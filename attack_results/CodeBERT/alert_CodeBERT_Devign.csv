Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
","static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *unit)

{

    int i;

    int dc = unit[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188.0,45.0,"block:unit,",81.0,0.0256337523460388,Greedy
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
","void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *sg;



    sg = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!sg) {

        return;

    }



    sg->base = base;

    sg->backing_file_str = g_strdup(backing_file_str);



    sg->on_error = on_error;

    sg->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, sg, sg->common.co, opaque);

    qemu_coroutine_enter(sg->common.co, sg);

}
",135.0,40.0,"s:sg,",114.0,0.0515534361203511,Greedy
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
","static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *aws = OMAP1_GPIO(dev);



    if (!aws->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, aws->omap1.handler, 16);

    sysbus_init_irq(sbd, &aws->omap1.irq);

    memory_region_init_io(&aws->iomem, OBJECT(aws), &omap_gpio_ops, &aws->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &aws->iomem);

    return 0;

}
",118.0,28.0,"s:aws,",76.0,0.0341768383979797,Greedy
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
","int ff_alloc_entries(AVCodecContext *raftcontext, int list)

{

    int io;



    if (raftcontext->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *np = raftcontext->internal->thread_ctx;

        np->thread_count  = raftcontext->thread_count;

        np->entries       = av_mallocz_array(list, sizeof(int));



        if (!np->entries) {

            return AVERROR(ENOMEM);

        }



        np->entries_count  = list;

        np->progress_mutex = av_malloc_array(np->thread_count, sizeof(pthread_mutex_t));

        np->progress_cond  = av_malloc_array(np->thread_count, sizeof(pthread_cond_t));



        for (io = 0; io < np->thread_count; io++) {

            pthread_mutex_init(&np->progress_mutex[io], NULL);

            pthread_cond_init(&np->progress_cond[io], NULL);

        }

    }



    return 0;

}
",156.0,36.0,"p:np,i:io,count:list,avctx:raftcontext,",232.0,0.1058229207992553,Greedy
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
","static void fpu_init (CPUMIPSState *ass, const mips_def_t *der)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        ass->fpus[i].fcr0 = der->CP1_fcr0;



    memcpy(&ass->active_fpu, &ass->fpus[0], sizeof(ass->active_fpu));

    if (ass->user_mode_only) {

        if (ass->CP0_Config1 & (1 << CP0C1_FP))

            ass->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (ass->active_fpu.fcr0 & (1 << FCR0_F64))

            ass->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",116.0,25.0,"def:der,env:ass,",133.0,0.0627169609069824,Greedy
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pipes, const uint8_t *pixelettes)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pipes; i++)

	{

		//FIXME slow?

		dst[0]= pixelettes[ src[i]*4+0 ];

		dst[1]= pixelettes[ src[i]*4+1 ];

		dst[2]= pixelettes[ src[i]*4+2 ];

		dst+= 3;

	}

}
",95.0,23.0,"num_pixels:num_pipes,palette:pixelettes,",110.0,0.0386831680933634,Greedy
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
","static AVStream * init_stream(AVFormatContext *sg)

{

    BinDemuxContext *con = sg->priv_data;

    AVStream *st = avformat_new_stream(sg, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!con->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, con->framerate.den, con->framerate.num);



    /* simulate tty display speed */

    con->chars_per_frame = FFMAX(av_q2d(st->time_base) * con->chars_per_frame, 1);



    return st;

}
",129.0,24.0,"bin:con,s:sg,",132.0,0.0443600296974182,Greedy
73,"static void device_initfn(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        qdev_hot_added = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {

        qdev_property_add_legacy(dev, prop, NULL);

        qdev_property_add_static(dev, prop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}
","static void device_initfn(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    Property *rop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        qdev_hot_added = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (rop = qdev_get_props(dev); rop && rop->name; rop++) {

        qdev_property_add_legacy(dev, rop, NULL);

        qdev_property_add_static(dev, rop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}
",116.0,32.0,"prop:rop,",89.0,0.0296531756718953,Greedy
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
","static void idiv64(uint64_t *ploom, uint64_t * phigg, int64_t beta)

{

    int sea, sf;

    sea = ((int64_t)* phigg < 0);

    if (sea)

        neg128(ploom,  phigg);

    sf = (beta < 0);

    if (sf)

        beta = -beta;

    div64(ploom,  phigg, beta);

    if (sea ^ sf)

        *ploom = - *ploom;

    if (sea)

        * phigg = - * phigg;

}
",95.0,28.0,"b:beta,sa:sea,phigh: phigg,plow:ploom,sb:sf,",291.0,0.0883970737457275,Greedy
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
","static void scsi_disk_realize(SCSIDevice *bug, Error **barr)

{

    DriveInfo * dinf;

    Error *localFer = NULL;



    if (!bug->conf.bs) {

        scsi_realize(bug, &localFer);

        assert(localFer);

        error_propagate(barr, localFer);

        return;

    }



     dinf = drive_get_by_blockdev(bug->conf.bs);

    if ( dinf->media_cd) {

        scsi_cd_realize(bug, barr);

    } else {

        scsi_hd_realize(bug, barr);

    }

}
",94.0,24.0,"local_err:localFer,dinfo: dinf,dev:bug,errp:barr,",198.0,0.0603449940681457,Greedy
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
","Object *object_resolve_path_component(Object *parent, const gchar *base)

{

    ObjectProperty *prop = object_property_find(parent, base, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",80.0,14.0,"part:base,",48.0,0.0197127938270568,Greedy
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
","static void vscsi_process_login(VSCSIState *state, vscsi_req *reg)

{

    union viosrp_iu *fi = &reg->fi;

    struct srp_login_rsp *rcp = &fi->srp.login_rsp;

    uint64_t tag = fi->srp.rcp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(fi, 0, sizeof(struct srp_login_rsp));

    rcp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rcp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rcp->tag = tag;

    rcp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rcp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rcp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(state, reg, sizeof(*rcp), VIOSRP_SRP_FORMAT);

}
",139.0,32.0,"req:reg,iu:fi,s:state,rsp:rcp,",233.0,0.0718870520591735,Greedy
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t diov, uint64_t lang)

{

    struct vhost_iotlb_msg ssg;



    ssg.diov = diov;

    ssg.size = lang;

    ssg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &ssg);

}
",51.0,14.0,"imsg:ssg,len:lang,iova:diov,",152.0,0.0542471885681152,Greedy
102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
","static void test_qemu_strtoull_overflow(void)

{

    const char *strings = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char * endpoint = &f;

    uint64_t res = 999;

    int rage;



    rage = qemu_strtoull(strings, & endpoint, 0, &res);



    g_assert_cmpint(rage, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert( endpoint == strings + strlen(strings));

}
",86.0,23.0,"err:rage,endptr: endpoint,str:strings,",145.0,0.0481871287027994,Greedy
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
","static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *stats;

    stats = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    stats->mem_offset = s->current_frame_offset;

    stats->mem_reg = s->frame_reg;

    stats->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",104.0,22.0,"ts:stats,",73.0,0.0355613311131795,Greedy
116,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
","FFTContext *av_fft_init(int numframes, int ninverse)

{

    FFTContext *local = av_malloc(sizeof(*local));



    if (s && localf_fft_init(s, nulocalframes, ninverse))

        av_freep(&local);



    return local;

}
",47.0,14.0,"nbits:numframes,inverse:ninverse,s:local,",482.0,0.2222718278566996,GA
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
","static void virtio_9p_device_unrealize(DeviceState *dev, Error **erP)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *z = VIRTIO_9P(dev);

    V9fsState *sq = &z->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(sq, erP);

}
",54.0,16.0,"v:z,s:sq,errp:erP,",119.0,0.0649913350741068,Greedy
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
","static int ipmovie_read_packet(AVFormatContext *private,

                               AVPacket * pqt)

{

    IPMVEContext *epmovie = (IPMVEContext *)private->priv_data;

    ByteIOContext *api = &private->api;

    int error;



    error = process_ipmovie_chunk(epmovie, api,  pqt);

    if (error == CHUNK_BAD)

        error = AVERROR_INVALIDDATA;

    else if (error == CHUNK_EOF)

        error = AVERROR_IO;

    else if (error == CHUNK_NOMEM)

        error = AVERROR_NOMEM;

    else

        error = 0;



    return error;

}
",89.0,27.0,"pb:api,pkt: pqt,ret:error,s:private,ipmovie:epmovie,",233.0,0.118794043858846,Greedy
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
","bool qemu_co_enter_next(CoQueue *menu)

{

    Coroutine *frame;



    frame = QSIMPLEQ_FIRST(&menu->entries);

    if (!frame) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&menu->entries, co_queue_next);

    qemu_coroutine_enter(frame, NULL);

    return true;

}
",53.0,12.0,"queue:menu,next:frame,",105.0,0.0511841336886088,Greedy
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
","static target_long monitor_get_reg(const struct MonitorDef *mode, int sel)

{

    CPUState *state = mon_get_cpu();

    if (!state)

        return 0;

    return state->regwptr[sel];

}
",39.0,8.0,"md:mode,env:state,val:sel,",125.0,0.0637789924939473,Greedy
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);



    if (id == -1) {

        *ptr = NULL;









    hubport = net_hub_port_find(id);

    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;
","static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *private = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(private, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *localener = NULL;

    int32_t id;

    NetClientState *bittype;



    if (private->realized) {

        qdev_prop_set_after_realize(private, name, errp);





    visit_type_int32(v, &id, name, &localener);

    if (localener) {

        error_propagate(errp, localener);



    if (id == -1) {

        *ptr = NULL;









    bittype = net_hub_port_find(id);

    if (!bittype) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = bittype;
",165.0,47.0,"local_err:localener,dev:private,peers_ptr:peers_ptr,hubport:bittype,",166.0,0.0890185674031575,Greedy
137,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
","int main(void)

{

    int cnb;

    Suite *s;

    SRunner *rg;



    s = qfloat_suite();

    rg = srunner_create(s);



    srunner_run_all(rg, CK_NORMAL);

    cnb = srunner_ntests_failed(rg);

    srunner_free(rg);



    return (cnb == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",61.0,20.0,"nf:cnb,sr:rg,",93.0,0.0560668071111043,Greedy
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong  ioga,

                                target_ulong Tcp)

{

    IOMMUTLBEntry seed;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = ( ioga - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"",  ioga);

        return H_PARAMETER;

    }



    tcet->table[index] = Tcp;



    seed.target_as = &address_space_memory,

    seed.iova =  ioga & page_mask;

    seed.translated_addr = Tcp & page_mask;

    seed.addr_mask = ~page_mask;

    seed.perm = spapr_tce_iommu_access_flags(Tcp);

    memory_region_notify_iommu(&tcet->iommu, seed);



    return H_SUCCESS;

}
",131.0,38.0,"entry:seed,tce:Tcp,ioba: ioga,",192.0,0.0929434935251871,Greedy
154,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
","static void gen_isel(DisasContext *gru)

{

    int  lOne,  l5;

    uint32_t bi = rC(gru->opcode);

    uint32_t sum;

    TCGv_i32 T2;



     lOne = gen_new_label();

     l5 = gen_new_label();



    sum = 0x08 >> (bi & 0x03);

    T2 = tcg_temp_new_i32();

    tcg_gen_andi_i32(T2, cpu_crf[bi >> 2], sum);

    tcg_gen_brcondi_i32(TCG_COND_EQ, T2, 0,  lOne);

    if (rA(gru->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(gru->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(gru->opcode)], cpu_gpr[rA(gru->opcode)]);

    tcg_gen_br( l5);

    gen_set_label( lOne);

    tcg_gen_mov_tl(cpu_gpr[rD(gru->opcode)], cpu_gpr[rB(gru->opcode)]);

    gen_set_label( l5);

    tcg_temp_free_i32(T2);

}
",177.0,54.0,"ctx:gru,mask:sum,l1: lOne,l2: l5,t0:T2,",261.0,0.1304465293884277,Greedy
156,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
","static int adpcm_decode_init(AVCodecContext * alcontext)

{

    ADPCMContext *arc = alcontext->priv_data;



    if(alcontext->channels > 2U){

        return -1;

    }



    arc->channel = 0;

    arc->status[0].predictor = arc->status[1].predictor = 0;

    arc->status[0].step_index = arc->status[1].step_index = 0;

    arc->status[0].step = arc->status[1].step = 0;



    switch(alcontext->codec->id) {

    case CODEC_ID_ADPCM_CT:

        arc->status[0].step = arc->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (alcontext->extradata && alcontext->extradata_size == 2 * 4) {

            arc->status[0].predictor = AV_RL32(alcontext->extradata);

            arc->status[1].predictor = AV_RL32(alcontext->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
",194.0,25.0,"c:arc,avctx:alcontext,",166.0,0.0819868365923563,Greedy
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtoll_whitespace(void)

{

    const char *i = ""  \t  "";

    char f = 'X';

    const char *adfd = &f;

    int64_t res = 999;

    int iter;



iter err = qemu_strtoll(i, &adfd, 0, &res);



    g_assert_cmpint(iter, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_asseradfdtr == i);

}
",81.0,19.0,"str:i,endptr:adfd,err:iter,",464.0,0.2236039400100708,GA
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
","static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *sa = bs->opaque;

    g_free(sa->pagetable);

#ifdef CACHE

    g_free(sa->pageentry_u8);

#endif



    migrate_del_blocker(sa->migration_blocker);

    error_free(sa->migration_blocker);

}
",49.0,13.0,"s:sa,",60.0,0.0385103821754455,Greedy
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
","void helper_store_fpcr (uint64_t vals)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((vals >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((vals >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",89.0,19.0,"val:vals,",48.0,0.0350764155387878,Greedy
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
","void qemu_system_wakeup_request(WakeupReason err)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << err))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &err);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",67.0,15.0,"reason:err,",61.0,0.0309102018674214,Greedy
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *hmt;



    /* accept both hex and decimal */

    hmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, hmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"fmt:hmt,",51.0,0.0282068252563476,Greedy
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
","static inline int cpu_gdb_index(CPUState *fc)

{

#if defined(CONFIG_USER_ONLY)

    return fc->host_tid;

#else

    return fc->cpu_index + 1;

#endif

}
",31.0,5.0,"cpu:fc,",46.0,0.0224095424016316,Greedy
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
","static inline int *DEC_UQUAD(int *ldst, unsigned idlex, unsigned comment)

{

    unsigned nz = idlex >> 12;



    ldst[0] = (idlex & 3) * (1 + (((int)comment >> 31) << 1));

    comment <<= nz & 1;

    nz >>= 1;

    ldst[1] = (idlex >> 2 & 3) * (1 + (((int)comment >> 31) << 1));

    comment <<= nz & 1;

    nz >>= 1;

    ldst[2] = (idlex >> 4 & 3) * (1 + (((int)comment >> 31) << 1));

    comment <<= nz & 1;

    nz >>= 1;

    ldst[3] = (idlex >> 6 & 3) * (1 + (((int)comment >> 31) << 1));



    return ldst + 4;

}
",178.0,28.0,"sign:comment,idx:idlex,dst:ldst,",209.0,0.0756713906923929,Greedy
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
","static void curl_multi_do(void *inc)

{

    BDRVCURLState *b = (BDRVCURLState *)inc;

    int ending;

    int er;



    if (!b->multi) {

        return;

    }



    do {

        er = curl_multi_socket_all(b->multi, &ending);

    } while(er == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(b);

}
",64.0,15.0,"r:er,s:b,running:ending,arg:inc,",209.0,0.0781439701716105,Greedy
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptouyvy)(const uint8_t *vsuc, const uint8_t *USroc, const uint8_t *wsrc, uint8_t *adsth,

                                         long width, long Height,

                                         long lumSTri, long chromSTro, long dblSTore)

{

    RENAME(yuvPlanartouyvy)(vsuc, USroc, wsrc, adsth, width, Height, lumSTri, chromSTro, dblSTore, 1);

}
",70.0,21.0,"ysrc:vsuc,usrc:USroc,vsrc:wsrc,dst:adsth,height:Height,lumStride:lumSTri,chromStride:chromSTro,dstStride:dblSTore,",386.0,0.1984224041302998,GA
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr opa,

    size_t vec)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!vec) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = vec;



    ventry->iov_base = cpu_physical_memory_map(opa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (vec != mapped_len)) {

        return false;

    }



    return true;

}
",122.0,28.0,"pa:opa,len:vec,",117.0,0.042765720685323,Greedy
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
","static int spawn_thread(void)

{

    pthread_attr_t cache;

    int ret;



    cur_Threadings++;

    idle_Threads++;



    pthread_attr_init(&cache);

    pthread_attr_setdetachstate(&cache, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &cache, aio_thread, NULL);

    pthread_attr_destroy(&cache);



    return ret;

}
",58.0,18.0,"attr:cache,idle_threads:idle_Threads,cur_threads:cur_Threadings,",101.0,0.0490188201268514,Greedy
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
","static CharDriverState *vc_init(const char *db, ChardevBackend *BACKend,

                                ChardevReturn *mem, Error **errP)

{

    return vc_handler(BACKend->u.vc, errP);

}
",37.0,8.0,"id:db,ret:mem,errp:errP,backend:BACKend,",103.0,0.0528187274932861,Greedy
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
","int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *pl;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    pl = &s->labels[idx];

    pl->has_value = 0;

    pl->u.first_reloc = NULL;

    return idx;

}
",67.0,16.0,"l:pl,",57.0,0.0294977903366088,Greedy
241,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
","void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector__sum,

                            int *cluster_nb_vector)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector__sum = sector_num;

        *cluster_nb_vector = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector__sum = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_vector = QEMU_ALIGN_UP(sector_num - *cluster_sector__sum +

                                            nb_sectors, c);

    }

}
",93.0,28.0,"cluster_nb_sectors:cluster_nb_vector,cluster_sector_num:cluster_sector__sum,",68.0,0.0306642174720764,Greedy
246,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
","int xen_config_dev_blk(DriveInfo *diff)

{

    char ize[256], bee[256];

    int vdev = 202 * 256 + 16 * diff->unit;

    int cdrom = diff->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *device    = cdrom ? ""r""     : ""w"";



    snprintf(diff->bdrv->device_name, sizeof(diff->bdrv->device_name),

	     ""xvd%c"", 'a' + diff->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  diff->unit, diff->bdrv->device_name, diff->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, ize, bee, sizeof(ize));



    /* frontend */

    xenstore_write_int(ize, ""virtual-device"",  vdev);

    xenstore_write_str(ize, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(bee, ""dev"",             diff->bdrv->device_name);

    xenstore_write_str(bee, ""type"",            ""file"");

    xenstore_write_str(bee, ""params"",          diff->bdrv->filename);

    xenstore_write_str(bee, ""mode"",            device);



    /* common stuff */

    return xen_config_dev_all(ize, bee);

}
",222.0,46.0,"disk:diff,be:bee,mode:device,fe:ize,",270.0,0.1065465172131856,Greedy
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
","static int get_uint16_equal(QEMUFile *file, void *ppf, size_t ffff)

{

    uint16_t *v = ppf;

    uint16_t v2;

    qemu_get_be16s(file, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",50.0,13.0,"v2:v2,f:file,pv:ppf,size:ffff,",114.0,0.0481067657470703,Greedy
276,"static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}
","static void hmp_migrate_status_cb(void *opacity)

{

    MigrationStatus *status = opacity;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}
",172.0,37.0,"opaque:opacity,",54.0,0.0306214928627014,Greedy
280,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
","static ModuleTypeList *find_type(module_init_type parent)

{

    ModuleTypeList *v;



    init_types();



    l v &init_type_list[parent];



    return v;

}
",29.0,8.0,"type:parent,l:v,",144.0,0.0823319156964619,GA
287,"void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))

{

    stream_printf(stream, ""Trace file \""%s\"" %s.\n"",

                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");

}
","void st_print_trace_file_status(FILE *socket, int (*stream_format)(FILE *socket, const char *fmt, ...))

{

    stream_format(socket, ""Trace file \""%s\"" %s.\n"",

                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");

}
",48.0,9.0,"stream:socket,stream_printf:stream_format,",69.0,0.0393739620844523,Greedy
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
","uint32_t div32(uint32_t *q_pt, uint64_t no, uint32_t day)

{

    *q_pt = no / day;

    return no % day;

}
",27.0,9.0,"den:day,q_ptr:q_pt,num:no,",122.0,0.0728281378746032,Greedy
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t exec, uint32_t shift)

{

    uint64_t txt;

    uint32_t use;



    shift &= 63;

    txt = (uint64_t)exec << 32 >> shift;

    use = txt >> 32;



    env->cc_c = (txt >> 31) & 1;

    env->cc_n = use;

    env->cc_z = use;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return use;

}
",92.0,24.0,"val:exec,result:use,temp:txt,",164.0,0.0809116005897521,Greedy
307,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
","void helper_tlb_update(uint32_t  Targ)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t padd;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	padd = cris_mmu_tlb_latest_update(env,  Targ);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", padd, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK,  Targ));

	tlb_flush_page(env, padd);

#endif

}
",80.0,23.0,"vaddr:padd,T0: Targ,",76.0,0.0441979527473449,Greedy
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
","static void patch_pcihp(int image, uint8_t *ssdt_pointers, uint32_t becess)

{

    ssdt_pointers[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(image >> 4);

    ssdt_pointers[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(image);

    ssdt_pointers[ACPI_PCIHP_OFFSET_ID] = image;

    ssdt_pointers[ACPI_PCIHP_OFFSET_ADR + 2] = image;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_pointers + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!becess) {

        memcpy(ssdt_pointers + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",91.0,26.0,"eject:becess,slot:image,ssdt_ptr:ssdt_pointers,",128.0,0.0742693980534871,Greedy
309,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
","static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *tmp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*mem0)[4] = tmp;

    int (*sum1)[4] = mem0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, mem0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &mem0[x]);

        }



        ssim += ssim_endn(mem0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",205.0,54.0,"temp:tmp,sum0:mem0,",100.0,0.0626078009605407,Greedy
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
","static void hScale8To15_c(SwsContext *cm, int16_t *dst, int ddrWeight, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int shapeLen)

{

    int i;

    for (i=0; i<ddrWeight; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<shapeLen; j++) {

            val += ((int)src[srcPos + j])*filter[shapeLen*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127.0,34.0,"filterSize:shapeLen,dstW:ddrWeight,c:cm,",132.0,0.0705521623293558,Greedy
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
","qemu_co_sendv_recvv(int sockedfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockedfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",126.0,31.0,"sockfd:sockedfd,",54.0,0.0364544868469238,Greedy
322,"static int mux_chr_can_read(void *opaque)

{

    CharDriverState *chr = opaque;

    MuxDriver *d = chr->opaque;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}
","static int mux_chr_can_read(void * opc)

{

    CharDriverState *chr =  opc;

    MuxDriver *fd = chr-> opc;



    if ((fd->prod - fd->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (fd->chr_can_read[chr->focus])

        return fd->chr_can_read[chr->focus](fd->ext_opaque[chr->focus]);

    return 0;

}
",75.0,15.0,"d:fd,opaque: opc,",112.0,0.0609508633613586,Greedy
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
","static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector * qicho, int nb_sectors,

                         BlockDriverCompletionFunc *db, void *opaque)

{

    BDRVRawState *services = bs->opaque;

    return paio_submit(bs, services->hfile, sector_num,  qicho, nb_sectors,

                       db, opaque, QEMU_AIO_READ);

}
",59.0,18.0,"qiov: qicho,bs:bs,cb:db,s:services,",159.0,0.0837172746658325,Greedy
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
","static void gen_compute_eflags_o(DisasContext *s, TCGv report)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(report, cpu_cc_src, 11);

    tcg_gen_andi_tl(report, report, 1);

}
",36.0,11.0,"reg:report,",65.0,0.0358180960019429,Greedy
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
","static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int fd)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",77.0,20.0,"flags:fd,",47.0,0.0293540755907694,Greedy
343,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;","static void bonito_ldma_writel(void *opaque, hwaddr oa,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *state = opaque;
    ((uint32_t *)(&state->bonldma))[oa/sizeof(uint32_t)] = val & 0xffffffff;",50.0,10.0,"s:state,addr:oa,",90.0,0.0459602753321329,Greedy
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
","static int64_t read_ts(char **comment, int *stage)

{

    int64_t type, port;



    if (sscanf(*comment, ""%""SCNd64"",%""SCNd64, &type, &port) == 2) {

        *comment += strcspn(*comment, ""\"""") + 1;

        *stage = port - type;

        return type;

    }

    return AV_NOPTS_VALUE;

}
",73.0,19.0,"line:comment,end:port,start:type,duration:stage,",193.0,0.0912315209706624,Greedy
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
","static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *key = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    key->init = raven_init;

    key->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    key->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    key->revision = 0x00;

    key->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",82.0,22.0,"k:key,",56.0,0.0348653356234232,Greedy
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
","static void gen_storeq_reg(DisasContext *ctx, int plower, int rthighest, TCGv_i64 alt)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, alt);

    store_reg(ctx, plower, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(alt, alt, 32);

    tcg_gen_trunc_i64_i32(tmp, alt);

    store_reg(ctx, rthighest, tmp);

}
",75.0,27.0,"rhigh:rthighest,val:alt,s:ctx,rlow:plower,",169.0,0.0976722041765848,Greedy
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int qio_channel_socket_dgram_sync(QIOChannelSocket *iioci,

                                  SocketAddressLegacy *remoteAddp,

                                  SocketAddressLegacy *remoteErrs,

                                  Error ** errP)

{

    int diff;



    trace_qio_channel_socket_dgram_sync(iioci, remoteAddp, remoteErrs);

    diff = socket_dgram(remoteErrs, remoteAddp,  errP);

    if (diff < 0) {

        trace_qio_channel_socket_dgram_fail(iioci);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(iioci, diff);

    if (qio_channel_socket_set_fd(iioci, diff,  errP) < 0) {

        close(diff);

        return -1;

    }



    return 0;

}
",94.0,27.0,"ioc:iioci,errp: errP,fd:diff,remoteAddr:remoteErrs,localAddr:remoteAddp,",279.0,0.1496806462605794,Greedy
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
","static void x86_cpuid_set_tsc_freq(Object *exec, Visitor *V, void *obatile,

                                   const char *name, Error **err)

{

    X86CPU *cow = X86_CPU(exec);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t media;



    visit_type_int(V, &media, name, err);

    if (error_is_set(err)) {

        return;

    }

    if (media < min || media > max) {

        error_set(err, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", media, min, max);

        return;

    }



    cow->env.tsc_khz = media / 1000;

}
",122.0,34.0,"errp:err,v:V,obj:exec,opaque:obatile,cpu:cow,value:media,",252.0,0.1211756070454915,Greedy
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
","static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *y = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(y);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
",56.0,17.0,"version_id:version_id,vdev:vdev,n:y,",110.0,0.0596736311912536,Greedy
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
","BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_peors, BdrvRequestFlags stats,

        BlockCompletionFunc *obb, void *compque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_peors, stats, compque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_peors,

                                 BDRV_REQ_ZERO_WRITE | stats,

                                 obb, compque, true);

}
",62.0,21.0,"opaque:compque,cb:obb,bs:bs,flags:stats,nb_sectors:nb_peors,",218.0,0.1086951255798339,Greedy
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
","static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *service = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(service->vdev);

    msix_reset(&service->pci_dev);

    service->flags = 0;

}
",46.0,12.0,"proxy:service,",65.0,0.0377739191055297,Greedy
403,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
","static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *od;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    od = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(od);



    qvirtio_pci_device_enable(od);

    qvirtio_reset(&od->vdev);

    qvirtio_set_acknowledge(&od->vdev);

    qvirtio_set_driver(&od->vdev);



    features = qvirtio_get_features(&od->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&od->vdev, features);



    qvirtio_set_driver_ok(&od->vdev);

}
",110.0,34.0,"dev:od,",90.0,0.0505702376365661,Greedy
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
","static void bdrv_password_cb(Monitor *conn, const char *patch, void *opaque)

{

    BlockDriverState *ba = opaque;

    int ret = 0;



    if (bdrv_set_key(ba, patch) != 0) {

        monitor_printf(conn, ""invalid password\n"");

        ret = -EPERM;

    }

    if (conn->password_completion_cb)

        conn->password_completion_cb(conn->password_opaque, ret);



    monitor_read_command(conn, 1);

}
",81.0,20.0,"mon:conn,bs:ba,password:patch,",156.0,0.076206362247467,Greedy
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mand, int vlan_id, const char *device)

{

    VLANState *vlas;

    VLANClientState *dev;



    vlas = qemu_find_vlan(vlan_id);



   for(dev = vlas->first_client; dev != NULL; dev = dev->next)

        if (!strcmp(dev->name, device))

            break;



    if (!dev) {

        monitor_printf(mand, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(dev);

}
",89.0,23.0,"vc:dev,vlan:vlas,mon:mand,",154.0,0.0792517900466918,Greedy
416,"void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);

    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);

    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
","void main_loop_wait(int notblock)

{

    fd_set rafdb, wfds, xfds;

    int mem, nfds;

    struct timeval json;

    int sleep;



    if (notblock)

        sleep = 0;

    else {

        sleep = qemu_calculate_timeout();

        qemu_bh_update_timeout(&sleep);

    }



    os_host_main_loop_wait(&sleep);



    json.tv_sec = sleep / 1000;

    json.tv_usec = (sleep % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rafdb);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rafdb, &wfds, &xfds);

    slirp_select_fill(&nfds, &rafdb, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    mem = select(nfds + 1, &rafdb, &wfds, &xfds, &json);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rafdb, &wfds, &xfds, mem);

    slirp_select_poll(&rafdb, &wfds, &xfds, (mem < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
",197.0,59.0,"tv:json,ret:mem,nonblocking:notblock,timeout:sleep,rfds:rafdb,",288.0,0.1533229271570841,Greedy
427,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
","static void i440fx_update_memory_mappings(PCII440FXState *session)

{

    int cli, mr;

    uint32_t sharm;

    bool smram__Enabled;



    memory_region_transaction_begin();

    update_pam(session, 0xf0000, 0x100000, (session->dev.config[I440FX_PAM] >> 4) & 3,

               &session->pam_regions[0]);

    for(cli = 0; cli < 12; cli++) {

        mr = (session->dev.config[(cli >> 1) + (I440FX_PAM + 1)] >> ((cli & 1) * 4)) & 3;

        update_pam(session, 0xc0000 + 0x4000 * cli, 0xc0000 + 0x4000 * (cli + 1), mr,

                   &session->pam_regions[cli+1]);

    }

    sharm = session->dev.config[I440FX_SMRAM];

    smram__Enabled = (session->smm_enabled && (sharm & 0x08)) || (sharm & 0x40);

    memory_region_set_enabled(&session->smram_region, !smram__Enabled);

    memory_region_transaction_commit();

}
",186.0,38.0,"smram_enabled:smram__Enabled,i:cli,r:mr,smram:sharm,d:session,",276.0,0.1496833006540934,Greedy
429,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
","static void control_to_network(RDMAControlHeader *form)

{

    form->type = htonl(form->type);

    form->len = htonl(form->len);

    form->repeat = htonl(form->repeat);

}
",43.0,11.0,"control:form,",69.0,0.0458842396736145,Greedy
439,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void spr_write_tbu (DisasContext *ctx, int Sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
",51.0,14.0,"sprn:Sprn,",23.0,0.0194042444229126,Greedy
444,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
","static void test_qemu_strtoull_full_negative(void)

{

    const char *res = "" \t -321"";

    uint64_t res = 999;

    int rar;



    rar = qemu_strtoull(res, NULL, 0, &res);



    g_assert_cmpint(rar, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",59.0,12.0,"err:rar,str:res,",84.0,0.0413014411926269,Greedy
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
","enum CodecID av_codec_get_id(const AVCodecTag *ks[4], unsigned int time)

{

    int v;

    fov(i=0v i<4 && ks[v]; v++){

        enum CodecID id= codec_get_id(ks[iv, time);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
",67.0,18.0,"tags:ks,tag:time,i:v,",474.0,0.2831369519233703,GA
464,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
","void object_property_add_bool(Object *node, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *pot = g_malloc0(sizeof(*pot));



    pot->get = get;

    pot->set = set;



    object_property_add(node, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        pot, errp);

}
",102.0,23.0,"obj:node,prop:pot,",119.0,0.0765516757965087,Greedy
465,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
","static inline int mirror(int vert, int gm){

    if     (vert<0) return -vert;

    else if(vert>gm) return 2*gm-vert;

    else         return vert;

}
",41.0,10.0,"v:vert,m:gm,",107.0,0.0570162653923034,Greedy
474,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
","static QmpInputVisitor *to_qiv(Visitor *s)

{

    return container_of(s, QmpInputVisitor, visitor);

}
",21.0,6.0,"v:s,",43.0,0.0333524386088053,Greedy
479,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
","static int usb_uhci_piix3_initfn(PCIDevice *diff)

{

    UHCIState *s sq DO_UPCAST(UHCIState, diff, diff);

    uint8_t *pcpci_conf ssq>diff.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(sq);

}
",53.0,17.0,"dev:diff,s:sq,pci_conf:pci_conf,",179.0,0.1525007645289103,GA
484,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    /* report success */
    return 0;","static int ipvideo_decode_block_opcode_0xD(IpvideoContext *sf, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&sf->stream_ptr);
            P[1] = bytestream2_get_byte(&sf->stream_ptr);
        memset(sf->pixel_ptr,     P[0], 4);
        memset(sf->pixel_ptr + 4, P[1], 4);
        sf->pixel_ptr += sf->stride;
    /* report success */
    return 0;",114.0,23.0,"s:sf,",92.0,0.0687280058860778,Greedy
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
","static void pred8x8_top_dc_rv40_c(uint8_t *src, int Stride){

    int pi;

    int dc0;



    dc0=0;

    for(pi=0;pi<8; pi++)

        dc0+= src[pi-Stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(pi=0; pi<8; pi++){

        ((uint32_t*)(src+pi*Stride))[0]=

        ((uint32_t*)(src+pi*Stride))[1]= dc0;

    }

}
",110.0,25.0,"stride:Stride,i:pi,",131.0,0.1067426522572835,Greedy
503,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
","void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **retoutclass)

{

    double d;

    char *tmp;

    FdMigrationState *s;

    const char *object = qdict_get_str(qdict, ""value"");



    d = strtod(object, &tmp);

    switch (*tmp) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
",129.0,27.0,"ptr:tmp,ret_data:retoutclass,value:object,",133.0,0.1120591600735982,Greedy
506,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)

{

    VirtQueueElement elem;

    VirtQueue *vq;



    vq = vser->c_ivq;

    if (!virtio_queue_ready(vq)) {

        return 0;

    }

    if (!virtqueue_pop(vq, &elem)) {

        return 0;

    }



    /* TODO: detect a buffer that's too short, set NEEDS_RESET */

    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);



    virtqueue_push(vq, &elem, len);

    virtio_notify(VIRTIO_DEVICE(vser), vq);

    return len;

}
","static size_t send_control_msg(VirtIOSerial *evcur, void *Buffer, size_t v)

{

    VirtQueueElement elements;

    VirtQueue *evbar;



    evbar = evcur->c_ivq;

    if (!virtio_queue_ready(evbar)) {

        return 0;

    }

    if (!virtqueue_pop(evbar, &elements)) {

        return 0;

    }



    /* TODO: detect a buffer that's too short, set NEEDS_RESET */

    iov_from_buf(elements.in_sg, elements.in_num, 0, Buffer, v);



    virtqueue_push(evbar, &elements, v);

    virtio_notify(VIRTIO_DEVICE(evcur), evbar);

    return v;

}
",99.0,27.0,"vq:evbar,elem:elements,buf:Buffer,len:v,vser:evcur,",261.0,0.1881088813145955,Greedy
509,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)

{

    q->pending++;

    set_bit(q->queue, n_IRQ);

}
","static inline void IRQ_setbit(IRQ_queue_t *quad, int n_IRQ)

{

    quad->ipadding++;

    set_bit(quad->queue, n_IRQ);

}
",28.0,7.0,"q:quad,pending:ipadding,",60.0,0.0512891729672749,Greedy
512,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
","static void vhost_log_stop(MemoryListener *listeners,

                           MemoryRegionSection *environment)

{

    /* FIXME: implement */

}
",14.0,3.0,"section:environment,listener:listeners,",49.0,0.0416583935419718,Greedy
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
","static int curl_sock_cb(CURL *curl, curl_socket_t feed, int action,

                        void *s, void *resp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, feed);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(feed, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(feed, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(feed, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(feed, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",108.0,29.0,"sp:resp,fd:feed,",109.0,0.0860464255015055,Greedy
519,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
","void ff_er_frame_start(ERContext *sf)

{

    if (!sf->avctx->err_recognition)

        return;



    memset(sf->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           sf->mb_stride * sf->mb_height * sizeof(uint8_t));

    sf->error_count    = 3 * sf->mb_num;

    sf->error_occurred = 0;

}
",62.0,13.0,"s:sf,",73.0,0.0572865764300028,Greedy
527,"static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext *mov = s->priv_data;

    int i, j;



    if (!mov->fragment_index_complete)

        return 0;



    for (i = 0; i < mov->fragment_index_count; i++) {

        if (mov->fragment_index_data[i]->track_id == st->id) {

            MOVFragmentIndex *index = index = mov->fragment_index_data[i];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }



    return 0;

}
","static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext * mocr = s->priv_data;

    int i, j;



    if (! mocr->fragment_index_complete)

        return 0;



    for (i = 0; i <  mocr->fragment_index_count; i++) {

        if ( mocr->fragment_index_data[i]->track_id == st->id) {

            MOVFragmentIndex *index = index =  mocr->fragment_index_data[i];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }



    return 0;

}
",153.0,33.0,"mov: mocr,",92.0,0.0693567792574564,Greedy
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
","static int mxf_read_track(MXFTrack *track, ByteIOContext *cp, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(cp);

        break;

    case 0x4804:

        get_buffer(cp, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(cp);

        track->edit_rate.num = get_be32(cp);

        break;

    case 0x4803:

        get_buffer(cp, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",99.0,20.0,"pb:cp,",71.0,0.0557582259178161,Greedy
531,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}
","static void decode0(GetByteContext *gz, RangeCoder *co, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = co->range * (uint64_t)cumFreq / total_freq;



    co->code1 += t + 1;

    co->range = co->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (co->range < TOP && bytestream2_get_bytes_left(gz) > 0) {

        unsigned byte = bytestream2_get_byte(gz);

        co->code = (co->code << 8) | byte;

        co->code1 <<= 8;

        co->range <<= 8;

    }

}
",121.0,30.0,"rc:co,gb:gz,",134.0,0.0936465620994567,Greedy
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
","static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *nv;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    nv = qmp_input_get_visitor(data->qiv);

    g_assert(nv != NULL);



    return nv;

}
",77.0,20.0,"v:nv,",68.0,0.0552754441897074,Greedy
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
","void blk_apply_root_state(BlockBackend *Blb, BlockDriverState *bid)

{

    bid->detect_zeroes = Blb->root_state.detect_zeroes;

}
",23.0,5.0,"bs:bid,blk:Blb,",69.0,0.0597924947738647,Greedy
557,"void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}
","void ff_h264_flush_change(H264Context *H)

{

    int i, j;



    H->next_outputed_poc = INT_MIN;

    H->prev_interlaced_frame = 1;

    idr(H);



    H->poc.prev_frame_num = -1;

    if (H->cur_pic_ptr) {

        H->cur_pic_ptr->reference = 0;

        for (j=i=0; H->delayed_pic[i]; i++)

            if (H->delayed_pic[i] != H->cur_pic_ptr)

                H->delayed_pic[j++] = H->delayed_pic[i];

        H->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(H, &H->last_pic_for_ec);



    H->first_field = 0;

    ff_h264_sei_uninit(&H->sei);

    H->recovery_frame = -1;

    H->frame_recovered = 0;

    H->current_slice = 0;

    H->mmco_reset = 1;

    for (i = 0; i < H->nb_slice_ctx; i++)

        H->slice_ctx[i].list_count = 0;

}
",184.0,42.0,"h:H,",105.0,0.0657201369603475,Greedy
560,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
","static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int gi;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(gi = 0; gi < 4; gi++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188.0,45.0,"i:gi,",90.0,0.0632150093714396,Greedy
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int strided, int mode, int ra)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-strided] + 53*src[0] + 18*src[strided] - 3*src[strided*2] + 32 - ra) >> 6;

    case 2: // 1/2 shift

        return (-src[-strided] + 9*src[0] + 9*src[strided] - src[strided*2] + 8 - ra) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-strided] + 18*src[0] + 53*src[strided] - 4*src[strided*2] + 32 - ra) >> 6;

    }

    return 0; //should not occur

}
",165.0,32.0,"r:ra,stride:strided,",148.0,0.0895505825678507,Greedy
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int IDx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    IDx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[IDx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[IDx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + IDx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + IDx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
",171.0,38.0,"idx:IDx,",82.0,0.0610057830810546,Greedy
563,"static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    gen_a64_set_pc_im(s->pc - offset);

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}
","static void gen_exception_insn(DisasContext *your, int cmp, int excp)

{

    gen_a64_set_pc_im(your->pc - cmp);

    gen_exception(excp);

    your->is_jmp = DISAS_JUMP;

}
",36.0,11.0,"s:your,offset:cmp,",97.0,0.0591558098793029,Greedy
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
","static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *o = pv;

    qemu_get_sbe64s(f, o);

    return 0;

}
",33.0,9.0,"v:o,",46.0,0.0281072576840718,Greedy
573,"static int piix4_initfn(PCIDevice *dev)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&d->dev.qdev);



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->dev;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
","static int piix4_initfn(PCIDevice *err)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, err, err);

    uint8_t *pci_config;



    isa_bus_new(&d->err.qdev);



    pci_config = d->err.config;

    pci_config_set_vendor_id(pci_config, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_config, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_config, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->err;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
",83.0,26.0,"dev:err,pci_conf:pci_config,",104.0,0.0662270824114481,Greedy
574,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        dst += stride;

        src += 8;

    }



    memset(_src, 0, sizeof(dctcoef) * 64);

}
","static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t * _dist, int Strided)

{

    int pixel;

    pixel *dst = (pixel *) _dst;

    dctcoef *support = (dctcoef *)  _dist;

    Strided /= sizeof(pixel);



    for (pixel = 0; pixel < 8; pixel++) {

        dst[0] += support[0];

        dst[1] += support[1];

        dst[2] += support[2];

        dst[3] += support[3];

        dst[4] += support[4];

        dst[5] += support[5];

        dst[6] += support[6];

        dst[7] += support[7];



        dst += Strided;

        support += 8;

    }



    memset( _dist, 0, sizeof(dctcoef) * 64);

}
",167.0,36.0,"stride:Strided,i:pixel,_src: _dist,src:support,",209.0,0.1238220373789469,Greedy
576,"void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && size > ts->cfg.op_size) {

        units = (double) size / ts->cfg.op_size;

    }



    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (is_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}
","void throttle_account(ThrottleState *ts, bool as_write, uint64_t SIZE)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && SIZE > ts->cfg.op_size) {

        units = (double) SIZE / ts->cfg.op_size;

    }



    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += SIZE;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (as_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += SIZE;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += SIZE;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}
",138.0,30.0,"is_write:as_write,size:SIZE,",93.0,0.0603112419446309,Greedy
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
","static void gen_addq_lo(DisasContext *s, TCGv_i64 serv, int rcflow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rcflow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(serv, serv, tmp);

    tcg_temp_free_i64(tmp);

}
",63.0,23.0,"rlow:rcflow,val:serv,",86.0,0.0602981130282084,Greedy
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
","static void sd_reset(SDState *sim, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t ection;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &ection);

    } else {

        ection = 0;

    }

    size = ection << 9;



    ection = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sim->state = sd_idle_state;

    sim->rca = 0x0000;

    sd_set_ocr(sim);

    sd_set_scr(sim);

    sd_set_cid(sim);

    sd_set_csd(sim, size);

    sd_set_cardstatus(sim);

    sd_set_sdstatus(sim);



    sim->bdrv = bdrv;



    if (sim->wp_groups)

        g_free(sim->wp_groups);

    sim->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sim->wp_groups = (int *) g_malloc0(sizeof(int) * ection);

    memset(sim->function_group, 0, sizeof(int) * 6);

    sim->erase_start = 0;

    sim->erase_end = 0;

    sim->size = size;

    sim->blk_len = 0x200;

    sim->pwd_len = 0;

    sim->expecting_acmd = 0;

}
",209.0,54.0,"sd:sim,sect:ection,",172.0,0.0981105128924051,Greedy
605,"static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
","static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int der;



    der = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(der, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
",60.0,12.0,"err:der,",50.0,0.0358000675837198,Greedy
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
","static inline void gen_st16(TCGv play, TCGv addr, int index)

{

    tcg_gen_qemu_st16(play, addr, index);

    dead_tmp(play);

}
",30.0,10.0,"val:play,",58.0,0.042838176091512,Greedy
613,"static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
","static void q35_host_class_init(ObjectClass *oklasses, void *parent)

{

    DeviceClass *dc = DEVICE_CLASS(oklasses);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(oklasses);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
",72.0,20.0,"klass:oklasses,data:parent,",68.0,0.0641777118047078,Greedy
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
","static void h261_v_loop_filter_c(uint8_t *route,uint8_t *gz, int etrider){

    int i,v,data,yz;

    int err;

    for(i=0; i<8; i++){

        for(v=1; v<7; v++){

            data = v * etrider + i;

            yz = v * 8 + i;

            err = (int)gz[yz-1*8] + ((int)(gz[yz+0*8]) * 2) + (int)gz[yz+1*8];

            err +=2;

            err >>=2;

            route[data] = (uint8_t)err;

        }

    }

}
",137.0,34.0,"stride:etrider,src:gz,dest:route,xy:data,res:err,j:v,",301.0,0.223416006565094,Greedy
620,"static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}
","static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } testing_ases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; testing_ases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(testing_ases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == testing_ases[i].decoded);

        if (testing_ases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), testing_ases[i].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}
",191.0,37.0,"test_cases:testing_ases,",98.0,0.0754798372586568,Greedy
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
","static inline void RENAME(yv12touyvy)(const uint8_t *iesource, const uint8_t * usource, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(iesource,  usource, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
",72.0,21.0,"ysrc:iesource,dst:dst,usrc: usource,",89.0,0.0627624829610188,Greedy
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}
","static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *reg)

{

    ASFContext *psf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, format, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        format    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, format, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, psf->offset, size);

    return 0;

}
",181.0,58.0,"asf:psf,type:format,g:reg,",145.0,0.1230334560076395,Greedy
634,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
","CPUArchState *cpu_copy(CPUArchState *ctx)

{

    CPUState *cpu = ENV_GET_CPU(ctx);

    CPUState *newjcpu = cpu_init(cpu_model);

    CPUArchState *newfenv = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wordpress;



    /* Reset non arch specific state */

    cpu_reset(newjcpu);



    memcpy(newfenv, ctx, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(newjcpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wordpress, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(newjcpu, wordpress->vaddr, wordpress->len, wordpress->flags, NULL);

    }



    return newfenv;

}
",142.0,40.0,"new_cpu:newjcpu,new_env:newfenv,env:ctx,bp:bp,wp:wordpress,",236.0,0.1865655104319254,Greedy
641,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
","void helper_single_step(CPUX86State *state)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(state, 1);

    state->dr[6] |= DR6_BS;

#endif

    raise_exception(state, EXCP01_DB);

}
",35.0,10.0,"env:state,",59.0,0.0465612689654032,Greedy
645,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};","static void xen_pci_passthrough_class_init(ObjectClass *class, void *info)

{

    DeviceClass *dc = DEVICE_CLASS(class);

    PCIDeviceClass *self = PCI_DEVICE_CLASS(class);



    self->realize = xen_pt_realize;

    self->exit = xen_pt_unregister_device;

    self->config_read = xen_pt_pci_read_config;

    self->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};",79.0,23.0,"klass:class,data:info,k:self,",117.0,0.0878568490346272,Greedy
660,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}
","static int vhost_user_start(VhostUserState *r)

{

    VhostNetOptions groups;



    if (vhost_user_running(r)) {

        return 0;

    }



    groups.backend_type = VHOST_BACKEND_TYPE_USER;

    groups.net_backend = &r->nc;

    groups.opaque = r->chr;



    r->vhost_net = vhost_net_init(&groups);



    return vhost_user_running(r) ? 0 : -1;

}
",68.0,16.0,"s:r,options:groups,",124.0,0.0948437293370564,Greedy
671,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
","static void stream_close(VideoState *isi)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    isi->abort_request = 1;

    SDL_WaitThread(isi->read_tid, NULL);

    SDL_WaitThread(isi->refresh_tid, NULL);

    packet_queue_destroy(&isi->videoq);

    packet_queue_destroy(&isi->audioq);

    packet_queue_destroy(&isi->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &isi->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(isi->pictq_mutex);

    SDL_DestroyCond(isi->pictq_cond);

    SDL_DestroyMutex(isi->subpq_mutex);

    SDL_DestroyCond(isi->subpq_cond);

    SDL_DestroyCond(isi->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(isi->img_convert_ctx);

#endif

    av_free(isi);

}
",175.0,44.0,"is:isi,",105.0,0.0876517653465271,Greedy
673,"static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
","static void qpa_fini_out (HWVoiceOut *hp)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hp;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
",107.0,26.0,"hw:hp,",54.0,0.0467276612917582,Greedy
674,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
","static int scsi_device_init(SCSIDevice *sync)

{

    SCSIDeviceClass *sc sqSCSI_DEVICE_GET_CLASS(sync);

    if (sq->init) {

        return sc-sqnit(sync);

    }

    return 0;

}
",38.0,8.0,"s:sync,sc:sq,",150.0,0.1163570761680603,GA
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
","static int get_buffer_sao(HEVCContext *s, AVFrame *scene, const HEVCSPS *sps)

{

    int ret, shift;



    scene->width  = s->avctx->width  + 2;

    scene->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, scene, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (shift = 0; scene->data[shift]; shift++) {

        int offset = scene->linesize[shift] + (1 << sps->pixel_shift);

        scene->data[shift] += offset;

    }

    scene->width  = s->avctx->width;

    scene->height = s->avctx->height;



    return 0;

}
",138.0,31.0,"i:shift,frame:scene,",164.0,0.1139695604642232,Greedy
686,"int MP3lame_encode_frame(AVCodecContext *avctx,

                     unsigned char *frame, int buf_size, void *data)

{

	Mp3AudioContext *s = avctx->priv_data;

	int num, i;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X\n"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (s->stereo) {

		num = lame_encode_buffer_interleaved(s->gfp, data,

			MPA_FRAME_SIZE, frame, buf_size);

	} else {

		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,

			frame, buf_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d\n"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return num;

}
","int MP3lame_encode_frame(AVCodecContext *avctx,

                     unsigned char *image, int buf_size, void *result)

{

	Mp3AudioContext *aws = avctx->priv_data;

	int x, in;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X\n"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (aws->stereo) {

		x = lame_encode_buffer_interleaved(aws->gfp, result,

			MPA_FRAME_SIZE, image, buf_size);

	} else {

		x = lame_encode_buffer(aws->gfp, result, result, MPA_FRAME_SIZE,

			image, buf_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d\n"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return x;

}
",84.0,26.0,"data:result,num:x,s:aws,frame:image,i:in,",245.0,0.1668028672536214,Greedy
709,"static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
","static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, ch;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    ch = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * ch));

    t1 = tcg_const_i32(1 << ch);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
",166.0,48.0,"sh:ch,",77.0,0.0460565408070882,Greedy
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}
","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bid, int64_t sector_num,

                                 QEMUIOVector *diov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void * opec)

{

    BlockDriver *drv = bid->drv;

    BlockDriverAIOCB *len;



    trace_bdrv_aio_readv(bid, sector_num, nb_sectors,  opec);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bid, sector_num, nb_sectors))

        return NULL;



    len = drv->bdrv_aio_readv(bid, sector_num, diov, nb_sectors,

                              cb,  opec);



    if (len) {

	/* Update stats even though technically transfer has not happened. */

	bid->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bid->rd_bytes ++;

    }



    return len;

}
",117.0,34.0,"ret:len,qiov:diov,rd_ops:rd_bytes,bs:bid,opaque: opec,",224.0,0.1594344655672709,Greedy
717,"static void migrate_set_downtime(QTestState *who, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(who, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);

}
","static void migrate_set_downtime(QTestState *someone, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(someone, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);

}
",65.0,19.0,"who:someone,",58.0,0.0474792997042338,Greedy
724,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
","int qdev_prop_check_globals(void)

{

    GList *b;

    int ret = 0;



    for (b = global_props; b; b = b->next) {

        GlobalProperty *prop = b->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
",162.0,37.0,"l:b,",79.0,0.0486359119415283,Greedy
735,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
","static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *in_buf = outlink->in_buf;



    outlink->in_buf = NULL;

    ff_start_frame(outlink, in_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, in_buf);

    ff_draw_slice(outlink, 0, in_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
",93.0,23.0,"out_buf:in_buf,",81.0,0.05504017273585,Greedy
736,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
","void av_register_output_format(AVOutputFormat *xml)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = xml;

    xml->next = NULL;

}
",45.0,10.0,"format:xml,",59.0,0.046959368387858,Greedy
738,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
","AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int arms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, arms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
",61.0,16.0,"perms:arms,",44.0,0.0399496992429097,Greedy
747,"QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    qstring->string[qstring->length] = 0;



    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}
","QString *qstring_from_substr(const char *br, int init, int begin)

{

    QString *qqstring;



    qqstring = g_malloc(sizeof(*qqstring));



    qqstring->length = begin - init + 1;

    qqstring->capacity = qqstring->length;



    qqstring->string = g_malloc(qqstring->capacity + 1);

    memcpy(qqstring->string, br + init, qqstring->length);

    qqstring->string[qqstring->length] = 0;



    QOBJECT_INIT(qqstring, &qstring_type);



    return qqstring;

}
",100.0,27.0,"str:br,start:init,end:begin,qstring:qqstring,",264.0,0.2126448472340901,Greedy
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
","static int get_packetheader(NUTContext *conn, ByteIOContext *mac, int padding_length, int calculate_checksum)

{

    int64_t error, false, last_len;

    error= url_ftell(mac) - padding_length;



    if(error != conn->packet_start + conn->written_packet_size){

        av_log(conn->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(mac, update_adler32, 0);



    false= get_v(mac);

    last_len= get_v(mac);

    if(conn->written_packet_size != last_len){

        av_log(conn->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", conn->written_packet_size, last_len, error);

        return -1;

    }



    conn->last_packet_start = conn->packet_start;

    conn->packet_start = error;

    conn->written_packet_size= false;



    return false;

}
",150.0,43.0,"start:error,last_size:last_len,nut:conn,prefix_length:padding_length,bc:mac,size:false,",312.0,0.1711134473482767,Greedy
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
","static int get_cpsr(QEMUFile *i, void *opaque, size_t _)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(i);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",95.0,26.0,"f:i,size:_,",72.0,0.0511759956677754,Greedy
784,"void esp_init(target_phys_addr_t espaddr, int it_shift,

              ESPDMAMemoryReadWriteFunc dma_memory_read,

              ESPDMAMemoryReadWriteFunc dma_memory_write,

              void *dma_opaque, qemu_irq irq, qemu_irq *reset,

              qemu_irq *dma_enable)

{

    DeviceState *dev;

    SysBusDevice *s;

    SysBusESPState *sysbus;

    ESPState *esp;



    dev = qdev_create(NULL, ""esp"");

    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);

    esp = &sysbus->esp;

    esp->dma_memory_read = dma_memory_read;

    esp->dma_memory_write = dma_memory_write;

    esp->dma_opaque = dma_opaque;

    sysbus->it_shift = it_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    esp->dma_enabled = 1;

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, espaddr);

    *reset = qdev_get_gpio_in(dev, 0);

    *dma_enable = qdev_get_gpio_in(dev, 1);

}
","void esp_init(target_phys_addr_t espaddr, int bit_shift,

              ESPDMAMemoryReadWriteFunc dma_memory_read,

              ESPDMAMemoryReadWriteFunc dma_memoryread,

              void *dma_opaque, qemu_irq  irqs, qemu_irq *reset,

              qemu_irq *dma_enable)

{

    DeviceState *dev;

    SysBusDevice *s;

    SysBusESPState *systemusb;

    ESPState *esp;



    dev = qdev_create(NULL, ""esp"");

    systemusb = DO_UPCAST(SysBusESPState, busdev.qdev, dev);

    esp = &systemusb->esp;

    esp->dma_memory_read = dma_memory_read;

    esp->dma_memoryread = dma_memoryread;

    esp->dma_opaque = dma_opaque;

    systemusb->bit_shift = bit_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    esp->dma_enabled = 1;

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0,  irqs);

    sysbus_mmio_map(s, 0, espaddr);

    *reset = qdev_get_gpio_in(dev, 0);

    *dma_enable = qdev_get_gpio_in(dev, 1);

}
",158.0,48.0,"dma_memory_write:dma_memoryread,it_shift:bit_shift,sysbus:systemusb,irq: irqs,",169.0,0.1196429332097371,Greedy
789,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
","static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *ot = &c->streams[i];

        if (ot->out)

            avio_close(ot->out);

        ot->out = NULL;

        if (ot->ctx && ot->ctx_inited)

            av_write_trailer(ot->ctx);

        if (ot->ctx && ot->ctx->pb)

            av_free(ot->ctx->pb);

        if (ot->ctx)

            avformat_free_context(ot->ctx);

        av_free(ot->metadata);

        for (j = 0; j < ot->nb_extra_packets; j++)

            av_free(ot->extra_packets[j]);

        for (j = 0; j < ot->nb_fragments; j++)

            av_free(ot->fragments[j]);

        av_free(ot->fragments);

    }

    av_freep(&c->streams);

}
",203.0,49.0,"os:ot,",107.0,0.063855222860972,Greedy
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
","yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *bag250  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (bag250[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
",232.0,60.0,"buf0:bag250,",48.0,0.0363036433855692,Greedy
791,"static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *bus;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (dev->num_child_bus) {

        bus = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(bus));

    }

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }

}
","static void device_unparent(Object *ctx)

{

    DeviceState *g = DEVICE(ctx);

    BusState *id;



    if (g->realized) {

        object_property_set_bool(ctx, false, ""realized"", NULL);

    }

    while (g->num_child_bus) {

        id = QLIST_FIRST(&g->child_bus);

        object_unparent(OBJECT(id));

    }

    if (g->parent_bus) {

        bus_remove_child(g->parent_bus, g);

        object_unref(OBJECT(g->parent_bus));

        g->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (g->pending_deleted_event) {

        g_assert(g->canonical_path);



        qapi_event_send_device_deleted(!!g->id, g->id, g->canonical_path,

                                       &error_abort);

        g_free(g->canonical_path);

        g->canonical_path = NULL;

    }

}
",150.0,35.0,"bus:id,obj:ctx,dev:g,",193.0,0.1116959929466247,Greedy
792,"QBool *qbool_from_bool(bool value)

{

    QBool *qb;



    qb = g_malloc(sizeof(*qb));

    qb->value = value;

    QOBJECT_INIT(qb, &qbool_type);



    return qb;

}
","QBool *qbool_from_bool(bool v)

{

    QBool *quf;



    quf = g_malloc(sizeof(*quf));

    qb->v qufv;

    QOBJECT_INIT(quf, &qbool_type);



    return quf;

}
",41.0,12.0,"value:v,qb:quf,",255.0,0.1599982539812723,GA
797,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));","void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecc, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecc)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",122.0,39.0,"ecn:ecc,",41.0,0.0345048308372497,Greedy
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *buf, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                buf, buf_size);

        avctx->frame_number++;

    }else

        ret= 0;

    return ret;

}
","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *Samps,

                         int *frame_size_ptr,

                         uint8_t *wav, int buf_size)

{

    int sb;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        sb = avctx->codec->decode(avctx, Samps, frame_size_ptr,

                                wav, buf_size);

        avctx->frame_number++;

    }else

        sb= 0;

    return sb;

}
",80.0,21.0,"samples:Samps,ret:sb,buf:wav,",132.0,0.0925419370333353,Greedy
813,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)

{

    S390CPU *cpu;

    Error *err = NULL;



    cpu = cpu_s390x_create(cpu_model, &err);

    if (err != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);



out:

    if (err) {

        error_propagate(errp, err);

        object_unref(OBJECT(cpu));

        cpu = NULL;

    }

    return cpu;

}
","S390CPU *s390x_new_cpu(const char *core_models, uint32_t  core_ident, Error **rP)

{

    S390CPU *parent;

    Error *norm = NULL;



    parent = cpu_s390x_create(core_models, &norm);

    if (norm != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(parent),  core_ident, ""core-id"", &norm);

    if (norm != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(parent), true, ""realized"", &norm);



out:

    if (norm) {

        error_propagate(rP, norm);

        object_unref(OBJECT(parent));

        parent = NULL;

    }

    return parent;

}
",123.0,30.0,"err:norm,cpu_model:core_models,core_id: core_ident,errp:rP,cpu:parent,",213.0,0.1216129700342814,Greedy
815,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)

{

    int n=0, x, y, i;



    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;

                tempData->cel_evals[n++].sourceY = y + (i&2)*4;

            }

}
","static void create_cel_evals(RoqContext *enc, RoqTempdata *TempModule)

{

    int n=0, x, y, i;



    TempModule->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                TempModule->cel_evals[n  ].sourceX = x + (i&1)*8;

                TempModule->cel_evals[n++].sourceY = y + (i&2)*4;

            }

}
",133.0,31.0,"tempData:TempModule,",63.0,0.0385149558385213,Greedy
819,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    struct nand_state_t *s = opaque;

    uint32_t r;

    int rdy;



    r = nand_getio(s->nand);

    nand_getpins(s->nand, &rdy);

    s->rdy = rdy;



    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));

    return r;

}
","static uint64_t nand_read(void *phpifice, target_phys_addr_t mac, unsigned  w)

{

    struct nand_state_t *services = phpifice;

    uint32_t r;

    int rdy;



    r = nand_getio(services->nand);

    nand_getpins(services->nand, &rdy);

    services->rdy = rdy;



    DNAND(printf(""%s addr=%x r=%x\n"", __func__, mac, r));

    return r;

}
",73.0,22.0,"opaque:phpifice,size: w,s:services,addr:mac,",167.0,0.0954840064048767,Greedy
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_put_8s(f, v);

}
","static void put_uint8(QEMUFile *file, void *pf, size_t fff)

{

    uint8_t *u = pf;

    qemu_put_8s(file, u);

}
",30.0,9.0,"size:fff,f:file,v:u,pv:pf,",132.0,0.0849788586298624,Greedy
835,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
","bool timerlist_expired(QEMUTimerList *timerlisttest)

{

    int64_t expirefmoney;



    if (!atomic_read(&timerlisttest->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timerlisttest->active_timers_lock);

    if (!timerlisttest->active_timers) {

        qemu_mutex_unlock(&timerlisttest->active_timers_lock);

        return false;

    }

    expirefmoney = timerlisttest->active_timers->expirefmoney;

    qemu_mutex_unlock(&timerlisttest->active_timers_lock);



    return expirefmoney < qemu_clock_get_ns(timerlisttest->clock->type);

}
",84.0,17.0,"expire_time:expirefmoney,timer_list:timerlisttest,",191.0,0.0855610926946004,Greedy
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
","static uint32_t dcr_read_pob (void *depque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = depque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
",71.0,19.0,"opaque:depque,",46.0,0.0331365386644999,Greedy
848,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *pic, *next;



    for (pic = ctx->pic_start; pic; pic = next) {

        next = pic->next;

        vaapi_encode_free(avctx, pic);

    }



    if (ctx->va_context != VA_INVALID_ID) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = VA_INVALID_ID;

    }



    if (ctx->va_config != VA_INVALID_ID) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = VA_INVALID_ID;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    av_buffer_unref(&ctx->recon_frames_ref);

    av_buffer_unref(&ctx->input_frames_ref);

    av_buffer_unref(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}
","av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *concept = avctx->priv_data;

    VAAPIEncodePicture *pic, *next;



    for (pic = concept->pic_start; pic; pic = next) {

        next = pic->next;

        vaapi_encode_free(avctx, pic);

    }



    if (concept->va_context != VA_INVALID_ID) {

        vaDestroyContext(concept->hwctx->display, concept->va_context);

        concept->va_context = VA_INVALID_ID;

    }



    if (concept->va_config != VA_INVALID_ID) {

        vaDestroyConfig(concept->hwctx->display, concept->va_config);

        concept->va_config = VA_INVALID_ID;

    }



    if (concept->codec->close)

        concept->codec->close(avctx);



    av_buffer_pool_uninit(&concept->output_buffer_pool);



    av_freep(&concept->codec_sequence_params);

    av_freep(&concept->codec_picture_params);



    av_buffer_unref(&concept->recon_frames_ref);

    av_buffer_unref(&concept->input_frames_ref);

    av_buffer_unref(&concept->device_ref);



    av_freep(&concept->priv_data);



    return 0;

}
",188.0,48.0,"ctx:concept,",113.0,0.0755311012268066,Greedy
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}
","static ssize_t socket_read(int sockfd, void *back, size_t count)

{

    ssize_t intvals, total = 0;



    while (count) {

        intvals = read(sockfd, back, count);

        if (intvals == 0) {

            return -EIO;

        }

        if (intvals < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        count -= intvals;

        back += intvals;

        total += intvals;

    }

    return total;

}
",89.0,25.0,"retval:intvals,buff:back,size:count,",184.0,0.1197679082552592,Greedy
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
","static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *mod = VIRTIO_RNG_S390(s390_dev);

    DeviceState *uvdb = DEVICE(&mod->uvdb);



    qdev_set_parent_bus(uvdb, BUS(&s390_dev->bus));

    if (qdev_init(uvdb) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(mod),

                             OBJECT(mod->uvdb.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(uvdb));

}
",93.0,23.0,"dev:mod,vdev:uvdb,",126.0,0.0829128662745157,Greedy
859,"static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)

{

    BDRVQEDState *s = acb_to_s(acb);



    /* Free resources */

    qemu_iovec_destroy(&acb->cur_qiov);

    qed_unref_l2_cache_entry(acb->request.l2_table);



    /* Free the buffer we may have allocated for zero writes */

    if (acb->flags & QED_AIOCB_ZERO) {

        qemu_vfree(acb->qiov->iov[0].iov_base);

        acb->qiov->iov[0].iov_base = NULL;

    }



    /* Start next allocating write request waiting behind this one.  Note that

     * requests enqueue themselves when they first hit an unallocated cluster

     * but they wait until the entire request is finished before waking up the

     * next request in the queue.  This ensures that we don't cycle through

     * requests multiple times but rather finish one at a time completely.

     */

    if (acb == s->allocating_acb) {

        s->allocating_acb = NULL;

        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {

            qemu_co_enter_next(&s->allocating_write_reqs);

        } else if (s->header.features & QED_F_NEED_CHECK) {

            qed_start_need_check_timer(s);

        }

    }

}
","static void coroutine_fn qed_aio_complete(QEDAIOCB *aitbb)

{

    BDRVQEDState *rows = acb_to_s(aitbb);



    /* Free resources */

    qemu_iovec_destroy(&aitbb->cur_qiov);

    qed_unref_l2_cache_entry(aitbb->request.l2_table);



    /* Free the buffer we may have allocated for zero writes */

    if (aitbb->flags & QED_AIOCB_ZERO) {

        qemu_vfree(aitbb->qiov->iov[0].iov_base);

        aitbb->qiov->iov[0].iov_base = NULL;

    }



    /* Start next allocating write request waiting behind this one.  Note that

     * requests enqueue themselves when they first hit an unallocated cluster

     * but they wait until the entire request is finished before waking up the

     * next request in the queue.  This ensures that we don't cycle through

     * requests multiple times but rather finish one at a time completely.

     */

    if (aitbb == rows->allocating_acb) {

        rows->allocating_acb = NULL;

        if (!qemu_co_queue_empty(&rows->allocating_write_reqs)) {

            qemu_co_enter_next(&rows->allocating_write_reqs);

        } else if (rows->header.features & QED_F_NEED_CHECK) {

            qed_start_need_check_timer(rows);

        }

    }

}
",130.0,26.0,"acb:aitbb,s:rows,",171.0,0.1053065538406372,Greedy
869,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
","static int write_fragments(struct Tracks *tracks, int  start_initial,

                           AVIOContext *str)

{

    char  dirdir[100], filename[500];

    int i, j;



    for (i =  start_initial; i < tracks->nb_tracks; i++) {

        struct Track *rank = tracks->tracks[i];

        const char *type    = rank->is_video ? ""video"" : ""audio"";

        snprintf( dirdir, sizeof( dirdir), ""QualityLevels(%d)"", rank->bitrate);

        mkdir( dirdir, 0777);

        for (j = 0; j < rank->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                      dirdir, type, rank->offsets[j].time);

            avio_seek(str, rank->offsets[j].offset, SEEK_SET);

            write_fragment(filename, str);

        }

    }

    return 0;

}
",174.0,44.0,"dirname: dirdir,track:rank,start_index: start_initial,in:str,",203.0,0.1172786037127176,Greedy
872,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,

                                 unsigned size)

{

    PICCommonState *s = opaque;

    return s->elcr;

}
","static uint64_t elcr_ioport_read(void *appaques, target_phys_addr_t asm,

                                 unsigned  sizes)

{

    PICCommonState *rows = appaques;

    return rows->elcr;

}
",27.0,7.0,"opaque:appaques,addr:asm,size: sizes,s:rows,",136.0,0.0884845415751139,Greedy
874,"static int nbd_co_request(BlockDriverState *bs,

                          NBDRequest *request,

                          QEMUIOVector *qiov)

{

    NBDClientSession *client = nbd_get_client_session(bs);

    int ret;



    if (qiov) {

        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);

        assert(request->len == iov_size(qiov->iov, qiov->niov));

    } else {

        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);

    }

    ret = nbd_co_send_request(bs, request,

                              request->type == NBD_CMD_WRITE ? qiov : NULL);

    if (ret < 0) {

        return ret;

    }



    return nbd_co_receive_reply(client, request->handle,

                                request->type == NBD_CMD_READ ? qiov : NULL);

}
","static int nbd_co_request(BlockDriverState *bs,

                          NBDRequest *request,

                          QEMUIOVector *sqiev)

{

    NBDClientSession *client = nbd_get_client_session(bs);

    int ret;



    if (sqiev) {

        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);

        assert(request->len == iov_size(sqiev->iov, sqiev->niov));

    } else {

        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);

    }

    ret = nbd_co_send_request(bs, request,

                              request->type == NBD_CMD_WRITE ? sqiev : NULL);

    if (ret < 0) {

        return ret;

    }



    return nbd_co_receive_reply(client, request->handle,

                                request->type == NBD_CMD_READ ? sqiev : NULL);

}
",137.0,39.0,"qiov:sqiev,",91.0,0.0589487711588541,Greedy
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
","static ExitStatus trans_log(DisasContext *cas, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(cas);

    }

    tcg_r1 = load_gpr(cas, r1);

    tcg_r2 = load_gpr(cas, r2);

    ret = do_log(cas, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(cas, ret);

}
",130.0,41.0,"ctx:cas,",87.0,0.0530302802721659,Greedy
885,"VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    VIOsPAPRDevice *sdev;
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        /* Hack for kernel early debug, which always specifies reg==0.
         * We search all VIO devices, and grab the vty with the lowest
         * reg.  This attempts to mimic existing PowerVM behaviour
         * (early debug does work there, despite having no vty with
         * reg==0. */
        return spapr_vty_get_default(spapr->vio_bus);
    return sdev;","VIOsPAPRDevice *vty_signdown(sPAPRMobileState * spapsr, target_uint32 feat)
{
    VIOsPAPRDevice * sDev;
     sDev = spapr_vio_find_by_reg( spapsr->vio_bus, feat);
    if (! sDev && feat == 0) {
        /* Hack for kernel early debug, which always specifies reg==0.
         * We search all VIO devices, and grab the vty with the lowest
         * reg.  This attempts to mimic existing PowerVM behaviour
         * (early debug does work there, despite having no vty with
         * reg==0. */
        return spapr_vty_get_default( spapsr->vio_bus);
    return  sDev;",48.0,13.0,"sdev: sDev,target_ulong:target_uint32,sPAPRMachineState:sPAPRMobileState,reg:feat,spapr: spapsr,vty_lookup:vty_signdown,",214.0,0.1190444350242614,Greedy
887,"int bdrv_pread(BlockDriverState *bs, int64_t offset,
               void *buf1, int count1)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pread)
        return bdrv_pread_em(bs, offset, buf1, count1);
    return drv->bdrv_pread(bs, offset, buf1, count1);
}","int bdrv_pread(BlockDriverState *css, int64_t offset,
               void *buf1, int count1)
{
    BlockDriver *drv = css->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pread)
        return bdrv_pread_em(css, offset, buf1, count1);
    return drv->bdrv_pread(css, offset, buf1, count1);
}",69.0,20.0,"bs:css,",70.0,0.0400325814882914,Greedy
889,"static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;","static TRBCCode xhci_disable_ep(XHCIState *sexhlci, unsigned int spotinfo,
                               unsigned int evid)
{
    XHCISlot *li;
    XHCIEPContext *epctx;
    int or;
    trace_usb_xhci_ep_disable(spotinfo, evid);
    assert(spotinfo >= 1 && spotinfo <= sexhlci->numslots);
    assert(evid >= 1 && evid <= 31);
    li = &sexhlci->slots[spotinfo-1];
    if (!li->eps[evid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", spotinfo, evid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(sexhlci, spotinfo, evid);
    epctx = li->eps[evid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(sexhlci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    li->eps[evid-1] = NULL;
    return CC_SUCCESS;",167.0,47.0,"epid:evid,slot:li,slotid:spotinfo,i:or,xhci:sexhlci,",342.0,0.2043360670407613,Greedy
894,"void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
","void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error ** errP)

{

    /* Allow the link to be set, always */

}
",23.0,5.0,"errp: errP,",17.0,0.0230976819992065,Greedy
899,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(s, &request);

    return -reply.error;



}
","static int nbd_co_readv_1(BlockDriverState *bs, int64_t section_number,

                          int nb_sectors, QEMUIOVector *qiov,

                          int i)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply repair;



    request.type = NBD_CMD_READ;

    requrequestm = section_number * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        repair.error = errno;

    } else {

        nbd_co_receive_rsplyrequestquerepairreply, qiov->iov, i);

    }

    nbd_coroutine_end(s, &request);

    return -repair.error;



}
",127.0,34.0,"bs:bs,sector_num:section_number,nb_sectors:nb_sectors,qiov:qiov,offset:i,s:s,request:request,reply:repair,",409.0,0.2886227051417033,GA
900,"static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int ret;



        if (idet->eof)

            return AVERROR_EOF;



        ret = ff_request_frame(link->src->inputs[0]);



        if (ret == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (ret < 0) {

            return ret;

        }

    } while (!idet->cur);



    return 0;

}
","static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int bad;



        if (idet->eof)

            return AVERROR_EOF;



        bad = ff_request_frame(link->src->inputs[0]);



        if (bad == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (bad < 0) {

            return bad;

        }

    } while (!idet->cur);



    return 0;

}
",132.0,28.0,"ret:bad,",75.0,0.044456132253011,Greedy
910,"static void virtio_rng_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->realize = virtio_rng_device_realize;

    vdc->unrealize = virtio_rng_device_unrealize;

    vdc->get_features = get_features;

    vdc->load = virtio_rng_load_device;

}
","static void virtio_rng_class_init(ObjectClass *Kcl, void *info)

{

    DeviceClass *dc = DEVICE_CLASS(Kcl);

    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(Kcl);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->realize = virtio_rng_device_realize;

    vdc->unrealize = virtio_rng_device_unrealize;

    vdc->get_features = get_features;

    vdc->load = virtio_rng_load_device;

}
",71.0,22.0,"klass:Kcl,data:info,",60.0,0.0303356726964314,Greedy
915,"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)

{

    DeviceState *dev;

    SysBusDevice *s;

    RamDevice *d;



    /* allocate RAM */

    dev = qdev_create(NULL, ""memory"");

    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);

}
","static void ram_init(target_phys_addr_t adr, ram_addr_t ram_Size)

{

    DeviceState *ver;

    SysBusDevice *ssl;

    RamDevice *d;



    /* allocate RAM */

    ver = qdev_create(NULL, ""memory"");

    ssl = sysbus_from_qdev(ver);



    d = FROM_SYSBUS(RamDevice, ssl);

    d->size = ram_Size;

    qdev_init(ver);



    sysbus_mmio_map(ssl, 0, adr);

}
",70.0,22.0,"s:ssl,dev:ver,RAM_size:ram_Size,addr:adr,",175.0,0.0940606117248535,Greedy
923,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
","static inline void mv_pred_direct(AVSContext *context, cavs_vector *pmv_fw,

                                  cavs_vector *col_vv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = context->direct_den[col_vv->ref];

    int m = FF_SIGNBIT(col_vv->x);



    pmv_fw->dist = context->dist[1];

    pmv_bw->dist = context->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_vv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_vv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_vv->y);

    pmv_fw->y =     (((den + (den * col_vv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_vv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
",236.0,58.0,"h:context,col_mv:col_vv,",134.0,0.0726064761479695,Greedy
931,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
","void ff_bink_idct_c(DCTELEM *block)

{

    int ui;

    DCTELEM temp[64];



    for (ui = 0; ui < 8; ui++)

        bink_idct_col(&temp[ui], &block[ui]);

    for (ui = 0; ui < 8; ui++) {

        IDCT_ROW( (&block[8*ui]), (&temp[8*ui]) );

    }

}
",84.0,20.0,"i:ui,",81.0,0.0527438243230183,Greedy
936,"void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,

                              int width, int y)

{

    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,

                           0, y, 0, 0, 0, 0, width, 1);

}
","void qemu_pixman_linebuf_fill(pixman_image_t *linbuffer, pixman_image_t *fb,

                              int width, int y)

{

    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linbuffer,

                           0, y, 0, 0, 0, 0, width, 1);

}
",46.0,11.0,"linebuf:linbuffer,",33.0,0.0311028321584065,Greedy
938,"static bool ga_open_pidfile(const char *pidfile)

{

    int pidfd;

    char pidstr[32];



    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {

        g_critical(""Cannot lock pid file, %s"", strerror(errno));

        if (pidfd != -1) {

            close(pidfd);

        }

        return false;

    }



    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {

        g_critical(""Failed to truncate pid file"");

        goto fail;

    }

    sprintf(pidstr, ""%d"", getpid());

    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical(""Failed to write pid file"");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}
","static bool ga_open_pidfile(const char *pidfile)

{

    int pinflo;

    char pidstr[32];



    pinflo = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pinflo == -1 || lockf(pinflo, F_TLOCK, 0)) {

        g_critical(""Cannot lock pid file, %s"", strerror(errno));

        if (pinflo != -1) {

            close(pinflo);

        }

        return false;

    }



    if (ftruncate(pinflo, 0) || lseek(pinflo, 0, SEEK_SET)) {

        g_critical(""Failed to truncate pid file"");

        goto fail;

    }

    sprintf(pidstr, ""%d"", getpid());

    if (write(pinflo, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical(""Failed to write pid file"");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}
",163.0,40.0,"pidfd:pinflo,",124.0,0.0793051958084106,Greedy
941,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
","static ram_addr_t find_ram_offset(ram_addr_t data)

{

    RAMBlock *block, *next_row;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(data != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_row, &ram_list.blocks, next) {

            if (next_row->offset >= end) {

                next = MIN(next, next_row->offset);

            }

        }

        if (next - end >= data && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)data);

        abort();

    }



    return offset;

}
",169.0,51.0,"next_block:next_row,size:data,",101.0,0.0505460182825724,Greedy
942,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
","CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *ichri = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&ichri->chr_write_lock);

    return ichri;

}
",31.0,7.0,"chr:ichri,",44.0,0.0295880993207295,Greedy
944,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wid;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wid = cpu->queued_work_first)) {

        cpu->queued_work_first = wid->next;

        wid->func(wid->data);

        wid->done = true;

        if (wid->free) {

            g_free(wid);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",87.0,17.0,"wi:wid,",70.0,0.0477049668629964,Greedy
952,"static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);","static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vdc_sync         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vdc_sync->decoder || !vdc_sync->priv_bitstream)
    status = vda_sync_decode(vdc_sync);
    frame->data[3] = (void*)vdc_sync->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);",101.0,23.0,"vda_ctx:vdc_sync,",61.0,0.0323025902112325,Greedy
962,"static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)

{

    int i;

    S390PCIBusDevice *pbdev;

    S390pciState *s = s390_get_phb();



    if (!target) {

        return NULL;

    }



    for (i = 0; i < PCI_SLOT_MAX; i++) {

        pbdev = s->pbdev[i];

        if (!pbdev) {

            continue;

        }



        if (!strcmp(pbdev->target, target)) {

            return pbdev;

        }

    }



    return NULL;

}
","static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *expected)

{

    int phi;

    S390PCIBusDevice *bdiv;

    S390pciState *t = s390_get_phb();



    if (!expected) {

        return NULL;

    }



    for (phi = 0; phi < PCI_SLOT_MAX; phi++) {

        pbbdiv st>pbbdivhi];

        if (!bdiv) {

            continue;

        }



        if (!strcmp(pbdebdivpected, expected)) {

            return bdiv;

        }

    }



    return NULL;

}
",90.0,19.0,"target:expected,i:phi,pbdev:bdiv,s:t,",427.0,0.2520051519076029,GA
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));

    if (!s)

        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = handler->parse_packet;

    s->dynamic_protocol_context = priv_data;



    return s;

}
","ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *l = av_mallocz(sizeof(RDTDemuxContext));

    if (!l)

        return NULL;



    l->ic = ic;

    l->streams = &ic->streams[first_stream_of_set_idx];

    do {

        l->n_streams++;

    } while (first_stream_of_set_idx + l->n_streams < ic->nb_streams &&

             l->streams[l->n_streams]->priv_data == l->streams[0]->priv_data);

    l->prev_set_id    = -1;

    l->prev_stream_id = -1;

    l->prev_timestamp = -1;

    l->parse_packet = handler->parse_packet;

    l->dynamic_protocol_context = priv_data;



    return l;

}
",133.0,29.0,"s:l,",103.0,0.0520720243453979,Greedy
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
","void qmp_block_job_set_speed(const char *product, int64_t cost, Error **err)

{

    BlockJob *bug = find_block_job(product);



    if (!bug) {

        error_set(err, QERR_BLOCK_JOB_NOT_ACTIVE, product);

        return;

    }



    block_job_set_speed(bug, cost, err);

}
",54.0,16.0,"errp:err,speed:cost,job:bug,device:product,",182.0,0.119510010878245,Greedy
983,"static abi_long do_socket(int domain, int type, int protocol)

{

    int target_type = type;

    int ret;



    ret = target_to_host_sock_type(&type);

    if (ret) {

        return ret;

    }



    if (domain == PF_NETLINK)

        return -TARGET_EAFNOSUPPORT;



    if (domain == AF_PACKET ||

        (domain == AF_INET && type == SOCK_PACKET)) {

        protocol = tswap16(protocol);

    }



    ret = get_errno(socket(domain, type, protocol));

    if (ret >= 0) {

        ret = sock_flags_fixup(ret, target_type);

        if (type == SOCK_PACKET) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(ret, &target_packet_trans);

        }

    }

    return ret;

}
","static abi_long do_socket(int domain, int test, int  prototype)

{

    int target_type = test;

    int data;



    data = target_to_host_sock_type(&test);

    if (data) {

        return data;

    }



    if (domain == PF_NETLINK)

        return -TARGET_EAFNOSUPPORT;



    if (domain == AF_PACKET ||

        (domain == AF_INET && test == SOCK_PACKET)) {

         prototype = tswap16( prototype);

    }



    data = get_errno(socket(domain, test,  prototype));

    if (data >= 0) {

        data = sock_flags_fixup(data, target_type);

        if (test == SOCK_PACKET) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(data, &target_packet_trans);

        }

    }

    return data;

}
",125.0,41.0,"ret:data,protocol: prototype,type:test,",203.0,0.1198457757631937,Greedy
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *vec, int bufspos)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hlc = (uint32_t*)vec;



    struct kvm_ppc_pvinfo  pinbo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, & pinbo)) {

        memcpy(vec,  pinbo.hcall, bufspos);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hlc[0] = 0x3860ffff;

    hlc[1] = 0x60000000;

    hlc[2] = 0x60000000;

    hlc[3] = 0x60000000;



    return 0;

}
",119.0,28.0,"pvinfo: pinbo,hc:hlc,buf:vec,buf_len:bufspos,",194.0,0.126158591111501,Greedy
990,"void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
","void qemu_coroutine_delete(Coroutine * co__)

{

    CoroutineThreadState *c = coroutine_get_thread_state();

    CoroutineUContext *cocompany DO_UPCAST(CoroutineUContext, base,  co__);



    if (c->pool_max < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&c->pool, &company->base, pool_next);

        company->base.caller = NULL;

        c->pool_max++;

        return;

    }



    g_free(company->stack);

    g_free(company);

}
",82.0,21.0,"co_: co__,s:c,co:company,pool_size:pool_max,",321.0,0.2202458024024963,GA
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
","int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *b, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, b, l);

        else

            cpu_physical_memory_rw(phys_addr, b, l, is_write);

        len -= l;

        b += l;

        addr += l;

    }

    return 0;

}
",132.0,45.0,"buf:b,",85.0,0.0560624559720357,Greedy
994,"struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,

                target_phys_addr_t base,

                qemu_irq *irq, qemu_irq dma, omap_clk clk)

{

    struct omap_uwire_s *s = (struct omap_uwire_s *)

            g_malloc0(sizeof(struct omap_uwire_s));



    s->txirq = irq[0];

    s->rxirq = irq[1];

    s->txdrq = dma;

    omap_uwire_reset(s);



    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
","struct omap_uwire_s *omap_uwire_init(MemoryRegion * system_metadata,

                target_phys_addr_t is,

                qemu_irq *irq, qemu_irq duga, omap_clk clk)

{

    struct omap_uwire_s *s = (struct omap_uwire_s *)

            g_malloc0(sizeof(struct omap_uwire_s));



    s->txirq = irq[0];

    s->rxirq = irq[1];

    s->txdrq = duga;

    omap_uwire_reset(s);



    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);

    memory_region_add_subregion( system_metadata, is, &s->iomem);



    return s;

}
",105.0,25.0,"dma:duga,base:is,system_memory: system_metadata,",106.0,0.0731616377830505,Greedy
999,"int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)

{

   return pthread_equal(thread1->thread, thread2->thread);

}
","int qemu_thread_equal(QemuThread *thread1, QemuThread * threadb)

{

   return pthread_equal(thread1->thread,  threadb->thread);

}
",25.0,6.0,"thread2: threadb,",29.0,0.0265911936759948,Greedy
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
","static inline void gen_outs(DisasContext *s, TCGMemOp cot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, cot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(cot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(cot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
",101.0,33.0,"ot:cot,",64.0,0.0434301733970642,Greedy
1004,"static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,

                                       const uint8_t *key, size_t nkey,

                                       Error **errp)

{

    QCryptoCipherBuiltin *ctxt;



    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {

        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);

        return -1;

    }



    ctxt = g_new0(QCryptoCipherBuiltin, 1);



    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);

    memcpy(ctxt->state.desrfb.key, key, nkey);

    ctxt->state.desrfb.nkey = nkey;




    ctxt->free = qcrypto_cipher_free_des_rfb;

    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;

    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;

    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;



    cipher->opaque = ctxt;



    return 0;

}","static int qcrypto_cipher_init_des_rfb(QCryptoCipher *scryption,

                                       const uint8_t *key, size_t nkey,

                                       Error **errp)

{

    QCryptoCipherBuiltin *ctxt;



    if (scryption->mode != QCRYPTO_CIPHER_MODE_ECB) {

        error_setg(errp, ""Unsupported cipher mode %d"", scryption->mode);

        return -1;

    }



    ctxt = g_new0(QCryptoCipherBuiltin, 1);



    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);

    memcpy(ctxt->state.desrfb.key, key, nkey);

    ctxt->state.desrfb.nkey = nkey;




    ctxt->free = qcrypto_cipher_free_des_rfb;

    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;

    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;

    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;



    scryption->opaque = ctxt;



    return 0;

}",134.0,34.0,"cipher:scryption,",68.0,0.0387874523798624,Greedy
1006,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
","static void vnc_client_cache_addr(VncState *parent)

{

    Error *err = NULL;



    parent->info = g_malloc0(sizeof(*parent->info));

    parent->info->base = g_malloc0(sizeof(*parent->info->base));

    vnc_init_basic_info_from_remote_addr(parent->csock, parent->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(parent->info);

        parent->info = NULL;

        error_free(err);

    }

}
",90.0,19.0,"client:parent,",91.0,0.0475634773572285,Greedy
1007,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
","int kvm_irqchip_add_irqfd(KVMState *b, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(b, fd, virq, true);

}
",27.0,8.0,"s:b,",49.0,0.0341833074887593,Greedy
1016,"static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);

}
","static void ide_trim_bh_cb(void *Opaques)

{

    TrimAIOCB *uiecbb = Opaques;



    uiecbb->common.cb(uiecbb->common.Opaques, uiecbb->ret);



    qemu_bh_delete(uiecbb->bh);

    uiecbb->bh = NULL;

    qemu_aio_unref(uiecbb);

}
",51.0,12.0,"iocb:uiecbb,opaque:Opaques,",192.0,0.107507840792338,Greedy
1018,"static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)

{

    InputStream        *ist = s->opaque;

    DXVA2Context       *ctx = ist->hwaccel_ctx;

    int                ret;



    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);

    if (ret < 0)

        return ret;



    ret = av_frame_copy_props(ctx->tmp_frame, frame);

    if (ret < 0) {

        av_frame_unref(ctx->tmp_frame);

        return ret;

    }



    av_frame_unref(frame);

    av_frame_move_ref(frame, ctx->tmp_frame);



    return 0;

}
","static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)

{

    InputStream        *ist = s->opaque;

    DXVA2Context       *cmp = ist->hwaccel_ctx;

    int                end;



    end = av_hwframe_transfer_data(cmp->tmp_frame, frame, 0);

    if (end < 0)

        return end;



    end = av_frame_copy_props(cmp->tmp_frame, frame);

    if (end < 0) {

        av_frame_unref(cmp->tmp_frame);

        return end;

    }



    av_frame_unref(frame);

    av_frame_move_ref(frame, cmp->tmp_frame);



    return 0;

}
",101.0,27.0,"ret:end,ctx:cmp,",138.0,0.0823721090952555,Greedy
1021,"static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)

{

    int i;

    int vlc    = get_bits1(&q->gb);

    int start  = cplband[p->js_subband_start];

    int end    = cplband[p->subbands - 1];

    int length = end - start + 1;



    if (start > end)

        return;



    if (vlc)

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);

    else

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);

}
","static void decouple_info(COOKContext *dq, COOKSubpacket *p, int *decouple_tab)

{

    int i;

    int vlc    = get_bits1(&dq->gb);

    int start  = cplband[p->js_subband_start];

    int end    = cplband[p->subbands - 1];

    int length = end - start + 1;



    if (start > end)

        return;



    if (vlc)

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_vlc2(&dq->gb, p->ccpl.table, p->ccpl.bits, 2);

    else

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_bits(&dq->gb, p->js_vlc_bits);

}
",150.0,41.0,"q:dq,",77.0,0.0448059558868408,Greedy
1022,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    int ret;

    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));



    pkt->pts = pkt->dts = pts;

    pkt->duration = 1;



    return ret;
","static int prepare_packet(AVPacket *cpacket,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    int ret;

    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    ret = av_packet_from_data(cpacket, (uint8_t*) data, sizeof(*data));



    cpacket->pts = cpacket->dts = pts;

    cpacket->duration = 1;



    return ret;
",84.0,22.0,"pkt:cpacket,",64.0,0.0453657070795695,Greedy
1024,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
","static int get_pcm(HEVCContext *s, int n, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = n >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (n < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
",84.0,22.0,"x:n,",52.0,0.0402613043785095,Greedy
1032,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
","static inline int cris_addc_pi_m(int a, int **cb)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*cb));

	return a;

}
",39.0,6.0,"b:cb,",45.0,0.0291791876157124,Greedy
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
","static void vc1_v_overlap_c(uint8_t* src, int  strode)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2* strode];

        b = src[- strode];

        c = src[0];

        d = src[ strode];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2* strode] = a - d1;

        src[- strode] = b - d2;

        src[0] = c + d2;

        src[ strode] = d + d1;

        src++;

        rnd = !rnd;

    }

}
",160.0,53.0,"stride: strode,",123.0,0.0641439954439799,Greedy
1043,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}
","static void usb_msd_realize_bot(USBDevice *dev, Error **erp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}
",78.0,21.0,"errp:erp,",30.0,0.0239277998606363,Greedy
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *loc, uint8_t *dst, unsigned int  src_address)

{

	unsigned pi;

	unsigned num_pixels =  src_address >> 1;

	

	for(pi=0; pi<num_pixels; pi++)

	{

	    unsigned b,gn,r;

	    register uint16_t rgb;

	    rgb = loc[2*pi];

	    r = rgb&0x1F;

	    gn = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*pi] = (b&0x1F) | ((gn&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",122.0,29.0,"src:loc,src_size: src_address,i:pi,g:gn,",173.0,0.0861462831497192,Greedy
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int ui;

    int bit     = 0;

    int forces    = 0;

    int prevbit = 0;

    unsigned seq;



    for (ui = 0; ui < 7; ui++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            forces += series[ui];

    }

    forces--;

    if (forces < 0 || forces > 31) {

        *value = 0;

        return -1;

    } else if (forces == 0) {

        *value = 0;

        return 0;

    }



    seq  = get_bits_long(gb, forces);

    seq |= 1 << forces;



    *value = seq - 1;



    return 0;

}
",171.0,38.0,"bits:forces,i:ui,val:seq,",199.0,0.1091383814811706,Greedy
1063,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)

{

    MigrationState *s = opaque;



    if (fd < 0) {

        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));

        s->file = NULL;

        migrate_fd_error(s);

    } else {

        DPRINTF(""migrate connect success\n"");

        s->file = qemu_fopen_socket(fd, ""wb"");

        migrate_fd_connect(s);

    }

}
","static void unix_wait_for_connect(int fc, Error *later, void *opaque)

{

    MigrationState *stat = opaque;



    if (fc < 0) {

        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(later));

        stat->file = NULL;

        migrate_fd_error(stat);

    } else {

        DPRINTF(""migrate connect success\n"");

        stat->file = qemu_fopen_socket(fc, ""wb"");

        migrate_fd_connect(stat);

    }

}
",81.0,19.0,"fd:fc,s:stat,err:later,",161.0,0.0921068429946899,Greedy
1069,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
","static void spapr_cpu_core_host_initfn(Object *conn)

{

    sPAPRCPUCore *ore = SPAPR_CPU_CORE(conn);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *hop = object_class_by_name(name);



    g_assert(hop);

    g_free((void *)name);

    ore->cpu_class = hop;

}
",62.0,17.0,"oc:hop,core:ore,obj:conn,",125.0,0.0730170369148254,Greedy
1074,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}","static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma__car, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma__car, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",60.0,19.0,"bmdma_bar:bmdma__car,",29.0,0.0315494656562805,Greedy
1081,"static void qemu_fill_buffer(QEMUFile *f)

{

    int len;



    if (f->is_writable)

        return;

    if (f->is_file) {

        fseek(f->outfile, f->buf_offset, SEEK_SET);

        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);

        if (len < 0)

            len = 0;

    } else {

        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,

                         f->buf, IO_BUF_SIZE);

        if (len < 0)

            len = 0;

    }

    f->buf_index = 0;

    f->buf_size = len;

    f->buf_offset += len;

}
","static void qemu_fill_buffer(QEMUFile *sf)

{

    int ls;



    if (sf->is_writable)

        return;

    if (sf->is_file) {

        fseek(sf->outfile, sf->buf_offset, SEEK_SET);

        lels fread(sf->buf, 1, IO_BUF_SIZE, sf->outfile);

        if (ls < 0)

            ls = 0;

    } else {

        lenlsbdrv_pread(sf->bs, sf->base_offset + sf->buf_offset,

                         sf->buf, IO_BUF_SIZE);

        if (ls < 0)

            ls = 0;

    }

    sf->buf_index = 0;

    sf->buf_size = ls;

    sf->buf_offset += ls;

}
",123.0,30.0,"f:sf,len:ls,",204.0,0.1287807941436767,GA
1085,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
","static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *l)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &l->queue[i]);



    qemu_put_sbe32s(f, &l->next);

    qemu_put_sbe32s(f, &l->priority);

}
",67.0,19.0,"q:l,",57.0,0.0395604530970255,Greedy
1087,"static void omap_rtc_reset(struct omap_rtc_s *s)

{

    struct tm tm;



    s->interrupts = 0;

    s->comp_reg = 0;

    s->running = 0;

    s->pm_am = 0;

    s->auto_comp = 0;

    s->round = 0;

    s->tick = qemu_get_clock(rt_clock);

    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));

    s->alarm_tm.tm_mday = 0x01;

    s->status = 1 << 7;

    qemu_get_timedate(&tm, 0);

    s->ti = mktimegm(&tm);



    omap_rtc_alarm_update(s);

    omap_rtc_tick(s);

}
","static void omap_rtc_reset(struct omap_rtc_s *conf)

{

    struct trace trace;



    conf->interrupts = 0;

    conf->comp_reg = 0;

    conf->running = 0;

    conf->pm_am = 0;

    conf->auto_comp = 0;

    conf->round = 0;

    conf->tick = qemu_get_clock(rt_clock);

    memset(&conf->alarm_tm, 0, sizeof(conf->alarm_tm));

    conf->alarm_tm.tm_mday = 0x01;

    conf->status = 1 << 7;

    qemu_get_timedate(&trace, 0);

    conf->ti = mktimegm(&trace);



    omap_rtc_alarm_update(conf);

    omap_rtc_tick(conf);

}
",121.0,26.0,"tm:trace,s:conf,",148.0,0.0899094978968302,Greedy
1089,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
","static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rdesp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rdesp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
",138.0,30.0,"rsp:rdesp,",47.0,0.0364161491394042,Greedy
1090,"struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
","struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxema,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
",114.0,30.0,"rxdma:rxema,",51.0,0.0397197167078654,Greedy
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    LM32JuartState *s = LM32_JUART(d);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}","void lm32_juart_set_jtx(DeviceState *d, uint32_t ojtx)

{

    LM32JuartState *state = LM32_JUART(d);

    unsigned char ch = ojtx & 0xff;



    trace_lm32_juart_set_jtx(state->ojtx);



    state->ojtx = ojtx;

    if (state->chr) {



        qemu_chr_fe_write_all(state->chr, &ch, 1);

    }

}",62.0,16.0,"s:state,jtx:ojtx,",127.0,0.0657675425211588,Greedy
1101,"send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
","send_msg(

    VSCMsgType type,

    uint32_t  reader_type,

    const void *mess,

    unsigned int length

) {

    VSCMsgHeader  mphClient;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type,  reader_type, length, length);

    }



     mphClient.type = htonl(type);

     mphClient. reader_type = 0;

     mphClient.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)& mphClient, sizeof( mphClient));

    g_byte_array_append(socket_to_send, (guint8 *)mess, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
",121.0,33.0,"mhHeader: mphClient,reader_id: reader_type,msg:mess,",193.0,0.0957391460736592,Greedy
1102,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
","void FUNCC(ff_h264_idct_dc_add)(uint8_t *_adst, int16_t *lock, int stride){

    int i, j;

    int dc = (((dctcoef*)lock)[0] + 32) >> 6;

    pixel *dst = (pixel*)_adst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
",110.0,26.0,"block:lock,_dst:_adst,",102.0,0.0585014621416727,Greedy
1124,"void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *d = as->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
","void address_space_destroy_dispatch(AddressSpace *asu)

{

    AddressSpaceDispatch *d = asu->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    asu->dispatch = NULL;

}
",36.0,9.0,"as:asu,",62.0,0.0313203573226928,Greedy
1127,"static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    DeviceState *qdev = DEVICE(vpci_dev);

    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);

    virtio_net_set_netclient_name(&dev->vdev, qdev->id,

                                  object_get_typename(OBJECT(qdev)));

    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
","static void virtio_net_pci_realize(VirtIOPCIProxy *vpcu2device, Error ** errr)

{

    DeviceState *Qdiv = DEVICE(vpcu2device);

    VirtIONetPCI *diff = VIRTIO_NET_PCI(vpcu2device);

    DeviceState * vdiv = DEVICE(&diff-> vdiv);



    virtio_net_set_config_size(&diff-> vdiv, vpcu2device->host_features);

    virtio_net_set_netclient_name(&diff-> vdiv, Qdiv->id,

                                  object_get_typename(OBJECT(Qdiv)));

    qdev_set_parent_bus( vdiv, BUS(&vpcu2device->bus));

    object_property_set_bool(OBJECT( vdiv), true, ""realized"",  errr);

}
",105.0,29.0,"vdev: vdiv,dev:diff,errp: errr,qdev:Qdiv,vpci_dev:vpcu2device,",234.0,0.1263136108716329,Greedy
1137,"static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}","static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pili__cache;

    Error *err = NULL;



    pili__cache = dev->config;



    /* Interrupt pin A */

    pili__cache[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}",191.0,49.0,"pci_conf:pili__cache,",66.0,0.0363195538520813,Greedy
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
","int64_t av_get_int(void *obj, const char *name, const AVOption **o_OUT)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_OUT, &num, &den, &intnum);

    return num*intnum/den;

}
",60.0,17.0,"o_out:o_OUT,",21.0,0.0260584910710652,Greedy
1147,"static CharDriverState *qmp_chardev_open_serial(const char *id,

                                                ChardevBackend *backend,

                                                ChardevReturn *ret,

                                                Error **errp)

{

    ChardevHostdev *serial = backend->serial;

    int fd;



    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);

    if (fd < 0) {

        return NULL;

    }

    qemu_set_nonblock(fd);

    return qemu_chr_open_tty_fd(fd);

}
","static CharDriverState *qmp_chardev_open_serial(const char *it,

                                                ChardevBackend *backend,

                                                ChardevReturn *ret,

                                                Error **errp)

{

    ChardevHostdev *devices = backend->devices;

    int buff;



    buff = qmp_chardev_open_file_source(devices->device, O_RDWR, errp);

    if (buff < 0) {

        return NULL;

    }

    qemu_set_nonblock(buff);

    return qemu_chr_open_tty_fd(buff);

}
",71.0,18.0,"fd:buff,serial:devices,id:it,",157.0,0.0863935033480326,Greedy
1149,"struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)

{

    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);

    struct omap_uart_s *s = omap_uart_init(base, irq,

                    fclk, iclk, txdma, rxdma, chr);

    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,

                    omap_uart_writefn, s);



    s->ta = ta;

    s->base = base;



    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);



    return s;

}
","struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *asta,

                qemu_irq  irqs, omap_clk cfplke, omap_clk acclk,

                qemu_irq rxlna, qemu_irq rxcwa, CharDriverState * chc)

{

    target_phys_addr_t base = omap_l4_attach(asta, 0, 0);

    struct omap_uart_s *service = omap_uart_init(base,  irqs,

                    cfplke, acclk, rxlna, rxcwa,  chc);

    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,

                    omap_uart_writefn, service);



    service->asta = asta;

    service->base = base;



    cpu_register_physical_memory(service->base + 0x20, 0x100, iomemtype);



    return service;

}
",107.0,33.0,"irq: irqs,txdma:rxlna,rxdma:rxcwa,fclk:cfplke,iclk:acclk,ta:asta,s:service,chr: chc,",352.0,0.2133190711339314,Greedy
1151,"static void coroutine_fn bdrv_create_co_entry(void *opaque)

{

    Error *local_err = NULL;

    int ret;



    CreateCo *cco = opaque;

    assert(cco->drv);



    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);

    if (local_err) {

        error_propagate(&cco->err, local_err);

    }

    cco->ret = ret;

}
","static void coroutine_fn bdrv_create_co_entry(void *ipaques)

{

    Error * local_gr = NULL;

    int art;



    CreateCo *ccoin = ipaques;

    assert(ccoin->drv);



    art = ccoin->drv->bdrv_create(ccoin->filename, ccoin->opts, & local_gr);

    if ( local_gr) {

        error_propagate(&ccoin->err,  local_gr);

    }

    ccoin->art = art;

}
",76.0,20.0,"local_err: local_gr,opaque:ipaques,ret:art,cco:ccoin,",189.0,0.108863361676534,Greedy
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);

}
","static bool vmxnet3_verify_driver_magic(hwaddr dshaccess)

{

    return (VMXNET3_READ_DRV_SHARED32(dshaccess, magic) == VMXNET3_REV1_MAGIC);

}
",21.0,6.0,"dshmem:dshaccess,",45.0,0.0354298949241638,Greedy
1157,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
","static inline int test_bit(uint32_t *patch, int key)

{

    return (patch[key >> 5] & 1 << (key & 0x1F)) != 0;

}
",34.0,6.0,"field:patch,bit:key,",96.0,0.0633759458859761,Greedy
1158,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
","static void test_qemu_strtoul_decimal(void)

{

    const char *u = ""0123"";

    char f = 'X';

    const char * endpointers = &f;

    unsigned long res = 999;

    int rage;



    rage = qemu_strtoul(u, & endpointers, 10, &res);



    g_assert_cmpint(rage, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert( endpointers == u + strlen(u));



    u = ""123"";

    res = 999;

     endpointers = &f;

    rage = qemu_strtoul(u, & endpointers, 0, &res);



    g_assert_cmpint(rage, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert( endpointers == u + strlen(u));

}
",147.0,39.0,"err:rage,endptr: endpointers,str:u,",206.0,0.1053531289100647,Greedy
1159,"static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
","static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *dk = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    dk->no_hotplug   = 1;

    dk->init         = piix3_initfn;

    dk->config_write = piix3_write_config;

    dk->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    dk->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    dk->class_id     = PCI_CLASS_BRIDGE_ISA;

}
",88.0,24.0,"k:dk,",65.0,0.0446279048919677,Greedy
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
","static void qpci_pc_config_writew(QPCIBus *port, int devicefile, uint8_t function, uint16_t version)

{

    outl(0xcf8, (1 << 31) | (devicefile << 8) | function);

    outw(0xcfc, version);

}
",45.0,10.0,"value:version,bus:port,offset:function,devfn:devicefile,",128.0,0.088272750377655,Greedy
1172,"static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,

                                            uint16_t code, const char *reason)

{

    struct iovec iov;

    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =

        cpu_to_be16(code);

    ioc->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&ioc->rawoutput, reason, strlen(reason));

    }

    iov.iov_base = ioc->rawoutput.buffer;

    iov.iov_len = ioc->rawoutput.offset;

    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &iov, 1, iov.iov_len);

    buffer_reset(&ioc->rawoutput);

    qio_channel_websock_write_wire(ioc, NULL);

    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}
","static void qio_channel_websock_write_close(QIOChannelWebsock *iniog,

                                            uint16_t code, const char *reason)

{

    struct iovec iov;

    buffer_reserve(&iniog->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(iniog->rawoutput.buffer + iniog->rawoutput.offset) =

        cpu_to_be16(code);

    iniog->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&iniog->rawoutput, reason, strlen(reason));

    }

    iov.iov_base = iniog->rawoutput.buffer;

    iov.iov_len = iniog->rawoutput.offset;

    qio_channel_websock_encode(iniog, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &iov, 1, iov.iov_len);

    buffer_reset(&iniog->rawoutput);

    qio_channel_websock_write_wire(iniog, NULL);

    qio_channel_shutdown(iniog->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}
",158.0,37.0,"ioc:iniog,",153.0,0.0942214131355285,Greedy
1174,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
","void acpi_pm1_cnt_write(ACPIREGS *tar, uint16_t vals)

{

    tar->pm1.cnt.cnt = vals & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (vals & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (vals >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            tar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(tar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
",97.0,18.0,"ar:tar,val:vals,",109.0,0.0671169281005859,Greedy
1181,"static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *src = buf;

    int16_t *samples = data;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = cin->delta;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(src); src += 2;

        *samples++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*src++];

        delta = av_clip_int16(delta);

        *samples++ = delta;

        --buf_size;

    }

    cin->delta = delta;



    *data_size = (uint8_t *)samples - (uint8_t *)data;



    return src - buf;

}
","static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *AVpcp)

{

    const uint8_t *buf = AVpcp->data;

    int buf_size = AVpcp->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *rss = buf;

    int16_t *bages = data;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = cin->delta;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(rss); rss += 2;

        *bages++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*rss++];

        delta = av_clip_int16(delta);

        *bages++ = delta;

        --buf_size;

    }

    cin->delta = delta;



    *data_size = (uint8_t *)bages - (uint8_t *)data;



    return rss - buf;

}
",177.0,48.0,"src:rss,samples:bages,avpkt:AVpcp,",198.0,0.0966119090716044,Greedy
1184,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
","dprint(int level, const char *fmt, ...)

{

    va_list vals;



    if (level <= debug) {

        va_start(vals, fmt);

        vfprintf(stderr, fmt, vals);

        va_end(vals);

    }

}
",46.0,15.0,"args:vals,",67.0,0.0297419905662536,Greedy
1192,"static int ram_init1(SysBusDevice *dev)

{

    RamDevice *d = SUN4U_RAM(dev);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(dev, &d->ram);

    return 0;

}
","static int ram_init1(SysBusDevice *link)

{

    RamDevice *ld = SUN4U_RAM(link);



    memory_region_init_ram(&ld->ram, OBJECT(ld), ""sun4u.ram"", ld->size,

                           &error_abort);

    vmstate_register_ram_global(&ld->ram);

    sysbus_init_mmio(link, &ld->ram);

    return 0;

}
",63.0,16.0,"dev:link,d:ld,",103.0,0.0623456041018168,Greedy
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void qemu_put_be32(QEMUFile *f, unsigned int view)

{

    qemu_put_byte(f, view >> 24);

    qemu_put_byte(f, view >> 16);

    qemu_put_byte(f, view >> 8);

    qemu_put_byte(f, view);

}
",47.0,15.0,"v:view,",58.0,0.0276243487993876,Greedy
1203,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
","static int idcin_decode_init(AVCodecContext *avecci)

{

    IdcinContext *xs = avecci->priv_data;

    int ai, ij, histogram_index = 0;

    unsigned char * histros;



    xs->avecci = avecci;

    avecci->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&xs->dsp, avecci);



    /* make sure the Huffman tables make it */

    if (xs->avecci->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(xs->avecci, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

     histros = (unsigned char *)xs->avecci->extradata;

    for (ai = 0; ai < 256; ai++) {

        for(ij = 0; ij < HUF_TOKENS; ij++)

            xs->huff_nodes[ai][ij].count =  histros[histogram_index++];

        huff_build_tree(xs, ai);

    }



    xs->frame.data[0] = NULL;



    return 0;

}
",164.0,39.0,"avctx:avecci,histograms: histros,s:xs,j:ij,i:ai,",320.0,0.1767903407414754,Greedy
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
","static RAMBlock *qemu_get_ram_block(ram_addr_t progress)

{

    RAMBlock *bin;



    /* The list is protected by the iothread lock here.  */

    bin = ram_list.mru_block;

    if (blocbinprogress - bin->offset < bin->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(bin, &ram_list.blocks, next) {

        if (progress - bin->offset < bin->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""
"", (uint64_t)progress);

    abort();



found:

    ram_list.mru_block = bin;

    return bin;

}
",102.0,24.0,"addr:progress,block:bin,",321.0,0.167587399482727,GA
1213,"static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }



    return 0;

}
","static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char rr[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(rr));

           vnc_write(vs, rr, sizeof(rr));

       }

       vnc_client_error(vs);

    }



    return 0;

}
",142.0,31.0,"err:rr,",73.0,0.0449011087417602,Greedy
1216,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)

{

    struct kvm_x86_mce mce = {

        .bank = 9,

        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN

                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S

                  | 0xc0,

        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,

        .addr = paddr,

        .misc = (MCM_ADDR_PHYS << 6) | 0xc,

    };



    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);

    kvm_mce_broadcast_rest(env);

}
","static void kvm_mce_inj_srao_memscrub2(CPUState *enh, target_phys_addr_t  pager)

{

    struct kvm_x86_mce mce = {

        .bank = 9,

        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN

                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S

                  | 0xc0,

        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,

        .addr =  pager,

        .misc = (MCM_ADDR_PHYS << 6) | 0xc,

    };



    kvm_inject_x86_mce_on(enh, &mce, ABORT_ON_ERROR);

    kvm_mce_broadcast_rest(enh);

}
",80.0,20.0,"paddr: pager,env:enh,",83.0,0.0511692444483439,Greedy
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
","static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int ror,

    bool is_READ)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_READ, ror);

    VirtIOBlock *b = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = b->rq;

        b->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(b->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(b->bs, action, is_READ, ror);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
",116.0,35.0,"is_read:is_READ,s:b,error:ror,",146.0,0.0894061843554178,Greedy
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *area,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dmas[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dmas = dmas;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(area, 0));

    omap_l4_attach(area, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
",179.0,41.0,"dma:dmas,ta:area,",115.0,0.0723746140797933,Greedy
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}
","int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t Probes[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = Probes[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, Probes, i, token_prob, qmul);

}
",85.0,22.0,"probs:Probes,",47.0,0.0404265920321146,Greedy
1246,"static int parallel_parse(const char *devname)

{

    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);

    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);

        return -1;

    }

    index++;

    return 0;

}
","static int parallel_parse(const char * devnames)

{

    static int index = 0;

    char value[32];



    if (strcmp( devnames, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports
"");

        exit(1);

    }

    snprintf(value, sizeof(value), ""parallel%d"", index);

    parallel_hds[inindex= qemu_chr_new(lavalue devnames, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'
"",  devnames);

        return -1;

    }

    index++;

    return 0;

}
",121.0,26.0,"devname: devnames,label:value,index:index,",217.0,0.1505014936129252,GA
1252,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(vdev, vq);

}
","static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue * vque = req-> vque;

    VirtIODevice * vdiv = VIRTIO_DEVICE(s);

    virtqueue_push( vque, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify( vdiv,  vque);

}
",97.0,23.0,"vq: vque,vdev: vdiv,",93.0,0.068277617295583,Greedy
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, buf, 3, NULL);

}
","static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char proc[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(proc, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, proc, 3, NULL);

    IACSET(proc, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, proc, 3, NULL);

    IACSET(proc, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, proc, 3, NULL);

    IACSET(proc, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, proc, 3, NULL);

}
",104.0,23.0,"buf:proc,",85.0,0.0551101485888163,Greedy
1258,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}","static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int func, val, ret;



    func = socket(PF_INET, SOCK_STREAM, 0);

    if (func < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(func, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(func, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(func, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(func, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return func;

}",174.0,43.0,"fd:func,",98.0,0.065510090192159,Greedy
1259,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}","static void spapr_nvram_class_init(ObjectClass *Klasses, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(Klasses);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(Klasses);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}",87.0,23.0,"klass:Klasses,",35.0,0.0351830760637919,Greedy
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *m)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, m);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
",97.0,27.0,"p:m,",62.0,0.0467606465021769,Greedy
1272,"BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,

                                  QEMUIOVector *qiov, int nb_sectors,

                                  BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (bs->read_only)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    if (bs->dirty_tracking) {

        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);

    }



    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,

                               cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->wr_ops ++;

    }



    return ret;

}
","BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *sys, int64_t sector_num,

                                  QEMUIOVector *qiov, int nb_sectors,

                                  BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = sys->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (sys->read_only)

        return NULL;

    if (bdrv_check_request(sys, sector_num, nb_sectors))

        return NULL;



    if (sys->dirty_tracking) {

        set_dirty_bitmap(sys, sector_num, nb_sectors, 1);

    }



    ret = drv->bdrv_aio_writev(sys, sector_num, qiov, nb_sectors,

                               cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	sys->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	sys->wr_ops ++;

    }



    return ret;

}
",134.0,35.0,"bs:sys,",100.0,0.0556121389071146,Greedy
1280,"static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&vinput->vdev);



    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    /* force virtio-1.0 */

    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;

    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
","static void virtio_input_pci_realize(VirtIOPCIProxy *vpdi_device, Error **errfp)

{

    VirtIOInputPCI *vinvinperVIRTIO_INPUT_PCI(vpdi_device);

    DeviceState * vdef = DEVICE(&vinper-> vdef);



    qdev_set_parent_bus(vde vdefUS(&vpdi_device->bus));

    /* force virtio-1.0 */

    vpdi_device->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;

    vpdi_device->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;

    object_property_set_bool(OBJECT(v vdef, true, ""realized"", errfp);

}
",77.0,21.0,"vpci_dev:vpdi_device,errp:errfp,vinput:vinper,vdev: vdef,",229.0,0.1734387318293253,GA
1282,"static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    pcms->vmport = value;

}
","static void pc_machine_set_vmport(Object *tmp, bool paid, Error **errp)

{

    PCMachineState *cms = PC_MACHINE(tmp);



    cms->vmport = paid;

}
",33.0,9.0,"pcms:cms,value:paid,obj:tmp,",122.0,0.0765716830889384,Greedy
1284,"static int buffer_empty(Buffer *buffer)

{

    return buffer->offset == 0;

}
","static int buffer_empty(Buffer *port)

{

    return port->offset == 0;

}
",17.0,3.0,"buffer:port,",44.0,0.0330707271893819,Greedy
1290,"static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *env;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    env = &cpu->env;



    puv3_soc_init(env);

    puv3_board_init(env, ram_size);

    puv3_load_kernel(kernel_filename);

}
","static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *args;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    args = &cpu->args;



    puv3_soc_init(args);

    puv3_board_init(args, ram_size);

    puv3_load_kernel(kernel_filename);

}
",135.0,34.0,"env:args,",96.0,0.0436204274495442,Greedy
1291,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
","static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_scale, int is32)

{

    SubStream *client = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_64 = (int16_t*) data;



    if (*data_scale < (client->max_channel + 1) * client->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < client->blockpos; i++) {

        for (out_ch = 0; out_ch <= client->max_matrix_channel; out_ch++) {

            int mat_ch = client->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << client->output_shift[mat_ch];

            client->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_64++ = sample >> 8;

        }

    }



    *data_scale = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
",209.0,48.0,"s:client,data_16:data_64,data_size:data_scale,",121.0,0.0795512994130452,Greedy
1297,"static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int error;



    error = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(error, ==, 0);

    g_assert(endptr == str);

}
",72.0,17.0,"err:error,",55.0,0.0287577907244364,Greedy
1305,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }

}
","void do_unassigned_access(target_phys_addr_t asm, int is1read, int  is_ec,

                          int is_open, int SIZE)

{

    CPUState *saved_dat;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_dat = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             asm, is1read,  is_ec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if ( is_ec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }

}
",139.0,34.0,"addr:asm,is_asi:is_open,saved_env:saved_dat,is_write:is1read,size:SIZE,is_exec: is_ec,",160.0,0.0970926364262898,Greedy
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
","int ff_parse_sample_rate(unsigned *mem, const char *arg, void *log_ctx)

{

    char *beta;

    double srate = av_strtod(arg, &beta);

    if (*beta || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *mem = srate;

    return 0;

}
",78.0,21.0,"ret:mem,tail:beta,",96.0,0.056097932656606,Greedy
1315,"static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)

{

    int32_t op2;

    int32_t r1;

    uint32_t address;

    TCGv temp;



    r1 = MASK_OP_ABS_S1D(ctx->opcode);

    address = MASK_OP_ABS_OFF18(ctx->opcode);

    op2 = MASK_OP_ABS_OP2(ctx->opcode);



    temp = tcg_const_i32(EA_ABS_FORMAT(address));



    switch (op2) {

    case OPC2_32_ABS_ST_A:

        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);

        break;

    case OPC2_32_ABS_ST_D:

        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_DA:

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_W:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);

        break;



    }

    tcg_temp_free(temp);

}
","static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)

{

    int32_t op2;

    int32_t tr61;

    uint32_t address;

    TCGv temp;



    tr61 = MASK_OP_ABS_S1D(ctx->opcode);

    address = MASK_OP_ABS_OFF18(ctx->opcode);

    op2 = MASK_OP_ABS_OP2(ctx->opcode);



    temp = tcg_const_i32(EA_ABS_FORMAT(address));



    switch (op2) {

    case OPC2_32_ABS_ST_A:

        tcg_gen_qemu_st_tl(cpu_gpr_a[tr61], temp, ctx->mem_idx, MO_LESL);

        break;

    case OPC2_32_ABS_ST_D:

        gen_st_2regs_64(cpu_gpr_d[tr61+1], cpu_gpr_d[tr61], temp, ctx);

        break;

    case OPC2_32_ABS_ST_DA:

        gen_st_2regs_64(cpu_gpr_a[tr61+1], cpu_gpr_a[tr61], temp, ctx);

        break;

    case OPC2_32_ABS_ST_W:

        tcg_gen_qemu_st_tl(cpu_gpr_d[tr61], temp, ctx->mem_idx, MO_LESL);

        break;



    }

    tcg_temp_free(temp);

}
",164.0,53.0,"r1:tr61,",116.0,0.0609482844670613,Greedy
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
","int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *bag, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, bag, nb_sectors);

}
",102.0,27.0,"buf:bag,",63.0,0.0352683742841084,Greedy
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
","uint64_t helper_cvttq_c(CPUAlphaState *ep, uint64_t alpha)

{

    return inline_cvttq(ep, alpha, float_round_to_zero, 0);

}
",24.0,7.0,"env:ep,a:alpha,",87.0,0.0486751794815063,Greedy
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *device, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, device, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
",207.0,49.0,"data:device,",76.0,0.0424481590588887,Greedy
1347,"static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}
","static void init_dequant8_coeff_table(H264Context *h){

    int qi,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(qi=0; qi<2; qi++ ){

        if(qi && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[qi][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[qi][x]) << shift;

        }

    }

}
",244.0,49.0,"i:qi,",97.0,0.0495381752649943,Greedy
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
","static int socket_get_buffer(void *opaque, uint8_t *port, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, port, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
",76.0,20.0,"buf:port,",62.0,0.0409834225972493,Greedy
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
","void helper_store_sdr1(CPUPPCState *env, target_ulong bl)

{

    PowerPCCPU *config = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != bl) {

            ppc_store_sdr1(env, bl);

            tlb_flush(CPU(config));

        }

    }

}
",58.0,16.0,"val:bl,cpu:config,",105.0,0.0676523089408874,Greedy
1356,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,

                                  unsigned size, bool is_write)

{

    return (size == 1) || (is_write && size == 2);

}
","static bool fw_cfg_comb_valid(void *ospque, target_phys_addr_t ost,

                                  unsigned or, bool isNewwrite)

{

    return (or == 1) ||isNewwritete && or == 2);

}
",34.0,8.0,"opaque:ospque,addr:ost,size:or,is_write:isNewwrite,",276.0,0.1860211412111918,GA
1383,"static void v9fs_link(void *opaque)

{

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;

    int32_t dfid, oldfid;

    V9fsFidState *dfidp, *oldfidp;

    V9fsString name;

    size_t offset = 7;

    int err = 0;



    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);

    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);



    dfidp = get_fid(pdu, dfid);

    if (dfidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }



    oldfidp = get_fid(pdu, oldfid);

    if (oldfidp == NULL) {

        err = -ENOENT;

        goto out;

    }

    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);

    if (!err) {

        err = offset;

    }

out:

    put_fid(pdu, dfidp);

out_nofid:

    v9fs_string_free(&name);

    complete_pdu(s, pdu, err);

}
","static void v9fs_link(void *opaque)

{

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;

    int32_t dfid, oldcit;

    V9fsFidState *dfidp, *oldfadm;

    V9fsString name;

    size_t offset = 7;

    int err = 0;



    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldcit, &name);

    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldcit, name.data);



    dfidp = get_fid(pdu, dfid);

    if (dfidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }



    oldfadm = get_fid(pdu, oldcit);

    if (oldfadm == NULL) {

        err = -ENOENT;

        goto out;

    }

    err = v9fs_co_link(pdu, oldfadm, dfidp, &name);

    if (!err) {

        err = offset;

    }

out:

    put_fid(pdu, dfidp);

out_nofid:

    v9fs_string_free(&name);

    complete_pdu(s, pdu, err);

}
",188.0,57.0,"oldfid:oldcit,oldfidp:oldfadm,",189.0,0.0844534516334533,Greedy
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
","static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, Index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    Index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[Index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[Index];

   

    return 0;

}
",147.0,38.0,"index:Index,",79.0,0.0489982962608337,Greedy
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
","static int write_cvid_header(CinepakEncContext *ssl, unsigned char *buf, int num_wraples, int window_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], window_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], ssl->w);

    AV_WB16(&buf[6], ssl->h);

    AV_WB16(&buf[8], num_wraples);



    return CVID_HEADER_SIZE;

}
",81.0,20.0,"s:ssl,data_size:window_size,num_strips:num_wraples,",118.0,0.0622024377187093,Greedy
1404,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}","static av_cold int mpeg4video_parse_init(AVCodecParserContext *sys)

{

    ParseContext1 *ctx = sys->priv_data;



    ctx->enc = av_mallocz(sizeof(MpegEncContext));

    if (!ctx->enc)

        return -1;

    ctx->first_picture = 1;


    return 0;

}",50.0,10.0,"pc:ctx,s:sys,",91.0,0.0636505881945292,Greedy
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
","static void arm_timer_recalibrate(arm_timer_state *service, int foreloader)

{

    uint32_t model;



    if ((service->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (service->control & TIMER_CTRL_32BIT)

            model = 0xffffffff;

        else

            model = 0xffff;

    } else {

          /* Periodic.  */

          model = service->model;

    }

    ptimer_set_limit(service->timer, model, foreloader);

}
",67.0,16.0,"s:service,limit:model,reload:foreloader,",164.0,0.0905582189559936,Greedy
1417,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

{

    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, timestamp))

        return -1;

    return timestamp;

}
","static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int fee)

{

    RTMP *m = s->priv_data;



    if (fee & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(m, timestamp))

        return -1;

    return timestamp;

}
",66.0,19.0,"s:s,flags:fee,r:m,",136.0,0.0762293895085652,Greedy
1418,"static av_cold int mace_decode_init(AVCodecContext * avctx)

{

    MACEContext *ctx = avctx->priv_data;



    if (avctx->channels > 2)

        return -1;

    avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&ctx->frame);

    avctx->coded_frame = &ctx->frame;



    return 0;

}
","static av_cold int mace_decode_init(AVCodecContext * avecmp)

{

    MACEContext *ccf= avecmp->priv_data;



    if (avecmp->channels > 2)

        return -1;

    avecmp->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&cf->frame);

    avecmp->coded_frame = &cf->frame;



    return 0;

}
",56.0,12.0,"avctx:avecmp,ctx:cf,",394.0,0.2325432300567627,GA
1441,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int msg;



    msg = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(msg, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",81.0,19.0,"endptr:endptr,err:msg,",85.0,0.0630844791730245,Greedy
1445,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}
","static inline TCGv iwmmxt_load_creg(int port)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[port]));

    return var;

}
",39.0,12.0,"reg:port,",45.0,0.0349381566047668,Greedy
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
","void HELPER(set_cp_reg64)(CPUARMState *en, void *rio, uint64_t value)

{

    const ARMCPRegInfo *ri = rio;



    ri->writefn(en, ri, value);

}
",37.0,10.0,"rip:rio,env:en,",85.0,0.0625328739484151,Greedy
1447,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
","static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *qdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(qdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, qdev);

    vhost_dev_disable_notifiers(&s->dev, qdev);

}
",125.0,32.0,"vdev:qdev,",66.0,0.0468525767326355,Greedy
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int open_by_handle(int devor, const char * fH, int bits)

{

    errno = ENOSYS;

    return -1;

}
",25.0,6.0,"mountfd:devor,flags:bits,fh: fH,",63.0,0.0563744147618611,Greedy
1455,"static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 

                      int nb_codes)

{

    uint8_t huff_size[256];

    uint16_t huff_code[256];



    memset(huff_size, 0, sizeof(huff_size));

    build_huffman_codes(huff_size, huff_code, bits_table, val_table);

    

    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);

}
","static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 

                      int nb_codes)

{

    uint8_t huffplength[256];

    uint16_t huff_code[256];



    memset(huffplength, 0, sizeof(huffplength));

    build_huffman_codes(huffplength, huff_code, bits_table, val_table);

    

    init_vlc(vlc, 9, nb_codes, huffplength, 1, 1, huff_code, 2, 2);

}
",79.0,20.0,"huff_size:huffplength,",58.0,0.044309910138448,Greedy
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int strid){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*strid;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*strid;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*strid;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*strid;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",202.0,62.0,"stride:strid,",104.0,0.0667605400085449,Greedy
1461,"static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
","static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *sys = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < sys->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(sys->addr, sys->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(sys->inode.data_vdi_id);

    sys->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&sys->inode, vid_to_vdi_oid(sys->inode.vdi_id),

                       sys->inode.nr_copies, datalen, 0, false, sys->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
",179.0,41.0,"s:sys,",93.0,0.0532913009325663,Greedy
1465,"static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    VirtIOBlockReq *req;

    MultiReqBuffer mrb = {};



    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start

     * dataplane here instead of waiting for .set_status().

     */

    if (s->dataplane) {

        virtio_blk_data_plane_start(s->dataplane);

        return;

    }



    blk_io_plug(s->blk);



    while ((req = virtio_blk_get_request(s))) {

        virtio_blk_handle_request(req, &mrb);

    }



    if (mrb.num_reqs) {

        virtio_blk_submit_multireq(s->blk, &mrb);

    }



    blk_io_unplug(s->blk);

}
","static void virtio_blk_handle_output(VirtIODevice *Vdiv, VirtQueue *vq)

{

    VirtIOBlock *services = VIRTIO_BLK(Vdiv);

    VirtIOBlockReq *sq;

    MultiReqBuffer mrb = {};



    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start

     * dataplane here instead of waiting for .set_status().

     */

    if (services->dataplane) {

        virtio_blk_data_plane_start(services->dataplane);

        return;

    }



    blk_io_plug(services->blk);



    while ((sq = virtio_blk_get_request(services))) {

        virtio_blk_handle_request(sq, &mrb);

    }



    if (mrb.num_reqs) {

        virtio_blk_submit_multireq(services->blk, &mrb);

    }



    blk_io_unplug(services->blk);

}
",103.0,25.0,"req:sq,s:services,vdev:Vdiv,",166.0,0.1002417047818501,Greedy
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{

    TCGv_i32 r_asi, r_size, r_sign;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_sign);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
","static void gen_ld_asi(DisasContext *cgi, TCGv dst, TCGv arch,

                       int INSc, int sum, int carry)

{

    TCGv_i32 rMadr, r_fee, r_err;



    rMadr = gen_get_asi(cgi, INSc);

    r_fee = tcg_const_i32(sum);

    r_err = tcg_const_i32(carry);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, arch, rMadr, r_fee, r_err);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, arch, rMadr, r_fee, r_err);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_err);

    tcg_temp_free_i32(r_fee);

    tcg_temp_free_i32(rMadr);

}
",125.0,48.0,"r_asi:rMadr,dst:dst,r_size:r_fee,r_sign:r_err,size:sum,addr:arch,dc:cgi,insn:INSc,sign:carry,",387.0,0.1592495242754618,Greedy
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
","static const char *read_ts(const char *buf, int *tsprestart, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, tsprestart, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *tsprestart = 100*(ss + 60*(ms + 60*hs)) + *tsprestart/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
",185.0,48.0,"ts_start:tsprestart,",76.0,0.0363276402155558,Greedy
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
","static void compare_sec_rs_finalize(SocketReadState * sec_rss)

{

    CompareState *stats = container_of( sec_rss, CompareState,  sec_rss);



    if (packet_enqueue(stats, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&stats->conn_list, colo_compare_connection, stats);

    }

}
",55.0,15.0,"sec_rs: sec_rss,s:stats,",85.0,0.0428034782409667,Greedy
1486,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();","void HELPER(access_check_cp_reg)(CPUARMState *gui, void *region, uint32_t syndrome)
{
    const ARMCPRegInfo *ai = region;
    switch (ai->accessfn(gui, ai)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        gui->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();",66.0,15.0,"env:gui,ri:ai,rip:region,",150.0,0.0745928883552551,Greedy
1488,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;



    if (in[n] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)

            f1 += in[x-y]*tgt[y];



        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }

        if ((f0 += f1*f2) < 0)

            return 0;

    }



    return 1;

}
","static int eval_lpc_coeffs(const float *conn, float *tgz, int l)

{

    int x, y;

    double f0, Fone,  f4;



    if (conn[l] == 0)

        return 0;



    if ((f0 = *conn) <= 0)

        return 0;



    conn--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= l; x++) {

        Fone = conn[x+1];



        for (y=0; y < x - 1; y++)

            Fone += conn[x-y]*tgz[y];



        tgz[x-1] =  f4 = -Fone/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgz[y] + tgz[x-y-2]* f4;

            tgz[x-y-2] += tgz[y]* f4;

            tgz[y] = temp;

        }

        if ((f0 += Fone* f4) < 0)

            return 0;

    }



    return 1;

}
",204.0,59.0,"in:conn,tgt:tgz,f2: f4,f1:Fone,f0:f0,x:x,n:l,",392.0,0.1807331919670105,Greedy
1490,"void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);","void pc_hot_add_cpu(const int64_t oid, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(oid);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", oid);
    if (oid >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", oid, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",96.0,29.0,"id:oid,",66.0,0.0323499202728271,Greedy
1514,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void *opaque, int ret), void *opaque)

{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,

                       DMA_DIRECTION_TO_DEVICE);

}
","BlockAIOCB *dma_bdrv_write(BlockDriverState *bd,

                           QEMUSGList *sis, uint64_t buf,

                           void (*ob)(void * opaques, int ret), void * opaques)

{

    return dma_bdrv_io(bd, sis, buf, bdrv_aio_writev, ob,  opaques,

                       DMA_DIRECTION_TO_DEVICE);

}
",53.0,16.0,"sg:sis,bs:bd,sector:buf,opaque: opaques,cb:ob,",203.0,0.1199183344841003,Greedy
1516,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
","static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t std;

    BDRVArchipelagoState *stats = bs->opaque;



    std = archipelago_volume_info(stats);

    return std;

}
",31.0,9.0,"ret:std,s:stats,",98.0,0.0543121616045634,Greedy
1537,"void serial_realize_core(SerialState *s, Error **errp)

{

    if (!qemu_chr_fe_backend_connected(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }



    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);



    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, s, NULL, true);

    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(s);

}
","void serial_realize_core(SerialState *http, Error ** errr)

{

    if (!qemu_chr_fe_backend_connected(&http->chr)) {

        error_setg( errr, ""Can't create serial device, empty char device"");

        return;

    }



    http->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, http);



    http->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, http);

    qemu_register_reset(serial_reset, http);



    qemu_chr_fe_set_handlers(&http->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, http, NULL, true);

    fifo8_create(&http->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&http->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(http);

}
",125.0,34.0,"s:http,errp: errr,",114.0,0.0696084896723429,Greedy
1540,"static void blockdev_do_action(int kind, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
","static void blockdev_do_action(int kind, void *key, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.key = key;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
",57.0,16.0,"data:key,",73.0,0.0482803662618001,Greedy
1547,"static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
","static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *self = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", self);

    return virtio_scsi_common_exit(vs);

}
",44.0,13.0,"s:self,",52.0,0.0412994861602783,Greedy
1549,"static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        g_free(s->filename);

    }



    s->filename = g_strdup(filename);

}
","static void rng_random_set_filename(Object *g, const char *filename,

                                 Error **errp)

{

    RngBackend *r = RNG_BACKEND(g);

    RndRandom *g = RNG_RANDOM(g);



    if (r->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (g->filename) {

        g_free(g->filename);

    }



    g->filename = g_strdup(filename);

}
",79.0,20.0,"obj:g,b:r,s:g,",153.0,0.09914098183314,Greedy
1554,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}
","static void virtio_scsi_parse_req(VirtIOSCSI *sys, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = sys;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}
",172.0,27.0,"s:sys,",69.0,0.0471079428990681,Greedy
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return info->init(dev);



err:

    return -1;

}
","static int ide_qdev_init(DeviceState * qdiff, DeviceInfo *base)

{

    IDEDevice *device = DO_UPCAST(IDEDevice,  qdiff,  qdiff);

    IDEDeviceInfo *bug = DO_UPCAST(IDEDeviceInfo,  qdiff, base);

    IDEBus *device = DO_UPCAST(IDEBus, qbus,  qdiff->parent_bus);



    if (!device->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"",  qdiff->bug->name);

        goto err;

    }

    if (device->unit == -1) {

        device->unit = device->master ? 1 : 0;

    }

    switch (device->unit) {

    case 0:

        if (device->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        device->master = device;

        break;

    case 1:

        if (device->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        device->slave = device;

        break;

    default:

        goto err;

    }

    return bug->init(device);



err:

    return -1;

}
",194.0,38.0,"info:bug,qdev: qdiff,dev:device,bus:device,",273.0,0.145513121287028,Greedy
1566,"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf1, int count1)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, buf1, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bs, offset, buf1, count1);

}
","int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf1, int count1)

{

    BlockDriver * drb = bs-> drb;



    if (! drb)

        return -ENOMEDIUM;

    if (! drb->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, buf1, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return  drb->bdrv_pwrite(bs, offset, buf1, count1);

}
",85.0,25.0,"drv: drb,",65.0,0.0451094309488932,Greedy
1567,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}
","static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *transfer;

    int ret;

    char *path = fs_path->data;



    transfer = rpath(ctx, path);

    ret = truncate(transfer, size);

    g_free(transfer);

    return ret;

}
",58.0,19.0,"buffer:transfer,",68.0,0.045370598634084,Greedy
1569,"static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
","static int stellaris_enet_can_receive(void * opasma)

{

    stellaris_enet_state *b = (stellaris_enet_state *) opasma;



    if ((b->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (b->np < 31);

}
",44.0,7.0,"opaque: opasma,s:b,",84.0,0.0524866422017415,Greedy
1577,"static void display_mouse_define(DisplayChangeListener *dcl,

                                 QEMUCursor *c)

{

    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);



    qemu_mutex_lock(&ssd->lock);

    if (c) {

        cursor_get(c);

    }

    cursor_put(ssd->cursor);

    ssd->cursor = c;

    ssd->hot_x = c->hot_x;

    ssd->hot_y = c->hot_y;

    g_free(ssd->ptr_move);

    ssd->ptr_move = NULL;

    g_free(ssd->ptr_define);

    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);

    qemu_mutex_unlock(&ssd->lock);

}
","static void display_mouse_define(DisplayChangeListener * dcel,

                                 QEMUCursor *c)

{

    SimpleSpiceDisplay *cssdb = container_of( dcel, SimpleSpiceDisplay,  dcel);



    qemu_mutex_lock(&cssdb->lock);

    if (c) {

        cursor_get(c);

    }

    cursor_put(cssdb->cursor);

    cssdb->cursor = c;

    cssdb->hot_x = c->hot_x;

    cssdb->hot_y = c->hot_y;

    g_free(cssdb->ptr_move);

    cssdb->ptr_move = NULL;

    g_free(cssdb->ptr_define);

    cssdb->ptr_define = qemu_spice_create_cursor_update(cssdb, c, 0);

    qemu_mutex_unlock(&cssdb->lock);

}
",116.0,32.0,"ssd:cssdb,dcl: dcel,",151.0,0.0743678530057271,Greedy
1588,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
","static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *srpc, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        srpc[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
",145.0,32.0,"rsp:srpc,",51.0,0.0274056315422058,Greedy
1591,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}
","static void enable_device(AcpiPciHpState *s, unsigned fbsels, int slot)

{

    s->acpi_pcihp_pci_status[fbsels].device_present |= (1U << slot);

}
",31.0,7.0,"bsel:fbsels,",31.0,0.0285307566324869,Greedy
1596,"static int setup_sigcontext(struct target_sigcontext *sc,

                            CPUSH4State *regs, unsigned long mask)

{

    int err = 0;

    int i;



#define COPY(x)         __put_user(regs->x, &sc->sc_##x)

    COPY(gregs[0]); COPY(gregs[1]);

    COPY(gregs[2]); COPY(gregs[3]);

    COPY(gregs[4]); COPY(gregs[5]);

    COPY(gregs[6]); COPY(gregs[7]);

    COPY(gregs[8]); COPY(gregs[9]);

    COPY(gregs[10]); COPY(gregs[11]);

    COPY(gregs[12]); COPY(gregs[13]);

    COPY(gregs[14]); COPY(gregs[15]);

    COPY(gbr); COPY(mach);

    COPY(macl); COPY(pr);

    COPY(sr); COPY(pc);

#undef COPY



    for (i=0; i<16; i++) {

        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);

    }

    __put_user(regs->fpscr, &sc->sc_fpscr);

    __put_user(regs->fpul, &sc->sc_fpul);



    /* non-iBCS2 extensions.. */

    __put_user(mask, &sc->oldmask);



    return err;

}
","static int setup_sigcontext(struct target_sigcontext *sub,

                            CPUSH4State *regs, unsigned long mask)

{

    int err = 0;

    int i;



#define COPY(x)         __put_user(regs->x, &sc->sc_##x)

    COPY(gregs[0]); COPY(gregs[1]);

    COPY(gregs[2]); COPY(gregs[3]);

    COPY(gregs[4]); COPY(gregs[5]);

    COPY(gregs[6]); COPY(gregs[7]);

    COPY(gregs[8]); COPY(gregs[9]);

    COPY(gregs[10]); COPY(gregs[11]);

    COPY(gregs[12]); COPY(gregs[13]);

    COPY(gregs[14]); COPY(gregs[15]);

    COPY(gbr); COPY(mach);

    COPY(macl); COPY(pr);

    COPY(sr); COPY(pc);

#undef COPY



    for (i=0; i<16; i++) {

        __put_user(regs->fregs[i], &sub->sc_fpregs[i]);

    }

    __put_user(regs->fpscr, &sub->sc_fpscr);

    __put_user(regs->fpul, &sub->sc_fpul);



    /* non-iBCS2 extensions.. */

    __put_user(mask, &sub->oldmask);



    return err;

}
",265.0,70.0,"sc:sub,",74.0,0.0497036019961039,Greedy
1608,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    int64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);



    mr = host_memory_backend_get_memory(dimm->hostmem, errp);

    value = memory_region_size(mr);



    visit_type_int(v, name, &value, errp);

}
","static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    int64_t values;

    MemoryRegion *mer;

    PCDIMMDevice *Dim = PC_DIMM(obj);



    mer = host_memory_backend_get_memory(Dim->hostmem, errp);

    values = memory_region_size(mer);



    visit_type_int(v, name, &values, errp);

}
",74.0,23.0,"mr:mer,dimm:Dim,value:values,",132.0,0.0867950280507405,Greedy
1619,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
","void do_delvm(Monitor *mat, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *fee = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mat, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &fee);

            if (fee) {

                monitor_printf(mat,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(fee));

                error_free(fee);

            }

        }

    }

}
",132.0,33.0,"mon:mat,err:fee,",130.0,0.0716243068377176,Greedy
1620,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
","void object_property_add(Object *node, const char *node, const char *types,

                         ObjectPropertyAccessor *read,

                         ObjectPropertyAccessor *read,

                         ObjectPropertyRelease *raise,

                         void *spaques, Error **errp)

{

    ObjectProperty *pb;



    QTAILQ_FOREACH(pb, &node->properties, node) {

        if (strcmp(pb->node, node) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", node,

                       object_get_typename(node));

            return;

        }

    }



    pb = g_malloc0(sizeof(*pb));



    pb->node = g_strdup(node);

    pb->types = g_strdup(types);



    pb->read = read;

    pb->read = read;

    pb->raise = raise;

    pb->spaques = spaques;



    QTAILQ_INSERT_TAIL(&node->properties, pb, node);

}
",157.0,43.0,"errp:errp,obj:node,opaque:spaques,prop:pb,set:read,release:raise,name:node,get:read,type:types,",422.0,0.2590730627377828,Greedy
1623,"static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct ioreq *ioreq;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        ioreq = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(ioreq);

	ioreq_release(ioreq);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
","static void blk_send_response_all(struct XenBlkDev *Blkdiv)

{

    struct  ioresc * ioresc;

    int send_notify = 0;



    while (!LIST_EMPTY(&Blkdiv->finished)) {

         ioresc = LIST_FIRST(&Blkdiv->finished);

	send_notify += blk_send_response_one( ioresc);

	ioreq_release( ioresc);

    }

    if (send_notify)

	xen_be_send_notify(&Blkdiv->xendev);

}
",68.0,17.0,"ioreq: ioresc,blkdev:Blkdiv,",176.0,0.0887367169062296,Greedy
1628,"static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *fp = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
","static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *farm = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*farm));

    env->fpuc = farm->fpuc;

    env->fpstt = (farm->fpus >> 11) & 7;

    env->fpus = farm->fpus & ~0x3800;

    fptag = farm->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &farm->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
",206.0,40.0,"fp:farm,",101.0,0.0609161814053853,Greedy
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);

}
","static int virtio_blk_exit_pci(PCIDevice *pci__dev)

{

    VirtIOPCIProxy *pc = DO_UPCAST(VirtIOPCIProxy, pci__dev, pci__dev);



    blockdev_mark_auto_del(pc->block.dinfo->bdrv);

    return virtio_exit_pci(pci__dev);

}
",40.0,11.0,"pci_dev:pci__dev,proxy:pc,",76.0,0.0456241965293884,Greedy
1639,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
","static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *stats = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(stats);

}
",56.0,13.0,"s:stats,",52.0,0.033369775613149,Greedy
1640,"static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
","static void gen_neon_unzip(int reg, int qa, int tmp, int size)

{

    int n;

    TCGv  t100, t1;



    for (n = 0; n < qa + 1; n += 2) {

         t100 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8( t100, t1); break;

        case 1: gen_neon_zip_u16( t100, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n,  t100);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
",126.0,36.0,"q:qa,t0: t100,",103.0,0.0560344497362772,Greedy
1643,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
","static int compare_int64(const void *aw, const void *as)

{

    int64_t va = *(int64_t *)aw, vb = *(int64_t *)as;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
",50.0,11.0,"b:as,a:aw,",75.0,0.0468081752459208,Greedy
1672,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,

                             TCGReg rd, TCGReg rn, uint64_t limm)

{

    unsigned h, l, r, c;



    assert(is_limm(limm));



    h = clz64(limm);

    l = ctz64(limm);

    if (l == 0) {

        r = 0;                  /* form 0....01....1 */

        c = ctz64(~limm) - 1;

        if (h == 0) {

            r = clz64(~limm);   /* form 1..10..01..1 */

            c += r;

        }

    } else {

        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */

        c = r - h - 1;

    }

    if (ext == TCG_TYPE_I32) {

        r &= 31;

        c &= 31;

    }



    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);

}
","static void tcg_out_logicali(TCGContext *spec, AArch64Insn insn, TCGType dep,

                             TCGReg RR, TCGReg rc, uint64_t logms)

{

    unsigned err, b, v, v;



    assert(is_limm(logms));



    err = clz64(logms);

    b = ctz64(logms);

    if (b == 0) {

        v = 0;                  /* form 0....01....1 */

        v = ctz64(~logms) - 1;

        if (err == 0) {

            v = clz64(~logms);   /* form 1..10..01..1 */

            v += v;

        }

    } else {

        v = 64 - b;             /* form 1....10....0 or 0..01..10..0 */

        v = v - err - 1;

    }

    if (dep == TCG_TYPE_I32) {

        v &= 31;

        v &= 31;

    }



    tcg_out_insn_3404(spec, insn, dep, RR, rc, dep, v, v);

}
",150.0,49.0,"insn:insn,h:err,r:v,limm:logms,c:v,s:spec,l:b,rd:RR,rn:rc,ext:dep,",459.0,0.2642111738522847,Greedy
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
","static int vmdk_reopen_prepare(BDRVReopenState *set,

                               BlockReopenQueue *Q, Error **errp)

{

    BDRVVmdkState *services;

    int ret = -1;

    int i;

    VmdkExtent *esi;



    assert(set != NULL);

    assert(set->bs != NULL);



    if (Q == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    services = set->bs->opaque;



    assert(services != NULL);



    for (i = 0; i < services->num_extents; i++) {

        esi = &services->extents[i];

        if (esi->file != set->bs->file) {

            bdrv_reopen_queue(Q, esi->file, set->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",148.0,34.0,"queue:Q,e:esi,s:services,state:set,",236.0,0.1441057999928792,Greedy
1695,"void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_se;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}
","void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_parse;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_parse) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}
",89.0,24.0,"new_se:new_parse,",32.0,0.0289289037386576,Greedy
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);

    if (info->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
","static int qdev_print_devinfo(DeviceInfo *diff, char *result, int data)

{

    int pos = 0;



    pos += snprintf(result+pos, data-pos, ""name \""%s\"", bus %s"",

                    diff->name, diff->bus_info->name);

    if (diff->alias)

        pos += snprintf(result+pos, data-pos, "", alias \""%s\"""", diff->alias);

    if (diff->desc)

        pos += snprintf(result+pos, data-pos, "", desc \""%s\"""", diff->desc);

    if (diff->no_user)

        pos += snprintf(result+pos, data-pos, "", no-user"");

    return pos;

}
",131.0,37.0,"info:diff,len:data,dest:result,",196.0,0.1104649504025777,Greedy
1706,"int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_sectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) len;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);

    }

}","int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_nectors)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_nectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) len;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_nectors);

    }

}",129.0,33.0,"nb_sectors:nb_nectors,",77.0,0.0398882031440734,Greedy
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
","static int make_cdt24_entry(int p1, int p2, int16_t * cdrt)

{

    int r, lb;



    lb =  cdrt[p2];

    r =  cdrt[p1]<<16;

    return (lb+r) << 1;

}
",46.0,14.0,"cdt: cdrt,b:lb,",92.0,0.050369111696879,Greedy
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *ssl,

                                                         PutBitContext *pb, const float *min, float *no,

                                                         const float * scased, int size, int scale_indg,

                                                         int bf, const float fun, const float uplims,

                                                         int *bits, const float WOUNDING) {

    int c;

    if (bits)

        *bits = 0;

    if (no) {

        for (c = 0; c < size; c += 4) {

           no[c  ] = 0.0f;

           no[c+1] = 0.0f;

           no[c+2] = 0.0f;

           no[c+3] = 0.0f;

        }

    }

}
",122.0,29.0,"s:ssl,lambda:fun,scale_idx:scale_indg,scaled: scased,uplim:uplims,in:min,i:c,cb:bf,out:no,ROUNDING:WOUNDING,",344.0,0.173637318611145,Greedy
1725,"static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
","static void mmap_release_buffer(AVPacket *Pcht)

{

    struct v4l2_buffer buf;

    int res, raf;

    struct buff_data *buf_descriptor = Pcht->priv;



    if (Pcht->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    raf = buf_descriptor->raf;

    av_free(buf_descriptor);



    res = ioctl(raf, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    Pcht->data = NULL;

    Pcht->size = 0;

}
",129.0,32.0,"res:res,buf:buf,buf_descriptor:buf_descriptor,pkt:Pcht,fd:raf,",276.0,0.1402799248695373,Greedy
1726,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
","static void coroutine_fn c1_fn(void *octaque)

{

    Coroutine *c2 = octaque;

    qemu_coroutine_enter(c2, NULL);

}
",25.0,7.0,"opaque:octaque,",33.0,0.020405371983846,Greedy
1727,"static int write_target_commit(BlockDriverState *bs, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* s = bs->opaque;

    return try_commit(s);

}
","static int write_target_commit(BlockDriverState *ns, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* state = ns->opaque;

    return try_commit(state);

}
",35.0,9.0,"s:state,bs:ns,",87.0,0.0552342891693115,Greedy
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
","static void sdhci_write_dataport(SDHCIState *s, uint32_t money, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = money & 0xFF;

        s->data_count++;

        money >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
",138.0,29.0,"value:money,",79.0,0.0473540385564168,Greedy
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
","static int read_quant_table(RangeCoder *c, int16_t *quant_tree, int scale)

{

    int vid;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (vid = 0; i < 128; vid++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_tree[i] = scale * vid;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_tree[256 - i] = -quant_tree[i];

    quant_tree[128] = -quant_tree[127];



    return 2 * vid - 1;

}
",146.0,37.0,"v:vid,quant_table:quant_tree,",168.0,0.0810736457506815,Greedy
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
","static int ffserver_set_int_param(int *result, const char *value, int factor,

                                  int min, int height, FFServerConfig *plugin,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > height)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (result)

        *result = tmp;

    return 0;

  error:

    if (plugin) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(plugin->filename, plugin->line_num, AV_LOG_ERROR,

                &plugin->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",187.0,50.0,"dest:result,max:height,config:plugin,",183.0,0.1077572464942932,Greedy
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}
","static int64_t find_tag(AVIOContext *ab, uint32_t tag1)

{

    unsigned int patch;

    int64_t size;



    for (;;) {

        if (url_feof(ab))

            return AVERROR_EOF;

        size = next_tag(ab, &patch);

        if (patch == tag1)

            break;

        wav_seek_tag(ab, size, SEEK_CUR);

    }

    return size;

}
",67.0,19.0,"tag:patch,pb:ab,",115.0,0.0622860232988993,Greedy
1758,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}
","static inline void get_limits(MpegEncContext *s, int *diff, int *xmin, int *ymin, int *xmax, int *ymit, int f__count)

{

    *diff = 8 * (1 << (f__count - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*diff *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *diff *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymit = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymit = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymit = s->mb_height*16 - 16;

    }

}
",180.0,35.0,"f_code:f__count,range:diff,ymax:ymit,",164.0,0.0948234677314758,Greedy
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
","static void mclms_predict(WmallDecodeCtx *ctx, int iscalf, int *stat)

{

    int cm, i;

    int order        = ctx->mclms_order;

    int num_channels = ctx->num_channels;



    for (cm = 0; cm < num_channels; cm++) {

        stat[cm] = 0;

        if (!ctx->is_channel_coded[cm])

            continue;

        for (i = 0; i < order * num_channels; i++)

            stat[cm] += ctx->mclms_prevvalues[i + ctx->mclms_recent] *

                         ctx->mclms_coeffs[i + order * num_channels * cm];

        for (i = 0; i < cm; i++)

            stat[cm] += ctx->channel_residues[i][iscalf] *

                         ctx->mclms_coeffs_cur[i + num_channels * cm];

        stat[cm] += 1 << ctx->mclms_scaling - 1;

        stat[cm] >>= ctx->mclms_scaling;

        ctx->channel_residues[cm][iscalf] += stat[cm];

    }

}
",190.0,57.0,"ich:cm,s:ctx,icoef:iscalf,pred:stat,",310.0,0.150513736406962,Greedy
1774,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
","uint32_t HELPER(clz)(uint32_t data)

{

    int e;

    for (coue32; data; e--)

        data >>= 1;

    return e;

}
",32.0,8.0,"x:data,count:e,",349.0,0.2123440345128377,GA
1786,"void tlb_flush_page(CPUState *env, target_ulong addr)

{

    int i;



#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    env->current_tb = NULL;



    addr &= TARGET_PAGE_MASK;

    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&env->tlb_table[0][i], addr);

    tlb_flush_entry(&env->tlb_table[1][i], addr);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&env->tlb_table[2][i], addr);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&env->tlb_table[3][i], addr);

#endif

#endif



    tlb_flush_jmp_cache(env, addr);



#ifdef USE_KQEMU

    if (env->kqemu_enabled) {

        kqemu_flush_page(env, addr);

    }

#endif

}
","void tlb_flush_page(CPUState *viron, target_ulong hop)

{

    int v;



#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", hop);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    viron->current_tb = NULL;



    hop &= TARGET_PAGE_MASK;

    v = (hop >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&viron->tlb_table[0][v], hop);

    tlb_flush_entry(&viron->tlb_table[1][v], hop);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&viron->tlb_table[2][v], hop);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&viron->tlb_table[3][v], hop);

#endif

#endif



    tlb_flush_jmp_cache(viron, hop);



#ifdef USE_KQEMU

    if (viron->kqemu_enabled) {

        kqemu_flush_page(viron, hop);

    }

#endif

}
",163.0,41.0,"addr:hop,i:v,env:viron,",242.0,0.1192297538121541,Greedy
1790,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}
","static int find_dirty_height(VncState *vs, int y, int last_x, int px)

{

    int code;



    for (code = 1; code < (vs->serverds.height - y); code++) {

        int  tmp_name;

        if (!vnc_get_bit(vs->dirty_row[y + code], last_x))

            break;

        for ( tmp_name = last_x;  tmp_name < px;  tmp_name++)

            vnc_clear_bit(vs->dirty_row[y + code],  tmp_name);

    }



    return code;

}
",97.0,28.0,"h:code,x:px,tmp_x: tmp_name,",144.0,0.093963078657786,Greedy
1792,"static void add_index_entry(AVStream *st,

                            int64_t pos, int64_t timestamp, int flags)

{

    AVIndexEntry *entries, *ie;

    

    entries = av_fast_realloc(st->index_entries,

                              &st->index_entries_allocated_size,

                              (st->nb_index_entries + 1) * 

                              sizeof(AVIndexEntry));

    if (entries) {

        st->index_entries = entries;

        ie = &entries[st->nb_index_entries++];

        ie->pos = pos;

        ie->timestamp = timestamp;

        ie->flags = flags;

    }

}
","static void add_index_entry(AVStream *st,

                            int64_t pos, int64_t timestamp, int flags)

{

    AVIndexEntry *endrance, *ie;

    

    endrance = av_fast_realloc(st->index_entries,

                              &st->index_entries_allocated_size,

                              (st->nb_index_entries + 1) * 

                              sizeof(AVIndexEntry));

    if (endrance) {

        st->index_entries = endrance;

        ie = &endrance[st->nb_index_entries++];

        ie->pos = pos;

        ie->timestamp = timestamp;

        ie->flags = flags;

    }

}
",94.0,25.0,"entries:endrance,",90.0,0.0534887711207071,Greedy
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
","static void put_uint64(QEMUFile *file, void *cpv, size_t fff)

{

    uint64_t *sv = cpv;

    qemu_put_be64s(file, sv);

}
",30.0,9.0,"v:sv,f:file,size:fff,pv:cpv,",122.0,0.0714182456334431,Greedy
1800,"static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}
","static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *Buffer, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, Buffer, len);



        ffm->packet_ptr += len;

        Buffer += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}
",151.0,42.0,"buf:Buffer,",94.0,0.0622292518615722,Greedy
1802,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}
","static void FUNCC(pred4x4_horizontal_add)(uint8_t * _pox, const int16_t *_image,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pprix= (pixel*) _pox;

    const dctcoef *position = (const dctcoef*)_image;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = prix[-1];

        prix[0]= v += position[0];

        prix[1]= v += position[1];

        prix[2]= v += position[2];

        prix[3]= v +  position[3];

        prix+= stride;

        position+= 4;

    }

}
",134.0,31.0,"_pix: _pox,_block:_image,stride:stride,i:i,pix:prix,block:position,",414.0,0.266354485352834,GA
1805,"int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)

{

    cl_int status;

    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,

                                      CL_TRUE,CL_MAP_READ, 0, buf_size,

                                      0, NULL, NULL, &status);



    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    memcpy(dst_buf, mapped, buf_size);



    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);

    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    return 0;

}
","int av_opencl_buffer_read(uint8_t *drc_queue, cl_mem src_pl_cb, size_t buf_size)

{

    cl_int temp;

    void *mamped = clEnqueueMapBuffer(gpu_env.command_queue, src_pl_cb,

                                      CL_TRUE,CL_MAP_READ, 0, buf_size,

                                      0, NULL, NULL, &temp);



    if (temp != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(temp));

        return AVERROR_EXTERNAL;

    }

    memcpy(drc_queue, mamped, buf_size);



    temp = clEnqueueUnmapMemObject(gpu_env.command_queue, src_pl_cb, mamped, 0, NULL, NULL);

    if (temp != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(temp));

        return AVERROR_EXTERNAL;

    }

    return 0;

}
",135.0,38.0,"dst_buf:drc_queue,mapped:mamped,src_cl_buf:src_pl_cb,status:temp,",162.0,0.1078323562939961,Greedy
1809,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    f->xfer_limit = limit;

}
","void qemu_file_set_rate_limit(QEMUFile *f, int64_t offset)

{

    f->xfer_limit = offset;

}
",18.0,5.0,"limit:offset,",48.0,0.0372160037358601,Greedy
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errpc)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errpc);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errpc, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
",102.0,27.0,"errp:errpc,",59.0,0.0373281637827555,Greedy
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
","int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int Offset;



    Offset = fdt_path_offset(fdt, node_path);

    if (Offset < 0)

        return Offset;



    return fdt_setprop_string(fdt, Offset, property, string);

}
",57.0,17.0,"offset:Offset,",78.0,0.0466185331344604,Greedy
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
","static void rc4030_dma_as_update_one(rc4030State *s, int offset, uint32_t iframe)

{

    if (offset < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[offset], false);

    }



    if (!iframe) {

        return;

    }



    if (offset >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      offset, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[offset], iframe);

    memory_region_set_enabled(&s->dma_mrs[offset], true);

}
",96.0,23.0,"frame:iframe,index:offset,",140.0,0.081958266099294,Greedy
1822,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);

}
","static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *fdef,

                                              VirtQueue *tveq)

{

    VirtIOSCSI *sf = (VirtIOSCSI *)fdef;



    assert(sf->ctx && sf->dataplane_started);

    return virtio_scsi_handle_cmd_vq(sf, tveq);

}
",43.0,11.0,"vq:tveq,s:sf,vdev:fdef,",119.0,0.0781184673309326,Greedy
1830,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}
","static void dyn_buf_write(void *opaques, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaques;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}
",169.0,48.0,"opaque:opaques,",78.0,0.0497923731803894,Greedy
1832,"static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
","static int hex_to_data(uint8_t *Data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (Data)

                Data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
",150.0,33.0,"data:Data,",76.0,0.0519530216852823,Greedy
1836,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);","static void bitmap_free(Qcow2Bitmap *bt)
{
    g_free(bt->name);
    g_free(bt);",22.0,6.0,"bm:bt,",54.0,0.0402119199434916,Greedy
1845,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
","static void add_bytes_l2_c(uint8_t *sdbl, uint8_t *src1, uint8_t *rc0, int wave)

{

    long i;

    for (i =i0; i <i wave - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(rc0 + i);

        *(long *)(sdbl + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i <iwave; i++)

        sdblii] = src1ii] + rc0[i];

}
",136.0,34.0,"dst:sdbl,src1:src1,src2:rc0,w:wave,i:i,",343.0,0.2187876145044962,GA
1851,"static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        locty_data->r_buffer.size);

}
","static int tpm_passthrough_unix_transfer(int tpm67db,

                                         const TPMLocality *loctysreader)

{

    return tpm_passthrough_unix_tx_bufs(tpm67db,

                                        loctysreader->w_buffer.buffer,

                                        loctysreader->w_offset,

                                        loctysreader->r_buffer.buffer,

                                        loctysreader->r_buffer.size);

}
",42.0,9.0,"locty_data:loctysreader,tpm_fd:tpm67db,",86.0,0.0544030388196309,Greedy
1852,"void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
","void do_tw (int s)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (s & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (s & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (s & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (s & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (s & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
",116.0,21.0,"flags:s,",68.0,0.0447141011555989,Greedy
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
","static void test_validate_fail_union_anon(TestInputVisitorData *m,

                                          const void * unbinitialized)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *vp;

    Error * erP = NULL;



    vp = validate_test_init(m, ""3.14"");



    visit_type_UserDefAnonUnion(vp, &tmp, NULL, & erP);

    g_assert(error_is_set(& erP));

    qapi_free_UserDefAnonUnion(tmp);

}
",68.0,18.0,"unused: unbinitialized,errp: erP,tmp:tmp,v:vp,data:m,",200.0,0.1113383332888285,Greedy
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
","void cpu_dump_state(CPUState *viron, FILE *fb, fprintf_function cpu_forprint,

        int fun)

{

    int uri;



    cpu_forprint(fb, ""PC=%08x\n"", viron->pc);



    for (uri = 0; uri < 16; ++uri) {

        cpu_forprint(fb, ""A%02d=%08x%c"", uri, viron->regs[uri],

                (uri % 4) == 3 ? '\n' : ' ');

    }

}
",82.0,18.0,"env:viron,f:fb,cpu_fprintf:cpu_forprint,flags:fun,i:uri,",226.0,0.1161553978919982,Greedy
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
","void visit_type_bool(Visitor *api, bool *det, const char *time, Error **ercp)

{

    if (!error_is_set(ercp)) {

        api->type_bool(api, det, time, ercp);

    }

}
",46.0,12.0,"v:api,errp:ercp,name:time,obj:det,",161.0,0.0826144019762675,Greedy
1887,"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)

{

    ssize_t ret;

    guint watch;



    assert(qemu_in_coroutine());

    /* Negotiation are always in main loop. */

    watch = qio_channel_add_watch(ioc,

                                  G_IO_OUT,

                                  nbd_negotiate_continue,

                                  qemu_coroutine_self(),

                                  NULL);

    ret = write_sync(ioc, buffer, size, NULL);

    g_source_remove(watch);

    return ret;

}
","static int nbd_negotiate_write(QIOChannel *ioci, const void *buffer, size_t size)

{

    ssize_t  result;

    guint push;



    assert(qemu_in_coroutine());

    /* Negotiation are always in main loop. */

    push = qio_channel_add_watch(ioci,

                                  G_IO_OUT,

                                  nbd_negotiate_continue,

                                  qemu_coroutine_self(),

                                  NULL);

     result = write_sync(ioci, buffer, size, NULL);

    g_source_remove(push);

    return  result;

}
",69.0,22.0,"ioc:ioci,ret: result,watch:push,",163.0,0.0975662151972452,Greedy
1889,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void spr_read_tbu (DisasContext *ctx, int  gPrn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[ gPrn], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
",51.0,14.0,"gprn: gPrn,",47.0,0.0350024660428365,Greedy
1894,"static void test_info_commands(void)

{

    char *resp, *info, *info_buf, *endp;



    info_buf = info = hmp(""help info"");



    while (*info) {

        /* Extract the info command, ignore parameters and description */

        g_assert(strncmp(info, ""info "", 5) == 0);

        endp = strchr(&info[5], ' ');

        g_assert(endp != NULL);

        *endp = '\0';

        /* Now run the info command */

        if (verbose) {

            fprintf(stderr, ""\t%s\n"", info);

        }

        resp = hmp(info);

        g_free(resp);

        /* And move forward to the next line */

        info = strchr(endp + 1, '\n');

        if (!info) {

            break;

        }

        info += 1;

    }



    g_free(info_buf);

}
","static void test_info_commands(void)

{

    char *resp, *info, *info2uf, *endp;



    info2uf = info = hmp(""help info"");



    while (*info) {

        /* Extract the info command, ignore parameters and description */

        g_assert(strncmp(info, ""info "", 5) == 0);

        endp = strchr(&info[5], ' ');

        g_assert(endp != NULL);

        *endp = '\0';

        /* Now run the info command */

        if (verbose) {

            fprintf(stderr, ""\t%s\n"", info);

        }

        resp = hmp(info);

        g_free(resp);

        /* And move forward to the next line */

        info = strchr(endp + 1, '\n');

        if (!info) {

            break;

        }

        info += 1;

    }



    g_free(info2uf);

}
",142.0,34.0,"info_buf:info2uf,",54.0,0.0318726420402526,Greedy
1915,"static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *ctx = avctx->priv_data;

    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}
","static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *cas = avctx->priv_data;

    av_freep(&cas->buf);

    cas->buf_size = 0;

    return 0;

}
",36.0,8.0,"ctx:cas,",54.0,0.0371001362800598,Greedy
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    int start_track, format, msf, toclen;

    uint64_t nb_sectors;



    msf = req->cmd.buf[1] & 2;

    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}
","static int scsi_disk_emulate_read_toc(SCSIRequest *err, uint8_t *outbuf)

{

    SCSIDiskState *services = DO_UPCAST(SCSIDiskState, qdev, err->dev);

    int start_track, pattern, msf, toclen;

    uint64_t nb_sectors;



    msf = err->cmd.buf[1] & 2;

    pattern = err->cmd.buf[2] & 0xf;

    start_track = err->cmd.buf[6];

    bdrv_get_geometry(services->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, pattern, msf >> 1);

    nb_sectors /= services->qdev.blocksize / 512;

    switch (pattern) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}
",206.0,48.0,"nb_sectors:nb_sectors,start_track:start_track,toclen:toclen,msf:msf,outbuf:outbuf,req:err,s:services,format:pattern,",443.0,0.2006162166595459,Greedy
1917,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
","void bdrv_invalidate_cache(BlockDriverState *bs, Error **Err)

{

    Error *local_err = NULL;

    int bit;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(Err, local_err);

        return;

    }



    bit = refresh_total_sectors(bs, bs->total_sectors);

    if (bit < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(Err, -bit, ""Could not refresh total sector count"");

        return;

    }

}
",158.0,34.0,"errp:Err,ret:bit,",111.0,0.0574891527493794,Greedy
1921,"static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
","static int cookie_string(AVDictionary *dict, char ** cookries)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (* cookries) av_free(* cookries);

    * cookries = av_malloc(len);

    if (! cookries) return AVERROR(ENOMEM);

    * cookries[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(* cookries, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
",143.0,36.0,"cookies: cookries,",75.0,0.0446213324864705,Greedy
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fnt;



    /* accept both hex and decimal */

    fnt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fnt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"fmt:fnt,",48.0,0.0359323461850484,Greedy
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *label)

{

    HuffEntry e[1024];

    uint32_t cases[1024];

    uint8_t bits[1024];

    uint16_t asym[1024];

    uint32_t address;

    int i;



    for (i = 0; i < 1024; i++) {

        e[i].sym = 1023 - i;

        e[i].label = label[i];



    }

    AV_QSORT(e, 1024, HuffEntry, huff_cmp_len10);



    address = 1;

    for (i = 1023; i >= 0; i--) {

        cases[i] = address >> (32 - e[i].label);

        bits[i]  = e[i].label;

        asym[i]  = e[i].sym;

        address += 0x80000000u >> (e[i].label - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(e[1023].label, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              cases, sizeof(*cases), sizeof(*cases),

                              asym,  sizeof(*asym),  sizeof(*asym), 0);

}",238.0,58.0,"codes:cases,code:address,he:e,syms:asym,len:label,",341.0,0.1926605304082234,Greedy
1957,"static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
","static void test_task_complete(void)

{

    QIOTask *task;

    Object *pos = object_new(TYPE_DUMMY);

    Object *sync;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(pos, task_callback, &data, NULL);

    sync = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(pos == sync);



    object_unref(pos);

    object_unref(sync);



    g_assert(data.source == pos);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
",107.0,31.0,"src:sync,obj:pos,",119.0,0.0620875755945841,Greedy
1962,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}","av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *cas = avctx->priv_data;
    ivi_free_buffers(&cas->planes[0]);
    if (cas->mb_vlc.cust_tab.table)
        ff_free_vlc(&cas->mb_vlc.cust_tab);
    av_frame_free(&cas->p_frame);
    return 0;
}",60.0,12.0,"avctx:avctx,ctx:cas,",93.0,0.0620789964993794,Greedy
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *rates, UID *uid)

{

    while (rates->id != CODEC_ID_NONE) {

        if(mxf_match_uid(rates->uid, *uid, 16))

            break;

        rates++;

    }

    return rates;

}
",49.0,10.0,"uls:rates,",83.0,0.0391286532084147,Greedy
1984,"static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
","static void pty_chr_state(CharDriverState *chro, int wired)

{

    PtyCharDriver *sservices= chro->opaque;



    if (!wired) {

        if (services->fd_tag) {

            g_source_remove(services->fd_tag);

            services->fd_tag = 0;

        }

    services   s->wired = 0;

        services->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chro, 1000);

    } else {

        iservices (!s->wired)

            qemu_chr_be_generic_open(chro);

    services   s->wired = 1;

    }

}
",89.0,18.0,"chr:chro,connected:wired,s:services,",290.0,0.1488794207572937,GA
1988,"static void continue_after_map_failure(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    dbs->bh = qemu_bh_new(reschedule_dma, dbs);

    qemu_bh_schedule(dbs->bh);

}
","static void continue_after_map_failure(void * opifice)

{

    DMAAIOCB *dbdsbi (DMAAIOCB *) opifice;



    dsbi->bh = qemu_bh_new(reschedule_dma, dsbi);

    qemu_bh_schedule(dsbi->bh);

}
",38.0,10.0,"opaque: opifice,dbs:dsbi,",369.0,0.2101951479911804,GA
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *buff;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    buff = object_resolve_path(name, NULL);



    return !buff ? NULL : SPAPR_DR_CONNECTOR(buff);

}
",56.0,15.0,"obj:buff,",65.0,0.0408844788869222,Greedy
2004,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
","static void gen_exts(int ot, TCGv err)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(err, err);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(err, err);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(err, err);

        break;

    default:

        break;

    }

}
",58.0,16.0,"reg:err,",75.0,0.0458064993222554,Greedy
2016,"static int nbd_co_flush(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    return nbd_client_session_co_flush(&s->client);

}
","static int nbd_co_flush(BlockDriverState *bos)

{

    BDRVNBDState *stats = bos->opaque;



    return nbd_client_session_co_flush(&stats->client);

}
",27.0,6.0,"s:stats,bs:bos,",80.0,0.0571100950241088,Greedy
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
","static int qiov_is_aligned(QEMUIOVector * qwav)

{

    int chi;



    for (chi = 0; chi <  qwav->niov; chi++) {

        if ((uintptr_t)  qwav->iov[chi].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
",54.0,10.0,"i:chi,qiov: qwav,",102.0,0.0623752196629842,Greedy
2018,"static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}
","static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *uf, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->uf;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)uf = seq->frame;



    return buf_size;

}
",129.0,31.0,"data:uf,",75.0,0.0406822443008422,Greedy
2024,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
","void wm8750_set_bclk_in(void *oacity, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) oacity;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
",43.0,11.0,"opaque:oacity,",36.0,0.0233407735824584,Greedy
2026,"static void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    assert(!bs->refcnt);

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}
","static void bdrv_delete(BlockDriverState *obs)

{

    assert(!obs->job);

    assert(bdrv_op_blocker_is_empty(obs));

    assert(!obs->refcnt);

    assert(QLIST_EMPTY(&obs->dirty_bitmaps));



    bdrv_close(obs);



    /* remove from list, if necessary */

    bdrv_make_anon(obs);



    g_free(obs);

}
",60.0,18.0,"bs:obs,",66.0,0.0265354514122009,Greedy
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
","static inline int sd_wp_addr(SDState *sam, uint32_t ha)

{

    return sam->wp_groups[ha >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
",30.0,8.0,"addr:ha,sd:sam,",92.0,0.0501285950342814,Greedy
2032,"void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }

}
","void ff_h264_init_dequant_tables(H264Context *h)

{

    int start, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (start = 0; start < 6; start++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[start][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (start = 0; start < 6; start++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[start][0][x] = 1 << 6;

    }

}
",136.0,29.0,"i:start,",89.0,0.0532587130864461,Greedy
2037,"static void test_hba_enable(void)

{

    AHCIQState *ahci;



    ahci = ahci_boot();

    ahci_pci_enable(ahci);

    ahci_hba_enable(ahci);

    ahci_shutdown(ahci);

}
","static void test_hba_enable(void)

{

    AHCIQState *acci;



    acci = ahci_boot();

    ahci_pci_enable(acci);

    ahci_hba_enable(acci);

    ahci_shutdown(acci);

}
",33.0,10.0,"ahci:acci,",62.0,0.0360465884208679,Greedy
2039,"static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)

{

    int i;

    for (i = 0; i < width; i++) {

        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264

        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264

    }

}
","static void RENAME(chrRangeToJpeg)(int16_t *datst, int width)

{

    int i;

    for (i = 0; i < width; i++) {

        datst[i     ] = (FFMIN(datst[i     ],30775)*4663 - 9289992)>>12; //-264

        datst[i+VOFW] = (FFMIN(datst[i+VOFW],30775)*4663 - 9289992)>>12; //-264

    }

}
",84.0,20.0,"dst:datst,",72.0,0.0511942664782206,Greedy
2047,"IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

{

    TCGv vb, vc;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, rb, fn11, 0);

    vc = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(vc, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(vc, cpu_env, vb);

        break;

    default:

        gen_qual_roundmode(ctx, fn11);

        gen_helper_cvttq(vc, cpu_env, vb);

        break;

    }



    gen_fp_exc_raise(rc, fn11);

}
","IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int bc, int rc, int lf2011)

{

    TCGv vb, pkg;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, bc, lf2011, 0);

    pkg = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (lf2011) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(pkg, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(pkg, cpu_env, vb);

        break;

    default:

        gen_qual_roundmode(ctx, lf2011);

        gen_helper_cvttq(pkg, cpu_env, vb);

        break;

    }



    gen_fp_exc_raise(rc, lf2011);

}
",140.0,49.0,"fn11:lf2011,vc:pkg,rb:bc,",152.0,0.0974585692087809,Greedy
2048,"static int virtio_serial_device_exit(DeviceState *dev)

{

    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    g_free(vser->ivqs);

    g_free(vser->ovqs);

    g_free(vser->ports_map);

    if (vser->post_load) {

        g_free(vser->post_load->connected);

        timer_del(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        g_free(vser->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}
","static int virtio_serial_device_exit(DeviceState *private)

{

    VirtIOSerial *gsl = VIRTIO_SERIAL(private);

    VirtIODevice *ldev = VIRTIO_DEVICE(private);



    unregister_savevm(private, ""virtio-console"", gsl);



    g_free(gsl->ivqs);

    g_free(gsl->ovqs);

    g_free(gsl->ports_map);

    if (gsl->post_load) {

        g_free(gsl->post_load->connected);

        timer_del(gsl->post_load->timer);

        timer_free(gsl->post_load->timer);

        g_free(gsl->post_load);

    }

    virtio_cleanup(ldev);

    return 0;

}
",109.0,28.0,"vser:gsl,vdev:ldev,dev:private,",169.0,0.0877764900525411,Greedy
2051,"static av_cold int mp_decode_init(AVCodecContext *avctx)

{

    MotionPixelsContext *mp = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    mp->avctx = avctx;

    ff_dsputil_init(&mp->dsp, avctx);

    mp->changes_map = av_mallocz(avctx->width * h4);

    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&mp->frame);

    return 0;

}","static av_cold int mp_decode_init(AVCodecContext *avctx)

{

    MotionPixelsContext *bc = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    bc->avctx = avctx;

    ff_dsputil_init(&bc->dsp, avctx);

    bc->changes_map = av_mallocz(avctx->width * h4);

    bc->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    bc->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    bc->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&bc->frame);

    return 0;

}",172.0,41.0,"mp:bc,",93.0,0.0571975270907084,Greedy
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
","void ppc_store_xer (CPUPPCState *env, uint32_t status)

{

    xer_so = (status >> XER_SO) & 0x01;

    xer_ov = (status >> XER_OV) & 0x01;

    xer_ca = (status >> XER_CA) & 0x01;

    xer_cmp = (status >> XER_CMP) & 0xFF;

    xer_bc = (status >> XER_BC) & 0x3F;

}
",62.0,18.0,"value:status,",78.0,0.0412315090497334,Greedy
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
","static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *member, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, member, errp);

}
",66.0,19.0,"name:member,",55.0,0.0283195773760477,Greedy
2063,"static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, base);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(s, 1, base + 0x1000);

    }

}
","static void ecc_init(target_phys_addr_t port, qemu_irq irq, uint32_t release)

{

    DeviceState *dev;

    SysBusDevice *sb;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", release);

    qdev_init(dev);

    sb = sysbus_from_qdev(dev);

    sysbus_connect_irq(sb, 0, irq);

    sysbus_mmio_map(sb, 0, port);

    if (release == 0) { // SS-600MP only

        sysbus_mmio_map(sb, 1, port + 0x1000);

    }

}
",92.0,26.0,"base:port,version:release,s:sb,",171.0,0.1087630589803059,Greedy
2065,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,

                                  void *opaque)

{

    monitor_flush(opaque);

    return FALSE;

}
","static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,

                                  void *operaque)

{

    monitor_flush(operaque);

    return FALSE;

}
",25.0,6.0,"opaque:operaque,",33.0,0.0278316378593444,Greedy
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
","static void add_cpreg_to_list(gpointer k, gpointer opsca)

{

    ARMCPU *GPU = opsca;

    uint64_t regpidxy;

    const ARMCPRegInfo *pi;



    regpidxy = *(uint32_t *)k;

    pi = get_arm_cp_reginfo(GPU->cp_regs, regpidxy);



    if (!(pi->type & ARM_CP_NO_MIGRATE)) {

        GPU->cpreg_indexes[GPU->cpreg_array_len] = cpreg_to_kvm_id(regpidxy);

        /* The value array need not be initialized at this point */

        GPU->cpreg_array_len++;

    }

}
",78.0,20.0,"ri:pi,regidx:regpidxy,cpu:GPU,key:k,opaque:opsca,",261.0,0.1498413681983947,Greedy
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
","void run_on_cpu(CPUState *nic, void (*func)(void *work), void *work)

{

    struct qemu_work_item wx;



    if (qemu_cpu_is_self(nic)) {

        func(work);

        return;

    }



    wx.func = func;

    wx.work = work;

    wx.free = false;

    if (nic->queued_work_first == NULL) {

        nic->queued_work_first = &wx;

    } else {

        nic->queued_work_last->next = &wx;

    }

    nic->queued_work_last = &wx;

    wx.next = NULL;

    wx.done = false;



    qemu_cpu_kick(nic);

    while (!wx.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
",143.0,34.0,"wi:wx,data:work,cpu:nic,",208.0,0.1217285911242167,Greedy
2092,"av_cold int ffv1_common_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;



    if (!avctx->width || !avctx->height)

        return AVERROR_INVALIDDATA;



    s->avctx = avctx;

    s->flags = avctx->flags;



    s->picture.f = avcodec_alloc_frame();

    s->last_picture.f = av_frame_alloc();



    ff_dsputil_init(&s->dsp, avctx);



    s->width  = avctx->width;

    s->height = avctx->height;



    // defaults

    s->num_h_slices = 1;

    s->num_v_slices = 1;



    return 0;

}","av_cold int ffv1_common_init(AVCodecContext *avalctl)

{

    FFV1Context *s = avalctl->priv_data;



    if (!avalctl->width || !avalctl->height)

        return AVERROR_INVALIDDATA;



    s->avalctl = avalctl;

    s->flags = avalctl->flags;



    s->picture.f = avcodec_alloc_frame();

    s->last_picture.f = av_frame_alloc();



    ff_dsputil_init(&s->dsp, avalctl);



    s->width  = avalctl->width;

    s->height = avalctl->height;



    // defaults

    s->num_h_slices = 1;

    s->num_v_slices = 1;



    return 0;

}",108.0,25.0,"avctx:avalctl,",106.0,0.0589563131332397,Greedy
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
","void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_apamples, const uint8_t *alignment)

{

	long i;

	for(i=0; i<num_apamples; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)alignment)[ src[i] ]);

}
",66.0,16.0,"palette:alignment,num_pixels:num_apamples,",70.0,0.051235278447469,Greedy
2108,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}
","static void monitor_puts(Monitor *MON, const char *err)

{

    char c;



    for(;;) {

        c = *err++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(MON->outbuf, '\r');

        }

        qstring_append_chr(MON->outbuf, c);

        if (c == '\n') {

            monitor_flush(MON);

        }

    }

}
",86.0,16.0,"c:c,mon:MON,str:err,",149.0,0.0939847032229105,Greedy
2112,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
","static int decode_copy(uint8_t *channel, int width, int direction,

                       const uint8_t *send, const uint8_t *source_end)

{

    const int size = width * direction;



    if (source_end - send < size)

        return -1;

    bytestream_get_buffer(&send, channel, size);

    return 0;

}
",58.0,16.0,"src_end:source_end,frame:channel,height:direction,src:send,",143.0,0.0855495611826578,Greedy
2119,"static void xen_log_start(MemoryListener *listener,

                          MemoryRegionSection *section)

{

    XenIOState *state = container_of(listener, XenIOState, memory_listener);



    xen_sync_dirty_bitmap(state, section->offset_within_address_space,

                          int128_get64(section->size));

}
","static void xen_log_start(MemoryListener *listener,

                          MemoryRegionSection *object)

{

    XenIOState *cache = container_of(listener, XenIOState, memory_listener);



    xen_sync_dirty_bitmap(cache, object->offset_within_address_space,

                          int128_get64(object->size));

}
",43.0,13.0,"state:cache,section:object,",96.0,0.052605136235555,Greedy
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

","static void mov_update_dts_shift(MOVStreamContext *context, int duration)

{

    if (duration < 0) {





        context->dts_shift = FFMAX(context->dts_shift, -duration);

",33.0,8.0,"sc:context,",50.0,0.0379883209864298,Greedy
2126,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    return (cluster_offset != 0);

}
","static int qcow2_is_allocated(BlockDriverState *outs, int64_t sector___ident,

                              int nb_vector, int *rnumber)

{

    uint64_t cluster_error;

    int data;



    *rnumber = nb_vector;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    data = qcow2_get_cluster_offset(outs, sector___ident << 9, rnumber, &cluster_error);

    if (data < 0) {

        *rnumber = 0;

    }



    return (cluster_error != 0);

}
",67.0,18.0,"cluster_offset:cluster_error,bs:outs,pnum:rnumber,sector_num:sector___ident,nb_sectors:nb_vector,ret:data,",221.0,0.1347203612327575,Greedy
2136,"static void nic_selective_reset(EEPRO100State * s)

{

    size_t i;

    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);

    //~ eeprom93xx_reset(s->eeprom);

    memcpy(eeprom_contents, s->conf.macaddr.a, 6);

    eeprom_contents[0xa] = 0x4000;

    if (s->device == i82557B || s->device == i82557C)

        eeprom_contents[5] = 0x0100;

    uint16_t sum = 0;

    for (i = 0; i < EEPROM_SIZE - 1; i++) {

        sum += eeprom_contents[i];

    }

    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;

    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));



    memset(s->mem, 0, sizeof(s->mem));

    uint32_t val = BIT(21);

    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));



    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));

    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));

}
","static void nic_selective_reset(EEPRO100State * aws)

{

    size_t id;

    uint16_t *eeprom_contentenses = eeprom93xx_data(aws->eeprom);

    //~ eeprom93xx_reset(s->eeprom);

    memcpy(eeprom_contentenses, aws->conf.macaddr.a, 6);

    eeprom_contentenses[0xa] = 0x4000;

    if (aws->device == i82557B || aws->device == i82557C)

        eeprom_contentenses[5] = 0x0100;

    uint16_t sum = 0;

    for (id = 0; id < EEPROM_SIZE - 1; id++) {

        sum += eeprom_contentenses[id];

    }

    eeprom_contentenses[EEPROM_SIZE - 1] = 0xbaba - sum;

    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contentenses[EEPROM_SIZE - 1]));



    memset(aws->mem, 0, sizeof(aws->mem));

    uint32_t val = BIT(21);

    memcpy(&aws->mem[SCBCtrlMDI], &val, sizeof(val));



    assert(sizeof(aws->mdimem) == sizeof(eepro100_mdi_default));

    memcpy(&aws->mdimem[0], &eepro100_mdi_default[0], sizeof(aws->mdimem));

}
",208.0,48.0,"eeprom_contents:eeprom_contentenses,i:id,s:aws,",207.0,0.1385034441947937,Greedy
2139,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    }

}
","static uint32_t bonito_readl(void *Opec, target_phys_addr_t conn)

{

    PCIBonitoState *aces = Opec;

    uint32_t sha;



    sha = (conn - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", conn);

    switch (sha) {

    case BONITO_INTISR:

        return aces->regs[sha];

    default:

        return aces->regs[sha];

    }

}
",71.0,18.0,"addr:conn,opaque:Opec,saddr:sha,s:aces,",194.0,0.1069321314493815,Greedy
2145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + elemsize * (cb >> 16);

    }

}
","static void fill_table(uint8_t* input[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int fc, void *y_tab)

{

    int ui;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (fc >> 9);



    for (ui = 0; ui < 256 + 2*YUVRGB_TABLE_HEADROOM; ui++) {

        int64_t cb = av_clip(ui-YUVRGB_TABLE_HEADROOM, 0, 255)*fc;

        input[ui] = y_table + elemsize * (cb >> 16);

    }

}
",98.0,26.0,"i:ui,table:input,inc:fc,",164.0,0.0917059977849324,Greedy
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
","bool memory_region_test_and_clear_dirty(MemoryRegion *err, hwaddr addr,

                                        hwaddr ish, unsigned client)

{

    assert(err->terminates);

    return cpu_physical_memory_test_and_clear_dirty(err->ram_addr + addr,

                                                    ish, client);

}
",39.0,12.0,"size:ish,mr:err,",86.0,0.0587105949719746,Greedy
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    BlockDriverInfo bdi;

    int ret;



    ret = bdrv_get_info(bs, &bdi);

    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    } else {

        return bdi.cluster_size;

    }

}
","static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    BlockDriverInfo bdi;

    int ber;



    ber = bdrv_get_info(bs, &bdi);

    if (ber < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    } else {

        return bdi.cluster_size;

    }

}
",53.0,12.0,"ret:ber,",62.0,0.0379026929537455,Greedy
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
","static int s390_virtio_device_init(VirtIOS390Device *cam, VirtIODevice *vvdiv)

{

    VirtIOS390Bus *b;

    int dev_len;



    b = DO_UPCAST(VirtIOS390Bus, b, cam->qdev.parent_bus);

    cam->vvdiv = vvdiv;

    cam->dev_offs = b->dev_offs;

    cam->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(cam) * VIRTIO_VQCONFIG_LEN;

    dev_len += cam->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&cam->b);



    b->dev_offs += dev_len;



    cam->host_features = virtio_bus_get_vdev_features(&cam->b,

                                                      cam->host_features);

    s390_virtio_device_sync(cam);

    s390_virtio_reset_idx(cam);

    if (cam->qdev.hotplugged) {

        S390CPU *mem = s390_cpu_addr2state(0);

        s390_virtio_irq(mem, VIRTIO_PARAM_DEV_ADD, cam->dev_offs);

    }



    return 0;

}
",155.0,43.0,"vdev:vvdiv,bus:b,cpu:mem,dev:cam,",250.0,0.1218637228012085,Greedy
2157,"static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
","static inline void tcg_out_movi(TCGContext *request, TCGType type,

                                int mem, tcg_target_long err)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (err != (err & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, err);

#endif

    if (err == (err & 0xfff))

        tcg_out32(request, ARITH_OR | INSN_RD(mem) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(err));

    else {

        tcg_out32(request, SETHI | INSN_RD(mem) | ((err & 0xfffffc00) >> 10));

        if (err & 0x3ff)

            tcg_out32(request, ARITH_OR | INSN_RD(mem) | INSN_RS1(mem) |

                      INSN_IMM13(err & 0x3ff));

    }

}
",143.0,40.0,"ret:mem,arg:err,s:request,",209.0,0.1001444737116495,Greedy
2174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
","static void master_abort_mem_write(void *opaque, hwaddr fd, uint64_t str,

                                   unsigned size)

{

}
",19.0,5.0,"addr:fd,val:str,",61.0,0.0443661173184712,Greedy
2176,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
","void ff_init_cabac_decoder(CABACContext *tc, const uint8_t *context, int buf_size){

    tc->bytestream_start=

    tc->bytestream= context;

    tc->bytestream_end= context + buf_size;



#if CABAC_BITS == 16

    tc->low =  (*tc->bytestream++)<<18;

    tc->low+=  (*tc->bytestream++)<<10;

#else

    tc->low =  (*tc->bytestream++)<<10;

#endif

    tc->low+= ((*tc->bytestream++)<<2) + 2;

    tc->range= 0x1FE;

}
",108.0,20.0,"c:tc,buf:context,",133.0,0.0734265605608622,Greedy
2182,"static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
","static void pc_compat_1_4(QEMUMachineInitArgs *Args)

{

    pc_compat_1_5(Args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
",43.0,11.0,"args:Args,",45.0,0.03112766345342,Greedy
2193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_rrp, Error * local_er)

{

    if ( local_er && dst_rrp == &error_abort) {

        error_report_err( local_er);

        abort();

    } else if (dst_rrp && !*dst_rrp) {

        *dst_rrp =  local_er;

    } else if ( local_er) {

        error_free( local_er);

    }

}
",62.0,16.0,"dst_errp:dst_rrp,local_err: local_er,",92.0,0.0605873743693033,Greedy
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
","int32 float64_to_int32_round_to_zero( float64 a STATUS_PAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
",190.0,58.0,"STATUS_PARAM:STATUS_PAM,",54.0,0.0362422148386637,Greedy
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int rules)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_reader;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    rules &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(rules));

    }



    bs_reader = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_reader, entry);



    bs_reader->state.bs = bs;

    bs_reader->state.rules = rules;



    return bs_queue;

}
",114.0,33.0,"bs_entry:bs_reader,flags:rules,",115.0,0.0738490939140319,Greedy
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
","int kvm_set_signal_mask(CPUState *ench, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmash;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(ench, KVM_SET_SIGNAL_MASK, NULL);



    sigmash = qemu_malloc(sizeof(*sigmash) + sizeof(*sigset));



    sigmash->len = 8;

    memcpy(sigmash->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(ench, KVM_SET_SIGNAL_MASK, sigmash);

    free(sigmash);



    return r;

}
",94.0,26.0,"env:ench,sigmask:sigmash,",146.0,0.0861067493756612,Greedy
2201,"static int unix_close(void *opaque)

{

    QEMUFileSocket *s = opaque;

    close(s->fd);

    g_free(s);

    return 0;

}
","static int unix_close(void *ompusher)

{

    QEMUFileSocket *s = ompusher;

    close(s->fd);

    g_free(s);

    return 0;

}
",31.0,8.0,"opaque:ompusher,",34.0,0.0300724983215332,Greedy
2203,"static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    }

}
","static void fd_chr_read(void *pac)

{

    CharDriverState *chr = pac;

    FDCharDriver *r = chr->pac;

    int val, val;

    uint8_t exc[1024];



    val = sizeof(exc);

    if (val > r->max_size)

        val = r->max_size;

    if (val == 0)

        return;

    val = read(r->fd_in, exc, val);

    if (val == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(r->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (val > 0) {

        qemu_chr_read(chr, exc, val);

    }

}
",126.0,32.0,"opaque:pac,buf:exc,s:r,len:val,size:val,",279.0,0.1609391530354817,Greedy
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
","static int xhci_setup_packet(XHCITransfer *yleder, XHCIPort *end, int ep)

{

    usb_packet_setup(&yleder->packet,

                     yleder->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     yleder->xhci->slots[yleder->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&yleder->packet, yleder->data, yleder->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            yleder->packet.pid, yleder->packet.devaddr, yleder->packet.devep);

    return 0;

}
",96.0,20.0,"xfer:yleder,port:end,",159.0,0.094338039557139,Greedy
2213,"static void thread_pool_cancel(BlockAIOCB *acb)

{

    ThreadPoolElement *elem = (ThreadPoolElement *)acb;

    ThreadPool *pool = elem->pool;



    trace_thread_pool_cancel(elem, elem->common.opaque);



    qemu_mutex_lock(&pool->lock);

    if (elem->state == THREAD_QUEUED &&

        /* No thread has yet started working on elem. we can try to ""steal""

         * the item from the worker if we can get a signal from the

         * semaphore.  Because this is non-blocking, we can do it with

         * the lock taken and ensure that elem will remain THREAD_QUEUED.

         */

        qemu_sem_timedwait(&pool->sem, 0) == 0) {

        QTAILQ_REMOVE(&pool->request_list, elem, reqs);

        qemu_bh_schedule(pool->completion_bh);



        elem->state = THREAD_DONE;

        elem->ret = -ECANCELED;

    }



    qemu_mutex_unlock(&pool->lock);

}
","static void thread_pool_cancel(BlockAIOCB *ascb)

{

    ThreadPoolElement * elev = (ThreadPoolElement *)ascb;

    ThreadPool *iam =  elev->iam;



    trace_thread_pool_cancel( elev,  elev->common.opaque);



    qemu_mutex_lock(&iam->lock);

    if ( elev->state == THREAD_QUEUED &&

        /* No thread has yet started working on elem. we can try to ""steal""

         * the item from the worker if we can get a signal from the

         * semaphore.  Because this is non-blocking, we can do it with

         * the lock taken and ensure that elem will remain THREAD_QUEUED.

         */

        qemu_sem_timedwait(&iam->sem, 0) == 0) {

        QTAILQ_REMOVE(&iam->request_list,  elev, reqs);

        qemu_bh_schedule(iam->completion_bh);



         elev->state = THREAD_DONE;

         elev->ret = -ECANCELED;

    }



    qemu_mutex_unlock(&iam->lock);

}
",109.0,27.0,"elem: elev,pool:iam,acb:ascb,",175.0,0.1130855719248453,Greedy
2221,"static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
","static int voc_probe(AVProbeData *p)

{

    int patch, view;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    patch = p->buf[22] | (p->buf[23] << 8);

    view = p->buf[24] | (p->buf[25] << 8);

    if (~patch + 0x1234 != view)

        return 10;



    return AVPROBE_SCORE_MAX;

}
",102.0,18.0,"version:patch,check:view,",104.0,0.0665504058202107,Greedy
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
","static void kvm_inject_x86_mce_on(CPUState *err, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .err = err,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!err->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(err, kvm_do_inject_x86_mce, &data);

}
",74.0,16.0,"env:err,",84.0,0.0468175212542215,Greedy
2234,"void qemu_file_set_error(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
","void qemu_file_set_error(QEMUFile *f, int xt)

{

    if (f->last_error == 0) {

        f->last_error = xt;

    }

}
",28.0,6.0,"ret:xt,",43.0,0.0315281629562377,Greedy
2238,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
","void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *fileMlen,

                                     void *start, unsigned i,

                                     uint8_t *cksam)

{

    BiosLinkerLoaderEntry event;

    const BiosLinkerFileEntry *line = bios_linker_find_file(linker, fileMlen);

    ptrdiff_t checksum_offset = (gchar *)cksam - line->blob->data;

    ptrdiff_t start_offset = (gchar *)start - line->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= line->blob->len);

    assert(start_offset + i <= line->blob->len);

    assert(*cksam == 0x0);



    memset(&event, 0, sizeof event);

    strncpy(event.cksum.line, fileMlen, sizeof event.cksum.line - 1);

    event.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    event.cksum.offset = cpu_to_le32(checksum_offset);

    event.cksum.start = cpu_to_le32(start_offset);

    event.cksum.length = cpu_to_le32(i);



    g_array_append_vals(linker->cmd_blob, &event, sizeof event);

}
",204.0,53.0,"file:line,size:i,checksum:cksam,file_name:fileMlen,entry:event,",308.0,0.1718748927116394,Greedy
2254,"static int srt_probe(AVProbeData *p)

{

    const unsigned char *ptr = p->buf;

    int i, v, num = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */



    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(ptr);

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}
","static int srt_probe(AVProbeData *op)

{

    const unsigned char *loc = op->buf;

    int i, sv, num = 0;



    if (AV_RB24(loc) == 0xEFBBBF)

        loc += 3;  /* skip UTF-8 BOM */



    while (*loc == '\r' || *loc == '\n')

        loc++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(loc, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &sv) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(loc);

        loc += strcspn(loc, ""\n"") + 1;

    }

    return 0;

}
",129.0,30.0,"ptr:loc,p:op,v:sv,",174.0,0.1063295284907023,Greedy
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *cas = avctx->priv_data;



    ff_free_vlc(&cas->ac_vlc);

    ff_free_vlc(&cas->dc_vlc);

    ff_free_vlc(&cas->run_vlc);



    av_freep(&cas->mb_scan_index);

    av_freep(&cas->rows);



    return 0;

}
",62.0,15.0,"avctx:avctx,ctx:cas,",99.0,0.0674368500709533,Greedy
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    return inl(0xcfc);

}
","static uint32_t qpci_pc_config_readl(QPCIBus *bus, int evpath, uint8_t optional)

{

    outl(0xcf8, (1 << 31) | (evpath << 8) | optional);

    return inl(0xcfc);

}
",41.0,8.0,"offset:optional,devfn:evpath,",61.0,0.0444467107454935,Greedy
2267,"static int load_normal_reset(S390CPU *cpu)

{

    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);



    pause_all_vcpus();

    cpu_synchronize_all_states();

    cpu_reset_all();


    io_subsystem_reset();

    scc->initial_cpu_reset(CPU(cpu));

    scc->load_normal(CPU(cpu));

    cpu_synchronize_all_post_reset();

    resume_all_vcpus();

    return 0;

}","static int load_normal_reset(S390CPU *linux)

{

    S390CPUClass *dsuc = S390_CPU_GET_CLASS(linux);



    pause_all_vcpus();

    cpu_synchronize_all_states();

    cpu_reset_all();


    io_subsystem_reset();

    dsuc->initial_cpu_reset(CPU(linux));

    dsuc->load_normal(CPU(linux));

    cpu_synchronize_all_post_reset();

    resume_all_vcpus();

    return 0;

}",66.0,17.0,"scc:dsuc,cpu:linux,",96.0,0.0661025802294413,Greedy
2272,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
","void ff_af_queue_close(AudioFrameQueue *afqs)

{

    /* remove/free any remaining frames */

    while (afqs->frame_queue)

        delete_next_frame(afqs);

    memset(afqs, 0, sizeof(*afqs));

}
",33.0,8.0,"afq:afqs,",67.0,0.0395951509475708,Greedy
2273,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int i;

    int32_t *dst = (int32_t *) _dst;

    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;

}
","static void lumRangeToJpeg16_c(int16_t * _lsts, int width)

{

    int i;

    int32_t *dst = (int32_t *)  _lsts;

    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;

}
",68.0,15.0,"_dst: _lsts,",51.0,0.0349711855252583,Greedy
2281,"void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, next) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);



        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}
","void qemu_opts_print(QemuOpts *OPs)

{

    QemuOpt *err;

    QemuOptDesc *desc = OPs->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(err, &OPs->head, next) {

            printf(""%s=\""%s\"" "", err->name, err->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *err = qemu_opt_find(OPs, desc->name);



        value = err ? err->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && err) {

            printf(""%s=%"" PRId64 "" "", desc->name, err->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}
",198.0,43.0,"opts:OPs,opt:err,",172.0,0.1021062016487121,Greedy
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
","int kvm_remove_breakpoint(CPUState *current_env, target_ulong target,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *buffer;

    CPUState *env;

    int aster;



    if (type == GDB_BREAKPOINT_SW) {

        buffer = kvm_find_sw_breakpoint(current_env, target);

        if (!buffer)

            return -ENOENT;



        if (buffer->use_count > 1) {

            buffer->use_count--;

            return 0;

        }



        aster = kvm_arch_remove_sw_breakpoint(current_env, buffer);

        if (aster)

            return aster;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, buffer, entry);

        qemu_free(buffer);

    } else {

        aster = kvm_arch_remove_hw_breakpoint(target, len, type);

        if (aster)

            return aster;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        aster = kvm_update_guest_debug(env, 0);

        if (aster)

            return aster;

    }

    return 0;

}
",167.0,47.0,"bp:buffer,err:aster,addr:target,",228.0,0.1476924339930216,Greedy
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
","static int mpeg4_decode_gop_header(MpegEncContext *sb, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(sb->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    sb->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
",110.0,30.0,"s:sb,",71.0,0.0346888661384582,Greedy
2297,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
","int kvm_ioctl(KVMState *a, int art, ...)

{

    int art;

    void *aj;

    va_list ap;



    va_start(ap, art);

    aj = va_arg(ap, void *);

    va_end(ap);



    art = ioctl(a->fd, art, aj);

    if (art == -1)

        art = -errno;



    return art;

}
",73.0,24.0,"s:a,arg:aj,type:art,ret:art,",209.0,0.1124096671740214,Greedy
2300,"static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
","static void av_build_index_raw(AVFormatContext *gs)

{

    AVPacket packet2, *pkt = &packet2;

    int arr;

    AVStream *art;



    art = gs->streams[0];

    av_read_frame_flush(gs);

    url_fseek(&gs->pb, gs->data_offset, SEEK_SET);



    for(;;) {

        arr = av_read_frame(gs, pkt);

        if (arr < 0)

            break;

        if (pkt->stream_index == 0 && art->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(art, art->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
",122.0,31.0,"st:art,s:gs,ret:arr,pkt1:packet2,",216.0,0.10697683095932,Greedy
2308,"static void kqemu_record_flush(void)

{

    PCRecord *r, *r_next;

    int h;



    for(h = 0; h < PC_REC_HASH_SIZE; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {

            r_next = r->next;

            free(r);

        }

        pc_rec_hash[h] = NULL;

    }

    nb_pc_records = 0;

}
","static void kqemu_record_flush(void)

{

    PCRecord *adr, *r_next;

    int err;



    for(err = 0; err < PC_REC_HASH_SIZE; err++) {

        for(adr = pc_rec_hash[h]; errdr != NULL; adr = r_next) {

            r_r_next adr->next;

            free(adr);

        }

        pc_rec_hash[err] = NULL;

    }

    nb_pc_records = 0;

}
",74.0,21.0,"r:adr,r_next:r_next,h:err,",202.0,0.1083739121754964,GA
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
","static void iscsi_allocationmap_set(IscsiLun *itschrielunion, int64_t sector_num,

                                    int nb_sector)

{

    int64_t cluster_sum, nb_clusters;

    if (itschrielunion->allocationmap == NULL) {

        return;

    }

    cluster_sum = sector_num / itschrielunion->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sector,

                               itschrielunion->cluster_sectors) - cluster_sum;

    bitmap_set(itschrielunion->allocationmap, cluster_sum, nb_clusters);

}
",67.0,20.0,"iscsilun:itschrielunion,cluster_num:cluster_sum,nb_sectors:nb_sector,",152.0,0.0792521198590596,Greedy
2311,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
","static void test_qemu_strtosz_metric(void)

{

    const char *r = ""12345k"";

    char *Endptr = NULL;

    int64_t rap;



  rapes = qemu_strtosz_metric(r, &Endptr);

    g_assert_cmpint(rap, ==, 12345000);

    g_asserEndptrtr == r + 6);

}
",54.0,13.0,"str:r,endptr:Endptr,res:rap,",447.0,0.2196959535280863,GA
2312,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t * dsts,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc,  dsts, width, height, lumStride, chromStride, dstStride, 1);

}
",70.0,21.0,"dst: dsts,",48.0,0.0334539850552876,Greedy
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
","static int copy_from(IpvideoContext *i, AVFrame *flash, AVFrame *inconst, int delta_w, int delta64x)

{

    int current_offset = i->pixel_ptr - inconst->data[0];

    int motion_offset = current_offset + delta64x * inconst->linesize[0]

                       + delta_w * (1 + i->is_16bpp);

    if (motion_offset < 0) {

        av_log(i->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > i->upper_motion_limit_offset) {

        av_log(i->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, i->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (flash->data[0] == NULL) {

        av_log(i->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    i->hdsp.put_pixels_tab[!i->is_16bpp][0](i->pixel_ptr, flash->data[0] + motion_offset,

                                            inconst->linesize[0], 8);

    return 0;

}
",194.0,41.0,"delta_y:delta64x,delta_x:delta_w,src:flash,dst:inconst,s:i,",214.0,0.1243773460388183,Greedy
2328,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t sector_num, uint8_t *buf, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = bs->opaque;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

        acb = qemu_aio_get(bs, cb, opaque);

        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);

        bh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(bh);

        return &acb->common;

    }



    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
","static BlockDriverAIOCB *raw_aio_read(BlockDriverState *db,

        int64_t block_begin, uint8_t *batch, int nb_sectors,

        BlockDriverCompletionFunc *rb, void *opaques)

{

    RawAIOCB *awv;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *stats = db->opaques;



    if (unlikely(stats->aligned_buf != NULL && ((uintptr_t) batch % 512))) {

        QEMUBH *bang;

        awv = qemu_aio_get(db, rb, opaques);

        awv->ret = raw_pread(db, 512 * block_begin, batch, 512 * nb_sectors);

        bang = qemu_bh_new(raw_aio_em_cb, awv);

        qemu_bh_schedule(bang);

        return &awv->common;

    }



    awv = raw_aio_setup(db, block_begin, batch, nb_sectors, rb, opaques);

    if (!awv)

        return NULL;

    if (aio_read(&awv->aiocb) < 0) {

        qemu_aio_release(awv);

        return NULL;

    }

    return &awv->common;

}
",170.0,46.0,"acb:awv,cb:rb,bh:bang,bs:db,buf:batch,sector_num:block_begin,s:stats,opaque:opaques,",447.0,0.2582501769065857,Greedy
2329,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,

    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,

    BdrvRequestFlags flags)

{

    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }



    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);

}
","static int coroutine_fn bdrv_co_do_readv(BdrvChild *cost,

    int64_t  sector_number, int nb_sharegments, QEMUIOVector *chiov,

    BdrvRequestFlags ops)

{

    if (nb_sharegments < 0 || nb_sharegments > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }



    return bdrv_co_preadv(cost->bs,  sector_number << BDRV_SECTOR_BITS,

                          nb_sharegments << BDRV_SECTOR_BITS, chiov, ops);

}
",61.0,19.0,"nb_sectors:nb_sharegments,child:cost,qiov:chiov,sector_num: sector_number,flags:ops,",175.0,0.1138795971870422,Greedy
2335,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], proto_nested[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));

    if ((ptr = strchr(proto_nested, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_nested, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}
","int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], proto_gnored[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(proto_gnored, proto_str, sizeof(proto_gnored));

    if ((ptr = strchr(proto_gnored, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_gnored, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}
",206.0,58.0,"proto_nested:proto_gnored,",109.0,0.0707249720891316,Greedy
2348,"static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int alpha, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          alpha, beta, lim_p0q0, lim_q1, lim_p1);

}
","static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int i, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          i, beta, lim_p0q0, lim_q1, lim_p1);

}
",65.0,20.0,"alpha:i,",56.0,0.0334876656532287,Greedy
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}
","void HELPER(stby_b)(CPUHPPAState *env, target_ulong attr, target_ulong fail)

{

    uintptr_t ra = GETPC();



    switch (attr & 3) {

    case 3:

        cpu_stb_data_ra(env, attr, fail, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, attr, fail, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, attr, fail, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, attr, fail >> 16, ra);

            cpu_stw_data_ra(env, attr + 1, fail, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, attr, fail, ra);

        break;

    }

}
",133.0,38.0,"addr:attr,val:fail,",154.0,0.0812620560328165,Greedy
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
","int av_image_check_sar(unsigned int e, unsigned int h, AVRational para)

{

    int64_t scalled_num;



    if (!para.den)

        return AVERROR(EINVAL);



    if (!para.num || para.num == para.den)

        return 0;



    if (para.num < para.den)

        scalled_num = av_rescale_rnd(e, para.num, para.den, AV_ROUND_ZERO);

    else

        scalled_num = av_rescale_rnd(h, para.den, para.num, AV_ROUND_ZERO);



    if (scalled_num > 0)

        return 0;



    return AVERROR(EINVAL);

}
",110.0,28.0,"sar:para,scaled_dim:scalled_num,w:e,",198.0,0.1063222328821818,Greedy
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
","QemuOpts *qemu_opts_from_qdict(QemuOptsList *call, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(call, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
",57.0,15.0,"list:call,",52.0,0.0336463371912638,Greedy
2370,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                datap[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
","static void dequantization_int(int x, int y, Jpeg2000Cblk * cbalk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w =  cbalk->coord[0][1] -  cbalk->coord[0][0];

    for (j = 0; j < ( cbalk->coord[1][1] -  cbalk->coord[1][0]); ++j) {

        int32_t *arraps = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                arraps[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                arraps[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
",214.0,45.0,"cblk: cbalk,datap:arraps,",181.0,0.0980069677035013,Greedy
2377,"static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)

{

    int ret;



    assert(client->optlen);

    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {

        return -EIO;

    }

    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,

                                     ""option '%s' should have zero length"",

                                     nbd_opt_lookup(client->opt));

    if (fatal && !ret) {

        error_setg(errp, ""option '%s' should have zero length"",

                   nbd_opt_lookup(client->opt));

        return -EINVAL;

    }

    return ret;

}
","static int nbd_reject_length(NBDClient *client, bool ofault, Error **errp)

{

    int ret;



    assert(client->optlen);

    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {

        return -EIO;

    }

    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,

                                     ""option '%s' should have zero length"",

                                     nbd_opt_lookup(client->opt));

    if (ofault && !ret) {

        error_setg(errp, ""option '%s' should have zero length"",

                   nbd_opt_lookup(client->opt));

        return -EINVAL;

    }

    return ret;

}
",103.0,27.0,"fatal:ofault,",49.0,0.0377941171328226,Greedy
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}","static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t hostingtimer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &hostingtimer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)hostingtimer;



    return 0;

}",121.0,27.0,"host_timer:hostingtimer,",37.0,0.0213672598203023,Greedy
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
","void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *reader,

                            FWCfgState *wallappregion, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(reader, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(wallappregion, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
",94.0,25.0,"fw_cfg:wallappregion,io:reader,",75.0,0.0416531960169474,Greedy
2402,"static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)

{

    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,

                       get_field(qtd->token, QTD_TOKEN_TBYTES),

                       get_field(qtd->token, QTD_TOKEN_CPAGE),

                       get_field(qtd->token, QTD_TOKEN_CERR),

                       get_field(qtd->token, QTD_TOKEN_PID),

                       (bool)(qtd->token & QTD_TOKEN_IOC),

                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),

                       (bool)(qtd->token & QTD_TOKEN_HALT),

                       (bool)(qtd->token & QTD_TOKEN_BABBLE),

                       (bool)(qtd->token & QTD_TOKEN_XACTERR));

}
","static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qod)

{

    trace_usb_ehci_qtd(q, addr, qod->next, qod->altnext,

                       get_field(qod->token, QTD_TOKEN_TBYTES),

                       get_field(qod->token, QTD_TOKEN_CPAGE),

                       get_field(qod->token, QTD_TOKEN_CERR),

                       get_field(qod->token, QTD_TOKEN_PID),

                       (bool)(qod->token & QTD_TOKEN_IOC),

                       (bool)(qod->token & QTD_TOKEN_ACTIVE),

                       (bool)(qod->token & QTD_TOKEN_HALT),

                       (bool)(qod->token & QTD_TOKEN_BABBLE),

                       (bool)(qod->token & QTD_TOKEN_XACTERR));

}
",123.0,31.0,"qtd:qod,",107.0,0.0555976271629333,Greedy
2407,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
","static void vararg_number(void)

{

    QObject *cb;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    cb = qobject_from_jsonf(""%d"", value);

    g_assert(cb != NULL);

    g_assert(qobject_type(cb) == QTYPE_QINT);



    qint = qobject_to_qint(cb);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    cb = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(cb != NULL);

    g_assert(qobject_type(cb) == QTYPE_QINT);



    qint = qobject_to_qint(cb);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    cb = qobject_from_jsonf(""%f"", valuef);

    g_assert(cb != NULL);

    g_assert(qobject_type(cb) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(cb);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
",183.0,62.0,"obj:cb,",111.0,0.0711560130119323,Greedy
2409,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    pbdev->iommu_enabled = false;

}
","void s390_pci_iommu_disable(S390PCIBusDevice *labdiv)

{

    memory_region_del_subregion(&labdiv->mr, &labdiv->iommu_mr);

    object_unparent(OBJECT(&labdiv->iommu_mr));

    labdiv->iommu_enabled = false;

}
",39.0,9.0,"pbdev:labdiv,",61.0,0.0426224033037821,Greedy
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
","static av_cold int ass_decode_init(AVCodecContext *avcms)

{

    avcms->subtitle_header = av_malloc(avcms->extradata_size);

    if (!avcms->extradata)

        return AVERROR(ENOMEM);

    memcpy(avcms->subtitle_header, avcms->extradata, avcms->extradata_size);

    avcms->subtitle_header_size = avcms->extradata_size;

    return 0;

}
",61.0,15.0,"avctx:avcms,",92.0,0.0565685153007507,Greedy
2423,"void bdrv_drain(BlockDriverState *bs)

{

    bool busy = true;



    bdrv_drain_recurse(bs);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bs);

         busy = bdrv_requests_pending(bs);

         busy |= aio_poll(bdrv_get_aio_context(bs), busy);

","void bdrv_drain(BlockDriverState *bc)

{

    bool busy = true;



    bdrv_drain_recurse(bc);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bc);

         busy = bdrv_requests_pending(bc);

         busy |= aio_poll(bdrv_get_aio_context(bc), busy);

",47.0,16.0,"bs:bc,",56.0,0.0334201693534851,Greedy
2426,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
","static void print_features(FILE *x,

                           int (*cpu_frprintln)(FILE *x, const char *fmt, ...),

                           uint32_t files, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (files & (1 << i))) {

            if (prefix)

                (*cpu_frprintln)(x, ""%s"", prefix);

            (*cpu_frprintln)(x, ""%s "", feature_name[i]);

        }

}
",108.0,25.0,"f:x,features:files,cpu_fprintf:cpu_frprintln,",140.0,0.0869777758916219,Greedy
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
","static const char *qobject_input_get_keyval(QObjectInputVisitor *qerv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qerv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qerv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
",93.0,24.0,"qiv:qerv,",55.0,0.0321875095367431,Greedy
2439,"static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
","static char *check_nan_suffix(char *v)

{

    char *data = v;



    if (*v++ != '(')

        return data;



    while ((*v >= 'a' && *v <= 'z') || (*v >= 'A' && *v <= 'Z') ||

           (*v >= '0' && *v <= '9') ||  *v == '_')

        v++;



    return *v == ')' ? v + 1 : data;

}
",95.0,17.0,"s:v,start:data,",141.0,0.0854234933853149,Greedy
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
","static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *code, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, code, errp);

    prop->set(obj, value, errp);

}
",66.0,19.0,"name:code,",56.0,0.0384271621704101,Greedy
2447,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
","void qmp_eject(const char *device, bool Has_forced, bool force, Error **errp)

{

    Error *localapperror = NULL;

    int rc;



    if (!Has_forced) {

        force = false;

    }



    rc = do_open_tray(device, force, &localapperror);

    if (localapperror) {

        error_propagate(errp, localapperror);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
",97.0,26.0,"local_err:localapperror,has_force:Has_forced,",57.0,0.0436033765474955,Greedy
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *exec)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &exec->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &exec->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",107.0,29.0,"uc:exec,",66.0,0.0404376188913981,Greedy
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
","static void FUNCC(pred8x8_left_dc)(uint8_t *_rc, int  strace){

    int is;

    int cd8, rc2;

    pixel4 dc0splat, dc2plat;

    pixel *remote = (pixel*)_rc;

     strace /= sizeof(pixel);



    cd8=rc2=0;

    for(is=0;is<4; is++){

        cd8+= remote[-1+is* strace];

        rc2+= remote[-1+(is+4)* strace];

    }

    dc0splat = PIXEL_SPLAT_X4((cd8 + 2)>>2);

    dc2plat = PIXEL_SPLAT_X4((rc2 + 2)>>2);



    for(is=0; is<4; is++){

        ((pixel4*)(remote+is* strace))[0]=

        ((pixel4*)(remote+is* strace))[1]= dc0splat;

    }

    for(is=4; is<8; is++){

        ((pixel4*)(remote+is* strace))[0]=

        ((pixel4*)(remote+is* strace))[1]= dc2plat;

    }

}
",221.0,51.0,"stride: strace,i:is,dc2:rc2,dc0:cd8,dc2splat:dc2plat,_src:_rc,src:remote,",407.0,0.192981207370758,Greedy
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
","static void alloc_and_copy(uint8_t **pouport,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *e,      uint32_t plan_length) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+plan_length+nal_header_size;

    *pouport = av_realloc(*pouport, *poutbuf_size);

    if (sps_pps)

        memcpy(*pouport+offset, sps_pps, sps_pps_size);

    memcpy(*pouport+sps_pps_size+nal_header_size+offset, e, plan_length);

    if (!offset)

        AV_WB32(*pouport+sps_pps_size, 1);

    else {

        (*pouport+offset)[0] = (*pouport+offset)[1] = 0;

        (*pouport+offset)[2] = 1;

    }

}
",151.0,42.0,"sps_pps_size:sps_pps_size,poutbuf_size:poutbuf_size,sps_pps:sps_pps,in_size:plan_length,poutbuf:pouport,in:e,",279.0,0.1496330539385477,Greedy
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
","int float_near_ulp(float a, float xb, unsigned  max_pull)

{

    union av_intfloat32 ad, y;



    ad.f = a;

    y.f = xb;



    if (is_negative(ad) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == xb;

    }



    if (abs(ad.i - y.i) <=  max_pull)

        return 1;



    return 0;

}
",72.0,20.0,"a:a,max_ulp: max_pull,b:xb,x:ad,",138.0,0.0779920617739359,Greedy
2464,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);

}
","static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *label)

{

    ff_wmv2_idct_c(label);

    put_pixels_clamped_c(label, dest, line_size);

}
",31.0,10.0,"block:label,",57.0,0.0283776442209879,Greedy
2467,"static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}
","static void write_target_close(BlockDriverState *rs) {

    BDRVVVFATState* spec = *((BDRVVVFATState**) rs->opaque);

    bdrv_delete(spec->qcow);

    free(spec->qcow_filename);

}
",40.0,8.0,"s:spec,bs:rs,",87.0,0.037081495920817,Greedy
2470,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
","static void dec_modu(DisasContext *auc)

{

    int  lone;



    LOG_DIS(""modu r%d, r%d, %d\n"", auc->r2, auc->r0, auc->r1);



    if (!(auc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(auc);

        return;

    }



     lone = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[auc->r1], 0,  lone);

    tcg_gen_movi_tl(cpu_pc, auc->pc);

    t_gen_raise_exception(auc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label( lone);

    tcg_gen_remu_tl(cpu_R[auc->r2], cpu_R[auc->r0], cpu_R[auc->r1]);

}
",128.0,35.0,"dc:auc,l1: lone,",117.0,0.0627528627713521,Greedy
2477,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
","static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg2const;



    reg2const.range.start = (uintptr_t)host_addr;

    reg2const.range.len = length;

    reg2const.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg2const)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
",90.0,23.0,"reg_struct:reg2const,",56.0,0.0390109260876973,Greedy
2484,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
","static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *her = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        her->halted = 0;

        her->pil_in |= 1 << irq;

        cpu_check_irqs(her);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        her->pil_in &= ~(1 << irq);

        cpu_check_irqs(her);

    }

}
",84.0,20.0,"env:her,",82.0,0.0571730136871337,Greedy
2486,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
","int qcow2_pre_write_overlap_check(BlockDriverState *bes, int  assign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bes,  assign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bes, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
",97.0,27.0,"ign: assign,bs:bes,",97.0,0.0652171730995178,Greedy
2495,"static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);



    r->req.status = status;

    scsi_disk_set_sense(s, sense_code);

}
","static void scsi_req_set_status(SCSIDiskReq *rs, int state, int sense_code)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, rs->req.dev);



    rs->req.state = state;

    scsi_disk_set_sense(s, sense_code);

}
",48.0,14.0,"status:state,sense_code:sense_code,r:rs,",127.0,0.0793393770853678,Greedy
2497,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,

                              Error **errp)

{

    int val;



    backend->vc = g_new0(ChardevVC, 1);



    val = qemu_opt_get_number(opts, ""width"", 0);

    if (val != 0) {

        backend->vc->has_width = true;

        backend->vc->width = val;

    }



    val = qemu_opt_get_number(opts, ""height"", 0);

    if (val != 0) {

        backend->vc->has_height = true;

        backend->vc->height = val;

    }



    val = qemu_opt_get_number(opts, ""cols"", 0);

    if (val != 0) {

        backend->vc->has_cols = true;

        backend->vc->cols = val;

    }



    val = qemu_opt_get_number(opts, ""rows"", 0);

    if (val != 0) {

        backend->vc->has_rows = true;

        backend->vc->rows = val;

    }

}
","static void qemu_chr_parse_vc(QemuOpts * ops, ChardevBackend *bender,

                              Error **err)

{

    int val;



    bender->vc = g_new0(ChardevVC, 1);



    val = qemu_opt_get_number( ops, ""width"", 0);

    if (val != 0) {

        bender->vc->has_width = true;

        bender->vc->width = val;

    }



    val = qemu_opt_get_number( ops, ""height"", 0);

    if (val != 0) {

        bender->vc->has_height = true;

        bender->vc->height = val;

    }



    val = qemu_opt_get_number( ops, ""cols"", 0);

    if (val != 0) {

        bender->vc->has_cols = true;

        bender->vc->cols = val;

    }



    val = qemu_opt_get_number( ops, ""rows"", 0);

    if (val != 0) {

        bender->vc->has_rows = true;

        bender->vc->rows = val;

    }

}
",177.0,36.0,"backend:bender,errp:err,opts: ops,",197.0,0.1253198862075805,Greedy
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
","static void mm_stop_timer(struct qemu_alarm_timer *w)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",21.0,6.0,"t:w,",33.0,0.022647746404012,Greedy
2517,"QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
","QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *S = qemu_mallocz(sizeof(QEMUFileFD));



    if (S == NULL)

        return NULL;



    S->fd = fd;

    S->file = qemu_fopen_ops(S, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return S->file;

}
",58.0,15.0,"s:S,",80.0,0.0298656105995178,Greedy
2522,"static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,

                struct usb_hci_out_fifo_s *fifo,

                void (*send)(struct HCIInfo *, const uint8_t *, int),

                int (*complete)(const uint8_t *, int),

                const uint8_t *data, int len)

{

    if (fifo->len) {

        memcpy(fifo->data + fifo->len, data, len);

        fifo->len += len;

        if (complete(fifo->data, fifo->len)) {

            send(s->hci, fifo->data, fifo->len);

            fifo->len = 0;

        }

    } else if (complete(data, len))

        send(s->hci, data, len);

    else {

        memcpy(fifo->data, data, len);

        fifo->len = len;

    }



    /* TODO: do we need to loop? */

}
","static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,

                struct usb_hci_out_fifo_s *fifode,

                void (*send)(struct HCIInfo *, const uint8_t *, int),

                int (*complete)(const uint8_t *, int),

                const uint8_t *data, int len)

{

    if (fifode->len) {

        memcpy(fifode->data + fifode->len, data, len);

        fifode->len += len;

        if (complete(fifode->data, fifode->len)) {

            send(s->hci, fifode->data, fifode->len);

            fifode->len = 0;

        }

    } else if (complete(data, len))

        send(s->hci, data, len);

    else {

        memcpy(fifode->data, data, len);

        fifode->len = len;

    }



    /* TODO: do we need to loop? */

}
",161.0,36.0,"fifo:fifode,",171.0,0.0773732384045918,Greedy
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
","static int mov_read_ares(MOVContext *icc, AVIOContext *tmp, MOVAtom temp)

{

    AVCodecContext *Codex = icc->fc->streams[icc->fc->nb_streams-1]->Codex;

    if (Codex->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        Codex->codec_id == AV_CODEC_ID_H264 &&

        temp.size > 11) {

        avio_skip(tmp, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(tmp) == 0xd4d)

            Codex->width = 1440;

        return 0;

    }



    return mov_read_avid(icc, tmp, temp);

}
",108.0,21.0,"pb:tmp,codec:Codex,c:icc,atom:temp,",231.0,0.1498203555742899,Greedy
2543,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}
","static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int win, int access){

    int i;



    for(i=0; i<win-1; i++){

        access+= src[i];

        dst[i]= access & mask;

        i++;

        access+= src[i];

        dst[i]= access & mask;

    }



    for(; i<win; i++){

        access+= src[i];

        dst[i]= access & mask;

    }



    return access;

}
",110.0,37.0,"w:win,acc:access,",148.0,0.0853810707728068,Greedy
2550,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
","static size_t get_request_size(VirtQueue *vQ)

{

    unsigned int win, out;



    virtqueue_get_avail_bytes(vQ, &win, &out);

    return win;

}
",30.0,9.0,"in:win,vq:vQ,",88.0,0.0607166091601053,Greedy
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
","static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *aws = avctx->priv_data;



    aws->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    aws->width = avctx->width;

    aws->height = avctx->height;



    aws->last_frame    = av_frame_alloc();

    aws->current_frame = av_frame_alloc();

    if (!aws->current_frame || !aws->last_frame) {

        av_frame_free(&aws->current_frame);

        av_frame_free(&aws->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
",132.0,31.0,"s:aws,",92.0,0.0692552049954732,Greedy
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void render_line(int x0, uint8_t y0, int ix01, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = ix01 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, ix01, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int px     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++px < ix01) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[px] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",170.0,59.0,"x:px,x1:ix01,",86.0,0.0611409624417622,Greedy
2565,"static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;



    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}
","static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *ptr = NULL, *lc = NULL;



    do {

        FFSWAP(BufferPoolEntry*, ptr, lc);

        ptr = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, lc, NULL);

        if (!ptr)

            return NULL;

    } while (ptr != lc);



    return ptr;

}
",73.0,15.0,"last:lc,cur:ptr,",125.0,0.0679235498110453,Greedy
2575,"static void ccw_machine_2_9_class_options(MachineClass *mc)

{

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(mc);

    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}
","static void ccw_machine_2_9_class_options(MachineClass *tc)

{

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(tc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(tc);

    SET_MACHINE_COMPAT(tc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}
",43.0,12.0,"mc:tc,",53.0,0.0345232725143432,Greedy
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}
","static uint32_t pcihotplug_read(void *opusacity, uint32_t alt)

{

    uint32_t val = 0;

    struct pci_status *w = opusacity;

    switch (alt) {

        case PCI_BASE:

            val = w->up;

            break;

        case PCI_BASE + 4:

            val = w->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", alt, val);

    return val;

}
",73.0,17.0,"addr:alt,g:w,opaque:opusacity,",137.0,0.0765583952267964,Greedy
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *ctx, uint8_t *dst, long  src_address)

{

	long ii;

	long num_pixels =  src_address >> 1;



	for(ii=0; ii<num_pixels; ii++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = ctx[2*ii];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*ii] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",121.0,29.0,"src:ctx,src_size: src_address,i:ii,",134.0,0.0771542509396871,Greedy
2582,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
","int vnc_job_add_rect(VncJob *node, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&node->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
",90.0,25.0,"job:node,",61.0,0.0412774324417114,Greedy
2584,"static void tracked_request_end(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, list);

    qemu_co_queue_restart_all(&req->wait_queue);

}
","static void tracked_request_end(BdrvTrackedRequest *dr)

{

    if (dr->serialising) {

        dr->bs->serialising_out_queue--;

    }



    QLIST_REMOVE(dr, list);

    qemu_co_queue_restart_all(&dr->wait_queue);

}
",40.0,9.0,"serialising_in_flight:serialising_out_queue,req:dr,",74.0,0.0387662410736084,Greedy
2588,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}
","static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acc = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acc = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acc, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acc;

}
",195.0,44.0,"acl:acc,",92.0,0.0467752456665039,Greedy
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        memory_region_get_dirty_log_mask(mr));

}
","void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr ish)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, ish,

                                        memory_region_get_dirty_log_mask(mr));

}
",38.0,12.0,"size:ish,",38.0,0.0234592715899149,Greedy
2593,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}","static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *rs = avctx->priv_data;
    ff_qsv_decode_close(&rs->qsv);
    qsv_clear_buffers(rs);
    av_fifo_free(rs->packet_fifo);
    return 0;
}",42.0,11.0,"s:rs,",62.0,0.0373585224151611,Greedy
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);

    }

}
","static void armv7m_nvic_clear_pending(void *opque, int igrq)

{

    NVICState bess = (NVICState *)opque;

    VecInfo *vec;



    assert(igrq > ARMV7M_EXCP_RESET && igrq < bes->num_irq);



    vecvec&sbes>vectors[igrq];

    trace_nvic_clear_pending(igrq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(bes);

    }

}
",82.0,22.0,"opaque:opque,irq:igrq,s:bes,vec:vec,",286.0,0.1715177257855733,GA
2598,"static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = SCSI_DEVICE(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    }

    scsi_device_destroy(dev);

    return 0;

}
","static int scsi_qdev_exit(DeviceState *sqdiv)

{

    SCSIDevice *ddiff= SCSI_DEVICE(sqdiv);



    if (diff->vmsentry) {

        qemu_del_vm_change_state_handler(diff->vmsentry);

    }

    scsi_device_destroy(diff);

    return 0;

}
",42.0,10.0,"qdev:sqdiv,dev:diff,",332.0,0.1814209342002868,GA
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}
","int check_tm_pred4x4_mode(int node, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? node : HOR_VP8_PRED;

    }

}
",38.0,11.0,"mode:node,",51.0,0.0427134354909261,Greedy
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
","void error_setg_win32(Error **errp, int win16_nr, const char *fmt, ...)

{

    va_list address;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(address, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, address);

    va_end(address);



    if (win16_nr != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win16_nr);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win16_nr);

        g_free(msg2);

        g_free(msg1);

    }

}
",119.0,33.0,"win32_err:win16_nr,ap:address,",99.0,0.0505669554074605,Greedy
2615,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
","void *rom_ptr(target_phys_addr_t ref)

{

    Rom *hom;



    hom = find_rom(ref);

    if (!hom || !hom->data)

        return NULL;

    return hom->data + (ref - hom->ref);

}
",46.0,11.0,"rom:hom,addr:ref,",135.0,0.0731138428052266,Greedy
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
","static int bdrv_read_em(BlockDriverState *bos, int64_t  sector_number,

                        uint8_t *bag, int nb_sector)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec  ensemble;

    QEMUIOVector wicho;



    async_ret = NOT_DONE;

     ensemble.iov_base = (void *)bag;

     ensemble.iov_len = nb_sector * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&wicho, & ensemble, 1);



    acb = bos->drv->bdrv_aio_readv(bos,  sector_number, &wicho, nb_sector,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
",122.0,33.0,"qiov:wicho,bs:bos,iov: ensemble,sector_num: sector_number,nb_sectors:nb_sector,buf:bag,",276.0,0.1834614992141723,Greedy
2625,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
","static int decode_5(SANMVideoContext *cms)

{

#if HAVE_BIGENDIAN

    uint16_t *fd;

    int  npamples;

#endif

    uint8_t *rddr = (uint8_t*)cms->frm0;



    if (rle_decode(cms, rddr, cms->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

     npamples = cms-> npamples;

    fd = cms->frm0;

    while ( npamples--)

        *fd++ = av_bswap16(*fd);

#endif



    return 0;

}
",83.0,21.0,"ctx:cms,dst:rddr,frm:fd,npixels: npamples,",194.0,0.1199180165926615,Greedy
2626,"static void aux_bridge_init(Object *obj)

{

    AUXTOI2CState *s = AUXTOI2C(obj);



    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");

}
","static void aux_bridge_init(Object *node)

{

    AUXTOI2CState *rs = AUXTOI2C(node);



    rs->i2c_bus = i2c_init_bus(DEVICE(node), ""aux-i2c"");

}
",34.0,9.0,"obj:node,s:rs,",94.0,0.0715545415878295,Greedy
2627,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
","static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *call = data->call;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(call, NULL);

}
",51.0,13.0,"co:call,",57.0,0.0492767373720804,Greedy
2631,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
","static void flat_print_key_prefix(WriterContext *ewsci)

{

    FlatContext *txt = ewsci->priv;

    const struct section *Parent_sect = ewsci->section[ewsci->level-1];



    printf(""%s"", txt->section_header[ewsci->level].str);



    if (Parent_sect->flags & SECTION_FLAG_IS_ARRAY) {

        int n = Parent_sect->id == SECTION_ID_PACKETS_AND_FRAMES ?

            ewsci->nb_section_packet_frame : ewsci->nb_item[ewsci->level-1];

        printf(""%d%s"", n, txt->sep_str);

    }

}
",98.0,21.0,"wctx:ewsci,parent_section:Parent_sect,flat:txt,",165.0,0.0750619570414225,Greedy
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}","static inline void hyscale_fast_c(SwsContext *context, int16_t *dst, int  dSTW,

                                  const uint8_t *support, int srcW, int exEnc)

{

    int f;

    unsigned int xpos=0;

    for (f=0;f< dSTW;f++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[f]= (support[xx]<<7) + (support[xx+1] - support[xx])*xalpha;

        xpos+=exEnc;

    }



}",109.0,28.0,"xInc:exEnc,i:f,dstWidth: dSTW,c:context,src:support,",211.0,0.1342698693275451,Greedy
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t node)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", node);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(node, 0, 0, 0, 4);

#endif

    return 0;

}
",61.0,12.0,"addr:node,",53.0,0.0404835700988769,Greedy
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
","static void qvirtio_scsi_pci_free(QVirtIOSCSI *ports)

{

    int v;



    for (v = 0; v < ports->num_queues + 2; v++) {

        qvirtqueue_cleanup(ports->dev->bus, ports->vq[v], ports->alloc);

    }

    pc_alloc_uninit(ports->alloc);

    qvirtio_pci_device_disable(container_of(ports->dev, QVirtioPCIDevice, vdev));

    g_free(ports->dev);

    qpci_free_pc(ports->bus);

    g_free(ports);

}
",92.0,25.0,"i:v,vs:ports,",130.0,0.069896646340688,Greedy
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
","void spapr_clear_pending_events(sPAPRMachineState *scaper)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &scaper->pending_events, next) {

        QTAILQ_REMOVE(&scaper->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
",53.0,15.0,"spapr:scaper,",75.0,0.0454634586970011,Greedy
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *sb, uint32_t *acsrc, int SC)

{

    int option;



    if(sb->extra_bits){

        SC <<= sb->extra_bits;



        if(sb->got_extra_bits){

            SC |= get_bits(&sb->gb_extra_bits, sb->extra_bits);

            *acsrc = *acsrc * 9 + (SC&0xffff) * 3 + ((unsigned)SC>>16);

        }

    }

    option = (SC & sb->and) | sb->or;

    return (((SC + option) << sb->shift) - option) << sb->post_shift;

}
",117.0,26.0,"s:sb,bit:option,S:SC,crc:acsrc,",227.0,0.1240794380505879,Greedy
2664,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
","void qmp_inject_nmi(Error ** errP)

{

#if defined(TARGET_I386)

    CPUState *cache;



    CPU_FOREACH(cache) {

        X86CPU *console = X86_CPU(cache);



        if (!console->apic_state) {

            cpu_interrupt(cache, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(console->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(),  errP);

#endif

}
",72.0,17.0,"errp: errP,cpu:console,cs:cache,",135.0,0.0921050270398457,Greedy
2667,"do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
","do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int dsums[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; dsums[i^=1] += *dp++)

        ;

    sum = (dsums[0] << 8) + dsums[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
",93.0,20.0,"bsum:dsums,",69.0,0.0541826725006103,Greedy
2668,"static void ics_simple_realize(DeviceState *dev, Error **errp)

{

    ICSState *ics = ICS_SIMPLE(dev);



    if (!ics->nr_irqs) {

        error_setg(errp, ""Number of interrupts needs to be greater 0"");

        return;

    }

    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));

    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);



    qemu_register_reset(ics_simple_reset, dev);

}
","static void ics_simple_realize(DeviceState *dev, Error **nerP)

{

    ICSState *cycles = ICS_SIMPLE(dev);



    if (!cycles->nr_irqs) {

        error_setg(nerP, ""Number of interrupts needs to be greater 0"");

        return;

    }

    cycles->irqs = g_malloc0(cycles->nr_irqs * sizeof(ICSIRQState));

    cycles->qirqs = qemu_allocate_irqs(ics_simple_set_irq, cycles, cycles->nr_irqs);



    qemu_register_reset(ics_simple_reset, dev);

}
",81.0,21.0,"ics:cycles,dev:dev,errp:nerP,",155.0,0.1029399871826171,Greedy
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
","VncJob *vnc_job_new(VncState *ns)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->ns = ns;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
",49.0,14.0,"vs:ns,",55.0,0.0383347789446512,Greedy
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		tcg_temp_free(c);

	}

}
","static inline void t_gen_addx_carry(DisasContext *DC, TCGv dt)

{

	if (DC->flagx_known) {

		if (DC->flags_x) {

			TCGv t;

            

			t = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(t, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(t, t, C_FLAG);

			tcg_gen_add_tl(dt, dt, t);

			tcg_temp_free(t);

		}

	} else {

		TCGv cross, t;



		cross = tcg_temp_new(TCG_TYPE_TL);

		t = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(cross, PR_CCS);

		tcg_gen_mov_tl(t, cross);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(t, t, C_FLAG);

		tcg_gen_andi_tl(cross, cross, X_FLAG);

		tcg_gen_shri_tl(cross, cross, 4);



		tcg_gen_and_tl(cross, cross, t);

		tcg_gen_add_tl(dt, dt, cross);        

		tcg_temp_free(cross);

		tcg_temp_free(t);

	}

}
",161.0,59.0,"d:dt,x:cross,c:t,dc:DC,",237.0,0.1282964587211608,Greedy
2686,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
","static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opters)

{

    const char *filename = opters->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
",91.0,25.0,"opts:opters,",46.0,0.0293951908747355,Greedy
2693,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
","void ppc970_irq_init (CPUState *exec)

{

    exec->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, exec, 7);

}
",28.0,6.0,"env:exec,",58.0,0.0374600291252136,Greedy
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
","void stq_tce(VIOsPAPRDevice *reg, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(reg, taddr, &val, sizeof(val));

}
",37.0,12.0,"dev:reg,",53.0,0.0291387160619099,Greedy
2701,"test_opts_dict_unvisited(void)

{

    QemuOpts *opts;

    Visitor *v;

    UserDefOptions *userdef;



    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,

                           &error_abort);



    v = opts_visitor_new(opts);

    /* BUG: bogus should be diagnosed */

    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);

    visit_free(v);

    qemu_opts_del(opts);

    qapi_free_UserDefOptions(userdef);

}
","test_opts_dict_unvisited(void)

{

    QemuOpts *opts;

    Visitor *verb;

    UserDefOptions *userblock;



    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,

                           &error_abort);



    verb = opts_visitor_new(opts);

    /* BUG: bogus should be diagnosed */

    visit_type_UserDefOptions(verb, NULL, &userblock, &error_abort);

    visit_free(verb);

    qemu_opts_del(opts);

    qapi_free_UserDefOptions(userblock);

}
",72.0,21.0,"v:verb,userdef:userblock,",95.0,0.0578460137049357,Greedy
2712,"static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
","static inline int test_bit(unsigned int bit, const unsigned long *app)

{

    return !!((app)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
",45.0,8.0,"map:app,",44.0,0.0464542229970296,Greedy
2714,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
","static int qmp_tmp105_get_temperature(const char *address)

{

    QDict *message;

    int ref;



    message = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", address);

    g_assert(qdict_haskey(message, ""return""));

    ref = qdict_get_int(message, ""return"");

    QDECREF(message);

    return ref;

}
",59.0,16.0,"response:message,id:address,ret:ref,",142.0,0.0942036390304565,Greedy
2716,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
","static void pci_hotplug(void)

{

    QVirtioPCIDevice *gd;

    QOSState *sync;

    const char *str = qtest_get_arch();



    sync = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    gd = virtio_blk_pci_init(sync->pcibus, PCI_SLOT_HP);

    g_assert(gd);

    qvirtio_pci_device_disable(gd);

    g_free(gd);



    /* unplug secondary disk */

    if (strcmp(str, ""i386"") == 0 || strcmp(str, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(sync);

}
",108.0,27.0,"dev:gd,arch:str,qs:sync,",165.0,0.0985350171724955,Greedy
2719,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
","static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int Argv, ide_idxe;

    Backend abi;



    Argv = setup_common(argv, ARRAY_SIZE(argv));

    for (abi = 0; abi <= backend_empty; abi++) {

        ide_idxe = backend_empty - abi;

        cur_ide[ide_idxe] = &hd_chst[abi][mbr_blank];

        Argv = setup_ide(Argv, argv, ARRAY_SIZE(argv),

                         ide_idxe, NULL, abi, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
",114.0,36.0,"argc:Argv,ide_idx:ide_idxe,i:abi,",194.0,0.1249739249547322,Greedy
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
","AddressSpace *pci_device_iommu_address_space(PCIDevice *diff)

{

    PCIBus *die = PCI_BUS(diff->die);

    PCIBus *iommu_bus = die;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->die);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(die, iommu_bus->iommu_opaque, diff->devfn);

    }

    return &address_space_memory;

}
",83.0,20.0,"bus:die,dev:diff,",119.0,0.0864168246587117,Greedy
2730,"static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,

                                            target_phys_addr_t base,

                                            qemu_irq txirq, qemu_irq rxirq,

                                            qemu_irq *dma, omap_clk clk)

{

    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)

            g_malloc0(sizeof(struct omap_mcbsp_s));



    s->txirq = txirq;

    s->rxirq = rxirq;

    s->txdrq = dma[0];

    s->rxdrq = dma[1];

    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);

    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);

    omap_mcbsp_reset(s);



    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
","static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion * system_network,

                                            target_phys_addr_t work,

                                            qemu_irq txirk, qemu_irq rhirquest,

                                            qemu_irq *dma, omap_clk clk)

{

    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)

            g_malloc0(sizeof(struct omap_mcbsp_s));



    s->txirk = txirk;

    s->rhirquest = rhirquest;

    s->txdrq = dma[0];

    s->rxdrq = dma[1];

    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);

    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);

    omap_mcbsp_reset(s);



    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);

    memory_region_add_subregion( system_network, work, &s->iomem);



    return s;

}
",141.0,38.0,"base:work,rxirq:rhirquest,txirq:txirk,system_memory: system_network,",208.0,0.1483970363934834,Greedy
