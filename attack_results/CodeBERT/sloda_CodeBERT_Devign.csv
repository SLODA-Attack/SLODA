Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost,Attack Type
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        quantization_tables=NewXMLTree(xml,exception);
        quantization_tables=DestroyXMLTree(quantization_tables);
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        return RTAS_OUT_SUCCESS;
    }
}",0,1,12,0.28,Insert
6,,,,,,,
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int dc = block[0];
    const uint8_t *cm;
    dc = (3 * dc +  1) >> 1;
    dc = (3 * dc + 16) >> 5;
    cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}","static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int dc = block[0];
    const uint8_t *cm;
    dc = (3 * dc +  1) >> 1;
    dc = (3 * dc + 16) >> 5;
    int a = 2;
    int b = 3;
    if (a != b) {
        cm = ff_cropTbl + MAX_NEG_CROP + dc;
    }
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}",1,0,2,0.09,Replace
12,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();","void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    int a = 2;
    int b = 3;
    long carry, tempdays, temp;
    exsltDateValDurationPtr u;
    exsltDateValDatePtr r, d;
    exsltDateValDatePtr r, d;
    carry  = d->mon + u->mon;
    r->mon = (unsigned int)MODULO_RANGE(carry, 1, 13);
    carry  = (long)FQUOTIENT_RANGE(carry, 1, 13);
    r->year = d->year + carry;
    carry  = (long)FQUOTIENT((long)r->sec, 60);
    while (a < b) {
        x0 = T0 | ((uint64_t) (env->y) << 32);
        const int Elemmizing;
        const int fc;
        void *y_lab;
        uint8_t* address[256 + 2*YUVRGB_TABLE_HEADROOM];
        uint8_t *yactable = y_lab;
        int i;
        for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
                int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*fc;
                address[i] = yactable + Elemmizing * (cb >> 16);
        }
        b = a;
    }
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",1,0,58,0.73,Insert
13,"void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    cpu_x86_update_cr0(env);
}","void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    int a = 2;
    int b = 2;
    if (a == b) {
        cpu_x86_update_cr0(env);
        u64 id;
        struct blkif_response *resp;
        resp->id        = id;
    }
}",0,1,19,0.25,Insert
14,"int qemu_cpu_self(void *env)
{
    return 1;
}","int qemu_cpu_self(void *env)
{
    struct cfg80211_registered_device *rdev;
    struct sk_buff *img;
    NLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
    genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,
    				nl80211_mlme_mcgrp.id, GFP_KERNEL);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 1;
    strcpy(str, ""a"");
    }
}",0,1,8,0.18,Insert
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)
{
    s->nc.link_down = link_down;
    if (s->nc.peer) {
        s->nc.peer->link_down = link_down;
    }
    if (s->nc.info->link_status_changed) {
        s->nc.info->link_status_changed(&s->nc);
    }
    if (s->nc.peer && s->nc.peer->info->link_status_changed) {
        s->nc.peer->info->link_status_changed(s->nc.peer);
    }
}","static void net_vhost_link_down(VhostUserState *s, bool link_down)
{
    s->nc.link_down = link_down;
    if (s->nc.peer) {
        int a = 2;
        struct CallCount *pb;
        if( pb ) pb->nStep = 1;
        int b = 3;
        if (a != b) {
            s->nc.peer->link_down = link_down;
        }
    }
    if (s->nc.info->link_status_changed) {
        s->nc.info->link_status_changed(&s->nc);
    }
    if (s->nc.peer && s->nc.peer->info->link_status_changed) {
        s->nc.peer->info->link_status_changed(s->nc.peer);
    }
}",0,1,13,0.44,Insert
18,"START_TEST(qint_get_int_test)
{
    QInt *qi;
    const int value = 123456;
    qi = qint_from_int(value);
    fail_unless(qint_get_int(qi) == value);
    QDECREF(qi);
}","START_TEST(qint_get_int_test)
{
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    hwaddr array;
    PowerPCCPU *cpu;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    CPUPPCState *viron = &cpu->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu, pte_index);
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    QInt *qi;
    int a = 97;
    int b = a;
    if(a*b>0){
        const int value = 123456;
    }
    qi = qint_from_int(value);
    fail_unless(qint_get_int(qi) == value);
    QDECREF(qi);
}",0,1,75,0.59,Insert
21,,,,,,,
23,,,,,,,
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,
                             uint32_t length)
{
    int n, i, r, g, b;
    if ((length % 3) != 0 || length > 256 * 3)
        return AVERROR_INVALIDDATA;
    n = length / 3;
    for (i = 0; i < n; i++) {
        r = bytestream2_get_byte(&s->gb);
        g = bytestream2_get_byte(&s->gb);
        b = bytestream2_get_byte(&s->gb);
        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
    }
    for (; i < 256; i++)
        s->palette[i] = (0xFFU << 24);
    s->state |= PNG_PLTE;
    bytestream2_skip(&s->gb, 4);      
    return 0;
}","static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,
                             uint32_t length)
{
    int n, i, r, g, b;
    struct sock *nowshop;
    spl_filesystem_object *eng = (spl_filesystem_object*)object;
    if (eng->_path) {
     		efree(eng->_path);
    }
    const struct ipv6_pinfo *sync = inet6_sk(sh);
    struct inet_sock *againintel;
    struct dccp6_sock *nextdp4;
    struct inet_request_sock *ireq = inet_rsk(req);
    nowshop = dccp_create_openreq_child(sh, req, skin);
    ip6_dst_store(nowshop, dst, NULL, NULL);
    nowshop->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |
    						      NETIF_F_TSO);
    						      BlockDriverState *bs;
    						      uint64_t offset;
    						      BDRVVHDXState *s_8;
    						      uint32_t desc_sectors, sectors, total_length;
    						      void *buffer = NULL;
    						      int sector_offset;
    						      uint64_t file_offset;
    						      uint32_t desc_sectors, sectors, total_length;
    						      VHDXLogEntryHeader new_hdr;
    						      sector_offset = offset % VHDX_LOG_SECTOR_SIZE;
    						      file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;
    						      new_hdr = (VHDXLogEntryHeader) {
    						                      .signature           = VHDX_LOG_SIGNATURE,
    						                      .tail                = s_8->log.tail,
    						                      .sequence_number     = s_8->log.sequence,
    						                      .descriptor_count    = sectors,
    						                      .reserved            = 0,
    						                      .flushed_file_offset = bdrv_getlength(bs->file->bs),
    						                      .last_file_offset    = bdrv_getlength(bs->file->bs),
    						                    };
    						      vhdx_update_checksum(buffer, total_length,
    						                               offsetof(VHDXLogEntryHeader, checksum));
    nextdp4 = (struct dccp6_sock *)nowshop;
    againintel = inet_sk(nowshop);
    if ((length % 3) != 0 || length > 256 * 3)
        return AVERROR_INVALIDDATA;
    n = length / 3;
    for (i = 0; i < n; i++) {
        r = bytestream2_get_byte(&s->gb);
        g = bytestream2_get_byte(&s->gb);
        b = bytestream2_get_byte(&s->gb);
        int a_1 = 43;
        int b_1 = a_1;
        if(a_1*b_1>0){
            s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
        }
    }
    for (; i < 256; i++)
        s->palette[i] = (0xFFU << 24);
    s->state |= PNG_PLTE;
    bytestream2_skip(&s->gb, 4);      
    return 0;
}",1,0,81,1.08,Insert
28,,,,,,,
29,,,,,,,
30,"static void mem_begin(MemoryListener *listener)
{
    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);
    d->phys_map.ptr = PHYS_MAP_NODE_NIL;
}","static void mem_begin(MemoryListener *listener)
{
    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);
    int a = 2;
    int b = 3;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    while (a < b) {
        d->phys_map.ptr = PHYS_MAP_NODE_NIL;
        b = a;
    }
}",0,1,32,0.42,Insert
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)
{
    uint32_t rgb = 0;
    if (bpp == 32) {
        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;
        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;
        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;
        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;
    }
    if (bpp == 16) {
        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;
        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;
    }
    return rgb;
}","static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)
{
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    uint32_t rgb = 0;
    if (bpp == 32) {
        int a = 2;
        int b = 3;
        while (a != b) {
            rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;
            b = a;
        }
        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;
        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;
        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;
    }
    if (bpp == 16) {
        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;
        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;
    }
    return rgb;
}",0,1,18,0.61,Insert
33,"void stream_start(const char *job_id, BlockDriverState *bs,
                  BlockDriverState *base, const char *backing_file_str,
                  int64_t speed, BlockdevOnError on_error,
                  BlockCompletionFunc *cb, void *opaque, Error **errp)
{
    StreamBlockJob *s;
    s = block_job_create(job_id, &stream_job_driver, bs, speed,
                         cb, opaque, errp);
    if (!s) {
        return;
    }
    s->base = base;
    s->backing_file_str = g_strdup(backing_file_str);
    s->on_error = on_error;
    s->common.co = qemu_coroutine_create(stream_run);
    trace_stream_start(bs, base, s, s->common.co, opaque);
    qemu_coroutine_enter(s->common.co, s);
}","void stream_start(const char *job_id, BlockDriverState *bs,
                  BlockDriverState *base, const char *backing_file_str,
                  int64_t speed, BlockdevOnError on_error,
                  BlockCompletionFunc *cb, void *opaque, Error **errp)
{
    StreamBlockJob *s;
    s = block_job_create(job_id, &stream_job_driver, bs, speed,
                         cb, opaque, errp);
    if (!s) {
        return;
    }
    s->base = base;
    s->backing_file_str = g_strdup(backing_file_str);
    s->on_error = on_error;
    s->common.co = qemu_coroutine_create(stream_run);
    trace_stream_start(bs, base, s, s->common.co, opaque);
    int a = 2;
    int b = 3;
    while (a < b) {
        qemu_coroutine_enter(s->common.co, s);
        b = a;
    }
}",1,0,1,0.08,Replace
35,"static int omap_gpio_init(SysBusDevice *sbd)
{
    DeviceState *dev = DEVICE(sbd);
    struct omap_gpif_s *s = OMAP1_GPIO(dev);
    if (!s->clk) {
        hw_error(""omap-gpio: clk not connected\n"");
    }
    qdev_init_gpio_in(dev, omap_gpio_set, 16);
    qdev_init_gpio_out(dev, s->omap1.handler, 16);
    sysbus_init_irq(sbd, &s->omap1.irq);
    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,
                          ""omap.gpio"", 0x1000);
    sysbus_init_mmio(sbd, &s->iomem);
    return 0;
}","static int omap_gpio_init(SysBusDevice *sbd)
{
    DeviceState *dev = DEVICE(sbd);
    struct omap_gpif_s *s = OMAP1_GPIO(dev);
    if (!s->clk) {
        hw_error(""omap-gpio: clk not connected\n"");
    }
    qdev_init_gpio_in(dev, omap_gpio_set, 16);
    qdev_init_gpio_out(dev, s->omap1.handler, 16);
    sysbus_init_irq(sbd, &s->omap1.irq);
    struct ext4_inode *raw_incode;
    long lag;
    struct inode *inode;
    if ((lon == EXT4_ROOT_INO) && (raw_incode->i_links_count == 0)) {
    		ext4_error_inode(inode, operation, ine, 0,
    				 ""iget: root inode unallocated"");
    		lag = -EFSCORRUPTED;
    		goto bad_inode;
    }
    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,
                          ""omap.gpio"", 0x1000);
    int a = 2;
    int b = 3;
    if (a != b) {
        sysbus_init_mmio(sbd, &s->iomem);
    }
    return 0;
}",1,0,30,0.67,Insert
36,,,,,,,
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)
{
    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )
       ) {
        float_raise(float_flag_invalid, status);
        return 0;
    }
    return
           ( a.low == b.low )
        && (    ( a.high == b.high )
             || (    ( a.low == 0 )
                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )
           );
}","int floatx80_eq(floatx80 a, floatx80 b, float_status *status)
{
    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )
       ) {
        float_raise(float_flag_invalid, status);
        char str_1[] = ""Constant"";
        while (strlen(str_1) > 5) {
            return 0;
        strcpy(str_1, ""a"");
        VirtIODevice *vrdevice;
        BlockConf *conf = &s_4->conf.conf;
        VirtIOBlock *s_4 = VIRTIO_BLK(vrdevice);
        int blk_size = conf->logical_block_size;
        struct virtio_blk_config blkcfg;
        virtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);
        virtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
        blkcfg.heads = conf->heads;
        blkcfg.size_max = 0;
        blkcfg.physical_block_exp = get_physical_block_exp(conf);
        }
        struct genl_info *part;
        struct station_del_parameters errors;
        struct cfg80211_registered_device *nddev = part->user_ptr[0];
        if (part->attrs[NL80211_ATTR_MAC])
        		errors.mac = nla_data(part->attrs[NL80211_ATTR_MAC]);
    }
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    return
           ( a.low == b.low )
        && (    ( a.high == b.high )
             || (    ( a.low == 0 )
                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )
           );
}",0,1,87,0.94,Insert
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)
{
    lexer->emit = func;
    lexer->state = IN_START;
    lexer->token = qstring_new();
    lexer->x = lexer->y = 0;
}","void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)
{
    struct edgeport_serial *serial;
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    status = -ENODEV;
    lexer->emit = func;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        lexer->state = IN_START;
    }
    lexer->token = qstring_new();
    lexer->x = lexer->y = 0;
}",0,1,65,0.57,Insert
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque, int type)
{
    struct qemu_paiocb *acb;
    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);
    if (!acb)
        return NULL;
    acb->aio_type = type;
    acb->aio_fildes = fd;
    acb->ev_signo = SIGUSR2;
    acb->async_context_id = get_async_context_id();
    if (qiov) {
        acb->aio_iov = qiov->iov;
        acb->aio_niov = qiov->niov;
    }
    acb->aio_nbytes = nb_sectors * 512;
    acb->aio_offset = sector_num * 512;
    acb->next = posix_aio_state->first_aio;
    posix_aio_state->first_aio = acb;
    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);
    qemu_paio_submit(acb);
    return &acb->common;
}","BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque, int type)
{
    struct qemu_paiocb *acb;
    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);
    if (!acb)
        return NULL;
    acb->aio_type = type;
    acb->aio_fildes = fd;
    acb->ev_signo = SIGUSR2;
    acb->async_context_id = get_async_context_id();
    if (qiov) {
        acb->aio_iov = qiov->iov;
        acb->aio_niov = qiov->niov;
    }
    acb->aio_nbytes = nb_sectors * 512;
    acb->aio_offset = sector_num * 512;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        BlockDriverState *btrvt;
        int mem;
        sg_io_hdr_t iloappdirector;
        mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
        acb->next = posix_aio_state->first_aio;
    strcpy(str, ""a"");
    }
    posix_aio_state->first_aio = acb;
    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);
    qemu_paio_submit(acb);
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    return &acb->common;
}",0,1,62,0.97,Insert
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)
{
    int i;
    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
        SliceThreadContext *p = avctx->internal->thread_ctx;
        p->thread_count  = avctx->thread_count;
        p->entries       = av_mallocz_array(count, sizeof(int));
        if (!p->entries) {
            return AVERROR(ENOMEM);
        }
        p->entries_count  = count;
        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));
        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));
        for (i = 0; i < p->thread_count; i++) {
            pthread_mutex_init(&p->progress_mutex[i], NULL);
            pthread_cond_init(&p->progress_cond[i], NULL);
        }
    }
    return 0;
}","int ff_alloc_entries(AVCodecContext *avctx, int count)
{
    int i;
    CPUState *cpu;
    unsigned int i_10;
    memset(&cpu->tb_jmp_cache[i_10], 0,
               TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
    memset(&cpu->tb_jmp_cache[i_10], 0,
               TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
        SliceThreadContext *p = avctx->internal->thread_ctx;
        p->thread_count  = avctx->thread_count;
        p->entries       = av_mallocz_array(count, sizeof(int));
        if (!p->entries) {
            return AVERROR(ENOMEM);
        }
        p->entries_count  = count;
        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));
        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));
        for (i = 0; i < p->thread_count; i++) {
            pthread_mutex_init(&p->progress_mutex[i], NULL);
            int a = 2;
            int b = 3;
            while (a < b) {
                pthread_cond_init(&p->progress_cond[i], NULL);
                b = a;
            }
        }
    }
    return 0;
}",1,0,38,0.9,Insert
42,,,,,,,
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)
{
    int i;
    for (i = 0; i < MIPS_FPU_MAX; i++)
        env->fpus[i].fcr0 = def->CP1_fcr0;
    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));
    if (env->user_mode_only) {
        if (env->CP0_Config1 & (1 << CP0C1_FP))
            env->hflags |= MIPS_HFLAG_FPU;
#ifdef TARGET_MIPS64
        if (env->active_fpu.fcr0 & (1 << FCR0_F64))
            env->hflags |= MIPS_HFLAG_F64;
#endif
    }
}","static void fpu_init (CPUMIPSState *env, const mips_def_t *def)
{
    int i;
    for (i = 0; i < MIPS_FPU_MAX; i++)
        env->fpus[i].fcr0 = def->CP1_fcr0;
    int a = 2;
    int b = 3;
    while (a != b) {
        memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));
        b = a;
    }
    if (env->user_mode_only) {
        struct sk_buff *img;
        nlmsg_free(img);
        if (env->CP0_Config1 & (1 << CP0C1_FP))
            env->hflags |= MIPS_HFLAG_FPU;
#ifdef TARGET_MIPS64
        if (env->active_fpu.fcr0 & (1 << FCR0_F64))
            env->hflags |= MIPS_HFLAG_F64;
#endif
    }
}",0,1,11,0.71,Insert
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    thread_pool_submit_aio(func, arg, NULL, NULL);
}","void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        thread_pool_submit_aio(func, arg, NULL, NULL);
        bool human;
        TestOutputVisitorData *data;
        data->human = human;
        data->sov = string_output_visitor_new(human);
        g_assert(data->sov);
        data->ov = string_output_get_visitor(data->sov);
        g_assert(data->ov);
    }
}",0,1,10,0.25,Insert
55,,,,,,,
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		dst[1]= palette[ src[i]*4+1 ];
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		stellaris_board_info *board;
    		qemu_irq *gpio_in[5];
    		qemu_irq *pic;
    		int i_5;
    		qemu_irq *gpio_out[5];
    		static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};
    		static const uint32_t gpio_addr[7] =
    		      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,
    		        0x40024000, 0x40025000, 0x40026000};
    		for (i_5 = 0; i_5 < 7; i_5++) {
    		        if (board->dc4 & (1 << i_5)) {
    		            gpio_in[i_5] = pl061_init(gpio_addr[i_5], pic[gpio_irq[i_5]],
    		                                    &gpio_out[i_5]);
    		        }
    		}
    		dst[1]= palette[ src[i]*4+1 ];
		}
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}",1,0,13,0.48,Insert
64,"void do_POWER_maskg (void)
{
    uint32_t ret;
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    T0 = ret;
}","void do_POWER_maskg (void)
{
    uint32_t ret;
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            ret = -1;
        strcpy(str, ""a"");
        long ret_7;
        if (ret_7 != -EACCES)
        		goto error;
        }
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    struct asd_sas_port *port = adr->port;
    struct domain_device *block, *nb;
    struct domain_device *block, *nb;
    list_for_each_entry_safe(block, nb, &port->destroy_list, disco_list_node)
    T0 = ret;
}",1,0,37,0.56,Insert
67,,,,,,,
70,"static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}","static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        AVStream *st = avformat_new_stream(s, NULL);
    }
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}",1,0,10,0.11,Replace
71,,,,,,,
73,"static void device_initfn(Object *obj)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop;
    if (qdev_hotplug) {
        dev->hotplugged = 1;
        qdev_hot_added = true;
    }
    dev->instance_id_alias = -1;
    dev->state = DEV_STATE_CREATED;
    qdev_prop_set_defaults(dev, qdev_get_props(dev));
    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {
        qdev_property_add_legacy(dev, prop, NULL);
        qdev_property_add_static(dev, prop, NULL);
    }
    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);
}","static void device_initfn(Object *obj)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        DeviceState *dev = DEVICE(obj);
    strcpy(str, ""a"");
    }
    Property *prop;
    if (qdev_hotplug) {
        dev->hotplugged = 1;
        qdev_hot_added = true;
    }
    dev->instance_id_alias = -1;
    dev->state = DEV_STATE_CREATED;
    qdev_prop_set_defaults(dev, qdev_get_props(dev));
    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {
        qdev_property_add_legacy(dev, prop, NULL);
        qdev_property_add_static(dev, prop, NULL);
    }
    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);
}",0,1,1,0.08,Replace
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    int sa, sb;
    sa = ((int64_t)*phigh < 0);
    if (sa)
        neg128(plow, phigh);
    sb = (b < 0);
    if (sb)
        b = -b;
    div64(plow, phigh, b);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (gst_date_time_get_second (dt) == gst_date_time_get_second (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    int sa, sb;
    sa = ((int64_t)*phigh < 0);
    if (sa)
        neg128(plow, phigh);
    sb = (b < 0);
    if (sb)
        b = -b;
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        div64(plow, phigh, b);
    strcpy(str_1, ""a"");
    }
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}",1,0,11,0.54,Insert
76,,,,,,,
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int ret;
    for(;;) {
        ret = write(s->fd, buf, size);
        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
    }
}","static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int a = 2;
    int b = 2;
    if (a == b) {
        int ret;
    }
    for(;;) {
        ret = write(s->fd, buf, size);
        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
        GF_BitStream *bits;
        GF_Box *s_8;
        GF_LASeRSampleEntryBox *buf_8 = (GF_LASeRSampleEntryBox*)s_8;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf_8, bits);
        ISOM_DECREASE_SIZE(buf_8, 8);
    }
}",0,1,34,0.62,Insert
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)
{
    DriveInfo *dinfo;
    Error *local_err = NULL;
    if (!dev->conf.bs) {
        scsi_realize(dev, &local_err);
        assert(local_err);
        error_propagate(errp, local_err);
        return;
    }
    dinfo = drive_get_by_blockdev(dev->conf.bs);
    if (dinfo->media_cd) {
        scsi_cd_realize(dev, errp);
    } else {
        scsi_hd_realize(dev, errp);
    }
}","static void scsi_disk_realize(SCSIDevice *dev, Error **errp)
{
    DriveInfo *dinfo;
    Error *local_err = NULL;
    if (!dev->conf.bs) {
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev_10 = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        scsi_realize(dev, &local_err);
        assert(local_err);
        error_propagate(errp, local_err);
        return;
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        dinfo = drive_get_by_blockdev(dev->conf.bs);
    }
    if (dinfo->media_cd) {
        scsi_cd_realize(dev, errp);
    } else {
        scsi_hd_realize(dev, errp);
    }
}",0,1,27,0.53,Insert
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)
{
    int cpu;
    bool first = true;
    GString *s = g_string_new(NULL);
    for (cpu = find_first_bit(cpus, max_cpus);
        cpu < max_cpus;
        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {
        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);
        first = false;
    }
    return g_string_free(s, FALSE);
}","static char *enumerate_cpus(unsigned long *cpus, int max_cpus)
{
    int cpu;
    bool first = true;
    int a = 2;
    int b = 3;
    if (a != b) {
        GString *s = g_string_new(NULL);
    }
    for (cpu = find_first_bit(cpus, max_cpus);
        cpu < max_cpus;
        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {
        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);
        first = false;
    }
    MachineState *machine;
    int i;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    PowerPCCPU *cpu_10;
    for (i = 0; i < smp_cpus; i++) {
            cpu_10 = cpu_ppc_init(machine->cpu_model);
            if (cpu_10 == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu_10, &error_fatal);
    }
    return g_string_free(s, FALSE);
}",0,1,13,0.54,Insert
84,"static void register_core_rtas(void)
{
    spapr_rtas_register(""display-character"", rtas_display_character);
    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);
    spapr_rtas_register(""power-off"", rtas_power_off);
}","static void register_core_rtas(void)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        spapr_rtas_register(""display-character"", rtas_display_character);
    strcpy(str, ""a"");
    }
    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);
    spapr_rtas_register(""power-off"", rtas_power_off);
}",1,0,5,0.05,Replace
85,,,,,,,
86,,,,,,,
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)
{
    ObjectProperty *prop = object_property_find(parent, part, NULL);
    if (prop == NULL) {
        return NULL;
    }
    if (object_property_is_link(prop)) {
        return *(Object **)prop->opaque;
    } else if (object_property_is_child(prop)) {
        return prop->opaque;
    } else {
        return NULL;
    }
}","Object *object_resolve_path_component(Object *parent, const gchar *part)
{
    ObjectProperty *prop = object_property_find(parent, part, NULL);
    if (prop == NULL) {
        return NULL;
    }
    if (object_property_is_link(prop)) {
        int a = 2;
        int b = 2;
        while (a == b) {
            return *(Object **)prop->opaque;
            b += 1;
        }
    } else if (object_property_is_child(prop)) {
        return prop->opaque;
    } else {
        return NULL;
    }
}",1,0,1,0.06,Replace
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)
{
    union viosrp_iu *iu = &req->iu;
    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
    uint64_t tag = iu->srp.rsp.tag;
    trace_spapr_vscsi__process_login();
    memset(iu, 0, sizeof(struct srp_login_rsp));
    rsp->opcode = SRP_LOGIN_RSP;
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);
    rsp->tag = tag;
    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);
}","static void vscsi_process_login(VSCSIState *s, vscsi_req *req)
{
    union viosrp_iu *iu = &req->iu;
    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
    uint64_t tag = iu->srp.rsp.tag;
    trace_spapr_vscsi__process_login();
    memset(iu, 0, sizeof(struct srp_login_rsp));
    rsp->opcode = SRP_LOGIN_RSP;
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);
    rsp->tag = tag;
    int a = 2;
    int b = 3;
    while (a < b) {
        unsigned char *p, *d, *iq;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        unsigned char *p, *d, *iq;
        long fn;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        if (p + job > d + fn) {
                bal = SSL_AD_DECODE_ERROR;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
                goto f_err;
        }
        rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
        b = a;
    }
    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);
}",1,0,26,0.71,Insert
90,,,,,,,
92,"int bdrv_is_removable(BlockDriverState *bs)
{
    return bs->removable;
}","int bdrv_is_removable(BlockDriverState *bs)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        err = extract32(ksns, 16, 5);
        handle_fp_compare(qs, order, coll, err, false, p);
        return bs->removable;
        b = a;
    }
}",0,1,4,0.28,Insert
93,,,,,,,
95,"void do_divwuo (void)
{
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        T0 = (uint32_t)T0 / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}","void do_divwuo (void)
{
    AVCodecContext *avctx;
    ICreateDevEnum *devenum = NULL;
    int r;
    r = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                             &IID_ICreateDevEnum, (void **) &devenum);
    PixletContext *tc = avctx->priv_data;
    WMAVoiceContext *s;
    AMRFixed *fcb;
    GetBitContext *gb;
    int block_idx;
    int pulse_off = s->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    int pulse_off = s->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    int pulse_off = s->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    int pulse_off = s->aw_first_pulse_off[block_idx],
            pulse_start, n, idx, range, aidx, start_off = 0;
    aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);
    fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0;
    if (bytestream2_get_be32(&tc->gb) != 1)
        bytestream2_skip(&tc->gb, 4);
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        T0 = (uint32_t)T0 / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            T0 = 0;
        }
    }
}",1,0,75,0.56,Insert
96,,,,,,,
97,,,,,,,
98,,,,,,,
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    imsg.iova = iova;
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    imsg.iova = iova;
    struct assoc_array_edit *edit;
    struct assoc_array_ptr *ptr;
    struct assoc_array_node *ne, *new_n0, *new_n1, *side;
    struct assoc_array_node *ne, *new_n0, *new_n1, *side;
    struct assoc_array_shortcut *shortcut, *new_s1;
    edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];
    edit->set[0].ptr = &assoc_array_ptr_to_node(ne->back_pointer)->slots[ne->parent_slot];
    edit->set[0].to = assoc_array_node_to_ptr(new_n0);
    edit->excised_meta[0] = assoc_array_node_to_ptr(ne);
    edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s1);
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
    strcpy(str, ""a"");
    }
}",1,0,15,0.34,Insert
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}","static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    uint32_t val;
    void *rma = NULL;
    hwaddr rma_alloc_size;
    rma_alloc_size = kvmppc_alloc_rma(&rma);
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    int a = 2;
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    int b = 3;
    if (a != b) {
        return val;
        GF_BitStream *bs;
        GF_Box *s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        GF_Err e;
        e = gf_isom_full_box_write(s, bs);
        gf_bs_write_u16(bs, cap->item_protection_index);
    }
}",0,1,74,0.62,Insert
102,"static void test_qemu_strtoull_overflow(void)
{
    const char *str = ""99999999999999999999999999999999999999999999"";
    char f = 'X';
    const char *endptr = &f;
    uint64_t res = 999;
    int err;
    err = qemu_strtoull(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, -ERANGE);
    g_assert_cmpint(res, ==, ULLONG_MAX);
    g_assert(endptr == str + strlen(str));
}","static void test_qemu_strtoull_overflow(void)
{
    int a_1 = 2;
    int b_1 = 3;
    if (a_1 != b_1) {
        const char *str = ""99999999999999999999999999999999999999999999"";
    }
    char f = 'X';
    const char *endptr = &f;
    uint64_t res = 999;
    int err;
    err = qemu_strtoull(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, -ERANGE);
    AVPacket *afpud;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    int buf_size = afpud->size;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    n = buf_size/sample_scale;
    g_assert_cmpint(res, ==, ULLONG_MAX);
    g_assert(endptr == str + strlen(str));
}",0,1,32,0.49,Insert
104,"int usb_device_delete_addr(int busnr, int addr)
{
    USBBus *bus;
    USBPort *port;
    USBDevice *dev;
    bus = usb_bus_find(busnr);
    if (!bus)
        return -1;
    TAILQ_FOREACH(port, &bus->used, next) {
        if (port->dev->addr == addr)
            break;
    }
    if (!port)
        return -1;
    dev = port->dev;
    TAILQ_REMOVE(&bus->used, port, next);
    bus->nused--;
    usb_attach(port, NULL);
    dev->info->handle_destroy(dev);
    TAILQ_INSERT_TAIL(&bus->free, port, next);
    bus->nfree++;
    return 0;
}","int usb_device_delete_addr(int busnr, int addr)
{
    USBBus *bus;
    bool lock;
    struct request_list *repl;
    uint16_t serial;
    uint8_t *view;
    struct genl_info *part;
    struct station_del_parameters errors;
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status_6 = *((__u8 *) skb->data_1);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data_1 = get_unaligned_le16(settings);
    struct cfg80211_registered_device *nddev = part->user_ptr[0];
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    if (part->attrs[NL80211_ATTR_MAC])
    		errors.mac = nla_data(part->attrs[NL80211_ATTR_MAC]);
    pci_config_set_device_id(view, serial);
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        USBPort *port;
    strcpy(str, ""a"");
    }
    USBDevice *dev;
    bus = usb_bus_find(busnr);
    if (!bus)
        return -1;
    TAILQ_FOREACH(port, &bus->used, next) {
        if (port->dev->addr == addr)
            break;
    }
    if (!port)
        return -1;
    dev = port->dev;
    TAILQ_REMOVE(&bus->used, port, next);
    const struct sun4d_hwdef *hawdecl;
    int ret;
    ram_addr_t gram_size, prom_reset, tcx64off;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *esp__set, *les_init;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *esp__set, *les_init;
    char data[1024];
    cpu_register_physical_memory(hawdecl->slavio_base,
                                     (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                     TARGET_PAGE_MASK,
                                     prom_reset | IO_MEM_ROM);
    ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
    sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
    espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                  ioulits[0], &espdma_iraque, &esp__set);
    ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                                 ioulits[0], &ledma_arquest, &les_init);
    bus->nused--;
    usb_attach(port, NULL);
    dev->info->handle_destroy(dev);
    TAILQ_INSERT_TAIL(&bus->free, port, next);
    bus->nfree++;
    return 0;
}",0,1,181,1.33,Insert
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qmp_output_add(qov, name, qfloat_from_double(*obj));
}","static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int v_10;
        int w_rev;
        w_rev = v_10;
        qmp_output_add(qov, name, qfloat_from_double(*obj));
        UserDefAnonUnion *var = NULL;
        Visitor *V;
        Error * erP = NULL;
        visit_type_UserDefAnonUnion(V, &var, NULL, & erP);
        g_assert(error_is_set(& erP));
    }
}",0,1,35,0.4,Insert
111,,,,,,,
112,"static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *ts;
    ts = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}","static void temp_allocate_frame(TCGContext *s, int temp)
{
    void *opaque;
    PCNetState *qs = opaque;
    pcnet_poll(qs);
    pcnet_update_irq(qs);
    int a = 2;
    int b = 2;
    if (a == b) {
        TCGTemp *ts;
    }
    ts = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}",0,1,18,0.56,Insert
113,"void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    BlockDriverState *bs;
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    bs = bdrv_find(device);
    if (!bs) {
        error_set(errp, QERR_DEVICE_NOT_FOUND, device);
        return;
    }
    if (base) {
        base_bs = bdrv_find_backing_image(bs, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(bs));
    trace_qmp_block_stream(bs, bs->job);
}","void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        BlockDriverState *bs;
        b += 1;
    }
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    bs = bdrv_find(device);
    if (!bs) {
        error_set(errp, QERR_DEVICE_NOT_FOUND, device);
        return;
    }
    if (base) {
        base_bs = bdrv_find_backing_image(bs, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(bs));
    trace_qmp_block_stream(bs, bs->job);
}",0,1,1,0.11,Replace
115,"static inline int num_effective_busses(XilinxSPIPS *s)
{
    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;
}","static inline int num_effective_busses(XilinxSPIPS *s)
{
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;
}",0,1,14,0.26,Insert
116,"FFTContext *av_fft_init(int nbits, int inverse)
{
    FFTContext *s = av_malloc(sizeof(*s));
    if (s && ff_fft_init(s, nbits, inverse))
        av_freep(&s);
    return s;
}","FFTContext *av_fft_init(int nbits, int inverse)
{
    unsigned char *p, *d, *iq;
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    unsigned char *p, *d, *iq;
    long fn;
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    if (p + job > d + fn) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
            goto f_err;
    }
    FFTContext *s = av_malloc(sizeof(*s));
    if (s && ff_fft_init(s, nbits, inverse))
        av_freep(&s);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return s;
    strcpy(str, ""a"");
    }
}",1,0,14,0.43,Insert
117,"static void gen_set_CF_bit31(TCGv var)
{
    TCGv tmp = new_tmp();
    tcg_gen_shri_i32(tmp, var, 31);
    gen_set_CF(tmp);
    dead_tmp(tmp);
}","static void gen_set_CF_bit31(TCGv var)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        TCGv tmp = new_tmp();
        struct sock *nowshop;
        ip6_dst_store(nowshop, dst, NULL, NULL);
        nowshop->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |
        						      NETIF_F_TSO);
        dccp_sync_mss(nowshop, dst_mtu(dst));
        b = a;
        gchar *str, *str2;
        gchar *str, *str2;
        GstDateTime *dt, *dt2;
        g_free (str2);
        g_free (str);
        str = gst_date_time_to_iso8601_string (dt);
        fail_unless (str != NULL);
        fail_unless_equals_string (str, ""2010-10"");
    }
    tcg_gen_shri_i32(tmp, var, 31);
    gen_set_CF(tmp);
    dead_tmp(tmp);
}",1,0,42,0.48,Insert
119,,,,,,,
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		struct perf_event *event;
		struct cpu_hw_events *cpuc;
		int i_3;
		struct hw_perf_event *hwc = &event->hw;
		hwc->idx = cpuc->assign[i_3];
		hwc->last_cpu = smp_processor_id();
		hwc->last_tag = ++cpuc->tags[i_3];
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		int a = 2;
		int b = 3;
		while (a != b) {
    		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
    		b = a;
		}
	}
}",1,0,11,0.77,Insert
122,"static uint32_t s390_pci_generate_fid(Error **errp)
{
    uint32_t fid = 0;
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        fid++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}","static uint32_t s390_pci_generate_fid(Error **errp)
{
    struct sock *Lister;
    struct vsock_sock *vcatel;
    vcatel = vsock_sk(Lister);
    sock_hold(Lister);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        uint32_t fid = 0;
    strcpy(str, ""a"");
    }
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        fid++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}",0,1,13,0.43,Insert
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    V9fsVirtioState *v = VIRTIO_9P(dev);
    V9fsState *s = &v->state;
    virtio_cleanup(vdev);
    v9fs_device_unrealize_common(s, errp);
}","static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    V9fsVirtioState *v = VIRTIO_9P(dev);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    int a = 2;
    int b = 2;
    if (a == b) {
        V9fsState *s = &v->state;
    }
    virtio_cleanup(vdev);
    v9fs_device_unrealize_common(s, errp);
}",0,1,11,0.44,Insert
124,"static int ipmovie_read_packet(AVFormatContext *s,
                               AVPacket *pkt)
{
    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;
    ByteIOContext *pb = &s->pb;
    int ret;
    ret = process_ipmovie_chunk(ipmovie, pb, pkt);
    if (ret == CHUNK_BAD)
        ret = AVERROR_INVALIDDATA;
    else if (ret == CHUNK_EOF)
        ret = AVERROR_IO;
    else if (ret == CHUNK_NOMEM)
        ret = AVERROR_NOMEM;
    else
        ret = 0;
    return ret;
}","static int ipmovie_read_packet(AVFormatContext *s,
                               AVPacket *pkt)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        DisplayState *ds;
        GtkDisplayState *s_8 = ds->opaque;
        if (s_8->surface) {
                cairo_surface_destroy(s_8->surface);
        }
        IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;
    }
    ByteIOContext *pb = &s->pb;
    int ret;
    ret = process_ipmovie_chunk(ipmovie, pb, pkt);
    if (ret == CHUNK_BAD)
        ret = AVERROR_INVALIDDATA;
    else if (ret == CHUNK_EOF)
        ret = AVERROR_IO;
    else if (ret == CHUNK_NOMEM)
        ret = AVERROR_NOMEM;
    else
        ret = 0;
    return ret;
}",1,0,18,0.65,Insert
126,"bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&queue->entries);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}","bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&queue->entries);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        qemu_coroutine_enter(next, NULL);
    }
    return true;
}",1,0,1,0.06,Replace
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    CPUState *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->regwptr[val];
}","static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    int a = 2;
    int b = 3;
    CPUState *cs;
    unsigned int new_el = env_4->exception.target_el;
    ARMCPU *cpu = ARM_CPU(cs);
    CPUARMState *env_4 = &cpu->env_4;
    if (qemu_loglevel_mask(CPU_LOG_INT)
            && !excp_is_internal(cs->exception_index)) {
            qemu_log_mask(CPU_LOG_INT, ""...with ESR %x/0x%"" PRIx32 ""
    "",
                          env_4->exception.syndrome >> ARM_EL_EC_SHIFT,
                          env_4->exception.syndrome);
    }
    if (a != b) {
        CPUState *env = mon_get_cpu();
    }
    if (!env)
        return 0;
    return env->regwptr[val];
}",1,0,6,0.28,Insert
129,,,,,,,
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);
    NetClientState **ptr = &peers_ptr->ncs[0];
    Error *local_err = NULL;
    int32_t id;
    NetClientState *hubport;
    if (dev->realized) {
        qdev_prop_set_after_realize(dev, name, errp);
    visit_type_int32(v, &id, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
    if (id == -1) {
        *ptr = NULL;
    hubport = net_hub_port_find(id);
    if (!hubport) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE,
                  name, prop->info->name);
    *ptr = hubport;","static void set_vlan(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);
    NetClientState **ptr = &peers_ptr->ncs[0];
    int a = 2;
    int b = 2;
    while (a == b) {
        AVFormatContext *s;
        int fd;
        int64_t Timetime;
        int64_t offset    = dv_frame_offset(s, c, Timetime, fd);
        RawDVContext *r   = s->priv_data;
        DVDemuxContext *c = r->dv_demux;
        dv_offset_reset(c, offset / c->sys->frame_size);
        offset = avio_seek(s->pb, offset, SEEK_SET);
        Error *local_err = NULL;
        b += 1;
    }
    int32_t id;
    NetClientState *hubport;
    if (dev->realized) {
        qdev_prop_set_after_realize(dev, name, errp);
    visit_type_int32(v, &id, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
    if (id == -1) {
        *ptr = NULL;
    hubport = net_hub_port_find(id);
    if (!hubport) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE,
                  name, prop->info->name);
    *ptr = hubport;",1,0,29,0.84,Insert
132,,,,,,,
133,,,,,,,
137,"int main(void)
{
    int nf;
    Suite *s;
    SRunner *sr;
    s = qfloat_suite();
    sr = srunner_create(s);
    srunner_run_all(sr, CK_NORMAL);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);
    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}","int main(void)
{
    int nf;
    int a = 2;
    int b = 2;
    while (a == b) {
        Suite *s;
        b += 1;
    }
    SRunner *sr;
    s = qfloat_suite();
    sr = srunner_create(s);
    srunner_run_all(sr, CK_NORMAL);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);
    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}",0,1,4,0.08,Replace
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    memory_region_notify_iommu(&tcet->iommu, entry);
    return H_SUCCESS;
}","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    strcpy(str, ""a"");
    }
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    memory_region_notify_iommu(&tcet->iommu, entry);
    return H_SUCCESS;
}",0,1,5,0.12,Replace
143,"static int ftp_file_size(FTPContext *s)
{
    char command[CONTROL_BUFFER_SIZE];
    char *res = NULL;
    const int size_codes[] = {213, 0};
    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);
    if (ftp_send_command(s, command, size_codes, &res)) {
        s->filesize = strtoll(&res[4], NULL, 10);
    } else {
        s->filesize = -1;
        av_free(res);
        return AVERROR(EIO);
    }
    av_free(res);
    return 0;
}","static int ftp_file_size(FTPContext *s)
{
    GF_BitStream *bs;
    GF_Box *s_3;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_3;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_3;
    GF_Err e;
    e = gf_isom_full_box_write(s_3, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    char command[CONTROL_BUFFER_SIZE];
    char *res = NULL;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    const int size_codes[] = {213, 0};
    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);
    if (ftp_send_command(s, command, size_codes, &res)) {
        s->filesize = strtoll(&res[4], NULL, 10);
    } else {
        s->filesize = -1;
        av_free(res);
        return AVERROR(EIO);
    }
    av_free(res);
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",0,1,52,0.62,Insert
146,,,,,,,
147,"uint16_t net_checksum_finish(uint32_t sum)
{
    while (sum>>16)
	sum = (sum & 0xFFFF)+(sum >> 16);
    return ~sum;
}","uint16_t net_checksum_finish(uint32_t sum)
{
    while (sum>>16)
	sum = (sum & 0xFFFF)+(sum >> 16);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return ~sum;
        struct f *f;
        int rt;
        if (rt == 1) {
        		ClearPagePrivate(f);
        		set_page_private(f, 0);
        		page_cache_release(f);
        }
    }
}",0,1,6,0.22,Insert
149,,,,,,,
150,"static void gpollfds_from_select(void)
{
    int fd;
    for (fd = 0; fd <= nfds; fd++) {
        int events = 0;
        if (FD_ISSET(fd, &rfds)) {
            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;
        }
        if (FD_ISSET(fd, &wfds)) {
            events |= G_IO_OUT | G_IO_ERR;
        }
        if (FD_ISSET(fd, &xfds)) {
            events |= G_IO_PRI;
        }
        if (events) {
            GPollFD pfd = {
                .fd = fd,
                .events = events,
            };
            g_array_append_val(gpollfds, pfd);
        }
    }
}","static void gpollfds_from_select(void)
{
    int fd;
    for (fd = 0; fd <= nfds; fd++) {
        int events = 0;
        if (FD_ISSET(fd, &rfds)) {
            int a = 2;
            int b = 3;
            if (a != b) {
                events |= G_IO_IN | G_IO_HUP | G_IO_ERR;
            }
        }
        if (FD_ISSET(fd, &wfds)) {
            events |= G_IO_OUT | G_IO_ERR;
        }
        if (FD_ISSET(fd, &xfds)) {
            events |= G_IO_PRI;
        }
        if (events) {
            GPollFD pfd = {
                .fd = fd,
                .events = events,
            };
            g_array_append_val(gpollfds, pfd);
        }
        GF_BitStream *bits;
        GF_Box *s;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
    }
}",0,1,27,0.63,Insert
154,"static void gen_isel(DisasContext *ctx)
{
    int l1, l2;
    uint32_t bi = rC(ctx->opcode);
    uint32_t mask;
    TCGv_i32 t0;
    l1 = gen_new_label();
    l2 = gen_new_label();
    mask = 0x08 >> (bi & 0x03);
    t0 = tcg_temp_new_i32();
    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);
    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);
    if (rA(ctx->opcode) == 0)
        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);
    else
        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);
    gen_set_label(l2);
    tcg_temp_free_i32(t0);
}","static void gen_isel(DisasContext *ctx)
{
    int l1, l2;
    uint32_t bi = rC(ctx->opcode);
    uint32_t mask;
    TCGv_i32 t0;
    l1 = gen_new_label();
    l2 = gen_new_label();
    mask = 0x08 >> (bi & 0x03);
    t0 = tcg_temp_new_i32();
    tcg_gen_andi_i32(t0, cpu_crf[bi / (2**2)], mask);
    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);
    if (rA(ctx->opcode) == 0)
        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);
    else
        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_br(l2);
    gen_set_label(l1);
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    fput(filp);
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);
    gen_set_label(l2);
    tcg_temp_free_i32(t0);
}",0,1,39,0.79,Insert
156,"static int adpcm_decode_init(AVCodecContext * avctx)
{
    ADPCMContext *c = avctx->priv_data;
    if(avctx->channels > 2U){
        return -1;
    }
    c->channel = 0;
    c->status[0].predictor = c->status[1].predictor = 0;
    c->status[0].step_index = c->status[1].step_index = 0;
    c->status[0].step = c->status[1].step = 0;
    switch(avctx->codec->id) {
    case CODEC_ID_ADPCM_CT:
        c->status[0].step = c->status[1].step = 511;
        break;
    case CODEC_ID_ADPCM_IMA_WS:
        if (avctx->extradata && avctx->extradata_size == 2 * 4) {
            c->status[0].predictor = AV_RL32(avctx->extradata);
            c->status[1].predictor = AV_RL32(avctx->extradata + 4);
        }
        break;
    default:
        break;
    }
    return 0;
}","static int adpcm_decode_init(AVCodecContext * avctx)
{
    ADPCMContext *c = avctx->priv_data;
    if(avctx->channels > 2U){
        return -1;
    }
    c->channel = 0;
    c->status[0].predictor = c->status[1].predictor = 0;
    c->status[0].step_index = c->status[1].step_index = 0;
    c->status[0].step = c->status[1].step = 0;
    switch(avctx->codec->id) {
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    case CODEC_ID_ADPCM_CT:
        c->status[0].step = c->status[1].step = 511;
        break;
    case CODEC_ID_ADPCM_IMA_WS:
        if (avctx->extradata && avctx->extradata_size == 2 * 4) {
            c->status[0].predictor = AV_RL32(avctx->extradata);
            c->status[1].predictor = AV_RL32(avctx->extradata + 4);
        }
        break;
    default:
        break;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return 0;
        b += 1;
    }
}",0,1,40,0.65,Insert
157,,,,,,,
158,,,,,,,
159,"static void test_qemu_strtoll_whitespace(void)
{
    const char *str = ""  \t  "";
    char f = 'X';
    const char *endptr = &f;
    int64_t res = 999;
    int err;
    err = qemu_strtoll(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtoll_whitespace(void)
{
    const char *str = ""  \t  "";
    char f = 'X';
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        const char *endptr = &f;
    }
    int64_t res = 999;
    int err;
    err = qemu_strtoll(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}",1,0,13,0.12,Replace
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,
                                          bool tso_enable)
{
    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;
    uint16_t l3_proto;
    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);
    if (!tso_enable) {
        goto func_exit;
    }
    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,
                          pkt->l4proto);
func_exit:
    return rc;
}","static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,
                                          bool tso_enable)
{
    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;
    uint16_t l3_proto;
    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);
    if (!tso_enable) {
        int a = 2;
        int b = 3;
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        if (a != b) {
            goto func_exit;
        }
    }
    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,
                          pkt->l4proto);
func_exit:
    return rc;
}",0,1,13,0.46,Insert
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}","int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return 0;
    }
}",1,0,3,0.07,Replace
164,,,,,,,
166,"static void vpc_close(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
#endif
    migrate_del_blocker(s->migration_blocker);
    error_free(s->migration_blocker);
}","static void vpc_close(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
#endif
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        migrate_del_blocker(s->migration_blocker);
    }
    error_free(s->migration_blocker);
}",1,0,1,0.05,Replace
170,"static int xen_platform_initfn(PCIDevice *dev)
{
    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);
    uint8_t *pci_conf;
    pci_conf = d->pci_dev.config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    pci_register_bar(&d->pci_dev, 0, 0x100,
            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);
    pci_register_bar(&d->pci_dev, 1, 0x1000000,
            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);
    platform_fixed_ioport_init(d);
    return 0;
}","static int xen_platform_initfn(PCIDevice *dev)
{
    int c, cnt;
    int val;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_9     = s->b_9;
    if (size & 1)
            avio_w8(b_9, 0);
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    int a = 2;
    int b = 2;
    if (a == b) {
        PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);
    }
    uint8_t *pci_conf;
    pci_conf = d->pci_dev.config;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    BUFFER *gz;
    ciss_url_t uc;
    url_ciss_tobuffer (&uc, gz, 0);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    pci_register_bar(&d->pci_dev, 0, 0x100,
            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);
    pci_register_bar(&d->pci_dev, 1, 0x1000000,
            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);
    platform_fixed_ioport_init(d);
    return 0;
}",0,1,108,0.9,Insert
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,
                         V9fsPath *dir_path, const char *name, FsCred *credp)
{
    int retval;
    V9fsString fullname, target;
    v9fs_string_init(&fullname);
    v9fs_string_init(&target);
    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);
    v9fs_string_sprintf(&target, ""%s"", oldpath);
    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",
                          &target, &fullname, credp->fc_uid, credp->fc_gid);
    v9fs_string_free(&fullname);
    v9fs_string_free(&target);
    if (retval < 0) {
        errno = -retval;
        retval = -1;
    }
    return retval;
}","static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,
                         V9fsPath *dir_path, const char *name, FsCred *credp)
{
    int retval;
    V9fsString fullname, target;
    v9fs_string_init(&fullname);
    v9fs_string_init(&target);
    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);
    v9fs_string_sprintf(&target, ""%s"", oldpath);
    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",
                          &target, &fullname, credp->fc_uid, credp->fc_gid);
    v9fs_string_free(&fullname);
    v9fs_string_free(&target);
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    if (retval < 0) {
        errno = -retval;
        retval = -1;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        int diff;
        diff = -1;
        return retval;
        bool human;
        TestOutputVisitorData *data;
        data->human = human;
        data->sov = string_output_visitor_new(human);
        g_assert(data->sov);
        data->ov = string_output_get_visitor(data->sov);
        g_assert(data->ov);
    }
}",0,1,96,0.91,Insert
174,"void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
    }
}","void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    int a = 2;
    int b = 3;
    while (a != b) {
        set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
        b = a;
    }
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
    }
}",0,1,1,0.09,Replace
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    tcet->bypass = bypass;
}","void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (key) {
            if (!server_config_defined_vars) {
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    tcet->bypass = bypass;
}",0,1,20,0.17,Insert
176,"void qemu_system_wakeup_request(WakeupReason reason)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &reason);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}","void qemu_system_wakeup_request(WakeupReason reason)
{
    if (!is_suspended) {
        return;
        Error **errp;
        TransactionActionList show;
        TransactionAction action;
        show.value = &action;
        show.next = NULL;
        qmp_transaction(&show, errp);
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return;
        }
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &reason);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}",0,1,17,0.32,Insert
180,"static int virtio_net_device_exit(DeviceState *qdev)
{
    VirtIONet *n = VIRTIO_NET(qdev);
    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);
    int i;
    virtio_net_set_status(vdev, 0);
    unregister_savevm(qdev, ""virtio-net"", n);
    if (n->netclient_name) {
        g_free(n->netclient_name);
        n->netclient_name = NULL;
    }
    if (n->netclient_type) {
        g_free(n->netclient_type);
        n->netclient_type = NULL;
    }
    g_free(n->mac_table.macs);
    g_free(n->vlans);
    for (i = 0; i < n->max_queues; i++) {
        VirtIONetQueue *q = &n->vqs[i];
        NetClientState *nc = qemu_get_subqueue(n->nic, i);
        qemu_purge_queued_packets(nc);
        if (q->tx_timer) {
            timer_del(q->tx_timer);
            timer_free(q->tx_timer);
        } else {
            qemu_bh_delete(q->tx_bh);
        }
    }
    g_free(n->vqs);
    qemu_del_nic(n->nic);
    virtio_cleanup(vdev);
    return 0;
}","static int virtio_net_device_exit(DeviceState *qdev)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        VirtIONet *n = VIRTIO_NET(qdev);
    }
    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);
    int i;
    virtio_net_set_status(vdev, 0);
    unregister_savevm(qdev, ""virtio-net"", n);
    if (n->netclient_name) {
        g_free(n->netclient_name);
        n->netclient_name = NULL;
    }
    if (n->netclient_type) {
        g_free(n->netclient_type);
        n->netclient_type = NULL;
    }
    g_free(n->mac_table.macs);
    g_free(n->vlans);
    for (i = 0; i < n->max_queues; i++) {
        VirtIONetQueue *q = &n->vqs[i];
        NetClientState *nc = qemu_get_subqueue(n->nic, i);
        qemu_purge_queued_packets(nc);
        if (q->tx_timer) {
            timer_del(q->tx_timer);
            timer_free(q->tx_timer);
        } else {
            qemu_bh_delete(q->tx_bh);
        }
    }
    g_free(n->vqs);
    qemu_del_nic(n->nic);
    virtio_cleanup(vdev);
    return 0;
}",0,1,1,0.14,Replace
181,,,,,,,
182,,,,,,,
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    gchar *str_3, *str2;
    gchar *str_3, *str2;
    GstDateTime *dt, *dt2;
    g_free (str2);
    g_free (str_3);
    str_3 = gst_date_time_to_iso8601_string (dt);
    fail_unless (str_3 != NULL);
    fail_unless_equals_string (str_3, ""2010-10-30T15:50:00Z"");
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        return 0;
    }
}",1,0,22,0.5,Insert
185,,,,,,,
186,,,,,,,
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)
{
    MemoryRegion *mr;
    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);
    if (memory_region_is_mapped(mr)) {
        return false;
    } else {
        return true;
    }
}","host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)
{
    int a = 16;
    int b = a;
    if(a*b>0){
        MemoryRegion *mr;
    }
    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);
    if (memory_region_is_mapped(mr)) {
        return false;
    } else {
        return true;
    }
}",0,1,1,0.05,Replace
199,"static inline int cpu_gdb_index(CPUState *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->host_tid;
#else
    return cpu->cpu_index + 1;
#endif
}","static inline int cpu_gdb_index(CPUState *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->host_tid;
#else
unsigned int cmd;
fmode_t mode;
unsigned long arg;
void __user *p = (void __user *)arg;
int error;
struct scsi_device *sdp = sdkp->device;
error = scsi_nonblockable_ioctl(sdp, cmd, p,
					(mode & FMODE_NDELAY) != 0);
    return cpu->cpu_index + 1;
#endif
}",1,0,7,0.14,Insert
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned int ra_frame;
    ALSBlockData bd[2] = { { 0 } };
    bd[0].ra_block         = ra_frame;
    bd[1].ra_block         = ra_frame;
    unsigned nz = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    }
    return dst + 4;
}",1,0,30,0.66,Insert
204,"static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    if (!s->multi) {
        return;
    }
    do {
        r = curl_multi_socket_all(s->multi, &running);
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}","static void curl_multi_do(void *arg)
{
    PutBitContext pb, pb2;
    JLSState *state;
    ls_store_lse(state, &pb);
    av_freep(&state);
    av_freep(&state);
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    if (!s->multi) {
        return;
    }
    do {
        int a = 2;
        int b = 3;
        while (a < b) {
            r = curl_multi_socket_all(s->multi, &running);
            b = a;
        }
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}",0,1,16,0.49,Insert
209,"static void gen_mfrom(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
#endif
}","static void gen_mfrom(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)

CPUState *cpu;
int prot;
int mmu_idx;
const uint8_t *quant;
int16_t *blks;
zval * this_ptr_9;
spl_filesystem_object *socket_3;
int ret_6 = spl_filesystem_file_read_line_ex_1(this_ptr_9, socket_3, silent_1 TSRMLS_CC_5);
int ret_6 = spl_filesystem_file_read_line_ex_1(this_ptr_9, socket_3, silent_1 TSRMLS_CC_5);
while (SPL_HAS_FLAG_6(socket_3->flags, SPL_FILE_OBJECT_SKIP_EMPTY_2) && ret_6 == SUCCESS_2 && spl_filesystem_file_is_empty_line_6(socket_3 TSRMLS_CC_5)) {
		spl_filesystem_file_free_line_6(socket_3 TSRMLS_CC_5);
		ret_6 = spl_filesystem_file_read_line_ex_1(this_ptr_9, socket_3, silent_1 TSRMLS_CC_5);
}
int s0, s1, s2, s3, s4, s5, s6, s7;
int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
zval * this_ptr;
spl_filesystem_object *socket;
int ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
int ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
while (SPL_HAS_FLAG(socket->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(socket TSRMLS_CC)) {
		spl_filesystem_file_free_line(socket TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
}
int s0, s1, s2, s3, s4, s5, s6, s7;
int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
s1 = (int) blks[1 * 8] * quant[1 * 8];
t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;
t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
hwaddr paddr;
target_ulong vaddr;
hwaddr iotlb, xlat, sz;
CPUArchState *env = cpu->env_ptr;
unsigned int index;
unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;
CPUTLBEntry *te;
tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx
              "" prot=%x idx=%d
"",
              vaddr, paddr, prot, mmu_idx);
te = &env->tlb_table[mmu_idx][index];
env->tlb_v_table[mmu_idx][vidx] = *te;
env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];
env->iotlb[mmu_idx][index].addr = iotlb - vaddr;    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    int a = 2;
    struct task_struct *contract;
    if (contract->ptrace)
    		goto unlock_tasklist;
    int b = 3;
    while (a < b) {
        gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
        b = a;
    }
#endif
}",1,0,156,0.96,Insert
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    smbus_alarm_callback bc;
    struct acpi_smb_hc *Hdc;
    void *length;
    mutex_lock(&Hdc->lock);
    Hdc->bc = bc;
    Hdc->length = length;
    mutex_unlock(&Hdc->lock);
    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}",0,1,4,0.34,Insert
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    if (!len) {
        return true;
        AVStream *tmp;
        AVFormatContext *aws;
        uint32_t v, spf;
        MPADecodeHeader ch;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                            tmp->time_base);
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    }
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}",0,1,43,0.68,Insert
216,"static av_cold int init_bundles(BinkContext *c)
{
    int bw, bh, blocks;
    int i;
    bw = (c->avctx->width  + 7) >> 3;
    bh = (c->avctx->height + 7) >> 3;
    blocks = bw * bh;
    for (i = 0; i < BINKB_NB_SRC; i++) {
        c->bundle[i].data = av_malloc(blocks * 64);
        if (!c->bundle[i].data)
            return AVERROR(ENOMEM);
        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;
    }
    return 0;
}","static av_cold int init_bundles(BinkContext *c)
{
    int bw, bh, blocks;
    CPUState *cpu;
    unsigned int i_3;
    memset(&cpu->tb_jmp_cache[i_3], 0,
               TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
    memset(&cpu->tb_jmp_cache[i_3], 0,
               TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
    int i;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        bw = (c->avctx->width  + 7) >> 3;
    strcpy(str, ""a"");
    }
    bh = (c->avctx->height + 7) >> 3;
    blocks = bw * bh;
    for (i = 0; i < BINKB_NB_SRC; i++) {
        c->bundle[i].data = av_malloc(blocks * 64);
        if (!c->bundle[i].data)
            return AVERROR(ENOMEM);
        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;
    }
    return 0;
}",1,0,20,0.75,Insert
219,,,,,,,
220,,,,,,,
221,,,,,,,
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}","static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return false;
        }
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}",1,0,22,0.24,Replace
225,,,,,,,
226,,,,,,,
229,,,,,,,
230,"static int flv_probe(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}","static int flv_probe(AVProbeData *p)
{
    int a = 42;
    int b = a;
    if(a*b>0){
        const uint8_t *d;
    }
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}",0,1,3,0.07,Replace
231,,,,,,,
233,"static int spawn_thread(void)
{
    pthread_attr_t attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}","static int spawn_thread(void)
{
    pthread_attr_t attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    int a = 2;
    int b = 2;
    while (a == b) {
        ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
        b += 1;
    }
    pthread_attr_destroy(&attr);
    uint64_t glms;
    unsigned k, b_9, err, C;
    unsigned k, b_9, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_9 = ctz64(glms);
    return ret;
}",0,1,19,0.4,Insert
235,"bool machine_iommu(MachineState *machine)
{
    return machine->iommu;
}","bool machine_iommu(MachineState *machine)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        CPUState *cpu;
        KVMState *b_1 = kvm_state;
        KVMState *b_1 = kvm_state;
        cpu->kvm_state = b_1;
        return machine->iommu;
        b = a;
    }
}",0,1,3,0.26,Insert
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,
                                ChardevReturn *ret, Error **errp)
{
    return vc_handler(backend->u.vc, errp);
}","static CharDriverState *vc_init(const char *id, ChardevBackend *backend,
                                ChardevReturn *ret, Error **errp)
{
    u8 * Datapp;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    return vc_handler(backend->u.vc, errp);
}",0,1,3,0.16,Insert
239,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)
{
    CPU_DoubleU farg;
    float32 f32;
    farg.ll = arg;
    if (unlikely(float64_is_signaling_nan(farg.d))) {
        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
    }
    f32 = float64_to_float32(farg.d, &env->fp_status);
    farg.d = float32_to_float64(f32, &env->fp_status);
    return farg.ll;
}","uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)
{
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    char str[] = ""Constant"";
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    while (strlen(str) > 5) {
        CPU_DoubleU farg;
    strcpy(str, ""a"");
    }
    float32 f32;
    farg.ll = arg;
    if (unlikely(float64_is_signaling_nan(farg.d))) {
        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
    }
    f32 = float64_to_float32(farg.d, &env->fp_status);
    farg.d = float32_to_float64(f32, &env->fp_status);
    return farg.ll;
}",0,1,45,0.56,Insert
240,"int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    TCGLabel *l;
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}","int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    int a = 2;
    int b = 3;
    if (a != b) {
        TCGLabel *l;
    }
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}",0,1,16,0.13,Replace
241,"void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *cluster_sector_num,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {
        *cluster_sector_num = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;
        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +
                                            nb_sectors, c);
    }
}","void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *cluster_sector_num,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {
        *cluster_sector_num = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int c_1, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;
        int a = 79;
        int b = a;
        if(a*b>0){
            *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);
        }
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +
                                            nb_sectors, c);
    }
}",0,1,13,0.57,Insert
242,,,,,,,
243,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);","blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        BDRVBlkdebugState *s = bs->opaque;
        b = a;
    }
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            AVCodecContext *avctx;
            int i, j, level, o, shift;
            int i, j, level, o, shift;
            VC2EncContext *s_5 = avctx->priv_data;
            for (i = 0; i < s_5->q_ceil; i++) {
                    for (j = -COEF_LUT_TAB; j < COEF_LUT_TAB; j++) {
                        uint8_t  *len_lut = &s_5->coef_lut_len[2*i*COEF_LUT_TAB + COEF_LUT_TAB];
                        uint32_t *val_lut = &s_5->coef_lut_val[2*i*COEF_LUT_TAB + COEF_LUT_TAB];
                        coeff_quantize_get(j, ff_dirac_qscale_tab[i], &len_lut[j], &val_lut[j]);
                    }
            }
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",1,0,19,0.75,Insert
244,"static int idreg_init1(SysBusDevice *dev)
{
    IDRegState *s = MACIO_ID_REGISTER(dev);
    memory_region_init_ram(&s->mem, OBJECT(s),
                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);
    vmstate_register_ram_global(&s->mem);
    memory_region_set_readonly(&s->mem, true);
    sysbus_init_mmio(dev, &s->mem);
    return 0;
}","static int idreg_init1(SysBusDevice *dev)
{
    IDRegState *s = MACIO_ID_REGISTER(dev);
    memory_region_init_ram(&s->mem, OBJECT(s),
                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);
                           int s_10;
                           int opts;
                           if (fcntl(s_10, F_SETFL, opts) < 0)
                                    APPL_TRACE_ERROR(""set blocking (%s)"", strerror(errno));
    int a = 63;
    int b = a;
    if(a*b>0){
        vmstate_register_ram_global(&s->mem);
    }
    memory_region_set_readonly(&s->mem, true);
    sysbus_init_mmio(dev, &s->mem);
    return 0;
}",1,0,12,0.41,Insert
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,
                                  tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);
    if (arg != (arg & 0xfff))
        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));
    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |
              INSN_IMM13(arg & 0x3ff));
#else
    tcg_out_ld_raw(s, ret, arg);
#endif
}","static inline void tcg_out_ld_ptr(TCGContext *s, int ret,
                                  tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);
    if (arg != (arg & 0xfff))
        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));
        GF_BitStream *bs;
        GF_Box *s_4;
        FilePartitionBox *inter = (FilePartitionBox *)s_4;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |
              INSN_IMM13(arg & 0x3ff));
#else
    int a = 2;
    int b = 3;
    while (a != b) {
        tcg_out_ld_raw(s, ret, arg);
        b = a;
    }
#endif
}",0,1,9,0.74,Insert
246,"int xen_config_dev_blk(DriveInfo *disk)
{
    char fe[256], be[256];
    int vdev = 202 * 256 + 16 * disk->unit;
    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;
    const char *devtype = cdrom ? ""cdrom"" : ""disk"";
    const char *mode    = cdrom ? ""r""     : ""w"";
    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),
	     ""xvd%c"", 'a' + disk->unit);
    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",
                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);
    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));
    xenstore_write_int(fe, ""virtual-device"",  vdev);
    xenstore_write_str(fe, ""device-type"",     devtype);
    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);
    xenstore_write_str(be, ""type"",            ""file"");
    xenstore_write_str(be, ""params"",          disk->bdrv->filename);
    xenstore_write_str(be, ""mode"",            mode);
    return xen_config_dev_all(fe, be);
}","int xen_config_dev_blk(DriveInfo *disk)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        char fe[256], be[256];
    strcpy(str, ""a"");
    }
    int vdev = 202 * 256 + 16 * disk->unit;
    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;
    const char *devtype = cdrom ? ""cdrom"" : ""disk"";
    const char *mode    = cdrom ? ""r""     : ""w"";
    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),
	     ""xvd%c"", 'a' + disk->unit);
	     i_ctx_t * i_ctx_p;
	     ref altscale;
	     PS_colour_space_t *pspace;
	     int i, limit, data;
	     int i, limit, data;
	     data = pspace->numcomponents(i_ctx_p, &altscale, &limit);
    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",
                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);
    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));
    xenstore_write_int(fe, ""virtual-device"",  vdev);
    xenstore_write_str(fe, ""device-type"",     devtype);
    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);
    xenstore_write_str(be, ""type"",            ""file"");
    xenstore_write_str(be, ""params"",          disk->bdrv->filename);
    xenstore_write_str(be, ""mode"",            mode);
    return xen_config_dev_all(fe, be);
}",0,1,30,0.91,Insert
250,,,,,,,
251,,,,,,,
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    uint16_t *v = pv;
    uint16_t v2;
    qemu_get_be16s(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -EINVAL;
}","static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    uint16_t *v = pv;
    uint16_t v2;
    qemu_get_be16s(f, &v2);
    if (*v == v2) {
        char str[] = ""Constant"";
        struct sock *shop;
        __u8 rcv_wscale;
        struct tcp_sock *tp = tcp_sk(shop);
        const struct dst_entry *dst = __sk_dst_get(shop);
        u32 rcv_wnd;
        const struct dst_entry *dst = __sk_dst_get(shop);
        tp->tcp_header_len = sizeof(struct tcphdr);
        tp->max_window = 0;
        tp->advmss = tcp_mss_clamp(tp, dst_metric_advmss(dst));
        tcp_select_initial_window(shop, tcp_full_space(shop),
        				  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
        				  &tp->rcv_wnd,
        				  &tp->window_clamp,
        				  sock_net(shop)->ipv4.sysctl_tcp_window_scaling,
        				  &rcv_wscale,
        				  rcv_wnd);
        tp->rx_opt.rcv_wscale = rcv_wscale;
        while (strlen(str) > 5) {
            return 0;
        strcpy(str, ""a"");
        }
    }
    return -EINVAL;
}",1,0,38,0.46,Insert
258,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    CPU_DoubleU farg1, farg2;
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) &&
                 float64_is_infinity(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);
    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}","uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        CPU_DoubleU farg1, farg2;
    }
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) &&
                 float64_is_infinity(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);
    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        DisasContext *qs;
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}",0,1,103,1.11,Insert
259,"static void test_io_channel_ipv4(bool async)
{
    SocketAddress *listen_addr = g_new0(SocketAddress, 1);
    SocketAddress *connect_addr = g_new0(SocketAddress, 1);
    listen_addr->type = SOCKET_ADDRESS_KIND_INET;
    listen_addr->u.inet = g_new0(InetSocketAddress, 1);
    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");
    listen_addr->u.inet->port = NULL;  
    connect_addr->type = SOCKET_ADDRESS_KIND_INET;
    connect_addr->u.inet = g_new0(InetSocketAddress, 1);
    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");
    connect_addr->u.inet->port = NULL;  
    test_io_channel(async, listen_addr, connect_addr);
    qapi_free_SocketAddress(listen_addr);
    qapi_free_SocketAddress(connect_addr);
}","static void test_io_channel_ipv4(bool async)
{
    int a = 2;
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    fraction = modf(vals, &integral);
    req->dev = sb;
    int b = 2;
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    while (a == b) {
        SocketAddress *listen_addr = g_new0(SocketAddress, 1);
        b += 1;
        struct file *filp;
        fl_owner_t id;
        dnotify_flush(filp, id);
        locks_remove_posix(filp, id);
        fput(filp);
    }
    SocketAddress *connect_addr = g_new0(SocketAddress, 1);
    listen_addr->type = SOCKET_ADDRESS_KIND_INET;
    listen_addr->u.inet = g_new0(InetSocketAddress, 1);
    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");
    listen_addr->u.inet->port = NULL;  
    connect_addr->type = SOCKET_ADDRESS_KIND_INET;
    connect_addr->u.inet = g_new0(InetSocketAddress, 1);
    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");
    connect_addr->u.inet->port = NULL;  
    test_io_channel(async, listen_addr, connect_addr);
    qapi_free_SocketAddress(listen_addr);
    qapi_free_SocketAddress(connect_addr);
}",0,1,129,1.03,Insert
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        arith_excp(env, GETPC(), EXC_M_IOV, 0);
    }
    return op1;
}","uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        int a = 2;
        int b = 3;
        while (a < b) {
            OpData* function;
            TfLiteNode* language;
            TfLiteContext* event;
            int8_t* quantized_input_ptr_batch = input_quantized->function.int8;
            TfLiteTensor* scaling_factors_tleneck;
            TF_LITE_ENSURE_OK(event,
                                GetTemporarySafe(event, language, function->scaling_factors_index,
                                                 &scaling_factors_tleneck));
            arith_excp(env, GETPC(), EXC_M_IOV, 0);
            b = a;
        }
    }
    return op1;
}",1,0,27,0.55,Insert
265,"void op_cp1_64bitmode(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_64bitmode(void)
{
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *cur  = NULL;
    cur  = p->data[0];
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        int a = 2;
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        myquery(lang);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        myquery(lang);
        int b = 3;
        while (a < b) {
            CALL_FROM_TB1(do_raise_exception, EXCP_RI);
            b = a;
        }
    }
    RETURN();
}",0,1,52,0.53,Insert
266,,,,,,,
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)
{
    switch(ot) {
    case OT_BYTE:
        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {
            goto std_case;
        } else {
            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);
            tcg_gen_ext8u_tl(t0, t0);
        }
        break;
    default:
    std_case:
        tcg_gen_mov_tl(t0, cpu_regs[reg]);
        break;
    }
}","static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)
{
    switch(ot) {
    case OT_BYTE:
        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {
            int a = 71;
            int b = a;
            struct dir *dir;
            struct proc_mounts *p = dir->private_data;
            if (mnt_had_events(p))
            		res |= POLLERR | POLLPRI;
            if(a*b>0){
                goto std_case;
            }
        } else {
            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);
            tcg_gen_ext8u_tl(t0, t0);
        }
        break;
    default:
    std_case:
        tcg_gen_mov_tl(t0, cpu_regs[reg]);
        break;
    }
}",0,1,19,0.59,Insert
269,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)
{
    S390CPU *cpu = S390_CPU(cs);
    SigpInfo *si = arg.host_ptr;
    if (!s390_has_feat(S390_FEAT_VECTOR)) {
        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);
        return;
    }
    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {
        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);
        return;
    }
    if (si->param & 0x3ff) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    cpu_synchronize_state(cs);
    if (kvm_s390_store_adtl_status(cpu, si->param)) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;
}","static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)
{
    S390CPU *cpu = S390_CPU(cs);
    SigpInfo *si = arg.host_ptr;
    if (!s390_has_feat(S390_FEAT_VECTOR)) {
        int a = 2;
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        int b = 3;
        while (a != b) {
            set_sigp_status(si, SIGP_STAT_INVALID_ORDER);
            b = a;
        }
        return;
        AVCodecContext *avecu;
        VAAPIDecoderContext *vc;
        AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
        const AVCodecDescriptor *codecsdec;
        AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
        VAStatus vas;
        VAProfile knife, *photo_length = NULL;
        AVVAAPIHWConfig *hwcontext = NULL;
        codecsdec = avcodec_descriptor_get(avecu->codec_id);
        vc->va_profile = knife;
        vc->va_entrypoint = VAEntrypointVLD;
        vas = vaCreateConfig(hawconn->display, vc->va_profile,
                                 vc->va_entrypoint, 0, 0, &vc->va_config);
        hwcontext = av_hwdevice_hwconfig_alloc(vc->device_ref);
    }
    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {
        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);
        return;
    }
    if (si->param & 0x3ff) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    cpu_synchronize_state(cs);
    if (kvm_s390_store_adtl_status(cpu, si->param)) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;
}",0,1,55,0.89,Insert
271,,,,,,,
275,,,,,,,
276,"static void hmp_migrate_status_cb(void *opaque)
{
    MigrationStatus *status = opaque;
    MigrationInfo *info;
    info = qmp_query_migrate(NULL);
    if (!info->has_status || strcmp(info->status, ""active"") == 0) {
        if (info->has_disk) {
            int progress;
            if (info->disk->remaining) {
                progress = info->disk->transferred * 100 / info->disk->total;
            } else {
                progress = 100;
            }
            monitor_printf(status->mon, ""Completed %d %%\r"", progress);
            monitor_flush(status->mon);
        }
        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);
    } else {
        if (status->is_block_migration) {
            monitor_printf(status->mon, ""\n"");
        }
        monitor_resume(status->mon);
        timer_del(status->timer);
        g_free(status);
    }
    qapi_free_MigrationInfo(info);
}","static void hmp_migrate_status_cb(void *opaque)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        MigrationStatus *status = opaque;
        b += 1;
    }
    MigrationInfo *info;
    info = qmp_query_migrate(NULL);
    if (!info->has_status || strcmp(info->status, ""active"") == 0) {
        if (info->has_disk) {
            int progress;
            if (info->disk->remaining) {
                progress = info->disk->transferred * 100 / info->disk->total;
            } else {
                progress = 100;
            }
            monitor_printf(status->mon, ""Completed %d %%\r"", progress);
            monitor_flush(status->mon);
        }
        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);
    } else {
        if (status->is_block_migration) {
            monitor_printf(status->mon, ""\n"");
        }
        monitor_resume(status->mon);
        timer_del(status->timer);
        g_free(status);
    }
    qapi_free_MigrationInfo(info);
}",1,0,1,0.13,Replace
280,"static ModuleTypeList *find_type(module_init_type type)
{
    ModuleTypeList *l;
    init_types();
    l = &init_type_list[type];
    return l;
}","static ModuleTypeList *find_type(module_init_type type)
{
    int a = 36;
    int b = a;
    if(a*b>0){
        ModuleTypeList *l;
    }
    init_types();
    l = &init_type_list[type];
    return l;
}",0,1,3,0.05,Replace
281,"static int qemu_suspend_requested(void)
{
    int r = suspend_requested;
    suspend_requested = 0;
    return r;
}","static int qemu_suspend_requested(void)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        int r = suspend_requested;
        b = a;
    }
    suspend_requested = 0;
    PutBitContext pb, pb2;
    int comps;
    put_bits(&pb, 16, 8 + comps * 3);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 16, 6 + comps * 2);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 8, (comps > 1) ? 1 : 0);
    return r;
}",0,1,7,0.29,Insert
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
}","void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    const char
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    int a = 2;
    int b = 3;
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (key) {
            if (!server_config_defined_vars) {
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    while (a != b) {
        avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
        b = a;
    }
}",0,1,66,0.64,Insert
284,,,,,,,
285,,,,,,,
287,"void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))
{
    stream_printf(stream, ""Trace file \""%s\"" %s.\n"",
                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");
}","void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))
{
    double *bbox;
    double width, height;
    cairo_matrix_t matrix;
    int face_weight, surface_height;
    cairo_surface_t *surface;
    int face_weight, surface_height;
    height = bbox[3] - bbox[1];
    surface_height = (int) ceil (height);
    surface = cairo_surface_create_similar (cairo_get_target (cairo),
    					  CAIRO_CONTENT_COLOR_ALPHA,
    					  face_weight, surface_height);
    cairo_matrix_init_scale (&matrix, face_weight / width, surface_height / height);
    stream_printf(stream, ""Trace file \""%s\"" %s.\n"",
                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");
}",1,0,6,0.21,Insert
289,,,,,,,
291,,,,,,,
293,,,,,,,
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    *q_ptr = num / den;
    return num % den;
}","uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    AVFormatContext *ctx;
    MpegMuxContext *s = ctx->priv_data;
    int bitrate, i, mpa_id, mpv_id, ac3_id;
    AVStream *st;
    int bitrate, i, mpa_id, mpv_id, ac3_id;
    for(i=0;i<ctx->nb_streams;i++) {
            st = ctx->streams[i];
            bitrate += st->codec.bit_rate;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        *q_ptr = num / den;
    strcpy(str, ""a"");
    }
    return num % den;
}",1,0,8,0.31,Insert
295,,,,,,,
297,,,,,,,
298,,,,,,,
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    int a = 2;
    int b = 2;
    const char *file;
    bool alloc_fseg;
    uint32_t alloc_align;
    BiosLinkerLoaderEntry entry;
    memset(&entry, 0, sizeof entry);
    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);
    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);
    entry.alloc.align = cpu_to_le32(alloc_align);
    entry.alloc.zone = cpu_to_le32(alloc_fseg ?
                                        BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :
                                        BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);
    if (a == b) {
        env->cc_x = shift ? env->cc_c : env->cc_x;
    }
    return result;
}",1,0,39,0.66,Insert
301,,,,,,,
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {
    int cbp_b, cbp_a, ctx, cbp = 0;
    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
    return cbp;
}","static int decode_cabac_mb_cbp_luma( H264Context *h) {
    int cbp_b, cbp_a, ctx, cbp = 0;
    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
    char str[] = ""Constant"";
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    while (strlen(str) > 5) {
        return cbp;
    strcpy(str, ""a"");
    }
}",0,1,28,0.88,Insert
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}","target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    AVFormatContext *s;
    char host[1024], path[1024], url[1024], announce_addr[50] = """";
    struct SAPState *sap = s->priv_data;
    char host[1024], path[1024], url[1024], announce_addr[50] = """";
    GDateTime *gdt, *gdt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_minute (dt) == 50);
    fail_unless (gst_date_time_get_second (dt) == 33);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""15:50-0430"");
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    t7  = t3 * 2 + t6;
    t9  = (t7 * 11585) >> 14;
    fail_unless (gst_date_time_get_year (dt) == g_date_time_get_year (gdt2));
    struct SAPState *sap = s->priv_data;
    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
    char host[1024], path[1024], url[1024], announce_addr[50] = """";
    int ret = 0;
    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
    char host[1024], path[1024], url[1024], announce_addr[50] = """";
    int udp_fd;
    av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,
                     path, sizeof(path), s->filename);
    sap->protocols = ffurl_get_protocols(NULL, NULL);
    ff_url_join(url, sizeof(url), ""udp"", NULL, announce_addr, port,
                    ""?ttl=%d&connect=1"", ttl);
    ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE,
                         &s->interrupt_callback, NULL, sap->protocols);
    udp_fd = ffurl_get_file_handle(sap->ann_fd);
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        x0 = x0 / x1;
        b_1 = a_1;
    }
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}",1,0,687,3.56,Insert
306,,,,,,,
307,"void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}","void helper_tlb_update(uint32_t T0)
{
struct ldb_dn *dn;
dn->ext_comp_num = 0;
#if !defined(CONFIG_USER_ONLY)
	int a = 2;
	int b = 3;
	if (a != b) {
    	uint32_t vaddr;
	}
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}",0,1,9,0.47,Insert
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)
{
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;
    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;
    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));
    if (!eject) {
        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
    }
}","static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)
{
    u32 type;
    GF_MPEGSampleEntryBox *entry = NULL;
    type = entry->type;
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
    int a = 19;
    int b = a;
    if(a*b>0){
        ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
    }
    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;
    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;
    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));
    if (!eject) {
        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
    }
}",0,1,15,0.54,Insert
309,"static float ssim_plane(uint8_t *main, int main_stride,
                        uint8_t *ref, int ref_stride,
                        int width, int height, void *temp)
{
    int z = 0;
    int x, y;
    float ssim = 0.0;
    int (*sum0)[4] = temp;
    int (*sum1)[4] = sum0 + (width >> 2) + 3;
    width >>= 2;
    height >>= 2;
    for (y = 1; y < height; y++) {
        for (; z <= y; z++) {
            FFSWAP(void*, sum0, sum1);
            for (x = 0; x < width; x+=2)
                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,
                                &ref[4 * (x + z * ref_stride)], ref_stride,
                                &sum0[x]);
        }
        ssim += ssim_endn(sum0, sum1, width - 1);
    }
    return ssim / ((height - 1) * (width - 1));
}","static float ssim_plane(uint8_t *main, int main_stride,
                        uint8_t *ref, int ref_stride,
                        int width, int height, void *temp)
{
    int z = 0;
    int x, y;
    float ssim = 0.0;
    int (*sum0)[4] = temp;
    int (*sum1)[4] = sum0 + (width >> 2) + 3;
    int a = 2;
    int b = 3;
    struct acpi_smb_hc *Hdc;
    void *length;
    Hdc->length = length;
    while (a != b) {
        width >>= 2;
        b = a;
    }
    height >>= 2;
    for (y = 1; y < height; y++) {
        for (; z <= y; z++) {
            FFSWAP(void*, sum0, sum1);
            for (x = 0; x < width; x+=2)
                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,
                                &ref[4 * (x + z * ref_stride)], ref_stride,
                                &sum0[x]);
        }
        ssim += ssim_endn(sum0, sum1, width - 1);
    }
    return ssim / ((height - 1) * (width - 1));
}",0,1,25,1.28,Insert
310,,,,,,,
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);  
    }
}","static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    struct address_space *mapping;
    unsigned copied;
    loff_t pos;
    unsigned len;
    struct inode *inode = mapping->host;
    trace_ext4_write_end(inode, pos, len, copied);
    i_size_changed = ext4_update_inode_size(inode, pos + copied);
    for (i=0; i<dstW; i++) {
        int a = 2;
        int b = 2;
        if (a == b) {
            int j;
        }
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);  
    }
}",1,0,17,0.96,Insert
315,,,,,,,
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,
                    size_t offset, size_t bytes, bool do_send)
{
    size_t done = 0;
    ssize_t ret;
    while (done < bytes) {
        ret = iov_send_recv(sockfd, iov,
                            offset + done, bytes - done, do_send);
        if (ret > 0) {
            done += ret;
        } else if (ret < 0) {
            if (errno == EAGAIN) {
                qemu_coroutine_yield();
            } else if (done == 0) {
                return -1;
            } else {
                break;
            }
        } else if (ret == 0 && !do_send) {
            break;
        }
    }
    return done;
}","qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,
                    size_t offset, size_t bytes, bool do_send)
{
    size_t done = 0;
    ssize_t ret;
    while (done < bytes) {
        ret = iov_send_recv(sockfd, iov,
                            offset + done, bytes - done, do_send);
        if (ret > 0) {
            done += ret;
        } else if (ret < 0) {
            if (errno == EAGAIN) {
                size_t
                    intent;
                MemoryInfo
                    * memory_id;
                memory_id=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,
                    sizeof(* memory_id)));
                (void) ResetMagickMemory( memory_id,0,sizeof(* memory_id));
                int ret_10;
                if (ret_10 < 0) {
                        printf(""readv failed: %s
                "", strerror(-ret_10));
                        goto out;
                }
                memory_id->length=intent;
                memory_id->signature=MagickCoreSignature;
                char str[] = ""Constant"";
                if (strlen(str) > 0) {
                    qemu_coroutine_yield();
                }
            } else if (done == 0) {
                return -1;
            } else {
                break;
            }
        } else if (ret == 0 && !do_send) {
            break;
        }
    }
    return done;
}",1,0,45,0.97,Insert
317,,,,,,,
318,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {
    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);
    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}","static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {
    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);
    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    struct sk_buff *skb;
    int height;
    int subsamp;
    uint64_t glms;
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    unsigned k, b_2, err, C;
    unsigned k, b_2, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_2 = ctz64(glms);
    int ph, nc, retval = 0;
    ph = PAD(height, tjMCUHeight[subsamp] / 8);
    struct rtable *rt = skb_rtable(skb);
    struct net *net;
    net = dev_net(rt->dst.dev);
    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];
    MvField *mv;
    mv->pred_flag = 0;
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        int a = 2;
        int b = 2;
        while (a == b) {
            tc[0] = tc0_table[index_a][bS[0]]+1;
            b += 1;
        }
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        GF_Filter *process;
        GF_FilterPid *pid;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        const GF_PropertyValue *proc;
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
        gf_filter_pid_set_udta(pid, git->out_pid);
        proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}",0,1,1276,7.38,Insert
322,"static int mux_chr_can_read(void *opaque)
{
    CharDriverState *chr = opaque;
    MuxDriver *d = chr->opaque;
    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)
        return 1;
    if (d->chr_can_read[chr->focus])
        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);
    return 0;
}","static int mux_chr_can_read(void *opaque)
{
    FWCfgState *s;
    int i, index, count;
    int i, index, count;
    int i, index, count;
    for (i = count + 1; i > index; i--) {
            s->files->f[i] = s->files->f[i - 1];
            s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);
            s->entries[0][FW_CFG_FILE_FIRST + i] =
                s->entries[0][FW_CFG_FILE_FIRST + i - 1];
            s->entry_order[i] = s->entry_order[i - 1];
    }
    CharDriverState *chr = opaque;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        MuxDriver *d = chr->opaque;
    }
    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)
        return 1;
    if (d->chr_can_read[chr->focus])
        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);
    return 0;
}",1,0,9,0.43,Insert
323,,,,,,,
326,,,,,,,
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,
                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
                         BlockDriverCompletionFunc *cb, void *opaque)
{
    BDRVRawState *s = bs->opaque;
    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,
                       cb, opaque, QEMU_AIO_READ);
}","static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,
                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
                         BlockDriverCompletionFunc *cb, void *opaque)
{
    int a = 2;
    int b = 3;
    GF_BitStream *bs_1;
    GF_Box *s_2;
    u32 len;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_2;
    if (cap->item_name) {
    		len = (u32) strlen(cap->item_name)+1;
    		gf_bs_write_data(bs_1, cap->item_name, len);
    	} else {
    		gf_bs_write_byte(bs_1, 0, 1);
    }
    while (a < b) {
        BDRVRawState *s = bs->opaque;
        b = a;
    }
    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,
                       cb, opaque, QEMU_AIO_READ);
}",0,1,7,0.56,Insert
335,,,,,,,
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}","static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    char str[] = ""Constant"";
    target_phys_addr_t espaddr;
    ESPState *esp;
    SysBusDevice *s_10;
    esp->dma_enabled = 1;
    sysbus_mmio_map(s_10, 0, espaddr);
    while (strlen(str) > 5) {
        tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    strcpy(str, ""a"");
    }
    tcg_gen_andi_tl(reg, reg, 1);
}",0,1,8,0.3,Insert
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,
                         int64_t timestamp, int flags)
{
    TMVContext *tmv = s->priv_data;
    int64_t pos;
    if (stream_index)
        return -1;
    pos = timestamp *
          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);
    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);
    tmv->stream_index = 0;
    return 0;
}","static int tmv_read_seek(AVFormatContext *s, int stream_index,
                         int64_t timestamp, int flags)
{
    TMVContext *tmv = s->priv_data;
    int64_t pos;
    if (stream_index)
        return -1;
    pos = timestamp *
          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);
    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        tmv->stream_index = 0;
    }
    return 0;
}",1,0,5,0.08,Replace
343,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;","static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);
        IDEState *s_2 = bmdma_active_if(bm);
        pci_dma_sglist_init(&s_2->sg, pci_dev,
                                s_2->nsector / (BMDMA_PAGE_SIZE / 512) + 1);
        PCIBonitoState *s = opaque;
    }
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",1,0,3,0.25,Insert
346,"static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = end - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}","static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        int a = 2;
        int b = 2;
        sPAPRPHBState *sphb;
        ExceptionInfo *exception;
        size_t
            length;
        ImageInfo
            *writeingsize;
        Image
            *group84__pixel;
        unsigned char
            *group4;
        group4=(unsigned char *) ImageToBlob(writeingsize,group84__pixel,&length,
            exception);
        group4=(unsigned char *) RelinquishMagickMemory(group4);
        void *fdt;
        PCIDevice *dev;
        int offset;
        uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);
        int pci_status, err;
        _FDT(fdt_setprop_cell(fdt, offset, ""vendor-id"",
                                  pci_default_read_config(dev, PCI_VENDOR_ID, 2)));
        _FDT(fdt_setprop_cell(fdt, offset, ""device-id"",
                                  pci_default_read_config(dev, PCI_DEVICE_ID, 2)));
        _FDT(fdt_setprop_cell(fdt, offset, ""revision-id"",
                                  pci_default_read_config(dev, PCI_REVISION_ID, 1)));
        _FDT(fdt_setprop_cell(fdt, offset, ""cache-line-size"",
                pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));
        pci_status = pci_default_read_config(dev, PCI_STATUS, 2);
        while (a == b) {
            *duration = end - start;
            b += 1;
        }
        return start;
    }
    return AV_NOPTS_VALUE;
}",1,0,41,0.73,Insert
347,"static void raven_class_init(ObjectClass *klass, void *data)
{
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    DeviceClass *dc = DEVICE_CLASS(klass);
    k->init = raven_init;
    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;
    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;
    k->revision = 0x00;
    k->class_id = PCI_CLASS_BRIDGE_HOST;
    dc->desc = ""PReP Host Bridge - Motorola Raven"";
    dc->vmsd = &vmstate_raven;
    dc->no_user = 1;
}","static void raven_class_init(ObjectClass *klass, void *data)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    }
    DeviceClass *dc = DEVICE_CLASS(klass);
    k->init = raven_init;
    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;
    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;
    k->revision = 0x00;
    k->class_id = PCI_CLASS_BRIDGE_HOST;
    dc->desc = ""PReP Host Bridge - Motorola Raven"";
    dc->vmsd = &vmstate_raven;
    dc->no_user = 1;
}",1,0,1,0.07,Replace
350,,,,,,,
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)
{
    TCGv tmp;
    tmp = new_tmp();
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rlow, tmp);
    tmp = new_tmp();
    tcg_gen_shri_i64(val, val, 32);
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rhigh, tmp);
}","static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)
{
    TCGv tmp;
    tmp = new_tmp();
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rlow, tmp);
    tmp = new_tmp();
    tcg_gen_shri_i64(val, val, 32);
    tcg_gen_trunc_i64_i32(tmp, val);
    int a = 2;
    int b = 3;
    while (a != b) {
        struct IscsiTask iTask;
        int r = 0;
        if (iTask.status != SCSI_STATUS_GOOD) {
                r = iTask.err_code;
                goto out_unlock;
        }
        store_reg(s, rhigh, tmp);
        b = a;
    }
}",1,0,22,0.76,Insert
355,,,,,,,
358,"static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->mclms_scaling = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int cbits = av_log2(s->mclms_scaling + 1);
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}","static void decode_mclms(WmallDecodeCtx *s)
{
    Indeo3DecodeContext *s_6;
    unsigned int hdr_width, hdr_height,
        chroma_width, chroma_height;
    unsigned int hdr_width, hdr_height,
        chroma_width, chroma_height;
    unsigned char *hdr_pos, *buf_pos;
    unsigned char *hdr_pos, *buf_pos;
    unsigned int hdr_width, hdr_height,
        chroma_width, chroma_height;
    unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;
    unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;
    hdr_height = le2me_16(*(uint16_t *)buf_pos);
    chroma_height = ((hdr_height >> 2) + 3) & 0x7ffc;
    iv_Decode_Chunk(s_6, s_6->cur_frame->Ybuf, s_6->ref_frame->Ybuf, hdr_width, 
        hdr_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, 
        min(hdr_width, 160));
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    UINT32 header;
    MPADecodeContext *s_4;
    int sample_rate_index, bitrate_index;
    int sample_rate, frame_size, mpeg25, padding;
    int sample_rate, frame_size, mpeg25, padding;
    sample_rate_index = (header >> 10) & 3;
    sample_rate = mpa_freq_tab[sample_rate_index] >> (s_4->lsf + mpeg25);
    sample_rate_index += 3 * (s_4->lsf + mpeg25);
    s_4->sample_rate_index = sample_rate_index;
    int a = 2;
    int b = 3;
    while (a < b) {
        s->mclms_scaling = get_bits(&s->gb, 4);
        b = a;
    }
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int cbits = av_log2(s->mclms_scaling + 1);
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}",1,0,59,1.53,Insert
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)
{
    int bits = 8, sign = 0, shift = 0;
    switch (as->fmt) {
    case AUD_FMT_S8:
        sign = 1;
    case AUD_FMT_U8:
        break;
    case AUD_FMT_S16:
        sign = 1;
    case AUD_FMT_U16:
        bits = 16;
        shift = 1;
        break;
    case AUD_FMT_S32:
        sign = 1;
    case AUD_FMT_U32:
        bits = 32;
        shift = 2;
        break;
    }
    info->freq = as->freq;
    info->bits = bits;
    info->sign = sign;
    info->nchannels = as->nchannels;
    info->shift = (as->nchannels == 2) + shift;
    info->align = (1 << info->shift) - 1;
    info->bytes_per_second = info->freq << info->shift;
    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);
}","void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)
{
    int bits = 8, sign = 0, shift = 0;
    switch (as->fmt) {
    DescInfo *info_7;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info_7, true);
    char *buf = desc_get_buf(info_7, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_7));
    case AUD_FMT_S8:
        sign = 1;
    case AUD_FMT_U8:
        break;
    case AUD_FMT_S16:
        sign = 1;
    case AUD_FMT_U16:
        bits = 16;
        shift = 1;
        break;
    case AUD_FMT_S32:
        sign = 1;
    case AUD_FMT_U32:
        bits = 32;
        shift = 2;
        break;
    }
    info->freq = as->freq;
    info->bits = bits;
    info->sign = sign;
    info->nchannels = as->nchannels;
    info->shift = (as->nchannels == 2) + shift;
    unsigned long flags;
    struct sas_task *task = slow->task;
    spin_lock_irqsave(&task->task_state_lock, flags);
    spin_unlock_irqrestore(&task->task_state_lock, flags);
    info->align = (1 << info->shift) - 1;
    info->bytes_per_second = info->freq << info->shift;
    int a = 2;
    int b = 2;
    if (a == b) {
        info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);
    }
}",0,1,76,1.36,Insert
363,"static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    txn->aborting = true;
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}","static void block_job_completed_txn_abort(BlockJob *job)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        AioContext *ctx;
        b = a;
    }
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    txn->aborting = true;
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}",0,1,31,1.04,Insert
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}","void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    int a = 2;
    int b = 3;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (a != b) {
        memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
    }
}",0,1,20,0.4,Insert
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    DisasContext *ctx;
    int32_t r1, r2;
    r1 = MASK_OP_BO_S1D(ctx->opcode);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 0;
    }
}",0,1,21,0.61,Insert
367,"int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}","int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        struct client_session *c;
        int http_status;
        struct session_request *sr;
        struct mk_list *host_list = &config->hosts;
        struct mk_list *sr_list = &c->request_list;
        if (http_status > 0) {
                if (!sr->host_conf) {
                    sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
                }
                mk_request_error(http_status, c, sr);
                mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                    NULL, c, sr);
        }
        int a = 2;
        int b = 2;
        if (a == b) {
            return memory_region_get_fd(mr->alias);
        }
    }
    assert(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}",0,1,7,0.36,Insert
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,
                              TCGReg r1, TCGReg r2, TCGReg rn,
                              tcg_target_long ofs, bool pre, bool w)
{
    insn |= 1u << 31;  
    insn |= pre << 24;
    insn |= w << 23;
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);
    insn |= (ofs & (0x7f << 3)) << (15 - 3);
    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);
}","static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,
                              TCGReg r1, TCGReg r2, TCGReg rn,
                              tcg_target_long ofs, bool pre, bool w)
{
    insn |= 1u << 31;  
    insn |= pre << 24;
    int a = 2;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    GF_BitStream *bits;
    GF_Box *s_4;
    GF_LASeRSampleEntryBox *buf_7 = (GF_LASeRSampleEntryBox*)s_4;
    GF_BitStream *bits_5;
    GF_Box *s_2;
    GF_LASeRSampleEntryBox *buf_3 = (GF_LASeRSampleEntryBox*)s_2;
    GF_Err e_8;
    e_8 = gf_isom_base_sample_entry_read_7((GF_SampleEntryBox *)buf_3, bits_5);
    ISOM_DECREASE_SIZE_6(buf_3, 8);
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf_7, bits);
    ISOM_DECREASE_SIZE(buf_7, 8);
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int b = 2;
    while (a == b) {
        insn |= w << 23;
        b += 1;
    }
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);
    insn |= (ofs & (0x7f << 3)) << (15 - 3);
    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);
}",0,1,100,1.09,Insert
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,
                                   const char *name, Error **errp)
{
    X86CPU *cpu = X86_CPU(obj);
    const int64_t min = 0;
    const int64_t max = INT_MAX;
    int64_t value;
    visit_type_int(v, &value, name, errp);
    if (error_is_set(errp)) {
        return;
    }
    if (value < min || value > max) {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",
                  name ? name : ""null"", value, min, max);
        return;
    }
    cpu->env.tsc_khz = value / 1000;
}","static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,
                                   const char *name, Error **errp)
{
    int a = 2;
    int b = 2;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *cur  = NULL;
    cur  = p->data[0];
    if (a == b) {
        X86CPU *cpu = X86_CPU(obj);
    }
    const int64_t min = 0;
    const int64_t max = INT_MAX;
    int64_t value;
    visit_type_int(v, &value, name, errp);
    if (error_is_set(errp)) {
        return;
    }
    if (value < min || value > max) {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",
                  name ? name : ""null"", value, min, max);
        return;
    }
    size_t size;
    struct kmem_cache *matchp;
    unsigned long bytes;
    left = calculate_slab_order(matchp, size, bytes | CFLGS_OFF_SLAB);
    cpu->env.tsc_khz = value / 1000;
}",0,1,55,1.04,Insert
371,"static av_cold int check_format(AVCodecContext *avctx)
{
    AVCodecParserContext *parser;
    uint8_t *pout;
    int psize;
    int index;
    H264Context *h;
    int ret = -1;
    parser = av_parser_init(avctx->codec->id);
    if (!parser) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");
        goto final;
    }
    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;
    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);
    if (index < 0) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");
        goto release_parser;
    }
    h = parser->priv_data;
    switch (h->sps.bit_depth_luma) {
    case 8:
        if (!CHROMA444(h) && !CHROMA422(h)) {
            ret = 0;
            break;
        }
    default:
        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");
    }
release_parser:
    av_parser_close(parser);
final:
    return ret;
}","static av_cold int check_format(AVCodecContext *avctx)
{
    AVCodecParserContext *parser;
    uint8_t *pout;
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    int psize;
    int index;
    H264Context *h;
    int ret = -1;
    parser = av_parser_init(avctx->codec->id);
    if (!parser) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");
        goto final;
    }
    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;
    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);
    if (index < 0) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");
        goto release_parser;
    }
    h = parser->priv_data;
    switch (h->sps.bit_depth_luma) {
    case 8:
        if (!CHROMA444(h) && !CHROMA422(h)) {
            ret = 0;
            break;
        }
    default:
        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");
    }
release_parser:
    av_parser_close(parser);
final:
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return ret;
    strcpy(str, ""a"");
    }
}",0,1,41,1.06,Insert
372,"static unsigned int dec_move_mr(DisasContext *dc)
{
	int memsize = memsize_zz(dc);
	int insn_len;
	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",
		    memsize_char(memsize),
		    dc->op1, dc->postinc ? ""+]"" : ""]"",
		    dc->op2));
	if (memsize == 4) {
		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_update_cc_op(dc, CC_OP_MOVE, 4);
		cris_update_cc_x(dc);
		cris_update_result(dc, cpu_R[dc->op2]);
	}
	else {
		TCGv t0;
		t0 = tcg_temp_new(TCG_TYPE_TL);
		insn_len = dec_prep_move_m(dc, 0, memsize, t0);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_alu(dc, CC_OP_MOVE,
			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);
		tcg_temp_free(t0);
	}
	do_postinc(dc, memsize);
	return insn_len;
}","static unsigned int dec_move_mr(DisasContext *dc)
{
	int memsize = memsize_zz(dc);
	int insn_len;
	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",
		    memsize_char(memsize),
		    dc->op1, dc->postinc ? ""+]"" : ""]"",
		    dc->op2));
	if (memsize == 4) {
		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);
		struct ttm_buffer_object *bo;
		struct ttm_bo_device *tdev = bo->tdev;
		struct ttm_bo_device *tdev = bo->tdev;
		dma_resv_assert_held(bo->base.resv);
		bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_update_cc_op(dc, CC_OP_MOVE, 4);
		GF_BitStream *bs;
		GF_Box *s;
		FilePartitionBox *inter = (FilePartitionBox *)s;
		u32 i;
		for (i=0;i < inter->nb_entries; i++) {
				inter->entries[i].block_count = gf_bs_read_u16(bs);
				inter->entries[i].block_size = gf_bs_read_u32(bs);
		}
		cris_update_cc_x(dc);
		cris_update_result(dc, cpu_R[dc->op2]);
	}
	else {
		DeviceState *mem = NULL;
		SysBusDevice *busDev;
		busDev = SYS_BUS_DEVICE(mem);
		sysbus_mmio_map(busDev, 0, 0xfff3c000);
		TCGv t0;
		int a = 2;
		int b = 2;
		QEMUBH *phi;
		phi = g_malloc0(sizeof(QEMUBH));
		phi->ctx = ctx;
		phi->cb = cb;
		phi->opaque = opaque;
		phi->next = ctx->first_bh;
		if (a == b) {
    		t0 = tcg_temp_new(TCG_TYPE_TL);
    		SDRequest *err;
    		SDState *esi;
    		uint32_t last_status = esi->card_status;
    		sd_rsp_type_t srowner;
    		uint32_t last_status = esi->card_status;
    		if (last_status & APP_CMD) {
    		        srowner = sd_app_command(esi, *err);
    		        esi->card_status &= ~APP_CMD;
    		    } else
    		        srowner = sd_normal_command(esi, *err);
		}
		insn_len = dec_prep_move_m(dc, 0, memsize, t0);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_alu(dc, CC_OP_MOVE,
			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);
		tcg_temp_free(t0);
	}
	do_postinc(dc, memsize);
	return insn_len;
}",0,1,165,1.76,Insert
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)
{
    VirtIONet *n = opaque;
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)
        return -EINVAL;
    return virtio_load(vdev, f, version_id);
}","static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        VirtIONet *n = opaque;
    strcpy(str, ""a"");
    }
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)
        return -EINVAL;
    return virtio_load(vdev, f, version_id);
}",0,1,1,0.05,Replace
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);
}","static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);
    strcpy(str, ""a"");
    BUFFER *gz;
    ciss_url_t uc;
    url_ciss_tobuffer (&uc, gz, 0);
    }
}",0,1,14,0.38,Insert
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,
        BlockCompletionFunc *cb, void *opaque)
{
    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);
    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,
                                 BDRV_REQ_ZERO_WRITE | flags,
                                 cb, opaque, true);
}","BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,
        BlockCompletionFunc *cb, void *opaque)
{
    char str[] = ""Constant"";
    GF_Box *s;
    GF_BitStream *bs_9;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    gf_bs_write_int(bs_9, ptr->config->nal_unit_size - 1, 2);
    gf_bs_write_int(bs_9, 0x7, 3);
    gf_bs_write_int(bs_9, ch, 5);
    gf_bs_write_u8(bs_9, ch);
    if (strlen(str) > 0) {
        trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);
    }
    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,
                                 BDRV_REQ_ZERO_WRITE | flags,
                                 cb, opaque, true);
}",0,1,6,0.55,Insert
379,"static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    virtio_reset(proxy->vdev);
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}","static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    int a = 2;
    int b = 2;
    while (a == b) {
        virtio_reset(proxy->vdev);
        b += 1;
    }
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}",0,1,8,0.08,Replace
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,
                            TCGReg dst, TCGReg lhs, TCGArg rhs,
                            bool rhs_is_const)
{
    if (rhs_is_const) {
        int rot = encode_imm(rhs);
        if (rot < 0) {
            rhs = ~rhs;
            rot = encode_imm(rhs);
            assert(rot >= 0);
            opc = opinv;
        }
        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));
    } else {
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
    }
}","static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,
                            TCGReg dst, TCGReg lhs, TCGArg rhs,
                            bool rhs_is_const)
{
    if (rhs_is_const) {
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        struct CallCount *pb;
        if( pb ) pb->nStep = 1;
        busDev = SYS_BUS_DEVICE(mem);
        sysbus_mmio_map(busDev, 0, 0xfff3c000);
        int rot = encode_imm(rhs);
        if (rot < 0) {
            rhs = ~rhs;
            rot = encode_imm(rhs);
            assert(rot >= 0);
            opc = opinv;
        }
        int a = 2;
        int b = 2;
        while (a == b) {
            tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));
            b += 1;
        }
    } else {
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
    }
}",0,1,46,1.16,Insert
381,"static int twl92230_init(i2c_slave *i2c)
{
    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);
    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);
    qdev_init_gpio_out(&i2c->qdev, s->out, 4);
    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);
    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];
    menelaus_reset(&s->i2c);
    return 0;
}","static int twl92230_init(i2c_slave *i2c)
{
    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);
    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);
    int a = 10;
    int b = a;
    if(a*b>0){
        qdev_init_gpio_out(&i2c->qdev, s->out, 4);
    }
    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);
    MpegEncContext *s_1;
    if (s_1->current_picture.reference)
            ff_thread_report_progress(&s_1->current_picture_ptr->tf, INT_MAX, 0);
    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];
    menelaus_reset(&s->i2c);
    return 0;
}",0,1,16,0.54,Insert
383,,,,,,,
386,"static inline int popcountl(unsigned long l)
{
    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);
}","static inline int popcountl(unsigned long l)
{
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (gst_date_time_get_second (dt) == gst_date_time_get_second (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);
}",1,0,3,0.18,Insert
387,,,,,,,
388,,,,,,,
389,,,,,,,
392,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}","static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        const v8::PropertyCallbackInfo<v8::Value>& py;
        from(py.Holder()->CreationContext());
        v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        MpegEncContext *ses;
        MotionEstContext * const k= &ses->me;
        MotionEstContext * const k= &ses->me;
        if(ses->no_rounding) k->hpel_put= ses->dsp.put_no_rnd_pixels_tab;
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        order = extract32(ksns, 22, 2);
        handle_fp_compare(qs, order, coll, err, false, p);
            else               k->hpel_put= ses->dsp.put_pixels_tab;
        if (strcmp(str1, str2) == 0) {
            h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);
        }
    } else {
        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}",0,1,82,1.36,Insert
398,,,,,,,
399,,,,,,,
400,"static USBDevice *usb_net_init(const char *cmdline)
{
    USBDevice *dev;
    QemuOpts *opts;
    int idx;
    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);
    if (!opts) {
    qemu_opt_set(opts, ""type"", ""nic"");
    qemu_opt_set(opts, ""model"", ""usb"");
    idx = net_client_init(NULL, opts, 0);
    if (idx == -1) {
    dev = usb_create(NULL  , ""usb-net"");
    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
    qdev_init_nofail(&dev->qdev);
    return dev;","static USBDevice *usb_net_init(const char *cmdline)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        USBDevice *dev;
        b = a;
        uint8_t rcv_id_line;
        const char *raw_pdu;
        const struct isis_circuit *circuit;
        size_t raw_pdu_len;
        struct list *arguments = yang_data_list_new();
        struct isis_area *area = circuit->area;
        const char *xpath = ""/frr-isisd:id-len-mismatch"";
        notif_prepr_iface_hdr(xpath, circuit, arguments);
        hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_line, raw_pdu,
        		  raw_pdu_len);
    }
    QemuOpts *opts;
    int idx;
    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);
    if (!opts) {
    qemu_opt_set(opts, ""type"", ""nic"");
    qemu_opt_set(opts, ""model"", ""usb"");
    idx = net_client_init(NULL, opts, 0);
    uint32_t val;
    CPUARMState *env;
    uint32_t mask;
    if (mask & CPSR_IT_2_7) {
            env->condexec_bits &= 3;
            env->condexec_bits |= (val >> 8) & 0xfc;
    }
    if (idx == -1) {
    dev = usb_create(NULL  , ""usb-net"");
    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
    qdev_init_nofail(&dev->qdev);
    return dev;",1,0,72,0.97,Insert
401,,,,,,,
402,"static void handle_mousewheel(SDL_Event *ev)
{
    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);
    SDL_MouseWheelEvent *wev = &ev->wheel;
    InputButton btn;
    if (wev->y > 0) {
        btn = INPUT_BUTTON_WHEEL_UP;
    } else if (wev->y < 0) {
        btn = INPUT_BUTTON_WHEEL_DOWN;
    } else {
        return;
    }
    qemu_input_queue_btn(scon->dcl.con, btn, true);
    qemu_input_event_sync();
    qemu_input_queue_btn(scon->dcl.con, btn, false);
    qemu_input_event_sync();
}","static void handle_mousewheel(SDL_Event *ev)
{
    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    char str[] = ""Constant"";
    struct sk_buff *img;
    nlmsg_free(img);
    while (strlen(str) > 5) {
        SDL_MouseWheelEvent *wev = &ev->wheel;
    strcpy(str, ""a"");
    }
    InputButton btn;
    if (wev->y > 0) {
        btn = INPUT_BUTTON_WHEEL_UP;
    } else if (wev->y < 0) {
        btn = INPUT_BUTTON_WHEEL_DOWN;
    } else {
        return;
    }
    qemu_input_queue_btn(scon->dcl.con, btn, true);
    qemu_input_event_sync();
    qemu_input_queue_btn(scon->dcl.con, btn, false);
    qemu_input_event_sync();
}",0,1,52,0.72,Insert
403,"static void init_virtio_dev(TestServer *s)
{
    QPCIBus *bus;
    QVirtioPCIDevice *dev;
    uint32_t features;
    bus = qpci_init_pc(NULL);
    g_assert_nonnull(bus);
    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);
    g_assert_nonnull(dev);
    qvirtio_pci_device_enable(dev);
    qvirtio_reset(&dev->vdev);
    qvirtio_set_acknowledge(&dev->vdev);
    qvirtio_set_driver(&dev->vdev);
    features = qvirtio_get_features(&dev->vdev);
    features = features & VIRTIO_NET_F_MAC;
    qvirtio_set_features(&dev->vdev, features);
    qvirtio_set_driver_ok(&dev->vdev);
}","static void init_virtio_dev(TestServer *s)
{
    QPCIBus *bus;
    QVirtioPCIDevice *dev;
    uint32_t features;
    bus = qpci_init_pc(NULL);
    g_assert_nonnull(bus);
    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);
    g_assert_nonnull(dev);
    qvirtio_pci_device_enable(dev);
    qvirtio_reset(&dev->vdev);
    Error **err;
    DeviceState *dev_3;
    PCIBus *bus_4 = PC_MACHINE(qdev_get_machine())->bus_4;
    int ret = 0;
    AMDVIState *none = AMD_IOMMU_DEVICE(dev_3);
    AMDVIState *none = AMD_IOMMU_DEVICE(dev_3);
    qdev_set_parent_bus(DEVICE(&none->pci), &bus_4->qbus);
    none->capab_offset = pci_add_capability(&none->pci.dev_3, AMDVI_CAPAB_ID_SEC, 0,
                                             AMDVI_CAPAB_SIZE);
    ret = pci_add_capability(&none->pci.dev_3, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);
    ret = pci_add_capability(&none->pci.dev_3, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);
    none->devid = object_property_get_int(OBJECT(&none->pci), ""addr"", err);
    qvirtio_set_acknowledge(&dev->vdev);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        qvirtio_set_driver(&dev->vdev);
    }
    features = qvirtio_get_features(&dev->vdev);
    features = features & VIRTIO_NET_F_MAC;
    qvirtio_set_features(&dev->vdev, features);
    qvirtio_set_driver_ok(&dev->vdev);
}",1,0,35,0.83,Insert
405,,,,,,,
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password\n"");
        ret = -EPERM;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}","static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        int a = 23;
        int b = a;
        if(a*b>0){
            monitor_printf(mon, ""invalid password\n"");
        }
        ret = -EPERM;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}",0,1,1,0.07,Replace
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        return;
    }
    qemu_del_vlan_client(vc);
}","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        VLANClientState *vc;
    strcpy(str, ""a"");
    }
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        return;
    }
    qemu_del_vlan_client(vc);
}",0,1,1,0.08,Replace
414,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)
{
    QObject *token;
    const char *val;
    if (ap == NULL) {
        return NULL;
    }
    token = parser_context_pop_token(ctxt);
    assert(token && token_get_type(token) == JSON_ESCAPE);
    val = token_get_value(token);
    if (!strcmp(val, ""%p"")) {
        return va_arg(*ap, QObject *);
    } else if (!strcmp(val, ""%i"")) {
        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%ld"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long)));
    } else if (!strcmp(val, ""%lld"") ||
               !strcmp(val, ""%I64d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
    } else if (!strcmp(val, ""%s"")) {
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));
    } else if (!strcmp(val, ""%f"")) {
        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));
    }
    return NULL;
}","static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)
{
    QObject *token;
    const char *val;
    if (ap == NULL) {
        int a = 2;
        int b = 3;
        while (a < b) {
            return NULL;
            b = a;
        }
    }
    token = parser_context_pop_token(ctxt);
    assert(token && token_get_type(token) == JSON_ESCAPE);
    val = token_get_value(token);
    if (!strcmp(val, ""%p"")) {
        return va_arg(*ap, QObject *);
        qemu_irq rx[128];
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        busDev = SYS_BUS_DEVICE(mem);
        sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
        busDev = SYS_BUS_DEVICE(mem);
        GF_BitStream *bs;
        GF_Box *s;
        u32 len;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        if (cap->item_name) {
        		len = (u32) strlen(cap->item_name)+1;
        		gf_bs_write_data(bs, cap->item_name, len);
        	} else {
        		gf_bs_write_byte(bs, 0, 1);
        }
        sysbus_mmio_map(busDev, 0, 0xfff34000);
        sysbus_connect_irq(busDev, 0, rx[18]);
    } else if (!strcmp(val, ""%i"")) {
        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%ld"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long)));
    } else if (!strcmp(val, ""%lld"") ||
               !strcmp(val, ""%I64d"")) {
        struct rose_neigh *client;
        rose_neigh_list           = client;
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
    } else if (!strcmp(val, ""%s"")) {
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));
    } else if (!strcmp(val, ""%f"")) {
        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));
    }
    return NULL;
}",0,1,93,1.89,Insert
416,"void main_loop_wait(int nonblocking)
{
    fd_set rfds, wfds, xfds;
    int ret, nfds;
    struct timeval tv;
    int timeout;
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);
    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
    qemu_mutex_unlock_iothread();
    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);
    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}","void main_loop_wait(int nonblocking)
{
    struct usb_serial_port *timeout_6;
    struct whiteheat_simple close_command;
    close_command.timeout_6 = timeout_6->port_number + 1;
    fd_set rfds, wfds, xfds;
    int ret, nfds;
    int a = 2;
    int b = 3;
    if (a != b) {
        struct timeval tv;
    }
    int timeout;
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);
    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
    qemu_mutex_unlock_iothread();
    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);
    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}",0,1,45,1.18,Insert
417,,,,,,,
419,,,,,,,
427,"static void i440fx_update_memory_mappings(PCII440FXState *d)
{
    int i, r;
    uint32_t smram;
    bool smram_enabled;
    memory_region_transaction_begin();
    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,
               &d->pam_regions[0]);
    for(i = 0; i < 12; i++) {
        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;
        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,
                   &d->pam_regions[i+1]);
    }
    smram = d->dev.config[I440FX_SMRAM];
    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);
    memory_region_set_enabled(&d->smram_region, !smram_enabled);
    memory_region_transaction_commit();
}","static void i440fx_update_memory_mappings(PCII440FXState *d)
{
    int i, r;
    uint32_t smram;
    bool smram_enabled;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ppc4xx_bd_info_t *bd;
        int i_7, n;
        ram_addr_t bdloc;
        for (i_7 = 0; i_7 < 32; i_7++)
                stb_phys(bdloc + 0x3C + i_7, bd->bi_s_version[i_7]);
        memory_region_transaction_begin();
    }
    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,
               &d->pam_regions[0]);
    for(i = 0; i < 12; i++) {
        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;
        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,
                   &d->pam_regions[i+1]);
    }
    smram = d->dev.config[I440FX_SMRAM];
    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);
    memory_region_set_enabled(&d->smram_region, !smram_enabled);
    memory_region_transaction_commit();
}",1,0,24,0.91,Insert
429,"static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->len = htonl(control->len);
    control->repeat = htonl(control->repeat);
}","static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        control->len = htonl(control->len);
    }
    control->repeat = htonl(control->repeat);
}",1,0,1,0.03,Replace
430,"static bool use_multiport(VirtIOSerial *vser)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(vser);
    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);
}","static bool use_multiport(VirtIOSerial *vser)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(vser);
    int a = 37;
    int b = a;
    if(a*b>0){
        return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
    }
}",0,1,6,0.24,Insert
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}","void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    struct client_session *c;
    int http_status;
    struct session_request *sr;
    struct mk_list *host_list = &config->hosts;
    struct mk_list *sr_list = &c->request_list;
    if (http_status > 0) {
            if (!sr->host_conf) {
                sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
            }
            mk_request_error(http_status, c, sr);
            mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                NULL, c, sr);
    }
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}",0,1,7,0.3,Insert
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->delay;
    afq->remaining_samples = avctx->delay;
    afq->frame_queue       = NULL;
}","void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->delay;
    afq->remaining_samples = avctx->delay;
    int a = 2;
    int b = 2;
    if (a == b) {
        afq->frame_queue       = NULL;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
    }
}",0,1,13,0.32,Insert
434,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)
{
    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
}","void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)
{
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    int a = 2;
    int b = 2;
    if (a == b) {
        kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
    }
}",0,1,3,0.29,Insert
439,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)
{
    if (use_icount) {
        gen_io_start();
    }
    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}","static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)
{
    if (use_icount) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            gen_io_start();
            CharDriverState *cher;
            cher->chr_update_read_handler = fd_chr_update_read_handler;
            cher->chr_close = fd_chr_close;
            qemu_chr_be_generic_open(cher);
        }
    }
    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}",0,1,9,0.35,Insert
441,"static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_evfsnabs(DisasContext *ctx)
{
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    if (unlikely(!ctx->spe_enabled)) {
        XMLTreeInfo
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i;
        for (i=0;i < inter->nb_entries; i++) {
        		inter->entries[i].block_count = gf_bs_read_u16(bs);
        		inter->entries[i].block_size = gf_bs_read_u32(bs);
        }
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        xml=FileToString(filename,~0UL,exception);
        quantization_tables=NewXMLTree(xml,exception);
        xml=DestroyString(xml);
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    int a = 38;
    int b = a;
    if(a*b>0){
        tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
    }
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",0,1,73,0.8,Insert
442,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:  
        DPRINTF("" cr = %x\n"", s->cr);
        return s->cr;
    case 1:  
        DPRINTF("" pr = %x\n"", s->pr);
        return s->pr;
    case 2:  
        DPRINTF("" sr = %x\n"", s->sr);
        return s->sr;
    case 3:  
        DPRINTF("" ir = %x\n"", s->ir);
        return s->ir;
    case 4:  
        DPRINTF("" ocr1 = %x\n"", s->ocr1);
        return s->ocr1;
    case 9:  
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x\n"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x\n"",
            (int)offset >> 2);
    return 0;
}","static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:  
        DPRINTF("" cr = %x\n"", s->cr);
        return s->cr;
    case 1:  
        DPRINTF("" pr = %x\n"", s->pr);
        return s->pr;
    case 2:  
        DPRINTF("" sr = %x\n"", s->sr);
        return s->sr;
        VirtIODevice *vrdevice;
        BlockConf *conf = &s_6->conf.conf;
        VirtIOBlock *s_6 = VIRTIO_BLK(vrdevice);
        int blk_size = conf->logical_block_size;
        struct virtio_blk_config blkcfg;
        virtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);
        virtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
        blkcfg.heads = conf->heads;
        blkcfg.size_max = 0;
        blkcfg.physical_block_exp = get_physical_block_exp(conf);
    case 3:  
        DPRINTF("" ir = %x\n"", s->ir);
        return s->ir;
    case 4:  
        DPRINTF("" ocr1 = %x\n"", s->ocr1);
        return s->ocr1;
    case 9:  
        int a = 2;
        int b = 2;
        if (a == b) {
            imx_timerg_update_counts(s);
        }
        DPRINTF("" cnt = %x\n"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x\n"",
            (int)offset >> 2);
    return 0;
}",0,1,61,1.0,Insert
444,"static void test_qemu_strtoull_full_negative(void)
{
    const char *str = "" \t -321"";
    uint64_t res = 999;
    int err;
    err = qemu_strtoull(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 18446744073709551295LLU);
}","static void test_qemu_strtoull_full_negative(void)
{
    const char *str = "" \t -321"";
    uint64_t res = 999;
    int a_1 = 2;
    struct ttm_buffer_object *bo;
    struct ttm_bo_device *tdev = bo->tdev;
    struct ttm_bo_device *tdev = bo->tdev;
    dma_resv_assert_held(bo->base.resv);
    bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
    int b_1 = 3;
    while (a_1 != b_1) {
        int err;
        b_1 = a_1;
    }
    err = qemu_strtoull(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 18446744073709551295LLU);
}",0,1,16,0.39,Insert
446,"float64 HELPER(ucf64_absd)(float64 a)
{
    return float64_abs(a);
}","float64 HELPER(ucf64_absd)(float64 a)
{
    int a_1 = 2;
    int b_1 = 2;
    while (a_1 == b_1) {
        return float64_abs(a);
        struct net_device *bond_dev;
        struct bonding *Bond = netdev_priv(bond_dev);
        struct bond_up_slave *usable, *all;
        if (usable) {
        		RCU_INIT_POINTER(Bond->usable_slaves, NULL);
        		kfree_rcu(usable, rcu);
        }
        b_1 += 1;
    }
}",0,1,26,0.31,Insert
447,"static CharDriverState *qemu_chr_open_null(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    CharDriverState *chr;
    ChardevCommon *common = backend->u.null;
    chr = qemu_chr_alloc(common, errp);
    if (!chr) {
        return NULL;
    }
    chr->chr_write = null_chr_write;
    chr->explicit_be_open = true;
    return chr;
}","static CharDriverState *qemu_chr_open_null(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    CharDriverState *chr;
    S390CPU *console;
    Error *order = NULL;
    console = cpu_s390x_create(cpu_model, &order);
    object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
    object_property_set_bool(OBJECT(console), true, ""realized"", &order);
    int a = 2;
    int b = 3;
    struct inode *inode;
    wait_queue_head_t *wriq;
    DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
    wriq = bit_waitqueue(&inode->i_state, __I_NEW);
    spin_unlock(&inode->i_lock);
    spin_unlock(&inode_hash_lock);
    spin_lock(&inode_hash_lock);
    while (a < b) {
        ChardevCommon *common = backend->u.null;
        b = a;
    }
    chr = qemu_chr_alloc(common, errp);
    if (!chr) {
        return NULL;
    }
    chr->chr_write = null_chr_write;
    chr->explicit_be_open = true;
    return chr;
}",0,1,54,0.71,Insert
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum CodecID id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}","enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    int i;
    for(i=0; i<4 && tags[i]; i++){
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            enum CodecID id= codec_get_id(tags[i], tag);
        strcpy(str, ""a"");
        }
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}",0,1,8,0.56,Insert
453,,,,,,,
458,"void sws_rgb2rgb_init(int flags)
{
#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX
    if (flags & SWS_CPU_CAPS_SSE2)
        rgb2rgb_init_SSE2();
    else if (flags & SWS_CPU_CAPS_MMX2)
        rgb2rgb_init_MMX2();
    else if (flags & SWS_CPU_CAPS_3DNOW)
        rgb2rgb_init_3DNOW();
    else if (flags & SWS_CPU_CAPS_MMX)
        rgb2rgb_init_MMX();
    else
#endif  
        rgb2rgb_init_C();
}","void sws_rgb2rgb_init(int flags)
{
#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX

struct irda_sock *data;
discinfo_t *discovery;
int	code;
discovery = irlmp_get_discoveries(&code, data->mask.word,
					    data->nslots);
kfree(discovery);    if (flags & SWS_CPU_CAPS_SSE2)
        rgb2rgb_init_SSE2();
    else if (flags & SWS_CPU_CAPS_MMX2)
        rgb2rgb_init_MMX2();
    else if (flags & SWS_CPU_CAPS_3DNOW)
        rgb2rgb_init_3DNOW();
    else if (flags & SWS_CPU_CAPS_MMX)
        rgb2rgb_init_MMX();
    else
#endif  
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            rgb2rgb_init_C();
        }
}",0,1,9,0.5,Insert
459,"static double tget_double(GetByteContext *gb, int le)
{
    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
    return i.f64;
}","static double tget_double(GetByteContext *gb, int le)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        struct mr6_table *mrt;
        struct mem *mem = read_pnet(&mrt->mem);
        atomic_dec(&mrt->cache_resolve_queue_len);
        av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
    }
    return i.f64;
}",0,1,29,0.48,Insert
461,,,,,,,
463,,,,,,,
464,"void object_property_add_bool(Object *obj, const char *name,
                              bool (*get)(Object *, Error **),
                              void (*set)(Object *, bool, Error **),
                              Error **errp)
{
    BoolProperty *prop = g_malloc0(sizeof(*prop));
    prop->get = get;
    prop->set = set;
    object_property_add(obj, name, ""bool"",
                        get ? property_get_bool : NULL,
                        set ? property_set_bool : NULL,
                        property_release_bool,
                        prop, errp);
}","void object_property_add_bool(Object *obj, const char *name,
                              bool (*get)(Object *, Error **),
                              void (*set)(Object *, bool, Error **),
                              Error **errp)
{
    BoolProperty *prop = g_malloc0(sizeof(*prop));
    prop->get = get;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        prop->set = set;
    }
    object_property_add(obj, name, ""bool"",
                        get ? property_get_bool : NULL,
                        set ? property_set_bool : NULL,
                        property_release_bool,
                        prop, errp);
}",1,0,4,0.1,Replace
465,"static inline int mirror(int v, int m){
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    else         return v;
}","static inline int mirror(int v, int m){
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    AVPacket *pkt;
    MOVTrack *trk = &mov->tracks[pkt->stream_index];
    AVCodecContext *enc = trk->enc;
    if (trk->vosLen == 0 && enc->extradata_size > 0) {
            trk->vosLen = enc->extradata_size;
            trk->vosData = av_malloc(trk->vosLen);
            memcpy(trk->vosData, enc->extradata, trk->vosLen);
    }
    else         return v;
}",1,0,6,0.39,Insert
466,,,,,,,
473,,,,,,,
474,"static QmpInputVisitor *to_qiv(Visitor *v)
{
    return container_of(v, QmpInputVisitor, visitor);
}","static QmpInputVisitor *to_qiv(Visitor *v)
{
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    return container_of(v, QmpInputVisitor, visitor);
}",0,1,4,0.2,Insert
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        return res;
    }
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    if (frame && s->interlaced) {
        frame->interlaced_frame = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}","static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    struct video_data *s = s1->priv_data;
    MpegEncContext *s_4;
    int mb_x, mb_y;
    mb_x = s_4->mb_x;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    char str[] = ""Constant"";
    VirtioCcwDevice *dev;
    Error *err = NULL;
    GF_BitStream *bs_6;
    GF_Box *s_7;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_7;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_7;
    GF_Err e;
    e = gf_isom_full_box_write(s_7, bs_6);
    AVPacket * pk;
    AVFormatContext *s_2;
    unsigned char rb[5];
    AVCodecParameters *par = s_2->streams[stream_index]->codecpar;
    AVIOContext *b     = s_2->b;
    const int stream_index =  pk->stream_index;
    avi_stream2fourcc(rb, stream_index, par->codec_type);
    avio_write(b, rb, 4);
    gf_bs_write_u16(bs_6, cap->item_protection_index);
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (strlen(str) > 0) {
        int res;
    }
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        return res;
    }
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    if (frame && s->interlaced) {
        frame->interlaced_frame = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
    GF_BitStream *bs;
    GF_Box *s_8;
    FilePartitionBox *inter = (FilePartitionBox *)s_8;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
}",0,1,168,1.47,Insert
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
    k->init = bonito_pcihost_initfn;
    dc->no_user = 1;
}","static void bonito_pcihost_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    GDateTime *gdt, *gdt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_day (dt) ==
          g_date_time_get_day_of_month (gdt));
    fail_unless (gst_date_time_get_hour (dt) == 15);
    fail_unless (gst_date_time_get_minute (dt) == 50);
    fail_unless (!gst_date_time_has_second (dt));
    gst_date_time_unref (dt);
    int a = 2;
    int b = 3;
    while (a != b) {
        SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
        b = a;
    }
    k->init = bonito_pcihost_initfn;
    dc->no_user = 1;
}",1,0,16,0.47,Insert
478,"void memory_region_iommu_replay_all(MemoryRegion *mr)
{
    IOMMUNotifier *notifier;
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
        memory_region_iommu_replay(mr, notifier, false);
    }
}","void memory_region_iommu_replay_all(MemoryRegion *mr)
{
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    struct nbd_request Request;
    uint32_t response;
    response = Request.type & NBD_CMD_MASK_COMMAND;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    IOMMUNotifier *notifier;
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
        int a = 10;
        int b = a;
        if(a*b>0){
            memory_region_iommu_replay(mr, notifier, false);
        }
    }
}",0,1,57,0.59,Insert
479,"static int usb_uhci_piix3_initfn(PCIDevice *dev)
{
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);
    return usb_uhci_common_initfn(s);
}","static int usb_uhci_piix3_initfn(PCIDevice *dev)
{
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    uint8_t *pci_conf = s->dev.config;
    int a = 2;
    int b = 2;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    if (a == b) {
        pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    }
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);
    return usb_uhci_common_initfn(s);
}",0,1,15,0.49,Insert
481,"static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	gf_bs_read_u8(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	struct CallCount *pb;
	if( pb ) pb->nStep = 1;
	int a = 98;
	int b = a;
	if(a*b>0){
    	t0 = tcg_temp_new(TCG_TYPE_TL);
	}
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}",0,1,49,0.86,Insert
484,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    return 0;","static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            int a = 2;
            int b = 3;
            while (a != b) {
                P[0] = bytestream2_get_byte(&s->stream_ptr);
                b = a;
            }
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    return 0;",1,0,4,0.09,Replace
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->file)) {
        goto out;
    }
    s->xfer_limit = new_rate;
out:
    return s->xfer_limit;
}","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->file)) {
        int a = 2;
        int b = 2;
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        if (a == b) {
            goto out;
        }
    }
    s->xfer_limit = new_rate;
out:
    return s->xfer_limit;
}",0,1,15,0.38,Insert
487,"static void scsi_disk_reset(DeviceState *dev)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);
    uint64_t nb_sectors;
    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->tray_open = 0;
}","static void scsi_disk_reset(DeviceState *dev)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);
    uint64_t nb_sectors;
    MachineState *machine;
    int i;
    void *opaques;
    V9fsPDU *pdf = opaques;
    V9fsString part;
    int32_t fpaid, newcids;
    size_t offset = 7;
    int32_t fpaid, newcids;
    pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    PowerPCCPU *cpu;
    for (i = 0; i < smp_cpus; i++) {
            BlockdevOnError on_source_bug;
            BlockdevOnError on_source_complete;
            const char *dev_8;
            enum MirrorSyncMode stage;
            int64_t peed;
            const char *data;
            int data;
            Error *localxer = NULL;
            BlockDriverState *source_vs;
            int64_t store;
            BlockDriverState *bes;
            bes = bdrv_find(dev_8);
            data = bes->open_flags | BDRV_O_RDWR;
            store = bdrv_getlength(bes);
            backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                             block_job_cb, bes, &localxer);
            cpu = cpu_ppc_init(machine->cpu_model);
            if (cpu == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu, &error_fatal);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));
        b = a;
    }
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->tray_open = 0;
}",0,1,91,1.02,Insert
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    dc0= 0x01010101*((dc0 + 4)>>3);
    for(i=0; i<8; i++){
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}","static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    int a = 3;
    int b = a;
    if(a*b>0){
        dc0= 0x01010101*((dc0 + 4)>>3);
    }
    for(i=0; i<8; i++){
        int16_t offset;
        int rt;
        int base;
        const char *opn = ""st_cond"";
        (void)opn;
        MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}",1,0,20,0.76,Insert
490,,,,,,,
491,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)
{
    rtl8139_do_receive(opaque, buf, size, 1);
}","static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        rtl8139_do_receive(opaque, buf, size, 1);
        AVPacket * pk;
        AVFormatContext *s;
        int size_9               =  pk->size_9;
        AVIOContext *b_2     = s->b_2;
        if (size_9 & 1)
                avio_w8(b_2, 0);
    }
}",0,1,3,0.32,Insert
492,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)
{
    char buffer[PATH_MAX];
    char *path = fs_path->data;
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||
        (fs_ctx->export_flags & V9FS_SM_NONE)) {
        return lchown(rpath(fs_ctx, path, buffer),
                      credp->fc_uid, credp->fc_gid);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {
        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {
        return local_set_mapped_file_attr(fs_ctx, path, credp);
    }
    return -1;
}","static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)
{
    char buffer[PATH_MAX];
    char *path = fs_path->data;
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||
        (fs_ctx->export_flags & V9FS_SM_NONE)) {
        return lchown(rpath(fs_ctx, path, buffer),
                      credp->fc_uid, credp->fc_gid);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {
        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {
        int a = 2;
        int b = 2;
        while (a == b) {
            return local_set_mapped_file_attr(fs_ctx, path, credp);
            b += 1;
        }
    }
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_10     = s->b_10;
    if (size & 1)
            avio_w8(b_10, 0);
    return -1;
}",0,1,11,0.7,Insert
494,,,,,,,
495,,,,,,,
498,,,,,,,
500,,,,,,,
503,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)
{
    double d;
    char *ptr;
    FdMigrationState *s;
    const char *value = qdict_get_str(qdict, ""value"");
    d = strtod(value, &ptr);
    switch (*ptr) {
    case 'G': case 'g':
        d *= 1024;
    case 'M': case 'm':
        d *= 1024;
    case 'K': case 'k':
        d *= 1024;
    default:
        break;
    }
    max_throttle = (uint32_t)d;
    s = migrate_to_fms(current_migration);
    if (s) {
        qemu_file_set_rate_limit(s->file, max_throttle);
    }
}","void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)
{
    double d;
    int a = 2;
    int b = 2;
    while (a == b) {
        char *ptr;
        b += 1;
    }
    FdMigrationState *s;
    const char *value = qdict_get_str(qdict, ""value"");
    d = strtod(value, &ptr);
    switch (*ptr) {
    case 'G': case 'g':
        d *= 1024;
    case 'M': case 'm':
        d *= 1024;
    case 'K': case 'k':
        d *= 1024;
    default:
        break;
    }
    max_throttle = (uint32_t)d;
    s = migrate_to_fms(current_migration);
    if (s) {
        qemu_file_set_rate_limit(s->file, max_throttle);
    }
}",0,1,1,0.13,Replace
504,"static inline void gen_efdneg(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_efdneg(DisasContext *ctx)
{
    uint64_t glms_9;
    unsigned k_4, b_5, err_6, C_2;
    unsigned k_4, b_5, err_6, C_2;
    assert_10(is_limm_5(glms_9));
    k_4 = clz64_7(glms_9);
    b_5 = ctz64_1(glms_9);
    if (unlikely(!ctx->spe_enabled)) {
        int a = 2;
        uint64_t glms;
        unsigned k, b_6, err, C;
        unsigned k, b_6, err, C;
        assert(is_limm(glms));
        struct rose_neigh *client;
        rose_neigh_list           = client;
        k = clz64(glms);
        b_6 = ctz64(glms);
        int b = 3;
        AVPacket *afpud;
        AVCodecContext *avctx;
        int sample_scale, c, n, i;
        int sample_scale, c, n, i;
        int buf_size = afpud->size;
        PCMDecode *s = avctx->priv_data;
        sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
        n = avctx->channels * sample_scale;
        n = buf_size/sample_scale;
        if (a != b) {
            gen_exception(ctx, POWERPC_EXCP_APU);
        }
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",0,1,191,1.37,Insert
506,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)
{
    VirtQueueElement elem;
    VirtQueue *vq;
    vq = vser->c_ivq;
    if (!virtio_queue_ready(vq)) {
        return 0;
    }
    if (!virtqueue_pop(vq, &elem)) {
        return 0;
    }
    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);
    virtqueue_push(vq, &elem, len);
    virtio_notify(VIRTIO_DEVICE(vser), vq);
    return len;
}","static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)
{
    VirtQueueElement elem;
    VirtQueue *vq;
    vq = vser->c_ivq;
    if (!virtio_queue_ready(vq)) {
        return 0;
    }
    if (!virtqueue_pop(vq, &elem)) {
        return 0;
    }
    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);
    virtqueue_push(vq, &elem, len);
    virtio_notify(VIRTIO_DEVICE(vser), vq);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return len;
    strcpy(str, ""a"");
    AnimationChannel &context;
    json &o;
    if (context.extras.Type() != NULL_TYPE) {
        SerializeValue(""extras"", context.extras, o);
    }
    }
}",0,1,20,0.68,Insert
508,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    cpu_physical_memory_read(addr, (void *) &ret, 1);
    return ret;
}","uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)
{
    GetBitContext * bb;
    int Global_growth, pulse_present = 0;
    Global_growth = get_bits(bb, 8);
    char str[] = ""Constant"";
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    const JsEventDetails& lines;
    struct PCIDevice *pci_dev;
    struct cgroup_taskset *teset;
    struct cgroup_subsys_state *plain;
    struct task_struct *exec;
    cgroup_taskset_for_each(exec, plain, teset)
    task_function_call(exec, __perf_cgroup_move, exec);
    int r;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    r = assign_device(Dev);
    r = assign_intx(Dev);
    assigned_dev_load_option_rom(Dev);
    add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
    const std::string& data;
    host_->frontend_loop_->PostTask(
          FROM_HERE, NewRunnableMethod(
              this, &Core::RouteJsEventOnFrontendLoop, data, lines));
    while (strlen(str) > 5) {
        uint8_t ret;
    strcpy(str, ""a"");
    }
    OMAP_8B_REG(addr);
    cpu_physical_memory_read(addr, (void *) &ret, 1);
    return ret;
}",0,1,167,1.15,Insert
509,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)
{
    q->pending++;
    set_bit(q->queue, n_IRQ);
}","static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        q->pending++;
    strcpy(str, ""a"");
    }
    set_bit(q->queue, n_IRQ);
}",1,0,2,0.04,Replace
511,,,,,,,
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}","static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            int a = 2;
            struct dst_entry *dst;
            struct rtable *rt = (struct rtable *) dst;
            if (!list_empty(&rt->rt_uncached)) {
            		spin_lock_bh(&rt_uncached_lock);
            		list_del(&rt->rt_uncached);
            		spin_unlock_bh(&rt_uncached_lock);
            }
            int b = 3;
            if (a != b) {
                qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            }
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}",0,1,21,0.74,Insert
517,,,,,,,
518,,,,,,,
519,"void ff_er_frame_start(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}","void ff_er_frame_start(ERContext *s)
{
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_2 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_2->linade, linade, datalen);
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s->error_count    = 3 * s->mb_num;
    strcpy(str, ""a"");
    }
    s->error_occurred = 0;
}",0,1,5,0.41,Insert
525,,,,,,,
527,"static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)
{
    MOVContext *mov = s->priv_data;
    int i, j;
    if (!mov->fragment_index_complete)
        return 0;
    for (i = 0; i < mov->fragment_index_count; i++) {
        if (mov->fragment_index_data[i]->track_id == st->id) {
            MOVFragmentIndex *index = index = mov->fragment_index_data[i];
            for (j = index->item_count - 1; j >= 0; j--) {
                if (index->items[j].time <= timestamp) {
                    if (index->items[j].headers_read)
                        return 0;
                    return mov_switch_root(s, index->items[j].moof_offset);
                }
            }
        }
    }
    return 0;
}","static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)
{
    MOVContext *mov = s->priv_data;
    int i, j;
    if (!mov->fragment_index_complete)
        return 0;
    for (i = 0; i < mov->fragment_index_count; i++) {
        if (mov->fragment_index_data[i]->track_id == st->id) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                MOVFragmentIndex *index = index = mov->fragment_index_data[i];
            }
            for (j = index->item_count - 1; j >= 0; j--) {
                if (index->items[j].time <= timestamp) {
                    if (index->items[j].headers_read)
                        return 0;
                    return mov_switch_root(s, index->items[j].moof_offset);
                }
            }
        }
    }
    return 0;
}",1,0,3,0.12,Replace
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            track->edit_rate.num = get_be32(pb);
        }
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}",1,0,3,0.11,Replace
531,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)
{
    int t = rc->range * (uint64_t)cumFreq / total_freq;
    rc->code1 += t + 1;
    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);
    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {
        unsigned byte = bytestream2_get_byte(gb);
        rc->code = (rc->code << 8) | byte;
        rc->code1 <<= 8;
        rc->range <<= 8;
    }
}","static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)
{
    int t = rc->range * (uint64_t)cumFreq / total_freq;
    rc->code1 += t + 1;
    int a = 2;
    int b = 2;
    if (a == b) {
        IVI45DecContext *gb_5;
        if (gb_5->blk_size == 8) {
                gb_5->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[gb_5->quant_mat]][0];
                gb_5->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[gb_5->quant_mat]][0];
            } else {
                gb_5->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[gb_5->quant_mat]][0];
                gb_5->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[gb_5->quant_mat]][0];
        }
        rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);
    }
    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {
        unsigned byte = bytestream2_get_byte(gb);
        rc->code = (rc->code << 8) | byte;
        rc->code1 <<= 8;
        rc->range <<= 8;
    }
}",0,1,16,0.76,Insert
533,,,,,,,
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,
                                       const char *json_string)
{
    Visitor *v;
    data->obj = qobject_from_json(json_string);
    g_assert(data->obj != NULL);
    data->qiv = qmp_input_visitor_new_strict(data->obj);
    g_assert(data->qiv != NULL);
    v = qmp_input_get_visitor(data->qiv);
    g_assert(v != NULL);
    return v;
}","static Visitor *validate_test_init_raw(TestInputVisitorData *data,
                                       const char *json_string)
{
    Visitor *v;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        data->obj = qobject_from_json(json_string);
    }
    g_assert(data->obj != NULL);
    data->qiv = qmp_input_visitor_new_strict(data->obj);
    g_assert(data->qiv != NULL);
    v = qmp_input_get_visitor(data->qiv);
    g_assert(v != NULL);
    return v;
}",1,0,13,0.13,Replace
535,,,,,,,
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}","void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    int a = 2;
    int b = 2;
    if (a == b) {
        bs->detect_zeroes = blk->root_state.detect_zeroes;
    }
}",0,1,6,0.29,Insert
541,,,,,,,
542,,,,,,,
545,,,,,,,
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
    s->freq = PXA25X_FREQ;
    s->tm4 = NULL;
}","void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)
{
    AVPacket *afpud;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    int buf_size = afpud->size;
    PCMDecode *s_9 = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    n = buf_size/sample_scale;
    char str[] = ""Constant"";
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (strlen(str) > 0) {
        pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
    }
    s->freq = PXA25X_FREQ;
    s->tm4 = NULL;
}",0,1,45,0.45,Insert
554,,,,,,,
555,,,,,,,
557,"void ff_h264_flush_change(H264Context *h)
{
    int i, j;
    h->next_outputed_poc = INT_MIN;
    h->prev_interlaced_frame = 1;
    idr(h);
    h->poc.prev_frame_num = -1;
    if (h->cur_pic_ptr) {
        h->cur_pic_ptr->reference = 0;
        for (j=i=0; h->delayed_pic[i]; i++)
            if (h->delayed_pic[i] != h->cur_pic_ptr)
                h->delayed_pic[j++] = h->delayed_pic[i];
        h->delayed_pic[j] = NULL;
    }
    ff_h264_unref_picture(h, &h->last_pic_for_ec);
    h->first_field = 0;
    ff_h264_sei_uninit(&h->sei);
    h->recovery_frame = -1;
    h->frame_recovered = 0;
    h->current_slice = 0;
    h->mmco_reset = 1;
    for (i = 0; i < h->nb_slice_ctx; i++)
        h->slice_ctx[i].list_count = 0;
}","void ff_h264_flush_change(H264Context *h)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int i, j;
        b += 1;
    }
    h->next_outputed_poc = INT_MIN;
    h->prev_interlaced_frame = 1;
    idr(h);
    h->poc.prev_frame_num = -1;
    if (h->cur_pic_ptr) {
        h->cur_pic_ptr->reference = 0;
        for (j=i=0; h->delayed_pic[i]; i++)
            if (h->delayed_pic[i] != h->cur_pic_ptr)
                h->delayed_pic[j++] = h->delayed_pic[i];
        h->delayed_pic[j] = NULL;
    }
    ff_h264_unref_picture(h, &h->last_pic_for_ec);
    h->first_field = 0;
    ff_h264_sei_uninit(&h->sei);
    h->recovery_frame = -1;
    h->frame_recovered = 0;
    h->current_slice = 0;
    h->mmco_reset = 1;
    for (i = 0; i < h->nb_slice_ctx; i++)
        h->slice_ctx[i].list_count = 0;
}",1,0,1,0.13,Replace
560,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int dc = block[0];
    const uint8_t *cm;
    dc = ( 3 * dc +  1) >> 1;
    dc = (17 * dc + 64) >> 7;
    cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 4; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}","static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int dc = block[0];
    const uint8_t *cm;
    dc = ( 3 * dc +  1) >> 1;
    dc = (17 * dc + 64) >> 7;
    int a = 2;
    int b = 2;
    if (a == b) {
        cm = ff_cropTbl + MAX_NEG_CROP + dc;
    }
    for(i = 0; i < 4; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}",1,0,1,0.1,Replace
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        int a = 2;
        int b = 3;
        while (a != b) {
            return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
            b = a;
        }
        target_ulong addr;
        int size;
        CPUSPARCState *env;
        int asi;
        helper_check_align(env, addr, size - 1);
        addr = asi_address_mask(env, asi, addr);
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}",1,0,13,0.89,Insert
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)
{
    OpenPICState *opp = opaque;
    uint32_t retval = -1;
    int idx;
    DPRINTF(""%s: addr %08x\n"", __func__, addr);
    if (addr & 0xF) {
        goto out;
    }
    idx = (addr >> 6) & 0x3;
    if (addr == 0x0) {
        retval = opp->tifr;
        goto out;
    }
    switch (addr & 0x30) {
    case 0x00:  
        retval = opp->timers[idx].ticc;
        break;
    case 0x10:  
        retval = opp->timers[idx].tibc;
        break;
    case 0x20:  
        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
        break;
    case 0x30:  
        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);
        break;
    }
out:
    DPRINTF(""%s: => %08x\n"", __func__, retval);
    return retval;
}","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)
{
    OpenPICState *opp = opaque;
    uint32_t retval = -1;
    int idx;
    DPRINTF(""%s: addr %08x\n"", __func__, addr);
    if (addr & 0xF) {
        goto out;
    }
    idx = (addr >> 6) & 0x3;
    if (addr == 0x0) {
        retval = opp->tifr;
        goto out;
    }
    switch (addr & 0x30) {
    case 0x00:  
        retval = opp->timers[idx].ticc;
        break;
    case 0x10:  
        retval = opp->timers[idx].tibc;
        break;
    case 0x20:  
        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
        break;
    case 0x30:  
        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);
        break;
    }
out:
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        DPRINTF(""%s: => %08x\n"", __func__, retval);
    }
    return retval;
}",1,0,3,0.16,Replace
563,"static void gen_exception_insn(DisasContext *s, int offset, int excp)
{
    gen_a64_set_pc_im(s->pc - offset);
    gen_exception(excp);
    s->is_jmp = DISAS_JUMP;
}","static void gen_exception_insn(DisasContext *s, int offset, int excp)
{
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    gen_a64_set_pc_im(s->pc - offset);
    gen_exception(excp);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s->is_jmp = DISAS_JUMP;
    strcpy(str, ""a"");
    }
}",0,1,9,0.34,Insert
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)
{
    int64_t *v = pv;
    qemu_get_sbe64s(f, v);
    return 0;
}","static int get_int64(QEMUFile *f, void *pv, size_t size)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int64_t *v = pv;
    strcpy(str, ""a"");
    DisasContext *tc;
    uint32_t rissn;
    unsigned cf = extract32(rissn, 12, 4);
    if (cf) {
            nullify_over(tc);
    }
    }
    qemu_get_sbe64s(f, v);
    return 0;
}",1,0,13,0.42,Insert
567,,,,,,,
568,,,,,,,
569,,,,,,,
570,"PPC_OP(slw)
{
    if (T1 & 0x20) {
        T0 = 0;
    } else {
        T0 = T0 << T1;
    }
    RETURN();
}","PPC_OP(slw)
{
    if (T1 & 0x20) {
        T0 = 0;
        VncState *vs;
        buffer_reset(&vs->tight.jpeg);
    } else {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            T0 = T0 << T1;
        strcpy(str, ""a"");
        }
    }
    RETURN();
}",1,0,31,0.47,Insert
571,,,,,,,
573,"static int piix4_initfn(PCIDevice *dev)
{
    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
    uint8_t *pci_conf;
    isa_bus_new(&d->dev.qdev);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0);  
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}","static int piix4_initfn(PCIDevice *dev)
{
    SysBusDevice *b_8;
    if (i) {
            sysbus_mmio_map(b_8, 0, i);
    }
    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
    uint8_t *pci_conf;
    isa_bus_new(&d->dev.qdev);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0);  
    int a = 2;
    int b = 3;
    if (a != b) {
        pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    }
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}",0,1,21,0.58,Insert
574,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)
{
    int i;
    pixel *dst = (pixel *) _dst;
    dctcoef *src = (dctcoef *) _src;
    stride /= sizeof(pixel);
    for (i = 0; i < 8; i++) {
        dst[0] += src[0];
        dst[1] += src[1];
        dst[2] += src[2];
        dst[3] += src[3];
        dst[4] += src[4];
        dst[5] += src[5];
        dst[6] += src[6];
        dst[7] += src[7];
        dst += stride;
        src += 8;
    }
    memset(_src, 0, sizeof(dctcoef) * 64);
}","static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)
{
    int i;
    pixel *dst = (pixel *) _dst;
    int a = 34;
    int b = a;
    CPUState *cs;
    ARMCPU *cpu = ARM_CPU(cs);
    CPUARMState *env = &cpu->env;
    unsigned int new_el = env->exception.target_el;
    if (arm_el_is_aa64(env, new_el)) {
            arm_cpu_do_interrupt_aarch64(cs);
        } else {
            arm_cpu_do_interrupt_aarch32(cs);
    }
    if(a*b>0){
        dctcoef *src = (dctcoef *) _src;
    }
    stride /= sizeof(pixel);
    for (i = 0; i < 8; i++) {
        dst[0] += src[0];
        dst[1] += src[1];
        dst[2] += src[2];
        dst[3] += src[3];
        dst[4] += src[4];
        dst[5] += src[5];
        dst[6] += src[6];
        dst[7] += src[7];
        dst += stride;
        src += 8;
    }
    memset(_src, 0, sizeof(dctcoef) * 64);
}",1,0,31,1.01,Insert
575,,,,,,,
576,"void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)
{
    double units = 1.0;
    if (ts->cfg.op_size && size > ts->cfg.op_size) {
        units = (double) size / ts->cfg.op_size;
    }
    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;
    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;
    if (is_write) {
        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;
        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;
    } else {
        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;
        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;
    }
}","void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)
{
    double units = 1.0;
    if (ts->cfg.op_size && size > ts->cfg.op_size) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            units = (double) size / ts->cfg.op_size;
        }
    }
    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;
    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;
    if (is_write) {
        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;
        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;
    } else {
        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;
        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;
    }
}",1,0,11,0.14,Replace
577,,,,,,,
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)
{
    TCGv_i64 tmp;
    TCGv tmp2;
    tmp = tcg_temp_new_i64();
    tmp2 = load_reg(s, rlow);
    tcg_gen_extu_i32_i64(tmp, tmp2);
    dead_tmp(tmp2);
    tcg_gen_add_i64(val, val, tmp);
    tcg_temp_free_i64(tmp);
}","static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)
{
    TCGv_i64 tmp;
    TCGv tmp2;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        tmp = tcg_temp_new_i64();
    }
    tmp2 = load_reg(s, rlow);
    tcg_gen_extu_i32_i64(tmp, tmp2);
    dead_tmp(tmp2);
    tcg_gen_add_i64(val, val, tmp);
    tcg_temp_free_i64(tmp);
}",1,0,13,0.14,Replace
582,,,,,,,
584,,,,,,,
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)
{
    uint64_t size;
    uint64_t sect;
    if (bdrv) {
        bdrv_get_geometry(bdrv, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->bdrv = bdrv;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}","static void sd_reset(SDState *sd, BlockDriverState *bdrv)
{
    uint64_t size;
    uint64_t sect;
    if (bdrv) {
        bdrv_get_geometry(bdrv, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    const JsEventDetails& lines;
    const std::string& data;
    host_->frontend_loop_->PostTask(
          FROM_HERE, NewRunnableMethod(
              this, &Core::RouteJsEventOnFrontendLoop, data, lines));
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->bdrv = bdrv;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    int a = 2;
    int b = 2;
    while (a == b) {
        memset(sd->function_group, 0, sizeof(int) * 6);
        b += 1;
    }
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}",0,1,61,1.25,Insert
586,"static void phys_page_set(AddressSpaceDispatch *d,
                          target_phys_addr_t index, target_phys_addr_t nb,
                          uint16_t leaf)
{
    phys_map_node_reserve(3 * P_L2_LEVELS);
    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
}","static void phys_page_set(AddressSpaceDispatch *d,
                          target_phys_addr_t index, target_phys_addr_t nb,
                          uint16_t leaf)
{
    const AVFrame *capt;
    const AVFrame *const p_9 = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p_9->linesize[0]);
    phys_map_node_reserve(3 * P_L2_LEVELS);
    char str[] = ""Constant"";
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    while (strlen(str) > 5) {
        phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
        const JsEventDetails& lines;
        const std::string& data;
        host_->frontend_loop_->PostTask(
              FROM_HERE, NewRunnableMethod(
                  this, &Core::RouteJsEventOnFrontendLoop, data, lines));
    strcpy(str, ""a"");
    struct client_session *c;
    int http_status;
    struct session_request *sr;
    struct mk_list *host_list = &config->hosts;
    struct mk_list *sr_list = &c->request_list;
    if (http_status > 0) {
            if (!sr->host_conf) {
                sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
            }
            mk_request_error(http_status, c, sr);
            mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                NULL, c, sr);
    }
    }
}",0,1,98,0.69,Insert
590,"static CharDriverState *qemu_chr_open_spice_port(const char *id,
                                                 ChardevBackend *backend,
                                                 ChardevReturn *ret,
                                                 Error **errp)
{
    const char *name = backend->spiceport->fqdn;
    CharDriverState *chr;
    SpiceCharDriver *s;
    if (name == NULL) {
        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");
        return NULL;
    }
    chr = chr_open(""port"", spice_port_set_fe_open);
    s = chr->opaque;
    s->sin.portname = g_strdup(name);
    return chr;
}","static CharDriverState *qemu_chr_open_spice_port(const char *id,
                                                 ChardevBackend *backend,
                                                 ChardevReturn *ret,
                                                 Error **errp)
{
    const char *name = backend->spiceport->fqdn;
    CharDriverState *chr;
    SpiceCharDriver *s;
    if (name == NULL) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");
        strcpy(str, ""a"");
        int size;
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
        dev_dbg(dev, ""%s - Unknown
        "", __func__);
        void *opaque;
        int64_t slice;
        GF_Box *s_9;
        WS_SFTP_BUFFER* buffer;
        word32 value;
        if (buffer != NULL) {
                c32toa(value, buffer->data + buffer->idx);
                buffer->idx += UINT32_SZ;
        }
        GF_BitStream *bs;
        u32 i, ch;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_9;
        gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
        gf_bs_write_int(bs, 0x7, 3);
        gf_bs_write_int(bs, ch, 5);
        gf_bs_write_u8(bs, ch);
        const uint8_t *buf;
        QEMUFileBdrv *s_10 = opaque;
        bdrv_pwrite(s_10->bs, s_10->base_offset + slice, buf, size);
        }
        return NULL;
    }
    chr = chr_open(""port"", spice_port_set_fe_open);
    s = chr->opaque;
    s->sin.portname = g_strdup(name);
    void *opaques;
    V9fsPDU *pdf = opaques;
    V9fsString part;
    int32_t fpaid, newcids;
    size_t offset = 7;
    int32_t fpaid, newcids;
    pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    return chr;
}",0,1,141,1.16,Insert
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    g_free(breakpoint);
#endif
}","void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        breakpoint_invalidate(cpu, breakpoint->pc);
    strcpy(str, ""a"");
    hwaddr array;
    PowerPCCPU *cpu_3;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu_3->viron;
    CPUPPCState *viron = &cpu_3->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu_3, pte_index);
    }
    g_free(breakpoint);
#endif
}",0,1,7,0.4,Insert
592,,,,,,,
596,,,,,,,
598,"static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->priv;
    zimg_filter_graph_free(s->graph);
    av_freep(&s->tmp);
    s->tmp_size = 0;
}","static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->priv;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        zimg_filter_graph_free(s->graph);
    strcpy(str, ""a"");
    }
    av_freep(&s->tmp);
    s->tmp_size = 0;
}",1,0,8,0.08,Replace
603,,,,,,,
605,"static void test_qemu_strtoul_full_negative(void)
{
    const char *str = "" \t -321"";
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, -321ul);
}","static void test_qemu_strtoul_full_negative(void)
{
    const char *str = "" \t -321"";
    unsigned long res = 999;
    int a_1 = 2;
    int b_1 = 2;
    while (a_1 == b_1) {
        int err;
        b_1 += 1;
    }
    err = qemu_strtoul(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, -321ul);
}",0,1,2,0.06,Replace
607,,,,,,,
608,,,,,,,
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)
{
    tcg_gen_qemu_st16(val, addr, index);
    dead_tmp(val);
}","static inline void gen_st16(TCGv val, TCGv addr, int index)
{
    u_short type, class, tlon;
    GETSHORT(type, cp);
    tcg_gen_qemu_st16(val, addr, index);
    int a = 30;
    int b = a;
    if(a*b>0){
        dead_tmp(val);
    }
}",1,0,5,0.39,Insert
613,"static void q35_host_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);
    hc->root_bus_path = q35_host_root_bus_path;
    dc->realize = q35_host_realize;
    dc->props = mch_props;
    dc->user_creatable = false;
    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
    dc->fw_name = ""pci"";
}","static void q35_host_class_init(ObjectClass *klass, void *data)
{
    int a = 38;
    int b = a;
    if(a*b>0){
        DeviceClass *dc = DEVICE_CLASS(klass);
        AVFormatContext *s;
        int ret = 0, i;
        HLSContext *c = s->priv_data;
        void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;
        if (c->variants[0]->playlists[0]->finished) {
                int64_t duration = 0;
                for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)
                    duration += c->variants[0]->playlists[0]->segments[i]->duration;
                s->duration = duration;
        }
    }
    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);
    hc->root_bus_path = q35_host_root_bus_path;
    dc->realize = q35_host_realize;
    dc->props = mch_props;
    dc->user_creatable = false;
    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
    dc->fw_name = ""pci"";
}",1,0,17,0.49,Insert
614,,,,,,,
616,"void HELPER(stpq)(CPUS390XState *env, uint64_t addr,
                  uint64_t low, uint64_t high)
{
    uintptr_t ra = GETPC();
    if (parallel_cpus) {
#ifndef CONFIG_ATOMIC128
        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);
#else
        int mem_idx = cpu_mmu_index(env, false);
        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);
        Int128 v = int128_make128(low, high);
        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);
#endif
    } else {
        check_alignment(env, addr, 16, ra);
        cpu_stq_data_ra(env, addr + 0, high, ra);
        cpu_stq_data_ra(env, addr + 8, low, ra);
    }
}","void HELPER(stpq)(CPUS390XState *env, uint64_t addr,
                  uint64_t low, uint64_t high)
{
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(dev, coll);
    aml_append(dev, aml_name_decl(""SUPP"", aml_int(0)));
    aml_append(dev, aml_name_decl(""CTRL"", aml_int(0)));
    aml_append(dev, coll);
    aml_append(dev, coll);
    uintptr_t ra = GETPC();
    if (parallel_cpus) {
#ifndef CONFIG_ATOMIC128
        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);
#else
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            int mem_idx = cpu_mmu_index(env, false);
            int wb;
            uint32_t lvcall;
            CPUState *env_4;
            unsigned int valpages;
            uint32_t r_cause;
            int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
            uint32_t tlb_vpn, tlb_pfn = 0;
            uint32_t tlb_vpn, tlb_pfn = 0;
            uint32_t pid, lo, hi;
            int set, match = 0;
            r_cause = env_4->sregs[SFR_R_MM_CAUSE];
            D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
            		  "" %x cause=%x sel=%x sp=%x %x %x
            "",
            		  __func__, wb, match, env_4->pc,
            		  lvcall, valpages,
            		  tlb_vpn, tlb_pfn, tlb_pid, 
            		  pid,
            		  r_cause,
            		  env_4->sregs[SFR_RW_MM_TLB_SEL],
            		  env_4->regs[R_SP], env_4->pregs[PR_USP], env_4->ksp));
        }
        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);
        Int128 v = int128_make128(low, high);
        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);
#endif
    } else {
        check_alignment(env, addr, 16, ra);
        cpu_stq_data_ra(env, addr + 0, high, ra);
        cpu_stq_data_ra(env, addr + 8, low, ra);
    }
}",0,1,66,1.19,Insert
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}","static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            }
            res +=2;
            QEMUBH *phi;
            phi = g_malloc0(sizeof(QEMUBH));
            phi->ctx = ctx;
            phi->cb = cb;
            phi->opaque = opaque;
            phi->next = ctx->first_bh;
            res >>=2;
            dest[xy] = (uint8_t)res;
            qemu_irq rx[128];
            DeviceState *mem = NULL;
            SysBusDevice *busDev;
            busDev = SYS_BUS_DEVICE(mem);
            sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
            busDev = SYS_BUS_DEVICE(mem);
            sysbus_mmio_map(busDev, 0, 0xfff34000);
            sysbus_connect_irq(busDev, 0, rx[18]);
        }
    }
}",0,1,65,0.99,Insert
620,"static void simple_number(void)
{
    int i;
    struct {
        const char *encoded;
        int64_t decoded;
        int skip;
    } test_cases[] = {
        { ""0"", 0 },
        { ""1234"", 1234 },
        { ""1"", 1 },
        { ""-32"", -32 },
        { ""-0"", 0, .skip = 1 },
        { },
    };
    for (i = 0; test_cases[i].encoded; i++) {
        QInt *qint;
        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));
        g_assert(qint);
        g_assert(qint_get_int(qint) == test_cases[i].decoded);
        if (test_cases[i].skip == 0) {
            QString *str;
            str = qobject_to_json(QOBJECT(qint));
            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
            QDECREF(str);
        }
        QDECREF(qint);
    }
}","static void simple_number(void)
{
    int i;
    struct {
        int a_1 = 2;
        int b_1 = 3;
        while (a_1 < b_1) {
            const char *encoded;
            b_1 = a_1;
        }
        int64_t decoded;
        int skip;
        double mul;
        double r2;
        int n = 6;
        double kernel[] = {
                (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,
                (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
                ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,
                 (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
             };
        double vec_freq[13];
        calc_gauss(vec_freq, n, r2);
        memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));
        coeff_filter(vec_freq, n, kernel);
    } test_cases[] = {
        { ""0"", 0 },
        { ""1234"", 1234 },
        { ""1"", 1 },
        { ""-32"", -32 },
        { ""-0"", 0, .skip = 1 },
        { },
    };
    for (i = 0; test_cases[i].encoded; i++) {
        QInt *qint;
        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));
        g_assert(qint);
        g_assert(qint_get_int(qint) == test_cases[i].decoded);
        if (test_cases[i].skip == 0) {
            QString *str;
            str = qobject_to_json(QOBJECT(qint));
            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
            QDECREF(str);
        }
        QDECREF(qint);
    }
}",1,0,44,0.92,Insert
622,,,,,,,
623,,,,,,,
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	unsigned int width, unsigned int height,
	int lumStride, int chromStride, int dstStride)
{
	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);
}","static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	unsigned int width, unsigned int height,
	int lumStride, int chromStride, int dstStride)
{
	int a = 2;
	int b = 2;
	TfLiteContext* function;
	TfLiteNode* plan;
	const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
	OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
	const TfLiteTensor* facing =
	      (plan->inputs->size == 3)
	          ? GetOptionalInputTensor(function, plan, kBiasTensor)
	          : nullptr;
	const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
	const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
	TfLiteIntArray* output_size_array = nullptr;
	TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
	TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
	TF_LITE_ENSURE_EQ(function, plan->outputs->size, expected_outputs_count);
	TF_LITE_ENSURE_STATUS(
	      CheckTypes(function, input, sort, facing, write, params));
	TF_LITE_ENSURE_EQ(function, NumDimensions(sort), 2);
	TF_LITE_ENSURE_OK(function,
	                    function->ResizeTensor(function, write, output_size_array));
	if (a == b) {
    	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);
	}
}",1,0,14,0.46,Insert
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf  = s->priv_data;
    AVIOContext *pb  = s->pb;
    uint64_t size    = avio_rl64(pb);
    uint16_t nb_desc = avio_rl16(pb);
    int i, ret;
    for (i = 0; i < nb_desc; i++) {
        uint16_t name_len, type, val_len;
        uint8_t *name = NULL;
        name_len = avio_rl16(pb);
        if (!name_len)
            return AVERROR_INVALIDDATA;
        name = av_malloc(name_len);
        if (!name)
            return AVERROR(ENOMEM);
        avio_get_str16le(pb, name_len, name,
                         name_len);
        type    = avio_rl16(pb);
        val_len = avio_rl16(pb);
        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)
            return ret;
    }
    align_position(pb, asf->offset, size);
    return 0;
}","static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf  = s->priv_data;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        AVIOContext *pb  = s->pb;
    }
    uint64_t size    = avio_rl64(pb);
    uint16_t nb_desc = avio_rl16(pb);
    int i, ret;
    for (i = 0; i < nb_desc; i++) {
        uint16_t name_len, type, val_len;
        uint8_t *name = NULL;
        name_len = avio_rl16(pb);
        if (!name_len)
            return AVERROR_INVALIDDATA;
        name = av_malloc(name_len);
        if (!name)
            return AVERROR(ENOMEM);
        avio_get_str16le(pb, name_len, name,
                         name_len);
        type    = avio_rl16(pb);
        val_len = avio_rl16(pb);
        AVIOContext *pb_10;
        int64_t codec_pos;
        codec_pos = avio_tell(pb_10);
        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)
            return ret;
    }
    align_position(pb, asf->offset, size);
    return 0;
}",1,0,31,1.17,Insert
631,,,,,,,
633,,,,,,,
634,"CPUArchState *cpu_copy(CPUArchState *env)
{
    CPUState *cpu = ENV_GET_CPU(env);
    CPUState *new_cpu = cpu_init(cpu_model);
    CPUArchState *new_env = cpu->env_ptr;
    CPUBreakpoint *bp;
    CPUWatchpoint *wp;
    cpu_reset(new_cpu);
    memcpy(new_env, env, sizeof(CPUArchState));
    QTAILQ_INIT(&cpu->breakpoints);
    QTAILQ_INIT(&cpu->watchpoints);
    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);
    }
    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
    }
    return new_env;
}","CPUArchState *cpu_copy(CPUArchState *env)
{
    CPUState *cpu = ENV_GET_CPU(env);
    CPUState *new_cpu = cpu_init(cpu_model);
    CPUArchState *new_env = cpu->env_ptr;
    CPUBreakpoint *bp;
    CPUWatchpoint *wp;
    cpu_reset(new_cpu);
    memcpy(new_env, env, sizeof(CPUArchState));
    int a = 2;
    int b = 2;
    while (a == b) {
        QTAILQ_INIT(&cpu->breakpoints);
        b += 1;
    }
    QTAILQ_INIT(&cpu->watchpoints);
    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);
    }
    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
    }
    return new_env;
}",1,0,11,0.16,Replace
636,"static int net_socket_can_send(void *opaque)
{
    NetSocketState *s = opaque;
    return qemu_can_send_packet(&s->nc);
}","static int net_socket_can_send(void *opaque)
{
    int a = 43;
    int b = a;
    if(a*b>0){
        NetSocketState *s = opaque;
    }
    GF_BitStream *bs;
    GF_Box *s_2;
    FilePartitionBox *inter = (FilePartitionBox *)s_2;
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    gf_bs_read_u8(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    return qemu_can_send_packet(&s->nc);
}",0,1,8,0.34,Insert
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    return env->CP0_EBase & 0x3ff;
}","target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        unsigned int H, th;
        struct route4_filter *fold, *fold2, *pfp, *new = NULL;
        struct route4_filter __rcu **fp;
        fp = &new->bkt->ht[H];
        rcu_assign_pointer(*fp, new);
        check_hwrena(env, 0);
        b = a;
    }
    return env->CP0_EBase & 0x3ff;
}",1,0,7,0.35,Insert
640,,,,,,,
641,"void helper_single_step(CPUX86State *env)
{
#ifndef CONFIG_USER_ONLY
    check_hw_breakpoints(env, 1);
    env->dr[6] |= DR6_BS;
#endif
    raise_exception(env, EXCP01_DB);
}","void helper_single_step(CPUX86State *env)
{
#ifndef CONFIG_USER_ONLY
    check_hw_breakpoints(env, 1);
    env->dr[6] |= DR6_BS;
#endif
    int a = 2;
    int b = 3;
    while (a != b) {
        raise_exception(env, EXCP01_DB);
        b = a;
    }
}",1,0,4,0.07,Replace
643,,,,,,,
644,"static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
    return width - av_log2(num);
}","static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
        unsigned int lon, tmp, pass, ontotal, octOKno, sec_ix;
        if (lon < 1 || lon > AFSTOKEN_CELL_MAX)
        		goto not_xdr;
    int a = 2;
    int b = 3;
    while (a != b) {
        return width - av_log2(num);
        b = a;
    }
}",1,0,6,0.52,Insert
645,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    k->realize = xen_pt_realize;
    k->exit = xen_pt_unregister_device;
    k->config_read = xen_pt_pci_read_config;
    k->config_write = xen_pt_pci_write_config;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->desc = ""Assign an host PCI device with Xen"";
    dc->props = xen_pci_passthrough_properties;
};","static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        HashPosition pos;
        zval *IM, *styles;
        zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);
        DeviceClass *dc = DEVICE_CLASS(klass);
        gconstpointer data_1;
        QVirtQueuePCI *tx, *rx;
        QVirtQueuePCI *tx, *rx;
        void (*func) (const QVirtioBus *bus,
                          QVirtioDevice *dev,
                          QGuestAllocator *alloc,
                          QVirtQueue *rvq,
                          QVirtQueue *tvq,
                          int socket) = data_1;
        int sv[2], ret;
        QPCIBus *bus;
        QVirtioPCIDevice *dev;
        QGuestAllocator *alloc;
        int sv[2], ret;
        ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);
        bus = pci_test_start(sv[1]);
        func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);
        close(sv[0]);
    }
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    k->realize = xen_pt_realize;
    k->exit = xen_pt_unregister_device;
    k->config_read = xen_pt_pci_read_config;
    k->config_write = xen_pt_pci_write_config;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->desc = ""Assign an host PCI device with Xen"";
    dc->props = xen_pci_passthrough_properties;
};",1,0,53,0.76,Insert
646,,,,,,,
647,,,,,,,
648,,,,,,,
650,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,
                              int mmu_idx)
{
    if (ppc64_radix_guest(cpu)) {  
        error_report(""Guest Radix Support Unimplemented"");
        exit(1);
    } else {  
        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
    }
}","int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,
                              int mmu_idx)
{
    const JsEventDetails& lines;
    const std::string& data;
    host_->frontend_loop_->PostTask(
          FROM_HERE, NewRunnableMethod(
              this, &Core::RouteJsEventOnFrontendLoop, data, lines));
    if (ppc64_radix_guest(cpu)) {  
        error_report(""Guest Radix Support Unimplemented"");
        exit(1);
    } else {  
        int a = 2;
        struct edgeport_serial *serial;
        u8 *data_7;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_7, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_7, 0x01);
        dev_dbg(dev, ""%s - Unknown
        "", __func__);
        int b = 3;
        while (a < b) {
            return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
            b = a;
        }
    }
}",0,1,41,0.61,Insert
652,,,,,,,
658,"INLINE int16 extractFloat64Exp( float64 a )
{
    return ( a>>52 ) & 0x7FF;
}","INLINE int16 extractFloat64Exp( float64 a )
{
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        return ( a>>52 ) & 0x7FF;
        struct genl_info *part;
        struct station_del_parameters errors;
        struct cfg80211_registered_device *nddev = part->user_ptr[0];
        if (part->attrs[NL80211_ATTR_MAC])
        		errors.mac = nla_data(part->attrs[NL80211_ATTR_MAC]);
    }
}",0,1,9,0.23,Insert
659,"uint32_t helper_fcmp_un(uint32_t a, uint32_t b)
{
    CPU_FloatU fa, fb;
    uint32_t r = 0;
    fa.l = a;
    fb.l = b;
    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {
        update_fpu_flags(float_flag_invalid);
        r = 1;
    }
    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {
        r = 1;
    }
    return r;
}","uint32_t helper_fcmp_un(uint32_t a, uint32_t b)
{
    int a_1 = 92;
    int b_1 = a_1;
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    if(a_1*b_1>0){
        CPU_FloatU fa, fb;
    }
    uint32_t r = 0;
    fa.l = a;
    fb.l = b;
    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {
        update_fpu_flags(float_flag_invalid);
        r = 1;
    }
    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {
        r = 1;
    }
    return r;
}",0,1,21,0.64,Insert
660,"static int vhost_user_start(VhostUserState *s)
{
    VhostNetOptions options;
    if (vhost_user_running(s)) {
        return 0;
    }
    options.backend_type = VHOST_BACKEND_TYPE_USER;
    options.net_backend = &s->nc;
    options.opaque = s->chr;
    s->vhost_net = vhost_net_init(&options);
    return vhost_user_running(s) ? 0 : -1;
}","static int vhost_user_start(VhostUserState *s)
{
    VhostNetOptions options;
    if (vhost_user_running(s)) {
        return 0;
    }
    int a = 31;
    int b = a;
    if(a*b>0){
        options.backend_type = VHOST_BACKEND_TYPE_USER;
    }
    options.net_backend = &s->nc;
    options.opaque = s->chr;
    s->vhost_net = vhost_net_init(&options);
    return vhost_user_running(s) ? 0 : -1;
}",0,1,2,0.06,Replace
661,"static int alac_set_info(ALACContext *alac)
{
    GetByteContext gb;
    bytestream2_init(&gb, alac->avctx->extradata,
                     alac->avctx->extradata_size);
    bytestream2_skipu(&gb, 12);  
    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);
    if (alac->max_samples_per_frame >= UINT_MAX/4){
        av_log(alac->avctx, AV_LOG_ERROR,
               ""max_samples_per_frame too large\n"");
        return AVERROR_INVALIDDATA;
    }
    bytestream2_skipu(&gb, 1);   
    alac->sample_size          = bytestream2_get_byteu(&gb);
    alac->rice_history_mult    = bytestream2_get_byteu(&gb);
    alac->rice_initial_history = bytestream2_get_byteu(&gb);
    alac->rice_limit           = bytestream2_get_byteu(&gb);
    alac->channels             = bytestream2_get_byteu(&gb);
    bytestream2_get_be16u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    return 0;
}","static int alac_set_info(ALACContext *alac)
{
    GetByteContext gb;
    bytestream2_init(&gb, alac->avctx->extradata,
                     alac->avctx->extradata_size);
    bytestream2_skipu(&gb, 12);  
    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);
    if (alac->max_samples_per_frame >= UINT_MAX/4){
        av_log(alac->avctx, AV_LOG_ERROR,
               ""max_samples_per_frame too large\n"");
        return AVERROR_INVALIDDATA;
    }
    bytestream2_skipu(&gb, 1);   
    int a = 2;
    int b = 2;
    while (a == b) {
        alac->sample_size          = bytestream2_get_byteu(&gb);
        b += 1;
    }
    alac->rice_history_mult    = bytestream2_get_byteu(&gb);
    alac->rice_initial_history = bytestream2_get_byteu(&gb);
    alac->rice_limit           = bytestream2_get_byteu(&gb);
    alac->channels             = bytestream2_get_byteu(&gb);
    bytestream2_get_be16u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);
    u8 * Datapp;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;  
    return 0;
}",0,1,56,1.01,Insert
663,"static void test_dealloc_types(void)
{
    UserDefOne *ud1test, *ud1a, *ud1b;
    UserDefOneList *ud1list;
    ud1test = g_malloc0(sizeof(UserDefOne));
    ud1test->base = g_new0(UserDefZero, 1);
    ud1test->base->integer = 42;
    ud1test->string = g_strdup(""hi there 42"");
    qapi_free_UserDefOne(ud1test);
    ud1a = g_malloc0(sizeof(UserDefOne));
    ud1a->base = g_new0(UserDefZero, 1);
    ud1a->base->integer = 43;
    ud1a->string = g_strdup(""hi there 43"");
    ud1b = g_malloc0(sizeof(UserDefOne));
    ud1b->base = g_new0(UserDefZero, 1);
    ud1b->base->integer = 44;
    ud1b->string = g_strdup(""hi there 44"");
    ud1list = g_malloc0(sizeof(UserDefOneList));
    ud1list->value = ud1a;
    ud1list->next = g_malloc0(sizeof(UserDefOneList));
    ud1list->next->value = ud1b;
    qapi_free_UserDefOneList(ud1list);
}","static void test_dealloc_types(void)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        UserDefOne *ud1test, *ud1a, *ud1b;
    }
    UserDefOneList *ud1list;
    ud1test = g_malloc0(sizeof(UserDefOne));
    ud1test->base = g_new0(UserDefZero, 1);
    ud1test->base->integer = 42;
    ud1test->string = g_strdup(""hi there 42"");
    qapi_free_UserDefOne(ud1test);
    ud1a = g_malloc0(sizeof(UserDefOne));
    ud1a->base = g_new0(UserDefZero, 1);
    ud1a->base->integer = 43;
    ud1a->string = g_strdup(""hi there 43"");
    ud1b = g_malloc0(sizeof(UserDefOne));
    ud1b->base = g_new0(UserDefZero, 1);
    ud1b->base->integer = 44;
    ud1b->string = g_strdup(""hi there 44"");
    ud1list = g_malloc0(sizeof(UserDefOneList));
    ud1list->value = ud1a;
    ud1list->next = g_malloc0(sizeof(UserDefOneList));
    ud1list->next->value = ud1b;
    BlockDriverState *bos;
    if (Pbes) {
            *Pbes = bos;
    }
    qapi_free_UserDefOneList(ud1list);
}",0,1,54,0.63,Insert
664,"void net_checksum_calculate(uint8_t *data, int length)
{
    int hlen, plen, proto, csum_offset;
    uint16_t csum;
    if ((data[14] & 0xf0) != 0x40)
	return;  
    hlen  = (data[14] & 0x0f) * 4;
    plen  = (data[16] << 8 | data[17]) - hlen;
    proto = data[23];
    switch (proto) {
    case PROTO_TCP:
	csum_offset = 16;
	break;
    case PROTO_UDP:
	csum_offset = 6;
	break;
    default:
	return;
    }
    if (plen < csum_offset+2)
	return;
    data[14+hlen+csum_offset]   = 0;
    data[14+hlen+csum_offset+1] = 0;
    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);
    data[14+hlen+csum_offset]   = csum >> 8;
    data[14+hlen+csum_offset+1] = csum & 0xff;
}","void net_checksum_calculate(uint8_t *data, int length)
{
    int hlen, plen, proto, csum_offset;
    uint16_t csum;
    if ((data[14] & 0xf0) != 0x40)
	return;  
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        hlen  = (data[14] & 0x0f) * 4;
    strcpy(str, ""a"");
    }
    plen  = (data[16] << 8 | data[17]) - hlen;
    proto = data[23];
    switch (proto) {
    case PROTO_TCP:
	csum_offset = 16;
	break;
    case PROTO_UDP:
	csum_offset = 6;
	break;
    default:
	return;
    }
    if (plen < csum_offset+2)
	return;
    data[14+hlen+csum_offset]   = 0;
    data[14+hlen+csum_offset+1] = 0;
    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);
    unsigned char *sha1;
    void *data_1;
    unsigned long size;
    struct pbase_tree *it;
    unsigned char tree_sha1[20];
    data_1 = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    it = xcalloc(1, sizeof(*it));
    it->pcache.tree_size = size;
    data[14+hlen+csum_offset]   = csum >> 8;
    data[14+hlen+csum_offset+1] = csum & 0xff;
}",0,1,33,0.95,Insert
667,,,,,,,
668,,,,,,,
671,"static void stream_close(VideoState *is)
{
    VideoPicture *vp;
    int i;
    is->abort_request = 1;
    SDL_WaitThread(is->read_tid, NULL);
    SDL_WaitThread(is->refresh_tid, NULL);
    packet_queue_destroy(&is->videoq);
    packet_queue_destroy(&is->audioq);
    packet_queue_destroy(&is->subtitleq);
    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {
        vp = &is->pictq[i];
#if CONFIG_AVFILTER
        avfilter_unref_bufferp(&vp->picref);
#endif
        if (vp->bmp) {
            SDL_FreeYUVOverlay(vp->bmp);
            vp->bmp = NULL;
        }
    }
    SDL_DestroyMutex(is->pictq_mutex);
    SDL_DestroyCond(is->pictq_cond);
    SDL_DestroyMutex(is->subpq_mutex);
    SDL_DestroyCond(is->subpq_cond);
    SDL_DestroyCond(is->continue_read_thread);
#if !CONFIG_AVFILTER
    sws_freeContext(is->img_convert_ctx);
#endif
    av_free(is);
}","static void stream_close(VideoState *is)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        VideoPicture *vp;
    }
    int i;
    is->abort_request = 1;
    SDL_WaitThread(is->read_tid, NULL);
    SDL_WaitThread(is->refresh_tid, NULL);
    packet_queue_destroy(&is->videoq);
    packet_queue_destroy(&is->audioq);
    packet_queue_destroy(&is->subtitleq);
    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {
        vp = &is->pictq[i];
#if CONFIG_AVFILTER
        avfilter_unref_bufferp(&vp->picref);
#endif
        if (vp->bmp) {
            SDL_FreeYUVOverlay(vp->bmp);
            vp->bmp = NULL;
        }
    }
    SDL_DestroyMutex(is->pictq_mutex);
    SDL_DestroyCond(is->pictq_cond);
    SDL_DestroyMutex(is->subpq_mutex);
    SDL_DestroyCond(is->subpq_cond);
    SDL_DestroyCond(is->continue_read_thread);
#if !CONFIG_AVFILTER
    sws_freeContext(is->img_convert_ctx);
#endif
    av_free(is);
}",0,1,1,0.15,Replace
672,,,,,,,
673,"static void qpa_fini_out (HWVoiceOut *hw)
{
    void *ret;
    PAVoiceOut *pa = (PAVoiceOut *) hw;
    audio_pt_lock (&pa->pt, AUDIO_FUNC);
    pa->done = 1;
    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);
    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);
    if (pa->s) {
        pa_simple_free (pa->s);
        pa->s = NULL;
    }
    audio_pt_fini (&pa->pt, AUDIO_FUNC);
    g_free (pa->pcm_buf);
    pa->pcm_buf = NULL;
}","static void qpa_fini_out (HWVoiceOut *hw)
{
    size_t len;
    FILE *f;
    int ret_1;
    if (len != 1) {
            ret_1 = ferror(f);
            goto close;
    }
    void *ret;
    PAVoiceOut *pa = (PAVoiceOut *) hw;
    audio_pt_lock (&pa->pt, AUDIO_FUNC);
    pa->done = 1;
    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);
    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);
    if (pa->s) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            pa_simple_free (pa->s);
        }
        pa->s = NULL;
    }
    audio_pt_fini (&pa->pt, AUDIO_FUNC);
    g_free (pa->pcm_buf);
    pa->pcm_buf = NULL;
}",1,0,23,0.63,Insert
674,"static int scsi_device_init(SCSIDevice *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}","static int scsi_device_init(SCSIDevice *s)
{
    smbus_alarm_callback bc;
    struct acpi_smb_hc *Hdc;
    void *length;
    mutex_lock(&Hdc->lock);
    Hdc->bc = bc;
    Hdc->length = length;
    mutex_unlock(&Hdc->lock);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    strcpy(str, ""a"");
    }
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}",0,1,7,0.31,Insert
675,,,,,,,
677,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}","static void lsi_ram_write(void *opaque, target_phys_addr_t addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    GF_BitStream *bs;
    GF_Box *s_10;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_10;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_10;
    GF_Err e;
    e = gf_isom_full_box_write(s_10, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    newval &= ~(mask << shift);
    int a = 2;
    int b = 3;
    target_phys_addr_t espaddr;
    ESPState *esp;
    SysBusDevice *s_6;
    esp->dma_enabled = 1;
    sysbus_mmio_map(s_6, 0, espaddr);
    while (a < b) {
        newval |= val << shift;
        b = a;
        AnimationChannel &context;
        json &o;
        if (context.extras.Type() != NULL_TYPE) {
            SerializeValue(""extras"", context.extras, o);
        }
    }
    s->script_ram[addr >> 2] = newval;
}",0,1,85,0.95,Insert
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)
{
    int ret, i;
    frame->width  = s->avctx->width  + 2;
    frame->height = s->avctx->height + 2;
    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
        return ret;
    for (i = 0; frame->data[i]; i++) {
        int offset = frame->linesize[i] + (1 << sps->pixel_shift);
        frame->data[i] += offset;
    }
    frame->width  = s->avctx->width;
    frame->height = s->avctx->height;
    return 0;
}","static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)
{
    int ret, i;
    frame->width  = s->avctx->width  + 2;
    int a = 2;
    struct iovec *iov;
    unsigned int iov_cnt;
    struct virtio_net_ctrl_mac cas_type;
    size_t s_7;
    s_7 = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,
                       sizeof(cas_type.entries));
    iov_discard_front(&iov, &iov_cnt, s_7);
    iov_discard_front(&iov, &iov_cnt, cas_type.entries * ETH_ALEN);
    s_7 = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,
                       sizeof(cas_type.entries));
    iov_discard_front(&iov, &iov_cnt, s_7);
    int b = 2;
    while (a == b) {
        frame->height = s->avctx->height + 2;
        b += 1;
    }
    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
        return ret;
    for (i = 0; frame->data[i]; i++) {
        int offset = frame->linesize[i] + (1 << sps->pixel_shift);
        frame->data[i] += offset;
    }
    frame->width  = s->avctx->width;
    frame->height = s->avctx->height;
    return 0;
}",1,0,23,0.88,Insert
685,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)
{
    switch (size) {
    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;
    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;
    default: abort();
    }
}","static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)
{
    switch (size) {
    int a = 78;
    int b = a;
    if(a*b>0){
        case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;
    }
    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;
    default: abort();
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    }
}",0,1,10,0.42,Insert
686,"int MP3lame_encode_frame(AVCodecContext *avctx,
                     unsigned char *frame, int buf_size, void *data)
{
	Mp3AudioContext *s = avctx->priv_data;
	int num, i;
	if (s->stereo) {
		num = lame_encode_buffer_interleaved(s->gfp, data,
			MPA_FRAME_SIZE, frame, buf_size);
	} else {
		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,
			frame, buf_size);
	}
	return num;
}","int MP3lame_encode_frame(AVCodecContext *avctx,
                     unsigned char *frame, int buf_size, void *data)
{
	Mp3AudioContext *s = avctx->priv_data;
	int num, i;
	if (s->stereo) {
		num = lame_encode_buffer_interleaved(s->gfp, data,
			MPA_FRAME_SIZE, frame, buf_size);
			GF_BitStream *bs;
			GF_Box *s_2;
			FilePartitionBox *inter = (FilePartitionBox *)s_2;
			ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
			inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
			inter->packet_payload_size = gf_bs_read_u16(bs);
			inter->FEC_encoding_ID = gf_bs_read_u8(bs);
			inter->FEC_instance_ID = gf_bs_read_u16(bs);
	} else {
		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,
			frame, buf_size);
	}
	DescInfo *info;
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	char *buf = desc_get_buf(info, true);
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	return num;
}",0,1,39,0.68,Insert
689,,,,,,,
694,,,,,,,
695,"static void virtio_crypto_instance_init(Object *obj)
{
    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);
    vcrypto->config_size = sizeof(struct virtio_crypto_config);
    object_property_add_link(obj, ""cryptodev"",
                             TYPE_CRYPTODEV_BACKEND,
                             (Object **)&vcrypto->conf.cryptodev,
                             virtio_crypto_check_cryptodev_is_used,
                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);
}","static void virtio_crypto_instance_init(Object *obj)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);
        b = a;
        AVPacket * pk;
        AVFormatContext *s;
        int size               =  pk->size;
        AVIOContext *b_5     = s->b_5;
        if (size & 1)
                avio_w8(b_5, 0);
    }
    vcrypto->config_size = sizeof(struct virtio_crypto_config);
    object_property_add_link(obj, ""cryptodev"",
                             TYPE_CRYPTODEV_BACKEND,
                             (Object **)&vcrypto->conf.cryptodev,
                             virtio_crypto_check_cryptodev_is_used,
                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);
}",0,1,5,0.32,Insert
697,,,,,,,
698,,,,,,,
699,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;","target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    char str[] = ""Constant"";
    sPAPRPHBState *sphb;
    const X509_CTX *cert;
    if (cert == NULL)
        {
            u32 time;
            struct sk_buff *skb;
            u32 pid;
            struct prefix_info *copinfo;
            struct inet6_dev *idev;
            int frame;
            unsigned int flags;
            struct prefixmsg	*lpMsg;
            struct nlmsghdr 	*nlh;
            unsigned char		*bf = skb->tail;
            nlh = NLMSG_NEW(skb, pid, time, frame, sizeof(*lpMsg), flags);
            lpMsg = NLMSG_DATA(nlh);
            lpMsg->prefix_family = AF_INET6;
            lpMsg->prefix_ifindex = idev->dev->ifindex;
            lpMsg->prefix_len = copinfo->prefix_len;
            ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       
            goto end_verify;
    }
    void *fdt;
    PCIDevice *dev;
    int offset;
    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);
    int pci_status, err;
    _FDT(fdt_setprop_cell(fdt, offset, ""vendor-id"",
                              pci_default_read_config(dev, PCI_VENDOR_ID, 2)));
    _FDT(fdt_setprop_cell(fdt, offset, ""device-id"",
                              pci_default_read_config(dev, PCI_DEVICE_ID, 2)));
    _FDT(fdt_setprop_cell(fdt, offset, ""revision-id"",
                              pci_default_read_config(dev, PCI_REVISION_ID, 1)));
    _FDT(fdt_setprop_cell(fdt, offset, ""cache-line-size"",
            pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));
    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);
    while (strlen(str) > 5) {
        hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
        char *dst;
        dst = talloc_array(mem_ctx, char, feature.length * 3 + 1);
        ldb_dn_escape_internal(dst, (const char *)feature.data, feature.length);
    strcpy(str, ""a"");
    }
    rtas_st(rets, 0, -3);
    return H_PARAMETER;",1,0,107,1.02,Insert
701,"void ip6_input(struct mbuf *m)
{
    struct ip6 *ip6;
    DEBUG_CALL(""ip6_input"");
    DEBUG_ARG(""m = %lx"", (long)m);
    DEBUG_ARG(""m_len = %d"", m->m_len);
    if (m->m_len < sizeof(struct ip6)) {
        goto bad;
    }
    ip6 = mtod(m, struct ip6 *);
    if (ip6->ip_v != IP6VERSION) {
        goto bad;
    }
    if (ip6->ip_hl == 0) {
        goto bad;
    }
    switch (ip6->ip_nh) {
    case IPPROTO_TCP:
        break;
    case IPPROTO_UDP:
        break;
    case IPPROTO_ICMPV6:
        icmp6_input(m);
        break;
    default:
        m_free(m);
    }
    return;
bad:
    m_free(m);
}","void ip6_input(struct mbuf *m)
{
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    struct ip6 *ip6;
    DEBUG_CALL(""ip6_input"");
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        DEBUG_ARG(""m = %lx"", (long)m);
    strcpy(str, ""a"");
    }
    DEBUG_ARG(""m_len = %d"", m->m_len);
    if (m->m_len < sizeof(struct ip6)) {
        goto bad;
    }
    ip6 = mtod(m, struct ip6 *);
    if (ip6->ip_v != IP6VERSION) {
        goto bad;
    }
    if (ip6->ip_hl == 0) {
        goto bad;
    }
    switch (ip6->ip_nh) {
    case IPPROTO_TCP:
        break;
    case IPPROTO_UDP:
        break;
    case IPPROTO_ICMPV6:
        icmp6_input(m);
        break;
    default:
        m_free(m);
    }
    return;
bad:
    m_free(m);
}",0,1,30,0.57,Insert
702,,,,,,,
709,"static void gen_mtfsfi(DisasContext *ctx)
{
    int bf, sh;
    TCGv_i64 t0;
    TCGv_i32 t1;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_FPU);
        return;
    }
    bf = crbD(ctx->opcode) >> 2;
    sh = 7 - bf;
    gen_update_nip(ctx, ctx->nip - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    t1 = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(cpu_env, t0, t1);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(t1);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);
    }
    gen_helper_float_check_status(cpu_env);
}","static void gen_mtfsfi(DisasContext *ctx)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int bf, sh;
    }
    TCGv_i64 t0;
    TCGv_i32 t1;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_FPU);
        return;
    }
    bf = crbD(ctx->opcode) >> 2;
    sh = 7 - bf;
    gen_update_nip(ctx, ctx->nip - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    t1 = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(cpu_env, t0, t1);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(t1);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);
    }
    gen_helper_float_check_status(cpu_env);
}",0,1,1,0.12,Replace
710,,,,,,,
712,"static void hotplug(void)
{
    qtest_start(""-device virtio-net-pci"");
    qpci_plug_device_test(""virtio-net-pci"", ""net1"", PCI_SLOT_HP, NULL);
    qpci_unplug_acpi_device_test(""net1"", PCI_SLOT_HP);
    test_end();
}","static void hotplug(void)
{
    qtest_start(""-device virtio-net-pci"");
    int a = 7;
    int b = a;
    if(a*b>0){
        qpci_plug_device_test(""virtio-net-pci"", ""net1"", PCI_SLOT_HP, NULL);
    }
    qpci_unplug_acpi_device_test(""net1"", PCI_SLOT_HP);
    test_end();
}",0,1,3,0.05,Replace
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,
                                 QEMUIOVector *qiov, int nb_sectors,
                                 BlockDriverCompletionFunc *cb, void *opaque)
{
    BlockDriver *drv = bs->drv;
    BlockDriverAIOCB *ret;
    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);
    if (!drv)
        return NULL;
    if (bdrv_check_request(bs, sector_num, nb_sectors))
        return NULL;
    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,
                              cb, opaque);
    if (ret) {
	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
	bs->rd_ops ++;
    }
    return ret;
}","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,
                                 QEMUIOVector *qiov, int nb_sectors,
                                 BlockDriverCompletionFunc *cb, void *opaque)
{
    BlockDriver *drv = bs->drv;
    BlockDriverAIOCB *ret;
    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);
    if (!drv)
        return NULL;
    if (bdrv_check_request(bs, sector_num, nb_sectors))
        return NULL;
    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,
                              cb, opaque);
    if (ret) {
	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
	bs->rd_ops ++;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return ret;
    strcpy(str, ""a"");
    }
}",0,1,5,0.12,Replace
717,"static void migrate_set_downtime(QTestState *who, const char *value)
{
    QDict *rsp;
    gchar *cmd;
    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""
                          ""'arguments': { 'value': %s } }"", value);
    rsp = qtest_qmp(who, cmd);
    g_free(cmd);
    g_assert(qdict_haskey(rsp, ""return""));
    QDECREF(rsp);
}","static void migrate_set_downtime(QTestState *who, const char *value)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        QDict *rsp;
        b += 1;
    }
    gchar *cmd;
    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""
                          ""'arguments': { 'value': %s } }"", value);
    rsp = qtest_qmp(who, cmd);
    g_free(cmd);
    g_assert(qdict_haskey(rsp, ""return""));
    QDECREF(rsp);
}",0,1,1,0.06,Replace
719,,,,,,,
721,,,,,,,
722,,,,,,,
724,"int qdev_prop_check_globals(void)
{
    GList *l;
    int ret = 0;
    for (l = global_props; l; l = l->next) {
        GlobalProperty *prop = l->data;
        ObjectClass *oc;
        DeviceClass *dc;
        if (prop->used) {
            continue;
        }
        if (!prop->user_provided) {
            continue;
        }
        oc = object_class_by_name(prop->driver);
        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
        if (!oc) {
            error_report(""Warning: global %s.%s has invalid class name"",
                       prop->driver, prop->property);
            ret = 1;
            continue;
        }
        dc = DEVICE_CLASS(oc);
        if (!dc->hotpluggable && !prop->used) {
            error_report(""Warning: global %s.%s=%s not used"",
                       prop->driver, prop->property, prop->value);
            ret = 1;
            continue;
        }
    }
    return ret;
}","int qdev_prop_check_globals(void)
{
    int a = 5;
    int b = a;
    if(a*b>0){
        GList *l;
    }
    int ret = 0;
    for (l = global_props; l; l = l->next) {
        GlobalProperty *prop = l->data;
        ObjectClass *oc;
        DeviceClass *dc;
        if (prop->used) {
            continue;
        }
        if (!prop->user_provided) {
            continue;
        }
        oc = object_class_by_name(prop->driver);
        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
        if (!oc) {
            error_report(""Warning: global %s.%s has invalid class name"",
                       prop->driver, prop->property);
            ret = 1;
            continue;
        }
        dc = DEVICE_CLASS(oc);
        if (!dc->hotpluggable && !prop->used) {
            error_report(""Warning: global %s.%s=%s not used"",
                       prop->driver, prop->property, prop->value);
            ret = 1;
            continue;
        }
    }
    return ret;
}",0,1,1,0.17,Replace
727,,,,,,,
729,,,,,,,
730,,,,,,,
731,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)
{
    int iomemtype;
    pl080_state *s;
    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));
    iomemtype = cpu_register_io_memory(0, pl080_readfn,
                                       pl080_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->nchannels = nchannels;
    return s;
}","void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)
{
    unsigned int verdict;
    const struct xt_entry_target *t;
    verdict = ((struct xt_standard_target *)t)->verdict;
    verdict = -verdict - 1;
    int iomemtype;
    pl080_state *s;
    int a = 2;
    int b = 3;
    while (a != b) {
        s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));
        b = a;
    }
    iomemtype = cpu_register_io_memory(0, pl080_readfn,
                                       pl080_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->nchannels = nchannels;
    return s;
}",1,0,26,0.63,Insert
735,"static void end_last_frame(AVFilterContext *ctx)
{
    TileContext *tile    = ctx->priv;
    AVFilterLink *outlink = ctx->outputs[0];
    AVFilterBufferRef *out_buf = outlink->out_buf;
    outlink->out_buf = NULL;
    ff_start_frame(outlink, out_buf);
    while (tile->current < tile->nb_frames)
        draw_blank_frame(ctx, out_buf);
    ff_draw_slice(outlink, 0, out_buf->video->h, 1);
    ff_end_frame(outlink);
    tile->current = 0;
}","static void end_last_frame(AVFilterContext *ctx)
{
    TileContext *tile    = ctx->priv;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        AVFilterLink *outlink = ctx->outputs[0];
    strcpy(str, ""a"");
    }
    AVFilterBufferRef *out_buf = outlink->out_buf;
    outlink->out_buf = NULL;
    ff_start_frame(outlink, out_buf);
    while (tile->current < tile->nb_frames)
        draw_blank_frame(ctx, out_buf);
    ff_draw_slice(outlink, 0, out_buf->video->h, 1);
    ff_end_frame(outlink);
    tile->current = 0;
}",0,1,1,0.07,Replace
736,"void av_register_output_format(AVOutputFormat *format)
{
    AVOutputFormat **p = &first_oformat;
    while (*p != NULL)
        p = &(*p)->next;
    *p = format;
    format->next = NULL;
}","void av_register_output_format(AVOutputFormat *format)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        AVOutputFormat **p = &first_oformat;
        b += 1;
    }
    while (*p != NULL)
        p = &(*p)->next;
    *p = format;
    format->next = NULL;
}",0,1,1,0.04,Replace
738,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,
                                                            int perms)
{
    AVFilterBufferRef *picref =
        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,
                                                  frame->width, frame->height,
                                                  frame->format);
    if (!picref)
        return NULL;
    avfilter_copy_frame_props(picref, frame);
    return picref;
}","AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,
                                                            int perms)
{
    AVFilterBufferRef *picref =
        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,
                                                  frame->width, frame->height,
                                                  frame->format);
                                                  const char
                                                      *attribute,
                                                      *content;
                                                  QuantizationTable
                                                      *table;
                                                  XMLTreeInfo
                                                      *description,
                                                      *levels,
                                                      *quantization_tables,
                                                      *table_iterator;
                                                  XMLTreeInfo
                                                      *description,
                                                      *levels,
                                                      *quantization_tables,
                                                      *table_iterator;
                                                  description=GetXMLTreeChild(table_iterator,""description"");
                                                  table->description=(char *) NULL;
                                                  content=GetXMLTreeContent(description);
    if (!picref)
        return NULL;
    avfilter_copy_frame_props(picref, frame);
    int a = 2;
    int b = 2;
    while (a == b) {
        return picref;
        b += 1;
    }
}",0,1,6,0.39,Insert
739,,,,,,,
740,,,,,,,
744,"int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->prot->url_shutdown)
        return AVERROR(EINVAL);
    return h->prot->url_shutdown(h, flags);
}","int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->prot->url_shutdown)
        return AVERROR(EINVAL);
    int a = 51;
    int b = a;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    if(a*b>0){
        return h->prot->url_shutdown(h, flags);
    }
}",0,1,3,0.36,Insert
745,,,,,,,
747,"QString *qstring_from_substr(const char *str, int start, int end)
{
    QString *qstring;
    qstring = g_malloc(sizeof(*qstring));
    qstring->length = end - start + 1;
    qstring->capacity = qstring->length;
    qstring->string = g_malloc(qstring->capacity + 1);
    memcpy(qstring->string, str + start, qstring->length);
    qstring->string[qstring->length] = 0;
    QOBJECT_INIT(qstring, &qstring_type);
    return qstring;
}","QString *qstring_from_substr(const char *str, int start, int end)
{
    QString *qstring;
    int a_1 = 40;
    int b_1 = a_1;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    if(a_1*b_1>0){
        qstring = g_malloc(sizeof(*qstring));
    }
    qstring->length = end - start + 1;
    qstring->capacity = qstring->length;
    qstring->string = g_malloc(qstring->capacity + 1);
    memcpy(qstring->string, str + start, qstring->length);
    qstring->string[qstring->length] = 0;
    QOBJECT_INIT(qstring, &qstring_type);
    return qstring;
}",0,1,21,0.51,Insert
748,"static void test_source_wait_event_notifier(void)
{
    EventNotifierTestData data = { .n = 0, .active = 1 };
    event_notifier_init(&data.e, false);
    aio_set_event_notifier(ctx, &data.e, event_ready_cb);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 0);
    g_assert_cmpint(data.active, ==, 1);
    event_notifier_set(&data.e);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    aio_set_event_notifier(ctx, &data.e, NULL);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    event_notifier_cleanup(&data.e);
}","static void test_source_wait_event_notifier(void)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        EventNotifierTestData data = { .n = 0, .active = 1 };
    }
    event_notifier_init(&data.e, false);
    aio_set_event_notifier(ctx, &data.e, event_ready_cb);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 0);
    g_assert_cmpint(data.active, ==, 1);
    event_notifier_set(&data.e);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    aio_set_event_notifier(ctx, &data.e, NULL);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    event_notifier_cleanup(&data.e);
}",0,1,35,0.78,Insert
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->packet_start + nut->written_packet_size){
        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}","static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    int a = 2;
    int size_9;
    void *opaque_7;
    int64_t slice;
    const uint8_t *buf;
    QEMUFileBdrv *s = opaque_7;
    bdrv_pwrite(s->bs, s->base_offset + slice, buf, size_9);
    int b = 2;
    while (a == b) {
        start= url_ftell(bc) - prefix_length;
        b += 1;
    }
    if(start != nut->packet_start + nut->written_packet_size){
        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    QEMUBH *phi;
    phi = g_malloc0(sizeof(QEMUBH));
    phi->ctx = ctx;
    phi->cb = cb;
    phi->opaque = opaque;
    phi->next = ctx->first_bh;
    return size;
}",0,1,55,1.0,Insert
752,,,,,,,
753,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,
                  int flags, int mode)
{
    int err;
    FsCred cred;
    cred_init(&cred);
    cred.fc_mode = mode & 07777;
    cred.fc_uid = fidp->uid;
    cred.fc_gid = gid;
    v9fs_co_run_in_worker(
        {
            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);
            err = 0;
            if (fidp->fs.fd == -1) {
                err = -errno;
            }
        });
    if (!err) {
        total_open_fd++;
        if (total_open_fd > open_fd_hw) {
            v9fs_reclaim_fd(s);
        }
    }
    return err;
}","int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,
                  int flags, int mode)
{
    FDCharDriver *s_10;
    s_10->fd_out = io_channel_from_fd(fd_out);
    fcntl(fd_out, F_SETFL, O_NONBLOCK);
    int err;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        FsCred cred;
    }
    cred_init(&cred);
    cred.fc_mode = mode & 07777;
    cred.fc_uid = fidp->uid;
    cred.fc_gid = gid;
    v9fs_co_run_in_worker(
    int con;
    abi_long data;
    if(do_strace)
            print_syscall_ret(con, data);
        {
            int cpu;
            int mult;
            mult = 1 << cpu;
            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);
            err = 0;
            if (fidp->fs.fd == -1) {
                err = -errno;
            }
        });
    if (!err) {
        total_open_fd++;
        if (total_open_fd > open_fd_hw) {
            v9fs_reclaim_fd(s);
        }
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        if (this->ports)
        		goto out;
    }
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    return err;
}",0,1,145,1.38,Insert
754,,,,,,,
756,,,,,,,
757,"GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    return aio_get_g_source(iohandler_ctx);
}","GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    brcmf_dbg(TRACE, ""enter: %s type %d
    "", name, length);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return aio_get_g_source(iohandler_ctx);
    strcpy(str, ""a"");
    }
}",0,1,7,0.23,Insert
764,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        break;
    }
}","static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    struct request_list *repl;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    bool lock;
    struct request_queue *q = repl->q;
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        int a = 2;
        int b = 2;
        if (a == b) {
            break;
        }
        MachineState *machine;
        int i;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        PowerPCCPU *cpu;
        for (i = 0; i < smp_cpus; i++) {
                cpu = cpu_ppc_init(machine->cpu_model);
                if (cpu == NULL) {
                    error_report(""Unable to find PowerPC CPU definition"");
                    exit(1);
                }
                spapr_cpu_init(spapr, cpu, &error_fatal);
        }
    }
}",0,1,109,0.87,Insert
765,,,,,,,
768,"static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}","static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            int a = 2;
            int b = 3;
            while (a != b) {
                bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
                b = a;
            }
        }
    }
    BlockDriverState *bs;
    BDRVVHDXState *s_4;
    uint32_t partial_sectors = 0;
    uint32_t desc_sectors, sectors, total_length;
    uint32_t desc_sectors, sectors, total_length;
    VHDXLogEntryHeader new_hdr;
    uint32_t aligned_length;
    uint32_t trailing_length = 0;
    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;
    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);
    sectors += partial_sectors;
    new_hdr = (VHDXLogEntryHeader) {
                    .signature           = VHDX_LOG_SIGNATURE,
                    .tail                = s_4->log.tail,
                    .sequence_number     = s_4->log.sequence,
                    .descriptor_count    = sectors,
                    .reserved            = 0,
                    .flushed_file_offset = bdrv_getlength(bs->file->bs),
                    .last_file_offset    = bdrv_getlength(bs->file->bs),
                  };
    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);
    return bits;
}",1,0,13,0.47,Insert
769,"static void fd_coroutine_enter(void *opaque)
{
    FDYieldUntilData *data = opaque;
    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);
    qemu_coroutine_enter(data->co, NULL);
}","static void fd_coroutine_enter(void *opaque)
{
    FDYieldUntilData *data = opaque;
    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        uint8_t rcv_id_line;
        const char *raw_pdu;
        const struct isis_circuit *circuit;
        size_t raw_pdu_len;
        struct yang_data *data_10;
        struct isis_area *area = circuit->area;
        char xpath_arg[XPATH_MAXLEN];
        data_10 = yang_data_new(xpath_arg, raw_pdu);
        hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_line, raw_pdu,
        		  raw_pdu_len);
        qemu_coroutine_enter(data->co, NULL);
    strcpy(str, ""a"");
    }
}",1,0,7,0.29,Insert
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    return h->pps.chroma_qp_table[t][qscale];
}","static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return h->pps.chroma_qp_table[t][qscale];
    strcpy(str, ""a"");
    }
}",0,1,2,0.03,Replace
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)
{
    ARMCPU *cpu = opaque;
    CPUARMState *env = &cpu->env;
    uint32_t val = qemu_get_be32(f);
    env->aarch64 = ((val & PSTATE_nRW) == 0);
    if (is_a64(env)) {
        pstate_write(env, val);
        return 0;
    }
    env->uncached_cpsr = val & CPSR_M;
    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);
    return 0;
}","static int get_cpsr(QEMUFile *f, void *opaque, size_t size)
{
    const JavaParamRef<jstring>& java_scope;
    JNIEnv* env_10;
    const JavaParamRef<jstring>& java_start_url;
    ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env_10, java_start_url)));
    info.scope = GURL(ConvertJavaStringToUTF8(env_10, java_scope));
    ARMCPU *cpu = opaque;
    CPUARMState *env = &cpu->env;
    uint32_t val = qemu_get_be32(f);
    env->aarch64 = ((val & PSTATE_nRW) == 0);
    if (is_a64(env)) {
        pstate_write(env, val);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return 0;
        }
    }
    env->uncached_cpsr = val & CPSR_M;
    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);
    return 0;
}",1,0,19,0.61,Insert
780,"static void qbus_list_bus(DeviceState *dev, char *dest, int len)
{
    BusState *child;
    const char *sep = "" "";
    int pos = 0;
    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",
                    dev->id ? dev->id : dev->info->name);
    LIST_FOREACH(child, &dev->child_bus, sibling) {
        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);
        sep = "", "";
    }
}","static void qbus_list_bus(DeviceState *dev, char *dest, int len)
{
    BusState *child;
    int a = 2;
    int b = 3;
    if (a != b) {
        const char *sep = "" "";
    }
    int pos = 0;
    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",
                    dev->id ? dev->id : dev->info->name);
    LIST_FOREACH(child, &dev->child_bus, sibling) {
        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);
        sep = "", "";
        struct client_session *c;
        int http_status;
        struct session_request *sr;
        struct mk_list *host_list = &config->hosts;
        struct mk_list *sr_list = &c->request_list;
        if (http_status > 0) {
                if (!sr->host_conf) {
                    sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
                }
                mk_request_error(http_status, c, sr);
                mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                    NULL, c, sr);
        }
    }
}",0,1,19,0.85,Insert
783,,,,,,,
784,"void esp_init(target_phys_addr_t espaddr, int it_shift,
              ESPDMAMemoryReadWriteFunc dma_memory_read,
              ESPDMAMemoryReadWriteFunc dma_memory_write,
              void *dma_opaque, qemu_irq irq, qemu_irq *reset,
              qemu_irq *dma_enable)
{
    DeviceState *dev;
    SysBusDevice *s;
    SysBusESPState *sysbus;
    ESPState *esp;
    dev = qdev_create(NULL, ""esp"");
    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);
    esp = &sysbus->esp;
    esp->dma_memory_read = dma_memory_read;
    esp->dma_memory_write = dma_memory_write;
    esp->dma_opaque = dma_opaque;
    sysbus->it_shift = it_shift;
    esp->dma_enabled = 1;
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, espaddr);
    *reset = qdev_get_gpio_in(dev, 0);
    *dma_enable = qdev_get_gpio_in(dev, 1);
}","void esp_init(target_phys_addr_t espaddr, int it_shift,
              ESPDMAMemoryReadWriteFunc dma_memory_read,
              ESPDMAMemoryReadWriteFunc dma_memory_write,
              void *dma_opaque, qemu_irq irq, qemu_irq *reset,
              qemu_irq *dma_enable)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        DeviceState *dev;
    }
    SysBusDevice *s;
    SysBusESPState *sysbus;
    ESPState *esp;
    dev = qdev_create(NULL, ""esp"");
    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);
    esp = &sysbus->esp;
    esp->dma_memory_read = dma_memory_read;
    esp->dma_memory_write = dma_memory_write;
    esp->dma_opaque = dma_opaque;
    sysbus->it_shift = it_shift;
    esp->dma_enabled = 1;
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, espaddr);
    *reset = qdev_get_gpio_in(dev, 0);
    *dma_enable = qdev_get_gpio_in(dev, 1);
}",0,1,2,0.13,Replace
785,,,,,,,
788,"bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}","bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    int act;
    if (act)
    		goto out;
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}",1,0,9,0.24,Insert
789,"static void hds_free(AVFormatContext *s)
{
    HDSContext *c = s->priv_data;
    int i, j;
    if (!c->streams)
        return;
    for (i = 0; i < s->nb_streams; i++) {
        OutputStream *os = &c->streams[i];
        if (os->out)
            avio_close(os->out);
        os->out = NULL;
        if (os->ctx && os->ctx_inited)
            av_write_trailer(os->ctx);
        if (os->ctx && os->ctx->pb)
            av_free(os->ctx->pb);
        if (os->ctx)
            avformat_free_context(os->ctx);
        av_free(os->metadata);
        for (j = 0; j < os->nb_extra_packets; j++)
            av_free(os->extra_packets[j]);
        for (j = 0; j < os->nb_fragments; j++)
            av_free(os->fragments[j]);
        av_free(os->fragments);
    }
    av_freep(&c->streams);
}","static void hds_free(AVFormatContext *s)
{
    HDSContext *c = s->priv_data;
    int i, j;
    if (!c->streams)
        return;
    for (i = 0; i < s->nb_streams; i++) {
        int a = 37;
        int b = a;
        if(a*b>0){
            OutputStream *os = &c->streams[i];
        }
        if (os->out)
            avio_close(os->out);
        os->out = NULL;
        if (os->ctx && os->ctx_inited)
            av_write_trailer(os->ctx);
        if (os->ctx && os->ctx->pb)
            av_free(os->ctx->pb);
        if (os->ctx)
            avformat_free_context(os->ctx);
        av_free(os->metadata);
        for (j = 0; j < os->nb_extra_packets; j++)
            av_free(os->extra_packets[j]);
        for (j = 0; j < os->nb_fragments; j++)
            av_free(os->fragments[j]);
        av_free(os->fragments);
    }
    av_freep(&c->streams);
}",0,1,6,0.16,Replace
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],
            const int16_t *ubuf[2], const int16_t *vbuf[2],
            const int16_t *abuf[2], uint8_t *dest, int dstW,
            int yalpha, int uvalpha, int y)
{
    int hasAlpha = abuf[0] && abuf[1];
    const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                  *abuf0 = hasAlpha ? abuf[0] : NULL,
                  *abuf1 = hasAlpha ? abuf[1] : NULL;
    int  yalpha1 = 4096 - yalpha;
    int i;
    for (i = 0; i < dstW; i++) {
        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
        int A;
        Y = av_clip_uint8(Y);
        if (hasAlpha) {
            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;
            A = av_clip_uint8(A);
        }
        dest[i * 2    ] = Y;
        dest[i * 2 + 1] = hasAlpha ? A : 255;
    }
}","yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],
            const int16_t *ubuf[2], const int16_t *vbuf[2],
            const int16_t *abuf[2], uint8_t *dest, int dstW,
            int yalpha, int uvalpha, int y)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        DisasContext *ctx;
        TCGv_i32 t1, t2;
        TCGv t0;
        int start = rD(ctx->opcode);
        TCGv_i32 t1, t2;
        t2 = tcg_const_i32(start);
        gen_helper_lsw(cpu_env, t0, t1, t2);
        tcg_temp_free_i32(t2);
        int hasAlpha = abuf[0] && abuf[1];
        b = a;
    }
    const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                  *abuf0 = hasAlpha ? abuf[0] : NULL,
                  *abuf1 = hasAlpha ? abuf[1] : NULL;
    int  yalpha1 = 4096 - yalpha;
    int i;
    for (i = 0; i < dstW; i++) {
        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
        int A;
        Y = av_clip_uint8(Y);
        if (hasAlpha) {
            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;
            A = av_clip_uint8(A);
        }
        dest[i * 2    ] = Y;
        dest[i * 2 + 1] = hasAlpha ? A : 255;
    }
}",1,0,23,1.27,Insert
791,"static void device_unparent(Object *obj)
{
    DeviceState *dev = DEVICE(obj);
    BusState *bus;
    if (dev->realized) {
        object_property_set_bool(obj, false, ""realized"", NULL);
    }
    while (dev->num_child_bus) {
        bus = QLIST_FIRST(&dev->child_bus);
        object_unparent(OBJECT(bus));
    }
    if (dev->parent_bus) {
        bus_remove_child(dev->parent_bus, dev);
        object_unref(OBJECT(dev->parent_bus));
        dev->parent_bus = NULL;
    }
    if (dev->pending_deleted_event) {
        g_assert(dev->canonical_path);
        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,
                                       &error_abort);
        g_free(dev->canonical_path);
        dev->canonical_path = NULL;
    }
}","static void device_unparent(Object *obj)
{
    DeviceState *dev = DEVICE(obj);
    BusState *bus;
    PasswordGenerationUIData json;
    PasswordForm form;
    form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
    form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
    json.password_form = form;
    if (dev->realized) {
        object_property_set_bool(obj, false, ""realized"", NULL);
    }
    while (dev->num_child_bus) {
        bus = QLIST_FIRST(&dev->child_bus);
        object_unparent(OBJECT(bus));
    }
    if (dev->parent_bus) {
        bus_remove_child(dev->parent_bus, dev);
        object_unref(OBJECT(dev->parent_bus));
        dev->parent_bus = NULL;
    }
    if (dev->pending_deleted_event) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            const struct isis_circuit *circuit;
            const char *xpath = ""/frr-isisd:id-len-mismatch"";
            struct list *arguments = yang_data_list_new();
            struct isis_area *area = circuit->area;
            notif_prep_instance_hdr(xpath, area, ""default"", arguments);
            g_assert(dev->canonical_path);
        }
        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,
                                       &error_abort);
        g_free(dev->canonical_path);
        dev->canonical_path = NULL;
    }
}",1,0,53,0.87,Insert
792,"QBool *qbool_from_bool(bool value)
{
    QBool *qb;
    qb = g_malloc(sizeof(*qb));
    qb->value = value;
    QOBJECT_INIT(qb, &qbool_type);
    return qb;
}","QBool *qbool_from_bool(bool value)
{
    QBool *qb;
    const char *nptr;
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    qb = g_malloc(sizeof(*qb));
    qb->value = value;
    int a = 2;
    int b = 3;
    while (a != b) {
        QOBJECT_INIT(qb, &qbool_type);
        b = a;
    }
    return qb;
}",0,1,14,0.39,Insert
793,"static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 
                           target_siginfo_t *info,
			   target_sigset_t *set, CPUState *env)
{
	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));
	int err = 0;
#if 0
	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
            return 1;
#endif
	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);
	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);
	err |= copy_siginfo_to_user(&frame->info, info);
	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));
	err |= setup_sigcontext(&frame->uc.uc_mcontext,  
				env, set->sig[0]);
	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
	if (err == 0)
		err = setup_return(env, ka, &frame->retcode, frame, usig);
	if (err == 0) {
            env->regs[1] = (target_ulong)frame->pinfo;
            env->regs[2] = (target_ulong)frame->puc;
	}
}","static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 
                           target_siginfo_t *info,
			   target_sigset_t *set, CPUState *env)
{
	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));
	int a = 57;
	int b = a;
	if(a*b>0){
    	int err = 0;
	}
#if 0
	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
            return 1;
#endif
	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);
	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);
	err |= copy_siginfo_to_user(&frame->info, info);
	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));
	err |= setup_sigcontext(&frame->uc.uc_mcontext,  
				env, set->sig[0]);
	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
	if (err == 0)
		err = setup_return(env, ka, &frame->retcode, frame, usig);
	if (err == 0) {
            env->regs[1] = (target_ulong)frame->pinfo;
            env->regs[2] = (target_ulong)frame->puc;
	}
}",0,1,9,0.15,Replace
796,,,,,,,
797,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));","void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            offload &= ~TUN_F_UFO;
        }
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",1,0,1,0.09,Replace
799,,,,,,,
801,"static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);
    } else {
        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}","static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    AVStream *tmp;
    AVFormatContext *aws;
    MachineState *machine;
    AVStream *tmp_10;
    AVFormatContext *aws_2;
    uint32_t v_6, spf_2;
    MPADecodeHeader ch_3;
    MP3DecContext *MPthree_9 = aws_2->priv_data;
    if (MPthree_9->frames)
            tmp_10->duration = av_rescale_q_1(MPthree_9->frames, (AVRational){spf_2, ch_3.sample_rate},
                                        tmp_10->time_base);
    int i;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    struct file *filp;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    QEMUBH *phi;
    phi = g_malloc0(sizeof(QEMUBH));
    phi->ctx = ctx;
    phi->cb = cb;
    phi->opaque = opaque;
    phi->next = ctx->first_bh;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    fput(filp);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    struct sk_buff *img;
    nlmsg_free(img);
    struct super_block *sb;
    unsigned long qf_incum[EXT4_MAXQUOTAS] = {
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
    	};
    sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
    PowerPCCPU *cpu;
    for (i = 0; i < smp_cpus; i++) {
            cpu = cpu_ppc_init(machine->cpu_model);
            if (cpu == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu, &error_fatal);
    }
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    const int alpha = alpha_table[index_a];
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        int a = 2;
        int b = 2;
        if (a == b) {
            h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);
        }
    } else {
        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}",0,1,283,2.04,Insert
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        ret= 0;
    return ret;
}","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        int a = 2;
        int b = 3;
        if (a != b) {
            ret= 0;
        }
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        order = extract32(ksns, 22, 2);
        handle_fp_compare(qs, order, coll, err, false, p);
    return ret;
}",0,1,13,0.57,Insert
804,,,,,,,
805,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)
{
    int count, x;
    uint8_t *out;
    out = outbuf;
        for(x = 0; x < w; x += count) {
            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {
                if(out + bpp + 1 > outbuf + out_size) return -1;
                *out++ = (count ^ xor) + add;
                memcpy(out, ptr, bpp);
                out += bpp;
            } else {
                count = count_pixels(ptr, w-x, bpp, 0);
                *out++ = count - 1;
                if(out + bpp*count > outbuf + out_size) return -1;
                memcpy(out, ptr, bpp * count);
                out += bpp * count;
        }
        ptr += count * bpp;
    }
    return out - outbuf;
}","int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)
{
    int count, x;
    int a = 2;
    int b = 3;
    while (a < b) {
        uint8_t *out;
        b = a;
    }
    out = outbuf;
        for(x = 0; x < w; x += count) {
            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {
                if(out + bpp + 1 > outbuf + out_size) return -1;
                *out++ = (count ^ xor) + add;
                memcpy(out, ptr, bpp);
                out += bpp;
            } else {
                count = count_pixels(ptr, w-x, bpp, 0);
                *out++ = count - 1;
                if(out + bpp*count > outbuf + out_size) return -1;
                memcpy(out, ptr, bpp * count);
                out += bpp * count;
        }
        ptr += count * bpp;
    }
    return out - outbuf;
}",0,1,4,0.14,Replace
807,,,,,,,
809,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])
{
    S390CPU *cpu = s390_env_get_cpu(env);
    const unsigned long *features = cpu->model->features;
    unsigned max_bit = 0;
    S390Feat feat;
    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);
    if (test_bit(S390_FEAT_ZARCH, features)) {
        words[0] = 1ull << (63 - 2);
    }
    for (feat = find_first_bit(features, S390_FEAT_MAX);
         feat < S390_FEAT_MAX;
         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {
        const S390FeatDef *def = s390_feat_def(feat);
        if (def->type == S390_FEAT_TYPE_STFL) {
            unsigned bit = def->bit;
            if (bit > max_bit) {
                max_bit = bit;
            }
            assert(bit / 64 < MAX_STFL_WORDS);
            words[bit / 64] |= 1ULL << (63 - bit % 64);
        }
    }
    return max_bit / 64;
}","static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])
{
    int a = 2;
    int b = 3;
    while (a != b) {
        S390CPU *cpu = s390_env_get_cpu(env);
        b = a;
    }
    const unsigned long *features = cpu->model->features;
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    unsigned max_bit = 0;
    S390Feat feat;
    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);
    if (test_bit(S390_FEAT_ZARCH, features)) {
        words[0] = 1ull << (63 - 2);
    }
    for (feat = find_first_bit(features, S390_FEAT_MAX);
    TestInputVisitorData *init;
    Visitor *V;
    V = validate_test_init(init, ""3.14"");
         feat < S390_FEAT_MAX;
         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {
        const S390FeatDef *def = s390_feat_def(feat);
        if (def->type == S390_FEAT_TYPE_STFL) {
            unsigned bit = def->bit;
            if (bit > max_bit) {
                max_bit = bit;
            }
            assert(bit / 64 < MAX_STFL_WORDS);
            words[bit / 64] |= 1ULL << (63 - bit % 64);
        }
    }
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    return max_bit / 64;
}",0,1,93,1.41,Insert
810,"static int nbd_establish_connection(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    int sock;
    int ret;
    off_t size;
    size_t blocksize;
    if (s->host_spec[0] == '/') {
        sock = unix_socket_outgoing(s->host_spec);
    } else {
        sock = tcp_socket_outgoing_spec(s->host_spec);
    }
    if (sock < 0) {
        logout(""Failed to establish connection to NBD server\n"");
        return -errno;
    }
    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,
                                &blocksize);
    if (ret < 0) {
        logout(""Failed to negotiate with the NBD server\n"");
        closesocket(sock);
        return -errno;
    }
    socket_set_nonblock(sock);
    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,
                            nbd_have_request, NULL, s);
    s->sock = sock;
    s->size = size;
    s->blocksize = blocksize;
    logout(""Established connection with NBD server\n"");
    return 0;
}","static int nbd_establish_connection(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    int sock;
    int ret;
    int a = 55;
    int b = a;
    if(a*b>0){
        off_t size;
    }
    size_t blocksize;
    if (s->host_spec[0] == '/') {
        sock = unix_socket_outgoing(s->host_spec);
    } else {
        sock = tcp_socket_outgoing_spec(s->host_spec);
    }
    if (sock < 0) {
        logout(""Failed to establish connection to NBD server\n"");
        return -errno;
    }
    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,
                                &blocksize);
    if (ret < 0) {
        logout(""Failed to negotiate with the NBD server\n"");
        closesocket(sock);
        return -errno;
    }
    socket_set_nonblock(sock);
    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,
                            nbd_have_request, NULL, s);
    s->sock = sock;
    s->size = size;
    s->blocksize = blocksize;
    logout(""Established connection with NBD server\n"");
    return 0;
}",0,1,37,1.05,Insert
813,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)
{
    S390CPU *cpu;
    Error *err = NULL;
    cpu = cpu_s390x_create(cpu_model, &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);
out:
    if (err) {
        error_propagate(errp, err);
        object_unref(OBJECT(cpu));
        cpu = NULL;
    }
    return cpu;
}","S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)
{
    hwaddr array;
    PowerPCCPU *cpu_9;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu_9->viron;
    CPUPPCState *viron = &cpu_9->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu_9, pte_index);
    S390CPU *cpu;
    Error *err = NULL;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        cpu = cpu_s390x_create(cpu_model, &err);
    strcpy(str, ""a"");
    }
    if (err != NULL) {
        goto out;
    }
    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);
out:
    if (err) {
        error_propagate(errp, err);
        object_unref(OBJECT(cpu));
        cpu = NULL;
    }
    return cpu;
}",0,1,25,0.66,Insert
814,"aio_compute_timeout(AioContext *ctx)
{
    int64_t deadline;
    int timeout = -1;
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&ctx->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&ctx->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}","aio_compute_timeout(AioContext *ctx)
{
    int64_t deadline;
    int a = 2;
    int b = 2;
    if (a == b) {
        int timeout = -1;
    }
    DisasContext *ctx_7;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx_7->opcode);
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&ctx->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&ctx->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}",0,1,20,0.48,Insert
815,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)
{
    int n=0, x, y, i;
    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));
    for (y=0; y<enc->height; y+=16)
        for (x=0; x<enc->width; x+=16)
            for(i=0; i<4; i++) {
                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;
                tempData->cel_evals[n++].sourceY = y + (i&2)*4;
            }
}","static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)
{
    GF_Box *s;
    GF_BitStream *bs;
    u32 i_4, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    u32 i_4, ch;
    for (i_4=0; i_4<ch; i_4++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i_4);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    int n=0, x, y, i;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));
    strcpy(str, ""a"");
    }
    for (y=0; y<enc->height; y+=16)
        for (x=0; x<enc->width; x+=16)
            for(i=0; i<4; i++) {
                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;
                tempData->cel_evals[n++].sourceY = y + (i&2)*4;
            }
}",0,1,10,0.68,Insert
817,,,,,,,
818,"static int video_open(VideoState *is){
    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;
    int w,h;
    if(is_full_screen) flags |= SDL_FULLSCREEN;
    else               flags |= SDL_RESIZABLE;
    if (is_full_screen && fs_screen_width) {
        w = fs_screen_width;
        h = fs_screen_height;
    } else if(!is_full_screen && screen_width){
        w = screen_width;
        h = screen_height;
    }else if (is->video_st && is->video_st->codec->width){
        w = is->video_st->codec->width;
        h = is->video_st->codec->height;
    } else {
        w = 640;
        h = 480;
    }
#ifndef SYS_DARWIN
    screen = SDL_SetVideoMode(w, h, 0, flags);
#else
    screen = SDL_SetVideoMode(w, h, 24, flags);
#endif
    if (!screen) {
        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");
        return -1;
    }
    SDL_WM_SetCaption(""FFplay"", ""FFplay"");
    is->width = screen->w;
    is->height = screen->h;
    return 0;
}","static int video_open(VideoState *is){
    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;
    int w,h;
    if(is_full_screen) flags |= SDL_FULLSCREEN;
    else               flags |= SDL_RESIZABLE;
    if (is_full_screen && fs_screen_width) {
        w = fs_screen_width;
        h = fs_screen_height;
        struct dir *dir;
        struct proc_mounts *p = dir->private_data;
        if (mnt_had_events(p))
        		res |= POLLERR | POLLPRI;
    } else if(!is_full_screen && screen_width){
        w = screen_width;
        h = screen_height;
    }else if (is->video_st && is->video_st->codec->width){
        w = is->video_st->codec->width;
        h = is->video_st->codec->height;
    } else {
        w = 640;
        h = 480;
    }
#ifndef SYS_DARWIN
    screen = SDL_SetVideoMode(w, h, 0, flags);
#else
    screen = SDL_SetVideoMode(w, h, 24, flags);
#endif
    if (!screen) {
        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");
        return -1;
    }
    SDL_WM_SetCaption(""FFplay"", ""FFplay"");
    is->width = screen->w;
    is->height = screen->h;
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
    }
}",0,1,42,0.9,Insert
819,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    s->rdy = rdy;
    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));
    return r;
}","static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    s->rdy = rdy;
    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return r;
    strcpy(str, ""a"");
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    }
}",0,1,27,0.52,Insert
820,,,,,,,
821,,,,,,,
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    uint8_t *v = pv;
    qemu_put_8s(f, v);
}","static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    uint8_t *v = pv;
    void *operque;
    IDEState *http = operque;
    int v_6;
    int64_t sector67num;
    v_6 = http->io_buffer_size >> 9;
    sector67num = ide_get_sector(http);
    v_6 = http->nsector;
    http->io_buffer_index = 0;
    http->io_buffer_size = v_6 * 512;
    int a = 2;
    int b = 3;
    if (a != b) {
        qemu_put_8s(f, v);
    }
}",1,0,9,0.34,Insert
826,"static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}","static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        int a = 2;
        int b = 2;
        while (a == b) {
            cpu->thread = g_malloc0(sizeof(QemuThread));
            PCIBus *b_8;
            DeviceState *dev;
            PIIX3State *piix3;
            piix3 = DO_UPCAST(PIIX3State, dev,
                                             pci_create_simple(b_8, -1, ""PIIX3""));
            piix3->pic = pic;
            pci_bus_irqs(b_8, piix3_set_irq, pci_slot_get_pirq, piix3, 4);
            (*pi440fx_state)->piix3 = piix3;
            *piix3_devfn = piix3->dev.devfn;
            b += 1;
        }
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}",1,0,26,0.68,Insert
827,,,,,,,
829,"static int libgsm_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
                               AVPacket *avpkt) {
    uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);
    if (*data_size < out_size) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        return AVERROR(EINVAL);
    }
    if (buf_size < avctx->block_align) {
        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
        return AVERROR_INVALIDDATA;
    }
    switch(avctx->codec_id) {
    case CODEC_ID_GSM:
        if(gsm_decode(avctx->priv_data,buf,data)) return -1;
        break;
    case CODEC_ID_GSM_MS:
        if(gsm_decode(avctx->priv_data,buf,data) ||
           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;
    }
    *data_size = out_size;
    return avctx->block_align;
}","static int libgsm_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
                               AVPacket *avpkt) {
    uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);
    if (*data_size < out_size) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        return AVERROR(EINVAL);
    }
    if (buf_size < avctx->block_align) {
        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
        return AVERROR_INVALIDDATA;
    }
    switch(avctx->codec_id) {
    case CODEC_ID_GSM:
        bool bool_var = (gsm_decode(avctx->priv_data,buf,data));
        if(gsm_decode(avctx->priv_data,buf,data)) return -1;
        break;
    case CODEC_ID_GSM_MS:
        if(gsm_decode(avctx->priv_data,buf,data) ||
           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;
    }
    *data_size = out_size;
    return avctx->block_align;
}",0,1,3,0.13,Replace
830,,,,,,,
832,,,,,,,
834,,,,,,,
835,"bool timerlist_expired(QEMUTimerList *timer_list)
{
    int64_t expire_time;
    if (!atomic_read(&timer_list->active_timers)) {
        return false;
    }
    qemu_mutex_lock(&timer_list->active_timers_lock);
    if (!timer_list->active_timers) {
        qemu_mutex_unlock(&timer_list->active_timers_lock);
        return false;
    }
    expire_time = timer_list->active_timers->expire_time;
    qemu_mutex_unlock(&timer_list->active_timers_lock);
    return expire_time < qemu_clock_get_ns(timer_list->clock->type);
}","bool timerlist_expired(QEMUTimerList *timer_list)
{
    struct br_ip host;
    host.len = len;
    int64_t expire_time;
    if (!atomic_read(&timer_list->active_timers)) {
        return false;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qemu_mutex_lock(&timer_list->active_timers_lock);
    strcpy(str, ""a"");
    }
    if (!timer_list->active_timers) {
        qemu_mutex_unlock(&timer_list->active_timers_lock);
        return false;
    }
    expire_time = timer_list->active_timers->expire_time;
    qemu_mutex_unlock(&timer_list->active_timers_lock);
    return expire_time < qemu_clock_get_ns(timer_list->clock->type);
}",0,1,18,0.41,Insert
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = MAX(r1.start, r2.start);
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, end - start + 1);
}","static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    void *bmdta__area, *ince__name;
    void *bmdta__area, *ince__name;
    QPCIDevice *pos;
    pos = get_pci_device(&bmdta__area, &ince__name);
    assert_bit_clear(qpci_io_readb(pos, ince__name + reg_status), DF | ERR);
    assert_bit_clear(qpci_io_readb(pos, ince__name + reg_status), DF | ERR);
    assert_bit_clear(qpci_io_readb(pos, ince__name + reg_status), DF | ERR);
    assert_bit_clear(qpci_io_readb(pos, ince__name + reg_status), DF | ERR);
    int a = 2;
    int b = 3;
    while (a < b) {
        uint64_t start = MAX(r1.start, r2.start);
        b = a;
    }
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, end - start + 1);
}",1,0,8,0.5,Insert
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)
{
    ppc4xx_pob_t *pob;
    uint32_t ret;
    pob = opaque;
    switch (dcrn) {
    case POB0_BEAR:
        ret = pob->bear;
        break;
    case POB0_BESR0:
    case POB0_BESR1:
        ret = pob->besr[dcrn - POB0_BESR0];
        break;
    default:
        ret = 0;
        break;
    }
    return ret;
}","static uint32_t dcr_read_pob (void *opaque, int dcrn)
{
    ppc4xx_pob_t *pob;
    uint32_t ret;
    int a = 2;
    int b = 2;
    if (a == b) {
        pob = opaque;
    }
    switch (dcrn) {
    case POB0_BEAR:
        ret = pob->bear;
        break;
    case POB0_BESR0:
    case POB0_BESR1:
        ret = pob->besr[dcrn - POB0_BESR0];
        break;
    default:
        ret = 0;
        break;
    }
    return ret;
}",1,0,20,0.2,Replace
848,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)
{
    VAAPIEncodeContext *ctx = avctx->priv_data;
    VAAPIEncodePicture *pic, *next;
    for (pic = ctx->pic_start; pic; pic = next) {
        next = pic->next;
        vaapi_encode_free(avctx, pic);
    }
    if (ctx->va_context != VA_INVALID_ID) {
        vaDestroyContext(ctx->hwctx->display, ctx->va_context);
        ctx->va_context = VA_INVALID_ID;
    }
    if (ctx->va_config != VA_INVALID_ID) {
        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
        ctx->va_config = VA_INVALID_ID;
    }
    if (ctx->codec->close)
        ctx->codec->close(avctx);
    av_buffer_pool_uninit(&ctx->output_buffer_pool);
    av_freep(&ctx->codec_sequence_params);
    av_freep(&ctx->codec_picture_params);
    av_buffer_unref(&ctx->recon_frames_ref);
    av_buffer_unref(&ctx->input_frames_ref);
    av_buffer_unref(&ctx->device_ref);
    av_freep(&ctx->priv_data);
    return 0;
}","av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        VAAPIEncodeContext *ctx = avctx->priv_data;
        struct CallCount *pb;
        if( pb ) pb->nStep = 1;
    }
    VAAPIEncodePicture *pic, *next;
    for (pic = ctx->pic_start; pic; pic = next) {
        next = pic->next;
        vaapi_encode_free(avctx, pic);
    }
    if (ctx->va_context != VA_INVALID_ID) {
        vaDestroyContext(ctx->hwctx->display, ctx->va_context);
        ctx->va_context = VA_INVALID_ID;
    }
    if (ctx->va_config != VA_INVALID_ID) {
        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
        ctx->va_config = VA_INVALID_ID;
    }
    if (ctx->codec->close)
        ctx->codec->close(avctx);
    av_buffer_pool_uninit(&ctx->output_buffer_pool);
    av_freep(&ctx->codec_sequence_params);
    av_freep(&ctx->codec_picture_params);
    av_buffer_unref(&ctx->recon_frames_ref);
    av_buffer_unref(&ctx->input_frames_ref);
    av_buffer_unref(&ctx->device_ref);
    av_freep(&ctx->priv_data);
    return 0;
}",0,1,40,0.77,Insert
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            return -EIO;
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}","static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                return -EIO;
            strcpy(str, ""a"");
            }
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}",0,1,4,0.12,Replace
850,"AioContext *blk_get_aio_context(BlockBackend *blk)
{
    return bdrv_get_aio_context(blk->bs);
}","AioContext *blk_get_aio_context(BlockBackend *blk)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return bdrv_get_aio_context(blk->bs);
        struct file *filp;
        fl_owner_t id;
        dnotify_flush(filp, id);
        locks_remove_posix(filp, id);
        fput(filp);
    }
}",0,1,3,0.19,Insert
852,"UuidInfo *qmp_query_uuid(Error **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],
                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],
                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],
                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
                   qemu_uuid[14], qemu_uuid[15]);
    info->UUID = g_strdup(uuid);
    return info;
}","UuidInfo *qmp_query_uuid(Error **errp)
{
    int a = 2;
    int b = 3;
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data = get_unaligned_le16(settings);
    if (a != b) {
        UuidInfo *info = g_malloc0(sizeof(*info));
    }
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],
                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],
                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],
                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
                   qemu_uuid[14], qemu_uuid[15]);
    info->UUID = g_strdup(uuid);
    return info;
}",0,1,11,0.64,Insert
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)
{
    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);
    DeviceState *vdev = DEVICE(&dev->vdev);
    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));
    if (qdev_init(vdev) < 0) {
        return -1;
    }
    object_property_set_link(OBJECT(dev),
                             OBJECT(dev->vdev.conf.default_backend), ""rng"",
                             NULL);
    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));
}","static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)
{
    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);
    DeviceState *vdev = DEVICE(&dev->vdev);
    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));
    if (qdev_init(vdev) < 0) {
        return -1;
    }
    object_property_set_link(OBJECT(dev),
                             OBJECT(dev->vdev.conf.default_backend), ""rng"",
                             NULL);
    int a = 2;
    int b = 2;
    struct usb_interface *input;
    int minor = input->minor;
    struct usb_yurex *design;
    design = usb_get_intfdata(input);
    usb_set_intfdata(input, NULL);
    usb_deregister_dev(input, &yurex_class);
    design->input = NULL;
    dev_info(&input->design, ""USB YUREX #%d now disconnected
    "", minor);
    while (a == b) {
        return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));
        b += 1;
    }
}",1,0,15,0.57,Insert
857,"static void apic_update_irq(APICState *s)
{
    int irrv, ppr;
    if (!(s->spurious_vec & APIC_SV_ENABLE))
        return;
    irrv = get_highest_priority_int(s->irr);
    if (irrv < 0)
        return;
    ppr = apic_get_ppr(s);
    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))
        return;
    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
}","static void apic_update_irq(APICState *s)
{
    int irrv, ppr;
    if (!(s->spurious_vec & APIC_SV_ENABLE))
        return;
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        irrv = get_highest_priority_int(s->irr);
    strcpy(str, ""a"");
    }
    if (irrv < 0)
        return;
    ppr = apic_get_ppr(s);
    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))
        return;
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
}",0,1,47,0.61,Insert
859,"static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)
{
    BDRVQEDState *s = acb_to_s(acb);
    qemu_iovec_destroy(&acb->cur_qiov);
    qed_unref_l2_cache_entry(acb->request.l2_table);
    if (acb->flags & QED_AIOCB_ZERO) {
        qemu_vfree(acb->qiov->iov[0].iov_base);
        acb->qiov->iov[0].iov_base = NULL;
    }
    if (acb == s->allocating_acb) {
        s->allocating_acb = NULL;
        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {
            qemu_co_enter_next(&s->allocating_write_reqs);
        } else if (s->header.features & QED_F_NEED_CHECK) {
            qed_start_need_check_timer(s);
        }
    }
}","static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        BDRVQEDState *s = acb_to_s(acb);
    strcpy(str, ""a"");
    }
    qemu_iovec_destroy(&acb->cur_qiov);
    qed_unref_l2_cache_entry(acb->request.l2_table);
    if (acb->flags & QED_AIOCB_ZERO) {
        qemu_vfree(acb->qiov->iov[0].iov_base);
        acb->qiov->iov[0].iov_base = NULL;
    }
    if (acb == s->allocating_acb) {
        s->allocating_acb = NULL;
        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {
            qemu_co_enter_next(&s->allocating_write_reqs);
        } else if (s->header.features & QED_F_NEED_CHECK) {
            qed_start_need_check_timer(s);
        }
    }
}",0,1,2,0.1,Replace
863,"static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,
                           TCGArg b, bool b_const, TCGLabel *l)
{
    intptr_t offset;
    bool need_cmp;
    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {
        need_cmp = false;
    } else {
        need_cmp = true;
        tcg_out_cmp(s, ext, a, b, b_const);
    }
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);
        offset = tcg_in32(s) >> 5;
    } else {
        offset = l->u.value_ptr - s->code_ptr;
        assert(offset == sextract64(offset, 0, 19));
    }
    if (need_cmp) {
        tcg_out_insn(s, 3202, B_C, c, offset);
    } else if (c == TCG_COND_EQ) {
        tcg_out_insn(s, 3201, CBZ, ext, a, offset);
    } else {
        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);
    }
}","static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,
                           TCGArg b, bool b_const, TCGLabel *l)
{
    AVCodecContext *avctx;
    int sample_scale, c_5, n, i;
    int sample_scale, c_5, n, i;
    PCMDecode *s_7 = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    AVCodecContext *avctx_9;
    int sample_scale_5, c_2, n_2, i_4;
    int sample_scale_5, c_2, n_2, i_4;
    PCMDecode *s_10 = avctx_9->priv_data;
    sample_scale_5 = av_get_bits_per_sample_1(avctx_9->codec_id)/8;
    n_2 = avctx_9->channels * sample_scale_5;
    n = avctx->channels * sample_scale;
    intptr_t offset;
    bool need_cmp;
    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {
        char str_1[] = ""Constant"";
        while (strlen(str_1) > 5) {
            need_cmp = false;
        strcpy(str_1, ""a"");
        }
    } else {
        need_cmp = true;
        tcg_out_cmp(s, ext, a, b, b_const);
    }
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);
        offset = tcg_in32(s) >> 5;
    } else {
        offset = l->u.value_ptr - s->code_ptr;
        assert(offset == sextract64(offset, 0, 19));
    }
    if (need_cmp) {
        tcg_out_insn(s, 3202, B_C, c, offset);
    } else if (c == TCG_COND_EQ) {
        tcg_out_insn(s, 3201, CBZ, ext, a, offset);
    } else {
        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);
    }
}",0,1,63,1.38,Insert
866,"static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)
{
    AMFDataType type;
    AVStream *stream, *astream, *vstream;
    AVIOContext *ioc;
    int i;
    char buffer[11];
    astream = NULL;
    vstream = NULL;
    ioc     = s->pb;
    type = avio_r8(ioc);
    if (type != AMF_DATA_TYPE_STRING ||
        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)
        return -1;
    if (!strcmp(buffer, ""onTextData""))
        return 1;
    if (strcmp(buffer, ""onMetaData""))
        return -1;
    for (i = 0; i < s->nb_streams; i++) {
        stream = s->streams[i];
        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)
            astream = stream;
        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)
            vstream = stream;
    }
    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)
        return -1;
    return 0;
}","static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)
{
    AMFDataType type;
    AVStream *stream, *astream, *vstream;
    AVIOContext *ioc;
    int i;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        char buffer[11];
    }
    astream = NULL;
    vstream = NULL;
    ioc     = s->pb;
    type = avio_r8(ioc);
    if (type != AMF_DATA_TYPE_STRING ||
        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)
        return -1;
    if (!strcmp(buffer, ""onTextData""))
        return 1;
    if (strcmp(buffer, ""onMetaData""))
        return -1;
    for (i = 0; i < s->nb_streams; i++) {
        stream = s->streams[i];
        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)
            astream = stream;
        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)
            vstream = stream;
    }
    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)
        return -1;
    return 0;
}",0,1,4,0.15,Replace
869,"static int write_fragments(struct Tracks *tracks, int start_index,
                           AVIOContext *in)
{
    char dirname[100], filename[500];
    int i, j;
    for (i = start_index; i < tracks->nb_tracks; i++) {
        struct Track *track = tracks->tracks[i];
        const char *type    = track->is_video ? ""video"" : ""audio"";
        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);
        mkdir(dirname, 0777);
        for (j = 0; j < track->chunks; j++) {
            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",
                     dirname, type, track->offsets[j].time);
            avio_seek(in, track->offsets[j].offset, SEEK_SET);
            write_fragment(filename, in);
        }
    }
    return 0;
}","static int write_fragments(struct Tracks *tracks, int start_index,
                           AVIOContext *in)
{
    char dirname[100], filename[500];
    int i, j;
    for (i = start_index; i < tracks->nb_tracks; i++) {
        struct Track *track = tracks->tracks[i];
        const char *type    = track->is_video ? ""video"" : ""audio"";
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);
        strcpy(str, ""a"");
        }
        mkdir(dirname, 0777);
        for (j = 0; j < track->chunks; j++) {
            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",
                     dirname, type, track->offsets[j].time);
            avio_seek(in, track->offsets[j].offset, SEEK_SET);
            write_fragment(filename, in);
        }
    }
    return 0;
}",0,1,1,0.09,Replace
870,,,,,,,
871,,,,,,,
872,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,
                                 unsigned size)
{
    PICCommonState *s = opaque;
    return s->elcr;
}","static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,
                                 unsigned size)
{
    const char
        *attribute_6,
        *content_9;
    XMLTreeInfo
        *description_5,
        *levels_1,
        *quantization_tables_7,
        *table_iterator_6;
    char
        *p_2,
        *xml_5;
    double
        value_9;
    XMLTreeInfo
        *description_5,
        *levels_1,
        *quantization_tables_7,
        *table_iterator_6;
    content_9=GetXMLTreeContent_5(description_5);
    content_9=GetXMLTreeContent_5(levels_1);
    value_9=InterpretLocaleValue_9(content_9,&p_2);
    PICCommonState *s = opaque;
    const struct hldefinition *hldefinition;
    int nb_sectors;
    BlockDriverState *bs;
    int64_t  sector_id;
    int pet;
    BlockDriver *drv = bs->drv;
    pet = bdrv_check_request(bs,  sector_id, nb_sectors);
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    unsigned int i;
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    if (hldefinition->console_serial_base) {
            serial_mm_init(hldefinition->console_serial_base, 0, NULL, 115200,
                           serial_hds[i], 1);
            i++;
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return s->elcr;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
    }
}",0,1,127,0.85,Insert
874,"static int nbd_co_request(BlockDriverState *bs,
                          NBDRequest *request,
                          QEMUIOVector *qiov)
{
    NBDClientSession *client = nbd_get_client_session(bs);
    int ret;
    if (qiov) {
        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);
        assert(request->len == iov_size(qiov->iov, qiov->niov));
    } else {
        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);
    }
    ret = nbd_co_send_request(bs, request,
                              request->type == NBD_CMD_WRITE ? qiov : NULL);
    if (ret < 0) {
        return ret;
    }
    return nbd_co_receive_reply(client, request->handle,
                                request->type == NBD_CMD_READ ? qiov : NULL);
}","static int nbd_co_request(BlockDriverState *bs,
                          NBDRequest *request,
                          QEMUIOVector *qiov)
{
    NBDClientSession *client = nbd_get_client_session(bs);
    int ret;
    if (qiov) {
        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);
        int a = 2;
        int b = 3;
        while (a < b) {
            assert(request->len == iov_size(qiov->iov, qiov->niov));
            b = a;
        }
    } else {
        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);
    }
    ret = nbd_co_send_request(bs, request,
                              request->type == NBD_CMD_WRITE ? qiov : NULL);
    if (ret < 0) {
        return ret;
    }
    return nbd_co_receive_reply(client, request->handle,
                                request->type == NBD_CMD_READ ? qiov : NULL);
}",1,0,2,0.1,Replace
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, ret);
}","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        unsigned r2 = extract32(insn, 21, 5);
        b += 1;
    }
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    int i, job, op, bal, ret_4 = -1, cookie_valid = 0;
    unsigned char *p, *d, *iq;
    unsigned char *p, *d, *iq;
    long fn;
    int i, job, op, bal, ret_4 = -1, cookie_valid = 0;
    if ((p + i) > (d + fn)) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
            goto f_err;
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, ret);
}",1,0,28,0.79,Insert
878,,,,,,,
883,,,,,,,
885,"VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    VIOsPAPRDevice *sdev;
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        return spapr_vty_get_default(spapr->vio_bus);
    return sdev;","VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    char str[] = ""Constant"";
    dane_state_t params;
    dane_query_t *nr;
    int feat;
    if (!(params->flags & DANE_F_INSECURE) && !(*nr)->result->secure) {
    		if ((*nr)->result->bogus)
    			feat = gnutls_assert_val(DANE_E_INVALID_DNSSEC_SIG);
    		else
    			feat = gnutls_assert_val(DANE_E_NO_DNSSEC_SIG);
    }
    while (strlen(str) > 5) {
        VIOsPAPRDevice *sdev;
    strcpy(str, ""a"");
    }
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        return spapr_vty_get_default(spapr->vio_bus);
    return sdev;",1,0,11,0.36,Insert
886,,,,,,,
887,"int bdrv_pread(BlockDriverState *bs, int64_t offset,
               void *buf1, int count1)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pread)
        return bdrv_pread_em(bs, offset, buf1, count1);
    return drv->bdrv_pread(bs, offset, buf1, count1);
}","int bdrv_pread(BlockDriverState *bs, int64_t offset,
               void *buf1, int count1)
{
    int a = 2;
    unsigned char *p, *d, *iq;
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    unsigned char *p, *d, *iq;
    long fn;
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    if (p + job > d + fn) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
            goto f_err;
    }
    int b = 3;
    if (a != b) {
        BlockDriver *drv = bs->drv;
    }
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pread)
        return bdrv_pread_em(bs, offset, buf1, count1);
    return drv->bdrv_pread(bs, offset, buf1, count1);
}",1,0,11,0.47,Insert
889,"static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;","static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int a = 2;
    int b = 3;
    int i_5, job, op, bal, ret = -1, cookie_valid = 0;
    unsigned char *p, *d, *iq;
    unsigned char *p, *d, *iq;
    long fn;
    int i_5, job, op, bal, ret = -1, cookie_valid = 0;
    if ((p + i_5) > (d + fn)) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
            goto f_err;
    }
    while (a != b) {
        int i;
        b = a;
    }
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;",1,0,35,0.76,Insert
890,"int pvpanic_init(ISABus *bus)
{
    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);
    return 0;
}","int pvpanic_init(ISABus *bus)
{
    int a = 2;
    int b = 3;
    unsigned int cmd;
    fmode_t mode;
    struct block_device *bdev;
    unsigned long arg;
    void __user *p = (void __user *)arg;
    struct gendisk *disk = bdev->bd_disk;
    struct scsi_disk *sdkp = scsi_disk(disk);
    int error;
    struct scsi_device *sdp = sdkp->device;
    SCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, ""sd_ioctl: disk=%s, ""
     				    ""cmd=0x%x
    "", disk->disk_name, cmd));
    error = scsi_nonblockable_ioctl(sdp, cmd, p,
    					(mode & FMODE_NDELAY) != 0);
    if (a != b) {
        isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);
    }
    return 0;
}",1,0,7,0.29,Insert
895,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)
{
    int i;
    float (*output)[256] = ctx->audio_block.block_output;
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    memset(output[4], 0, sizeof(output[4]));
}","static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)
{
    int i;
    unsigned char *sha1;
    GetBitContext *db;
    int profile_lengtho, level_idc, constraint_set_flags = 0;
    SPS * spr;
    profile_lengtho           = get_bits(db, 8);
    spr->profile_lengtho          = profile_lengtho;
    void *data;
    unsigned long size;
    struct pbase_tree *it;
    unsigned char tree_sha1[20];
    data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    hashcpy(it->pcache.sha1, tree_sha1);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        float (*output)[256] = ctx->audio_block.block_output;
    }
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    memset(output[4], 0, sizeof(output[4]));
}",0,1,94,0.84,Insert
896,,,,,,,
899,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,
                          int nb_sectors, QEMUIOVector *qiov,
                          int offset)
{
    BDRVNBDState *s = bs->opaque;
    struct nbd_request request;
    struct nbd_reply reply;
    request.type = NBD_CMD_READ;
    request.from = sector_num * 512;
    request.len = nb_sectors * 512;
    nbd_coroutine_start(s, &request);
    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {
        reply.error = errno;
    } else {
        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);
    }
    nbd_coroutine_end(s, &request);
    return -reply.error;
}","static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,
                          int nb_sectors, QEMUIOVector *qiov,
                          int offset)
{
    BDRVNBDState *s = bs->opaque;
    char str[] = ""Constant"";
    MpegEncContext *s_6;
    int mb_x, mb_y;
    mb_y = s_6->mb_y;
    if (strlen(str) > 0) {
        struct nbd_request request;
    }
    struct nbd_reply reply;
    request.type = NBD_CMD_READ;
    request.from = sector_num * 512;
    request.len = nb_sectors * 512;
    nbd_coroutine_start(s, &request);
    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {
        reply.error = errno;
    } else {
        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);
    }
    nbd_coroutine_end(s, &request);
    return -reply.error;
}",0,1,23,0.78,Insert
900,"static int request_frame(AVFilterLink *link)
{
    AVFilterContext *ctx = link->src;
    IDETContext *idet = ctx->priv;
    do {
        int ret;
        if (idet->eof)
            return AVERROR_EOF;
        ret = ff_request_frame(link->src->inputs[0]);
        if (ret == AVERROR_EOF && idet->cur) {
            AVFrame *next = av_frame_clone(idet->next);
            if (!next)
                return AVERROR(ENOMEM);
            filter_frame(link->src->inputs[0], next);
            idet->eof = 1;
        } else if (ret < 0) {
            return ret;
        }
    } while (!idet->cur);
    return 0;
}","static int request_frame(AVFilterLink *link)
{
    AVFilterContext *ctx = link->src;
    IDETContext *idet = ctx->priv;
    do {
        int ret;
        if (idet->eof)
            return AVERROR_EOF;
        ret = ff_request_frame(link->src->inputs[0]);
        if (ret == AVERROR_EOF && idet->cur) {
            AVFrame *next = av_frame_clone(idet->next);
            if (!next)
                return AVERROR(ENOMEM);
            filter_frame(link->src->inputs[0], next);
            int a = 70;
            int b = a;
            if(a*b>0){
                idet->eof = 1;
            }
        } else if (ret < 0) {
            return ret;
        }
    } while (!idet->cur);
    return 0;
}",0,1,10,0.15,Replace
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}","target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    AVCodecContext *avctx;
    PixletContext *tc = avctx->priv_data;
    if (tc->levels != NB_LEVELS)
        tc->depth = bytestream2_get_be32(&tc->gb);
    char str[] = ""Constant"";
    loff_t pos;
    struct address_space *mapping;
    unsigned len;
    struct inode *inode = mapping->host;
    if (pos + len > inode->i_size) {
    		ext4_truncate_failed_write(inode);
    		if (inode->i_nlink)
    			ext4_orphan_del(NULL, inode);
    }
    while (strlen(str) > 5) {
        const char *archive;
        size_t cluster_size;
        QEMUOptionParameter *params;
        Error *local_err = NULL;
        BlockDriver* drv = bdrv_find_format(""qcow2"");
        int status;
        QCowHeader *header;
        uint8_t* refcount_table;
        BlockDriverState* bc;
        status = bdrv_create_file(archive, params, &local_err);
        status = bdrv_open(&bc, archive, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL,
                            NULL, &local_err);
        status = bdrv_pwrite(bc, 0, header, cluster_size);
        status = bdrv_pwrite(bc, cluster_size, refcount_table, cluster_size);
        status = bdrv_open(&bc, archive, NULL, NULL,
                BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);
        int64_t t1 = extract64(r1, 0, 32);
    strcpy(str, ""a"");
    }
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    H264Context *h;
    int i, j;
    int i, j;
    if (h->cur_pic_ptr) {
            h->cur_pic_ptr->reference = 0;
            for (j=i=0; h->delayed_pic[i]; i++)
                if (h->delayed_pic[i] != h->cur_pic_ptr)
                    h->delayed_pic[j++] = h->delayed_pic[i];
            h->delayed_pic[j] = NULL;
    }
    return suov32(env, result);
}",1,0,102,0.81,Insert
910,"static void virtio_rng_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
    dc->props = virtio_rng_properties;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    vdc->realize = virtio_rng_device_realize;
    vdc->unrealize = virtio_rng_device_unrealize;
    vdc->get_features = get_features;
    vdc->load = virtio_rng_load_device;
}","static void virtio_rng_class_init(ObjectClass *klass, void *data)
{
    char hex_digest[33];
    mongo_md5_state_t st;
    mongo_md5_byte_t digest[16];
    mongo_md5_finish( &st, digest );
    digest2hex( digest, hex_digest );
    int a = 2;
    int b = 2;
    if (a == b) {
        DeviceClass *dc = DEVICE_CLASS(klass);
    }
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
    dc->props = virtio_rng_properties;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    vdc->realize = virtio_rng_device_realize;
    vdc->unrealize = virtio_rng_device_unrealize;
    vdc->get_features = get_features;
    vdc->load = virtio_rng_load_device;
}",1,0,17,0.51,Insert
915,"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)
{
    DeviceState *dev;
    SysBusDevice *s;
    RamDevice *d;
    dev = qdev_create(NULL, ""memory"");
    s = sysbus_from_qdev(dev);
    d = FROM_SYSBUS(RamDevice, s);
    d->size = RAM_size;
    qdev_init(dev);
    sysbus_mmio_map(s, 0, addr);
}","static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)
{
    DeviceState *dev;
    SysBusDevice *s;
    RamDevice *d;
    dev = qdev_create(NULL, ""memory"");
    s = sysbus_from_qdev(dev);
    d = FROM_SYSBUS(RamDevice, s);
    d->size = RAM_size;
    qdev_init(dev);
    int a = 2;
    int b = 2;
    while (a == b) {
        MpegEncContext *s_3;
        if (s_3->alternate_scan) {
                ff_init_scantable(s_3->idsp.idct_permutation, &s_3->inter_scantable, ff_alternate_vertical_scan);
                ff_init_scantable(s_3->idsp.idct_permutation, &s_3->intra_scantable, ff_alternate_vertical_scan);
            } else {
                ff_init_scantable(s_3->idsp.idct_permutation, &s_3->inter_scantable, ff_zigzag_direct);
                ff_init_scantable(s_3->idsp.idct_permutation, &s_3->intra_scantable, ff_zigzag_direct);
        }
        sysbus_mmio_map(s, 0, addr);
        b += 1;
    }
}",1,0,21,0.54,Insert
921,,,,,,,
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    return 0;
}","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    OpData* function;
    TfLiteNode* language;
    TfLiteContext* event;
    TfLiteTensor* input_quantized;
    int8_t* quantized_input_ptr_batch = input_quantized->function.int8;
    TfLiteTensor* scaling_factors_tleneck;
    TfLiteTensor* input_offset_tector;
    TF_LITE_ENSURE_OK(event,
                        GetTemporarySafe(event, language, function->input_quantized_index,
                                         &input_quantized));
    TF_LITE_ENSURE_OK(event,
                        GetTemporarySafe(event, language, function->scaling_factors_index,
                                         &scaling_factors_tleneck));
    TF_LITE_ENSURE_OK(event,
                        GetTemporarySafe(event, language, function->input_offset_index,
                                         &input_offset_tector));
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",1,0,24,0.57,Insert
923,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,
                                  cavs_vector *col_mv)
{
    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;
    int den = h->direct_den[col_mv->ref];
    int m = FF_SIGNBIT(col_mv->x);
    pmv_fw->dist = h->dist[1];
    pmv_bw->dist = h->dist[0];
    pmv_fw->ref = 1;
    pmv_bw->ref = 0;
    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
    m = FF_SIGNBIT(col_mv->y);
    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
}","static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,
                                  cavs_vector *col_mv)
{
    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;
    int den = h->direct_den[col_mv->ref];
    int m = FF_SIGNBIT(col_mv->x);
    pmv_fw->dist = h->dist[1];
    pmv_bw->dist = h->dist[0];
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        pmv_fw->ref = 1;
    }
    pmv_bw->ref = 0;
    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
    m = FF_SIGNBIT(col_mv->y);
    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
}",1,0,4,0.09,Replace
924,"static inline void h264_deblock_q1(register vector unsigned char p0,
                                                   register vector unsigned char p1,
                                                   register vector unsigned char p2,
                                                   register vector unsigned char q0,
                                                   register vector unsigned char tc0) {
    register vector unsigned char average = vec_avg(p0, q0);
    register vector unsigned char temp;
    register vector unsigned char uncliped;
    register vector unsigned char ones;
    register vector unsigned char max;
    register vector unsigned char min;
    temp = vec_xor(average, p2);
    average = vec_avg(average, p2);      
    ones = vec_splat_u8(1);
    temp = vec_and(temp, ones);          
    uncliped = vec_subs(average, temp);  
    max = vec_adds(p1, tc0);
    min = vec_subs(p1, tc0);
    p1 = vec_max(min, uncliped);
    p1 = vec_min(max, p1);
}","static inline void h264_deblock_q1(register vector unsigned char p0,
                                                   register vector unsigned char p1,
                                                   register vector unsigned char p2,
                                                   register vector unsigned char q0,
                                                   register vector unsigned char tc0) {
    register vector unsigned char average = vec_avg(p0, q0);
    register vector unsigned char temp;
    register vector unsigned char uncliped;
    size_t vec;
    hwaddr mapped_len = 0;
    mapped_len = vec;
    register vector unsigned char ones;
    struct sk_buff *skb;
    struct rtable *rt = skb_rtable(skb);
    struct net *net;
    net = dev_net(rt->dst.dev);
    register vector unsigned char max;
    register vector unsigned char min;
    temp = vec_xor(average, p2);
    average = vec_avg(average, p2);      
    ones = vec_splat_u8(1);
    int a = 2;
    int b = 2;
    if (a == b) {
        temp = vec_and(temp, ones);          
    }
    uncliped = vec_subs(average, temp);  
    max = vec_adds(p1, tc0);
    min = vec_subs(p1, tc0);
    p1 = vec_max(min, uncliped);
    p1 = vec_min(max, p1);
}",0,1,53,1.39,Insert
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,
                                target_ulong pc2, TCGv r_cond)
{
    int l1;
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);
    gen_goto_tb(dc, 0, pc2, pc1);
    gen_set_label(l1);
    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);
}","static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,
                                target_ulong pc2, TCGv r_cond)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        uint64_t glms;
        unsigned k, b_3, err, C;
        unsigned k, b_3, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_3 = ctz64(glms);
        int l1;
        GF_BitStream *bs;
        GF_Box *s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        gf_bs_write_u16(bs, cap->item_protection_index);
    }
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);
    gen_goto_tb(dc, 0, pc2, pc1);
    gen_set_label(l1);
    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);
}",0,1,44,0.47,Insert
929,"MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,
              CharDriverState *chrA, CharDriverState *chrB,
              int clock, int it_shift)
{
    DeviceState *dev;
    SysBusDevice *s;
    SerialState *d;
    dev = qdev_create(NULL, ""escc"");
    qdev_prop_set_uint32(dev, ""disabled"", 0);
    qdev_prop_set_uint32(dev, ""frequency"", clock);
    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);
    qdev_prop_set_chr(dev, ""chrB"", chrB);
    qdev_prop_set_chr(dev, ""chrA"", chrA);
    qdev_prop_set_uint32(dev, ""chnBtype"", ser);
    qdev_prop_set_uint32(dev, ""chnAtype"", ser);
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irqB);
    sysbus_connect_irq(s, 1, irqA);
    if (base) {
        sysbus_mmio_map(s, 0, base);
    }
    d = FROM_SYSBUS(SerialState, s);
    return &d->mmio;
}","MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,
              CharDriverState *chrA, CharDriverState *chrB,
              int clock, int it_shift)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        DeviceState *dev;
    }
    SysBusDevice *s;
    SerialState *d;
    dev = qdev_create(NULL, ""escc"");
    qdev_prop_set_uint32(dev, ""disabled"", 0);
    qdev_prop_set_uint32(dev, ""frequency"", clock);
    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);
    qdev_prop_set_chr(dev, ""chrB"", chrB);
    qdev_prop_set_chr(dev, ""chrA"", chrA);
    qdev_prop_set_uint32(dev, ""chnBtype"", ser);
    qdev_prop_set_uint32(dev, ""chnAtype"", ser);
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irqB);
    sysbus_connect_irq(s, 1, irqA);
    if (base) {
        sysbus_mmio_map(s, 0, base);
    }
    d = FROM_SYSBUS(SerialState, s);
    return &d->mmio;
}",0,1,1,0.11,Replace
930,"static void free_geotags(TiffContext *const s)
{
    int i;
    for (i = 0; i < s->geotag_count; i++) {
        if (s->geotags[i].val)
            av_freep(&s->geotags[i].val);
    }
    av_freep(&s->geotags);
}","static void free_geotags(TiffContext *const s)
{
    CPULM32State *env;
    int i_7;
    qemu_irq irq[32];
    for (i_7 = 0; i_7 < 32; i_7++) {
            irq[i_7] = qdev_get_gpio_in(env->pic_state, i_7);
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        int i;
        b = a;
    }
    for (i = 0; i < s->geotag_count; i++) {
        if (s->geotags[i].val)
            av_freep(&s->geotags[i].val);
    }
    av_freep(&s->geotags);
}",1,0,6,0.42,Insert
931,"void ff_bink_idct_c(DCTELEM *block)
{
    int i;
    DCTELEM temp[64];
    for (i = 0; i < 8; i++)
        bink_idct_col(&temp[i], &block[i]);
    for (i = 0; i < 8; i++) {
        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );
    }
}","void ff_bink_idct_c(DCTELEM *block)
{
    int i;
    DCTELEM temp[64];
    for (i = 0; i < 8; i++)
        bink_idct_col(&temp[i], &block[i]);
    for (i = 0; i < 8; i++) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            IDCT_ROW( (&block[8*i]), (&temp[8*i]) );
        }
    }
}",1,0,1,0.05,Replace
932,,,,,,,
934,,,,,,,
936,"void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,
                              int width, int y)
{
    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,
                           0, y, 0, 0, 0, 0, width, 1);
}","void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,
                              int width, int y)
{
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i, size, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size   = put_bits_count(&pb) >> 3;
    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,
                           0, y, 0, 0, 0, 0, width, 1);
}",0,1,2,0.24,Insert
938,"static bool ga_open_pidfile(const char *pidfile)
{
    int pidfd;
    char pidstr[32];
    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);
    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {
        g_critical(""Cannot lock pid file, %s"", strerror(errno));
        if (pidfd != -1) {
            close(pidfd);
        }
        return false;
    }
    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {
        g_critical(""Failed to truncate pid file"");
        goto fail;
    }
    sprintf(pidstr, ""%d"", getpid());
    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {
        g_critical(""Failed to write pid file"");
        goto fail;
    }
    return true;
fail:
    unlink(pidfile);
    return false;
}","static bool ga_open_pidfile(const char *pidfile)
{
    int pidfd;
    int a = 2;
    int b = 2;
    while (a == b) {
        char pidstr[32];
        b += 1;
    }
    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);
    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {
        g_critical(""Cannot lock pid file, %s"", strerror(errno));
        if (pidfd != -1) {
            close(pidfd);
        }
        return false;
    }
    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {
        g_critical(""Failed to truncate pid file"");
        goto fail;
    }
    sprintf(pidstr, ""%d"", getpid());
    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {
        g_critical(""Failed to write pid file"");
        goto fail;
    }
    return true;
fail:
    unlink(pidfile);
    return false;
}",0,1,3,0.13,Replace
940,,,,,,,
941,"static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    return offset;
}","static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        txMachine* the;
        txSlot* instance = fxCheckDataViewInstance(the, mxThis);
        if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
        		endian = EndianLittle;
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    int a = 45;
    int b = a;
    if(a*b>0){
        return offset;
    }
}",0,1,25,1.09,Insert
942,"CharDriverState *qemu_chr_alloc(void)
{
    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
    qemu_mutex_init(&chr->chr_write_lock);
    return chr;
}","CharDriverState *qemu_chr_alloc(void)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
    }
    qemu_mutex_init(&chr->chr_write_lock);
    return chr;
}",0,1,2,0.04,Replace
944,"static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *cpu)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        struct qemu_work_item *wi;
    }
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",0,1,1,0.09,Replace
945,,,,,,,
946,,,,,,,
950,"void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        u8 * Datapp;
        struct wmi_disconnect_event *dev;
        dev = (struct wmi_disconnect_event *)  Datapp;
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}",0,1,15,0.2,Insert
952,"static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);","static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        struct vda_context *vda_ctx         = avctx->hwaccel_context;
    }
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);",1,0,1,0.07,Replace
954,,,,,,,
955,,,,,,,
956,,,,,,,
959,,,,,,,
962,"static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)
{
    int i;
    S390PCIBusDevice *pbdev;
    S390pciState *s = s390_get_phb();
    if (!target) {
        return NULL;
    }
    for (i = 0; i < PCI_SLOT_MAX; i++) {
        pbdev = s->pbdev[i];
        if (!pbdev) {
            continue;
        }
        if (!strcmp(pbdev->target, target)) {
            return pbdev;
        }
    }
    return NULL;
}","static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)
{
    int i;
    S390PCIBusDevice *pbdev;
    int a = 2;
    int b = 2;
    if (a == b) {
        S390pciState *s = s390_get_phb();
    }
    if (!target) {
        return NULL;
    }
    for (i = 0; i < PCI_SLOT_MAX; i++) {
        pbdev = s->pbdev[i];
        if (!pbdev) {
            continue;
        }
        if (!strcmp(pbdev->target, target)) {
            return pbdev;
        }
    }
    target_phys_addr_t espaddr;
    SysBusDevice *s_7;
    sysbus_mmio_map(s_7, 0, espaddr);
    return NULL;
}",0,1,21,0.53,Insert
963,"static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)
{
    uint16_t cmd;
    int i, sz, offset, code;
    unsigned char *dst_end = dst + dst_size;
    const unsigned char *src_end = src + src_size;
    while (src < src_end && dst < dst_end) {
        code = *src++;
        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {
            if (code & (1 << i)) {
                *dst++ = *src++;
            } else {
                cmd = AV_RL16(src); src += 2;
                offset = cmd >> 4;
                sz = (cmd & 0xF) + 2;
                sz = FFMIN(sz, dst_end - dst);
                while (sz--) {
                    *dst = *(dst - offset - 1);
                    ++dst;
                }
            }
        }
    }
}","static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)
{
    uint16_t cmd;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int i, sz, offset, code;
    strcpy(str, ""a"");
    }
    unsigned char *dst_end = dst + dst_size;
    const unsigned char *src_end = src + src_size;
    while (src < src_end && dst < dst_end) {
        code = *src++;
        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {
            if (code & (1 << i)) {
                *dst++ = *src++;
            } else {
                cmd = AV_RL16(src); src += 2;
                offset = cmd >> 4;
                sz = (cmd & 0xF) + 2;
                sz = FFMIN(sz, dst_end - dst);
                while (sz--) {
                    *dst = *(dst - offset - 1);
                    ++dst;
                }
            }
        }
    }
}",0,1,1,0.12,Replace
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,
                  void *priv_data, RTPDynamicProtocolHandler *handler)
{
    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));
    if (!s)
        return NULL;
    s->ic = ic;
    s->streams = &ic->streams[first_stream_of_set_idx];
    do {
        s->n_streams++;
    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&
             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);
    s->prev_set_id    = -1;
    s->prev_stream_id = -1;
    s->prev_timestamp = -1;
    s->parse_packet = handler->parse_packet;
    s->dynamic_protocol_context = priv_data;
    return s;
}","ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,
                  void *priv_data, RTPDynamicProtocolHandler *handler)
{
    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));
    if (!s)
        return NULL;
    s->ic = ic;
    s->streams = &ic->streams[first_stream_of_set_idx];
    do {
        s->n_streams++;
    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&
             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);
    s->prev_set_id    = -1;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        s->prev_stream_id = -1;
    }
    s->prev_timestamp = -1;
    s->parse_packet = handler->parse_packet;
    s->dynamic_protocol_context = priv_data;
    return s;
}",1,0,11,0.13,Replace
969,"static int intel_hda_init(PCIDevice *pci)
{
    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);
    uint8_t *conf = d->pci.config;
    d->name = d->pci.qdev.info->name;
    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(conf, 0x2668);
    pci_config_set_revision(conf, 1);
    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);
    pci_config_set_interrupt_pin(conf, 1);
    conf[0x40] = 0x01;
    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,
                                          intel_hda_mmio_write, d,
                                          DEVICE_NATIVE_ENDIAN);
    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);
    if (d->msi) {
        msi_init(&d->pci, 0x50, 1, true, false);
    }
    hda_codec_bus_init(&d->pci.qdev, &d->codecs,
                       intel_hda_response, intel_hda_xfer);
    return 0;
}","static int intel_hda_init(PCIDevice *pci)
{
    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);
    uint8_t *conf = d->pci.config;
    d->name = d->pci.qdev.info->name;
    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(conf, 0x2668);
    pci_config_set_revision(conf, 1);
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);
    pci_config_set_interrupt_pin(conf, 1);
    conf[0x40] = 0x01;
    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,
                                          intel_hda_mmio_write, d,
                                          DEVICE_NATIVE_ENDIAN);
    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);
    if (d->msi) {
        msi_init(&d->pci, 0x50, 1, true, false);
    }
    hda_codec_bus_init(&d->pci.qdev, &d->codecs,
                       intel_hda_response, intel_hda_xfer);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,35,0.92,Insert
970,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    RawAIOCB *acb;
    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);
    if (!acb)
        return NULL;
    if (qemu_paio_write(&acb->aiocb) < 0) {
        raw_aio_remove(acb);
        return NULL;
    }
    return &acb->common;
}","static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    RawAIOCB *acb;
    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    if (!acb)
        return NULL;
    if (qemu_paio_write(&acb->aiocb) < 0) {
        raw_aio_remove(acb);
        return NULL;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return &acb->common;
        b += 1;
    }
}",0,1,16,0.58,Insert
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}","static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    int a = 63;
    int b = a;
    if(a*b>0){
        uint32_t ret;
    }
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}",0,1,2,0.11,Replace
973,"static void bdrv_throttle_write_timer_cb(void *opaque)
{
    BlockDriverState *bs = opaque;
    qemu_co_enter_next(&bs->throttled_reqs[1]);
}","static void bdrv_throttle_write_timer_cb(void *opaque)
{
    int a = 29;
    int b = a;
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    if(a*b>0){
        BlockDriverState *bs = opaque;
    }
    qemu_co_enter_next(&bs->throttled_reqs[1]);
}",0,1,16,0.3,Insert
975,"static int kvm_put_xcrs(CPUState *env)
{
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.nr_xcrs = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
#else
    return 0;
#endif
}","static int kvm_put_xcrs(CPUState *env)
{
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.nr_xcrs = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    int a = 2;
    int b = 3;
    if (a != b) {
        return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
    }
#else
    return 0;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
#endif
}",0,1,19,0.34,Insert
977,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)
{
    uint32_t val = pci_default_read_config(d, address, len);
#ifdef TARGET_WORDS_BIGENDIAN
    val = bswap32(val);
#endif
    return val;
}","static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)
{
    int a = 2;
    int b = 3;
    GF_Box *s;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
    gf_bs_write_int(bs, 0x7, 3);
    gf_bs_write_int(bs, ch, 5);
    gf_bs_write_u8(bs, ch);
    while (a < b) {
        uint32_t val = pci_default_read_config(d, address, len);
        b = a;
    }
#ifdef TARGET_WORDS_BIGENDIAN
const char
    *attribute,
    *content;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
char
    *p,
    *xml;
double
    value;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
content=GetXMLTreeContent(description);
content=GetXMLTreeContent(levels);
value=InterpretLocaleValue(content,&p);
    val = bswap32(val);
#endif
size_t vec;
hwaddr mapped_len = 0;
mapped_len = vec;
    return val;
}",0,1,75,0.75,Insert
978,,,,,,,
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        return;
    }
    block_job_set_speed(job, speed, errp);
}","void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    int a = 65;
    int b = a;
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    if(a*b>0){
        BlockJob *job = find_block_job(device);
    }
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        return;
    }
    block_job_set_speed(job, speed, errp);
}",0,1,15,0.48,Insert
983,"static abi_long do_socket(int domain, int type, int protocol)
{
    int target_type = type;
    int ret;
    ret = target_to_host_sock_type(&type);
    if (ret) {
        return ret;
    }
    if (domain == PF_NETLINK)
        return -TARGET_EAFNOSUPPORT;
    if (domain == AF_PACKET ||
        (domain == AF_INET && type == SOCK_PACKET)) {
        protocol = tswap16(protocol);
    }
    ret = get_errno(socket(domain, type, protocol));
    if (ret >= 0) {
        ret = sock_flags_fixup(ret, target_type);
        if (type == SOCK_PACKET) {
            fd_trans_register(ret, &target_packet_trans);
        }
    }
    return ret;
}","static abi_long do_socket(int domain, int type, int protocol)
{
    const char *filename;
    int64_t parent;
    int ecd;
    ecd = open(filename, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    int target_type = type;
    int ret;
    ret = target_to_host_sock_type(&type);
    if (ret) {
        return ret;
    }
    if (domain == PF_NETLINK)
        return -TARGET_EAFNOSUPPORT;
    if (domain == AF_PACKET ||
        (domain == AF_INET && type == SOCK_PACKET)) {
        protocol = tswap16(protocol);
    }
    ret = get_errno(socket(domain, type, protocol));
    if (ret >= 0) {
        ret = sock_flags_fixup(ret, target_type);
        if (type == SOCK_PACKET) {
            fd_trans_register(ret, &target_packet_trans);
        }
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return ret;
    }
}",0,1,20,0.94,Insert
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *cs = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    struct kvm_ppc_pvinfo pvinfo;
    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
        memcpy(buf, pvinfo.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    gf_bs_read_u8(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    CPUState *cs = CPU(cpu);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        uint32_t *hc = (uint32_t*)buf;
    }
    struct kvm_ppc_pvinfo pvinfo;
    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
        memcpy(buf, pvinfo.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}",0,1,26,0.72,Insert
985,,,,,,,
990,"void qemu_coroutine_delete(Coroutine *co_)
{
    CoroutineThreadState *s = coroutine_get_thread_state();
    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);
    if (s->pool_size < POOL_MAX_SIZE) {
        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);
        co->base.caller = NULL;
        s->pool_size++;
        return;
    }
    g_free(co->stack);
    g_free(co);
}","void qemu_coroutine_delete(Coroutine *co_)
{
    CoroutineThreadState *s = coroutine_get_thread_state();
    int a = 2;
    int b = 3;
    while (a < b) {
        CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);
        b = a;
    }
    struct PCIDevice *pci_dev;
    int r;
    AssignedDevice *Dev = DO_UPCAST_5(AssignedDevice, Dev, pci_dev);
    AssignedDevice *Dev = DO_UPCAST_5(AssignedDevice, Dev, pci_dev);
    r = assign_device(Dev);
    r = assign_intx(Dev);
    assigned_dev_load_option_rom(Dev);
    add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
    if (s->pool_size < POOL_MAX_SIZE) {
        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);
        co->base.caller = NULL;
        s->pool_size++;
        return;
    }
    g_free(co->stack);
    g_free(co);
}",0,1,21,0.6,Insert
991,"int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )
{
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        float_raise( float_flag_invalid STATUS_VAR);
        return 0;
    }
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
}","int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )
{
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    stonith_event_t *e;
    char *sub = g_strdup_printf(
            ""Operation %s requested by %s for peer %s: %s (ref=%s)"",
            e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id);
    g_free(sub);
    RCore *model_10;
    RAnalEsil *esil_2 = model_10->anal->esil_2;
    RAnalEsil *esil_2 = model_10->anal->esil_2;
    RAnalEsilSession *before_5 = (RAnalEsilSession *) tail_4->data;
    eprintf_9 (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set_1 (esil_2, before_5);
    r_core_esil_step_4 (model_10, end_2, NULL, &prev_6, false);
    r_anal_esil_session_set_1 (esil_2, before_5);
    r_core_esil_step_4 (model_10, prev_6, NULL, NULL, false);
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        float_raise( float_flag_invalid STATUS_VAR);
        return 0;
    }
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
    }
}",0,1,76,0.73,Insert
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,
                        uint8_t *buf, int len, int is_write)
{
    int l;
    target_phys_addr_t phys_addr;
    target_ulong page;
    while (len > 0) {
        page = addr & TARGET_PAGE_MASK;
        phys_addr = cpu_get_phys_page_debug(env, page);
        if (phys_addr == -1)
            return -1;
        l = (page + TARGET_PAGE_SIZE) - addr;
        if (l > len)
            l = len;
        phys_addr += (addr & ~TARGET_PAGE_MASK);
        if (is_write)
            cpu_physical_memory_write_rom(phys_addr, buf, l);
        else
            cpu_physical_memory_rw(phys_addr, buf, l, is_write);
        len -= l;
        buf += l;
        addr += l;
    }
    return 0;
}","int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,
                        uint8_t *buf, int len, int is_write)
{
    int l;
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf_3;
    emulated_edge_mc(buf_3, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    target_phys_addr_t phys_addr;
    target_ulong page;
    while (len > 0) {
        page = addr & TARGET_PAGE_MASK;
        int a = 2;
        int b = 3;
        while (a < b) {
            phys_addr = cpu_get_phys_page_debug(env, page);
            b = a;
        }
        if (phys_addr == -1)
            return -1;
        l = (page + TARGET_PAGE_SIZE) - addr;
        if (l > len)
            l = len;
        phys_addr += (addr & ~TARGET_PAGE_MASK);
        if (is_write)
            cpu_physical_memory_write_rom(phys_addr, buf, l);
        else
            cpu_physical_memory_rw(phys_addr, buf, l, is_write);
        len -= l;
        buf += l;
        addr += l;
    }
    return 0;
}",0,1,23,0.86,Insert
994,"struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,
                target_phys_addr_t base,
                qemu_irq *irq, qemu_irq dma, omap_clk clk)
{
    struct omap_uwire_s *s = (struct omap_uwire_s *)
            g_malloc0(sizeof(struct omap_uwire_s));
    s->txirq = irq[0];
    s->rxirq = irq[1];
    s->txdrq = dma;
    omap_uwire_reset(s);
    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);
    memory_region_add_subregion(system_memory, base, &s->iomem);
    return s;
}","struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,
                target_phys_addr_t base,
                qemu_irq *irq, qemu_irq dma, omap_clk clk)
{
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    struct omap_uwire_s *s = (struct omap_uwire_s *)
            g_malloc0(sizeof(struct omap_uwire_s));
            Network::ConnectionEvent id;
            ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                             static_cast<int>(id), upstream_ == nullptr);
    s->txirq = irq[0];
    s->rxirq = irq[1];
    s->txdrq = dma;
    omap_uwire_reset(s);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);
    strcpy(str, ""a"");
    }
    memory_region_add_subregion(system_memory, base, &s->iomem);
    return s;
}",0,1,45,0.6,Insert
998,"float32 HELPER(ucf64_abss)(float32 a)
{
    return float32_abs(a);
}","float32 HELPER(ucf64_abss)(float32 a)
{
    int a_1 = 42;
    int b_1 = a_1;
    unsigned long flags;
    struct sas_task *task = slow->task;
    spin_lock_irqsave(&task->task_state_lock, flags);
    spin_unlock_irqrestore(&task->task_state_lock, flags);
    if(a_1*b_1>0){
        return float32_abs(a);
    }
}",0,1,19,0.29,Insert
999,"int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)
{
   return pthread_equal(thread1->thread, thread2->thread);
}","int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)
{
   int a = 86;
   int b = a;
   if(a*b>0){
       return pthread_equal(thread1->thread, thread2->thread);
   }
}",0,1,2,0.03,Replace
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    gen_string_movl_A0_ESI(s);
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}","static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    if (use_icount)
        gen_io_start();
    gen_string_movl_A0_ESI(s);
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}",0,1,18,0.55,Insert
1004,"static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,
                                       const uint8_t *key, size_t nkey,
                                       Error **errp)
{
    QCryptoCipherBuiltin *ctxt;
    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {
        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);
        return -1;
    }
    ctxt = g_new0(QCryptoCipherBuiltin, 1);
    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);
    memcpy(ctxt->state.desrfb.key, key, nkey);
    ctxt->state.desrfb.nkey = nkey;
    ctxt->free = qcrypto_cipher_free_des_rfb;
    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;
    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;
    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;
    cipher->opaque = ctxt;
    return 0;
}","static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,
                                       const uint8_t *key, size_t nkey,
                                       Error **errp)
{
    QCryptoCipherBuiltin *ctxt;
    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {
        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);
        return -1;
    }
    ctxt = g_new0(QCryptoCipherBuiltin, 1);
    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);
    memcpy(ctxt->state.desrfb.key, key, nkey);
    ctxt->state.desrfb.nkey = nkey;
    ctxt->free = qcrypto_cipher_free_des_rfb;
    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;
    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;
    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;
    int a = 2;
    int b = 2;
    while (a == b) {
        cipher->opaque = ctxt;
        b += 1;
    }
    return 0;
}",1,0,3,0.12,Replace
1006,"static void vnc_client_cache_addr(VncState *client)
{
    Error *err = NULL;
    client->info = g_malloc0(sizeof(*client->info));
    client->info->base = g_malloc0(sizeof(*client->info->base));
    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,
                                         &err);
    if (err) {
        qapi_free_VncClientInfo(client->info);
        client->info = NULL;
        error_free(err);
    }
}","static void vnc_client_cache_addr(VncState *client)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        Error *err = NULL;
        b = a;
    }
    client->info = g_malloc0(sizeof(*client->info));
    client->info->base = g_malloc0(sizeof(*client->info->base));
    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,
                                         &err);
    if (err) {
        qapi_free_VncClientInfo(client->info);
        client->info = NULL;
        error_free(err);
    }
}",0,1,1,0.07,Replace
1007,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)
{
    return kvm_irqchip_assign_irqfd(s, fd, virq, true);
}","int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        return kvm_irqchip_assign_irqfd(s, fd, virq, true);
    }
}",0,1,1,0.03,Replace
1008,"static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)
{
    CharDriverState *chr = opaque;
    NetCharDriver *s = chr->opaque;
    gsize bytes_read = 0;
    GIOStatus status;
    if (s->max_size == 0)
        return FALSE;
    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),
                                     &bytes_read, NULL);
    s->bufcnt = bytes_read;
    s->bufptr = s->bufcnt;
    if (status != G_IO_STATUS_NORMAL) {
        return FALSE;
    }
    s->bufptr = 0;
    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
        s->bufptr++;
        s->max_size = qemu_chr_be_can_write(chr);
    }
    return TRUE;
}","static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)
{
    CharDriverState *chr = opaque;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        NetCharDriver *s = chr->opaque;
    strcpy(str, ""a"");
    }
    gsize bytes_read = 0;
    GIOStatus status;
    if (s->max_size == 0)
        return FALSE;
    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),
                                     &bytes_read, NULL);
    s->bufcnt = bytes_read;
    s->bufptr = s->bufcnt;
    if (status != G_IO_STATUS_NORMAL) {
        return FALSE;
    }
    s->bufptr = 0;
    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
        s->bufptr++;
        s->max_size = qemu_chr_be_can_write(chr);
    }
    return TRUE;
}",0,1,23,0.25,Replace
1010,"static int raw_init_encoder(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    avctx->coded_frame->pict_type = FF_I_TYPE;
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}","static int raw_init_encoder(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    int a = 2;
    int b = 2;
    const uint8_t *data;
    int size;
    AVCodecParserContext *ctx;
    VP9ParseContext *s = ctx->priv_data;
    parse_frame(ctx, data, size);
    if (a == b) {
        avctx->coded_frame->pict_type = FF_I_TYPE;
    }
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}",0,1,38,0.43,Insert
1012,,,,,,,
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
}","void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    XMLTreeInfo
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_prop_set_uint32(mem, ""num-cpu"", smp_cpus);
    qdev_prop_set_uint32(mem, ""num-irq"", NIRQ_GIC);
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    mem = qdev_create(NULL, ""sp804"");
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
        SysBusDevice *b_10;
        if (i) {
                sysbus_mmio_map(b_10, 0, i);
        }
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    int a = 2;
    int b = 2;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    while (a == b) {
        avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
        b += 1;
    }
}",0,1,121,0.91,Insert
1014,"static int film_probe(AVProbeData *p)
{
    if (p->buf_size < 4)
        return 0;
    if (AV_RB32(&p->buf[0]) != FILM_TAG)
        return 0;
    return AVPROBE_SCORE_MAX;
}","static int film_probe(AVProbeData *p)
{
    if (p->buf_size < 4)
        return 0;
    if (AV_RB32(&p->buf[0]) != FILM_TAG)
        return 0;
        struct fp *fp;
        int diff;
        diff = -1;
        int pet;
        pet = seq_open(fp, &show_traces_seq_ops);
    int a = 2;
    int b = 3;
    while (a < b) {
        return AVPROBE_SCORE_MAX;
        b = a;
    }
}",0,1,45,0.55,Insert
1015,"static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,
                       unsigned int size, int mem_index)
{
    int l1 = gen_new_label();
    TCGv taddr = tcg_temp_local_new();
    TCGv tval = tcg_temp_local_new();
    TCGv t1 = tcg_temp_local_new();
    dc->postinc = 0;
    cris_evaluate_flags(dc);
    tcg_gen_mov_tl(taddr, addr);
    tcg_gen_mov_tl(tval, val);
    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);
    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);
    if (size == 1) {
        tcg_gen_qemu_st8(tval, taddr, mem_index);
    } else if (size == 2) {
        tcg_gen_qemu_st16(tval, taddr, mem_index);
    } else {
        tcg_gen_qemu_st32(tval, taddr, mem_index);
    }
    gen_set_label(l1);
    tcg_gen_shri_tl(t1, t1, 1);   
    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1);  
    tcg_temp_free(t1);
    tcg_temp_free(tval);
    tcg_temp_free(taddr);
}","static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,
                       unsigned int size, int mem_index)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int l1 = gen_new_label();
    }
    TCGv taddr = tcg_temp_local_new();
    TCGv tval = tcg_temp_local_new();
    TCGv t1 = tcg_temp_local_new();
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    			struct videobuf_buffer *vb;
    			struct videbuf_vmalloc_memory *mem=vb->priv;
    			int pages;
    			struct videbuf_vmalloc_memory *mem=vb->priv;
    			pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
    			dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
    			"",
    							(unsigned long)mem->vmalloc,
    							pages << PAGE_SHIFT);
    dc->postinc = 0;
    AVPacket * pk;
    AVFormatContext *s;
    int size_10               =  pk->size_10;
    AVIOContext *b     = s->b;
    if (size_10 & 1)
            avio_w8(b, 0);
    cris_evaluate_flags(dc);
    tcg_gen_mov_tl(taddr, addr);
    VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
    uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size_1;
    internal_buf->chunk_header.port = VDP_SERVER_PORT;
    internal_buf->chunk_header.size_1 = sizeof(VDAgentMessage) + size_1;
    internal_buf->header.protocol = VD_AGENT_PROTOCOL;
    internal_buf->header.type = type;
    internal_buf->header.opaque = 0;
    tcg_gen_mov_tl(tval, val);
    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);
    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);
    if (size == 1) {
        tcg_gen_qemu_st8(tval, taddr, mem_index);
    } else if (size == 2) {
        tcg_gen_qemu_st16(tval, taddr, mem_index);
    } else {
        tcg_gen_qemu_st32(tval, taddr, mem_index);
    }
    gen_set_label(l1);
    tcg_gen_shri_tl(t1, t1, 1);   
    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1);  
    tcg_temp_free(t1);
    tcg_temp_free(tval);
    tcg_temp_free(taddr);
}",0,1,137,1.55,Insert
1016,"static void ide_trim_bh_cb(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.cb(iocb->common.opaque, iocb->ret);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}","static void ide_trim_bh_cb(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    int a = 2;
    int b = 3;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    if (a != b) {
        iocb->common.cb(iocb->common.opaque, iocb->ret);
    }
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}",0,1,14,0.35,Insert
1018,"static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)
{
    InputStream        *ist = s->opaque;
    DXVA2Context       *ctx = ist->hwaccel_ctx;
    int                ret;
    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);
    if (ret < 0)
        return ret;
    ret = av_frame_copy_props(ctx->tmp_frame, frame);
    if (ret < 0) {
        av_frame_unref(ctx->tmp_frame);
        return ret;
    }
    av_frame_unref(frame);
    av_frame_move_ref(frame, ctx->tmp_frame);
    return 0;
}","static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)
{
    InputStream        *ist = s->opaque;
    int a = 30;
    int b = a;
    if(a*b>0){
        DXVA2Context       *ctx = ist->hwaccel_ctx;
    }
    int                ret;
    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);
    const AVFrame *capt;
    struct hid_driver *hderver;
    int ret_3;
    ret_3 = driver_register(&hderver->driver);
    ret_3 = driver_create_file(&hderver->driver, &driver_attr_new_id);
    const AVFrame *const p = capt;
    uint8_t *cur  = NULL;
    cur  = p->data[0];
    if (ret < 0)
        return ret;
    ret = av_frame_copy_props(ctx->tmp_frame, frame);
    if (ret < 0) {
        av_frame_unref(ctx->tmp_frame);
        return ret;
    }
    av_frame_unref(frame);
    av_frame_move_ref(frame, ctx->tmp_frame);
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    return 0;
}",0,1,82,0.79,Insert
1021,"static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)
{
    int i;
    int vlc    = get_bits1(&q->gb);
    int start  = cplband[p->js_subband_start];
    int end    = cplband[p->subbands - 1];
    int length = end - start + 1;
    if (start > end)
        return;
    if (vlc)
        for (i = 0; i < length; i++)
            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);
    else
        for (i = 0; i < length; i++)
            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);
}","static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)
{
    int i;
    int vlc    = get_bits1(&q->gb);
    int a = 2;
    int b = 3;
    if (a != b) {
        int start  = cplband[p->js_subband_start];
    }
    int end    = cplband[p->subbands - 1];
    int length = end - start + 1;
    if (start > end)
        return;
    if (vlc)
        for (i = 0; i < length; i++)
            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);
    else
        for (i = 0; i < length; i++)
            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);
}",0,1,6,0.11,Replace
1022,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)
{
    int ret;
    FailingMuxerPacketData *data = av_malloc(sizeof(*data));
    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));
    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));
    pkt->pts = pkt->dts = pts;
    pkt->duration = 1;
    return ret;","static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)
{
    int ret;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        FailingMuxerPacketData *data = av_malloc(sizeof(*data));
    }
    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));
    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));
    pkt->pts = pkt->dts = pts;
    pkt->duration = 1;
    return ret;",1,0,4,0.07,Replace
1024,"static int get_pcm(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int x_pu             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}","static int get_pcm(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    char str[] = ""Constant"";
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i, size, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size   = put_bits_count(&pb) >> 3;
    if (strlen(str) > 0) {
        int x_pu             = x >> log2_min_pu_size;
    }
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}",0,1,13,0.44,Insert
1026,,,,,,,
1032,"static inline int cris_addc_pi_m(int a, int **b)
{
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	return a;
}","static inline int cris_addc_pi_m(int a, int **b)
{
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	opj_image_t *crop;
	int *d0, *d1, *d2, *r, *g, *b_8;
	int *d0, *d1, *d2, *r, *g, *b_8;
	unsigned int maxw, maxh, range;
	d2 = b_8 = (int*)malloc(sizeof(int) * (size_t)range);
	crop->comps[2].data = d2;
	char str_1[] = ""Constant"";
	if (strlen(str_1) > 0) {
    	return a;
	}
}",1,0,3,0.17,Insert
1033,"static void vmgenid_query_monitor_test(void)
{
    QemuUUID expected, measured;
    gchar *cmd;
    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);
    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""
                          ""guid=%s"", VGID_GUID);
    qtest_start(cmd);
    read_guid_from_monitor(&measured);
    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
    qtest_quit(global_qtest);
    g_free(cmd);
}","static void vmgenid_query_monitor_test(void)
{
    const char *function;
    const char *type;
    struct keyring_index_key index_key = {
    		.function	= function,
    	};
    if (!index_key.type->match || !index_key.type->instantiate ||
     	    (!index_key.function && !index_key.type->preparse))
     		goto error_put_type;
    QemuUUID expected, measured;
    gchar *cmd;
    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);
    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""
                          ""guid=%s"", VGID_GUID);
    qtest_start(cmd);
    int a = 2;
    int b = 2;
    while (a == b) {
        read_guid_from_monitor(&measured);
        b += 1;
    }
    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
    qtest_quit(global_qtest);
    g_free(cmd);
}",1,0,17,0.58,Insert
1039,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)
{
    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);
    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
                    offsetof(CPUX86State,segs[seg_reg].selector));
    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
                  offsetof(CPUX86State,segs[seg_reg].base));
}","static inline void gen_op_movl_seg_T0_vm(int seg_reg)
{
    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);
    RAMBlock *news_work;
    if (host) {
            news_work->flags |= RAM_PREALLOC;
    }
    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
                    offsetof(CPUX86State,segs[seg_reg].selector));
                    int C, len, vv;
                    len = 0;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        BlockDriverState *bos;
        if (Pbes) {
                *Pbes = bos;
        }
        tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        quantization_tables=NewXMLTree(xml,exception);
        quantization_tables=DestroyXMLTree(quantization_tables);
    strcpy(str, ""a"");
    uint32_t ings;
    MessageWriter exec;
    exec.Push<uint32_t>(ings);
    }
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (!saved_server_config_defines) {
            init_config_defines(cli->pool);
    }
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
                  offsetof(CPUX86State,segs[seg_reg].base));
}",0,1,156,1.01,Insert
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int d1, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}","static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int d1, d2;
    int rnd_part1 = -5;
    int rnd_part2 = 6;
    int rnd = rnd_part1 + rnd_part2;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}",1,0,5,0.12,Replace
1043,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)
{
    MSDState *s = DO_UPCAST(MSDState, dev, dev);
    usb_desc_create_serial(dev);
    usb_desc_init(dev);
    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),
                 &usb_msd_scsi_info_bot, NULL);
    s->bus.qbus.allow_hotplug = 0;
    usb_msd_handle_reset(dev);
}","static void usb_msd_realize_bot(USBDevice *dev, Error **errp)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        MSDState *s = DO_UPCAST(MSDState, dev, dev);
    }
    usb_desc_create_serial(dev);
    usb_desc_init(dev);
    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),
                 &usb_msd_scsi_info_bot, NULL);
    s->bus.qbus.allow_hotplug = 0;
    usb_msd_handle_reset(dev);
}",1,0,1,0.05,Replace
1045,,,,,,,
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}","static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}",1,0,4,0.14,Insert
1050,,,,,,,
1051,,,,,,,
1055,,,,,,,
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	char str1[] = ""Constant"";
	DCTELEM *type;
	int i_8;
	DCTELEM zip[64];
	for (i_8 = 0; i_8 < 8; i_8++)
	        bink_idct_col(&zip[i_8], &type[i_8]);
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	unsigned num_pixels = src_size >> 1;
	}
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}",1,0,21,0.68,Insert
1057,,,,,,,
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)
{
    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };
    int i;
    int bit     = 0;
    int bits    = 0;
    int prevbit = 0;
    unsigned val;
    for (i = 0; i < 7; i++) {
        if (prevbit && bit)
            break;
        prevbit = bit;
        bit = get_bits1(gb);
        if (bit && !prevbit)
            bits += series[i];
    }
    bits--;
    if (bits < 0 || bits > 31) {
        *value = 0;
        return -1;
    } else if (bits == 0) {
        *value = 0;
        return 0;
    }
    val  = get_bits_long(gb, bits);
    val |= 1 << bits;
    *value = val - 1;
    return 0;
}","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)
{
    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };
    int i;
    int bit     = 0;
    int bits    = 0;
    int prevbit = 0;
    unsigned val;
    for (i = 0; i < 7; i++) {
        if (prevbit && bit)
            break;
        prevbit = bit;
        bit = get_bits1(gb);
        if (bit && !prevbit)
            bits += series[i];
    }
    bits--;
    if (bits < 0 || bits > 31) {
        *value = 0;
        return -1;
    } else if (bits == 0) {
        *value = 0;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return 0;
        }
    }
    val  = get_bits_long(gb, bits);
    val |= 1 << bits;
    *value = val - 1;
    return 0;
}",1,0,5,0.17,Replace
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    Error *errp = NULL;
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}","static void test_validate_fail_union_flat(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    Error *errp = NULL;
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    }
    g_assert(error_is_set(&errp));
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    qapi_free_UserDefFlatUnion(tmp);
}",0,1,21,0.43,Insert
1061,"void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)
{
#if defined(DEBUG_MMU)
    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);
#endif
    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=
        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {
        tlb_flush(env, 1);
    }
    if (!(env->cpuid_features & CPUID_SSE))
        new_cr4 &= ~CR4_OSFXSR_MASK;
    if (new_cr4 & CR4_OSFXSR_MASK)
        env->hflags |= HF_OSFXSR_MASK;
    else
        env->hflags &= ~HF_OSFXSR_MASK;
    env->cr[4] = new_cr4;
}","void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)
{
#if defined(DEBUG_MMU)
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);
    }
#endif
    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=
    bool human;
    TestOutputVisitorData *data;
    data->human = human;
    data->sov = string_output_visitor_new(human);
    g_assert(data->sov);
    data->ov = string_output_get_visitor(data->sov);
    g_assert(data->ov);
        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {
        tlb_flush(env, 1);
        rdpTransport* interort;
        int source;
        status = transport_read(interort, interort->ReceiveBuffer)sourceus = transport_read(interort, interort->ReceiveBuffer);
        Stream_Seek(interort->ReceiveBuffer, source);
    }
    if (!(env->cpuid_features & CPUID_SSE))
        new_cr4 &= ~CR4_OSFXSR_MASK;
    if (new_cr4 & CR4_OSFXSR_MASK)
        env->hflags |= HF_OSFXSR_MASK;
    else
        env->hflags &= ~HF_OSFXSR_MASK;
    env->cr[4] = new_cr4;
}",0,1,52,0.68,Insert
1063,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;
    if (fd < 0) {
        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));
        s->file = NULL;
        migrate_fd_error(s);
    } else {
        DPRINTF(""migrate connect success\n"");
        s->file = qemu_fopen_socket(fd, ""wb"");
        migrate_fd_connect(s);
    }
}","static void unix_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;
    if (fd < 0) {
        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));
        s->file = NULL;
        migrate_fd_error(s);
    } else {
        DPRINTF(""migrate connect success\n"");
        char str[] = ""Constant"";
        size_t pkt_len;
        int len;
        struct virtio_net_hdr *vhdr;
        uint8_t *data;
        len = pkt_len - vhdr->csum_start;
        stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));
        if (strlen(str) > 0) {
            s->file = qemu_fopen_socket(fd, ""wb"");
        }
        migrate_fd_connect(s);
    }
}",1,0,35,0.59,Insert
1068,,,,,,,
1069,"static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}","static void spapr_cpu_core_host_initfn(Object *obj)
{
    int a = 88;
    int b = a;
    if(a*b>0){
        sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    }
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}",0,1,1,0.05,Replace
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
    }
}","void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        int a = 2;
        int b = 3;
        while (a != b) {
            (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
            b = a;
        }
        size_t vec;
        hwaddr mapped_len = 0;
        mapped_len = vec;
    }
}",0,1,18,0.46,Insert
1072,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int slot = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, slot);
    } else {
        disable_device(s, bsel, slot);
    }
    return 0;
}","int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int slot = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, slot);
    } else {
        disable_device(s, bsel, slot);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,1,0.09,Replace
1073,,,,,,,
1074,"static void test_flush_nodev(void)
{
    QPCIDevice *dev;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}","static void test_flush_nodev(void)
{
    QPCIDevice *dev;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    uint8_t *lon;
    uint32_t type;
    uint16_t syms[1024];
    uint8_t bits[1024];
    int cli;
    uint32_t codes[1024];
    HuffEntry e[1024];
    for (cli = 1023; cli >= 0; cli--) {
            codes[cli] = type >> (32 - e[cli].lon);
            bits[cli]  = e[cli].lon;
            syms[cli]  = e[cli].sym;
            type += 0x80000000u >> (e[cli].lon - 1);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ide_test_quit();
    }
}",1,0,18,0.43,Insert
1075,,,,,,,
1077,"static void compute_frame_duration(int *pnum, int *pden,
                                   AVFormatContext *s, AVStream *st, 
                                   AVCodecParserContext *pc, AVPacket *pkt)
{
    int frame_size;
    *pnum = 0;
    *pden = 0;
    switch(st->codec.codec_type) {
    case CODEC_TYPE_VIDEO:
        *pnum = st->codec.frame_rate_base;
        *pden = st->codec.frame_rate;
        if (pc && pc->repeat_pict) {
            *pden *= 2;
            *pnum = (*pnum) * (2 + pc->repeat_pict);
        }
        break;
    case CODEC_TYPE_AUDIO:
        frame_size = get_audio_frame_size(&st->codec, pkt->size);
        if (frame_size < 0)
            break;
        *pnum = frame_size;
        *pden = st->codec.sample_rate;
        break;
    default:
        break;
    }
}","static void compute_frame_duration(int *pnum, int *pden,
                                   AVFormatContext *s, AVStream *st, 
                                   AVCodecParserContext *pc, AVPacket *pkt)
{
    int frame_size;
    *pnum = 0;
    *pden = 0;
    switch(st->codec.codec_type) {
    case CODEC_TYPE_VIDEO:
        *pnum = st->codec.frame_rate_base;
        *pden = st->codec.frame_rate;
        if (pc && pc->repeat_pict) {
            *pden *= 2;
            *pnum = (*pnum) * (2 + pc->repeat_pict);
        }
        break;
    case CODEC_TYPE_AUDIO:
        frame_size = get_audio_frame_size(&st->codec, pkt->size);
        if (frame_size < 0)
            break;
        *pnum = frame_size;
        *pden = st->codec.sample_rate;
        break;
    default:
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            break;
        strcpy(str, ""a"");
        }
    }
}",0,1,17,0.22,Replace
1079,,,,,,,
1080,"static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)
{
    uint32_t val;
    val = bswap32(cpu_inl(addr & IOPORTS_MASK));
    return val;
}","static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)
{
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_10;
    a_10 = ldb_schema_attribute_by_name(ydm, attr);
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    uint32_t val;
    val = bswap32(cpu_inl(addr & IOPORTS_MASK));
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    gf_bs_write_u16(bs, cap->item_protection_index);
    int a = 2;
    int b = 2;
    if (a == b) {
        return val;
    }
}",0,1,67,0.58,Insert
1081,"static void qemu_fill_buffer(QEMUFile *f)
{
    int len;
    if (f->is_writable)
        return;
    if (f->is_file) {
        fseek(f->outfile, f->buf_offset, SEEK_SET);
        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);
        if (len < 0)
            len = 0;
    } else {
        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,
                         f->buf, IO_BUF_SIZE);
        if (len < 0)
            len = 0;
    }
    f->buf_index = 0;
    f->buf_size = len;
    f->buf_offset += len;
}","static void qemu_fill_buffer(QEMUFile *f)
{
    int len;
    void *opaque;
    PCNetState *qs = opaque;
    pcnet_poll(qs);
    pcnet_update_irq(qs);
    if (f->is_writable)
        return;
    if (f->is_file) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            fseek(f->outfile, f->buf_offset, SEEK_SET);
        }
        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);
        if (len < 0)
            len = 0;
    } else {
        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,
                         f->buf, IO_BUF_SIZE);
        if (len < 0)
            len = 0;
    }
    f->buf_index = 0;
    struct mr6_table *mrt;
    struct mem *mem = read_pnet(&mrt->mem);
    atomic_dec(&mrt->cache_resolve_queue_len);
    f->buf_size = len;
    f->buf_offset += len;
}",0,1,44,0.86,Insert
1085,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)
{
    unsigned int i;
    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)
        qemu_put_be32s(f, &q->queue[i]);
    qemu_put_sbe32s(f, &q->next);
    qemu_put_sbe32s(f, &q->priority);
}","static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        unsigned int i;
    }
    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)
        qemu_put_be32s(f, &q->queue[i]);
    qemu_put_sbe32s(f, &q->next);
    qemu_put_sbe32s(f, &q->priority);
}",0,1,1,0.04,Replace
1087,"static void omap_rtc_reset(struct omap_rtc_s *s)
{
    struct tm tm;
    s->interrupts = 0;
    s->comp_reg = 0;
    s->running = 0;
    s->pm_am = 0;
    s->auto_comp = 0;
    s->round = 0;
    s->tick = qemu_get_clock(rt_clock);
    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));
    s->alarm_tm.tm_mday = 0x01;
    s->status = 1 << 7;
    qemu_get_timedate(&tm, 0);
    s->ti = mktimegm(&tm);
    omap_rtc_alarm_update(s);
    omap_rtc_tick(s);
}","static void omap_rtc_reset(struct omap_rtc_s *s)
{
    struct tm tm;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    s->interrupts = 0;
    s->comp_reg = 0;
    s->running = 0;
    s->pm_am = 0;
    s->auto_comp = 0;
    s->round = 0;
    s->tick = qemu_get_clock(rt_clock);
    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));
    s->alarm_tm.tm_mday = 0x01;
    s->status = 1 << 7;
    qemu_get_timedate(&tm, 0);
    int a = 35;
    int b = a;
    if(a*b>0){
        s->ti = mktimegm(&tm);
    }
    omap_rtc_alarm_update(s);
    omap_rtc_tick(s);
}",0,1,32,0.6,Insert
1089,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    IPMISensor *sens;
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    sens = ibs->sensors + cmd[2];
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);
    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);
}","static void get_sensor_evt_enable(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    IPMISensor *sens;
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    double width, height;
    double width_5, height_1;
    int face_weight_3, surface_height_6;
    cairo_surface_t *surface_7;
    int face_weight_3, surface_height_6;
    cairo_pattern_t *pattern_2;
    surface_height_6 = (int) ceil_9 (height_1);
    surface_7 = cairo_surface_create_similar_2 (cairo_get_target_4 (cairo_7),
    					  CAIRO_CONTENT_COLOR_ALPHA_5,
    					  face_weight_3, surface_height_6);
    cairo_7 = cairo_create_9 (surface_7);
    cairo_surface_destroy_8 (surface_7);
    pattern_2 = cairo_pattern_create_for_surface_2 (cairo_get_target_4 (cairo_7));
    int face_weight, surface_height;
    cairo_surface_t *surface;
    int face_weight, surface_height;
    cairo_pattern_t *pattern;
    surface_height = (int) ceil (height);
    surface = cairo_surface_create_similar (cairo_get_target (cairo),
    					  CAIRO_CONTENT_COLOR_ALPHA,
    					  face_weight, surface_height);
    cairo = cairo_create (surface);
    cairo_surface_destroy (surface);
    pattern = cairo_pattern_create_for_surface (cairo_get_target (cairo));
    sens = ibs->sensors + cmd[2];
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);
    int a = 2;
    int b = 3;
    while (a != b) {
        IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);
        b = a;
    }
    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);
}",1,0,56,0.86,Insert
1090,"struct omap_uart_s *omap_uart_init(hwaddr base,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma,
                const char *label, CharDriverState *chr)
{
    struct omap_uart_s *s = (struct omap_uart_s *)
            g_malloc0(sizeof(struct omap_uart_s));
    s->base = base;
    s->fclk = fclk;
    s->irq = irq;
    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,
                               omap_clk_getrate(fclk)/16,
                               chr ?: qemu_chr_new(label, ""null"", NULL),
                               DEVICE_NATIVE_ENDIAN);
    return s;
}","struct omap_uart_s *omap_uart_init(hwaddr base,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma,
                const char *label, CharDriverState *chr)
{
    struct omap_mmc_s *s_6 = (struct omap_mmc_s *)
                g_malloc0_6(sizeof(struct omap_mmc_s));
    s_6->IRqs = IRqs;
    struct omap_uart_s *s = (struct omap_uart_s *)
            g_malloc0(sizeof(struct omap_uart_s));
    s->base = base;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s->fclk = fclk;
    strcpy(str, ""a"");
    }
    s->irq = irq;
    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,
                               omap_clk_getrate(fclk)/16,
                               chr ?: qemu_chr_new(label, ""null"", NULL),
                               DEVICE_NATIVE_ENDIAN);
    return s;
}",1,0,9,0.62,Insert
1094,,,,,,,
1095,,,,,,,
1097,,,,,,,
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)
{
    LM32JuartState *s = LM32_JUART(d);
    unsigned char ch = jtx & 0xff;
    trace_lm32_juart_set_jtx(s->jtx);
    s->jtx = jtx;
    if (s->chr) {
        qemu_chr_fe_write_all(s->chr, &ch, 1);
    }
}","void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)
{
    LM32JuartState *s = LM32_JUART(d);
    unsigned char ch = jtx & 0xff;
    trace_lm32_juart_set_jtx(s->jtx);
    s->jtx = jtx;
    if (s->chr) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            qemu_chr_fe_write_all(s->chr, &ch, 1);
            AVCodecContext *avctx;
            VC2EncContext *s_3 = avctx->priv_data;
            if (!s_3->slice_args)
                    goto alloc_fail;
        strcpy(str, ""a"");
        }
    }
}",1,0,12,0.48,Insert
1101,"send_msg(
    VSCMsgType type,
    uint32_t reader_id,
    const void *msg,
    unsigned int length
) {
    VSCMsgHeader mhHeader;
    qemu_mutex_lock(&socket_to_send_lock);
    if (verbose > 10) {
        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",
               type, reader_id, length, length);
    }
    mhHeader.type = htonl(type);
    mhHeader.reader_id = 0;
    mhHeader.length = htonl(length);
    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));
    g_byte_array_append(socket_to_send, (guint8 *)msg, length);
    g_idle_add(socket_prepare_sending, NULL);
    qemu_mutex_unlock(&socket_to_send_lock);
    return 0;
}","send_msg(
    VSCMsgType type,
    uint32_t reader_id,
    const void *msg,
    unsigned int length
) {
    VSCMsgHeader mhHeader;
    qemu_mutex_lock(&socket_to_send_lock);
    if (verbose > 10) {
        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",
               type, reader_id, length, length);
    }
    mhHeader.type = htonl(type);
    mhHeader.reader_id = 0;
    mhHeader.length = htonl(length);
    int a = 2;
    int b = 2;
    int* result;
    *result = ret;
    if (a == b) {
        g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));
    }
    g_byte_array_append(socket_to_send, (guint8 *)msg, length);
    g_idle_add(socket_prepare_sending, NULL);
    qemu_mutex_unlock(&socket_to_send_lock);
    return 0;
}",0,1,37,0.74,Insert
1102,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){
    int i, j;
    int dc = (((dctcoef*)block)[0] + 32) >> 6;
    pixel *dst = (pixel*)_dst;
    stride >>= sizeof(pixel)-1;
    for( j = 0; j < 4; j++ )
    {
        for( i = 0; i < 4; i++ )
            dst[i] = av_clip_pixel( dst[i] + dc );
        dst += stride;
    }
}","void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){
    int i, j;
    int dc = (((dctcoef*)block)[0] + 32) >> 6;
    int a = 2;
    int b = 2;
    while (a == b) {
        pixel *dst = (pixel*)_dst;
        b += 1;
    }
    stride >>= sizeof(pixel)-1;
    for( j = 0; j < 4; j++ )
    {
        for( i = 0; i < 4; i++ )
            dst[i] = av_clip_pixel( dst[i] + dc );
        dst += stride;
    }
}",0,1,7,0.09,Replace
1107,"int avfilter_register(AVFilter *filter)
{
    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)
        return -1;
    registered_avfilters[next_registered_avfilter_idx++] = filter;
    return 0;
}","int avfilter_register(AVFilter *filter)
{
    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)
        return -1;
    int a = 2;
    int b = 3;
    CPUState *cpu;
    KVMState *b_2 = kvm_state;
    KVMState *b_2 = kvm_state;
    cpu->kvm_state = b_2;
    if (a != b) {
        registered_avfilters[next_registered_avfilter_idx++] = filter;
    }
    return 0;
}",0,1,5,0.28,Insert
1108,"void qmp_migrate_cancel(Error **errp)
{
    migrate_fd_cancel(migrate_get_current());
}","void qmp_migrate_cancel(Error **errp)
{
    int a = 57;
    int b = a;
    apr_uint64_t *phash;
    gset_decoder *decoder;
    apr_uint64_t flex = 0, fixed = 0, delta;
    apr_uint64_t flex = 0, fixed = 0, delta;
    delta = (flex << decoder->log2p) | fixed;
    *phash = delta + decoder->last_val;
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,
                      ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
                      APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT, 
                      *phash, delta, (int)flex, fixed);
    if(a*b>0){
        migrate_fd_cancel(migrate_get_current());
    }
}",1,0,10,0.29,Insert
1110,,,,,,,
1112,,,,,,,
1113,,,,,,,
1114,,,,,,,
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != CUDA_SUCCESS) {
        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
        return 0;
    }
    return 1;
}","static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != CUDA_SUCCESS) {
        int a = 2;
        int b = 3;
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *cur  = NULL;
        cur  = p->data[0];
        while (a != b) {
            av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
            b = a;
        }
        return 0;
    }
    return 1;
}",0,1,30,0.47,Insert
1118,,,,,,,
1119,,,,,,,
1121,,,,,,,
1123,,,,,,,
1124,"void address_space_destroy_dispatch(AddressSpace *as)
{
    AddressSpaceDispatch *d = as->dispatch;
    memory_listener_unregister(&d->listener);
    g_free(d);
    as->dispatch = NULL;
}","void address_space_destroy_dispatch(AddressSpace *as)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        AddressSpaceDispatch *d = as->dispatch;
    }
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    memory_listener_unregister(&d->listener);
    g_free(d);
    as->dispatch = NULL;
}",0,1,9,0.29,Insert
1125,"mst_fpga_readb(void *opaque, target_phys_addr_t addr)
{
	mst_irq_state *s = (mst_irq_state *) opaque;
	switch (addr) {
	case MST_LEDDAT1:
		return s->leddat1;
	case MST_LEDDAT2:
		return s->leddat2;
	case MST_LEDCTRL:
		return s->ledctrl;
	case MST_GPSWR:
		return s->gpswr;
	case MST_MSCWR1:
		return s->mscwr1;
	case MST_MSCWR2:
		return s->mscwr2;
	case MST_MSCWR3:
		return s->mscwr3;
	case MST_MSCRD:
		return s->mscrd;
	case MST_INTMSKENA:
		return s->intmskena;
	case MST_INTSETCLR:
		return s->intsetclr;
	case MST_PCMCIA0:
		return s->pcmcia0;
	case MST_PCMCIA1:
		return s->pcmcia1;
	default:
		printf(""Mainstone - mst_fpga_readb: Bad register offset ""
			""0x"" TARGET_FMT_plx "" \n"", addr);
	}
	return 0;
}","mst_fpga_readb(void *opaque, target_phys_addr_t addr)
{
	Rocker *r_9;
	DescInfo *info_4;
	char *buf_7 = desc_get_buf_1(info_4, true);
	RockerTlv *tlvs_3[ROCKER_TLV_TX_MAX_6 + 1];
	char *buf_7 = desc_get_buf_1(info_4, true);
	PCIDevice *dev_1 = PCI_DEVICE_9(r_9);
	RockerTlv *tlvs_3[ROCKER_TLV_TX_MAX_6 + 1];
	uint32_t pport_10;
	rocker_tlv_parse_5(tlvs_3, ROCKER_TLV_TX_MAX_6, buf_7, desc_tlv_size_8(info_4));
	pport_10 = rocker_get_pport_by_tx_ring_5(r_9, desc_get_ring_6(info_4));
	mst_irq_state *s = (mst_irq_state *) opaque;
	switch (addr) {
	case MST_LEDDAT1:
		return s->leddat1;
	case MST_LEDDAT2:
		return s->leddat2;
	case MST_LEDCTRL:
		char str[] = ""Constant"";
		const AVFrame *capt;
		const AVFrame *const p = capt;
		uint8_t *last = NULL;
		uint8_t *zero = NULL;
		zero = last = av_mallocz(p->linesize[0]);
		av_freep(&zero);
		av_freep(&zero);
		if (strlen(str) > 0) {
    		return s->ledctrl;
		}
	case MST_GPSWR:
		return s->gpswr;
	case MST_MSCWR1:
		return s->mscwr1;
	case MST_MSCWR2:
		return s->mscwr2;
	case MST_MSCWR3:
		return s->mscwr3;
	case MST_MSCRD:
		return s->mscrd;
	case MST_INTMSKENA:
		return s->intmskena;
	case MST_INTSETCLR:
		struct rose_neigh *client;
		rose_neigh_list           = client;
		return s->intsetclr;
	case MST_PCMCIA0:
		return s->pcmcia0;
	case MST_PCMCIA1:
		return s->pcmcia1;
	default:
		printf(""Mainstone - mst_fpga_readb: Bad register offset ""
			""0x"" TARGET_FMT_plx "" \n"", addr);
	}
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	return 0;
}",0,1,123,1.15,Insert
1126,"static int pci_piix_ide_initfn(PCIIDEState *d)
{
    uint8_t *pci_conf = d->dev.config;
    pci_conf[PCI_CLASS_PROG] = 0x80;  
    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);
    qemu_register_reset(piix3_reset, d);
    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);
    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);
    pci_piix_init_ports(d);
    return 0;
}","static int pci_piix_ide_initfn(PCIIDEState *d)
{
    uint8_t *pci_conf = d->dev.config;
    pci_conf[PCI_CLASS_PROG] = 0x80;  
    int a = 2;
    int b = 3;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs);
    		inter->entries[i].block_size = gf_bs_read_u32(bs);
    }
    while (a < b) {
        pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);
        b = a;
    }
    qemu_register_reset(piix3_reset, d);
    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);
    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);
    pci_piix_init_ports(d);
    return 0;
}",0,1,20,0.57,Insert
1127,"static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    DeviceState *qdev = DEVICE(vpci_dev);
    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);
    DeviceState *vdev = DEVICE(&dev->vdev);
    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);
    virtio_net_set_netclient_name(&dev->vdev, qdev->id,
                                  object_get_typename(OBJECT(qdev)));
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
}","static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        DeviceState *qdev = DEVICE(vpci_dev);
    }
    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);
    DeviceState *vdev = DEVICE(&dev->vdev);
    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);
    virtio_net_set_netclient_name(&dev->vdev, qdev->id,
                                  object_get_typename(OBJECT(qdev)));
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    zval *SIZE, *DIV;
    gdImagePtr im__dsts, img_surface;
    ZEND_FETCH_RESOURCE(img_surface, gdImagePtr, &SIZE, -1, ""Image"", le_gd);
    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
}",0,1,17,0.56,Insert
1129,"static void ehci_free_packet(EHCIPacket *p)
{
    trace_usb_ehci_packet_action(p->queue, p, ""free"");
    if (p->async == EHCI_ASYNC_INFLIGHT) {
        usb_cancel_packet(&p->packet);
        usb_packet_unmap(&p->packet, &p->sgl);
        qemu_sglist_destroy(&p->sgl);
    QTAILQ_REMOVE(&p->queue->packets, p, next);
    usb_packet_cleanup(&p->packet);
    g_free(p);","static void ehci_free_packet(EHCIPacket *p)
{
    trace_usb_ehci_packet_action(p->queue, p, ""free"");
    if (p->async == EHCI_ASYNC_INFLIGHT) {
        int a = 2;
        int b = 3;
        struct sock *km;
        struct flowi6		FL4;
        struct ipv6_pinfo	*np = inet6_sk(km);
        int			addrFtype;
        if (!FL4.flowi6_oif && (addrFtype&IPV6_ADDR_MULTICAST))
        		FL4.flowi6_oif = np->mcast_oif;
        if (a != b) {
            register ssize_t
                i;
            struct jpeg_decompress_struct
                jpg2error;
            Image
                *image;
            jpeg_create_decompress(&jpg2error);
            JPEGSourceManager(&jpg2error,image);
            jpeg_set_marker_processor(&jpg2error,JPEG_COM,ReadComment);
            i=(ssize_t) jpeg_read_header(&jpg2error,TRUE);
            jpg2error.dct_method=JDCT_FLOAT;
            usb_cancel_packet(&p->packet);
        }
        usb_packet_unmap(&p->packet, &p->sgl);
        qemu_sglist_destroy(&p->sgl);
    QTAILQ_REMOVE(&p->queue->packets, p, next);
    usb_packet_cleanup(&p->packet);
    g_free(p);",1,0,43,0.73,Insert
1130,,,,,,,
1131,,,,,,,
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        return !(is_write && mr->readonly);
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    return false;
}","static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        char str[] = ""Constant"";
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i;
        for (i=0;i < inter->nb_entries; i++) {
        		inter->entries[i].block_count = gf_bs_read_u16(bs);
        		inter->entries[i].block_size = gf_bs_read_u32(bs);
        }
        if (strlen(str) > 0) {
            return !(is_write && mr->readonly);
        }
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    return false;
}",0,1,9,0.31,Insert
1135,,,,,,,
1137,"static int esp_pci_scsi_init(PCIDevice *dev)
{
    PCIESPState *pci = PCI_ESP(dev);
    DeviceState *d = DEVICE(dev);
    ESPState *s = &pci->esp;
    uint8_t *pci_conf;
    Error *err = NULL;
    pci_conf = dev->config;
    pci_conf[PCI_INTERRUPT_PIN] = 0x01;
    s->dma_memory_read = esp_pci_dma_memory_read;
    s->dma_memory_write = esp_pci_dma_memory_write;
    s->dma_opaque = pci;
    s->chip_id = TCHI_AM53C974;
    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,
                          ""esp-io"", 0x80);
    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);
    s->irq = pci_allocate_irq(dev);
    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);
    if (!d->hotplugged) {
        scsi_bus_legacy_handle_cmdline(&s->bus, &err);
        if (err != NULL) {
            error_free(err);
            return -1;
        }
    }
    return 0;
}","static int esp_pci_scsi_init(PCIDevice *dev)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        PCIESPState *pci = PCI_ESP(dev);
    }
    DeviceState *d = DEVICE(dev);
    ESPState *s = &pci->esp;
    uint8_t *pci_conf;
    Error *err = NULL;
    pci_conf = dev->config;
    pci_conf[PCI_INTERRUPT_PIN] = 0x01;
    s->dma_memory_read = esp_pci_dma_memory_read;
    s->dma_memory_write = esp_pci_dma_memory_write;
    s->dma_opaque = pci;
    s->chip_id = TCHI_AM53C974;
    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,
                          ""esp-io"", 0x80);
    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);
    s->irq = pci_allocate_irq(dev);
    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);
    if (!d->hotplugged) {
        scsi_bus_legacy_handle_cmdline(&s->bus, &err);
        if (err != NULL) {
            error_free(err);
            return -1;
        }
    }
    return 0;
}",1,0,3,0.14,Replace
1139,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)
{
    return telldir(fs->dir);
}","static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)
{
    int a = 2;
    int b = a;
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data = get_unaligned_le16(settings);
    if(a*b>0){
        return telldir(fs->dir);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i;
        for (i=0;i < inter->nb_entries; i++) {
        		inter->entries[i].block_count = gf_bs_read_u16(bs);
        		inter->entries[i].block_size = gf_bs_read_u32(bs);
        }
    }
}",0,1,47,0.39,Insert
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(obj, name, o_out, &num, &den, &intnum);
    return num*intnum/den;
}","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    int a = 2;
    int b = 3;
    while (a != b) {
        av_get_number(obj, name, o_out, &num, &den, &intnum);
        b = a;
    }
    return num*intnum/den;
}",1,0,11,0.09,Replace
1145,,,,,,,
1146,"static int virtio_serial_init_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    VirtIODevice *vdev;
    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&
        proxy->class_code != PCI_CLASS_DISPLAY_OTHER &&  
        proxy->class_code != PCI_CLASS_OTHERS)           
        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;
    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);
    if (!vdev) {
        return -1;
    }
    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED
                                        ? proxy->serial.max_virtserial_ports + 1
                                        : proxy->nvectors;
    virtio_init_pci(proxy, vdev,
                    PCI_VENDOR_ID_REDHAT_QUMRANET,
                    PCI_DEVICE_ID_VIRTIO_CONSOLE,
                    proxy->class_code, 0x00);
    proxy->nvectors = vdev->nvectors;
    return 0;
}","static int virtio_serial_init_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    VirtIODevice *vdev;
    BlockdevOnError on_source_bug;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs);
    		inter->entries[i].block_size = gf_bs_read_u32(bs);
    }
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&
        proxy->class_code != PCI_CLASS_DISPLAY_OTHER &&  
        proxy->class_code != PCI_CLASS_OTHERS)           
        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;
    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);
    if (!vdev) {
        return -1;
    }
    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED
                                        ? proxy->serial.max_virtserial_ports + 1
                                        : proxy->nvectors;
    virtio_init_pci(proxy, vdev,
                    PCI_VENDOR_ID_REDHAT_QUMRANET,
                    PCI_DEVICE_ID_VIRTIO_CONSOLE,
                    proxy->class_code, 0x00);
    proxy->nvectors = vdev->nvectors;
    int a = 2;
    int b = 3;
    if (a != b) {
        return 0;
    }
}",0,1,73,0.99,Insert
1147,"static CharDriverState *qmp_chardev_open_serial(const char *id,
                                                ChardevBackend *backend,
                                                ChardevReturn *ret,
                                                Error **errp)
{
    ChardevHostdev *serial = backend->serial;
    int fd;
    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);
    if (fd < 0) {
        return NULL;
    }
    qemu_set_nonblock(fd);
    return qemu_chr_open_tty_fd(fd);
}","static CharDriverState *qmp_chardev_open_serial(const char *id,
                                                ChardevBackend *backend,
                                                ChardevReturn *ret,
                                                Error **errp)
{
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    int a = 74;
    int b = a;
    if(a*b>0){
        ChardevHostdev *serial = backend->serial;
    }
    int fd;
    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);
    if (fd < 0) {
        return NULL;
    }
    qemu_set_nonblock(fd);
    return qemu_chr_open_tty_fd(fd);
}",0,1,18,0.45,Insert
1148,"void alpha_pci_vga_setup(PCIBus *pci_bus)
{
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(pci_bus, -1, ""qxl-vga"");
        return;
#endif
    case VGA_CIRRUS:
        pci_cirrus_vga_init(pci_bus);
        return;
    case VGA_VMWARE:
        if (pci_vmsvga_init(pci_bus)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(pci_bus);
    }
}","void alpha_pci_vga_setup(PCIBus *pci_bus)
{
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    gf_bs_read_u8(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        int a = 2;
        int b = 2;
        if (a == b) {
            pci_create_simple(pci_bus, -1, ""qxl-vga"");
        }
        return;
#endif
    case VGA_CIRRUS:
        pci_cirrus_vga_init(pci_bus);
        return;
    case VGA_VMWARE:
        if (pci_vmsvga_init(pci_bus)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(pci_bus);
    }
}",0,1,16,0.47,Insert
1149,"struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)
{
    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);
    struct omap_uart_s *s = omap_uart_init(base, irq,
                    fclk, iclk, txdma, rxdma, chr);
    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,
                    omap_uart_writefn, s);
    s->ta = ta;
    s->base = base;
    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);
    return s;
}","struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)
{
    int a = 2;
    int b = 2;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    struct f *f;
    int rt;
    if (rt == 1) {
    		ClearPagePrivate(f);
    		set_page_private(f, 0);
    		page_cache_release(f);
    }
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (a == b) {
        target_phys_addr_t base = omap_l4_attach(ta, 0, 0);
    }
    struct omap_uart_s *s = omap_uart_init(base, irq,
                    fclk, iclk, txdma, rxdma, chr);
    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,
                    omap_uart_writefn, s);
    s->ta = ta;
    s->base = base;
    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);
    return s;
}",0,1,43,0.79,Insert
1151,"static void coroutine_fn bdrv_create_co_entry(void *opaque)
{
    Error *local_err = NULL;
    int ret;
    CreateCo *cco = opaque;
    assert(cco->drv);
    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);
    if (local_err) {
        error_propagate(&cco->err, local_err);
    }
    cco->ret = ret;
}","static void coroutine_fn bdrv_create_co_entry(void *opaque)
{
    Error *local_err = NULL;
    int ret;
    CreateCo *cco = opaque;
    assert(cco->drv);
    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);
    if (local_err) {
        error_propagate(&cco->err, local_err);
    }
    BDRVSheepdogState *sis;
    SheepdogObjReq hdr;
    int nr_copies = sis->inode.nr_copies;
    int nr_copies = sis->inode.nr_copies;
    hdr.copies = sis->inode.nr_copies;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        cco->ret = ret;
    strcpy(str, ""a"");
    }
}",0,1,17,0.43,Insert
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
}","static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
        b += 1;
    }
}",1,0,1,0.03,Replace
1154,,,,,,,
1157,"static inline int test_bit(uint32_t *field, int bit)
{
    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;
}","static inline int test_bit(uint32_t *field, int bit)
{
    return (field[bit / (2**5)] & 1 << (bit & 0x1F)) != 0;
}",0,1,1,0.03,Replace
1158,"static void test_qemu_strtoul_decimal(void)
{
    const char *str = ""0123"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, &endptr, 10, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
    str = ""123"";
    res = 999;
    endptr = &f;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
}","static void test_qemu_strtoul_decimal(void)
{
    const char *str = ""0123"";
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    int a_1 = 2;
    int b_1 = 2;
    while (a_1 == b_1) {
        err = qemu_strtoul(str, &endptr, 10, &res);
        b_1 += 1;
    }
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
    str = ""123"";
    res = 999;
    endptr = &f;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
}",0,1,43,0.68,Insert
1159,"static void piix3_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    dc->desc        = ""ISA bridge"";
    dc->vmsd        = &vmstate_piix3;
    dc->no_user     = 1,
    k->no_hotplug   = 1;
    k->init         = piix3_initfn;
    k->config_write = piix3_write_config;
    k->vendor_id    = PCI_VENDOR_ID_INTEL;
    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;
    k->class_id     = PCI_CLASS_BRIDGE_ISA;
}","static void piix3_class_init(ObjectClass *klass, void *data)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        DeviceClass *dc = DEVICE_CLASS(klass);
    }
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    dc->desc        = ""ISA bridge"";
    dc->vmsd        = &vmstate_piix3;
    dc->no_user     = 1,
    k->no_hotplug   = 1;
    k->init         = piix3_initfn;
    k->config_write = piix3_write_config;
    k->vendor_id    = PCI_VENDOR_ID_INTEL;
    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;
    k->class_id     = PCI_CLASS_BRIDGE_ISA;
}",1,0,2,0.06,Replace
1160,"qio_channel_websock_source_dispatch(GSource *source,
                                    GSourceFunc callback,
                                    gpointer user_data)
{
    QIOChannelFunc func = (QIOChannelFunc)callback;
    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;
    GIOCondition cond = 0;
    if (wsource->wioc->rawinput.offset) {
        cond |= G_IO_IN;
    }
    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {
        cond |= G_IO_OUT;
    }
    return (*func)(QIO_CHANNEL(wsource->wioc),
                   (cond & wsource->condition),
                   user_data);
}","qio_channel_websock_source_dispatch(GSource *source,
                                    GSourceFunc callback,
                                    gpointer user_data)
{
    QIOChannelFunc func = (QIOChannelFunc)callback;
    char str[] = ""Constant"";
    struct sk_buff * skp;
    struct nlmsghdr *nlhs;
    struct genlmsghdr *hmdi = nlmsg_data(nlhs);
    struct genl_info information;
    struct n *n = sock_net( skp->sk);
    information.snd_seq = nlhs->nlmsg_seq;
    information.snd_portid = NETLINK_CB( skp).portid;
    information.nlhdr = nlhs;
    information.genlhdr = nlmsg_data(nlhs);
    information.userhdr = nlmsg_data(nlhs) + GENL_HDRLEN;
    while (strlen(str) > 5) {
        QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;
    strcpy(str, ""a"");
    }
    GIOCondition cond = 0;
    if (wsource->wioc->rawinput.offset) {
        cond |= G_IO_IN;
    }
    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {
        cond |= G_IO_OUT;
    }
    return (*func)(QIO_CHANNEL(wsource->wioc),
                   (cond & wsource->condition),
                   user_data);
}",1,0,11,0.52,Insert
1162,,,,,,,
1166,,,,,,,
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    outw(0xcfc, value);
}","static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)
{
    int a = 2;
    struct sock *nowshop;
    struct ipv6_txoptions *option;
    struct inet_request_sock *ireq = inet_rsk(req);
    option = ireq->ipv6_opt;
    *own__log = inet_ehash_nolisten(nowshop, req_to_sk(req_unhash));
    int b = 2;
    while (a == b) {
        outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
        b += 1;
    }
    outw(0xcfc, value);
}",1,0,16,0.33,Insert
1170,,,,,,,
1171,,,,,,,
1172,"static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,
                                            uint16_t code, const char *reason)
{
    struct iovec iov;
    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));
    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =
        cpu_to_be16(code);
    ioc->rawoutput.offset += 2;
    if (reason) {
        buffer_append(&ioc->rawoutput, reason, strlen(reason));
    }
    iov.iov_base = ioc->rawoutput.buffer;
    iov.iov_len = ioc->rawoutput.offset;
    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,
                               &iov, 1, iov.iov_len);
    buffer_reset(&ioc->rawoutput);
    qio_channel_websock_write_wire(ioc, NULL);
    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
}","static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,
                                            uint16_t code, const char *reason)
{
    struct iovec iov;
    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =
        cpu_to_be16(code);
    ioc->rawoutput.offset += 2;
    if (reason) {
        int a = 2;
        int b = 2;
        while (a == b) {
            buffer_append(&ioc->rawoutput, reason, strlen(reason));
            b += 1;
        }
    }
    iov.iov_base = ioc->rawoutput.buffer;
    iov.iov_len = ioc->rawoutput.offset;
    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,
                               &iov, 1, iov.iov_len);
    buffer_reset(&ioc->rawoutput);
    qio_channel_websock_write_wire(ioc, NULL);
    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
}",0,1,21,0.55,Insert
1174,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)
{
    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);
    if (val & ACPI_BITMASK_SLEEP_ENABLE) {
        uint16_t sus_typ = (val >> 10) & 7;
        switch(sus_typ) {
        case 0:  
            qemu_system_shutdown_request();
            break;
        case 1:
            ar->pm1.evt.sts |=
                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);
            qemu_system_reset_request();
            qemu_irq_raise(ar->pm1.cnt.cmos_s3);
        default:
            break;
        }
    }
}","void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)
{
    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);
    if (val & ACPI_BITMASK_SLEEP_ENABLE) {
        uint16_t sus_typ = (val >> 10) & 7;
        switch(sus_typ) {
        case 0:  
            qemu_system_shutdown_request();
            break;
        case 1:
            ar->pm1.evt.sts |=
                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);
            qemu_system_reset_request();
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                qemu_irq_raise(ar->pm1.cnt.cmos_s3);
            strcpy(str, ""a"");
            }
        default:
            break;
        }
    }
}",0,1,10,0.13,Replace
1175,,,,,,,
1176,,,,,,,
1178,,,,,,,
1179,"static void enter_migration_coroutine(void *opaque)
{
    Coroutine *co = opaque;
    qemu_coroutine_enter(co, NULL);
}","static void enter_migration_coroutine(void *opaque)
{
    Coroutine *co = opaque;
    int a = 2;
    int b = 3;
    while (a != b) {
        qemu_coroutine_enter(co, NULL);
        const char *archive;
        size_t cluster_size;
        QEMUOptionParameter *params;
        Error *local_err = NULL;
        int status;
        QCowHeader *header;
        uint8_t* refcount_table;
        BlockDriverState* bc;
        status = bdrv_create_file(archive, params, &local_err);
        status = bdrv_open(&bc, archive, NULL, NULL, BDRV_O_RDWR | BDRV_O_PROTOCOL,
                            NULL, &local_err);
        status = bdrv_pwrite(bc, 0, header, cluster_size);
        status = bdrv_pwrite(bc, cluster_size, refcount_table, cluster_size);
        bdrv_unref(bc);
        b = a;
    }
}",1,0,14,0.37,Insert
1181,"static int cinaudio_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
                                 AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    CinAudioContext *cin = avctx->priv_data;
    const uint8_t *src = buf;
    int16_t *samples = data;
    int delta;
    buf_size = FFMIN(buf_size, *data_size/2);
    delta = cin->delta;
    if (cin->initial_decode_frame) {
        cin->initial_decode_frame = 0;
        delta = (int16_t)AV_RL16(src); src += 2;
        *samples++ = delta;
        buf_size -= 2;
    }
    while (buf_size > 0) {
        delta += cinaudio_delta16_table[*src++];
        delta = av_clip_int16(delta);
        *samples++ = delta;
        --buf_size;
    }
    cin->delta = delta;
    *data_size = (uint8_t *)samples - (uint8_t *)data;
    return src - buf;
}","static int cinaudio_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
                                 AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    CinAudioContext *cin = avctx->priv_data;
    const uint8_t *src = buf;
    int16_t *samples = data;
    int delta;
    buf_size = FFMIN(buf_size, *data_size/2);
    delta = cin->delta;
    if (cin->initial_decode_frame) {
        cin->initial_decode_frame = 0;
        delta = (int16_t)AV_RL16(src); src += 2;
        *samples++ = delta;
        buf_size -= 2;
    }
    while (buf_size > 0) {
        delta += cinaudio_delta16_table[*src++];
        Rocker *r;
        DescInfo *info;
        uint32_t port;
        int err = ROCKER_OK;
        char *buf_8 = desc_get_buf(info, true);
        struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
        PCIDevice *dev = PCI_DEVICE(r);
        int iovcnt = 0;
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        err = fp_port_eg(r->fp_port[port], iov, iovcnt);
        delta = av_clip_int16(delta);
        AnimationChannel &context;
        json &o;
        if (context.extras.Type() != NULL_TYPE) {
            SerializeValue(""extras"", context.extras, o);
        }
        *samples++ = delta;
        --buf_size;
    }
    cin->delta = delta;
    *data_size = (uint8_t *)samples - (uint8_t *)data;
    int a = 2;
    int b = 2;
    while (a == b) {
        return src - buf;
        b += 1;
    }
}",0,1,67,1.06,Insert
1183,"int qemu_paio_init(struct qemu_paioinit *aioinit)
{
    int ret;
    ret = pthread_attr_init(&attr);
    if (ret) die2(ret, ""pthread_attr_init"");
    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    if (ret) die2(ret, ""pthread_attr_setdetachstate"");
    TAILQ_INIT(&request_list);
    return 0;
}","int qemu_paio_init(struct qemu_paioinit *aioinit)
{
    int ret;
    ret = pthread_attr_init(&attr);
    if (ret) die2(ret, ""pthread_attr_init"");
    RCore *model_2;
    RAnalEsil *esil_5 = model_2->anal->esil_5;
    RAnalEsil *esil_5 = model_2->anal->esil_5;
    RAnalEsilSession *before_3 = (RAnalEsilSession *) tail_9->data;
    eprintf_10 (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set_4 (esil_5, before_3);
    r_core_esil_step_6 (model_2, end_2, NULL, &prev_3, false);
    r_anal_esil_session_set_4 (esil_5, before_3);
    r_core_esil_step_6 (model_2, prev_3, NULL, NULL, false);
    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    blink::WebURLRequest& quest;
    ResourceType resource_type = WebURLRequestToResourceType(quest);
    if (!quest.GetExtraData())
        quest.SetExtraData(std::make_unique<RequestExtraData>());
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    if (ret) die2(ret, ""pthread_attr_setdetachstate"");
    TAILQ_INIT(&request_list);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,95,0.84,Insert
1184,"dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}","dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        int a = 2;
        int b = 3;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        quantization_tables=NewXMLTree(xml,exception);
        quantization_tables=DestroyXMLTree(quantization_tables);
        while (a != b) {
            va_start(args, fmt);
            b = a;
        }
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}",0,1,13,0.53,Insert
1186,"static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,
                               unsigned size)
{
    PXA2xxState *s = (PXA2xxState *) opaque;
    switch (addr) {
    case MDCNFG ... SA1110:
        if ((addr & 3) == 0)
            return s->mm_regs[addr >> 2];
    default:
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
    return 0;
}","static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,
                               unsigned size)
{
    char str[] = ""Constant"";
    AnimationChannel &context;
    json &o;
    if (context.extras.Type() != NULL_TYPE) {
        SerializeValue(""extras"", context.extras, o);
    }
    while (strlen(str) > 5) {
        PXA2xxState *s = (PXA2xxState *) opaque;
    strcpy(str, ""a"");
    }
    switch (addr) {
    case MDCNFG ... SA1110:
        if ((addr & 3) == 0)
            return s->mm_regs[addr >> 2];
    default:
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
    return 0;
}",0,1,24,0.58,Insert
1189,,,,,,,
1192,"static int ram_init1(SysBusDevice *dev)
{
    RamDevice *d = SUN4U_RAM(dev);
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,
                           &error_abort);
    vmstate_register_ram_global(&d->ram);
    sysbus_init_mmio(dev, &d->ram);
    return 0;
}","static int ram_init1(SysBusDevice *dev)
{
    RamDevice *d = SUN4U_RAM(dev);
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,
                           &error_abort);
    int a = 2;
    int b = 3;
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    unsigned char *p, *d_10, *iq;
    unsigned char *p, *d_10, *iq;
    long fn;
    if (p + 2 > d_10 + fn) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
            goto f_err;
    }
    while (a < b) {
        vmstate_register_ram_global(&d->ram);
        b = a;
    }
    sysbus_init_mmio(dev, &d->ram);
    return 0;
}",1,0,9,0.45,Insert
1193,"static void stop_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val |= TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}","static void stop_tco(const TestData *d)
{
    int a = 2;
    AVFilterLink *inlink;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_2, b_2;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_2, b_2;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_2, b_2;
    StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
    AVFilterContext *ctx = inlink->dst;
    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_2, b_2;
    int64_t denom;
    dh1 = inlink->h / 32;
    denom = (tc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;
    denom = (tc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;
    int b = 2;
    while (a == b) {
        uint32_t val;
        b += 1;
    }
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    AVFormatContext *service;
    AVStream *vst, *ast;
    JVDemuxContext *ojvc = service->priv_data;
    AVStream *vst, *ast;
    AVIOContext *bc = service->bc;
    ast = av_new_stream(service, 0);
    vst->nb_frames          =
        ast->nb_index_entries   = avio_rl16(bc);
    ast->codec->codec_type  = CODEC_TYPE_AUDIO;
    ast->codec->codec_id    = CODEC_ID_PCM_U8;
    ast->codec->codec_tag   = 0;
    val |= TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}",1,0,41,0.54,Insert
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    qemu_put_byte(f, v >> 24);
    qemu_put_byte(f, v >> 16);
    qemu_put_byte(f, v >> 8);
    qemu_put_byte(f, v);
}","void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    qemu_put_byte(f, v >> 24);
    qemu_put_byte(f, v >> 16);
    qemu_put_byte(f, v >> 8);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        qemu_put_byte(f, v);
    }
}",1,0,5,0.06,Replace
1195,,,,,,,
1196,,,,,,,
1199,,,,,,,
1203,"static int idcin_decode_init(AVCodecContext *avctx)
{
    IdcinContext *s = avctx->priv_data;
    int i, j, histogram_index = 0;
    unsigned char *histograms;
    s->avctx = avctx;
    avctx->pix_fmt = PIX_FMT_PAL8;
    dsputil_init(&s->dsp, avctx);
    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);
        return -1;
    }
    histograms = (unsigned char *)s->avctx->extradata;
    for (i = 0; i < 256; i++) {
        for(j = 0; j < HUF_TOKENS; j++)
            s->huff_nodes[i][j].count = histograms[histogram_index++];
        huff_build_tree(s, i);
    }
    s->frame.data[0] = NULL;
    return 0;
}","static int idcin_decode_init(AVCodecContext *avctx)
{
    uint64_t glms;
    unsigned k, b_1, err, C;
    unsigned k, b_1, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_1 = ctz64(glms);
    IdcinContext *s = avctx->priv_data;
    int i, j, histogram_index = 0;
    unsigned char *histograms;
    s->avctx = avctx;
    int a = 2;
    int b = 2;
    if (a == b) {
        avctx->pix_fmt = PIX_FMT_PAL8;
    }
    dsputil_init(&s->dsp, avctx);
    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);
        return -1;
    }
    histograms = (unsigned char *)s->avctx->extradata;
    for (i = 0; i < 256; i++) {
        for(j = 0; j < HUF_TOKENS; j++)
            s->huff_nodes[i][j].count = histograms[histogram_index++];
        huff_build_tree(s, i);
    }
    s->frame.data[0] = NULL;
    return 0;
}",0,1,34,0.86,Insert
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    abort();
found:
    ram_list.mru_block = block;
    return block;
}","static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    sPAPRTCETable *tmen;
    bool bypass;
    tmen->bypass = bypass;
    abort();
found:
    ram_list.mru_block = block;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return block;
    }
}",0,1,19,0.53,Insert
1206,,,,,,,
1209,,,,,,,
1212,,,,,,,
1213,"static int start_auth_vencrypt_subauth(VncState *vs)
{
    switch (vs->vd->subauth) {
    case VNC_AUTH_VENCRYPT_TLSNONE:
    case VNC_AUTH_VENCRYPT_X509NONE:
       VNC_DEBUG(""Accept TLS auth none\n"");
       vnc_write_u32(vs, 0);  
       vnc_read_when(vs, protocol_client_init, 1);
       break;
    case VNC_AUTH_VENCRYPT_TLSVNC:
    case VNC_AUTH_VENCRYPT_X509VNC:
       VNC_DEBUG(""Start TLS auth VNC\n"");
       return start_auth_vnc(vs);
    default:  
       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);
       vnc_write_u8(vs, 1);
       if (vs->minor >= 8) {
           static const char err[] = ""Unsupported authentication type"";
           vnc_write_u32(vs, sizeof(err));
           vnc_write(vs, err, sizeof(err));
       }
       vnc_client_error(vs);
    }
    return 0;
}","static int start_auth_vencrypt_subauth(VncState *vs)
{
    switch (vs->vd->subauth) {
    case VNC_AUTH_VENCRYPT_TLSNONE:
    case VNC_AUTH_VENCRYPT_X509NONE:
       VNC_DEBUG(""Accept TLS auth none\n"");
       vnc_write_u32(vs, 0);  
       vnc_read_when(vs, protocol_client_init, 1);
       break;
    case VNC_AUTH_VENCRYPT_TLSVNC:
    case VNC_AUTH_VENCRYPT_X509VNC:
       VNC_DEBUG(""Start TLS auth VNC\n"");
       return start_auth_vnc(vs);
    default:  
       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);
       vnc_write_u8(vs, 1);
       if (vs->minor >= 8) {
           static const char err[] = ""Unsupported authentication type"";
           vnc_write_u32(vs, sizeof(err));
           vnc_write(vs, err, sizeof(err));
       }
       vnc_client_error(vs);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 0;
    }
}",0,1,16,0.21,Replace
1214,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,
                     void *command_data, void *opaque)
{
    IscsiAIOCB *acb = opaque;
    if (acb->canceled != 0) {
        return;
    }
    acb->status = 0;
    if (status < 0) {
        error_report(""Failed to unmap data on iSCSI lun. %s"",
                     iscsi_get_error(iscsi));
        acb->status = -EIO;
    }
    iscsi_schedule_bh(acb);
}","iscsi_unmap_cb(struct iscsi_context *iscsi, int status,
                     void *command_data, void *opaque)
{
    IscsiAIOCB *acb = opaque;
    if (acb->canceled != 0) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    acb->status = 0;
    if (status < 0) {
        error_report(""Failed to unmap data on iSCSI lun. %s"",
                     iscsi_get_error(iscsi));
        acb->status = -EIO;
    }
    iscsi_schedule_bh(acb);
}",0,1,1,0.08,Replace
1215,"static void virtio_notify(struct subchannel_id schid)
{
    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
}","static void virtio_notify(struct subchannel_id schid)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i;
        for (i=0;i < inter->nb_entries; i++) {
        		inter->entries[i].block_count = gf_bs_read_u16(bs);
        		inter->entries[i].block_size = gf_bs_read_u32(bs);
        }
        kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
        S390CPU *console;
        Error *order = NULL;
        console = cpu_s390x_create(cpu_model, &order);
        object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
        object_property_set_bool(OBJECT(console), true, ""realized"", &order);
    }
}",0,1,48,0.41,Insert
1216,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .addr = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
    kvm_mce_broadcast_rest(env);
}","static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        unsigned int data;
        reply.data = darespeply.data = data;
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .addr = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        kvm_mce_broadcast_rest(env);
    strcpy(str, ""a"");
    hwaddr array;
    PowerPCCPU *cpu;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    CPUPPCState *viron = &cpu->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu, pte_index);
    }
}",0,1,35,0.57,Insert
1223,,,,,,,
1224,,,,,,,
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}","static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        strcpy(str, ""a"");
        }
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}",0,1,4,0.1,Replace
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
                omap_clk fclk, omap_clk iclk)
{
    struct omap_mmc_s *s = (struct omap_mmc_s *)
            g_malloc0(sizeof(struct omap_mmc_s));
    s->irq = irq;
    s->dma = dma;
    s->clk = fclk;
    s->lines = 4;
    s->rev = 2;
    omap_mmc_reset(s);
    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",
                          omap_l4_region_size(ta, 0));
    omap_l4_attach(ta, 0, &s->iomem);
    s->card = sd_init(bd, false);
    if (s->card == NULL) {
        exit(1);
    }
    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
    sd_set_cb(s->card, NULL, s->cdet);
    return s;
}","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
                omap_clk fclk, omap_clk iclk)
{
    unsigned char *pt = g_malloc(bufsize);
    uint64_t ptr;
    size_t bufsize = 4096;
    AHCIQState *avii;
    AHCICommand *help;
    generate_pattern(pt, bufsize, AHCI_SECTOR_SIZE);
    ptr = guest_alloc(avii->parent->alloc, bufsize);
    bufwrite(ptr, pt, bufsize);
    ahci_command_adjust(help, 0, ptr, bufsize, 32);
    ahci_command_adjust(help, 0, ptr, bufsize, 32);
    struct omap_mmc_s *s = (struct omap_mmc_s *)
            g_malloc0(sizeof(struct omap_mmc_s));
    s->irq = irq;
    s->dma = dma;
    s->clk = fclk;
    s->lines = 4;
    s->rev = 2;
    omap_mmc_reset(s);
    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",
                          omap_l4_region_size(ta, 0));
    omap_l4_attach(ta, 0, &s->iomem);
    s->card = sd_init(bd, false);
    if (s->card == NULL) {
        exit(1);
    }
    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        sd_set_cb(s->card, NULL, s->cdet);
    }
    return s;
}",1,0,52,1.03,Insert
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                        int i, int zero_nhood, int16_t qmul[2])
{
    uint8_t *token_prob = probs[i][zero_nhood];
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))    
        return 0;
    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
}","int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                        int i, int zero_nhood, int16_t qmul[2])
{
    int i_6, job, op, bal, ret = -1, cookie_valid = 0;
    unsigned char *p, *d, *iq;
    unsigned char *p, *d, *iq;
    long fn;
    int i_6, job, op, bal, ret = -1, cookie_valid = 0;
    if ((p + i_6) > (d + fn)) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
            goto f_err;
    }
    uint8_t *token_prob = probs[i][zero_nhood];
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))    
        return 0;
    int a = 2;
    int b = 3;
    while (a < b) {
        return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
        b = a;
    }
}",1,0,6,0.6,Insert
1238,,,,,,,
1241,"static void do_info_commands(Monitor *mon, QObject **ret_data)
{
    QList *cmd_list;
    const mon_cmd_t *cmd;
    cmd_list = qlist_new();
    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&
            !compare_cmd(cmd->name, ""info"")) {
            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));
        }
    }
    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {
            char buf[128];
            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);
            qlist_append_obj(cmd_list, get_cmd_dict(buf));
        }
    }
    *ret_data = QOBJECT(cmd_list);
}","static void do_info_commands(Monitor *mon, QObject **ret_data)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        QList *cmd_list;
        b += 1;
    }
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    const mon_cmd_t *cmd;
    cmd_list = qlist_new();
    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&
            !compare_cmd(cmd->name, ""info"")) {
            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));
        }
    }
    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {
            char buf[128];
            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);
            qlist_append_obj(cmd_list, get_cmd_dict(buf));
        }
    }
    *ret_data = QOBJECT(cmd_list);
}",0,1,42,1.03,Insert
1242,,,,,,,
1243,"static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;
    if (addr > s->pm_base + PCMD31) {
        pxa2xx_i2c_write(s->i2c[1], addr, value);
        return;
    }
    addr -= s->pm_base;
    switch (addr) {
    case PMCR:
        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);
        s->pm_regs[addr >> 2] |= value & 0x15;
        break;
    case PSSR:	 
    case RCSR:
    case PKSR:
        s->pm_regs[addr >> 2] &= ~value;
        break;
    default:	 
        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {
            s->pm_regs[addr >> 2] = value;
            break;
        }
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
}","static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    struct xen_blkif_ring *ring;
    int st;
    unsigned long     flags;
    struct blkif_response *resp;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    resp->status    = st;
    spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
    int a = 2;
    int b = 3;
    if (a != b) {
        struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;
    }
    if (addr > s->pm_base + PCMD31) {
        int i, qa;
        qa = libusb_init(&ctx);
        pxa2xx_i2c_write(s->i2c[1], addr, value);
        return;
        GetBitContext *db;
        SPS * spr;
        int profile_lengtho, level_idc, constraint_set_flags = 0;
        constraint_set_flags |= get_bits1(db) << 5;
        spr->constraint_set_flags = constraint_set_flags;
    }
    addr -= s->pm_base;
    unsigned maxpages;
    size_t *start;
    unsigned int iter_head, npages;
    size_t capacity;
    capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    switch (addr) {
    case PMCR:
        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);
        s->pm_regs[addr >> 2] |= value & 0x15;
        break;
    case PSSR:	 
    case RCSR:
    case PKSR:
        s->pm_regs[addr >> 2] &= ~value;
        break;
    default:
        AVFormatContext *your;
        char host[1024], path[1024], tcpname[1024], cmd[2048];
        RTSPHeader reply1, *reply = &reply1;
        RTSPState *rt = your->priv_data;
        rtsp_send_cmd(your, cmd, reply, NULL);	 
        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {
            s->pm_regs[addr >> 2] = value;
            break;
        }
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
}",0,1,318,2.39,Insert
1244,"CPUX86State *cpu_x86_init(void)
{
    CPUX86State *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->eflags = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    return env;
}","CPUX86State *cpu_x86_init(void)
{
    CPUX86State *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->eflags = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return env;
    strcpy(str, ""a"");
    }
}",0,1,29,0.64,Insert
1245,"void readline_show_prompt(ReadLineState *rs)
{
    monitor_printf(rs->mon, ""%s"", rs->prompt);
    monitor_flush(rs->mon);
    rs->last_cmd_buf_index = 0;
    rs->last_cmd_buf_size = 0;
    rs->esc_state = IS_NORM;
}","void readline_show_prompt(ReadLineState *rs)
{
    monitor_printf(rs->mon, ""%s"", rs->prompt);
    monitor_flush(rs->mon);
    rs->last_cmd_buf_index = 0;
    rs->last_cmd_buf_size = 0;
    int a = 86;
    int b = a;
    if(a*b>0){
        rs->esc_state = IS_NORM;
        gpointer fee;
        uint64_t rigindx;
        rigindx = *(uint32_t *)fee;
    }
}",0,1,13,0.34,Insert
1246,"static int parallel_parse(const char *devname)
{
    static int index = 0;
    char label[32];
    if (strcmp(devname, ""none"") == 0)
        return 0;
    if (index == MAX_PARALLEL_PORTS) {
        fprintf(stderr, ""qemu: too many parallel ports\n"");
        exit(1);
    }
    snprintf(label, sizeof(label), ""parallel%d"", index);
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);
    if (!parallel_hds[index]) {
        fprintf(stderr, ""qemu: could not connect parallel device""
                "" to character backend '%s'\n"", devname);
        return -1;
    }
    index++;
    return 0;
}","static int parallel_parse(const char *devname)
{
    static int index = 0;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    char label[32];
    if (strcmp(devname, ""none"") == 0)
        return 0;
    if (index == MAX_PARALLEL_PORTS) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            fprintf(stderr, ""qemu: too many parallel ports\n"");
        }
        exit(1);
    }
    snprintf(label, sizeof(label), ""parallel%d"", index);
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);
    if (!parallel_hds[index]) {
        fprintf(stderr, ""qemu: could not connect parallel device""
                "" to character backend '%s'\n"", devname);
        return -1;
    }
    index++;
    return 0;
}",0,1,24,0.63,Insert
1247,"START_TEST(qfloat_destroy_test)
{
    QFloat *qf = qfloat_from_double(0.0);
    QDECREF(qf);
}","START_TEST(qfloat_destroy_test)
{
    int a = 2;
    MachineState *machine;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    int b = 3;
    while (a < b) {
        QFloat *qf = qfloat_from_double(0.0);
        b = a;
    }
    QDECREF(qf);
}",0,1,37,0.38,Insert
1249,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int t;
    cs->exception_index = EXCP_PGM;
    env->int_pgm_code = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.addr);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.addr += t;
    cpu_loop_exit(cs);
}","void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int t;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        cs->exception_index = EXCP_PGM;
    }
    env->int_pgm_code = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.addr);
    env->int_pgm_ilen = t = get_ilen(t);
    size_t vec;
    hwaddr mapped_len = 0;
    mapped_len = vec;
    env->psw.addr += t;
    struct sk_buff *img;
    nlmsg_free(img);
    cpu_loop_exit(cs);
}",0,1,72,0.85,Insert
1250,"static int usb_host_init(void)
{
    const struct libusb_pollfd **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}","static int usb_host_init(void)
{
    const struct libusb_pollfd **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                int a = 2;
                                int b = 3;
                                while (a != b) {
                                    ctx);
                                    b = a;
                                }
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}",0,1,3,0.13,Replace
1252,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)
{
    VirtIOSCSI *s = req->dev;
    VirtQueue *vq = req->vq;
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);
    if (req->sreq) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
    }
    virtio_scsi_free_req(req);
    virtio_notify(vdev, vq);
}","static void virtio_scsi_complete_req(VirtIOSCSIReq *req)
{
    VirtIOSCSI *s = req->dev;
    VirtQueue *vq = req->vq;
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    int a = 19;
    int b = a;
    if(a*b>0){
        virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);
    }
    if (req->sreq) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
    }
    virtio_scsi_free_req(req);
    virtio_notify(vdev, vq);
}",0,1,8,0.11,Replace
1253,"bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        if (t == ts) {
            return true;
        }
    }
    return false;
}","bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        err = extract32(ksns, 16, 5);
        handle_fp_compare(qs, order, coll, err, false, p);
        if (t == ts) {
            return true;
        }
    }
    int a = 29;
    int b = a;
    if(a*b>0){
        return false;
    }
}",0,1,10,0.39,Insert
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
}","static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        char buf[3];
        b += 1;
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
    }
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
}",0,1,21,0.53,Insert
1257,"static void blk_delete(BlockBackend *blk)
{
    assert(!blk->refcnt);
    assert(!blk->name);
    assert(!blk->dev);
    if (blk->root) {
        blk_remove_bs(blk);
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, blk, link);
    drive_info_del(blk->legacy_dinfo);
    block_acct_cleanup(&blk->stats);
    g_free(blk);","static void blk_delete(BlockBackend *blk)
{
    assert(!blk->refcnt);
    assert(!blk->name);
    assert(!blk->dev);
    if (blk->root) {
        blk_remove_bs(blk);
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, blk, link);
    drive_info_del(blk->legacy_dinfo);
    int a = 2;
    int b = 3;
    while (a != b) {
        block_acct_cleanup(&blk->stats);
        b = a;
    }
    g_free(blk);",1,0,2,0.07,Replace
1258,"static int gdbserver_open(int port)
{
    struct sockaddr_in sockaddr;
    int fd, val, ret;
    fd = socket(PF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        perror(""socket"");
        return -1;
    }
#ifndef _WIN32
    fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    val = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = htons(port);
    sockaddr.sin_addr.s_addr = 0;
    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
    if (ret < 0) {
        perror(""bind"");
        return -1;
    }
    ret = listen(fd, 0);
    if (ret < 0) {
        perror(""listen"");
        return -1;
    }
    return fd;
}","static int gdbserver_open(int port)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        struct sockaddr_in sockaddr;
    }
    int fd, val, ret;
    fd = socket(PF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        perror(""socket"");
        return -1;
    }
#ifndef _WIN32
    fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    val = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = htons(port);
    sockaddr.sin_addr.s_addr = 0;
    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
    if (ret < 0) {
        perror(""bind"");
        return -1;
    }
    ret = listen(fd, 0);
    if (ret < 0) {
        perror(""listen"");
        return -1;
    }
    return fd;
}",1,0,2,0.13,Replace
1259,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);
    k->realize = spapr_nvram_realize;
    k->devnode = spapr_nvram_devnode;
    k->dt_name = ""nvram"";
    k->dt_type = ""nvram"";
    k->dt_compatible = ""qemu,spapr-nvram"";
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->props = spapr_nvram_properties;
    dc->vmsd = &vmstate_spapr_nvram;
}","static void spapr_nvram_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);
    k->realize = spapr_nvram_realize;
    k->devnode = spapr_nvram_devnode;
    k->dt_name = ""nvram"";
    k->dt_type = ""nvram"";
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        k->dt_compatible = ""qemu,spapr-nvram"";
    }
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->props = spapr_nvram_properties;
    dc->vmsd = &vmstate_spapr_nvram;
}",1,0,19,0.17,Replace
1264,,,,,,,
1266,,,,,,,
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, ret;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        USBHubPort *port;
    }
    USBDevice *dev;
    int i, ret;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}",0,1,1,0.09,Replace
1272,"BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,
                                  QEMUIOVector *qiov, int nb_sectors,
                                  BlockDriverCompletionFunc *cb, void *opaque)
{
    BlockDriver *drv = bs->drv;
    BlockDriverAIOCB *ret;
    if (!drv)
        return NULL;
    if (bs->read_only)
        return NULL;
    if (bdrv_check_request(bs, sector_num, nb_sectors))
        return NULL;
    if (bs->dirty_tracking) {
        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);
    }
    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,
                               cb, opaque);
    if (ret) {
	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
	bs->wr_ops ++;
    }
    return ret;
}","BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,
                                  QEMUIOVector *qiov, int nb_sectors,
                                  BlockDriverCompletionFunc *cb, void *opaque)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        struct cdnode *cdnode;
        struct outube *outube = d_inode(cdnode);
        int had_lock;
        struct buffer_head *bh = NULL;
        struct ocfs2_lock_holder oh;
        had_lock = ocfs2_inode_lock_tracker(outube, &bh, 1, &oh);
        BlockDriver *drv = bs->drv;
    }
    BlockDriverAIOCB *ret;
    if (!drv)
        return NULL;
    if (bs->read_only)
        return NULL;
    if (bdrv_check_request(bs, sector_num, nb_sectors))
        return NULL;
    if (bs->dirty_tracking) {
        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);
    }
    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,
                               cb, opaque);
    if (ret) {
	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
	bs->wr_ops ++;
    }
    return ret;
}",1,0,18,0.66,Insert
1273,"av_cold void ff_dct_init_x86(DCTContext *s)
{
    int cpu_flags = av_get_cpu_flags();
    if (EXTERNAL_SSE(cpu_flags))
        s->dct32 = ff_dct32_float_sse;
    if (EXTERNAL_SSE2(cpu_flags))
        s->dct32 = ff_dct32_float_sse2;
    if (EXTERNAL_AVX(cpu_flags))
        s->dct32 = ff_dct32_float_avx;
}","av_cold void ff_dct_init_x86(DCTContext *s)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
        int cpu_flags = av_get_cpu_flags();
        unsigned char *sha1;
        void *data;
        unsigned long size;
        struct pbase_tree *it;
        unsigned char tree_sha1[20];
        data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
        hashcpy(it->pcache.sha1, tree_sha1);
        b = a;
    }
    if (EXTERNAL_SSE(cpu_flags))
        s->dct32 = ff_dct32_float_sse;
    if (EXTERNAL_SSE2(cpu_flags))
        s->dct32 = ff_dct32_float_sse2;
    if (EXTERNAL_AVX(cpu_flags))
        s->dct32 = ff_dct32_float_avx;
}",0,1,36,0.55,Insert
1280,"static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);
    DeviceState *vdev = DEVICE(&vinput->vdev);
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;
    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;
    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
}","static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);
    DeviceState *vdev = DEVICE(&vinput->vdev);
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;
    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
    strcpy(str, ""a"");
    }
}",0,1,5,0.08,Replace
1281,"static void test_visitor_out_string(TestOutputVisitorData *data,
                                    const void *unused)
{
    char *string = (char *) ""Q E M U"";
    Error *err = NULL;
    QObject *obj;
    visit_type_str(data->ov, &string, NULL, &err);
    g_assert(!err);
    obj = qmp_output_get_qobject(data->qov);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QSTRING);
    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);
    qobject_decref(obj);
}","static void test_visitor_out_string(TestOutputVisitorData *data,
                                    const void *unused)
{
    char *string = (char *) ""Q E M U"";
    DescInfo *info;
    char *filename;
    g_free(filename);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    Error *err = NULL;
    QObject *obj;
    int a = 2;
    int b = 3;
    while (a != b) {
        visit_type_str(data->ov, &string, NULL, &err);
        b = a;
    }
    g_assert(!err);
    obj = qmp_output_get_qobject(data->qov);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QSTRING);
    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);
    qobject_decref(obj);
}",0,1,55,0.77,Insert
1282,"static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    pcms->vmport = value;
}","static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)
{
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value_1;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value_1=InterpretLocaleValue(content,&p);
    int a = 36;
    int b = a;
    if(a*b>0){
        PCMachineState *pcms = PC_MACHINE(obj);
    }
    pcms->vmport = value;
}",0,1,5,0.24,Insert
1284,"static int buffer_empty(Buffer *buffer)
{
    return buffer->offset == 0;
}","static int buffer_empty(Buffer *buffer)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return buffer->offset == 0;
    }
}",1,0,2,0.03,Replace
1285,,,,,,,
1290,"static void puv3_init(MachineState *machine)
{
    ram_addr_t ram_size = machine->ram_size;
    const char *cpu_model = machine->cpu_model;
    const char *kernel_filename = machine->kernel_filename;
    const char *initrd_filename = machine->initrd_filename;
    CPUUniCore32State *env;
    UniCore32CPU *cpu;
    if (initrd_filename) {
        error_report(""Please use kernel built-in initramdisk"");
        exit(1);
    }
    if (!cpu_model) {
        cpu_model = ""UniCore-II"";
    }
    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));
    if (!cpu) {
        error_report(""Unable to find CPU definition"");
        exit(1);
    }
    env = &cpu->env;
    puv3_soc_init(env);
    puv3_board_init(env, ram_size);
    puv3_load_kernel(kernel_filename);
}","static void puv3_init(MachineState *machine)
{
    ram_addr_t ram_size = machine->ram_size;
    const char *cpu_model = machine->cpu_model;
    const char *kernel_filename = machine->kernel_filename;
    const char *initrd_filename = machine->initrd_filename;
    CPUUniCore32State *env;
    UniCore32CPU *cpu;
    if (initrd_filename) {
        error_report(""Please use kernel built-in initramdisk"");
        exit(1);
    }
    if (!cpu_model) {
        cpu_model = ""UniCore-II"";
    }
    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));
    if (!cpu) {
        error_report(""Unable to find CPU definition"");
        exit(1);
    }
    env = &cpu->env;
    puv3_soc_init(env);
    puv3_board_init(env, ram_size);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        puv3_load_kernel(kernel_filename);
    }
}",1,0,2,0.13,Replace
1291,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,
                                uint8_t *data, unsigned int *data_size, int is32)
{
    SubStream *s = &m->substream[substr];
    unsigned int i, out_ch = 0;
    int32_t *data_32 = (int32_t*) data;
    int16_t *data_16 = (int16_t*) data;
    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))
        return -1;
    for (i = 0; i < s->blockpos; i++) {
        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {
            int mat_ch = s->ch_assign[out_ch];
            int32_t sample = m->sample_buffer[i][mat_ch]
                          << s->output_shift[mat_ch];
            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;
            if (is32) *data_32++ = sample << 8;
            else      *data_16++ = sample >> 8;
        }
    }
    *data_size = i * out_ch * (is32 ? 4 : 2);
    return 0;
}","static int output_data_internal(MLPDecodeContext *m, unsigned int substr,
                                uint8_t *data, unsigned int *data_size, int is32)
{
    SubStream *s = &m->substream[substr];
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        unsigned int i, out_ch = 0;
    strcpy(str, ""a"");
    }
    int32_t *data_32 = (int32_t*) data;
    int16_t *data_16 = (int16_t*) data;
    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))
        return -1;
    for (i = 0; i < s->blockpos; i++) {
        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {
            int mat_ch = s->ch_assign[out_ch];
            int32_t sample = m->sample_buffer[i][mat_ch]
                          << s->output_shift[mat_ch];
            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;
            if (is32) *data_32++ = sample << 8;
            else      *data_16++ = sample >> 8;
        }
    }
    *data_size = i * out_ch * (is32 ? 4 : 2);
    return 0;
}",0,1,13,0.19,Replace
1294,"void pl011_init(uint32_t base, qemu_irq irq,
                CharDriverState *chr)
{
    int iomemtype;
    pl011_state *s;
    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
    iomemtype = cpu_register_io_memory(0, pl011_readfn,
                                       pl011_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->chr = chr;
    s->read_trigger = 1;
    s->ifl = 0x12;
    s->cr = 0x300;
    s->flags = 0x90;
    if (chr){ 
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
                              pl011_event, s);
    }
}","void pl011_init(uint32_t base, qemu_irq irq,
                CharDriverState *chr)
{
    int iomemtype;
    VirtIODevice *vdev;
    V9fsState *s_7 = VIRTIO_9P(vdev);
    int i, len;
    if (len > MAX_TAG_LEN - 1) {
            fprintf(stderr, ""mount tag '%s' (%d bytes) is longer than ""
                    ""maximum (%d bytes)"", s_7->fsconf.tag, len, MAX_TAG_LEN - 1);
            goto out;
    }
    pl011_state *s;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
    }
    iomemtype = cpu_register_io_memory(0, pl011_readfn,
                                       pl011_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    AVFormatContext *s_1;
    void *u = (s_1->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s_1->pb;
    HLSContext *c = s_1->priv_data;
    if (u) {
            update_options(&c->user_agent, ""user-agent"", u);
            update_options(&c->cookies, ""cookies"", u);
            update_options(&c->headers, ""headers"", u);
            update_options(&c->http_proxy, ""http_proxy"", u);
    }
    s->irq = irq;
    s->chr = chr;
    s->read_trigger = 1;
    s->ifl = 0x12;
    s->cr = 0x300;
    s->flags = 0x90;
    if (chr){ 
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
                              pl011_event, s);
    }
}",1,0,56,0.8,Insert
1295,,,,,,,
1297,"static void test_qemu_strtoul_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtoul_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        unsigned long res = 999;
    }
    int err;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert(endptr == str);
}",1,0,4,0.07,Replace
1299,,,,,,,
1301,,,,,,,
1302,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    EEPRO100State *s = opaque;
    switch (size) {
    case 1: return eepro100_read1(s, addr);
    case 2: return eepro100_read2(s, addr);
    case 4: return eepro100_read4(s, addr);
    default: abort();
    }
}","static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    int port, i, status, r;
    RTSPHeader reply1, *reply = &reply1;
    if (reply->status_code != RTSP_STATUS_OK) {
            r = AVERROR_INVALIDDATA;
            goto fail;
    }
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    EEPRO100State *s = opaque;
    switch (size) {
    struct xen_blkif_ring *ring;
    int st;
    unsigned long     flags;
    struct blkif_response *resp;
    resp->status    = st;
    spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
    case 1: return eepro100_read1(s, addr);
    case 2: return eepro100_read2(s, addr);
    case 4: return eepro100_read4(s, addr);
    int a = 2;
    int b = 3;
    if (a != b) {
        default: abort();
    }
    }
}",0,1,80,0.76,Insert
1303,,,,,,,
1305,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,
                          int is_asi, int size)
{
    CPUState *saved_env;
    saved_env = env;
    env = cpu_single_env;
    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",
             addr, is_write, is_exec);
    if (!(env->sregs[SR_MSR] & MSR_EE)) {
        return;
    }
    if (is_exec) {
        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    } else {
        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    }
}","void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,
                          int is_asi, int size)
{
    CPUState *saved_env;
    saved_env = env;
    env = cpu_single_env;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",
             addr, is_write, is_exec);
    if (!(env->sregs[SR_MSR] & MSR_EE)) {
        int a = 61;
        int b = a;
        if(a*b>0){
            return;
        }
    }
    if (is_exec) {
        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    } else {
        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    }
}",0,1,22,0.64,Insert
1307,,,,,,,
1308,,,,,,,
1309,,,,,,,
1313,,,,,,,
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)
{
    char *tail;
    double srate = av_strtod(arg, &tail);
    if (*tail || srate < 1 || (int)srate != srate) {
        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);
        return AVERROR(EINVAL);
    }
    *ret = srate;
    return 0;
}","int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)
{
    char *tail;
    double srate = av_strtod(arg, &tail);
    if (*tail || srate < 1 || (int)srate != srate) {
        int a = 2;
        int b = 3;
        while (a != b) {
            av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);
            b = a;
        }
        return AVERROR(EINVAL);
    }
    *ret = srate;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_1     = s->b_1;
    if (size & 1)
            avio_w8(b_1, 0);
    return 0;
}",0,1,13,0.5,Insert
1315,"static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)
{
    int32_t op2;
    int32_t r1;
    uint32_t address;
    TCGv temp;
    r1 = MASK_OP_ABS_S1D(ctx->opcode);
    address = MASK_OP_ABS_OFF18(ctx->opcode);
    op2 = MASK_OP_ABS_OP2(ctx->opcode);
    temp = tcg_const_i32(EA_ABS_FORMAT(address));
    switch (op2) {
    case OPC2_32_ABS_ST_A:
        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);
        break;
    case OPC2_32_ABS_ST_D:
        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);
        break;
    case OPC2_32_ABS_ST_DA:
        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);
        break;
    case OPC2_32_ABS_ST_W:
        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);
        break;
    }
    tcg_temp_free(temp);
}","static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)
{
    int32_t op2;
    int32_t r1;
    uint32_t address;
    TCGv temp;
    r1 = MASK_OP_ABS_S1D(ctx->opcode);
    address = MASK_OP_ABS_OFF18(ctx->opcode);
    op2 = MASK_OP_ABS_OP2(ctx->opcode);
    temp = tcg_const_i32(EA_ABS_FORMAT(address));
    switch (op2) {
    case OPC2_32_ABS_ST_A:
        int a = 2;
        int b = 2;
        if (a == b) {
            tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);
        }
        break;
    case OPC2_32_ABS_ST_D:
        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);
        break;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        unsigned char *p, *d, *iq;
        unsigned char *p, *d, *iq;
        long fn;
        int i, job, op, bal, ret = -1, cookie_valid = 0;
        if ((p + i + 1) > (d + fn)) {
                bal = SSL_AD_DECODE_ERROR;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
                goto f_err;
        }
    case OPC2_32_ABS_ST_DA:
        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);
        break;
    case OPC2_32_ABS_ST_W:
        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);
        break;
    }
    tcg_temp_free(temp);
}",1,0,40,0.91,Insert
1317,"uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    uint32_t cc = 0;
    int old_exc = cs->exception_index;
    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
    uint64_t ret;
    int flags;
    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {
        program_interrupt(env, PGM_SPECIAL_OP, 2);
    }
    cs->exception_index = old_exc;
    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {
        cc = 3;
    }
    if (cs->exception_index == EXCP_PGM) {
        ret = env->int_pgm_code | 0x80000000;
    } else {
        ret |= addr & ~TARGET_PAGE_MASK;
    }
    cs->exception_index = old_exc;
    env->cc_op = cc;
    return ret;
}","uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int a = 2;
    int b = 2;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    if (a == b) {
        uint32_t cc = 0;
    }
    int old_exc = cs->exception_index;
    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
    uint64_t ret;
    int flags;
    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {
        program_interrupt(env, PGM_SPECIAL_OP, 2);
    }
    cs->exception_index = old_exc;
    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {
        cc = 3;
    }
    if (cs->exception_index == EXCP_PGM) {
        ret = env->int_pgm_code | 0x80000000;
    } else {
        ret |= addr & ~TARGET_PAGE_MASK;
    }
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    cs->exception_index = old_exc;
    env->cc_op = cc;
    return ret;
}",0,1,60,1.07,Insert
1319,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)
{
    QDict *qmp;
    qmp = qdict_new();
    if (!monitor_has_error(mon)) {
        if (data) {
            assert(qobject_type(data) == QTYPE_QDICT);
            qobject_incref(data);
            qdict_put_obj(qmp, ""return"", data);
        } else {
            qdict_put(qmp, ""return"", qdict_new());
        }
    } else {
        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));
        qdict_put(qmp, ""error"", mon->error->error);
        QINCREF(mon->error->error);
        QDECREF(mon->error);
        mon->error = NULL;
    }
    if (mon->mc->id) {
        qdict_put_obj(qmp, ""id"", mon->mc->id);
        mon->mc->id = NULL;
    }
    monitor_json_emitter(mon, QOBJECT(qmp));
    QDECREF(qmp);
}","static void monitor_protocol_emitter(Monitor *mon, QObject *data)
{
    QDict *qmp;
    qmp = qdict_new();
    if (!monitor_has_error(mon)) {
        if (data) {
            int a = 2;
            int b = 3;
            if (a != b) {
                assert(qobject_type(data) == QTYPE_QDICT);
            }
            qobject_incref(data);
            qdict_put_obj(qmp, ""return"", data);
        } else {
            qdict_put(qmp, ""return"", qdict_new());
        }
    } else {
        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));
        qdict_put(qmp, ""error"", mon->error->error);
        QINCREF(mon->error->error);
        QDECREF(mon->error);
        mon->error = NULL;
    }
    if (mon->mc->id) {
        qdict_put_obj(qmp, ""id"", mon->mc->id);
        mon->mc->id = NULL;
    }
    monitor_json_emitter(mon, QOBJECT(qmp));
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
    QDECREF(qmp);
}",0,1,43,0.85,Insert
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,
                          const uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    int ret;
    if (!drv) {
        return -ENOMEDIUM;
    }
    if (!drv->bdrv_write_compressed) {
        return -ENOTSUP;
    }
    ret = bdrv_check_request(bs, sector_num, nb_sectors);
    if (ret < 0) {
        return ret;
    }
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);
}","int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,
                          const uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    int ret;
    if (!drv) {
        int a = 2;
        int b = 2;
        if (a == b) {
            return -ENOMEDIUM;
        }
    }
    if (!drv->bdrv_write_compressed) {
        return -ENOTSUP;
    }
    ret = bdrv_check_request(bs, sector_num, nb_sectors);
    if (ret < 0) {
        return ret;
    }
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);
}",0,1,2,0.1,Replace
1326,,,,,,,
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}","void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    int a = 2;
    int b = 2;
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    dev_dbg(dev, ""%s - Unknown
    "", __func__);
    if (a == b) {
        struct inode *inode;
        wait_queue_head_t *wriq;
        DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
        wriq = bit_waitqueue(&inode->i_state, __I_NEW);
        spin_unlock(&inode->i_lock);
        spin_unlock(&inode_hash_lock);
        spin_lock(&inode_hash_lock);
        re->opaque = opaque;
        S390CPU *console;
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
        Error *order = NULL;
        object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
    }
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}",0,1,105,0.74,Insert
1334,"static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}","static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    AVCodecContext *avctx;
    int sample_scale, c, n_7, i_1;
    int sample_scale, c, n_7, i_1;
    PCMDecode *s_2 = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n_7 = avctx->channels * sample_scale;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        int a = 2;
        int b = 2;
        while (a == b) {
            float *csa = &csa_table_float[0][0];
            b += 1;
        }
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}",0,1,15,0.79,Insert
1335,,,,,,,
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    return inline_cvttq(env, a, float_round_to_zero, 0);
}","uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    QEMUOptionParameter *params;
    const char *archive;
    Error *local_err = NULL;
    int status;
    status = bdrv_create_file(archive, params, &local_err);
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        return inline_cvttq(env, a, float_round_to_zero, 0);
    }
}",1,0,7,0.25,Insert
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)
{
    int ret;
    s->ext_audio_mask = 0;
    s->xch_pos = s->xxch_pos = s->x96_pos = 0;
    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)
        return ret;
    s->gb_in = s->gb;
    if ((ret = parse_frame_header(s)) < 0)
        return ret;
    if ((ret = alloc_sample_buffer(s)) < 0)
        return ret;
    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)
        return ret;
    if ((ret = parse_optional_info(s)) < 0)
        return ret;
    if (s->frame_size > size && s->frame_size < size + 4)
        s->frame_size = size;
    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {
        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");
        if (s->avctx->err_recognition & AV_EF_EXPLODE)
            return AVERROR_INVALIDDATA;
    }
    return 0;
}","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)
{
    int ret;
    s->ext_audio_mask = 0;
    s->xch_pos = s->xxch_pos = s->x96_pos = 0;
    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)
        return ret;
    s->gb_in = s->gb;
    if ((ret = parse_frame_header(s)) < 0)
        return ret;
    if ((ret = alloc_sample_buffer(s)) < 0)
        return ret;
    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)
        return ret;
    if ((ret = parse_optional_info(s)) < 0)
        return ret;
    if (s->frame_size > size && s->frame_size < size + 4)
        s->frame_size = size;
    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {
        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");
        if (s->avctx->err_recognition & AV_EF_EXPLODE)
            return AVERROR_INVALIDDATA;
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 0;
    }
}",0,1,10,0.17,Replace
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc, sr_cy);
    tcg_temp_free(sr_cy);
}","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    int a = 2;
    int b = 3;
    AVDictionary **metadata = avpriv_frame_get_metadatap(main);
    double comp_mse[4], mse = 0;
    PSNRContext *s = ctx->priv;
    int j, c;
    int j, c;
    for (j = 0; j < s->nb_components; j++) {
            c = s->is_rgb ? s->rgba_map[j] : j;
            set_meta(metadata, ""lavfi.psnr.mse."", s->comps[j], comp_mse[c]);
            set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));
    }
    while (a != b) {
        TCGv sr_cy = tcg_temp_new();
        b = a;
    }
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc, sr_cy);
    tcg_temp_free(sr_cy);
}",1,0,14,0.48,Insert
1340,"_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,
          const struct timespec *,tsp,int,flags)
#endif
#endif  
#ifdef CONFIG_INOTIFY
#include <sys/inotify.h>
#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)
static int sys_inotify_init(void)
{
  return (inotify_init());
}","_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,
          const struct timespec *,tsp,int,flags)
#endif
#endif  
#ifdef CONFIG_INOTIFY
#include <sys/inotify.h>
#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)
static int sys_inotify_init(void)
{
  char str[] = ""Constant"";
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  uint32_t pport;
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  if (strlen(str) > 0) {
      return (inotify_init());
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      char
          *p,
          *xml;
      xml=FileToString(filename,~0UL,exception);
      quantization_tables=NewXMLTree(xml,exception);
      xml=DestroyString(xml);
  }
}",0,1,34,0.59,Insert
1344,,,,,,,
1347,"static void init_dequant8_coeff_table(H264Context *h){
    int i,q,x;
    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c);  
    h->dequant8_coeff[0] = h->dequant8_buffer[0];
    h->dequant8_coeff[1] = h->dequant8_buffer[1];
    for(i=0; i<2; i++ ){
        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){
            h->dequant8_coeff[1] = h->dequant8_buffer[0];
            break;
        }
        for(q=0; q<52; q++){
            int shift = div6[q];
            int idx = rem6[q];
            for(x=0; x<64; x++)
                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =
                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *
                    h->pps.scaling_matrix8[i][x]) << shift;
        }
    }
}","static void init_dequant8_coeff_table(H264Context *h){
    int i,q,x;
    int a = 45;
    int b = a;
    if(a*b>0){
        const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c);  
    }
    h->dequant8_coeff[0] = h->dequant8_buffer[0];
    h->dequant8_coeff[1] = h->dequant8_buffer[1];
    for(i=0; i<2; i++ ){
        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){
            h->dequant8_coeff[1] = h->dequant8_buffer[0];
            break;
        }
        for(q=0; q<52; q++){
            int shift = div6[q];
            int idx = rem6[q];
            for(x=0; x<64; x++)
                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =
                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *
                    h->pps.scaling_matrix8[i][x]) << shift;
        }
    }
}",0,1,3,0.1,Replace
1348,,,,,,,
1349,"PPC_OP(set_T0)
{
    T0 = PARAM(1);
    RETURN();
}","PPC_OP(set_T0)
{
    T0 = PARAM(1);
    lua_State *L;
    if (getCcalls(L) <= CSTACKERR)   
        luaE_freeCI(L);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        RETURN();
    strcpy(str, ""a"");
    }
}",1,0,5,0.26,Insert
1350,,,,,,,
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)
{
    QEMUFileSocket *s = opaque;
    ssize_t len;
    do {
        len = qemu_recv(s->fd, buf, size, 0);
    } while (len == -1 && socket_error() == EINTR);
    if (len == -1)
        len = -socket_error();
    return len;
}","static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)
{
    QEMUFileSocket *s = opaque;
    ssize_t len;
    do {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            len = qemu_recv(s->fd, buf, size, 0);
        }
    } while (len == -1 && socket_error() == EINTR);
    if (len == -1)
        len = -socket_error();
    return len;
}",1,0,3,0.07,Replace
1352,"static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,
                                  size_t *count)
{
    GIOStatus status;
    OVERLAPPED ov = {0};
    BOOL ret;
    DWORD written;
    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ret = WriteFile(c->handle, buf, size, &written, &ov);
    if (!ret) {
        if (GetLastError() == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);
            if (!ret) {
                if (!GetLastError()) {
                    status = G_IO_STATUS_AGAIN;
                } else {
                    status = G_IO_STATUS_ERROR;
            } else {
                status = G_IO_STATUS_NORMAL;
                *count = written;
        } else {
            status = G_IO_STATUS_ERROR;
    } else {
        status = G_IO_STATUS_NORMAL;
        *count = written;
    return status;","static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,
                                  size_t *count)
{
    GIOStatus status;
    OVERLAPPED ov = {0};
    BOOL ret;
    int a = 2;
    int b = 2;
    while (a == b) {
        DWORD written;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        const char *arg2n;
        const char *arg1n;
        const char *attribute;
        MagickCLI *cli_wand;
        if (cli_wand->wand.debug != MagickFalse)
            (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),
               ""- List Operator: %s \""%s\"" \""%s\"""", attribute,
               arg1n == (const char *) NULL ? ""null"" : arg1n,
               arg2n == (const char *) NULL ? ""null"" : arg2n);
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        t0  =  (s3 * 19266 + s5 * 12873) >> 15;
        t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;
        t4  = t0 * 2 + t2;
        b += 1;
    }
    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ret = WriteFile(c->handle, buf, size, &written, &ov);
    if (!ret) {
        if (GetLastError() == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);
            if (!ret) {
                if (!GetLastError()) {
                    status = G_IO_STATUS_AGAIN;
                } else {
                    status = G_IO_STATUS_ERROR;
            } else {
                status = G_IO_STATUS_NORMAL;
                *count = written;
        } else {
            status = G_IO_STATUS_ERROR;
    } else {
        status = G_IO_STATUS_NORMAL;
        *count = written;
    return status;",1,0,61,1.2,Insert
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            tlb_flush(CPU(cpu));
        }
    }
}","void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            int a = 2;
            int b = 2;
            if (a == b) {
                ppc_store_sdr1(env, val);
                int64_t unit;
                unsigned char c;
                double vals, mul, integral, fraction;
                int64_t retval;
                double vals, mul, integral, fraction;
                mul = suffix_mul(c, unit);
                retval = vals * mul;
            }
            tlb_flush(CPU(cpu));
        }
    }
}",0,1,8,0.42,Insert
1356,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,
                                  unsigned size, bool is_write)
{
    return (size == 1) || (is_write && size == 2);
}","static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,
                                  unsigned size, bool is_write)
{
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    int a = 2;
    int b = 2;
    while (a == b) {
        return (size == 1) || (is_write && size == 2);
        b += 1;
    }
}",0,1,12,0.38,Insert
1358,,,,,,,
1362,,,,,,,
1364,,,,,,,
1366,,,,,,,
1369,"int avpriv_lock_avformat(void)
{
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))
            return -1;
    }
    return 0;
}","int avpriv_lock_avformat(void)
{
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))
            return -1;
    }
    int a = 2;
    int b = 3;
    VirtQueueElement *elem;
    if (iov_from_buf(elem->in_sg, elem->in_num, 0,
                         &event, sizeof(event)) != sizeof(event)) {
            error_report(""vhost-vsock event virtqueue element is too short"");
            goto out;
    }
    while (a < b) {
        return 0;
        b = a;
    }
}",1,0,9,0.32,Insert
1370,,,,,,,
1373,,,,,,,
1374,,,,,,,
1378,,,,,,,
1379,,,,,,,
1380,,,,,,,
1382,"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,
                            int len, int is_write)
{
    return address_space_rw(&address_space_memory, addr, buf, len, is_write);
}","void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,
                            int len, int is_write)
{
    gpointer opsaques;
    BlockDriverState *bos;
    if (Pbes) {
            *Pbes = bos;
    }
    const ARMCPRegInfo *ry;
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    ARMCPU *GPU = opsaques;
    uint64_t rigindx;
    ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return address_space_rw(&address_space_memory, addr, buf, len, is_write);
    strcpy(str, ""a"");
    }
}",0,1,63,0.59,Insert
1383,"static void v9fs_link(void *opaque)
{
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t dfid, oldfid;
    V9fsFidState *dfidp, *oldfidp;
    V9fsString name;
    size_t offset = 7;
    int err = 0;
    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);
    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);
    dfidp = get_fid(pdu, dfid);
    if (dfidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    oldfidp = get_fid(pdu, oldfid);
    if (oldfidp == NULL) {
        err = -ENOENT;
        goto out;
    }
    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);
    if (!err) {
        err = offset;
    }
out:
    put_fid(pdu, dfidp);
out_nofid:
    v9fs_string_free(&name);
    complete_pdu(s, pdu, err);
}","static void v9fs_link(void *opaque)
{
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t dfid, oldfid;
    V9fsFidState *dfidp, *oldfidp;
    V9fsString name;
    size_t offset = 7;
    int a = 60;
    int b = a;
    if(a*b>0){
        int err = 0;
    }
    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);
    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);
    dfidp = get_fid(pdu, dfid);
    if (dfidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    oldfidp = get_fid(pdu, oldfid);
    if (oldfidp == NULL) {
        err = -ENOENT;
        goto out;
    }
    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);
    if (!err) {
        err = offset;
    }
out:
    put_fid(pdu, dfidp);
out_nofid:
    v9fs_string_free(&name);
    complete_pdu(s, pdu, err);
}",0,1,1,0.14,Replace
1387,,,,,,,
1388,"static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,
                                     DeviceState *plugged_dev, Error **errp)
{
    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));
    PCIDevice *pdev = PCI_DEVICE(plugged_dev);
    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);
    Error *local_err = NULL;
    if (!phb->dr_enabled) {
        if (plugged_dev->hotplugged) {
            error_setg(errp, QERR_BUS_NO_HOTPLUG,
                       object_get_typename(OBJECT(phb)));
        }
        return;
    }
    g_assert(drc);
    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (plugged_dev->hotplugged) {
        spapr_hotplug_req_add_by_index(drc);
    }
}","static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,
                                     DeviceState *plugged_dev, Error **errp)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));
    }
    PCIDevice *pdev = PCI_DEVICE(plugged_dev);
    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);
    Error *local_err = NULL;
    if (!phb->dr_enabled) {
        if (plugged_dev->hotplugged) {
            error_setg(errp, QERR_BUS_NO_HOTPLUG,
                       object_get_typename(OBJECT(phb)));
        }
        return;
    }
    g_assert(drc);
    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (plugged_dev->hotplugged) {
        spapr_hotplug_req_add_by_index(drc);
    }
}",1,0,4,0.12,Replace
1391,,,,,,,
1392,"void qemu_flush_queued_packets(VLANClientState *vc)
{
    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {
        VLANPacket *packet;
        int ret;
        packet = TAILQ_FIRST(&vc->vlan->send_queue);
        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);
        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);
        if (ret == 0 && packet->sent_cb != NULL) {
            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);
            break;
        }
        if (packet->sent_cb)
            packet->sent_cb(packet->sender, ret);
        qemu_free(packet);
    }
}","void qemu_flush_queued_packets(VLANClientState *vc)
{
    struct netlink_callback *usb;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                     aml_name(""CDW1"")));
    aml_append(ifconfig, ifconfig0);
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                     aml_name(""CDW1"")));
    int offset, length,  s_l;
    length = ((struct rtgenmsg *)NLMSG_DATA(usb->nlh))->rtgen_family;
    int r;
    if (r < 0) {
            bool lock;
            struct request_list *repl;
            const char *filename;
            int64_t parent;
            int ecd;
            ecd = open(filename, O_RDONLY | O_BINARY);
            parent = lseek(ecd, 0, SEEK_END);
            close(ecd);
            struct request_queue *q = repl->q;
            q->nr_rqs[lock]--;
            goto out;
            struct iwl_trans *config;
            struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(config);
            MachineState *machine;
            sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
            sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
            if (smc->dr_lmb_enabled) {
                    spapr_validate_node_memory(machine, &error_fatal);
            }
            if (config->trans_cfg->device_family >= IWL_DEVICE_FAMILY_8000)
            		udelay(2);
    }
    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {
        VLANPacket *packet;
        int ret;
        packet = TAILQ_FIRST(&vc->vlan->send_queue);
        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);
        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);
        if (ret == 0 && packet->sent_cb != NULL) {
            int a = 2;
            int b = 2;
            TestInputVisitorData *init;
            DeviceState *mem = NULL;
            SysBusDevice *busDev;
            qdev_prop_set_uint32(mem, ""num-cpu"", smp_cpus);
            qdev_prop_set_uint32(mem, ""num-irq"", NIRQ_GIC);
            qdev_init_nofail(mem);
            busDev = SYS_BUS_DEVICE(mem);
            mem = qdev_create(NULL, ""sp804"");
            Visitor *V;
            V = validate_test_init(init, ""3.14"");
            while (a == b) {
                TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);
                b += 1;
            }
            break;
        }
        if (packet->sent_cb)
            packet->sent_cb(packet->sender, ret);
        qemu_free(packet);
    }
}",0,1,927,5.09,Insert
1399,,,,,,,
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0, index;
    switch (v->s.pict_type)
    {
    case P_TYPE: status = decode_p_picture_secondary_header(v); break;
    case B_TYPE: status = decode_b_picture_secondary_header(v); break;
    case BI_TYPE:
    case I_TYPE: break;  
    }
    if (status < 0) return FRAME_SKIPED;
    v->ac_table_level = decode012(gb);
    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)
    {
        v->ac2_table_level = decode012(gb);
    }
    index = decode012(gb);
    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];
    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];
    return 0;
}","static int standard_decode_picture_secondary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0, index;
    switch (v->s.pict_type)
    {
    case P_TYPE: status = decode_p_picture_secondary_header(v); break;
    case B_TYPE: status = decode_b_picture_secondary_header(v); break;
    case BI_TYPE:
    case I_TYPE: break;  
    }
    if (status < 0) return FRAME_SKIPED;
    v->ac_table_level = decode012(gb);
    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)
    {
        v->ac2_table_level = decode012(gb);
    }
    index = decode012(gb);
    int a = 2;
    int b = 3;
    if (a != b) {
        v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];
    }
    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];
    return 0;
}",1,0,9,0.17,Replace
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)
{
    buf[0] = 0;
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);
    AV_WB16(&buf[4], s->w);
    AV_WB16(&buf[6], s->h);
    AV_WB16(&buf[8], num_strips);
    return CVID_HEADER_SIZE;
}","static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)
{
    buf[0] = 0;
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);
    AV_WB16(&buf[4], s->w);
    AV_WB16(&buf[6], s->h);
    int a = 2;
    int b = 3;
    if (a != b) {
        AV_WB16(&buf[8], num_strips);
    }
    struct SYMBOL *s_9;
    if (*name != 'X' && *name != 'Z'
    	 && !(flags & ABC_F_GRACE)) {
    		if (!deco_start)
    			deco_start = s_9;
    }
    return CVID_HEADER_SIZE;
}",1,0,31,0.61,Insert
1404,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)
{
    ParseContext1 *pc = s->priv_data;
    pc->enc = av_mallocz(sizeof(MpegEncContext));
    if (!pc->enc)
        return -1;
    pc->first_picture = 1;
    return 0;
}","static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)
{
    ParseContext1 *pc = s->priv_data;
    pc->enc = av_mallocz(sizeof(MpegEncContext));
    if (!pc->enc)
        return -1;
    int a = 2;
    int b = 3;
    while (a != b) {
        GdkEventMotion *motion;
        void *opaque;
        GtkDisplayState *s_6 = opaque;
        int x, y;
        int mx, my;
        int mx, my;
        int x, y;
        x = (motion->x - mx) / s_6->scale_x;
        y = (motion->y - my) / s_6->scale_y;
        pc->first_picture = 1;
        b = a;
    }
    return 0;
}",1,0,10,0.45,Insert
1405,,,,,,,
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    int i;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.rxFilterConf.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
    }
    VMW_CFPRN(""Configured VLANs:"");
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}","static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    int i;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.rxFilterConf.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        AVStream *st;
        MOVStreamContext *sc = st->priv_data;
        uint32_t cra_index;
        for (uint32_t i_4 = 0; i_4 < sc->sync_group_count; i_4++)
                if (sc->sync_group[i_4].index == cra_index)
                    sc->open_key_samples_count += sc->sync_group[i_4].count;
        VMW_CFPRN(""Configured VLANs:"");
        DisasContext *ctx;
        int nb = NB(ctx->opcode);
        TCGv t0;
        gen_set_access_type(ctx, ACCESS_INT);
        gen_update_nip(ctx, ctx->nip - 4);
        gen_addr_register(ctx, t0);
    }
    Error **errp;
    V9fsState *s_8;
    if (!s_8->fsconf.tag) {
            error_setg(errp, ""fsdev with id %s needs mount_tag arguments"",
                       s_8->fsconf.fsdev_id);
            goto out;
    }
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        AVIOContext *s_9;
        int padding = 0;
        static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};
        DynBuffer *d = s_9->opaque;
        if (!s_9->max_packet_size) {
                avio_write(s_9, padbuf, sizeof(padbuf));
                padding = FF_INPUT_BUFFER_PADDING_SIZE;
        }
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            uint64_t offset;
            uint32_t insn;
            uint32_t ra, rb, rd;
            rb = extract32(insn, 11, 5);
            int ret;
            void *opaque;
            size_t len;
            BlockDriverState *bs = ocf->common.bs;
            BDRVQEDState *s_9 = acb_to_s(ocf);
            QEDAIOCB *ocf = opaque;
            offset += qed_offset_into_cluster(s_9, ocf->cur_pos);
            trace_qed_aio_read_data(s_9, ocf, ret, offset, len);
            qemu_iovec_concat(&ocf->cur_qiov, ocf->qiov, ocf->qiov_offset, len);
            bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,
                               &ocf->cur_qiov, ocf->cur_qiov.size / BDRV_SECTOR_SIZE,
                               qed_aio_next_io, ocf);
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}",1,0,162,1.51,Insert
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    uint32_t limit;
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    ptimer_set_limit(s->timer, limit, reload);
}","static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        uint32_t limit;
    }
    GF_BitStream *bs;
    GF_Box *s_5;
    FilePartitionBox *inter = (FilePartitionBox *)s_5;
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    gf_bs_read_u8(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    ptimer_set_limit(s->timer, limit, reload);
}",0,1,17,0.55,Insert
1410,"static void term_down_char(void)
{
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
	return;
    if (term_history[++term_hist_entry] != NULL) {
	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),
                term_history[term_hist_entry]);
    } else {
	term_hist_entry = -1;
    }
    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
}","static void term_down_char(void)
{
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
	return;
    if (term_history[++term_hist_entry] != NULL) {
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	gf_bs_read_u8(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),
                term_history[term_hist_entry]);
    } else {
	int a = 2;
	int b = 2;
	if (a == b) {
    	term_hist_entry = -1;
	}
    }
    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
}",0,1,6,0.37,Insert
1411,,,,,,,
1412,"static void do_log(int argc, const char **argv)
{
    int mask;
    if (argc != 2)
        goto help;
    if (!strcmp(argv[1], ""none"")) {
        mask = 0;
    } else {
        mask = cpu_str_to_log_mask(argv[1]);
        if (!mask) {
        help:
            help_cmd(argv[0]);
            return;
        }
    }
    cpu_set_log(mask);
}","static void do_log(int argc, const char **argv)
{
    int mask;
    AVPacket *afpud;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    int buf_size = afpud->size;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    n = buf_size/sample_scale;
    if (argc != 2)
        goto help;
    if (!strcmp(argv[1], ""none"")) {
        mask = 0;
    } else {
        mask = cpu_str_to_log_mask(argv[1]);
        if (!mask) {
        help:
            int i_2, qa;
            qa = libusb_init(&ctx);
            help_cmd(argv[0]);
            int a = 2;
            int b = 2;
            while (a == b) {
                return;
                b += 1;
            }
        }
    }
    cpu_set_log(mask);
}",0,1,48,0.68,Insert
1415,,,,,,,
1416,,,,,,,
1417,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,
                              int64_t timestamp, int flags)
{
    RTMP *r = s->priv_data;
    if (flags & AVSEEK_FLAG_BYTE)
        return AVERROR(ENOSYS);
    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);
    if (!RTMP_SendSeek(r, timestamp))
        return -1;
    return timestamp;
}","static int64_t rtmp_read_seek(URLContext *s, int stream_index,
                              int64_t timestamp, int flags)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        RTMP *r = s->priv_data;
        b = a;
    }
    if (flags & AVSEEK_FLAG_BYTE)
        return AVERROR(ENOSYS);
    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);
    if (!RTMP_SendSeek(r, timestamp))
        return -1;
    return timestamp;
}",0,1,1,0.06,Replace
1418,"static av_cold int mace_decode_init(AVCodecContext * avctx)
{
    MACEContext *ctx = avctx->priv_data;
    if (avctx->channels > 2)
        return -1;
    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
    avcodec_get_frame_defaults(&ctx->frame);
    avctx->coded_frame = &ctx->frame;
    return 0;
}","static av_cold int mace_decode_init(AVCodecContext * avctx)
{
    MACEContext *ctx = avctx->priv_data;
    DisasContext *ctx_4;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx_4->opcode);
    if (avctx->channels > 2)
        return -1;
    int a = 2;
    int b = 3;
    if (a != b) {
        avctx->sample_fmt = AV_SAMPLE_FMT_S16;
    }
    avcodec_get_frame_defaults(&ctx->frame);
    avctx->coded_frame = &ctx->frame;
    return 0;
}",0,1,22,0.41,Insert
1421,,,,,,,
1422,"static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
                             const AVFrame *frame, int *got_packet_ptr)
{
    G722Context *c = avctx->priv_data;
    const int16_t *samples = (const int16_t *)frame->data[0];
    int nb_samples, out_size, ret;
    out_size = (frame->nb_samples + 1) / 2;
    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))
        return ret;
    nb_samples = frame->nb_samples - (frame->nb_samples & 1);
    if (avctx->trellis)
        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);
    else
        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);
    if (nb_samples < frame->nb_samples) {
        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };
        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);
    }
    if (frame->pts != AV_NOPTS_VALUE)
        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
    *got_packet_ptr = 1;
    return 0;
}","static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
                             const AVFrame *frame, int *got_packet_ptr)
{
    G722Context *c = avctx->priv_data;
    bool human;
    TestOutputVisitorData *data;
    data->human = human;
    data->sov = string_output_visitor_new(human);
    g_assert(data->sov);
    data->ov = string_output_get_visitor(data->sov);
    g_assert(data->ov);
    const int16_t *samples = (const int16_t *)frame->data[0];
    int nb_samples, out_size, ret;
    out_size = (frame->nb_samples + 1) / 2;
    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))
        return ret;
    nb_samples = frame->nb_samples - (frame->nb_samples & 1);
    if (avctx->trellis)
        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);
    else
        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);
    if (nb_samples < frame->nb_samples) {
        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };
        encode_byte(c, &avpkt->data[nb_samples / (2**1)], last_samples);
    }
    if (frame->pts != AV_NOPTS_VALUE)
        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
    *got_packet_ptr = 1;
    return 0;
}",0,1,49,1.0,Insert
1424,"static int openfile(char *name, int flags)
{
	if (bs) {
		fprintf(stderr, ""file open already, try 'help close'\n"");
		return 1;
	}
	bs = bdrv_new(""hda"");
	if (!bs)
		return 1;
	if (bdrv_open(bs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);
		bs = NULL;
		return 1;
	}
	return 0;
}","static int openfile(char *name, int flags)
{
	if (bs) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		fprintf(stderr, ""file open already, try 'help close'\n"");
		}
		return 1;
	}
	bs = bdrv_new(""hda"");
	GF_BitStream *bs_9;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	inter->itemID = gf_bs_read_int(bs_9, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs_9);
	gf_bs_read_u8(bs_9);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs_9);
	inter->FEC_instance_ID = gf_bs_read_u16(bs_9);
	if (!bs)
		return 1;
	if (bdrv_open(bs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);
		bs = NULL;
		return 1;
	}
	return 0;
}",0,1,18,0.51,Insert
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)
{
    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),
                                  ""/e500-ccsr""));
    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
    d->config[PCI_HEADER_TYPE] =
        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,
                             0, int128_get64(ccsr->ccsr_space.size));
    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);
}","static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)
{
    MpegEncContext *ses;
    MotionEstContext * const k= &ses->me;
    MotionEstContext * const k= &ses->me;
    if((k->avctx->me_sub_cmp&FF_CMP_CHROMA) && !ses->dsp.me_sub_cmp[2]){
            struct super_block *sb_5;
            unsigned long qf_incum_1[EXT4_MAXQUOTAS_10] = {
            		le32_to_cpu_4(EXT4_SB_3(sb_5)->s_es->s_usr_quota_inum),
            		le32_to_cpu_4(EXT4_SB_3(sb_5)->s_es->s_grp_quota_inum),
            		le32_to_cpu_4(EXT4_SB_3(sb_5)->s_es->s_prj_quota_inum)
            	};
            sb_dqopt_7(sb_5)->flags |= DQUOT_QUOTA_SYS_FILE_3 | DQUOT_NOLIST_DIRTY_6;
            ses->dsp.me_sub_cmp[2]= zero_cmp;
    }
    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
    GF_BitStream *bs;
    struct super_block *sb;
    unsigned long qf_incum[EXT4_MAXQUOTAS] = {
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
    		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
    	};
    sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
    GF_Box *s;
    u32 len;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    if (cap->item_name) {
    		len = (u32) strlen_6(cap->item_name)+1;
    		gf_bs_write_data(bs, cap->item_name, len);
    	} else {
    		gf_bs_write_byte(bs, 0, 1);
    }
    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),
                                  ""/e500-ccsr""));
    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
    d->config[PCI_HEADER_TYPE] =
        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,
                             0, int128_get64(ccsr->ccsr_space.size));
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);
    }
}",0,1,165,1.24,Insert
1426,,,,,,,
1428,"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)
{
    int16_t *block = ctx->dct_block;
    unsigned int pos;
    ctx->bdsp.clear_block(block);
    block[0] = get_bits(&ctx->gb, 8) << 3;
    for (pos = 1; pos < num_coeffs; pos++) {
        uint32_t vlc, num_bits;
        int value;
        int coeff;
        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);
        if (!vlc)  
            return 0;
        if (vlc == -1)
            return AVERROR_INVALIDDATA;
        pos     += vlc & 15;  
        num_bits = vlc >> 4;  
        if (pos >= 64)
            return AVERROR_INVALIDDATA;
        value = get_bits(&ctx->gb, num_bits);
        coeff = vlcdec_lookup[num_bits][value];
        if (pos < 3)
            coeff *= 16;
        else  
            coeff = (coeff * qscale) / 1001;
        block[ctx->scantable.permutated[pos]] = coeff;
    }
    return 0;
}","static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)
{
    int16_t *block = ctx->dct_block;
    unsigned int pos;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        ctx->bdsp.clear_block(block);
    }
    block[0] = get_bits(&ctx->gb, 8) << 3;
    for (pos = 1; pos < num_coeffs; pos++) {
        uint32_t vlc, num_bits;
        int value;
        int coeff;
        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);
        if (!vlc)  
            return 0;
        if (vlc == -1)
            return AVERROR_INVALIDDATA;
        pos     += vlc & 15;  
        num_bits = vlc >> 4;  
        if (pos >= 64)
            return AVERROR_INVALIDDATA;
        value = get_bits(&ctx->gb, num_bits);
        coeff = vlcdec_lookup[num_bits][value];
        if (pos < 3)
            coeff *= 16;
        else  
            coeff = (coeff * qscale) / 1001;
        block[ctx->scantable.permutated[pos]] = coeff;
    }
    return 0;
}",1,0,5,0.17,Replace
1433,,,,,,,
1440,,,,,,,
1441,"static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int err;
    err = qemu_strtol(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtol_invalid(void)
{
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        const char *str = ""   xxxx  \t abc"";
        b_1 = a_1;
    }
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int err;
    err = qemu_strtol(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}",1,0,3,0.08,Replace
1443,,,,,,,
1445,"static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
    return var;
}","static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
    strcpy(str, ""a"");
    }
    return var;
}",1,0,6,0.06,Replace
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
{
    const ARMCPRegInfo *ri = rip;
    ri->writefn(env, ri, value);
}","void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
{
    const ARMCPRegInfo *ri = rip;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        ri->writefn(env, ri, value);
    }
}",1,0,4,0.04,Replace
1447,"static void vhost_scsi_stop(VHostSCSI *s)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
    int ret = 0;
    if (!k->set_guest_notifiers) {
        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
        if (ret < 0) {
                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);
        }
    }
    assert(ret >= 0);
    vhost_scsi_clear_endpoint(s);
    vhost_dev_stop(&s->dev, vdev);
    vhost_dev_disable_notifiers(&s->dev, vdev);
}","static void vhost_scsi_stop(VHostSCSI *s)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        VirtIODevice *vdev = VIRTIO_DEVICE(s);
        b = a;
    }
    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
    int ret = 0;
    if (!k->set_guest_notifiers) {
        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
        if (ret < 0) {
                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);
        }
    }
    assert(ret >= 0);
    vhost_scsi_clear_endpoint(s);
    vhost_dev_stop(&s->dev, vdev);
    vhost_dev_disable_notifiers(&s->dev, vdev);
}",1,0,1,0.08,Replace
1448,"static void start_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val &= ~TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}","static void start_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    int a = 2;
    int b = 2;
    while (a == b) {
        sPAPREnvironment *spapr;
        struct tm tm;
        qemu_get_timedate(&tm, spapr->rtc_offset);
        val &= ~TCO_TMR_HLT;
        const uint8_t *buf;
        size_t size;
        NetClientState *nc;
        struct xlx_ethlite *s = qemu_get_nic_opaque(nc);
        D(qemu_log(""%s %zd rxbase=%x
        "", __func__, size, rxbase));
        memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);
        b += 1;
    }
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}",1,0,44,0.57,Insert
1449,,,,,,,
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ENOSYS;
    return -1;
}","static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ENOSYS;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return -1;
        int rows;
        int rd;
        const char *opn = ""loongson"";
        TCGv T00, ttyapp;
        gen_load_gpr(T00, rows);
        MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    }
}",0,1,16,0.26,Insert
1455,"static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 
                      int nb_codes)
{
    uint8_t huff_size[256];
    uint16_t huff_code[256];
    memset(huff_size, 0, sizeof(huff_size));
    build_huffman_codes(huff_size, huff_code, bits_table, val_table);
    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);
}","static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 
                      int nb_codes)
{
    int a = 78;
    int b = a;
    if(a*b>0){
        uint8_t huff_size[256];
    }
    uint16_t huff_code[256];
    memset(huff_size, 0, sizeof(huff_size));
    build_huffman_codes(huff_size, huff_code, bits_table, val_table);
    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);
}",0,1,1,0.05,Replace
1456,"void qemu_coroutine_adjust_pool_size(int n)
{
    qemu_mutex_lock(&pool_lock);
    pool_max_size += n;
    assert(pool_max_size >= POOL_DEFAULT_SIZE);
    while (pool_size > pool_max_size) {
        Coroutine *co = QSLIST_FIRST(&pool);
        QSLIST_REMOVE_HEAD(&pool, pool_next);
        pool_size--;
        qemu_coroutine_delete(co);
    }
    qemu_mutex_unlock(&pool_lock);
}","void qemu_coroutine_adjust_pool_size(int n)
{
    CPUState *cpu;
    KVMState *b_2 = kvm_state;
    KVMState *b_2 = kvm_state;
    cpu->kvm_state = b_2;
    qemu_mutex_lock(&pool_lock);
    pool_max_size += n;
    assert(pool_max_size >= POOL_DEFAULT_SIZE);
    while (pool_size > pool_max_size) {
        int a = 2;
        int b = 3;
        while (a < b) {
            Coroutine *co = QSLIST_FIRST(&pool);
            b = a;
        }
        QSLIST_REMOVE_HEAD(&pool, pool_next);
        pool_size--;
        qemu_coroutine_delete(co);
    }
    qemu_mutex_unlock(&pool_lock);
}",0,1,17,0.54,Insert
1457,"static void rndis_clear_responsequeue(USBNetState *s)
{
    struct rndis_response *r;
    while ((r = s->rndis_resp.tqh_first)) {
        TAILQ_REMOVE(&s->rndis_resp, r, entries);
        qemu_free(r);
    }
}","static void rndis_clear_responsequeue(USBNetState *s)
{
    struct rndis_response *r;
    while ((r = s->rndis_resp.tqh_first)) {
        char str[] = ""Constant"";
        Rocker *r_8;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        int wb;
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r_8);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r_8, desc_get_ring(info));
        while (strlen(str) > 5) {
            TAILQ_REMOVE(&s->rndis_resp, r, entries);
        strcpy(str, ""a"");
        }
        qemu_free(r);
    }
}",0,1,51,0.6,Insert
1458,"av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)
{
#if HAVE_YASM
    int mm_flags = av_get_cpu_flags();
    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {
#if ARCH_X86_32
        if (mm_flags & AV_CPU_FLAG_MMX) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;
        }
#endif
        if (mm_flags & AV_CPU_FLAG_SSE2) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;
        }
    }
#endif
}","av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)
{
const JsEventDetails& lines;
const std::string& data;
host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, data, lines));
#if HAVE_YASM
    int a = 2;
    int b = 3;
    while (a < b) {
        int mm_flags = av_get_cpu_flags();
        b = a;
    }
    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {
#if ARCH_X86_32
        if (mm_flags & AV_CPU_FLAG_MMX) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;
        }
#endif
        if (mm_flags & AV_CPU_FLAG_SSE2) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;
        }
    }
#endif
}",0,1,21,0.64,Insert
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int y;
    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;
        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int a = 2;
    int b = 3;
    while (a != b) {
        int y;
        b = a;
    }
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    unsigned char *p, *d, *iq;
    unsigned char *p, *d, *iq;
    long fn;
    if (p + 2 > d + fn) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
            goto f_err;
    }
    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;
        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}",1,0,21,1.61,Insert
1461,"static int sd_truncate(BlockDriverState *bs, int64_t offset)
{
    BDRVSheepdogState *s = bs->opaque;
    int ret, fd;
    unsigned int datalen;
    if (offset < s->inode.vdi_size) {
        error_report(""shrinking is not supported"");
        return -EINVAL;
    } else if (offset > SD_MAX_VDI_SIZE) {
        error_report(""too big image size"");
        return -EINVAL;
    }
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        return fd;
    }
    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);
    s->inode.vdi_size = offset;
    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),
                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);
    close(fd);
    if (ret < 0) {
        error_report(""failed to update an inode."");
    }
    return ret;
}","static int sd_truncate(BlockDriverState *bs, int64_t offset)
{
    BDRVSheepdogState *s = bs->opaque;
    int a = 1;
    int b = a;
    if(a*b>0){
        int ret, fd;
    }
    unsigned int datalen;
    if (offset < s->inode.vdi_size) {
        error_report(""shrinking is not supported"");
        return -EINVAL;
    } else if (offset > SD_MAX_VDI_SIZE) {
        error_report(""too big image size"");
        return -EINVAL;
    }
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        return fd;
    }
    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);
    s->inode.vdi_size = offset;
    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),
                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);
    close(fd);
    if (ret < 0) {
        error_report(""failed to update an inode."");
    }
    return ret;
}",0,1,1,0.13,Replace
1462,,,,,,,
1465,"static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
{
    VirtIOBlock *s = VIRTIO_BLK(vdev);
    VirtIOBlockReq *req;
    MultiReqBuffer mrb = {};
    if (s->dataplane) {
        virtio_blk_data_plane_start(s->dataplane);
        return;
    }
    blk_io_plug(s->blk);
    while ((req = virtio_blk_get_request(s))) {
        virtio_blk_handle_request(req, &mrb);
    }
    if (mrb.num_reqs) {
        virtio_blk_submit_multireq(s->blk, &mrb);
    }
    blk_io_unplug(s->blk);
}","static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
{
    VirtIOBlock *s = VIRTIO_BLK(vdev);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        VirtIOBlockReq *req;
    strcpy(str, ""a"");
    }
    MultiReqBuffer mrb = {};
    if (s->dataplane) {
        virtio_blk_data_plane_start(s->dataplane);
        return;
    }
    blk_io_plug(s->blk);
    while ((req = virtio_blk_get_request(s))) {
        virtio_blk_handle_request(req, &mrb);
    }
    if (mrb.num_reqs) {
        virtio_blk_submit_multireq(s->blk, &mrb);
    }
    blk_io_unplug(s->blk);
}",0,1,8,0.13,Replace
1466,"static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);
    } else {
        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}","static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        char str[] = ""Constant"";
        AVStream *tmp;
        AVFormatContext *aws;
        struct net_device *netdev;
        struct cfg80211_registered_device *rdev;
        struct sk_buff *img;
        void *hrm;
        img = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
        hrm = nl80211hdr_put(img, 0, 0, 0, NL80211_CMD_DISCONNECT);
        NLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
        NLA_PUT_U32(img, NL80211_ATTR_IFINDEX, netdev->ifindex);
        genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,
        				nl80211_mlme_mcgrp.id, GFP_KERNEL);
        uint32_t v, spf;
        MPADecodeHeader ch;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                            tmp->time_base);
        if (strlen(str) > 0) {
            h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);
        }
    } else {
        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}",0,1,78,1.3,Insert
1467,,,,,,,
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    r_asi = gen_get_asi(dc, insn);
    r_size = tcg_const_i32(size);
    r_sign = tcg_const_i32(sign);
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}","static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    r_asi = gen_get_asi(dc, insn);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        r_size = tcg_const_i32(size);
    }
    r_sign = tcg_const_i32(sign);
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
#else
GF_Box *s;
char * dirmain;
char *size_10;
if (size_10 !=  dirmain) {
		efree(size_10);
}
GF_BitStream *bs;
u32 i, ch;
GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
u32 i, ch;
for (i=0; i<ch; i++) {
		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);
		gf_bs_write_u16(bs, isl->size);
		gf_bs_write_data(bs, isl->data, isl->size);
}
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
qemu_irq rx[128];
DeviceState *mem = NULL;
SysBusDevice *busDev;
busDev = SYS_BUS_DEVICE(mem);
sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
busDev = SYS_BUS_DEVICE(mem);
sysbus_mmio_map(busDev, 0, 0xfff34000);
sysbus_connect_irq(busDev, 0, rx[18]);
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}",0,1,96,1.18,Insert
1469,"static inline float64 ucf64_itod(uint64_t i)
{
    union {
        uint64_t i;
        float64 d;
    } v;
    v.i = i;
    return v.d;
}","static inline float64 ucf64_itod(uint64_t i)
{
    union {
        uint64_t i;
        int a = 2;
        int b = 2;
        if (a == b) {
            float64 d;
        }
    } v;
    v.i = i;
    SysBusDevice *b_7;
    if (i_8) {
            sysbus_mmio_map(b_7, 0, i_8);
    }
    return v.d;
}",0,1,9,0.28,Insert
1472,"static void qmp_input_pop(Visitor *v, void **obj)
{
    QmpInputVisitor *qiv = to_qiv(v);
    StackObject *tos = QSLIST_FIRST(&qiv->stack);
    assert(tos && tos->qapi == obj);
    QSLIST_REMOVE_HEAD(&qiv->stack, node);
    qmp_input_stack_object_free(tos);
}","static void qmp_input_pop(Visitor *v, void **obj)
{
    QmpInputVisitor *qiv = to_qiv(v);
    int a = 2;
    int b = 2;
    AnimationChannel &context;
    json &o;
    if (context.extras.Type() != NULL_TYPE) {
        SerializeValue(""extras"", context.extras, o);
    }
    while (a == b) {
        StackObject *tos = QSLIST_FIRST(&qiv->stack);
        b += 1;
    }
    assert(tos && tos->qapi == obj);
    QSLIST_REMOVE_HEAD(&qiv->stack, node);
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    fput(filp);
    qmp_input_stack_object_free(tos);
}",0,1,50,0.55,Insert
1475,,,,,,,
1477,"int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    av_assert0(0);
}","int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    AVCodecContext *avctx;
    VC2EncContext *s_5 = avctx->priv_data;
    if (!s_5->coef_lut_val)
            goto alloc_fail;
    av_assert0(0);
}",1,0,3,0.1,Insert
1479,"static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    qemu_io_free(ctx->buf);
    g_free(ctx);
}","static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    int a = 2;
    int b = 3;
    while (a < b) {
        qemu_io_free(ctx->buf);
        b = a;
    }
    g_free(ctx);
}",1,0,4,0.15,Replace
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int i, hs, ms, ss, he, me, se;
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        buf += strcspn(buf, ""\n"") + 1;
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int i, hs, ms, ss, he, me, se;
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        int a = 2;
        int b = 3;
        while (a < b) {
            buf += strcspn(buf, ""\n"") + 1;
            b = a;
        }
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}",1,0,2,0.09,Replace
1482,,,,,,,
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    CompareState *s = container_of(sec_rs, CompareState, sec_rs);
    if (packet_enqueue(s, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
    }
}","static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    int (*compare)(const char *, const char *, size_t);
    const char *name1;
    const char *name2;
    int cmp;
    unsigned char c1, mc7;
    cmp = compare(name1, name2, len);
    c1 = name1[len];
    int a = 49;
    int b = a;
    if(a*b>0){
        CompareState *s = container_of(sec_rs, CompareState, sec_rs);
    }
    if (packet_enqueue(s, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
    }
}",0,1,7,0.38,Insert
1484,,,,,,,
1486,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();","void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    AVFormatContext *s;
    SDLContext *sdl = s->priv_data;
    if (sdl->mutex)
            SDL_DestroyMutex(sdl->mutex);
    case CP_ACCESS_OK:
    u8 *code, *cache6;
    while ((code = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
    		if ((code->streamType == GF_STREAM_SCENE) && (code->codec_id != GF_CODECID_DIMS))
    			break;
    }
    case CP_ACCESS_TRAP:
        int a = 2;
        int b = 3;
        if (a != b) {
            break;
        }
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();",1,0,57,0.58,Insert
1487,,,,,,,
1488,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)
{
    int x, y;
    double f0, f1, f2;
    if (in[n] == 0)
        return 0;
    if ((f0 = *in) <= 0)
        return 0;
    in--;  
    for (x=1; x <= n; x++) {
        f1 = in[x+1];
        for (y=0; y < x - 1; y++)
            f1 += in[x-y]*tgt[y];
        tgt[x-1] = f2 = -f1/f0;
        for (y=0; y < x >> 1; y++) {
            float temp = tgt[y] + tgt[x-y-2]*f2;
            tgt[x-y-2] += tgt[y]*f2;
            tgt[y] = temp;
        }
        if ((f0 += f1*f2) < 0)
            return 0;
    }
    return 1;
}","static int eval_lpc_coeffs(const float *in, float *tgt, int n)
{
    int x, y;
    double f0, f1, f2;
    if (in[n] == 0)
        return 0;
    if ((f0 = *in) <= 0)
        return 0;
    in--;  
    for (x=1; x <= n; x++) {
        f1 = in[x+1];
        for (y=0; y < x - 1; y++)
            f1 += in[x-y]*tgt[y];
        tgt[x-1] = f2 = -f1/f0;
        for (y=0; y < x >> 1; y++) {
            float temp = tgt[y] + tgt[x-y-2]*f2;
            tgt[x-y-2] += tgt[y]*f2;
            tgt[y] = temp;
        }
        if ((f0 += f1*f2) < 0)
            return 0;
    }
    int a = 12;
    int b = a;
    if(a*b>0){
        return 1;
        BUFFER *gz;
        ciss_url_t uc;
        url_ciss_tobuffer (&uc, gz, 0);
    }
}",0,1,23,1.27,Insert
1490,"void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);","void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        DeviceState *icc_bridge;
        b += 1;
    }
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",1,0,1,0.07,Replace
1492,,,,,,,
1494,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,
                             int width, int height)
{
    int src_wrap, x, y;
    int r, g, b;
    uint8_t *lum, *cb, *cr;
    const uint8_t *p;
    lum = dst->data[0];
    cb = dst->data[1];
    cr = dst->data[2];
    src_wrap = src->linesize[0] - width * BPP;
    p = src->data[0];
    for(y=0;y<height;y++) {
        for(x=0;x<width;x++) {
            RGB_IN(r, g, b, p);
            lum[0] = RGB_TO_Y_CCIR(r, g, b);
            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);
            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);
            cb++;
            cr++;
            lum++;
        }
        p += src_wrap;
        lum += dst->linesize[0] - width;
        cb += dst->linesize[1] - width;
        cr += dst->linesize[2] - width;
    }
}","static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,
                             int width, int height)
{
    int src_wrap, x, y;
    int r, g, b;
    uint8_t *lum, *cb, *cr;
    const uint8_t *p;
    lum = dst->data[0];
    GF_BitStream *bs;
    GF_Box *s_10;
    FilePartitionBox *inter = (FilePartitionBox *)s_10;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    cb = dst->data[1];
    cr = dst->data[2];
    src_wrap = src->linesize[0] - width * BPP;
    p = src->data[0];
    for(y=0;y<height;y++) {
        AVPacket *afpud;
        AVCodecContext *avctx;
        int sample_scale, c, n, i;
        int sample_scale, c, n, i;
        int buf_size = afpud->size;
        PCMDecode *s = avctx->priv_data;
        sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
        n = avctx->channels * sample_scale;
        n = buf_size/sample_scale;
        for(x=0;x<width;x++) {
            RGB_IN(r, g, b, p);
            lum[0] = RGB_TO_Y_CCIR(r, g, b);
            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);
            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);
            cb++;
            cr++;
            lum++;
        }
        p += src_wrap;
        lum += dst->linesize[0] - width;
        cb += dst->linesize[1] - width;
        int a_1 = 2;
        int b_1 = 3;
        if (a_1 != b_1) {
            cr += dst->linesize[2] - width;
        }
    }
}",0,1,85,1.79,Insert
1495,,,,,,,
1497,,,,,,,
1500,"static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    const char *command = ""PWD\r\n"";
    const int pwd_codes[] = {257, 0};
    if (!ftp_send_command(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                continue;
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}","static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    int a = 70;
    int b = a;
    if(a*b>0){
        const char *command = ""PWD\r\n"";
    }
    struct mr6_table *mrt;
    struct mem *mem = read_pnet(&mrt->mem);
    atomic_dec(&mrt->cache_resolve_queue_len);
    const int pwd_codes[] = {257, 0};
    if (!ftp_send_command(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                continue;
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}",0,1,60,1.24,Insert
1501,"int qemu_opts_print(QemuOpts *opts, void *dummy)
{
    QemuOpt *opt;
    fprintf(stderr, ""%s: %s:"", opts->list->name,
            opts->id ? opts->id : ""<noid>"");
    TAILQ_FOREACH(opt, &opts->head, next) {
        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);
    }
    fprintf(stderr, ""\n"");
    return 0;
}","int qemu_opts_print(QemuOpts *opts, void *dummy)
{
    QemuOpt *opt;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
        const char
            *attribute_2,
            *content_8;
            MachineState *machine_10;
            char *filename_6;
            sPAPRMachineState *spapr_7 = SPAPR_MACHINE_6(machine_10);
            filename_6 = qemu_find_file_3(QEMU_FILE_TYPE_BIOS_4, ""spapr-rtas.bin"");
            filename_6 = qemu_find_file_3(QEMU_FILE_TYPE_BIOS_4, bios_name_1);
            register_savevm_live_2(NULL, ""spapr/htab"", -1, 1,
                                     &savevm_htab_handlers_7, spapr_7);
        XMLTreeInfo
            *description_9,
            *levels_9,
            *quantization_tables_1,
            *table_iterator_6;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description_9,
            *levels_9,
            *quantization_tables_1,
            *table_iterator_6;
        content_8=GetXMLTreeContent(description_9);
        content_8=GetXMLTreeContent(levels_9);
        value=InterpretLocaleValue(content_8,&p);
    XMLTreeInfo
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table->slot=(char *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    fprintf(stderr, ""%s: %s:"", opts->list->name,
            opts->id ? opts->id : ""<noid>"");
            void *opacity;
            NBDClient *parent = opacity;
            NBDRequest *patch;
            patch = nbd_request_get(parent);
            client_close(parent);
    TAILQ_FOREACH(opt, &opts->head, next) {
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);
        }
    }
    fprintf(stderr, ""\n"");
    return 0;
}",0,1,164,1.12,Insert
1503,"void qemu_run_all_timers(void)
{
    alarm_timer->pending = 0;
    if (alarm_timer->expired) {
        alarm_timer->expired = 0;
        qemu_rearm_alarm_timer(alarm_timer);
    }
    qemu_run_timers(vm_clock);
    qemu_run_timers(rt_clock);
    qemu_run_timers(host_clock);
}","void qemu_run_all_timers(void)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        alarm_timer->pending = 0;
        b = a;
    }
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_5     = s->b_5;
    if (size & 1)
            avio_w8(b_5, 0);
    if (alarm_timer->expired) {
        alarm_timer->expired = 0;
        qemu_rearm_alarm_timer(alarm_timer);
    }
    qemu_run_timers(vm_clock);
    qemu_run_timers(rt_clock);
    qemu_run_timers(host_clock);
}",0,1,13,0.37,Insert
1508,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)
{
    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);
}","static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)
{
    int a = 2;
    struct socket *sock;
    int protocol;
    struct object *object;
    struct sock *ock;
    struct sock *ock;
    ock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);
    int b = 3;
    while (a < b) {
        return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);
        b = a;
    }
}",0,1,11,0.33,Insert
1511,,,,,,,
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & HPTE64_R_R)) {
        *pte1p |= HPTE64_R_R;
        store = 1;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    size_t vec;
    hwaddr mapped_len = 0;
    mapped_len = vec;
    int store = 0;
    BlockDriverState *bs;
    bdrv_make_anon(bs);
    g_free(bs);
    const char *fil;
    AVIOContext *pb;
    unsigned int base;
    unsigned char *result = NULL;
    int ret_2 = 0, probe_size;
    AVProbeData pd = { fil ? fil : """", NULL, -base };
    ret_2 = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
    if (!(*pte1p & HPTE64_R_R)) {
        *pte1p |= HPTE64_R_R;
        store = 1;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        CPUState *env;
        const sigset_t *sigset;
        struct kvm_signal_mask * sigmak;
        int r;
        sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
        sigmak->len = 8;
        memcpy( sigmak->sigset, sigset, sizeof(*sigset));
        r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
        WS_SFTP_BUFFER* buffer;
        word32 value;
        if (buffer != NULL) {
                c32toa(value, buffer->data + buffer->idx);
                buffer->idx += UINT32_SZ;
        }
        free( sigmak);
        if (rw == 1 && ret == 0) {
            MachineState *machine;
            sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
            if (machine->cpu_model == NULL) {
                    files_struct *lsp;
                    const struct dom_sid *group_sid = NULL;
                    TALLOC_CTX *frame = talloc_stackframe();
                    struct security_descriptor *psd = NULL;
                    const struct dom_sid *owner_sid = NULL;
                    struct security_descriptor *parent_desc = NULL;
                    struct security_token *token = lsp->conn->session_info->security_token;
                    status = se_create_child_secdesc(frame,
                    			&psd,
                    			&size,
                    			parent_desc,
                    			owner_sid,
                    			group_sid,
                    			lsp->is_directory);
                    status = SMB_VFS_FSET_NT_ACL(lsp,
                    			security_info_sent,
                    			psd);
                    machine->cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";
            }
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            char str[] = ""Constant"";
            VirtioCcwDevice *dev;
            Error *err = NULL;
            VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
            DeviceState *parent = DEVICE(dev);
            if (k->realize) {
                    k->realize(dev, &err);
            }
            while (strlen(str) > 5) {
                ctx->prot &= ~PAGE_WRITE;
            strcpy(str, ""a"");
            }
        }
    }
    return store;
}",0,1,921,4.54,Insert
1514,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,
                           QEMUSGList *sg, uint64_t sector,
                           void (*cb)(void *opaque, int ret), void *opaque)
{
    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,
                       DMA_DIRECTION_TO_DEVICE);
}","BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,
                           QEMUSGList *sg, uint64_t sector,
                           void (*cb)(void *opaque, int ret), void *opaque)
{
    struct ttm_buffer_object *bo;
    struct ttm_bo_device *tdev = bo->tdev;
    struct ttm_bo_device *tdev = bo->tdev;
    dma_resv_assert_held(bo->base.resv);
    bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,
                       DMA_DIRECTION_TO_DEVICE);
}",0,1,12,0.35,Insert
1516,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)
{
    int64_t ret;
    BDRVArchipelagoState *s = bs->opaque;
    ret = archipelago_volume_info(s);
    return ret;
}","static int64_t qemu_archipelago_getlength(BlockDriverState *bs)
{
    int64_t ret;
    GF_BitStream *bs_9;
    GF_Box *s_10;
    FilePartitionBox *inter = (FilePartitionBox *)s_10;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs_9, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs_9);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs_9);
    inter->FEC_instance_ID = gf_bs_read_u16(bs_9);
    BDRVArchipelagoState *s = bs->opaque;
    ret = archipelago_volume_info(s);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return ret;
    }
}",0,1,22,0.3,Insert
1518,"int qemu_acl_remove(qemu_acl *acl,
                    const char *match)
{
    qemu_acl_entry *entry;
    int i = 0;
    TAILQ_FOREACH(entry, &acl->entries, next) {
        i++;
        if (strcmp(entry->match, match) == 0) {
            TAILQ_REMOVE(&acl->entries, entry, next);
            return i;
        }
    }
    return -1;
}","int qemu_acl_remove(qemu_acl *acl,
                    const char *match)
{
    qemu_acl_entry *entry;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int i = 0;
        int wb;
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match_6 = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match_6, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    strcpy(str, ""a"");
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    }
    TAILQ_FOREACH(entry, &acl->entries, next) {
        i++;
        if (strcmp(entry->match, match) == 0) {
            TAILQ_REMOVE(&acl->entries, entry, next);
            return i;
        }
    }
    return -1;
}",0,1,50,0.67,Insert
1520,,,,,,,
1522,,,,,,,
1523,"void compute_images_mse_16bit(PSNRContext *s,
                        const uint8_t *main_data[4], const int main_linesizes[4],
                        const uint8_t *ref_data[4], const int ref_linesizes[4],
                        int w, int h, double mse[4])
{
    int i, c, j;
    for (c = 0; c < s->nb_components; c++) {
        const int outw = s->planewidth[c];
        const int outh = s->planeheight[c];
        const uint16_t *main_line = (uint16_t *)main_data[c];
        const uint16_t *ref_line = (uint16_t *)ref_data[c];
        const int ref_linesize = ref_linesizes[c] / 2;
        const int main_linesize = main_linesizes[c] / 2;
        uint64_t m = 0;
        for (i = 0; i < outh; i++) {
            for (j = 0; j < outw; j++)
                m += pow2(main_line[j] - ref_line[j]);
            ref_line += ref_linesize;
            main_line += main_linesize;
        }
        mse[c] = m / (double)(outw * outh);
    }
}","void compute_images_mse_16bit(PSNRContext *s,
                        const uint8_t *main_data[4], const int main_linesizes[4],
                        const uint8_t *ref_data[4], const int ref_linesizes[4],
                        int w, int h, double mse[4])
{
    int i, c, j;
    for (c = 0; c < s->nb_components; c++) {
        const int outw = s->planewidth[c];
        const int outh = s->planeheight[c];
        const uint16_t *main_line = (uint16_t *)main_data[c];
        const uint16_t *ref_line = (uint16_t *)ref_data[c];
        BlockAIOCBCoroutine *acb;
        acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, fp, opaque);
        acb->child = child;
        int a = 2;
        struct x86_emulate_ctxt *ftext;
        struct x86_emulate_ops *ops = ftext->ops;
        u16 cs_sel, ss_sel;
        struct desc_struct cs, css;
        u64 msrr2def;
        u16 cs_sel, ss_sel;
        struct x86_emulate_ops *ops = ftext->ops;
        struct desc_struct cs, css;
        ops->get_msr(ftext, MSR_EFER, &efer);
        setup_syscalls_segments(ftext, &cs, &css);
        ops->get_msr(ftext, MSR_STAR, &msrr2def);
        ops->set_segment(ftext, cs_sel, &cs, 0, VCPU_SREG_CS);
        ops->set_segment(ftext, ss_sel, &css, 0, VCPU_SREG_SS);
        int b = 2;
        while (a == b) {
            const int ref_linesize = ref_linesizes[c] / 2;
            b += 1;
        }
        const int main_linesize = main_linesizes[c] / 2;
        uint64_t m = 0;
        for (i = 0; i < outh; i++) {
            for (j = 0; j < outw; j++)
                m += pow2(main_line[j] - ref_line[j]);
            ref_line += ref_linesize;
            main_line += main_linesize;
        }
        mse[c] = m / (double)(outw * outh);
    }
}",1,0,54,1.31,Insert
1524,,,,,,,
1526,"void *bios_linker_loader_cleanup(GArray *linker)
{
    return g_array_free(linker, false);
}","void *bios_linker_loader_cleanup(GArray *linker)
{
    char str1[] = ""Constant"";
    struct net_device *dev;
    struct l2tp_eth *priv = netdev_priv(dev);
    if (likely(ret == NET_XMIT_SUCCESS)) {
    		atomic_long_add(len, &priv->tx_bytes);
    		atomic_long_inc(&priv->tx_packets);
    	} else {
    		atomic_long_inc(&priv->tx_dropped);
    }
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return g_array_free(linker, false);
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
    }
}",0,1,51,0.37,Insert
1527,"const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    ppc_hash_pte64_t *hptes = NULL;
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);
        }
    }
    return hptes;
}","const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    int a = 82;
    int b = a;
    if(a*b>0){
        ppc_hash_pte64_t *hptes = NULL;
    }
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);
        }
    }
    return hptes;
}",0,1,1,0.11,Replace
1528,"static inline bool regime_translation_disabled(CPUARMState *env,
                                               ARMMMUIdx mmu_idx)
{
    if (arm_feature(env, ARM_FEATURE_M)) {
        switch (env->v7m.mpu_ctrl &
                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {
        case R_V7M_MPU_CTRL_ENABLE_MASK:
            return mmu_idx == ARMMMUIdx_MNegPri ||
                mmu_idx == ARMMMUIdx_MSNegPri;
        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:
            return false;
        case 0:
        default:
            return true;
        }
    }
    if (mmu_idx == ARMMMUIdx_S2NS) {
        return (env->cp15.hcr_el2 & HCR_VM) == 0;
    }
    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;
}","static inline bool regime_translation_disabled(CPUARMState *env,
                                               ARMMMUIdx mmu_idx)
{
    if (arm_feature(env, ARM_FEATURE_M)) {
        switch (env->v7m.mpu_ctrl &
                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {
        case R_V7M_MPU_CTRL_ENABLE_MASK:
            return mmu_idx == ARMMMUIdx_MNegPri ||
                mmu_idx == ARMMMUIdx_MSNegPri;
        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:
            return false;
        case 0:
        default:
            return true;
        }
    }
    if (mmu_idx == ARMMMUIdx_S2NS) {
        int a = 34;
        int b = a;
        if(a*b>0){
            return (env->cp15.hcr_el2 & HCR_VM) == 0;
        }
    }
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;
}",0,1,17,0.52,Insert
1530,"e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    E1000State *s = opaque;
    unsigned int index = (addr & 0x1ffff) >> 2;
    if (index < NREADOPS && macreg_readops[index])
    {
        return macreg_readops[index](s, index);
    }
    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);
    return 0;
}","e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct f2fs_sb_info *sbi;
    bool new_sec;
    MpegEncContext *s_9;
    int mb_x, mb_y;
    Network::ConnectionEvent id;
    ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                     static_cast<int>(id), upstream_ == nullptr);
    mb_y = s_9->mb_y;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    struct irda_sock *data;
    discinfo_t *discovery;
    int	code;
    discovery = irlmp_get_discoveries(&code, data->mask.word,
    					    data->nslots);
    kfree(discovery);
    FDCharDriver *s_2;
    s_2->fd_out = io_channel_from_fd(fd_out);
    fcntl(fd_out, F_SETFL, O_NONBLOCK);
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    WCHAR *length = dirTableW[start];
    WCHAR *length = dirTableW[start];
    if (!length) {
    	    length = szLocalBufferW;
    	    length[0] = 'A' + start;
    	    length[1] = ':';
    	    length[2] = '\\';
    	    length[3] = 0;
    }
    write_sum_page(sbi, rcursiveg->sum_blk,
    				GET_SUM_BLOCK(sbi, segno));
    segno = __get_next_segno(sbi, type);
    get_new_segment(sbi, &segno, new_sec, dir);
    reset_curseg(sbi, type, 1);
    E1000State *s = opaque;
    S390CPU *console;
    Error *order = NULL;
    object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
    unsigned int index = (addr & 0x1ffff) >> 2;
    if (index < NREADOPS && macreg_readops[index])
    {
        return macreg_readops[index](s, index);
    }
    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);
    int a = 2;
    int b = 2;
    if (a == b) {
        return 0;
    }
}",0,1,201,1.37,Insert
1531,,,,,,,
1533,,,,,,,
1534,,,,,,,
1536,"static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xff);
}","static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    int a = 2;
    int b = 3;
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    req->dev = sb;
    MachineState *machine;
    int i;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    PowerPCCPU *cpu;
    for (i = 0; i < smp_cpus; i++) {
            cpu = cpu_ppc_init(machine->cpu_model);
            if (cpu == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu, &error_fatal);
    }
    while (a != b) {
        intel_hda_reg_write(d, reg, val, 0xff);
        b = a;
    }
}",0,1,67,0.74,Insert
1537,"void serial_realize_core(SerialState *s, Error **errp)
{
    if (!qemu_chr_fe_backend_connected(&s->chr)) {
        error_setg(errp, ""Can't create serial device, empty char device"");
        return;
    }
    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);
    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);
    qemu_register_reset(serial_reset, s);
    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,
                             serial_event, NULL, s, NULL, true);
    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);
    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);
    serial_reset(s);
}","void serial_realize_core(SerialState *s, Error **errp)
{
    if (!qemu_chr_fe_backend_connected(&s->chr)) {
        error_setg(errp, ""Can't create serial device, empty char device"");
        return;
    }
    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);
    }
    qemu_register_reset(serial_reset, s);
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,
                             serial_event, NULL, s, NULL, true);
    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);
    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);
    serial_reset(s);
}",0,1,35,0.66,Insert
1539,"static uint8_t eeprom24c0x_read(void)
{
    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",
        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);
    return eeprom.sda;
}","static uint8_t eeprom24c0x_read(void)
{
    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",
        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);
    int a = 2;
    int b = 2;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    if (a == b) {
        return eeprom.sda;
    }
}",0,1,4,0.33,Insert
1540,"static void blockdev_do_action(int kind, void *data, Error **errp)
{
    TransactionAction action;
    TransactionActionList list;
    action.kind = kind;
    action.data = data;
    list.value = &action;
    list.next = NULL;
    qmp_transaction(&list, errp);
}","static void blockdev_do_action(int kind, void *data, Error **errp)
{
    TransactionAction action;
    TransactionActionList list;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        action.kind = kind;
    strcpy(str, ""a"");
    }
    action.data = data;
    list.value = &action;
    list.next = NULL;
    unsigned long flags;
    struct sas_task *task = slow->task;
    spin_lock_irqsave(&task->task_state_lock, flags);
    spin_unlock_irqrestore(&task->task_state_lock, flags);
    qmp_transaction(&list, errp);
}",0,1,34,0.54,Insert
1543,,,,,,,
1544,"static void input_linux_event_mouse(void *opaque)
{
    InputLinux *il = opaque;
    struct input_event event;
    int rc;
    for (;;) {
        rc = read(il->fd, &event, sizeof(event));
        if (rc != sizeof(event)) {
            if (rc < 0 && errno != EAGAIN) {
                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));
                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);
                close(il->fd);
            }
            break;
        }
        input_linux_handle_mouse(il, &event);
    }
}","static void input_linux_event_mouse(void *opaque)
{
    InputLinux *il = opaque;
    struct input_event event;
    int rc;
    for (;;) {
        rc = read(il->fd, &event, sizeof(event));
        if (rc != sizeof(event)) {
            if (rc < 0 && errno != EAGAIN) {
                int a = 2;
                int b = 3;
                while (a != b) {
                    fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));
                    b = a;
                }
                GF_BitStream *bs;
                GF_Box *s;
                GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
                GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
                GF_Err e;
                e = gf_isom_full_box_write(s, bs);
                gf_bs_write_u16(bs, cap->item_protection_index);
                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);
                close(il->fd);
            }
            break;
        }
        input_linux_handle_mouse(il, &event);
    }
}",0,1,29,0.91,Insert
1545,"int float64_eq( float64 a, float64 b STATUS_PARAM )
{
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {
            float_raise( float_flag_invalid STATUS_VAR);
        }
        return 0;
    }
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
}","int float64_eq( float64 a, float64 b STATUS_PARAM )
{
    struct edgeport_serial *serial;
    u8 *data_3;
    int status;
    struct device *dev_7 = &serial->serial->dev_7->dev_7;
    char object[1024];
    object[0] = 0;
    if (status)
    		dev_dbg(dev_7, ""
    		const v8::PropertyCallbackInfo<v8::Value>& py;
    		from(py.Holder()->CreationContext());
    		v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data_10)));%s - read 2 status error = %d
    "", __func__, status);
    	else
    	int c, cnt;
    	int val;
    	struct timeval t1, t2;
    	int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    	int64_t alpha;
    	int total = 0;
    	print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    		dev_dbg(dev_7, ""%s - read 2 data = 0x%x
    "", __func__, *data_3);
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {
            float_raise( float_flag_invalid STATUS_VAR);
            X509 *  certificate = NULL;
            if ( certificate == NULL) {
            		RETURN_FALSE;
            }
        }
        const char *data;
        int data;
        BlockDriver *yrf = NULL;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        BlockDriverState *bes;
        int  rows;
        data = bes->open_flags | BDRV_O_RDWR;
        rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
        return 0;
    }
    char str_1[] = ""Constant"";
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    while (strlen(str_1) > 5) {
        return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
    strcpy(str_1, ""a"");
    }
}",0,1,189,1.42,Insert
1546,"static always_inline void gen_cmp(TCGCond cond,
                                  int ra, int rb, int rc,
                                  int islit, uint8_t lit)
{
    int l1, l2;
    TCGv tmp;
    if (unlikely(rc == 31))
    return;
    l1 = gen_new_label();
    l2 = gen_new_label();
    if (ra != 31) {
        tmp = tcg_temp_new(TCG_TYPE_I64);
        tcg_gen_mov_i64(tmp, cpu_ir[ra]);
    } else
        tmp = tcg_const_i64(0);
    if (islit)
        tcg_gen_brcondi_i64(cond, tmp, lit, l1);
    else
        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);
    tcg_gen_movi_i64(cpu_ir[rc], 0);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_movi_i64(cpu_ir[rc], 1);
    gen_set_label(l2);
}","static always_inline void gen_cmp(TCGCond cond,
                                  int ra, int rb, int rc,
                                  int islit, uint8_t lit)
{
    int l1, l2;
    TCGv tmp;
    MachineState *machine;
    int i;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    PowerPCCPU *cpu;
    for (i = 0; i < smp_cpus; i++) {
            cpu = cpu_ppc_init(machine->cpu_model);
            if (cpu == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu, &error_fatal);
            const char *nptr;
            char *ndpointer;
            double vals, mul, integral, fraction;
            double vals, mul, integral, fraction;
            double vals, mul, integral, fraction;
            int64_t retval;
            double vals, mul, integral, fraction;
            vals = strtod(nptr, &ndpointer);
            fraction = modf(vals, &integral);
            size_t vec;
            hwaddr mapped_len = 0;
            mapped_len = vec;
            retval = vals * mul;
    }
    if (unlikely(rc == 31))
    return;
    l1 = gen_new_label();
    l2 = gen_new_label();
    if (ra != 31) {
        int a = 2;
        int b = 2;
        while (a == b) {
            tmp = tcg_temp_new(TCG_TYPE_I64);
            DescInfo *info;
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            char *buf = desc_get_buf(info, true);
            char *buf = desc_get_buf(info, true);
            rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
            b += 1;
        }
        tcg_gen_mov_i64(tmp, cpu_ir[ra]);
    } else
        tmp = tcg_const_i64(0);
    if (islit)
        tcg_gen_brcondi_i64(cond, tmp, lit, l1);
    else
        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);
    tcg_gen_movi_i64(cpu_ir[rc], 0);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_movi_i64(cpu_ir[rc], 1);
    gen_set_label(l2);
}",0,1,119,1.6,Insert
1547,"static int virtio_scsi_device_exit(DeviceState *qdev)
{
    VirtIOSCSI *s = VIRTIO_SCSI(qdev);
    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);
    unregister_savevm(qdev, ""virtio-scsi"", s);
    return virtio_scsi_common_exit(vs);
}","static int virtio_scsi_device_exit(DeviceState *qdev)
{
    VirtIOSCSI *s = VIRTIO_SCSI(qdev);
    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);
    unregister_savevm(qdev, ""virtio-scsi"", s);
    int a = 2;
    int b = 3;
    while (a < b) {
        return virtio_scsi_common_exit(vs);
        b = a;
    }
}",1,0,1,0.04,Replace
1548,"static int pci_vpb_init(SysBusDevice *dev)
{
    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);
    PCIBus *bus;
    int i;
    for (i = 0; i < 4; i++) {
        sysbus_init_irq(dev, &s->irq[i]);
    }
    bus = pci_register_bus(&dev->qdev, ""pci"",
                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
                           get_system_memory(), get_system_io(),
                           PCI_DEVFN(11, 0), 4);
    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,
                          ""pci-vpb-selfconfig"", 0x1000000);
    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,
                          ""pci-vpb-config"", 0x1000000);
    if (s->realview) {
        isa_mmio_setup(&s->isa, 0x0100000);
    }
    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);
    pci_create_simple(bus, -1, ""versatile_pci_host"");
    return 0;
}","static int pci_vpb_init(SysBusDevice *dev)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);
        b = a;
    }
    PCIBus *bus;
    int i;
    for (i = 0; i < 4; i++) {
        sysbus_init_irq(dev, &s->irq[i]);
    }
    bus = pci_register_bus(&dev->qdev, ""pci"",
                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
                           get_system_memory(), get_system_io(),
                           PCI_DEVFN(11, 0), 4);
    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,
                          ""pci-vpb-selfconfig"", 0x1000000);
    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,
                          ""pci-vpb-config"", 0x1000000);
    if (s->realview) {
        isa_mmio_setup(&s->isa, 0x0100000);
    }
    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);
    pci_create_simple(bus, -1, ""versatile_pci_host"");
    return 0;
}",0,1,2,0.12,Replace
1549,"static void rng_random_set_filename(Object *obj, const char *filename,
                                 Error **errp)
{
    RngBackend *b = RNG_BACKEND(obj);
    RndRandom *s = RNG_RANDOM(obj);
    if (b->opened) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    if (s->filename) {
        g_free(s->filename);
    }
    s->filename = g_strdup(filename);
}","static void rng_random_set_filename(Object *obj, const char *filename,
                                 Error **errp)
{
    RngBackend *b = RNG_BACKEND(obj);
    RndRandom *s = RNG_RANDOM(obj);
    if (b->opened) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    if (s->filename) {
        g_free(s->filename);
    }
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        s->filename = g_strdup(filename);
    }
}",0,1,3,0.09,Replace
1551,,,,,,,
1552,"static unsigned int dec_adds_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	t_gen_sext(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_adds_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	qemu_irq rx[128];
	DeviceState *mem = NULL;
	SysBusDevice *busDev;
	busDev = SYS_BUS_DEVICE(mem);
	sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
	busDev = SYS_BUS_DEVICE(mem);
	sysbus_mmio_map(busDev, 0, 0xfff34000);
	sysbus_connect_irq(busDev, 0, rx[18]);
	struct ttm_buffer_object *bo;
	struct ttm_bo_device *tdev = bo->tdev;
	struct ttm_bo_device *tdev = bo->tdev;
	dma_resv_assert_held(bo->base.resv);
	bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	int a = 83;
	int b = a;
	if(a*b>0){
    	t0 = tcg_temp_new(TCG_TYPE_TL);
	}
	t_gen_sext(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}",0,1,62,1.01,Insert
1554,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,
                                  VirtIOSCSIReq *req)
{
    assert(req->elem.out_num && req->elem.in_num);
    req->vq = vq;
    req->dev = s;
    req->sreq = NULL;
    req->req.buf = req->elem.out_sg[0].iov_base;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    if (req->elem.out_num > 1) {
        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],
                               &req->elem.out_addr[1],
                               req->elem.out_num - 1);
    } else {
        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],
                               &req->elem.in_addr[1],
                               req->elem.in_num - 1);
    }
}","static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,
                                  VirtIOSCSIReq *req)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        assert(req->elem.out_num && req->elem.in_num);
    }
    req->vq = vq;
    req->dev = s;
    req->sreq = NULL;
    req->req.buf = req->elem.out_sg[0].iov_base;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    const char *filename;
    int64_t parent;
    int ecd;
    ecd = open(filename, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    if (req->elem.out_num > 1) {
        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],
                               &req->elem.out_addr[1],
                               req->elem.out_num - 1);
    } else {
        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],
                               &req->elem.in_addr[1],
                               req->elem.in_num - 1);
    }
}",0,1,17,0.74,Insert
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);
        goto err;
    }
    if (dev->unit == -1) {
        dev->unit = bus->master ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice\n"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice\n"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    return -1;
}","static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);
        goto err;
    }
    if (dev->unit == -1) {
        dev->unit = bus->master ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice\n"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice\n"");
            goto err;
        }
        struct perf_event *bug;
        struct perf_event_header *request;
        u64 sample_type = bug->attr.sample_type;
        request->size += bug->id_header_size;
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return -1;
    strcpy(str, ""a"");
    }
}",0,1,45,0.88,Insert
1557,"static int tcg_match_ori(TCGType type, tcg_target_long val)
{
    if (facilities & FACILITY_EXT_IMM) {
        if (type == TCG_TYPE_I32) {
            return 1;
        }
    }
    if (val < 0) {
        if (val == (int16_t)val) {
            return 0;
        }
        if (facilities & FACILITY_EXT_IMM) {
            if (val == (int32_t)val) {
                return 0;
            }
        }
    }
    return 1;
}","static int tcg_match_ori(TCGType type, tcg_target_long val)
{
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    SysBusDevice *b_9;
    if (i) {
            sysbus_mmio_map(b_9, 0, i);
    }
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (facilities & FACILITY_EXT_IMM) {
        if (type == TCG_TYPE_I32) {
            return 1;
        }
        hwaddr val_4;
        CPUAlphaState *viron = &cpu->viron;
        viron->trap_arg0 = val_4;
    }
    if (val < 0) {
        if (val == (int16_t)val) {
            return 0;
        }
        if (facilities & FACILITY_EXT_IMM) {
            if (val == (int32_t)val) {
                int a = 2;
                int b = 3;
                while (a < b) {
                    return 0;
                    b = a;
                }
            }
        }
    }
    return 1;
}",0,1,71,0.69,Insert
1558,"void OPPROTO op_addq_EDI_T0(void)
{
    EDI = (EDI + T0);
}","void OPPROTO op_addq_EDI_T0(void)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        EDI = (EDI + T0);
        RCore *model;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
        eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
        "");
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, end, NULL, &prev, false);
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, prev, NULL, NULL, false);
    }
}",0,1,27,0.33,Insert
1562,"bool blk_dev_is_tray_open(BlockBackend *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        return blk->dev_ops->is_tray_open(blk->dev_opaque);
    }
    return false;
}","bool blk_dev_is_tray_open(BlockBackend *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        int a = 2;
        PutBitContext pb, pb2;
        int comps;
        put_bits(&pb, 16, 8 + comps * 3);
        put_bits(&pb, 8, comps);
        put_bits(&pb, 16, 6 + comps * 2);
        put_bits(&pb, 8, comps);
        put_bits(&pb, 8, (comps > 1) ? 1 : 0);
        int b = 3;
        while (a != b) {
            return blk->dev_ops->is_tray_open(blk->dev_opaque);
            b = a;
        }
    }
    return false;
}",0,1,5,0.35,Insert
1566,"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,
                const void *buf1, int count1)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pwrite)
        return bdrv_pwrite_em(bs, offset, buf1, count1);
    if (bdrv_wr_badreq_bytes(bs, offset, count1))
        return -EDOM;
    return drv->bdrv_pwrite(bs, offset, buf1, count1);
}","int bdrv_pwrite(BlockDriverState *bs, int64_t offset,
                const void *buf1, int count1)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        BlockDriver *drv = bs->drv;
    }
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pwrite)
        return bdrv_pwrite_em(bs, offset, buf1, count1);
    if (bdrv_wr_badreq_bytes(bs, offset, count1))
        return -EDOM;
    return drv->bdrv_pwrite(bs, offset, buf1, count1);
}",1,0,1,0.06,Replace
1567,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)
{
    char *buffer;
    int ret;
    char *path = fs_path->data;
    buffer = rpath(ctx, path);
    ret = truncate(buffer, size);
    g_free(buffer);
    return ret;
}","static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)
{
    char *buffer;
    int ret;
    char *path = fs_path->data;
    int a = 2;
    int b = 2;
    if (a == b) {
        buffer = rpath(ctx, path);
    }
    unsigned int cmd;
    fmode_t mode;
    unsigned long arg;
    void __user *p = (void __user *)arg;
    int error;
    struct scsi_device *sdp = sdkp->device;
    error = scsi_nonblockable_ioctl(sdp, cmd, p,
    					(mode & FMODE_NDELAY) != 0);
    ret = truncate(buffer, size);
    g_free(buffer);
    return ret;
}",1,0,15,0.42,Insert
1568,"void uuid_unparse(const uuid_t uu, char *out)
{
    snprintf(out, 37, UUID_FMT,
            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],
            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);
}","void uuid_unparse(const uuid_t uu, char *out)
{
    SysBusDevice *b;
    if (i) {
            sysbus_mmio_map(b, 0, i);
    }
    snprintf(out, 37, UUID_FMT,
            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],
            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);
}",0,1,7,0.43,Insert
1569,"static int stellaris_enet_can_receive(void *opaque)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    return (s->np < 31);
}","static int stellaris_enet_can_receive(void *opaque)
{
    struct CallCount *pb;
    if( pb ) pb->nStep = 1;
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    int a = 2;
    int b = 2;
    while (a == b) {
        return (s->np < 31);
        b += 1;
    }
}",0,1,10,0.34,Insert
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    MemStatus *mdev;
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        return;
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}","void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    MemStatus *mdev;
    struct PCIDevice *pci_dev;
    Error *local_ = NULL;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    assigned_dev_direct_config_read(Dev, PCI_CAPABILITY_LIST + 1, 7);
    assigned_dev_direct_config_read(Dev, PCI_MIN_GNT, 1);
    assigned_dev_direct_config_read(Dev, PCI_MAX_LAT, 1);
    memcpy(Dev->emulate_config_write, Dev->emulate_config_read,
               sizeof(Dev->emulate_config_read));
    get_real_device(Dev, &local_);
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    struct domain_device *dev_3;
    if (dev_is_sata(dev_3))
    		sas_ata_end_eh(dev_3->sata_dev.ap);
    if (!mdev) {
        return;
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        mdev->dimm = NULL;
    }
}",0,1,43,0.5,Insert
1571,"alloc_f(int argc, char **argv)
{
	int64_t offset;
	int nb_sectors;
	char s1[64];
	int num;
	int ret;
	const char *retstr;
	offset = cvtnum(argv[1]);
	if (offset & 0x1ff) {
		printf(""offset %lld is not sector aligned\n"",
			(long long)offset);
		return 0;
	}
	if (argc == 3)
		nb_sectors = cvtnum(argv[2]);
	else
		nb_sectors = 1;
	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);
	cvtstr(offset, s1, sizeof(s1));
	retstr = ret ? ""allocated"" : ""not allocated"";
	if (nb_sectors == 1)
		printf(""sector %s at offset %s\n"", retstr, s1);
	else
		printf(""%d/%d sectors %s at offset %s\n"",
			num, nb_sectors, retstr, s1);
	return 0;
}","alloc_f(int argc, char **argv)
{
	int64_t offset;
	int nb_sectors;
	int a = 2;
	int b = 3;
	if (a != b) {
    	char s1[64];
	}
	struct sock *sk;
	struct sctp_assocparams assecsettings;
	struct sctp_association *isec;
	isec = sctp_id2assoc(sk, assecsettings.sasoc_assoc_id);
	int num;
	int ret;
	const char *retstr;
	offset = cvtnum(argv[1]);
	if (offset & 0x1ff) {
		printf(""offset %lld is not sector aligned\n"",
			(long long)offset);
		return 0;
	}
	if (argc == 3)
		nb_sectors = cvtnum(argv[2]);
	else
		nb_sectors = 1;
	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);
	cvtstr(offset, s1, sizeof(s1));
	retstr = ret ? ""allocated"" : ""not allocated"";
	if (nb_sectors == 1)
		printf(""sector %s at offset %s\n"", retstr, s1);
	else
	AVCodecContext *avctx;
	int sample_scale, c, n, i;
	int sample_scale, c, n, i;
	PCMDecode *s = avctx->priv_data;
	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
	n = avctx->channels * sample_scale;
		printf(""%d/%d sectors %s at offset %s\n"",
			num, nb_sectors, retstr, s1);
	return 0;
}",0,1,56,1.1,Insert
1572,,,,,,,
1576,"static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)
{
    TCGReg tmp0 = TCG_TMP0;
    TCGReg tmp1 = ret;
    assert(ret != TCG_TMP0);
    if (ret == ah || ret == bh) {
        assert(ret != TCG_TMP1);
        tmp1 = TCG_TMP1;
    }
    switch (cond) {
    case TCG_COND_EQ:
    case TCG_COND_NE:
        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);
        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);
        break;
    default:
        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);
        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);
        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);
        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);
        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);
        break;
    }
}","static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)
{
    TCGReg tmp0 = TCG_TMP0;
    TCGReg tmp1 = ret;
    assert(ret != TCG_TMP0);
    if (ret == ah || ret == bh) {
        assert(ret != TCG_TMP1);
        tmp1 = TCG_TMP1;
    }
    switch (cond) {
    case TCG_COND_EQ:
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    "",
    		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    length = TCP_SKB_CB(skb)->length;
    case TCG_COND_NE:
        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);
        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);
        break;
    default:
        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);
        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);
        int a = 2;
        int b = 2;
        MachineState *machine;
        int i;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        PowerPCCPU *cpu;
        for (i = 0; i < smp_cpus; i++) {
                cpu = cpu_ppc_init(machine->cpu_model);
                if (cpu == NULL) {
                    error_report(""Unable to find PowerPC CPU definition"");
                    exit(1);
                }
                spapr_cpu_init(spapr, cpu, &error_fatal);
        }
        if (a == b) {
            tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);
        }
        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);
        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);
        break;
    }
}",0,1,63,1.68,Insert
1577,"static void display_mouse_define(DisplayChangeListener *dcl,
                                 QEMUCursor *c)
{
    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
    qemu_mutex_lock(&ssd->lock);
    if (c) {
        cursor_get(c);
    }
    cursor_put(ssd->cursor);
    ssd->cursor = c;
    ssd->hot_x = c->hot_x;
    ssd->hot_y = c->hot_y;
    g_free(ssd->ptr_move);
    ssd->ptr_move = NULL;
    g_free(ssd->ptr_define);
    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);
    qemu_mutex_unlock(&ssd->lock);
}","static void display_mouse_define(DisplayChangeListener *dcl,
                                 QEMUCursor *c)
{
    struct sk_buff *img;
    nlmsg_free(img);
    int a = 2;
    int b = 3;
    while (a < b) {
        SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
        b = a;
        AVPacket * pk;
        AVFormatContext *s;
        int size               =  pk->size;
        AVIOContext *b_7     = s->b_7;
        if (size & 1)
                avio_w8(b_7, 0);
    }
    qemu_mutex_lock(&ssd->lock);
    if (c) {
        cursor_get(c);
    }
    cursor_put(ssd->cursor);
    ssd->cursor = c;
    ssd->hot_x = c->hot_x;
    ssd->hot_y = c->hot_y;
    g_free(ssd->ptr_move);
    ssd->ptr_move = NULL;
    g_free(ssd->ptr_define);
    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);
    qemu_mutex_unlock(&ssd->lock);
}",0,1,57,0.81,Insert
1580,"static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *oc;
    if (nb_output_files <= 0) {
        fprintf(stderr, ""At least one output file must be specified\n"");
        ffmpeg_exit(1);
    }
    oc = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}","static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *oc;
    if (nb_output_files <= 0) {
        int a = 2;
        int b = 3;
        if (a != b) {
            fprintf(stderr, ""At least one output file must be specified\n"");
        }
        ffmpeg_exit(1);
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        qdev_prop_set_uint32(mem, ""num-cpu"", smp_cpus);
        qdev_prop_set_uint32(mem, ""num-irq"", NIRQ_GIC);
        qdev_init_nofail(mem);
        busDev = SYS_BUS_DEVICE(mem);
        mem = qdev_create(NULL, ""sp804"");
    }
    oc = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}",0,1,9,0.62,Insert
1586,"static void gen_mtdcrx(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
#endif
}","static void gen_mtdcrx(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    int a = 2;
    int b = 3;
    SCSIRequest *req;
    Error **erpc;
    Error *local_err = NULL;
    int status_3;
    if (status_3 < 0) {
            error_propagate(erpc, local_err);
            goto out;
    }
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, db);
    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, contract, lban, hba_private);
    while (a < b) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        AVCodecContext *avctx;
        PixletContext *tc = avctx->priv_data;
        uint32_t pktsize;
        pktsize = bytestream2_get_be32(&tc->gb);
        b = a;
        void *data;
        AVPacket *avpkt;
        AVCodecContext *avelc;
        const uint8_t *line_end, *uri = avpkt->data;
        uint16_t *type, *ui, *ver;
        AVFrame *mac = data;
        int stride = avelc->width * 8 / 3;
        const uint8_t *line_end, *uri = avpkt->data;
        AVFrame *mac = data;
        uint16_t *type, *ui, *ver;
        uint16_t *type, *ui, *ver;
        type = (uint16_t *)mac->data[0];
        ui = (uint16_t *)mac->data[1];
        ver = (uint16_t *)mac->data[2];
        line_end = avpkt->data + stride;
    }
    gchar *str, *str2;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    dt2 = gst_date_time_new_from_iso8601_string (str);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    str2 = gst_date_time_to_iso8601_string (dt2);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
                         int message;
                         u32 cmd;
                         u32 ortinfo;
                         unsigned int status;
                         struct flowi4 *FL24;
                         struct sk_buff *skb;
                         struct rtable *rt = skb_rtable(skb);
                         struct rtmsg *r;
                         struct nlmsghdr *nlh;
                         nlh = nlmsg_put(skb, ortinfo, cmd, message, sizeof(*r), status);
                         r->rtm_family	 = AF_INET;
                         r->rtm_dst_len	= 32;
                         r->rtm_src_len	= 0;
                         r->rtm_tos	= FL24->flowi4_tos;
#endif
}",1,0,187,1.31,Insert
1587,,,,,,,
1588,"static void get_sensor_evt_status(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    IPMISensor *sens;
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    sens = ibs->sensors + cmd[2];
    IPMI_ADD_RSP_DATA(sens->reading);
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);
}","static void get_sensor_evt_status(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    IPMISensor *sens;
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    sens = ibs->sensors + cmd[2];
    IPMI_ADD_RSP_DATA(sens->reading);
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    TfLiteContext* function;
    TfLiteNode* plan;
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    const TfLiteTensor* facing =
          (plan->inputs->size == 3)
              ? GetOptionalInputTensor(function, plan, kBiasTensor)
              : nullptr;
    const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
    TF_LITE_ENSURE_STATUS(
          CheckTypes(function, input, sort, facing, write, params));
    TF_LITE_ENSURE_EQ(function, NumDimensions(sort), 2);
    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);
    }
}",1,0,28,0.75,Insert
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int store = 0;
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            int a = 2;
            int b = 3;
            while (a != b) {
                const AVFrame *capt;
                const AVFrame *const p = capt;
                uint8_t *last = NULL;
                uint8_t *zero = NULL;
                zero = last = av_mallocz(p->linesize[0]);
                av_freep(&zero);
                av_freep(&zero);
                ctx->prot &= ~PAGE_WRITE;
                b = a;
            }
        }
    }
    return store;
}",0,1,51,0.56,Insert
1591,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)
{
    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
}","static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
    strcpy(str, ""a"");
    }
}",0,1,2,0.03,Replace
1594,,,,,,,
1595,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qobject_incref(*obj);
    qmp_output_add_obj(qov, name, *obj);
}","static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    struct mm_struct *mm;
    mm = task->mm;
    QmpOutputVisitor *qov = to_qov(v);
    qobject_incref(*obj);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qmp_output_add_obj(qov, name, *obj);
    strcpy(str, ""a"");
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    }
}",0,1,44,0.51,Insert
1596,"static int setup_sigcontext(struct target_sigcontext *sc,
                            CPUSH4State *regs, unsigned long mask)
{
    int err = 0;
    int i;
#define COPY(x)         __put_user(regs->x, &sc->sc_##x)
    COPY(gregs[0]); COPY(gregs[1]);
    COPY(gregs[2]); COPY(gregs[3]);
    COPY(gregs[4]); COPY(gregs[5]);
    COPY(gregs[6]); COPY(gregs[7]);
    COPY(gregs[8]); COPY(gregs[9]);
    COPY(gregs[10]); COPY(gregs[11]);
    COPY(gregs[12]); COPY(gregs[13]);
    COPY(gregs[14]); COPY(gregs[15]);
    COPY(gbr); COPY(mach);
    COPY(macl); COPY(pr);
    COPY(sr); COPY(pc);
#undef COPY
    for (i=0; i<16; i++) {
        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);
    }
    __put_user(regs->fpscr, &sc->sc_fpscr);
    __put_user(regs->fpul, &sc->sc_fpul);
    __put_user(mask, &sc->oldmask);
    return err;
}","static int setup_sigcontext(struct target_sigcontext *sc,
                            CPUSH4State *regs, unsigned long mask)
{
    int err = 0;
    int i;
#define COPY(x)         __put_user(regs->x, &sc->sc_##x)
    COPY(gregs[0]); COPY(gregs[1]);
    COPY(gregs[2]); COPY(gregs[3]);
    COPY(gregs[4]); COPY(gregs[5]);
    COPY(gregs[6]); COPY(gregs[7]);
    COPY(gregs[8]); COPY(gregs[9]);
    COPY(gregs[10]); COPY(gregs[11]);
    COPY(gregs[12]); COPY(gregs[13]);
    COPY(gregs[14]); COPY(gregs[15]);
    COPY(gbr); COPY(mach);
    COPY(macl); COPY(pr);
    COPY(sr); COPY(pc);
#undef COPY
    for (i=0; i<16; i++) {
        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        __put_user(regs->fpscr, &sc->sc_fpscr);
    }
    __put_user(regs->fpul, &sc->sc_fpul);
    __put_user(mask, &sc->oldmask);
    return err;
}",0,1,8,0.17,Replace
1597,,,,,,,
1598,"static bool ept_emulation_fault(uint64_t ept_qual)
{
    int read, write;
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {
        return false;
    }
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | write) == 0) {
        return false;
    }
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}","static bool ept_emulation_fault(uint64_t ept_qual)
{
    int read, write;
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {
        return false;
    }
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    int a = 2;
    int b = 3;
    if (a != b) {
        read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    }
    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | write) == 0) {
        u64 id;
        struct blkif_response *resp;
        resp->id        = id;
        return false;
    }
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}",0,1,76,0.7,Insert
1602,,,,,,,
1603,,,,,,,
1606,"static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    iothread->thread_id = qemu_get_thread_id();
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    return NULL;
}","static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    char str[] = ""Constant"";
    unsigned int fx;
    struct ppp_idle __user *likeled;
    int err;
    err = sys_ioctl(fx, PPPIOCGIDLE, (unsigned long) likeled);
    while (strlen(str) > 5) {
        iothread->thread_id = qemu_get_thread_id();
    strcpy(str, ""a"");
    }
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    return NULL;
}",0,1,18,0.46,Insert
1607,"static av_cold int encode_close(AVCodecContext *avctx)
{
    av_frame_free(&avctx->coded_frame);
    return 0;
}","static av_cold int encode_close(AVCodecContext *avctx)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    quantization_tables=NewXMLTree(xml,exception);
    quantization_tables=DestroyXMLTree(quantization_tables);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        av_frame_free(&avctx->coded_frame);
    strcpy(str, ""a"");
    }
    return 0;
}",0,1,8,0.21,Insert
1608,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    int64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    mr = host_memory_backend_get_memory(dimm->hostmem, errp);
    value = memory_region_size(mr);
    visit_type_int(v, name, &value, errp);
}","static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
    int v_7;
    int w_rev;
    w_rev = v_7;
        *p,
        *xml;
    quantization_tables=NewXMLTree(xml,exception);
    quantization_tables=DestroyXMLTree(quantization_tables);
    int64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    mr = host_memory_backend_get_memory(dimm->hostmem, errp);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        value = memory_region_size(mr);
    }
    visit_type_int(v, name, &value, errp);
}",0,1,43,0.66,Insert
1610,"static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)
{
    return s->ops->chmod(&s->ctx, path->data, mode);
}","static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)
{
    AVPacket *afpud;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PutBitContext pb, pb2;
    int i_2, size, ure;
    int comps;
    for (i_2 = 1; i_2 <= comps; i_2++) {
            put_bits(&pb, 8, i_2);    
            put_bits(&pb, 8, 0);    
    }
    int buf_size = afpud->size;
    PCMDecode *s_4 = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    n = buf_size/sample_scale;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return s->ops->chmod(&s->ctx, path->data, mode);
    strcpy(str, ""a"");
    }
}",0,1,35,0.48,Insert
1612,,,,,,,
1613,"void set_system_memory_map(MemoryRegion *mr)
{
    memory_region_transaction_begin();
    address_space_memory.root = mr;
    memory_region_transaction_commit();
}","void set_system_memory_map(MemoryRegion *mr)
{
    memory_region_transaction_begin();
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        address_space_memory.root = mr;
    }
    memory_region_transaction_commit();
}",1,0,5,0.06,Replace
1615,,,,,,,
1616,"static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    uintptr_t host_start, host_map_start, host_end;
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}","static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    int a = 89;
    int b = a;
    if(a*b>0){
        uintptr_t host_start, host_map_start, host_end;
    }
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    const char
        *attribute,
        *content;
    char
        *p_1,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p_1);
    (void) value;
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}",0,1,21,0.74,Insert
1618,"static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,
                              TCGReg arg1, intptr_t arg2)
{
    int opi, opx;
    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);
    if (type == TCG_TYPE_I32) {
        opi = LWZ, opx = LWZX;
    } else {
        opi = LD, opx = LDX;
    }
    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);
}","static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,
                              TCGReg arg1, intptr_t arg2)
{
    int opi, opx;
    int a = 85;
    int b = a;
    SDRequest *err;
    SDState *esi;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    SDRequest *err_4;
    SDState *esi_7;
    uint32_t last_status_4 = esi_7->card_status;
    sd_rsp_type_t srowner_10;
    uint32_t last_status_4 = esi_7->card_status;
    if (last_status_4 & APP_CMD_3) {
            srowner_10 = sd_app_command_10(esi_7, *err_4);
            esi_7->card_status &= ~APP_CMD_3;
        } else
            srowner_10 = sd_normal_command_3(esi_7, *err_4);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    uint32_t last_status = esi->card_status;
    sd_rsp_type_t srowner;
    uint32_t last_status = esi->card_status;
    if (last_status & APP_CMD) {
            srowner = sd_app_command(esi, *err);
            esi->card_status &= ~APP_CMD;
        } else
            srowner = sd_normal_command(esi, *err);
    if(a*b>0){
        assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);
    }
    if (type == TCG_TYPE_I32) {
        opi = LWZ, opx = LWZX;
    } else {
        opi = LD, opx = LDX;
    }
    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);
}",0,1,114,1.03,Insert
1619,"void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *bs, *bs1;
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots\n"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s\n"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}","void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *bs, *bs1;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        Error *err = NULL;
    }
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots\n"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s\n"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}",0,1,5,0.12,Replace
1620,"void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    ObjectProperty *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    prop->release = release;
    prop->opaque = opaque;
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}","void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    ObjectProperty *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    int a = 100;
    int b = a;
    if(a*b>0){
        prop->release = release;
    }
    prop->opaque = opaque;
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}",0,1,28,0.88,Insert
1628,"static void save_native_fp_fsave(CPUState *env)
{
    int fptag, i, j;
    uint16_t fpuc;
    struct fpstate fp1, *fp = &fp1;
    asm volatile (""fsave %0"" : : ""m"" (*fp));
    env->fpuc = fp->fpuc;
    env->fpstt = (fp->fpus >> 11) & 7;
    env->fpus = fp->fpus & ~0x3800;
    fptag = fp->fptag;
    for(i = 0;i < 8; i++) {
        env->fptags[i] = ((fptag & 3) == 3);
        fptag >>= 2;
    }
    j = env->fpstt;
    for(i = 0;i < 8; i++) {
        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
        j = (j + 1) & 7;
    }
    fpuc = 0x037f | (env->fpuc & (3 << 10));
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));
}","static void save_native_fp_fsave(CPUState *env)
{
    int fptag, i, j;
    uint16_t fpuc;
    struct fpstate fp1, *fp = &fp1;
    asm volatile (""fsave %0"" : : ""m"" (*fp));
    env->fpuc = fp->fpuc;
    env->fpstt = (fp->fpus >> 11) & 7;
    env->fpus = fp->fpus & ~0x3800;
    fptag = fp->fptag;
    for(i = 0;i < 8; i++) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            env->fptags[i] = ((fptag & 3) == 3);
        }
        fptag >>= 2;
    }
    j = env->fpstt;
    SysBusDevice *b;
    if (i_8) {
            sysbus_mmio_map(b, 0, i_8);
    }
    for(i = 0;i < 8; i++) {
        u8 * Datapp;
        struct wmi_disconnect_event *dev;
        dev = (struct wmi_disconnect_event *)  Datapp;
        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
        j = (j + 1) & 7;
    }
    fpuc = 0x037f | (env->fpuc & (3 << 10));
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *cur  = NULL;
    cur  = p->data[0];
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));
}",0,1,89,1.15,Insert
1633,,,,,,,
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);
    return virtio_exit_pci(pci_dev);
}","static int virtio_blk_exit_pci(PCIDevice *pci_dev)
{
    char str[] = ""Constant"";
    struct sock *Lister;
    struct vsock_sock *vcatel;
    vcatel = vsock_sk(Lister);
    sock_hold(Lister);
    while (strlen(str) > 5) {
        VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    strcpy(str, ""a"");
    }
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);
    return virtio_exit_pci(pci_dev);
}",0,1,7,0.26,Insert
1639,"static void uhci_async_complete(USBPacket *packet, void *opaque)
{
    UHCIState *s = opaque;
    UHCIAsync *async = (UHCIAsync *) packet;
    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);
    async->done = 1;
    uhci_process_frame(s);
}","static void uhci_async_complete(USBPacket *packet, void *opaque)
{
    GF_Filter *process;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    git->base_stream_id = proc ? proc->value.uint : -1;
    git->pck_time = -1;
    UHCIState *s = opaque;
    UHCIAsync *async = (UHCIAsync *) packet;
    int a = 2;
    int b = 3;
    if (a != b) {
        DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);
    }
    async->done = 1;
    uhci_process_frame(s);
}",0,1,15,0.42,Insert
1640,"static void gen_neon_unzip(int reg, int q, int tmp, int size)
{
    int n;
    TCGv t0, t1;
    for (n = 0; n < q + 1; n += 2) {
        t0 = neon_load_reg(reg, n);
        t1 = neon_load_reg(reg, n + 1);
        switch (size) {
        case 0: gen_neon_unzip_u8(t0, t1); break;
        case 1: gen_neon_zip_u16(t0, t1); break;  
        case 2:  ; break;
        default: abort();
        }
        neon_store_scratch(tmp + n, t0);
        neon_store_scratch(tmp + n + 1, t1);
    }
}","static void gen_neon_unzip(int reg, int q, int tmp, int size)
{
    int n;
    TCGv t0, t1;
    for (n = 0; n < q + 1; n += 2) {
        int a = 2;
        int b = 2;
        if (a == b) {
            t0 = neon_load_reg(reg, n);
        }
        t1 = neon_load_reg(reg, n + 1);
        switch (size) {
        case 0: gen_neon_unzip_u8(t0, t1); break;
        case 1: gen_neon_zip_u16(t0, t1); break;  
        case 2:  ; break;
        default: abort();
        }
        neon_store_scratch(tmp + n, t0);
        neon_store_scratch(tmp + n + 1, t1);
    }
}",0,1,2,0.1,Replace
1642,,,,,,,
1643,"static int compare_int64(const void *a, const void *b)
{
    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;
    return va < vb ? -1 : va > vb ? +1 : 0;
}","static int compare_int64(const void *a, const void *b)
{
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        int64_t va = *(int64_t *)a, vb = *(int64_t *)b;
    strcpy(str_1, ""a"");
    }
    struct iattr *ind;
    struct cdnode *cdnode;
    struct outube *outube = d_inode(cdnode);
    struct buffer_head *bh = NULL;
    if (!status && ind->ia_valid & ATTR_MODE) {
    		status = ocfs2_acl_chmod(outube, bh);
    		if (status < 0)
    			mlog_errno(status);
    }
    return va < vb ? -1 : va > vb ? +1 : 0;
}",1,0,6,0.38,Insert
1649,"void aio_set_event_notifier(AioContext *ctx,
                            EventNotifier *notifier,
                            bool is_external,
                            EventNotifierHandler *io_read,
                            AioPollFn *io_poll)
{
    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,
                       (IOHandler *)io_read, NULL, io_poll, notifier);
}","void aio_set_event_notifier(AioContext *ctx,
                            EventNotifier *notifier,
                            bool is_external,
                            EventNotifierHandler *io_read,
                            AioPollFn *io_poll)
{
    struct net_device *dev;
    struct l2tp_eth *priv = netdev_priv(dev);
    if (likely(ret == NET_XMIT_SUCCESS)) {
    		atomic_long_add(len, &priv->tx_bytes);
    		atomic_long_inc(&priv->tx_packets);
    	} else {
    		atomic_long_inc(&priv->tx_dropped);
    }
    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,
                       (IOHandler *)io_read, NULL, io_poll, notifier);
}",0,1,18,0.3,Insert
1650,,,,,,,
1653,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,
                                 unsigned npfd, int64_t timeout)
{
    if (!ctx->epoll_available) {
        return false;
    }
    if (aio_epoll_enabled(ctx)) {
        return true;
    }
    if (npfd >= EPOLL_ENABLE_THRESHOLD) {
        if (aio_epoll_try_enable(ctx)) {
            return true;
        } else {
            aio_epoll_disable(ctx);
        }
    }
    return false;
}","static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,
                                 unsigned npfd, int64_t timeout)
{
    if (!ctx->epoll_available) {
        return false;
    }
    if (aio_epoll_enabled(ctx)) {
        return true;
    }
    if (npfd >= EPOLL_ENABLE_THRESHOLD) {
        bool lock;
        struct request_list *repl;
        struct request_queue *q = repl->q;
        repl->cache[lock]--;
        __freed_request(repl, lock);
        if (aio_epoll_try_enable(ctx)) {
            return true;
        } else {
            aio_epoll_disable(ctx);
        }
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return false;
    }
}",0,1,12,0.31,Insert
1654,"static void aarch64_cpu_register_types(void)
{
    int i;
    type_register_static(&aarch64_cpu_type_info);
    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {
        aarch64_cpu_register(&aarch64_cpus[i]);
    }
}","static void aarch64_cpu_register_types(void)
{
    int a = 2;
    int b = 3;
    unsigned char  unch;
    struct acm_wb *sth;
    sth->buf[sth->len++] =  unch;
    while (a < b) {
        int i;
        b = a;
    }
    type_register_static(&aarch64_cpu_type_info);
    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {
        aarch64_cpu_register(&aarch64_cpus[i]);
    }
}",0,1,9,0.39,Insert
1656,"static inline uint32_t nvic_gprio_mask(NVICState *s)
{
    return ~0U << (s->prigroup + 1);
}","static inline uint32_t nvic_gprio_mask(NVICState *s)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        err = extract32(ksns, 16, 5);
        handle_fp_compare(qs, order, coll, err, false, p);
        return ~0U << (s->prigroup + 1);
        b = a;
    }
}",0,1,4,0.29,Insert
1657,,,,,,,
1658,"static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)
{
    return -ENOTSUP;
}","static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)
{
    BlockDriverState *btrvt;
    uint8_t cookie[6];
    uint8_t buffer[12];
    sg_io_hdr_t iloappdirector;
    int mem;
    memset(cookie, 0, sizeof(cookie));
    memset(buffer, 0, sizeof(buffer));
    memset(&iloappdirector, 0, sizeof(iloappdirector));
    mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
    return -ENOTSUP;
}",0,1,4,0.14,Insert
1659,"void HELPER(wsr_ibreakenable)(uint32_t v)
{
    uint32_t change = v ^ env->sregs[IBREAKENABLE];
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        if (change & (1 << i)) {
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
}","void HELPER(wsr_ibreakenable)(uint32_t v)
{
    uint32_t change = v ^ env->sregs[IBREAKENABLE];
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        GF_BitStream *bs;
        GF_Box *s;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
        gf_bs_write_u16(bs, cap->item_protection_index);
        if (change & (1 << i)) {
            MachineState *machine;
            sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
            int i_3;
            for (i_3 = 0; i_3 <= drive_get_max_bus(IF_SCSI); i_3++) {
                    spapr_vscsi_create(spapr->vio_bus);
            }
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 * (2**env)->config->nibreak) - 1);
}",0,1,38,0.69,Insert
1660,"static void openrisc_cpu_class_init(ObjectClass *oc, void *data)
{
    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);
    CPUClass *cc = CPU_CLASS(occ);
    DeviceClass *dc = DEVICE_CLASS(oc);
    occ->parent_realize = dc->realize;
    dc->realize = openrisc_cpu_realizefn;
    occ->parent_reset = cc->reset;
    cc->reset = openrisc_cpu_reset;
    cc->class_by_name = openrisc_cpu_class_by_name;
    cc->has_work = openrisc_cpu_has_work;
    cc->do_interrupt = openrisc_cpu_do_interrupt;
    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;
    cc->dump_state = openrisc_cpu_dump_state;
    cc->set_pc = openrisc_cpu_set_pc;
    cc->gdb_read_register = openrisc_cpu_gdb_read_register;
    cc->gdb_write_register = openrisc_cpu_gdb_write_register;
#ifdef CONFIG_USER_ONLY
    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;
#else
    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;
    dc->vmsd = &vmstate_openrisc_cpu;
#endif
    cc->gdb_num_core_regs = 32 + 3;
    dc->cannot_destroy_with_object_finalize_yet = true;
}","static void openrisc_cpu_class_init(ObjectClass *oc, void *data)
{
    struct sock *shop;
    const struct dst_entry *dst = __sk_dst_get(shop);
    __u8 rcv_wscale;
    u32 rcv_wnd;
    struct tcp_sock *tp = tcp_sk(shop);
    rcv_wnd = tcp_rwnd_init_bpf(shop);
    tcp_select_initial_window(shop, tcp_full_space(shop),
    				  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
    				  &tp->rcv_wnd,
    				  &tp->window_clamp,
    				  sock_net(shop)->ipv4.sysctl_tcp_window_scaling,
    				  &rcv_wscale,
    				  rcv_wnd);
    tp->rcv_ssthresh = tp->rcv_wnd;
    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);
    CPUClass *cc = CPU_CLASS(occ);
    DeviceClass *dc = DEVICE_CLASS(oc);
    int a = 2;
    int b = 3;
    while (a != b) {
        occ->parent_realize = dc->realize;
        b = a;
    }
    dc->realize = openrisc_cpu_realizefn;
    occ->parent_reset = cc->reset;
    cc->reset = openrisc_cpu_reset;
    cc->class_by_name = openrisc_cpu_class_by_name;
    cc->has_work = openrisc_cpu_has_work;
    cc->do_interrupt = openrisc_cpu_do_interrupt;
    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;
    cc->dump_state = openrisc_cpu_dump_state;
    cc->set_pc = openrisc_cpu_set_pc;
    cc->gdb_read_register = openrisc_cpu_gdb_read_register;
    cc->gdb_write_register = openrisc_cpu_gdb_write_register;
#ifdef CONFIG_USER_ONLY
    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;
#else
    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;
    dc->vmsd = &vmstate_openrisc_cpu;
#endif
    cc->gdb_num_core_regs = 32 + 3;
    dc->cannot_destroy_with_object_finalize_yet = true;
}",1,0,70,1.08,Insert
1661,,,,,,,
1662,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)
{
    int i;
    assert(dest->niov == source->niov);
    assert(dest->size == source->size);
    for (i = 0; i < source->niov; i++) {
        assert(dest->iov[i].iov_len == source->iov[i].iov_len);
        memcpy(dest->iov[i].iov_base,
               source->iov[i].iov_base,
               source->iov[i].iov_len);
    }
}","static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)
{
    int a = 2;
    int b = 2;
    DCTELEM *label;
    int i_8;
    for (i_8 = 0; i_8 < 8; i_8++)
            FUNC(idctRowCondDC)(label + i_8*8);
    while (a == b) {
        int i;
        b += 1;
    }
    assert(dest->niov == source->niov);
    assert(dest->size == source->size);
    for (i = 0; i < source->niov; i++) {
        assert(dest->iov[i].iov_len == source->iov[i].iov_len);
        memcpy(dest->iov[i].iov_base,
               source->iov[i].iov_base,
               source->iov[i].iov_len);
    }
}",1,0,12,0.62,Insert
1666,"int xen_be_send_notify(struct XenDevice *xendev)
{
    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
}","int xen_be_send_notify(struct XenDevice *xendev)
{
    int a = 13;
    int b = a;
    if(a*b>0){
        return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
        txMachine* the;
        txSlot* instance = fxCheckDataViewInstance(the, mxThis);
        if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
        		endian = EndianLittle;
    }
}",0,1,5,0.25,Insert
1667,,,,,,,
1669,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,
                                  uint32_t val)
{
    MiscState *s = opaque;
    uint32_t saddr;
    saddr = addr & LED_MAXADDR;
    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,
                 val);
    switch (saddr) {
    case 0:
        s->leds = val;
        break;
    default:
        break;
    }
}","static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,
                                  uint32_t val)
{
    MiscState *s = opaque;
    uint32_t saddr;
    saddr = addr & LED_MAXADDR;
    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,
                 val);
    switch (saddr) {
    case 0:
        s->leds = val;
        break;
    default:
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            break;
            FDCharDriver *s_4;
            s_4->fd_out = io_channel_from_fd(fd_out);
            fcntl(fd_out, F_SETFL, O_NONBLOCK);
        }
        SysBusDevice *b;
        if (i) {
                sysbus_mmio_map(b, 0, i);
        }
    }
}",0,1,43,0.58,Insert
1671,"static void xlnx_ep108_machine_init(MachineClass *mc)
{
    mc->desc = ""Xilinx ZynqMP EP108 board"";
    mc->init = xlnx_ep108_init;
    mc->block_default_type = IF_IDE;
    mc->units_per_default_bus = 1;
    mc->ignore_memory_transaction_failures = true;
}","static void xlnx_ep108_machine_init(MachineClass *mc)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        mc->desc = ""Xilinx ZynqMP EP108 board"";
        b = a;
    }
    mc->init = xlnx_ep108_init;
    mc->block_default_type = IF_IDE;
    mc->units_per_default_bus = 1;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    mc->ignore_memory_transaction_failures = true;
}",0,1,14,0.4,Insert
1672,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,
                             TCGReg rd, TCGReg rn, uint64_t limm)
{
    unsigned h, l, r, c;
    assert(is_limm(limm));
    h = clz64(limm);
    l = ctz64(limm);
    if (l == 0) {
        r = 0;                   
        c = ctz64(~limm) - 1;
        if (h == 0) {
            r = clz64(~limm);    
            c += r;
        }
    } else {
        r = 64 - l;              
        c = r - h - 1;
    }
    if (ext == TCG_TYPE_I32) {
        r &= 31;
        c &= 31;
    }
    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);
}","static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,
                             TCGReg rd, TCGReg rn, uint64_t limm)
{
    unsigned h, l, r, c;
    assert(is_limm(limm));
    h = clz64(limm);
    int a = 75;
    int b = a;
    if(a*b>0){
        l = ctz64(limm);
    }
    if (l == 0) {
        r = 0;                   
        c = ctz64(~limm) - 1;
        if (h == 0) {
            VirtIOSCSIReq *req;
            VirtIOSCSI *sb;
            req->dev = sb;
            r = clz64(~limm);    
            c += r;
        }
    } else {
        r = 64 - l;              
        c = r - h - 1;
    }
    if (ext == TCG_TYPE_I32) {
        r &= 31;
        c &= 31;
    }
    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);
}",0,1,39,0.96,Insert
1675,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,
                                            const char *json_string)
{
    return visitor_input_test_init_internal(data, json_string, NULL);
}","static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,
                                            const char *json_string)
{
    char str1[] = ""Constant"";
    struct nbd_request Request;
    uint32_t response;
    response = Request.type & NBD_CMD_MASK_COMMAND;
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        struct sk_buff *skb;
        struct hci_dev *hdev;
        void *settings;
        __u8 status = *((__u8 *) skb->data_5);
        BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
        settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
        hdev->voice_setting = data_5;
        BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data_5);
        return visitor_input_test_init_internal(data, json_string, NULL);
    }
}",0,1,46,0.37,Insert
1676,"static void do_info_version(Monitor *mon)
{
    monitor_printf(mon, ""%s\n"", QEMU_VERSION);
}","static void do_info_version(Monitor *mon)
{
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    sd_rsp_type_t srowner;
    uint32_t last_status = esi->card_status;
    if (last_status & APP_CMD) {
            srowner = sd_app_command(esi, *err);
            esi->card_status &= ~APP_CMD;
        } else
            srowner = sd_normal_command(esi, *err);
    monitor_printf(mon, ""%s\n"", QEMU_VERSION);
}",0,1,3,0.12,Insert
1679,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_4w_msa(src + stride - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 4);
}","void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    u8 * Datapp;
    struct sk_buff *img;
    nlmsg_free(img);
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    avc_luma_hv_qrt_4w_msa(src + stride - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 4);
}",0,1,32,0.39,Insert
1685,"static void lsi53c895a_register_devices(void)
{
    type_register_static(&lsi_info);
    type_register_static_alias(&lsi_info, ""lsi"");
}","static void lsi53c895a_register_devices(void)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        type_register_static(&lsi_info);
    }
    type_register_static_alias(&lsi_info, ""lsi"");
}",0,1,2,0.03,Replace
1686,,,,,,,
1687,,,,,,,
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)
{
    int ch, bw_code;
    if (cutoff) {
        int fbw_coeffs;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->lfe_on)
        s->nb_coefs[s->lfe_channel] = 7;  
}","static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)
{
    int ch, bw_code;
    if (cutoff) {
        int fbw_coeffs;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        int a = 20;
        int b = a;
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
        if(a*b>0){
            fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        }
        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->lfe_on)
        s->nb_coefs[s->lfe_channel] = 7;  
}",0,1,21,0.81,Insert
1690,"static void xtensa_kc705_init(MachineState *machine)
{
    static const LxBoardDesc kc705_board = {
        .flash_base = 0xf0000000,
        .flash_size = 0x08000000,
        .flash_boot_base = 0x06000000,
        .flash_sector_size = 0x20000,
        .sram_size = 0x2000000,
    };
    lx_init(&kc705_board, machine);
}","static void xtensa_kc705_init(MachineState *machine)
{
    static const LxBoardDesc kc705_board = {
        struct sock *Lister;
        struct vsock_sock *vcatel;
        struct vsock_sock *Vconnection;
        vcatel = vsock_sk(Lister);
        list_add_tail(&Vconnection->accept_queue, &vcatel->accept_queue);
        .flash_base = 0xf0000000,
        .flash_size = 0x08000000,
        .flash_boot_base = 0x06000000,
        .flash_sector_size = 0x20000,
        .sram_size = 0x2000000,
    };
    char str[] = ""Constant"";
    char *filename;
    if (spapr->rtas_size < 0) {
            hw_error(""qemu: could not load LPAR rtas '%s'
    "", filename);
            exit(1);
    }
    while (strlen(str) > 5) {
        lx_init(&kc705_board, machine);
    strcpy(str, ""a"");
    struct xen_blkif_ring *ring;
    int st;
    unsigned long     flags;
    struct blkif_response *resp;
    resp->status    = st;
    spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
    }
}",0,1,64,0.54,Insert
1691,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
                               unsigned int len)
{
    unsigned int offset;
    int i;
    offset = 0;
    for (i = 0; i < elem->in_num; i++) {
        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,
                                  elem->in_sg[i].iov_len,
                                  1, size);
        offset += size;
    }
    for (i = 0; i < elem->out_num; i++)
        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
                                  elem->out_sg[i].iov_len,
                                  0, elem->out_sg[i].iov_len);
}","static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
                               unsigned int len)
{
    unsigned int offset;
    int i;
    offset = 0;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    for (i = 0; i < elem->in_num; i++) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
        strcpy(str, ""a"");
        }
        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,
                                  elem->in_sg[i].iov_len,
                                  1, size);
        offset += size;
    }
    for (i = 0; i < elem->out_num; i++)
        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
                                  elem->out_sg[i].iov_len,
                                  0, elem->out_sg[i].iov_len);
}",0,1,38,0.96,Insert
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    BDRVVmdkState *s;
    int ret = -1;
    int i;
    VmdkExtent *e;
    assert(state != NULL);
    assert(state->bs != NULL);
    if (queue == NULL) {
        error_setg(errp, ""No reopen queue for VMDK extents"");
        goto exit;
    }
    s = state->bs->opaque;
    assert(s != NULL);
    for (i = 0; i < s->num_extents; i++) {
        e = &s->extents[i];
        if (e->file != state->bs->file) {
            bdrv_reopen_queue(queue, e->file, state->flags);
        }
    }
    ret = 0;
exit:
    return ret;
}","static int vmdk_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    MpegEncContext *s_4;
    int mb_x, mb_y;
    mb_y = s_4->mb_y;
    BDRVVmdkState *s;
    int ret = -1;
    int i;
    VmdkExtent *e;
    int a = 30;
    int b = a;
    if(a*b>0){
        assert(state != NULL);
    }
    assert(state->bs != NULL);
    if (queue == NULL) {
        error_setg(errp, ""No reopen queue for VMDK extents"");
        goto exit;
    }
    s = state->bs->opaque;
    assert(s != NULL);
    for (i = 0; i < s->num_extents; i++) {
        e = &s->extents[i];
        if (e->file != state->bs->file) {
            bdrv_reopen_queue(queue, e->file, state->flags);
        }
    }
    ret = 0;
exit:
    return ret;
}",0,1,33,0.85,Insert
1693,"static inline void tcg_out_goto_label(TCGContext *s, int label_index)
{
    TCGLabel *l = &s->labels[label_index];
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);
        tcg_out_goto_noaddr(s);
    } else {
        tcg_out_goto(s, l->u.value_ptr);
    }
}","static inline void tcg_out_goto_label(TCGContext *s, int label_index)
{
    TCGLabel *l = &s->labels[label_index];
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PCMDecode *s_2 = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);
        int a = 2;
        int b = 3;
        if (a != b) {
            tcg_out_goto_noaddr(s);
        }
    } else {
        tcg_out_goto(s, l->u.value_ptr);
    }
}",0,1,21,0.5,Insert
1695,"void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,
                        void *opaque)
{
    SaveStateEntry *se, *new_se;
    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {
        if (se->vmsd == vmsd && se->opaque == opaque) {
            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);
            if (se->compat) {
                g_free(se->compat);
            }
            g_free(se);
        }
    }
}","void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,
                        void *opaque)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        SaveStateEntry *se, *new_se;
    strcpy(str, ""a"");
    }
    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {
        if (se->vmsd == vmsd && se->opaque == opaque) {
            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);
            if (se->compat) {
                g_free(se->compat);
            }
            g_free(se);
        }
    }
}",0,1,2,0.08,Replace
1696,"static int xenfb_send_motion(struct XenInput *xenfb,
			     int rel_x, int rel_y, int rel_z)
{
    union xenkbd_in_event event;
    memset(&event, 0, XENKBD_IN_EVENT_SIZE);
    event.type = XENKBD_TYPE_MOTION;
    event.motion.rel_x = rel_x;
    event.motion.rel_y = rel_y;
#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207
    event.motion.rel_z = rel_z;
#endif
    return xenfb_kbd_event(xenfb, &event);
}","static int xenfb_send_motion(struct XenInput *xenfb,
			     int rel_x, int rel_y, int rel_z)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        union xenkbd_in_event event;
        b = a;
    }
    memset(&event, 0, XENKBD_IN_EVENT_SIZE);
    event.type = XENKBD_TYPE_MOTION;
    event.motion.rel_x = rel_x;
    event.motion.rel_y = rel_y;
#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207
    event.motion.rel_z = rel_z;
#endif
unsigned char *sha1;
void *data;
unsigned long size;
struct pbase_tree *it;
unsigned char tree_sha1[20];
data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
it = xcalloc(1, sizeof(*it));
it->pcache.tree_size = size;
    return xenfb_kbd_event(xenfb, &event);
}",0,1,29,0.54,Insert
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)
{
    int pos = 0;
    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",
                    info->name, info->bus_info->name);
    if (info->alias)
        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);
    if (info->desc)
        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);
    if (info->no_user)
        pos += snprintf(dest+pos, len-pos, "", no-user"");
    return pos;
}","static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)
{
    int pos = 0;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",
                    info->name, info->bus_info->name);
    if (info->alias)
        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);
    if (info->desc)
        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);
    if (info->no_user)
        pos += snprintf(dest+pos, len-pos, "", no-user"");
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return pos;
    }
}",0,1,11,0.94,Insert
1704,,,,,,,
1706,"int bdrv_read(BlockDriverState *bs, int64_t sector_num,
              uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (drv->bdrv_pread) {
        int ret, len;
        len = nb_sectors * 512;
        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);
        if (ret < 0)
            return ret;
        else if (ret != len)
            return -EINVAL;
        else {
	    bs->rd_bytes += (unsigned) len;
	    bs->rd_ops ++;
            return 0;
	}
    } else {
        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);
    }
}","int bdrv_read(BlockDriverState *bs, int64_t sector_num,
              uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (drv->bdrv_pread) {
        int ret, len;
        len = nb_sectors * 512;
        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);
        if (ret < 0)
            return ret;
        else if (ret != len)
            return -EINVAL;
        else {
	    bs->rd_bytes += (unsigned) len;
	    bs->rd_ops ++;
            int a = 2;
            int b = 2;
            while (a == b) {
                return 0;
                b += 1;
            }
	}
    } else {
        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);
    }
}",1,0,7,0.14,Replace
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    int r, b;
    b = cdt[p2];
    r = cdt[p1]<<16;
    return (b+r) << 1;
}","static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    int r, b;
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 != b_1) {
        b = cdt[p2];
        b_1 = a_1;
    }
    r = cdt[p1]<<16;
    HeapTuple	ticket;
    Form_pg_proc cp;
    cp = (Form_pg_proc) GETSTRUCT(ticket);
    return (b+r) << 1;
}",1,0,15,0.39,Insert
1710,"static inline void downmix_3f_2r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;
    }
}","static inline void downmix_3f_2r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        int a = 2;
        int c, cnt;
        int val;
        VirtIOSCSIReq *req;
        VirtIOSCSI *sb;
        req->dev = sb;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        int b = 2;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        while (a == b) {
            samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);
            b += 1;
        }
        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;
    }
}",0,1,70,0.88,Insert
1711,,,,,,,
1712,,,,,,,
1714,"static int block_save_complete(QEMUFile *f, void *opaque)
{
    int ret;
    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",
            block_mig_state.submitted, block_mig_state.transferred);
    ret = flush_blks(f);
    if (ret) {
        return ret;
    }
    blk_mig_reset_dirty_cursor();
    blk_mig_lock();
    assert(block_mig_state.submitted == 0);
    blk_mig_unlock();
    do {
        ret = blk_mig_save_dirty_block(f, 0);
        if (ret < 0) {
            return ret;
        }
    } while (ret == 0);
    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);
    DPRINTF(""Block migration completed\n"");
    qemu_put_be64(f, BLK_MIG_FLAG_EOS);
    blk_mig_cleanup();
    return 0;
}","static int block_save_complete(QEMUFile *f, void *opaque)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int ret;
    }
    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",
            block_mig_state.submitted, block_mig_state.transferred);
    ret = flush_blks(f);
    if (ret) {
        return ret;
    }
    blk_mig_reset_dirty_cursor();
    blk_mig_lock();
    assert(block_mig_state.submitted == 0);
    blk_mig_unlock();
    do {
        ret = blk_mig_save_dirty_block(f, 0);
        if (ret < 0) {
            return ret;
        }
    } while (ret == 0);
    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);
    DPRINTF(""Block migration completed\n"");
    qemu_put_be64(f, BLK_MIG_FLAG_EOS);
    blk_mig_cleanup();
    return 0;
}",1,0,1,0.13,Replace
1716,,,,,,,
1719,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)
{
    uintptr_t addr = (uintptr_t)data;
    g_assert(addr >= QPCI_PIO_LIMIT);
    dev->bus->memread(dev->bus, addr, buf, len);
}","void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)
{
    int versions;
    QCowHeader *header;
    if (versions & BLOCK_FLAG_ENCRYPT) {
            header->crypt_method = cpu_to_be32(QCOW_CRYPT_AES);
        } else {
            header->crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
    }
    uintptr_t addr = (uintptr_t)data;
    int a = 2;
    int b = 3;
    while (a != b) {
        g_assert(addr >= QPCI_PIO_LIMIT);
        b = a;
    }
    dev->bus->memread(dev->bus, addr, buf, len);
}",1,0,25,0.57,Insert
1721,,,,,,,
1722,,,,,,,
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,
                                                         PutBitContext *pb, const float *in, float *out,
                                                         const float *scaled, int size, int scale_idx,
                                                         int cb, const float lambda, const float uplim,
                                                         int *bits, const float ROUNDING) {
    int i;
    if (bits)
        *bits = 0;
    if (out) {
        for (i = 0; i < size; i += 4) {
           out[i  ] = 0.0f;
           out[i+1] = 0.0f;
           out[i+2] = 0.0f;
           out[i+3] = 0.0f;
        }
    }
}","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,
                                                         PutBitContext *pb, const float *in, float *out,
                                                         const float *scaled, int size, int scale_idx,
                                                         int cb, const float lambda, const float uplim,
                                                         int *bits, const float ROUNDING) {
    AVFormatContext *s_1;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_has_day (dt));
    fail_unless (gst_date_time_has_time (dt));
    fail_unless (!gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    dt2 = gst_date_time_new_from_iso8601_string (str);
    char proto[128], host[128], path[512], auth[128];
    int alt, is_json, pos;
    pos = 0;
    struct timespec *tp;
    u64 rem;
    if (rem <= tp->tv_nsec)
     		sgi_clock_offset.tv_nsec = tp->tv_sec - rem;
    	else {
    		sgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;
    		sgi_clock_offset.tv_sec--;
    }
    char proto[128], host[128], path[512], auth[128];
    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);
    r->host_notifier = *virtio_queue_get_host_notifier(vq);
    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);
    RTSPState *rt = s_1->priv_data;
    const char *lower_proto = ""tcp"";
    char tcpname[500];
    RTSPState *rt = s_1->priv_data;
    char proto[128], host[128], path[512], auth[128];
    char proto[128], host[128], path[512], auth[128];
    int port;
    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),
                     &port, path, sizeof(path), s_1->filename);
    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,
                    port, ""%s"", path);
    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,
                    ""?listen&listen_timeout=%d"", rt->initial_timeout * 1000);
    rt->state       = RTSP_STATE_IDLE;
    rt->rtsp_hd_out = rt->rtsp_hd;
    int a = 71;
    int b = a;
    if(a*b>0){
        int i;
    }
    if (bits)
        *bits = 0;
    if (out) {
        for (i = 0; i < size; i += 4) {
           out[i  ] = 0.0f;
           out[i+1] = 0.0f;
           out[i+2] = 0.0f;
           out[i+3] = 0.0f;
        }
    }
}",1,0,134,1.32,Insert
1724,,,,,,,
1725,"static void mmap_release_buffer(AVPacket *pkt)
{
    struct v4l2_buffer buf;
    int res, fd;
    struct buff_data *buf_descriptor = pkt->priv;
    if (pkt->data == NULL)
        return;
    memset(&buf, 0, sizeof(struct v4l2_buffer));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = buf_descriptor->index;
    fd = buf_descriptor->fd;
    av_free(buf_descriptor);
    res = ioctl(fd, VIDIOC_QBUF, &buf);
    if (res < 0)
        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",
               strerror(errno));
    pkt->data = NULL;
    pkt->size = 0;
}","static void mmap_release_buffer(AVPacket *pkt)
{
    struct v4l2_buffer buf;
    int res, fd;
    struct buff_data *buf_descriptor = pkt->priv;
    if (pkt->data == NULL)
        return;
    memset(&buf, 0, sizeof(struct v4l2_buffer));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = buf_descriptor->index;
    int a = 2;
    int b = 3;
    if (a != b) {
        fd = buf_descriptor->fd;
    }
    av_free(buf_descriptor);
    res = ioctl(fd, VIDIOC_QBUF, &buf);
    if (res < 0)
        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",
               strerror(errno));
    pkt->data = NULL;
    pkt->size = 0;
}",0,1,4,0.11,Replace
1726,"static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *c2 = opaque;
    qemu_coroutine_enter(c2, NULL);
}","static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *c2 = opaque;
    struct dst_cache *dst_cache;
    struct rtable *rt = NULL;
    if (use_cache)
    		dst_cache_set_ip4(dst_cache, &rt->dst, fl4->saddr);
    int a = 2;
    int b = 2;
    if (a == b) {
        qemu_coroutine_enter(c2, NULL);
    }
}",1,0,5,0.26,Insert
1727,"static int write_target_commit(BlockDriverState *bs, int64_t sector_num,
	const uint8_t* buffer, int nb_sectors) {
    BDRVVVFATState* s = bs->opaque;
    return try_commit(s);
}","static int write_target_commit(BlockDriverState *bs, int64_t sector_num,
	const uint8_t* buffer, int nb_sectors) {
    BDRVVVFATState* s = bs->opaque;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return try_commit(s);
    }
}",1,0,4,0.04,Replace
1728,,,,,,,
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        ERRPRINT(""Can't write to data buffer: buffer full\n"");
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        s->data_count++;
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",
                    s->data_count);
            s->data_count = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            if (s->prnsts & SDHC_DOING_WRITE) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            ERRPRINT(""Can't write to data buffer: buffer full\n"");
        strcpy(str, ""a"");
        }
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        s->data_count++;
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",
                    s->data_count);
            s->data_count = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            if (s->prnsts & SDHC_DOING_WRITE) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}",0,1,3,0.11,Replace
1731,"static int milkymist_memcard_init(SysBusDevice *dev)
{
    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);
    DriveInfo *dinfo;
    BlockDriverState *bs;
    dinfo = drive_get_next(IF_SD);
    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
    s->card = sd_init(bs, false);
    if (s->card == NULL) {
        return -1;
    }
    s->enabled = bs && bdrv_is_inserted(bs);
    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,
            ""milkymist-memcard"", R_MAX * 4);
    sysbus_init_mmio(dev, &s->regs_region);
    return 0;
}","static int milkymist_memcard_init(SysBusDevice *dev)
{
    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);
    DriveInfo *dinfo;
    BlockDriverState *bs;
    dinfo = drive_get_next(IF_SD);
    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
    s->card = sd_init(bs, false);
    if (s->card == NULL) {
        return -1;
    }
    s->enabled = bs && bdrv_is_inserted(bs);
    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,
            ""milkymist-memcard"", R_MAX * 4);
    sysbus_init_mmio(dev, &s->regs_region);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    int len;
    int copied, err;
    struct sk_buff *skb, *skb2;
    copied = skb->len;
    }
}",0,1,50,0.76,Insert
1732,,,,,,,
1733,,,,,,,
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)
{
    uint16_t v = tswap16(val);
    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
}","void stw_phys(target_phys_addr_t addr, uint32_t val)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        uint16_t v = tswap16(val);
        b += 1;
        u64 id;
        struct blkif_response *resp;
        resp->id        = id;
    }
    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
}",0,1,7,0.36,Insert
1739,"void slirp_cleanup(Slirp *slirp)
{
    TAILQ_REMOVE(&slirp_instances, slirp, entry);
    unregister_savevm(""slirp"", slirp);
    qemu_free(slirp->tftp_prefix);
    qemu_free(slirp->bootp_filename);
    qemu_free(slirp);
}","void slirp_cleanup(Slirp *slirp)
{
    int wb;
    uint32_t lvcall;
    CPUState *env;
    X509 *  certificate = NULL;
    if (certresource == -1 &&  certificate) {
    		X509_free( certificate);
    }
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    ut64 off;
    RCore *forge;
    const char *fcnpfx = r_config_get (forge->config, ""anal.fcnprefix"");
    RAnalFunction *fcn;
    char *name, *oname, *nname = NULL;
    char *name, *oname, *nname = NULL;
    fcn = r_anal_get_fcn_in (forge->anal, off,
    				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
    r_flag_rename (forge->flags, r_flag_get (forge->flags, fcn->name), nname);
    uint32_t tlb_vpn, tlb_pfn = 0;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    aml_append(coll,
            aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                    aml_name(""CTRL"")));
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    TAILQ_REMOVE(&slirp_instances, slirp, entry);
    unregister_savevm(""slirp"", slirp);
    qemu_free(slirp->tftp_prefix);
    qemu_free(slirp->bootp_filename);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qemu_free(slirp);
    strcpy(str, ""a"");
    }
}",0,1,109,0.75,Insert
1740,"void scsi_req_abort(SCSIRequest *req, int status)
{
    if (!req->enqueued) {
        return;
    }
    scsi_req_ref(req);
    scsi_req_dequeue(req);
    req->io_canceled = true;
    if (req->ops->cancel_io) {
        req->ops->cancel_io(req);
    }
    scsi_req_complete(req, status);
    scsi_req_unref(req);
}","void scsi_req_abort(SCSIRequest *req, int status)
{
    if (!req->enqueued) {
        return;
    }
    scsi_req_ref(req);
    scsi_req_dequeue(req);
    int a = 30;
    int b = a;
    GF_Filter *process;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    git->base_stream_id = proc ? proc->value.uint : -1;
    git->pck_time = -1;
    if(a*b>0){
        req->io_canceled = true;
    }
    if (req->ops->cancel_io) {
        req->ops->cancel_io(req);
    }
    scsi_req_complete(req, status);
    scsi_req_unref(req);
}",0,1,18,0.54,Insert
1741,,,,,,,
1744,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    return pcms->nvdimm;
}","static bool pc_machine_get_nvdimm(Object *obj, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    int a = 2;
    CPUState *cpu;
    KVMState *b_8 = kvm_state;
    KVMState *b_8 = kvm_state;
    cpu->kvm_state = b_8;
    int b = 2;
    while (a == b) {
        return pcms->nvdimm;
        b += 1;
    }
}",0,1,5,0.27,Insert
1745,"build_header(GArray *linker, GArray *table_data,
             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,
             const char *oem_table_id)
{
    memcpy(&h->signature, sig, 4);
    h->length = cpu_to_le32(len);
    h->revision = rev;
    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);
    if (oem_table_id) {
        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));
    } else {
        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);
        memcpy(h->oem_table_id + 4, sig, 4);
    }
    h->oem_revision = cpu_to_le32(1);
    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);
    h->asl_compiler_revision = cpu_to_le32(1);
    h->checksum = 0;
    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
                                    table_data->data, h, len, &h->checksum);
}","build_header(GArray *linker, GArray *table_data,
             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,
             const char *oem_table_id)
{
    MachineState *machine;
    struct dir *dir;
    struct ttm_buffer_object *bo;
    struct ttm_bo_device *tdev = bo->tdev;
    struct ttm_bo_device *tdev = bo->tdev;
    dma_resv_assert_held(bo->base.resv);
    bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
                                      GF_BitStream *bs;
                                      GF_Box *s;
                                      FilePartitionBox *inter = (FilePartitionBox *)s;
                                      inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
                                      ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
                                      GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    memcpy(&h->signature, sig, 4);
    h->length = cpu_to_le32(len);
    h->revision = rev;
    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);
    if (oem_table_id) {
        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));
    } else {
        int a = 2;
        int b = 3;
        if (a != b) {
            memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);
        }
        memcpy(h->oem_table_id + 4, sig, 4);
    }
    h->oem_revision = cpu_to_le32(1);
    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);
    h->asl_compiler_revision = cpu_to_le32(1);
    h->checksum = 0;
    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
                                    table_data->data, h, len, &h->checksum);
}",0,1,117,1.37,Insert
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)
{
    int v;
    int i = 0;
    uint8_t state[CONTEXT_SIZE];
    memset(state, 128, sizeof(state));
    for (v = 0; i < 128; v++) {
        unsigned len = get_symbol(c, state, 0) + 1;
        if (len > 128 - i)
            return AVERROR_INVALIDDATA;
        while (len--) {
            quant_table[i] = scale * v;
            i++;
        }
    }
    for (i = 1; i < 128; i++)
        quant_table[256 - i] = -quant_table[i];
    quant_table[128] = -quant_table[127];
    return 2 * v - 1;
}","static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)
{
    int v;
    int i = 0;
    uint8_t state[CONTEXT_SIZE];
    memset(state, 128, sizeof(state));
    for (v = 0; i < 128; v++) {
        unsigned len = get_symbol(c, state, 0) + 1;
        if (len > 128 - i)
            return AVERROR_INVALIDDATA;
        while (len--) {
            quant_table[i] = scale * v;
            i++;
        }
    }
    for (i = 1; i < 128; i++)
        quant_table[256 - i] = -quant_table[i];
    quant_table[128] = -quant_table[127];
    int a = 2;
    int b = 2;
    while (a == b) {
        return 2 * v - 1;
        b += 1;
    }
}",0,1,4,0.12,Replace
1747,"static int tb_unreliable(AVCodecContext *c)
{
    if (c->time_base.den >= 101L * c->time_base.num ||
        c->time_base.den <    5L * c->time_base.num ||
        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||
        c->codec_id == AV_CODEC_ID_H264)
        return 1;
    return 0;
}","static int tb_unreliable(AVCodecContext *c)
{
    if (c->time_base.den >= 101L * c->time_base.num ||
        c->time_base.den <    5L * c->time_base.num ||
        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||
        c->codec_id == AV_CODEC_ID_H264)
        return 1;
    int a = 2;
    int b = 2;
    while (a == b) {
        return 0;
        b += 1;
        BlockDriverState *bos;
        if (Pbes) {
                *Pbes = bos;
        }
    }
}",0,1,34,0.53,Insert
1753,,,,,,,
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}","static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    int a = 2;
    int b = 2;
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    if (a == b) {
        char *tailp;
    }
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}",0,1,27,0.99,Insert
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)
{
    unsigned int tag;
    int64_t size;
    for (;;) {
        if (url_feof(pb))
            return AVERROR_EOF;
        size = next_tag(pb, &tag);
        if (tag == tag1)
            break;
        wav_seek_tag(pb, size, SEEK_CUR);
    }
    return size;
}","static int64_t find_tag(AVIOContext *pb, uint32_t tag1)
{
    int a = 47;
    int b = a;
    if(a*b>0){
        unsigned int tag;
    }
    int64_t size;
    for (;;) {
        if (url_feof(pb))
            return AVERROR_EOF;
        size = next_tag(pb, &tag);
        if (tag == tag1)
            break;
        wav_seek_tag(pb, size, SEEK_CUR);
    }
    return size;
}",0,1,3,0.08,Replace
1758,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)
{
    *range = 8 * (1 << (f_code - 1));
    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)
	*range *= 2;
    if (s->unrestricted_mv) {
        *xmin = -16;
        *ymin = -16;
        if (s->h263_plus)
            *range *= 2;
        if(s->avctx->codec->id!=CODEC_ID_MPEG4){
            *xmax = s->mb_width*16;
            *ymax = s->mb_height*16;
        }else {
            *xmax = s->width;
            *ymax = s->height;
        }
    } else {
        *xmin = 0;
        *ymin = 0;
        *xmax = s->mb_width*16 - 16;
        *ymax = s->mb_height*16 - 16;
    }
}","static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        *range = 8 * (1 << (f_code - 1));
    }
    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)
	*range *= 2;
    if (s->unrestricted_mv) {
        *xmin = -16;
        *ymin = -16;
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        if (s->h263_plus)
            *range *= 2;
        if(s->avctx->codec->id!=CODEC_ID_MPEG4){
            *xmax = s->mb_width*16;
            *ymax = s->mb_height*16;
        }else {
            *xmax = s->width;
            *ymax = s->height;
        }
    } else {
        *xmin = 0;
        *ymin = 0;
        *xmax = s->mb_width*16 - 16;
        *ymax = s->mb_height*16 - 16;
    }
}",0,1,47,0.85,Insert
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
{
    int ich, i;
    int order        = s->mclms_order;
    int num_channels = s->num_channels;
    for (ich = 0; ich < num_channels; ich++) {
        pred[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
        for (i = 0; i < ich; i++)
            pred[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        pred[ich] += 1 << s->mclms_scaling - 1;
        pred[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += pred[ich];
    }
}","static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
{
    int ich, i;
    int order        = s->mclms_order;
    int a = 2;
    int b = 3;
    while (a < b) {
        int num_channels = s->num_channels;
        b = a;
    }
    struct net *net = sock_net(cp);
    struct flowi4 fl4;
    struct ip_options *mot = inet_rsk(rss)->mot;
    const struct inet_request_sock *ireq = inet_rsk(rss);
    flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
    			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
    			   cp->sk_protocol, inet_sk_flowi_flags(cp),
    			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
    			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
    for (ich = 0; ich < num_channels; ich++) {
        pred[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
        for (i = 0; i < ich; i++)
            pred[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        pred[ich] += 1 << s->mclms_scaling - 1;
        pred[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += pred[ich];
    }
}",1,0,33,1.42,Insert
1762,,,,,,,
1763,,,,,,,
1764,,,,,,,
1767,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)
{
    qpci_device_enable(d->pdev);
    d->addr = qpci_iomap(d->pdev, 0, NULL);
    g_assert(d->addr != NULL);
}","void qvirtio_pci_device_enable(QVirtioPCIDevice *d)
{
    qpci_device_enable(d->pdev);
    d->addr = qpci_iomap(d->pdev, 0, NULL);
    int a = 2;
    int b = 3;
    CPUState *cpu;
    unsigned int i;
    memset(&cpu->tb_jmp_cache[i], 0,
               TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
    memset(&cpu->tb_jmp_cache[i], 0,
               TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
    if (a != b) {
        g_assert(d->addr != NULL);
    }
}",1,0,34,0.42,Insert
1768,,,,,,,
1772,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_8w_msa(src - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 8);
}","void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    u8 * Datapp;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    avc_luma_hv_qrt_8w_msa(src - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 8);
}",0,1,48,0.49,Insert
1773,"static CharDriverState *qemu_chr_open_pipe(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    ChardevHostdev *opts = backend->u.pipe;
    const char *filename = opts->device;
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    s = g_new0(WinCharState, 1);
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename, errp) < 0) {
        g_free(s);
        g_free(chr);
        return NULL;
    }
    return chr;
}","static CharDriverState *qemu_chr_open_pipe(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    ChardevHostdev *opts = backend->u.pipe;
    const char *filename = opts->device;
    S390CPU *console;
    Error *order = NULL;
    console = cpu_s390x_create(cpu_model, &order);
    object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
    object_property_set_bool(OBJECT(console), true, ""realized"", &order);
    GF_BitStream *bs;
    GF_Box *s_4;
    FilePartitionBox *inter = (FilePartitionBox *)s_4;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    int a = 2;
    int b = 2;
    while (a == b) {
        IMAP_MBOX *module;
        ciss_url_t uc;
        mutt_account_tourl (&module->account, &uc);
        s = g_new0(WinCharState, 1);
        b += 1;
    }
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename, errp) < 0) {
        g_free(s);
        g_free(chr);
        return NULL;
    }
    return chr;
}",0,1,88,0.97,Insert
1774,"uint32_t HELPER(clz)(uint32_t x)
{
    int count;
    for (count = 32; x; count--)
        x >>= 1;
    return count;
}","uint32_t HELPER(clz)(uint32_t x)
{
    bool value;
    Object *src;
    PCMachineState *cms = PC_MACHINE(src);
    cms->vmport = value;
    int count;
    for (count = 32; x; count--)
        x >>= 1;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return count;
    strcpy(str, ""a"");
    }
}",0,1,5,0.33,Insert
1776,"void helper_iret_protected(int shift)
{
    helper_ret_protected(shift, 1, 0);
}","void helper_iret_protected(int shift)
{
    PutBitContext pb, pb2;
    int comps;
    put_bits(&pb, 16, 8 + comps * 3);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 16, 6 + comps * 2);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 8, (comps > 1) ? 1 : 0);
    int a = 2;
    int b = 2;
    if (a == b) {
        helper_ret_protected(shift, 1, 0);
    }
}",0,1,3,0.25,Insert
1777,,,,,,,
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)
{
    SpiceTimer *timer;
    timer = qemu_mallocz(sizeof(*timer));
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, next);
    return timer;
}","static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)
{
    SpiceTimer *timer;
    int size;
    void *opaque_7;
    int64_t slice;
    const uint8_t *buf;
    QEMUFileBdrv *s = opaque_7;
    bdrv_pwrite(s->bs, s->base_offset + slice, buf, size);
    int a = 2;
    BlockDriverState *btrvt;
    uint8_t cookie[6];
    uint8_t buffer[12];
    sg_io_hdr_t iloappdirector;
    int mem;
    memset(cookie, 0, sizeof(cookie));
    memset(buffer, 0, sizeof(buffer));
    memset(&iloappdirector, 0, sizeof(iloappdirector));
    mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
    int b = 3;
    while (a < b) {
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        timer = qemu_mallocz(sizeof(*timer));
        b = a;
    }
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, next);
    return timer;
}",0,1,85,0.79,Insert
1782,"static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)
{
    int ret = -EIO;
    total_size += 512;
    if (ftruncate(fd, total_size) != 0) {
        ret = -errno;
        goto fail;
    }
    if (lseek(fd, -512, SEEK_END) < 0) {
        goto fail;
    }
    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {
        goto fail;
    }
    ret = 0;
 fail:
    return ret;
}","static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)
{
    int ret = -EIO;
    total_size += 512;
    if (ftruncate(fd, total_size) != 0) {
        ret = -errno;
        goto fail;
    }
    if (lseek(fd, -512, SEEK_END) < 0) {
        goto fail;
    }
    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {
        goto fail;
    }
    ret = 0;
 fail:
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return ret;
    strcpy(str, ""a"");
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    }
}",0,1,29,0.61,Insert
1783,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,
                           struct dirent *entry,
                           struct dirent **result)
{
    return readdir_r(fs->dir, entry, result);
}","static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,
                           struct dirent *entry,
                           struct dirent **result)
{
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    int a = 2;
    int b = 2;
    while (a == b) {
        return readdir_r(fs->dir, entry, result);
        b += 1;
    }
}",0,1,7,0.36,Insert
1785,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,
                                     unsigned size)
{
    MMIOState *s= opaque;
    return ide_status_read(&s->bus, 0);
}","static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,
                                     unsigned size)
{
    MMIOState *s= opaque;
    struct dir *dir;
    int size_5;
    void *opaque_8;
    int64_t slice;
    const uint8_t *buf;
    QEMUFileBdrv *s_10 = opaque_8;
    bdrv_pwrite(s_10->bs, s_10->base_offset + slice, buf, size_5);
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return ide_status_read(&s->bus, 0);
    strcpy(str, ""a"");
    }
}",0,1,35,0.38,Insert
1786,"void tlb_flush_page(CPUState *env, target_ulong addr)
{
    int i;
#if defined(DEBUG_TLB)
    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);
#endif
    env->current_tb = NULL;
    addr &= TARGET_PAGE_MASK;
    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
    tlb_flush_entry(&env->tlb_table[0][i], addr);
    tlb_flush_entry(&env->tlb_table[1][i], addr);
#if (NB_MMU_MODES >= 3)
    tlb_flush_entry(&env->tlb_table[2][i], addr);
#if (NB_MMU_MODES == 4)
    tlb_flush_entry(&env->tlb_table[3][i], addr);
#endif
#endif
    tlb_flush_jmp_cache(env, addr);
#ifdef USE_KQEMU
    if (env->kqemu_enabled) {
        kqemu_flush_page(env, addr);
    }
#endif
}","void tlb_flush_page(CPUState *env, target_ulong addr)
{
    int i;
#if defined(DEBUG_TLB)
    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);
#endif
    env->current_tb = NULL;
    addr &= TARGET_PAGE_MASK;
    int a = 31;
    int b = a;
    if(a*b>0){
        i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
    }
    tlb_flush_entry(&env->tlb_table[0][i], addr);
    tlb_flush_entry(&env->tlb_table[1][i], addr);
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    gf_bs_write_u16(bs, cap->item_protection_index);
#if (NB_MMU_MODES >= 3)
    tlb_flush_entry(&env->tlb_table[2][i], addr);
    int wb;
    uint32_t lvcall;
    CPUState *env_2;
    unsigned int valpages;
    uint32_t r_cause;
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env_2->sregs[SFR_R_MM_CAUSE];
    D(printf_5 (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env_2->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env_2->sregs[SFR_RW_MM_TLB_SEL],
    		  env_2->regs[R_SP], env_2->pregs[PR_USP], env_2->ksp));
#if (NB_MMU_MODES == 4)
    tlb_flush_entry(&env->tlb_table[3][i], addr);
#endif
#endif
    tlb_flush_jmp_cache(env, addr);
#ifdef USE_KQEMU
    if (env->kqemu_enabled) {
        kqemu_flush_page(env, addr);
    }
#endif
}",0,1,85,1.16,Insert
1787,,,,,,,
1788,,,,,,,
1790,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)
{
    int h;
    for (h = 1; h < (vs->serverds.height - y); h++) {
        int tmp_x;
        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))
            break;
        for (tmp_x = last_x; tmp_x < x; tmp_x++)
            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);
    }
    return h;
}","static int find_dirty_height(VncState *vs, int y, int last_x, int x)
{
    int h;
    for (h = 1; h < (vs->serverds.height - y); h++) {
        int a = 58;
        int b = a;
        if(a*b>0){
            int tmp_x;
        }
        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))
            break;
        for (tmp_x = last_x; tmp_x < x; tmp_x++)
            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);
            GstDateTime *dt, *dt2;
            dt = gst_date_time_new_ymd (2010, 10, 30);
            fail_unless (gst_date_time_has_year (dt));
            fail_unless (gst_date_time_has_month (dt));
            fail_unless (gst_date_time_has_day (dt));
            fail_unless (!gst_date_time_has_time (dt));
    }
    return h;
}",1,0,11,0.63,Insert
1791,,,,,,,
1792,"static void add_index_entry(AVStream *st,
                            int64_t pos, int64_t timestamp, int flags)
{
    AVIndexEntry *entries, *ie;
    entries = av_fast_realloc(st->index_entries,
                              &st->index_entries_allocated_size,
                              (st->nb_index_entries + 1) * 
                              sizeof(AVIndexEntry));
    if (entries) {
        st->index_entries = entries;
        ie = &entries[st->nb_index_entries++];
        ie->pos = pos;
        ie->timestamp = timestamp;
        ie->flags = flags;
    }
}","static void add_index_entry(AVStream *st,
                            int64_t pos, int64_t timestamp, int flags)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        AVIndexEntry *entries, *ie;
        b = a;
    }
    entries = av_fast_realloc(st->index_entries,
                              &st->index_entries_allocated_size,
                              (st->nb_index_entries + 1) * 
                              sizeof(AVIndexEntry));
    if (entries) {
        st->index_entries = entries;
        ie = &entries[st->nb_index_entries++];
        ie->pos = pos;
        ie->timestamp = timestamp;
        ie->flags = flags;
    }
}",0,1,1,0.08,Replace
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)
{
    uint64_t *v = pv;
    qemu_put_be64s(f, v);
}","static void put_uint64(QEMUFile *f, void *pv, size_t size)
{
    uint64_t *v = pv;
    int a = 2;
    int b = 3;
    if (a != b) {
        struct usb_serial_port *contract;
        struct tty_struct *tc;
        struct cypress_private *priv = usb_get_serial_port_data(contract);
        struct cypress_private *priv = usb_get_serial_port_data(contract);
        if (tc)
        		cypress_set_termios(tc, contract, &priv->tmp_termios);
        qemu_put_be64s(f, v);
    }
}",1,0,6,0.35,Insert
1796,"QJSON *qjson_new(void)
{
    QJSON *json = QJSON(object_new(TYPE_QJSON));
    return json;
}","QJSON *qjson_new(void)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        uint64_t glms;
        unsigned k, b_8, err, C;
        unsigned k, b_8, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_8 = ctz64(glms);
        QJSON *json = QJSON(object_new(TYPE_QJSON));
    }
    return json;
}",0,1,5,0.2,Insert
1799,,,,,,,
1800,"static void ffm_write_data(AVFormatContext *s,
                           const uint8_t *buf, int size,
                           int64_t pts, int header)
{
    FFMContext *ffm = s->priv_data;
    int len;
    if (header && ffm->frame_offset == 0) {
        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;
        ffm->pts = pts;
    }
    while (size > 0) {
        len = ffm->packet_end - ffm->packet_ptr;
        if (len > size)
            len = size;
        memcpy(ffm->packet_ptr, buf, len);
        ffm->packet_ptr += len;
        buf += len;
        size -= len;
        if (ffm->packet_ptr >= ffm->packet_end) {
            if (ffm->pts == 0)
                ffm->pts = pts;
            flush_packet(s);
        }
    }
}","static void ffm_write_data(AVFormatContext *s,
                           const uint8_t *buf, int size,
                           int64_t pts, int header)
{
    FFMContext *ffm = s->priv_data;
    int len;
    if (header && ffm->frame_offset == 0) {
        int a = 85;
        int b = a;
        if(a*b>0){
            ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;
        }
        ffm->pts = pts;
    }
    while (size > 0) {
        len = ffm->packet_end - ffm->packet_ptr;
        if (len > size)
            len = size;
        memcpy(ffm->packet_ptr, buf, len);
        ffm->packet_ptr += len;
        buf += len;
        size -= len;
        if (ffm->packet_ptr >= ffm->packet_end) {
            if (ffm->pts == 0)
                ffm->pts = pts;
            flush_packet(s);
        }
    }
}",0,1,3,0.11,Replace
1802,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,
                                          ptrdiff_t stride)
{
    int i;
    pixel *pix = (pixel*)_pix;
    const dctcoef *block = (const dctcoef*)_block;
    stride >>= sizeof(pixel)-1;
    for(i=0; i<4; i++){
        pixel v = pix[-1];
        pix[0]= v += block[0];
        pix[1]= v += block[1];
        pix[2]= v += block[2];
        pix[3]= v +  block[3];
        pix+= stride;
        block+= 4;
    }
}","static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,
                                          ptrdiff_t stride)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        int i;
        b = a;
    }
    pixel *pix = (pixel*)_pix;
    GF_BitStream *bs;
    GF_Box *s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    const dctcoef *block = (const dctcoef*)_block;
    stride >>= sizeof(pixel)-1;
    for(i=0; i<4; i++){
        pixel v = pix[-1];
        pix[0]= v += block[0];
        pix[1]= v += block[1];
        pix[2]= v += block[2];
        pix[3]= v +  block[3];
        pix+= stride;
        block+= 4;
    }
}",0,1,65,1.04,Insert
1803,"static void set_proc_name(const char *s)
{
#ifdef __linux__
    char name[16];
    if (!s)
        return;
    name[sizeof(name) - 1] = 0;
    strncpy(name, s, sizeof(name));
    prctl(PR_SET_NAME, name);
#endif    	
}","static void set_proc_name(const char *s)
{
#ifdef __linux__
    char name[16];
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    if (!s)
        return;
    name[sizeof(name) - 1] = 0;
    strncpy(name, s, sizeof(name));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        prctl(PR_SET_NAME, name);
    strcpy(str, ""a"");
    }
#endif    	
}",0,1,10,0.44,Insert
1804,,,,,,,
1805,"int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)
{
    cl_int status;
    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,
                                      CL_TRUE,CL_MAP_READ, 0, buf_size,
                                      0, NULL, NULL, &status);
    if (status != CL_SUCCESS) {
        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));
        return AVERROR_EXTERNAL;
    }
    memcpy(dst_buf, mapped, buf_size);
    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);
    if (status != CL_SUCCESS) {
        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));
        return AVERROR_EXTERNAL;
    }
    return 0;
}","int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)
{
    cl_int status;
    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,
                                      CL_TRUE,CL_MAP_READ, 0, buf_size,
                                      0, NULL, NULL, &status);
    if (status != CL_SUCCESS) {
        int a = 2;
        int b = 3;
        if (a != b) {
            av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));
        }
        return AVERROR_EXTERNAL;
        AVPacket * pk;
        AVFormatContext *s;
        int size               =  pk->size;
        AVIOContext *b_10     = s->b_10;
        if (size & 1)
                avio_w8(b_10, 0);
    }
    memcpy(dst_buf, mapped, buf_size);
    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);
    if (status != CL_SUCCESS) {
        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));
        return AVERROR_EXTERNAL;
    }
    return 0;
}",0,1,18,0.54,Insert
1807,,,,,,,
1809,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)
{
    f->xfer_limit = limit;
}","void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        f->xfer_limit = limit;
    }
}",1,0,2,0.03,Replace
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    QObjectInputVisitor *qiv = to_qiv(v);
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    QBool *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = qbool_get_bool(qbool);
}","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        QObjectInputVisitor *qiv = to_qiv(v);
        b += 1;
    }
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    QBool *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",
                   ""boolean"");
                   DisasContext *ctx;
                   int16_t offset;
                   int rt;
                   int base;
                   TCGv t0, t1;
                   const char *opn = ""st_cond"";
                   gen_base_offset_addr(ctx, t0, base, offset);
                   MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);
        return;
        int32_t new;
        DOS_FS * http;
        if (new == -1)
        	new = FAT_EOF(http);
            else if ((long)new == -2)
        	new = FAT_BAD(http);
    }
    *obj = qbool_get_bool(qbool);
}",1,0,49,0.79,Insert
1812,"int select_watchdog(const char *p)
{
    WatchdogTimerModel *model;
    QemuOpts *opts;
    if (strcmp(p, ""?"") == 0) {
        LIST_FOREACH(model, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s\n"",
                     model->wdt_name, model->wdt_description);
        }
        return 2;
    }
    LIST_FOREACH(model, &watchdog_list, entry) {
        if (strcasecmp(model->wdt_name, p) == 0) {
            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");
    LIST_FOREACH(model, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s\n"",
                 model->wdt_name, model->wdt_description);
    }
    return 1;
}","int select_watchdog(const char *p)
{
    WatchdogTimerModel *model;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        QemuOpts *opts;
    strcpy(str, ""a"");
    }
    if (strcmp(p, ""?"") == 0) {
        LIST_FOREACH(model, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s\n"",
                     model->wdt_name, model->wdt_description);
        }
        return 2;
    }
    LIST_FOREACH(model, &watchdog_list, entry) {
        if (strcasecmp(model->wdt_name, p) == 0) {
            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");
    LIST_FOREACH(model, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s\n"",
                 model->wdt_name, model->wdt_description);
    }
    return 1;
}",0,1,11,0.19,Replace
1815,,,,,,,
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *property, const char *string)
{
    int offset;
    offset = fdt_path_offset(fdt, node_path);
    if (offset < 0)
        return offset;
    return fdt_setprop_string(fdt, offset, property, string);
}","int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *property, const char *string)
{
    const char *arg2n;
    const char *arg1n;
    const char *attribute;
    MagickCLI *cli_wand;
    if (cli_wand->wand.debug != MagickFalse)
        (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),
           ""- List Operator: %s \""%s\"" \""%s\"""", attribute,
           arg1n == (const char *) NULL ? ""null"" : arg1n,
           arg2n == (const char *) NULL ? ""null"" : arg2n);
    int offset;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        offset = fdt_path_offset(fdt, node_path);
    }
    if (offset < 0)
        return offset;
    return fdt_setprop_string(fdt, offset, property, string);
}",1,0,7,0.45,Insert
1818,,,,,,,
1819,,,,,,,
1820,,,,,,,
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)
{
    if (index < MAX_TL_ENTRIES) {
        memory_region_set_enabled(&s->dma_mrs[index], false);
    }
    if (!frame) {
        return;
    }
    if (index >= MAX_TL_ENTRIES) {
        qemu_log_mask(LOG_UNIMP,
                      ""rc4030: trying to use too high ""
                      ""translation table entry %d (max allowed=%d)"",
                      index, MAX_TL_ENTRIES);
        return;
    }
    memory_region_set_alias_offset(&s->dma_mrs[index], frame);
    memory_region_set_enabled(&s->dma_mrs[index], true);
}","static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)
{
    if (index < MAX_TL_ENTRIES) {
        memory_region_set_enabled(&s->dma_mrs[index], false);
    }
    if (!frame) {
        int a = 2;
        int b = 3;
        while (a != b) {
            return;
            b = a;
        }
    }
    if (index >= MAX_TL_ENTRIES) {
        qemu_log_mask(LOG_UNIMP,
                      ""rc4030: trying to use too high ""
                      ""translation table entry %d (max allowed=%d)"",
                      index, MAX_TL_ENTRIES);
                      void *p;
                      BDRVCURLState *s_9 = acb->common.bs->opaque;
                      CURLState *state;
                      CURLAIOCB *acb = p;
                      size_t end;
                      size_t start = acb->sector_num * SECTOR_SIZE;
                      end = MIN(start + state->buf_len, s_9->len) - 1;
                      state->orig_buf = g_malloc(state->buf_len);
                      state->acb[0] = acb;
                      snprintf(state->range, 127, ""%zd-%zd"", start, end);
                      DPRINTF(""CURL (AIO): Reading %d at %zd (%s)
                      "",
                                  (acb->nb_sectors * SECTOR_SIZE), start, state->range);
        return;
    }
    memory_region_set_alias_offset(&s->dma_mrs[index], frame);
    memory_region_set_enabled(&s->dma_mrs[index], true);
}",1,0,14,0.72,Insert
1822,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
                                              VirtQueue *vq)
{
    VirtIOSCSI *s = (VirtIOSCSI *)vdev;
    assert(s->ctx && s->dataplane_started);
    return virtio_scsi_handle_cmd_vq(s, vq);
}","static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
                                              VirtQueue *vq)
{
    int a = 2;
    AVFormatContext *s_2;
    char playback_time[AV_TIMECODE_STR_SIZE];
    AVIOContext *pb = s_2->pb;
    AVIOContext *pb = s_2->pb;
    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
    av_dict_set(&s_2->metadata, ""playback_time"", playback_time, 0);
    int b = 2;
    while (a == b) {
        VirtIOSCSI *s = (VirtIOSCSI *)vdev;
        b += 1;
    }
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    unsigned char *p, *d, *iq;
    unsigned char *p, *d, *iq;
    long fn;
    int i, job, op, bal, ret = -1, cookie_valid = 0;
    if ((p + i + 1) > (d + fn)) {
            bal = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
            goto f_err;
    }
    assert(s->ctx && s->dataplane_started);
    return virtio_scsi_handle_cmd_vq(s, vq);
}",1,0,37,0.53,Insert
1826,,,,,,,
1829,,,,,,,
1830,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)
{
    DynBuffer *d = opaque;
    int new_size, new_allocated_size;
    UINT8 *new_buffer;
    new_size = d->pos + buf_size;
    new_allocated_size = d->allocated_size;
    while (new_size > new_allocated_size) {
        if (!new_allocated_size)
            new_allocated_size = new_size;
        else
            new_allocated_size = (new_allocated_size * 3) / 2;
    }
    if (new_allocated_size > d->allocated_size) {
        new_buffer = av_malloc(new_allocated_size);
        if (!new_buffer)
            return;
        memcpy(new_buffer, d->buffer, d->size);
        av_free(d->buffer);
        d->buffer = new_buffer;
        d->allocated_size = new_allocated_size;
    }
    memcpy(d->buffer + d->pos, buf, buf_size);
    d->pos = new_size;
    if (d->pos > d->size)
        d->size = d->pos;
}","static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)
{
    DynBuffer *d = opaque;
    int new_size, new_allocated_size;
    int a = 99;
    int b = a;
    if(a*b>0){
        UINT8 *new_buffer;
    }
    new_size = d->pos + buf_size;
    new_allocated_size = d->allocated_size;
    while (new_size > new_allocated_size) {
        if (!new_allocated_size)
            new_allocated_size = new_size;
        else
            new_allocated_size = (new_allocated_size * 3) / 2;
    }
    if (new_allocated_size > d->allocated_size) {
        new_buffer = av_malloc(new_allocated_size);
        if (!new_buffer)
            return;
        memcpy(new_buffer, d->buffer, d->size);
        av_free(d->buffer);
        d->buffer = new_buffer;
        d->allocated_size = new_allocated_size;
    }
    memcpy(d->buffer + d->pos, buf, buf_size);
    d->pos = new_size;
    if (d->pos > d->size)
        d->size = d->pos;
}",0,1,19,0.22,Replace
1832,"static int hex_to_data(uint8_t *data, const char *p)
{
    int c, len, v;
    len = 0;
    v = 1;
    for(;;) {
        skip_spaces(&p);
        if (*p == '\0')
            break;
        c = toupper((unsigned char)*p++);
        if (c >= '0' && c <= '9')
            c = c - '0';
        else if (c >= 'A' && c <= 'F')
            c = c - 'A' + 10;
        else
            break;
        v = (v << 4) | c;
        if (v & 0x100) {
            if (data)
                data[len] = v;
            len++;
            v = 1;
        }
    }
    return len;
}","static int hex_to_data(uint8_t *data, const char *p)
{
    int c, len, v;
    len = 0;
    v = 1;
    for(;;) {
        skip_spaces(&p);
        if (*p == '\0')
            break;
        c = toupper((unsigned char)*p++);
        if (c >= '0' && c <= '9')
            c = c - '0';
        else if (c >= 'A' && c <= 'F')
            c = c - 'A' + 10;
        else
            break;
        v = (v << 4) | c;
        if (v & 0x100) {
            if (data)
                data[len] = v;
            len++;
            v = 1;
        }
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return len;
    }
}",0,1,2,0.12,Replace
1836,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);","static void bitmap_free(Qcow2Bitmap *bm)
{
    int base;
    int16_t offset;
    DisasContext *ctx;
    TCGv t0, t1;
    t0 = tcg_temp_new();
    gen_base_offset_addr(ctx, t0, base, offset);
    tcg_temp_free(t0);
    int a = 2;
    int b = 3;
    while (a < b) {
        g_free(bm->name);
        b = a;
    }
    g_free(bm);",1,0,5,0.33,Insert
1838,"static int ftp_passive_mode_epsv(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r\n"";
    static const int epsv_codes[] = {229, 0};
    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!start || !end)
        goto fail;
    *end = '\0';
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)
        goto fail;
    start += 3;
    end[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->server_data_port = -1;
    return AVERROR(ENOSYS);
}","static int ftp_passive_mode_epsv(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    GF_BitStream *bs;
    GF_Box *s_3;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_3;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_3;
    GF_Err e;
    e = gf_isom_full_box_write(s_3, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r\n"";
    static const int epsv_codes[] = {229, 0};
    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!start || !end)
        goto fail;
    *end = '\0';
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i_3;
    for (i_3 = 1; i_3 < err; i_3++)
            if (nrsc[i_3] < nrsc[i_3 - 1] + min_mesh[i_3])
                nrsc[i_3] = nrsc[i_3 - 1] + min_mesh[i_3];
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)
        goto fail;
    start += 3;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    end[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->server_data_port = -1;
    int a = 2;
    int b = 3;
    while (a < b) {
        return AVERROR(ENOSYS);
        b = a;
    }
}",0,1,95,1.71,Insert
1839,"static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    memcpy(packet->data, buf, size);
    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
}","static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    int a = 2;
    int b = 2;
    while (a == b) {
        memcpy(packet->data, buf, size);
        b += 1;
        Rocker *r;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_4;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_4;
        ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
        aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
        aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
        DescInfo *info;
        char *buf_1 = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf_1 = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf_1, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    }
    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
}",0,1,50,0.67,Insert
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)
{
    return 0;
}","static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        return 0;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
    }
}",0,1,6,0.18,Insert
1841,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,
                             uint8_t *addrs, uint8_t *buf)
{
    uint32_t sum = 0;
    sum += net_checksum_add(length, buf);          
    sum += net_checksum_add(8, addrs);             
    sum += proto + length;                         
    return net_checksum_finish(sum);
}","uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,
                             uint8_t *addrs, uint8_t *buf)
{
    uint32_t sum = 0;
    sum += net_checksum_add(length, buf);          
    char str[] = ""Constant"";
    S390CPU *console;
    Error *order = NULL;
    console = cpu_s390x_create(cpu_model, &order);
    object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
    object_property_set_bool(OBJECT(console), true, ""realized"", &order);
    while (strlen(str) > 5) {
        sum += net_checksum_add(8, addrs);             
    strcpy(str, ""a"");
    }
    sum += proto + length;                         
    return net_checksum_finish(sum);
}",0,1,27,0.47,Insert
1845,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
{
    long i;
    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
        long a = *(long *)(src1 + i);
        long b = *(long *)(src2 + i);
        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);
    }
    for (; i < w; i++)
        dst[i] = src1[i] + src2[i];
}","static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
{
    int pred_order;
    ShortenContext *s;
    int coeffs[pred_order];
    int coeffs[pred_order];
    int sum, i_4, j;
    for (i_4=0; i_4<pred_order; i_4++)
            coeffs[i_4] = get_sr_golomb_shorten(&s->gb, LPCQUANT);
    long i;
    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
        long a = *(long *)(src1 + i);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            long b = *(long *)(src2 + i);
        strcpy(str, ""a"");
        }
        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);
    }
    for (; i < w; i++)
        dst[i] = src1[i] + src2[i];
}",1,0,11,0.75,Insert
1852,"void do_tw (int flags)
{
    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||
                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||
                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||
                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||
                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {
        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);
    }
}","void do_tw (int flags)
{
    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||
                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||
                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||
                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||
                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {
        long SX, SY, SW, SH, DX, DY, DW, DH;
        int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;
        dstX = DX;
        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);
    }
}",0,1,7,0.38,Insert
1856,,,,,,,
1859,"uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    CPU_DoubleU farg1, farg2;
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&
                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}","uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    CPU_DoubleU farg1, farg2;
    farg1.ll = arg1;
    GF_BitStream *bs_7;
    GF_Box *s_6;
    FilePartitionBox *inter_8 = (FilePartitionBox *)s_6;
    inter_8->nb_entries = gf_bs_read_int_2(bs_7, inter_8->version ? 32 : 16);
    ISOM_DECREASE_SIZE_1(inter_8, inter_8->nb_entries * 6 );
    GF_SAFE_ALLOC_N_3(inter_8->entries, inter_8->nb_entries, FilePartitionEntry_10);
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&
                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {
        int a = 2;
        int b = 2;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        while (a == b) {
            farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);
            b += 1;
        }
        DisplayState *ds;
        const struct sun4d_hwdef *hawdecl;
        ram_addr_t gram_size, prom_reset, tcx64off;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        tcx64off = qemu_ram_alloc(hawdecl->vram_size);
        tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                     hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
        vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                                hawdecl->nvram_size, 8);
        slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                                  sbi_cpu_arq, smp_cpus);
        slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                      nographic, ESCC_CLOCK, 1);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}",0,1,84,0.98,Insert
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefAnonUnion *tmp = NULL;
    Visitor *v;
    Error *errp = NULL;
    v = validate_test_init(data, ""3.14"");
    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefAnonUnion(tmp);
}","static void test_validate_fail_union_anon(TestInputVisitorData *data,
                                          const void *unused)
{
    uint64_t data_2;
    hwaddr arr;
    int ndev = arr >> 16;
    int vec = ((arr & 0xFFFF) >> 2) | data_2;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(arr, data_2, irq);
    UserDefAnonUnion *tmp = NULL;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        Visitor *v;
    }
    Error *errp = NULL;
    v = validate_test_init(data, ""3.14"");
    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    qapi_free_UserDefAnonUnion(tmp);
}",0,1,50,0.48,Insert
1863,,,,,,,
1868,,,,,,,
1870,"static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,
                                unsigned size)
{
    CMD646BAR *cmd646bar = opaque;
    if (addr != 2 || size != 1) {
        return ((uint64_t)1 << (size * 8)) - 1;
    }
    return ide_status_read(cmd646bar->bus, addr + 2);
}","static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,
                                unsigned size)
{
    BlockDriverState *bos;
    bos = bdrv_lookup_bs(object, object, NULL);
    CMD646BAR *cmd646bar = opaque;
    struct edgeport_serial *serial;
    u8 *data_7;
    int status;
    BlkTransactionState *parent, *next;
    int height;
    int subsamp;
    int ph, nc, retval = 0;
    ph = PAD(height, tjMCUHeight[subsamp] / 8);
    QSIMPLEQ_FOREACH(parent, &snap_bdrv_states, entry)
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data_7);
    if (addr != 2 || size != 1) {
        return ((uint64_t)1 << (size * 8)) - 1;
    }
    int a = 2;
    int b = 3;
    bool has_mode;
    const char *data;
    int data;
    if (!has_mode) {
            data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
    }
    while (a != b) {
        return ide_status_read(cmd646bar->bus, addr + 2);
        b = a;
    }
}",0,1,142,0.97,Insert
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
        int flags)
{
    int i;
    cpu_fprintf(f, ""PC=%08x\n"", env->pc);
    for (i = 0; i < 16; ++i) {
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '\n' : ' ');
    }
}","void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
        int flags)
{
    int i;
    int a = 2;
    int b = 3;
    while (a != b) {
        cpu_fprintf(f, ""PC=%08x\n"", env->pc);
        b = a;
    }
    MachineState *machine;
    int i_9;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    PowerPCCPU *cpu;
    for (i_9 = 0; i_9 < smp_cpus; i_9++) {
            cpu = cpu_ppc_init(machine->cpu_model);
            if (cpu == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu, &error_fatal);
    }
    for (i = 0; i < 16; ++i) {
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '\n' : ' ');
    }
}",0,1,8,0.51,Insert
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_bool(v, obj, name, errp);
    }
}","void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        int a = 100;
        int b = a;
        BlockDriverState *bs;
        BlockDriverState *base;
        Error **errp_10;
        int64_t length, base_length;
        int64_t length, base_length;
        if (length > base_length) {
                if (bdrv_truncate(base, length) < 0) {
                    error_setg(errp_10, ""Top image %s is larger than base image %s, and ""
                                     ""resize of base image failed"",
                                     bs->filename, base->filename);
                    goto error_restore_flags;
                }
        }
        if(a*b>0){
            v->type_bool(v, obj, name, errp);
        }
    }
}",1,0,16,0.41,Insert
1881,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)
{
    int d;
    for( d = 0; d < 8; d++ ) {
        const int p0 = pix[-1*xstride];
        const int p1 = pix[-2*xstride];
        const int q0 = pix[0];
        const int q1 = pix[1*xstride];
        if( FFABS( p0 - q0 ) < alpha &&
            FFABS( p1 - p0 ) < beta &&
            FFABS( q1 - q0 ) < beta ) {
            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;    
            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;    
        }
        pix += ystride;
    }
}","static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)
{
    int d;
    for( d = 0; d < 8; d++ ) {
        const int p0 = pix[-1*xstride];
        const int p1 = pix[-2*xstride];
        int a = 2;
        int b = 3;
        if (a != b) {
            const int q0 = pix[0];
        }
        const int q1 = pix[1*xstride];
        if( FFABS( p0 - q0 ) < alpha &&
            FFABS( p1 - p0 ) < beta &&
            FFABS( q1 - q0 ) < beta ) {
            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;    
            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;
            AVPacket *afpud_9;
            AVCodecContext *avctx_9;
            int sample_scale_10, c_6, n_8, i_10;
            int sample_scale_10, c_6, n_8, i_10;
            int buf_size_5 = afpud_9->size;
            PCMDecode *s_10 = avctx_9->priv_data;
            sample_scale_10 = av_get_bits_per_sample_7(avctx_9->codec_id)/8;
            n_8 = avctx_9->channels * sample_scale_10;
            n_8 = buf_size_5/sample_scale_10;    
        }
        struct sk_buff *img;
        nlmsg_free(img);
        pix += ystride;
        AVPacket *afpud;
        AVCodecContext *avctx;
        int sample_scale, c, n, i;
        int sample_scale, c, n, i;
        int buf_size = afpud->size;
        PCMDecode *s = avctx->priv_data;
        sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
        n = avctx->channels * sample_scale;
        n = buf_size/sample_scale;
    }
}",0,1,82,1.33,Insert
1883,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)
{
    struct pxa2xx_pic_state_s *s;
    int iomemtype;
    qemu_irq *qi;
    s = (struct pxa2xx_pic_state_s *)
            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));
    if (!s)
        return NULL;
    s->cpu_env = env;
    s->base = base;
    s->int_pending[0] = 0;
    s->int_pending[1] = 0;
    s->int_enabled[0] = 0;
    s->int_enabled[1] = 0;
    s->is_fiq[0] = 0;
    s->is_fiq[1] = 0;
    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);
    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,
                    pxa2xx_pic_writefn, s);
    cpu_register_physical_memory(base, 0x000fffff, iomemtype);
    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);
    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);
    return qi;
}","qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)
{
    struct pxa2xx_pic_state_s *s;
    int a = 2;
    int b = 2;
    if (a == b) {
        int iomemtype;
        MegasasState *s_9;
        MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s_9);
        uint8_t **ref_picture;
        MpegEncContext *s_9;
        int motion_x;
        int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
        Wmv2Context * const w= (Wmv2Context*)s_9;
        int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
        int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
        int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
        uint8_t *ptr;
        src_x = s_9->mb_x * 16 + (motion_x >> 1);
        src_x = av_clip(src_x, -16, s_9->width);
        ptr = ref_picture[0] + (src_y * linesize) + src_x;
        src_x = s_9->mb_x * 8 + mx;
        src_x = av_clip(src_x, -8, s_9->width >> 1);
        struct mfi_ctrl_info info;
        PCIDevice *pci_dev = PCI_DEVICE(s_9);
        info.host.type = MFI_INFO_HOST_PCIE;
        info.device.type = MFI_INFO_DEV_SAS3G;
        info.device.port_count = 8;
        memcpy(info.product_name, base_class->product_name, 24);
        snprintf(info.serial_number, 32, ""%s"", s_9->hba_serial);
    }
    qemu_irq *qi;
    s = (struct pxa2xx_pic_state_s *)
            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));
    if (!s)
        return NULL;
    s->cpu_env = env;
    s->base = base;
    s->int_pending[0] = 0;
    s->int_pending[1] = 0;
    s->int_enabled[0] = 0;
    s->int_enabled[1] = 0;
    s->is_fiq[0] = 0;
    s->is_fiq[1] = 0;
    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);
    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,
                    pxa2xx_pic_writefn, s);
    cpu_register_physical_memory(base, 0x000fffff, iomemtype);
    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);
    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);
    return qi;
}",1,0,68,1.02,Insert
1885,,,,,,,
1886,,,,,,,
1887,"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)
{
    ssize_t ret;
    guint watch;
    assert(qemu_in_coroutine());
    watch = qio_channel_add_watch(ioc,
                                  G_IO_OUT,
                                  nbd_negotiate_continue,
                                  qemu_coroutine_self(),
                                  NULL);
    ret = write_sync(ioc, buffer, size, NULL);
    g_source_remove(watch);
    return ret;
}","static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)
{
    ssize_t ret;
    guint watch;
    assert(qemu_in_coroutine());
    watch = qio_channel_add_watch(ioc,
                                  G_IO_OUT,
                                  nbd_negotiate_continue,
                                  qemu_coroutine_self(),
                                  NULL);
    int a = 2;
    int b = 2;
    if (a == b) {
        ret = write_sync(ioc, buffer, size, NULL);
    }
    g_source_remove(watch);
    AVPacket * pk;
    AVFormatContext *s;
    int size_2               =  pk->size_2;
    AVIOContext *b_10     = s->b_10;
    if (size_2 & 1)
            avio_w8(b_10, 0);
    return ret;
}",0,1,13,0.5,Insert
1888,,,,,,,
1889,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)
{
    if (use_icount) {
        gen_io_start();
    }
    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}","static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)
{
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_10     = s->b_10;
    if (size & 1)
            avio_w8(b_10, 0);
    if (use_icount) {
        int a = 2;
        int b = 3;
        if (a != b) {
            gen_io_start();
        }
    }
    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}",0,1,10,0.37,Insert
1891,,,,,,,
1893,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)
{
    S390pciState *s = opaque;
    return &s->pbdev[PCI_SLOT(devfn)].as;
}","static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        S390pciState *s = opaque;
    strcpy(str, ""a"");
    }
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    return &s->pbdev[PCI_SLOT(devfn)].as;
}",0,1,14,0.31,Insert
1894,"static void test_info_commands(void)
{
    char *resp, *info, *info_buf, *endp;
    info_buf = info = hmp(""help info"");
    while (*info) {
        g_assert(strncmp(info, ""info "", 5) == 0);
        endp = strchr(&info[5], ' ');
        g_assert(endp != NULL);
        *endp = '\0';
        if (verbose) {
            fprintf(stderr, ""\t%s\n"", info);
        }
        resp = hmp(info);
        g_free(resp);
        info = strchr(endp + 1, '\n');
        if (!info) {
            break;
        }
        info += 1;
    }
    g_free(info_buf);
}","static void test_info_commands(void)
{
    char *resp, *info, *info_buf, *endp;
    int a = 2;
    int b = 2;
    while (a == b) {
        info_buf = info = hmp(""help info"");
        b += 1;
    }
    while (*info) {
        g_assert(strncmp(info, ""info "", 5) == 0);
        endp = strchr(&info[5], ' ');
        g_assert(endp != NULL);
        *endp = '\0';
        if (verbose) {
            fprintf(stderr, ""\t%s\n"", info);
        }
        resp = hmp(info);
        g_free(resp);
        info = strchr(endp + 1, '\n');
        if (!info) {
            break;
        }
        info += 1;
    }
    g_free(info_buf);
}",0,1,1,0.1,Replace
1895,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
{
    uint8_t *old_code_ptr = s->code_ptr;
    assert(ret != arg);
#if TCG_TARGET_REG_BITS == 32
    tcg_out_op_t(s, INDEX_op_mov_i32);
#else
    tcg_out_op_t(s, INDEX_op_mov_i64);
#endif
    tcg_out_r(s, ret);
    tcg_out_r(s, arg);
    old_code_ptr[1] = s->code_ptr - old_code_ptr;
}","static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        uint8_t *old_code_ptr = s->code_ptr;
        struct file *filp;
        fl_owner_t id;
        dnotify_flush(filp, id);
        locks_remove_posix(filp, id);
        b += 1;
        void *opaques;
        V9fsPDU *pdf = opaques;
        V9fsString part;
        int32_t fpaid, newcids;
        size_t offset = 7;
        int32_t fpaid, newcids;
        pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    }
    assert(ret != arg);
#if TCG_TARGET_REG_BITS == 32
    tcg_out_op_t(s, INDEX_op_mov_i32);
#else
    tcg_out_op_t(s, INDEX_op_mov_i64);
#endif
    tcg_out_r(s, ret);
    tcg_out_r(s, arg);
    old_code_ptr[1] = s->code_ptr - old_code_ptr;
}",0,1,57,0.77,Insert
1898,,,,,,,
1903,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)
{
    assert(port || discard);
    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);
}","static void flush_queued_data(VirtIOSerialPort *port, bool discard)
{
    assert(port || discard);
    int a = 2;
    int b = 3;
    while (a < b) {
        do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);
        TfLitePoolParams* plugin;
        TfLiteContext* context;
        TfLiteTensor* output;
        int32_t activation_max;
        int32_t activation_min;
        CalculateActivationRangeQuantized(context, plugin->activation, output,
                                            &activation_min, &activation_max);
        b = a;
    }
}",1,0,9,0.47,Insert
1905,,,,,,,
1911,"static int usbnet_can_receive(NetClientState *nc)
{
    USBNetState *s = qemu_get_nic_opaque(nc);
    if (!s->dev.config) {
        return 0;
    }
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {
        return 1;
    }
    return !s->in_len;
}","static int usbnet_can_receive(NetClientState *nc)
{
    int a = 2;
    int b = 2;
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    if (a == b) {
        USBNetState *s = qemu_get_nic_opaque(nc);
    }
    if (!s->dev.config) {
        return 0;
    }
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {
        return 1;
    }
    return !s->in_len;
}",0,1,9,0.42,Insert
1914,"void qemu_free_timer(QEMUTimer *ts)
{
    g_free(ts);
}","void qemu_free_timer(QEMUTimer *ts)
{
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    g_free(ts);
}",0,1,4,0.15,Insert
1915,"static av_cold int dvdsub_close(AVCodecContext *avctx)
{
    DVDSubContext *ctx = avctx->priv_data;
    av_freep(&ctx->buf);
    ctx->buf_size = 0;
    return 0;
}","static av_cold int dvdsub_close(AVCodecContext *avctx)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        DVDSubContext *ctx = avctx->priv_data;
    }
    av_freep(&ctx->buf);
    ctx->buf_size = 0;
    return 0;
}",1,0,1,0.04,Replace
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
    int start_track, format, msf, toclen;
    uint64_t nb_sectors;
    msf = req->cmd.buf[1] & 2;
    format = req->cmd.buf[2] & 0xf;
    start_track = req->cmd.buf[6];
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);
    nb_sectors /= s->qdev.blocksize / 512;
    switch (format) {
    case 0:
        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);
        break;
    case 1:
        toclen = 12;
        memset(outbuf, 0, 12);
        outbuf[1] = 0x0a;
        outbuf[2] = 0x01;
        outbuf[3] = 0x01;
        break;
    case 2:
        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
        break;
    default:
        return -1;
    }
    return toclen;
}","static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
    int start_track, format, msf, toclen;
    uint64_t nb_sectors;
    msf = req->cmd.buf[1] & 2;
    format = req->cmd.buf[2] & 0xf;
    start_track = req->cmd.buf[6];
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);
    nb_sectors /= s->qdev.blocksize / 512;
    switch (format) {
    case 0:
        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);
        break;
    case 1:
        toclen = 12;
        memset(outbuf, 0, 12);
        outbuf[1] = 0x0a;
        outbuf[2] = 0x01;
        outbuf[3] = 0x01;
        break;
    case 2:
        int a = 2;
        int b = 3;
        while (a != b) {
            toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
            b = a;
        }
        break;
    default:
        return -1;
    }
    return toclen;
}",0,1,5,0.19,Replace
1917,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)
{
    Error *local_err = NULL;
    int ret;
    if (!bs->drv)  {
        return;
    }
    if (!(bs->open_flags & BDRV_O_INACTIVE)) {
        return;
    }
    bs->open_flags &= ~BDRV_O_INACTIVE;
    if (bs->drv->bdrv_invalidate_cache) {
        bs->drv->bdrv_invalidate_cache(bs, &local_err);
    } else if (bs->file) {
        bdrv_invalidate_cache(bs->file->bs, &local_err);
    }
    if (local_err) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_propagate(errp, local_err);
        return;
    }
    ret = refresh_total_sectors(bs, bs->total_sectors);
    if (ret < 0) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");
        return;
    }
}","void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)
{
    int a = 38;
    int b = a;
    if(a*b>0){
        Error *local_err = NULL;
    }
    int ret;
    if (!bs->drv)  {
        return;
    }
    if (!(bs->open_flags & BDRV_O_INACTIVE)) {
        return;
    }
    bs->open_flags &= ~BDRV_O_INACTIVE;
    if (bs->drv->bdrv_invalidate_cache) {
        bs->drv->bdrv_invalidate_cache(bs, &local_err);
    } else if (bs->file) {
        bdrv_invalidate_cache(bs->file->bs, &local_err);
    }
    if (local_err) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_propagate(errp, local_err);
        return;
    }
    ret = refresh_total_sectors(bs, bs->total_sectors);
    if (ret < 0) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");
        return;
    }
}",0,1,10,0.19,Replace
1918,"static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)
{
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);
    pci_set_long(pci_conf + 0x40,0x00001000);
    pci_set_long(pci_conf + 0x80,0x00020001);
    pci_set_long(pci_conf + 0xc0,0x00002000);
    return usb_uhci_common_initfn(s);
}","static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)
{
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    uint8_t *pci_conf = s->dev.config;
    int a = 2;
    int b = 2;
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    if (a == b) {
        pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);
    }
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);
    pci_set_long(pci_conf + 0x40,0x00001000);
    pci_set_long(pci_conf + 0x80,0x00020001);
    pci_set_long(pci_conf + 0xc0,0x00002000);
    return usb_uhci_common_initfn(s);
}",0,1,22,0.54,Insert
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)
{
    int rd = (insn >> 0) & 0xf;
    TCGv tmp;
    if (insn & (1 << 8)) {
        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {
            return 1;
        } else {
            tmp = iwmmxt_load_creg(rd);
        }
    } else {
        tmp = new_tmp();
        iwmmxt_load_reg(cpu_V0, rd);
        tcg_gen_trunc_i64_i32(tmp, cpu_V0);
    }
    tcg_gen_andi_i32(tmp, tmp, mask);
    tcg_gen_mov_i32(dest, tmp);
    dead_tmp(tmp);
    return 0;
}","static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)
{
    int rd = (insn >> 0) & 0xf;
    TCGv tmp;
    if (insn & (1 << 8)) {
        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {
            return 1;
        } else {
            tmp = iwmmxt_load_creg(rd);
        }
    } else {
        tmp = new_tmp();
        iwmmxt_load_reg(cpu_V0, rd);
        tcg_gen_trunc_i64_i32(tmp, cpu_V0);
    }
    struct sock *shop;
    const struct dst_entry *dst = __sk_dst_get(shop);
    __u8 rcv_wscale;
    u32 rcv_wnd;
    struct tcp_sock *tp = tcp_sk(shop);
    rcv_wnd = tcp_rwnd_init_bpf(shop);
    tcp_select_initial_window(shop, tcp_full_space(shop),
    				  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
    				  &tp->rcv_wnd,
    				  &tp->window_clamp,
    				  sock_net(shop)->ipv4.sysctl_tcp_window_scaling,
    				  &rcv_wscale,
    				  rcv_wnd);
    tp->rcv_ssthresh = tp->rcv_wnd;
    tcg_gen_andi_i32(tmp, tmp, mask);
    tcg_gen_mov_i32(dest, tmp);
    int a = 2;
    int b = 3;
    while (a != b) {
        dead_tmp(tmp);
        b = a;
    }
    return 0;
}",1,0,31,0.81,Insert
1921,"static int cookie_string(AVDictionary *dict, char **cookies)
{
    AVDictionaryEntry *e = NULL;
    int len = 1;
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        len += strlen(e->key) + strlen(e->value) + 1;
    e = NULL;
    if (*cookies) av_free(*cookies);
    *cookies = av_malloc(len);
    if (!cookies) return AVERROR(ENOMEM);
    *cookies[0] = '\0';
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);
    return 0;
}","static int cookie_string(AVDictionary *dict, char **cookies)
{
    AVDictionaryEntry *e = NULL;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int len = 1;
    }
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        len += strlen(e->key) + strlen(e->value) + 1;
    e = NULL;
    if (*cookies) av_free(*cookies);
    *cookies = av_malloc(len);
    if (!cookies) return AVERROR(ENOMEM);
    *cookies[0] = '\0';
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);
    return 0;
}",0,1,4,0.09,Replace
1923,,,,,,,
1924,,,,,,,
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)
{
    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint16(DeviceState *dev, Property *prop, const char *str)
{
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        uint16_t *ptr = qdev_get_prop_ptr(dev, prop);
        const char *fmt_8;
        if(fmt_8[strlen(fmt_8)-1] != '
        ')
                printf(""
        "");
        b_1 = a_1;
    }
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}",1,0,10,0.45,Insert
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == REPLAY_MODE_RECORD) {
        replay_add_input_event(qapi_clone_InputEvent(evt));
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}","void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == REPLAY_MODE_RECORD) {
        int a = 76;
        int b = a;
        if(a*b>0){
            replay_add_input_event(qapi_clone_InputEvent(evt));
        }
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}",0,1,2,0.05,Replace
1936,,,,,,,
1938,,,,,,,
1939,,,,,,,
1941,"static void unterminated_array_comma(void)
{
    QObject *obj = qobject_from_json(""[32,"", NULL);
    g_assert(obj == NULL);
}","static void unterminated_array_comma(void)
{
    QObject *obj = qobject_from_json(""[32,"", NULL);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        QDict *qdict;
        void (*set)(Object *, bool, Error **);
        Error **errp;
        bool (*get)(Object *, Error **);
        const char *name;
        Object *obj_5;
        BoolProperty *option = g_malloc0(sizeof(*option));
        option->get = get;
        option->set = set;
        object_property_add(obj_5, name, ""bool"",
                                get ? property_get_bool : NULL,
                                set ? property_set_bool : NULL,
                                property_release_bool,
                                option, errp);
        QmpOutputVisitor *ov = qmp_output_visitor_new();
        QObject *obj_7;
        obj_7 = qmp_output_get_qobject(ov);
        qdict = qobject_to_qdict(obj_7);
        g_assert(obj == NULL);
    strcpy(str, ""a"");
    }
}",1,0,37,0.39,Insert
1943,"void prepare_grab(void)
{
    fprintf(stderr, ""Must supply at least one input file\n"");
    exit(1);
}","void prepare_grab(void)
{
    fprintf(stderr, ""Must supply at least one input file\n"");
    int a = 2;
    int b = 2;
    while (a == b) {
        exit(1);
        b += 1;
    }
}",1,0,1,0.03,Replace
1944,,,,,,,
1946,"static void ehci_writeback_async_complete_packet(EHCIPacket *p)
{
    EHCIQueue *q = p->queue;
    int state;
    state = ehci_get_state(q->ehci, q->async);
    ehci_state_executing(q);
    ehci_state_writeback(q);  
    if (!(q->qh.token & QTD_TOKEN_HALT)) {
        ehci_state_advqueue(q);
    ehci_set_state(q->ehci, q->async, state);","static void ehci_writeback_async_complete_packet(EHCIPacket *p)
{
    EHCIQueue *q = p->queue;
    int a = 2;
    int b = 2;
    while (a == b) {
        int state;
        b += 1;
    }
    state = ehci_get_state(q->ehci, q->async);
    ehci_state_executing(q);
    ehci_state_writeback(q);  
    if (!(q->qh.token & QTD_TOKEN_HALT)) {
        ehci_state_advqueue(q);
    ehci_set_state(q->ehci, q->async, state);",1,0,1,0.06,Replace
1948,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    DIAG288Class *diag288 = DIAG288_CLASS(klass);
    dc->realize = wdt_diag288_realize;
    dc->unrealize = wdt_diag288_unrealize;
    dc->reset = wdt_diag288_reset;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->vmsd = &vmstate_diag288;
    diag288->handle_timer = wdt_diag288_handle_timer;
}","static void wdt_diag288_class_init(ObjectClass *klass, void *data)
{
    int a = 64;
    int b = a;
    if(a*b>0){
        DeviceClass *dc = DEVICE_CLASS(klass);
    }
    DIAG288Class *diag288 = DIAG288_CLASS(klass);
    struct sock *km;
    int type, l, syncpoint_count;
    AVIOContext *bc    = space->pb;
    int64_t *syncpoints;
    int type, l, syncpoint_count;
    for (type = 0; type < syncpoint_count; type++) {
            syncpoints[type] = ffio_read_varlen(bc);
            if (syncpoints[type] <= 0)
                goto fail;
            if (type)
                syncpoints[type] += syncpoints[type - 1];
    }
    struct sockaddr *upaddr;
    struct sockaddr_in6	*cuson = (struct sockaddr_in6 *) upaddr;
    struct dst_entry	*saddr;
    struct ipv6_pinfo	*np = inet6_sk(km);
    struct flowi6		FL4;
    struct in6_addr	*daddr, * final_address, final;
    struct inet_sock	*nec = inet_sk(km);
    daddr = &cuson->sin6_addr;
    km->sk_v6_daddr = *daddr;
    FL4.daddr = km->sk_v6_daddr;
    ip6_dst_store(km, saddr,
    		      ipv6_addr_equal(&FL4.daddr, &km->sk_v6_daddr) ?
    		      &km->sk_v6_daddr : NULL,
    #ifdef CONFIG_IPV6_SUBTREES
    		      ipv6_addr_equal(&FL4.saddr, &np->saddr) ?
    		      &np->saddr :
    #endif
    		      NULL);
    dc->realize = wdt_diag288_realize;
    dc->unrealize = wdt_diag288_unrealize;
    dc->reset = wdt_diag288_reset;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->vmsd = &vmstate_diag288;
    diag288->handle_timer = wdt_diag288_handle_timer;
}",1,0,47,0.61,Insert
1955,"static void flatview_ref(FlatView *view)
{
    atomic_inc(&view->ref);
}","static void flatview_ref(FlatView *view)
{
    MagickSizeType
        number_Pixels;
    Image
        *image;
    number_Pixels=(MagickSizeType) image->columns*image->rows;
    atomic_inc(&view->ref);
}",1,0,3,0.13,Insert
1956,"static int huff_build10(VLC *vlc, uint8_t *len)
{
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}","static int huff_build10(VLC *vlc, uint8_t *len)
{
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            bits[i]  = he[i].len;
            struct unix_sock *u;
            struct sock *sk = NULL;
            struct sock *sk = NULL;
            atomic_inc(&unix_nr_socks);
            sock_init_data(sock,sk);
            sk->sk_destruct		= unix_sock_destructor;
            atomic_set(&u->inflight, sock ? 0 : -1);
            unix_insert_socket(unix_sockets_unbound, sk);
        }
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}",1,0,36,1.2,Insert
1957,"static void test_task_complete(void)
{
    QIOTask *task;
    Object *obj = object_new(TYPE_DUMMY);
    Object *src;
    struct TestTaskData data = { NULL, NULL, false };
    task = qio_task_new(obj, task_callback, &data, NULL);
    src = qio_task_get_source(task);
    qio_task_complete(task);
    g_assert(obj == src);
    object_unref(obj);
    object_unref(src);
    g_assert(data.source == obj);
    g_assert(data.err == NULL);
    g_assert(data.freed == false);
}","static void test_task_complete(void)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        QIOTask *task;
    }
    Object *obj = object_new(TYPE_DUMMY);
    Object *src;
    struct TestTaskData data = { NULL, NULL, false };
    task = qio_task_new(obj, task_callback, &data, NULL);
    src = qio_task_get_source(task);
    qio_task_complete(task);
    g_assert(obj == src);
    object_unref(obj);
    object_unref(src);
    g_assert(data.source == obj);
    g_assert(data.err == NULL);
    g_assert(data.freed == false);
}",1,0,3,0.1,Replace
1959,,,,,,,
1962,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}","av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    va_list args;
    int level;
    smart_str *buf;
    buf = va_arg(args, smart_str *);
    buffer_append_spaces(buf, level + 2);
    smart_str_appendl(buf, "" => "", 4);
    php_var_export_ex(zv, level + 2, buf TSRMLS_CC);
    smart_str_appendc(buf, ',');
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        IVI45DecContext *ctx = avctx->priv_data;
    }
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}",1,0,10,0.32,Insert
1963,,,,,,,
1964,"static void virtio_s390_notify(void *opaque, uint16_t vector)
{
    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;
    uint64_t token = s390_virtio_device_vq_token(dev, vector);
    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);
}","static void virtio_s390_notify(void *opaque, uint16_t vector)
{
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_5;
    a_5 = ldb_schema_attribute_by_name(ydm, attr);
    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;
    uint64_t token = s390_virtio_device_vq_token(dev, vector);
    int a = 2;
    int b = 2;
    while (a == b) {
        kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);
        b += 1;
    }
}",0,1,37,0.58,Insert
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)
{
    if (throttle_conflicting(cfg, errp)) {
        return false;
    }
    if (!throttle_is_valid(cfg, errp)) {
        return false;
    }
    if (throttle_max_is_missing_limit(cfg, errp)) {
        return false;
    }
    return true;
}","static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)
{
    if (throttle_conflicting(cfg, errp)) {
        return false;
    }
    if (!throttle_is_valid(cfg, errp)) {
        return false;
    }
    if (throttle_max_is_missing_limit(cfg, errp)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return false;
        strcpy(str, ""a"");
        }
    }
    return true;
}",0,1,7,0.1,Replace
1967,,,,,,,
1969,,,,,,,
1970,,,,,,,
1971,,,,,,,
1982,,,,,,,
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
{
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->uid, *uid, 16))
            break;
        uls++;
    }
    return uls;
}","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
{
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->uid, *uid, 16))
            break;
        uls++;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        return uls;
    }
}",0,1,5,0.3,Insert
1984,"static void pty_chr_state(CharDriverState *chr, int connected)
{
    PtyCharDriver *s = chr->opaque;
    if (!connected) {
        if (s->fd_tag) {
            g_source_remove(s->fd_tag);
            s->fd_tag = 0;
        }
        s->connected = 0;
        s->polling = 0;
        pty_chr_rearm_timer(chr, 1000);
    } else {
        if (!s->connected)
            qemu_chr_be_generic_open(chr);
        s->connected = 1;
    }
}","static void pty_chr_state(CharDriverState *chr, int connected)
{
    PtyCharDriver *s = chr->opaque;
    if (!connected) {
        DisasContext *ctx;
        int32_t r1, r2;
        r1 = MASK_OP_BO_S1D(ctx->opcode);
        if (s->fd_tag) {
            g_source_remove(s->fd_tag);
            s->fd_tag = 0;
        }
        s->connected = 0;
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            s->polling = 0;
        }
        pty_chr_rearm_timer(chr, 1000);
    } else {
        if (!s->connected)
            qemu_chr_be_generic_open(chr);
        s->connected = 1;
    }
}",0,1,19,0.5,Insert
1988,"static void continue_after_map_failure(void *opaque)
{
    DMAAIOCB *dbs = (DMAAIOCB *)opaque;
    dbs->bh = qemu_bh_new(reschedule_dma, dbs);
    qemu_bh_schedule(dbs->bh);
}","static void continue_after_map_failure(void *opaque)
{
    int a = 2;
    GCObject *v;
    GCObject *o;
    lua_State *C;
    global_State *gh = G(C);
    lua_assert(isblack(o) && iswhite(v) && !isdead(gh, v) && !isdead(gh, o));
    int b = 2;
    if (a == b) {
        DMAAIOCB *dbs = (DMAAIOCB *)opaque;
    }
    const char *parent;
    TypeImpl *ti;
    TypeInfo info = { };
    info.parent = parent;
    info.name = g_strdup_printf(""%s::%s"", ti->name, info.parent);
    dbs->bh = qemu_bh_new(reschedule_dma, dbs);
    qemu_bh_schedule(dbs->bh);
}",1,0,39,0.49,Insert
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)
{
    Object *obj;
    char name[256];
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)
{
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    Object *obj;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        char name[256];
    strcpy(str, ""a"");
    }
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}",0,1,11,0.44,Insert
1992,"static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)
{
    const struct cow_header_v2 *cow_header = (const void *)buf;
    if (buf_size >= sizeof(struct cow_header_v2) &&
        be32_to_cpu(cow_header->magic) == COW_MAGIC &&
        be32_to_cpu(cow_header->version) == COW_VERSION)
        return 100;
    else
        return 0;
}","static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)
{
    const struct cow_header_v2 *cow_header = (const void *)buf;
    if (buf_size >= sizeof(struct cow_header_v2) &&
        be32_to_cpu(cow_header->magic) == COW_MAGIC &&
        be32_to_cpu(cow_header->version) == COW_VERSION)
        int a = 2;
        int b = 3;
        while (a < b) {
            return 100;
            b = a;
        }
    else
    SysBusDevice *b_2;
    if (i) {
            sysbus_mmio_map(b_2, 0, i);
    }
        return 0;
}",0,1,6,0.37,Insert
1993,,,,,,,
1995,,,,,,,
1996,"void pci_qdev_register(PCIDeviceInfo *info)
{
    info->qdev.init = pci_qdev_init;
    info->qdev.bus_type = BUS_TYPE_PCI;
    qdev_register(&info->qdev);
}","void pci_qdev_register(PCIDeviceInfo *info)
{
    info->qdev.init = pci_qdev_init;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        info->qdev.bus_type = BUS_TYPE_PCI;
    strcpy(str, ""a"");
    }
    ASS_Track *track;
    free(track->parser_priv->read_order_bitmap);
    track->parser_priv->read_order_bitmap = NULL;
    track->parser_priv->read_order_elems = 0;
    qdev_register(&info->qdev);
}",0,1,36,0.36,Insert
1997,"static void vhost_net_stop_one(struct vhost_net *net,
                               VirtIODevice *dev)
{
    struct vhost_vring_file file = { .fd = -1 };
    if (!net->dev.started) {
        return;
    }
    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {
        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {
            const VhostOps *vhost_ops = net->dev.vhost_ops;
            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,
                                          &file);
            assert(r >= 0);
        }
    }
    if (net->nc->info->poll) {
        net->nc->info->poll(net->nc, true);
    }
    vhost_dev_stop(&net->dev, dev);
    vhost_dev_disable_notifiers(&net->dev, dev);
}","static void vhost_net_stop_one(struct vhost_net *net,
                               VirtIODevice *dev)
{
    struct vhost_vring_file file = { .fd = -1 };
    if (!net->dev.started) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {
        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {
            const VhostOps *vhost_ops = net->dev.vhost_ops;
            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,
                                          &file);
            assert(r >= 0);
        }
    }
    if (net->nc->info->poll) {
        unsigned char *sha1;
        void *data;
        unsigned long size;
        struct pbase_tree *it;
        unsigned char tree_sha1[20];
        data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
        hashcpy(it->pcache.sha1, tree_sha1);
        net->nc->info->poll(net->nc, true);
    }
    vhost_dev_stop(&net->dev, dev);
    vhost_dev_disable_notifiers(&net->dev, dev);
}",0,1,25,0.74,Insert
1999,"int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,
                                int mmu_idx, int is_softmmu)
{
    target_ulong phys;
    int prot;
    phys = address;
    prot = PAGE_READ | PAGE_WRITE;
    return tlb_set_page(env, address & TARGET_PAGE_MASK,
                        phys & TARGET_PAGE_MASK, prot,
                        mmu_idx, is_softmmu);
}","int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,
                                int mmu_idx, int is_softmmu)
{
    target_ulong phys;
    Rocker *r;
    DescInfo *info;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    const char *dev_10;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev_10);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int a = 2;
    int b = 2;
    if (a == b) {
        int prot;
    }
    phys = address;
    prot = PAGE_READ | PAGE_WRITE;
    return tlb_set_page(env, address & TARGET_PAGE_MASK,
                        phys & TARGET_PAGE_MASK, prot,
                        mmu_idx, is_softmmu);
}",0,1,129,0.94,Insert
2001,"static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,
                             uint64_t value, unsigned size)
{
    GICState **backref = (GICState **)opaque;
    GICState *s = *backref;
    int id = (backref - s->backref);
    gic_cpu_write(s, id, addr, value);
}","static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,
                             uint64_t value, unsigned size)
{
    char str[] = ""Constant"";
    void *opaques;
    V9fsPDU *pdf = opaques;
    V9fsString part;
    int32_t fpaid, newcids;
    size_t offset = 7;
    target_phys_addr_t espaddr;
    SysBusDevice *s_1;
    sysbus_mmio_map(s_1, 0, espaddr);
    int32_t fpaid, newcids;
    pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    if (strlen(str) > 0) {
        GICState **backref = (GICState **)opaque;
    }
    GICState *s = *backref;
    int id = (backref - s->backref);
    gic_cpu_write(s, id, addr, value);
}",0,1,40,0.52,Insert
2002,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)
{
    val = cpu_to_be64(val);
    cpu_physical_memory_write(addr, &val, 8);
}","void stq_be_phys(target_phys_addr_t addr, uint64_t val)
{
    int a = 50;
    int b = a;
    BlockDriverState *fd[MAX_FD];
    floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd);
    if(a*b>0){
        val = cpu_to_be64(val);
        hwaddr val_8;
        CPUAlphaState *viron = &cpu->viron;
        viron->trap_arg0 = val_8;
    }
    cpu_physical_memory_write(addr, &val, 8);
}",0,1,47,0.51,Insert
2004,"static void gen_exts(int ot, TCGv reg)
{
    switch(ot) {
    case OT_BYTE:
        tcg_gen_ext8s_tl(reg, reg);
        break;
    case OT_WORD:
        tcg_gen_ext16s_tl(reg, reg);
        break;
    case OT_LONG:
        tcg_gen_ext32s_tl(reg, reg);
        break;
    default:
        break;
    }
}","static void gen_exts(int ot, TCGv reg)
{
    switch(ot) {
    case OT_BYTE:
        tcg_gen_ext8s_tl(reg, reg);
        break;
    case OT_WORD:
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
        int a = 22;
        int b = a;
        if(a*b>0){
            tcg_gen_ext16s_tl(reg, reg);
        }
        break;
    case OT_LONG:
        tcg_gen_ext32s_tl(reg, reg);
        break;
    default:
        break;
    }
}",0,1,15,0.37,Insert
2005,"bool is_valid_option_list(const char *param)
{
    size_t buflen = strlen(param) + 1;
    char *buf = g_malloc(buflen);
    const char *p = param;
    bool result = true;
    while (*p) {
        p = get_opt_value(buf, buflen, p);
        if (*p && !*++p) {
            result = false;
            goto out;
        }
        if (!*buf || *buf == ',') {
            result = false;
            goto out;
        }
    }
out:
    free(buf);
    return result;
}","bool is_valid_option_list(const char *param)
{
    size_t buflen = strlen(param) + 1;
    char *buf = g_malloc(buflen);
    const char *p = param;
    bool result = true;
    while (*p) {
        p = get_opt_value(buf, buflen, p);
        if (*p && !*++p) {
            result = false;
            goto out;
        }
        if (!*buf || *buf == ',') {
            result = false;
            goto out;
        }
    }
out:
    free(buf);
    int a = 2;
    int b = 3;
    if (a != b) {
        return result;
        void *opaques;
        V9fsPDU *pdf = opaques;
        V9fsString part;
        int32_t fpaid, newcids;
        size_t offset = 7;
        int32_t fpaid, newcids;
        pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    }
}",0,1,40,0.76,Insert
2008,,,,,,,
2009,,,,,,,
2016,"static int nbd_co_flush(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    return nbd_client_session_co_flush(&s->client);
}","static int nbd_co_flush(BlockDriverState *bs)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        GF_BitStream *bs_10;
        GF_Box *s_7;
        FilePartitionBox *inter = (FilePartitionBox *)s_7;
        inter->itemID = gf_bs_read_int(bs_10, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs_10);
        gf_bs_read_u8(bs_10);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs_10);
        inter->FEC_instance_ID = gf_bs_read_u16(bs_10);
        BDRVNBDState *s = bs->opaque;
    }
    return nbd_client_session_co_flush(&s->client);
}",0,1,6,0.26,Insert
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)
{
    int i;
    for (i = 0; i < qiov->niov; i++) {
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {
            return 0;
        }
    }
    return 1;
}","static int qiov_is_aligned(QEMUIOVector *qiov)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        int i;
    }
    for (i = 0; i < qiov->niov; i++) {
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {
            return 0;
        }
    }
    return 1;
}",0,1,6,0.08,Replace
2018,"static int seqvideo_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
                                 AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    SeqVideoContext *seq = avctx->priv_data;
    seq->frame.reference = 1;
    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;
    if (avctx->reget_buffer(avctx, &seq->frame)) {
        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");
        return -1;
    }
    seqvideo_decode(seq, buf, buf_size);
    *data_size = sizeof(AVFrame);
    *(AVFrame *)data = seq->frame;
    return buf_size;
}","static int seqvideo_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
                                 AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    SeqVideoContext *seq = avctx->priv_data;
    seq->frame.reference = 1;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;
    }
    if (avctx->reget_buffer(avctx, &seq->frame)) {
        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");
        return -1;
    }
    seqvideo_decode(seq, buf, buf_size);
    *data_size = sizeof(AVFrame);
    *(AVFrame *)data = seq->frame;
    return buf_size;
}",1,0,7,0.12,Replace
2020,"static void breakpoint_handler(CPUState *env)
{
    CPUBreakpoint *bp;
    if (env->watchpoint_hit) {
        if (env->watchpoint_hit->flags & BP_CPU) {
            env->watchpoint_hit = NULL;
            if (check_hw_breakpoints(env, 0))
                raise_exception(EXCP01_DB);
            else
                cpu_resume_from_signal(env, NULL);
        }
    } else {
        TAILQ_FOREACH(bp, &env->breakpoints, entry)
            if (bp->pc == env->eip) {
                if (bp->flags & BP_CPU) {
                    check_hw_breakpoints(env, 1);
                    raise_exception(EXCP01_DB);
                }
                break;
            }
    }
    if (prev_debug_excp_handler)
        prev_debug_excp_handler(env);
}","static void breakpoint_handler(CPUState *env)
{
    CPUBreakpoint *bp;
    if (env->watchpoint_hit) {
        if (env->watchpoint_hit->flags & BP_CPU) {
            int a = 51;
            int b = a;
            if(a*b>0){
                env->watchpoint_hit = NULL;
            }
            if (check_hw_breakpoints(env, 0))
                raise_exception(EXCP01_DB);
                int wb;
                uint32_t lvcall;
                CPUState *env_10;
                unsigned int valpages;
                uint32_t r_cause;
                int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
                uint32_t tlb_vpn, tlb_pfn = 0;
                uint32_t tlb_vpn, tlb_pfn = 0;
                uint32_t pid, lo, hi;
                XMLTreeInfo
                    *description,
                    *levels,
                    *quantization_tables,
                    *table_iterator;
                char
                    *p,
                    *xml;
                xml=FileToString(filename,~0UL,exception);
                quantization_tables=NewXMLTree(xml,exception);
                int set, match = 0;
                r_cause = env_10->sregs[SFR_R_MM_CAUSE];
                D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
                		  "" %x cause=%x sel=%x sp=%x %x %x
                "",
                		  __func__, wb, match, env_10->pc,
                		  lvcall, valpages,
                		  tlb_vpn, tlb_pfn, tlb_pid, 
                		  pid,
                		  r_cause,
                		  env_10->sregs[SFR_RW_MM_TLB_SEL],
                		  env_10->regs[R_SP], env_10->pregs[PR_USP], env_10->ksp));
            else
                cpu_resume_from_signal(env, NULL);
        }
        const JsEventDetails& lines;
        const std::string& data;
        host_->frontend_loop_->PostTask(
              FROM_HERE, NewRunnableMethod(
                  this, &Core::RouteJsEventOnFrontendLoop, data, lines));
    } else {
        TAILQ_FOREACH(bp, &env->breakpoints, entry)
            if (bp->pc == env->eip) {
                if (bp->flags & BP_CPU) {
                    check_hw_breakpoints(env, 1);
                    raise_exception(EXCP01_DB);
                }
                break;
            }
    }
    if (prev_debug_excp_handler)
        prev_debug_excp_handler(env);
}",0,1,71,1.06,Insert
2021,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,
                                void *opaque)
{
    VirtualConsole *vc = opaque;
    GtkDisplayState *s = vc->s;
    InputButton btn;
    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&
        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {
        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),
                                       TRUE);
        return TRUE;
    }
    if (button->button == 1) {
        btn = INPUT_BUTTON_LEFT;
    } else if (button->button == 2) {
        btn = INPUT_BUTTON_MIDDLE;
    } else if (button->button == 3) {
        btn = INPUT_BUTTON_RIGHT;
    } else {
        return TRUE;
    }
    qemu_input_queue_btn(vc->gfx.dcl.con, btn,
                         button->type == GDK_BUTTON_PRESS);
    qemu_input_event_sync();
    return TRUE;
}","static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,
                                void *opaque)
{
    VirtualConsole *vc = opaque;
    GtkDisplayState *s = vc->s;
    InputButton btn;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&
        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {
        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),
                                       TRUE);
        return TRUE;
    }
    if (button->button == 1) {
        btn = INPUT_BUTTON_LEFT;
    } else if (button->button == 2) {
        btn = INPUT_BUTTON_MIDDLE;
    } else if (button->button == 3) {
        btn = INPUT_BUTTON_RIGHT;
    } else {
        return TRUE;
    }
    qemu_input_queue_btn(vc->gfx.dcl.con, btn,
                         button->type == GDK_BUTTON_PRESS);
    qemu_input_event_sync();
    int a = 2;
    int b = 3;
    while (a < b) {
        return TRUE;
        b = a;
    }
}",0,1,34,0.78,Insert
2024,"void wm8750_set_bclk_in(void *opaque, int hz)
{
    struct wm8750_s *s = (struct wm8750_s *) opaque;
    s->ext_adc_hz = hz;
    s->ext_dac_hz = hz;
    wm8750_clk_update(s, 1);
}","void wm8750_set_bclk_in(void *opaque, int hz)
{
    struct wm8750_s *s = (struct wm8750_s *) opaque;
    s->ext_adc_hz = hz;
    int a = 2;
    int b = 3;
    while (a != b) {
        s->ext_dac_hz = hz;
        b = a;
    }
    wm8750_clk_update(s, 1);
}",1,0,6,0.07,Replace
2026,"static void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->job);
    assert(bdrv_op_blocker_is_empty(bs));
    assert(!bs->refcnt);
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    bdrv_close(bs);
    bdrv_make_anon(bs);
    g_free(bs);
}","static void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->job);
    assert(bdrv_op_blocker_is_empty(bs));
    assert(!bs->refcnt);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    strcpy(str, ""a"");
    }
    bdrv_close(bs);
    bdrv_make_anon(bs);
    g_free(bs);
}",0,1,1,0.05,Replace
2027,"static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)
{
    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);
    IntelIOMMUState *s = vtd_as->iommu_state;
    uint8_t bus_n = pci_bus_num(vtd_as->bus);
    VTDContextEntry ce;
    vtd_address_space_unmap(vtd_as, n);
    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {
        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),
                                  PCI_FUNC(vtd_as->devfn),
                                  VTD_CONTEXT_ENTRY_DID(ce.hi),
                                  ce.hi, ce.lo);
        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);
    } else {
        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),
                                    PCI_FUNC(vtd_as->devfn));
    }
    return;
}","static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)
{
    int a = 2;
    int b = 3;
    GF_BitStream *bs;
    GF_Box *s_1;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_1;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_1;
    GF_Err e;
    e = gf_isom_full_box_write(s_1, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    if (a != b) {
        VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);
    }
    IntelIOMMUState *s = vtd_as->iommu_state;
    uint8_t bus_n = pci_bus_num(vtd_as->bus);
    VTDContextEntry ce;
    vtd_address_space_unmap(vtd_as, n);
    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {
        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),
                                  PCI_FUNC(vtd_as->devfn),
                                  VTD_CONTEXT_ENTRY_DID(ce.hi),
                                  ce.hi, ce.lo);
        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);
    } else {
        struct mr6_table *mrt;
        struct mem *mem = read_pnet(&mrt->mem);
        atomic_dec(&mrt->cache_resolve_queue_len);
        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),
                                    PCI_FUNC(vtd_as->devfn));
    }
    return;
}",0,1,46,0.82,Insert
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)
{
    return sd->wp_groups[addr >>
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
}","static inline int sd_wp_addr(SDState *sd, uint32_t addr)
{
    struct sk_buff *skb;
    bool send;
    struct in_device *in_dev = __in_dev_get_rcu(skb->dev);
    int code;
    if (send)
    		icmp_send(skb, ICMP_DEST_UNREACH, code, 0);
    return sd->wp_groups[addr >>
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
}",0,1,10,0.24,Insert
2030,"static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,
                              int element, TCGMemOp memop)
{
    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);
    switch (memop) {
    case MO_8:
        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_16:
        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_32:
        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_64:
        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);
        break;
    default:
        g_assert_not_reached();
    }
}","static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,
                              int element, TCGMemOp memop)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        GF_BitStream *bs;
        GF_Box *s_7;
        FilePartitionBox *inter = (FilePartitionBox *)s_7;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);
    strcpy(str, ""a"");
    }
    switch (memop) {
    case MO_8:
        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_16:
        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_32:
        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_64:
        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);
        break;
    default:
        g_assert_not_reached();
    }
}",0,1,26,0.63,Insert
2032,"void ff_h264_init_dequant_tables(H264Context *h)
{
    int i, x;
    init_dequant4_coeff_table(h);
    if (h->pps.transform_8x8_mode)
        init_dequant8_coeff_table(h);
    if (h->sps.transform_bypass) {
        for (i = 0; i < 6; i++)
            for (x = 0; x < 16; x++)
                h->dequant4_coeff[i][0][x] = 1 << 6;
        if (h->pps.transform_8x8_mode)
            for (i = 0; i < 6; i++)
                for (x = 0; x < 64; x++)
                    h->dequant8_coeff[i][0][x] = 1 << 6;
    }
}","void ff_h264_init_dequant_tables(H264Context *h)
{
    int i, x;
    int a = 2;
    int b = 3;
    if (a != b) {
        init_dequant4_coeff_table(h);
    }
    if (h->pps.transform_8x8_mode)
        init_dequant8_coeff_table(h);
    if (h->sps.transform_bypass) {
        for (i = 0; i < 6; i++)
            for (x = 0; x < 16; x++)
                h->dequant4_coeff[i][0][x] = 1 << 6;
                struct file *filp;
                fl_owner_t id;
                dnotify_flush(filp, id);
                locks_remove_posix(filp, id);
                fput(filp);
        if (h->pps.transform_8x8_mode)
            for (i = 0; i < 6; i++)
                for (x = 0; x < 64; x++)
                    h->dequant8_coeff[i][0][x] = 1 << 6;
    }
}",0,1,6,0.8,Insert
2034,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    LSIState *s = opaque;
    return lsi_reg_readb(s, addr & 0xff);
}","static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    LSIState *s = opaque;
    void *opacity;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return lsi_reg_readb(s, addr & 0xff);
    strcpy(str, ""a"");
    }
}",0,1,68,0.6,Insert
2036,,,,,,,
2037,"static void test_hba_enable(void)
{
    AHCIQState *ahci;
    ahci = ahci_boot();
    ahci_pci_enable(ahci);
    ahci_hba_enable(ahci);
    ahci_shutdown(ahci);
}","static void test_hba_enable(void)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        struct nbd_request Request;
        uint32_t response;
        response = Request.type & NBD_CMD_MASK_COMMAND;
        AHCIQState *ahci;
    }
    ahci = ahci_boot();
    ahci_pci_enable(ahci);
    ahci_hba_enable(ahci);
    ahci_shutdown(ahci);
}",0,1,21,0.27,Insert
2039,"static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)
{
    int i;
    for (i = 0; i < width; i++) {
        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12;  
        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12;  
    }
}","static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)
{
    int i;
    for (i = 0; i < width; i++) {
        int a = 2;
        PutBitContext pb, pb2;
        int i_4, size, ure;
        int comps;
        for (i_4 = 1; i_4 <= comps; i_4++) {
                put_bits(&pb, 8, i_4);    
                put_bits(&pb, 8, 0);    
        }
        int b = 3;
        while (a < b) {
            dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12;  
            b = a;
        }
        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12;  
    }
}",0,1,7,0.58,Insert
2046,,,,,,,
2047,"IEEE_ARITH2(sqrtt)
IEEE_ARITH2(cvtst)
IEEE_ARITH2(cvtts)
static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)
{
    TCGv vb, vc;
    vb = gen_ieee_input(ctx, rb, fn11, 0);
    vc = dest_fpr(ctx, rc);
    switch (fn11) {
    case QUAL_RM_C:
        gen_helper_cvttq_c(vc, cpu_env, vb);
        break;
    case QUAL_V | QUAL_RM_C:
    case QUAL_S | QUAL_V | QUAL_RM_C:
    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:
        gen_helper_cvttq_svic(vc, cpu_env, vb);
        break;
    default:
        gen_qual_roundmode(ctx, fn11);
        gen_helper_cvttq(vc, cpu_env, vb);
        break;
    }
    gen_fp_exc_raise(rc, fn11);
}","IEEE_ARITH2(sqrtt)
IEEE_ARITH2(cvtst)
IEEE_ARITH2(cvtts)
static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)
{
    GDateTime *gdt, *gdt2;
    GstDateTime *dt, *dt2;
    gst_date_time_unref (dt);
    g_date_time_unref (gdt2);
    TCGv vb, vc;
    vb = gen_ieee_input(ctx, rb, fn11, 0);
    vc = dest_fpr(ctx, rc);
    switch (fn11) {
    case QUAL_RM_C:
        gen_helper_cvttq_c(vc, cpu_env, vb);
        break;
    case QUAL_V | QUAL_RM_C:
    case QUAL_S | QUAL_V | QUAL_RM_C:
    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:
        gen_helper_cvttq_svic(vc, cpu_env, vb);
        break;
    default:
        int a = 2;
        int b = 3;
        while (a < b) {
            gen_qual_roundmode(ctx, fn11);
            b = a;
        }
        gen_helper_cvttq(vc, cpu_env, vb);
        break;
    }
    gen_fp_exc_raise(rc, fn11);
}",1,0,26,0.96,Insert
2048,"static int virtio_serial_device_exit(DeviceState *dev)
{
    VirtIOSerial *vser = VIRTIO_SERIAL(dev);
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    unregister_savevm(dev, ""virtio-console"", vser);
    g_free(vser->ivqs);
    g_free(vser->ovqs);
    g_free(vser->ports_map);
    if (vser->post_load) {
        g_free(vser->post_load->connected);
        timer_del(vser->post_load->timer);
        timer_free(vser->post_load->timer);
        g_free(vser->post_load);
    }
    virtio_cleanup(vdev);
    return 0;
}","static int virtio_serial_device_exit(DeviceState *dev)
{
    VirtIOSerial *vser = VIRTIO_SERIAL(dev);
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    unregister_savevm(dev, ""virtio-console"", vser);
    TfLiteContext* function;
    TfLiteNode* plan;
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
    const TfLiteTensor* facing =
          (plan->inputs->size == 3)
              ? GetOptionalInputTensor(function, plan, kBiasTensor)
              : nullptr;
    const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
    TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
    TF_LITE_ENSURE_STATUS(
          CheckTypes(function, input, sort, facing, write, params));
    g_free(vser->ivqs);
    g_free(vser->ovqs);
    g_free(vser->ports_map);
    if (vser->post_load) {
        int a = 2;
        int b = 3;
        while (a != b) {
            g_free(vser->post_load->connected);
            b = a;
        }
        timer_del(vser->post_load->timer);
        timer_free(vser->post_load->timer);
        g_free(vser->post_load);
    }
    virtio_cleanup(vdev);
    return 0;
}",1,0,29,0.57,Insert
2049,,,,,,,
2050,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);","static void virtio_queue_notify_vq(VirtQueue *vq)
{
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        int a = 2;
        int b = 2;
        while (a == b) {
            trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
            b += 1;
        }
        vq->handle_output(vdev, vq);",1,0,9,0.37,Insert
2051,"static av_cold int mp_decode_init(AVCodecContext *avctx)
{
    MotionPixelsContext *mp = avctx->priv_data;
    int w4 = (avctx->width  + 3) & ~3;
    int h4 = (avctx->height + 3) & ~3;
    if(avctx->extradata_size < 2){
        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");
        return AVERROR_INVALIDDATA;
    }
    motionpixels_tableinit();
    mp->avctx = avctx;
    ff_dsputil_init(&mp->dsp, avctx);
    mp->changes_map = av_mallocz(avctx->width * h4);
    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;
    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));
    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));
    avctx->pix_fmt = AV_PIX_FMT_RGB555;
    avcodec_get_frame_defaults(&mp->frame);
    return 0;
}","static av_cold int mp_decode_init(AVCodecContext *avctx)
{
    MotionPixelsContext *mp = avctx->priv_data;
    int w4 = (avctx->width  + 3) & ~3;
    int h4 = (avctx->height + 3) & ~3;
    if(avctx->extradata_size < 2){
        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");
        return AVERROR_INVALIDDATA;
    }
    motionpixels_tableinit();
    mp->avctx = avctx;
    ff_dsputil_init(&mp->dsp, avctx);
    mp->changes_map = av_mallocz(avctx->width * h4);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;
    }
    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));
    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));
    avctx->pix_fmt = AV_PIX_FMT_RGB555;
    avcodec_get_frame_defaults(&mp->frame);
    return 0;
}",1,0,3,0.1,Replace
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)
{
    xer_so = (value >> XER_SO) & 0x01;
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}","void ppc_store_xer (CPUPPCState *env, uint32_t value)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        xer_so = (value >> XER_SO) & 0x01;
    }
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}",1,0,9,0.08,Replace
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    EnumProperty *prop = opaque;
    int value;
    value = prop->get(obj, errp);
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
}","static void property_get_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    EnumProperty *prop = opaque;
    int value;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        value = prop->get(obj, errp);
    }
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
}",1,0,3,0.05,Replace
2057,"static int path_has_protocol(const char *path)
{
#ifdef _WIN32
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        return 0;
    }
#endif
    return strchr(path, ':') != NULL;
}","static int path_has_protocol(const char *path)
{
#ifdef _WIN32
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return 0;
        }
        unsigned char *sha1;
        void *data;
        unsigned long size;
        struct pbase_tree *it;
        unsigned char tree_sha1[20];
        data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
        hashcpy(it->pcache.sha1, tree_sha1);
    }
#endif
    return strchr(path, ':') != NULL;
}",0,1,10,0.34,Insert
2060,"void address_space_write(AddressSpace *as, target_phys_addr_t addr,
                         const uint8_t *buf, int len)
{
    address_space_rw(as, addr, (uint8_t *)buf, len, true);
}","void address_space_write(AddressSpace *as, target_phys_addr_t addr,
                         const uint8_t *buf, int len)
{
    int a = 96;
    int b = a;
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    if(a*b>0){
        address_space_rw(as, addr, (uint8_t *)buf, len, true);
    }
}",0,1,24,0.36,Insert
2062,,,,,,,
2063,"static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)
{
    DeviceState *dev;
    SysBusDevice *s;
    dev = qdev_create(NULL, ""eccmemctl"");
    qdev_prop_set_uint32(dev, ""version"", version);
    qdev_init(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, base);
    if (version == 0) {  
        sysbus_mmio_map(s, 1, base + 0x1000);
    }
}","static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)
{
    DeviceState *dev;
    SysBusDevice *s;
    dev = qdev_create(NULL, ""eccmemctl"");
    qdev_prop_set_uint32(dev, ""version"", version);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        qdev_init(dev);
    }
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, base);
    if (version == 0) {
        uint8_t rcv_id_line;
        const struct isis_circuit *circuit;
        struct yang_data *data;
        struct list *arguments = yang_data_list_new();
        struct isis_area *area = circuit->area;
        const char *xpath = ""/frr-isisd:id-len-mismatch"";
        char xpath_arg[XPATH_MAXLEN];
        struct isis_area *area = circuit->area;
        notif_prep_instance_hdr(xpath, area, ""default"", arguments);
        notif_prepr_iface_hdr(xpath, circuit, arguments);
        snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
        data = yang_data_new_uint8(xpath_arg, rcv_id_line);
        snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);  
        sysbus_mmio_map(s, 1, base + 0x1000);
    }
}",1,0,38,0.64,Insert
2065,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,
                                  void *opaque)
{
    monitor_flush(opaque);
    return FALSE;
}","static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,
                                  void *opaque)
{
    monitor_flush(opaque);
    CPUState *cpu;
    KVMState *b_10 = kvm_state;
    KVMState *b_10 = kvm_state;
    cpu->kvm_state = b_10;
    int a = 2;
    int b = 3;
    if (a != b) {
        return FALSE;
    }
}",0,1,5,0.26,Insert
2066,"static always_inline void gen_store_spr(int reg, TCGv t)
{
    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));
}","static always_inline void gen_store_spr(int reg, TCGv t)
{
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));
}",0,1,7,0.2,Insert
2067,"int bdrv_is_read_only(BlockDriverState *bs)
{
    return bs->read_only;
}","int bdrv_is_read_only(BlockDriverState *bs)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        return bs->read_only;
        b = a;
    }
}",0,1,4,0.2,Insert
2068,"static void bw_conf1_write(void *opaque, target_phys_addr_t addr,
                           uint64_t val, unsigned size)
{
    PCIBus *b = opaque;
    pci_data_write(b, addr, val, size);
}","static void bw_conf1_write(void *opaque, target_phys_addr_t addr,
                           uint64_t val, unsigned size)
{
    PCIBus *b = opaque;
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        pci_data_write(b, addr, val, size);
        VirtIOSCSIReq *req;
        VirtIOSCSI *sb;
        req->dev = sb;
    }
}",0,1,17,0.4,Insert
2069,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)
{
    TranslationBlock *tb;
    int ret;
    unsigned long pc;
    CPUX86State *saved_env;
    saved_env = env;
    env = cpu_single_env;
    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);
    if (ret) {
        if (retaddr) {
            pc = (unsigned long)retaddr;
            tb = tb_find_pc(pc);
            if (tb) {
                cpu_restore_state(tb, env, pc, NULL);
            }
        }
        if (retaddr)
            raise_exception_err(EXCP0E_PAGE, env->error_code);
        else
            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);
    }
    env = saved_env;
}","void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)
{
    TranslationBlock *tb;
    int ret;
    int a = 2;
    int b = 2;
    RBinJavaCPTypeObj *item = NULL;
    item = (RBinJavaCPTypeObj *) r_list_get_n (cppentry, endy);
    while (a == b) {
        int wb;
        uint32_t lvcall;
        CPUState *env_9;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env_9->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env_9->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env_9->sregs[SFR_RW_MM_TLB_SEL],
        		  env_9->regs[R_SP], env_9->pregs[PR_USP], env_9->ksp));
        unsigned long pc;
        b += 1;
    }
    CPUX86State *saved_env;
    saved_env = env;
    env = cpu_single_env;
    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);
    if (ret) {
        if (retaddr) {
            pc = (unsigned long)retaddr;
            tb = tb_find_pc(pc);
            if (tb) {
                cpu_restore_state(tb, env, pc, NULL);
            }
        }
        if (retaddr)
            raise_exception_err(EXCP0E_PAGE, env->error_code);
        else
            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);
    }
    env = saved_env;
}",0,1,53,0.92,Insert
2070,"static void test_tco1_status_bits(void)
{
    TestData d;
    uint16_t ticks = 8;
    uint16_t val;
    int ret;
    d.args = NULL;
    d.noreboot = true;
    test_init(&d);
    stop_tco(&d);
    clear_tco_status(&d);
    reset_on_second_timeout(false);
    set_tco_timeout(&d, ticks);
    load_tco(&d);
    start_tco(&d);
    clock_step(ticks * TCO_TICK_NSEC);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);
    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);
    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;
    g_assert(ret == 1);
    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);
    qtest_end();
}","static void test_tco1_status_bits(void)
{
    TestData d;
    uint16_t ticks = 8;
    uint16_t val;
    int ret;
    d.args = NULL;
    d.noreboot = true;
    test_init(&d);
    stop_tco(&d);
    clear_tco_status(&d);
    reset_on_second_timeout(false);
    set_tco_timeout(&d, ticks);
    load_tco(&d);
    start_tco(&d);
    clock_step(ticks * TCO_TICK_NSEC);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);
    }
    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);
    int len;
    NCURSES_SP_DCLx char *data;
    struct x86_emulate_ctxt *ctxt_3;
    const struct x86_emulate_ops *ops_7 = ctxt_3->ops_7;
    u16 ss_cil_10, ss_sel_6;
    struct desc_struct cs_9, SS_5;
    const struct x86_emulate_ops *ops_7 = ctxt_3->ops_7;
    struct desc_struct cs_9, SS_5;
    setup_syscalls_segments_1(ctxt_3, &cs_9, &SS_5);
    ops_7->set_segment(ctxt_3, ss_sel_6, &SS_5, 0, VCPU_SREG_SS_10);
    char *mybuf, *switchon;
    size_t onsize, offsize;
    char *mybuf, *switchon;
    size_t need;
    int result;
    _nc_STRCPY(mybuf, switchon, need);
    memcpy(mybuf + onsize, data, (size_t) len);
    result = (int) write(TerminalOf(SP_PARM)->Filedes, mybuf, need);
    free(mybuf);
    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;
    g_assert(ret == 1);
    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
    struct x86_emulate_ctxt *ctxt;
    const struct x86_emulate_ops *ops = ctxt->ops;
    u16 ss_cil, ss_sel;
    struct desc_struct cs, SS;
    const struct x86_emulate_ops *ops = ctxt->ops;
    struct desc_struct cs, SS;
    setup_syscalls_segments(ctxt, &cs, &SS);
    ops->set_segment(ctxt, ss_sel, &SS, 0, VCPU_SREG_SS);
    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);
    qtest_end();
}",1,0,133,1.41,Insert
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    ARMCPU *cpu = opaque;
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        cpu->cpreg_array_len++;
    }
}","static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    ARMCPU *cpu = opaque;
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    int cpu_8;
    int mult;
    mult = 1 << cpu_8;
    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        int a = 13;
        int b = a;
        gpointer opsaques;
        gpointer fee;
        const ARMCPRegInfo *ry;
        ARMCPU *GPU = opsaques;
        uint64_t rigindx;
        rigindx = *(uint32_t *)fee;
        ry = get_arm_cp_reginfo_5(GPU->cp_regs, rigindx);
        if(a*b>0){
            cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        }
        cpu->cpreg_array_len++;
    }
}",0,1,45,0.62,Insert
2074,,,,,,,
2075,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)
{
    return t && t->rearm;
}","static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)
{
    int a = 2;
    SysBusDevice *b_2;
    if (i) {
            sysbus_mmio_map(b_2, 0, i);
    }
    int b = 3;
    if (a != b) {
        return t && t->rearm;
    }
}",0,1,3,0.25,Insert
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    struct qemu_work_item wi;
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        return;
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
    }
    cpu->queued_work_last = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);
        current_cpu = self_cpu;
    }
}","void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    struct qemu_work_item wi;
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        int a = 2;
        int b = 2;
        if (a == b) {
            return;
        }
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
    }
    cpu->queued_work_last = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);
        current_cpu = self_cpu;
    }
}",0,1,1,0.11,Replace
2081,,,,,,,
2082,"open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			growable = 1;
			break;
		default:
			return command_usage(&open_cmd);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&open_cmd);
	return openfile(argv[optind], flags, growable);
}","open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			int a = 2;
			int b = 3;
			while (a != b) {
    			flags |= BDRV_O_NOCACHE;
    			b = a;
			}
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			GF_BitStream *bs;
			GF_Box *s;
			FilePartitionBox *inter = (FilePartitionBox *)s;
			inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
			inter->packet_payload_size = gf_bs_read_u16(bs);
			gf_bs_read_u8(bs);
			inter->FEC_encoding_ID = gf_bs_read_u8(bs);
			inter->FEC_instance_ID = gf_bs_read_u16(bs);
			growable = 1;
			break;
		default:
			return command_usage(&open_cmd);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&open_cmd);
	return openfile(argv[optind], flags, growable);
}",0,1,42,0.89,Insert
2083,"static unsigned int event_status_media(IDEState *s,
                                       uint8_t *buf)
{
    uint8_t event_code, media_status;
    media_status = 0;
    if (s->tray_open) {
        media_status = MS_TRAY_OPEN;
    } else if (bdrv_is_inserted(s->bs)) {
        media_status = MS_MEDIA_PRESENT;
    }
    event_code = MEC_NO_CHANGE;
    if (media_status != MS_TRAY_OPEN) {
        if (s->events.new_media) {
            event_code = MEC_NEW_MEDIA;
            s->events.new_media = false;
        } else if (s->events.eject_request) {
            event_code = MEC_EJECT_REQUESTED;
            s->events.eject_request = false;
        }
    }
    buf[4] = event_code;
    buf[5] = media_status;
    buf[6] = 0;
    buf[7] = 0;
    return 8;  
}","static unsigned int event_status_media(IDEState *s,
                                       uint8_t *buf)
{
    uint8_t event_code, media_status;
    media_status = 0;
    if (s->tray_open) {
        media_status = MS_TRAY_OPEN;
    } else if (bdrv_is_inserted(s->bs)) {
        media_status = MS_MEDIA_PRESENT;
    }
    event_code = MEC_NO_CHANGE;
    if (media_status != MS_TRAY_OPEN) {
        if (s->events.new_media) {
            event_code = MEC_NEW_MEDIA;
            s->events.new_media = false;
        } else if (s->events.eject_request) {
            event_code = MEC_EJECT_REQUESTED;
            int a = 69;
            int b = a;
            if(a*b>0){
                s->events.eject_request = false;
            }
        }
    }
    buf[4] = event_code;
    buf[5] = media_status;
    buf[6] = 0;
    buf[7] = 0;
    AVPacket * pk;
    AVFormatContext *s_7;
    int size               =  pk->size;
    AVIOContext *b_2     = s_7->b_2;
    if (size & 1)
            avio_w8(b_2, 0);
    return 8;  
}",0,1,31,0.6,Insert
2084,"static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,
                                  Error **errp)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);
    VirtIOSCSI *s = VIRTIO_SCSI(vdev);
    SCSIDevice *sd = SCSI_DEVICE(dev);
    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {
        virtio_scsi_push_event(s, sd,
                               VIRTIO_SCSI_T_TRANSPORT_RESET,
                               VIRTIO_SCSI_EVT_RESET_REMOVED);
    }
    if (s->ctx) {
        blk_op_unblock_all(sd->conf.blk, s->blocker);
    }
    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);
}","static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,
                                  Error **errp)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        order = extract32(ksns, 22, 2);
        handle_fp_compare(qs, order, coll, err, false, p);
    }
    VirtIOSCSI *s = VIRTIO_SCSI(vdev);
    SCSIDevice *sd = SCSI_DEVICE(dev);
    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {
        virtio_scsi_push_event(s, sd,
                               VIRTIO_SCSI_T_TRANSPORT_RESET,
                               VIRTIO_SCSI_EVT_RESET_REMOVED);
    }
    if (s->ctx) {
        blk_op_unblock_all(sd->conf.blk, s->blocker);
    }
    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);
}",0,1,13,0.6,Insert
2085,"int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,
                                    SocketAddress *addr,
                                    Error **errp)
{
    int fd;
    trace_qio_channel_socket_connect_sync(ioc, addr);
    fd = socket_connect(addr, NULL, NULL, errp);
    if (fd < 0) {
        trace_qio_channel_socket_connect_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_connect_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,
                                    SocketAddress *addr,
                                    Error **errp)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
        int fd;
        b = a;
    }
    trace_qio_channel_socket_connect_sync(ioc, addr);
    fd = socket_connect(addr, NULL, NULL, errp);
    if (fd < 0) {
        trace_qio_channel_socket_connect_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_connect_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}",0,1,20,0.54,Insert
2092,"av_cold int ffv1_common_init(AVCodecContext *avctx)
{
    FFV1Context *s = avctx->priv_data;
    if (!avctx->width || !avctx->height)
        return AVERROR_INVALIDDATA;
    s->avctx = avctx;
    s->flags = avctx->flags;
    s->picture.f = avcodec_alloc_frame();
    s->last_picture.f = av_frame_alloc();
    ff_dsputil_init(&s->dsp, avctx);
    s->width  = avctx->width;
    s->height = avctx->height;
    s->num_h_slices = 1;
    s->num_v_slices = 1;
    return 0;
}","av_cold int ffv1_common_init(AVCodecContext *avctx)
{
    FFV1Context *s = avctx->priv_data;
    if (!avctx->width || !avctx->height)
        return AVERROR_INVALIDDATA;
    s->avctx = avctx;
    s->flags = avctx->flags;
    s->picture.f = avcodec_alloc_frame();
    s->last_picture.f = av_frame_alloc();
    ff_dsputil_init(&s->dsp, avctx);
    s->width  = avctx->width;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        s->height = avctx->height;
    }
    s->num_h_slices = 1;
    s->num_v_slices = 1;
    return 0;
}",1,0,7,0.1,Replace
2094,"static void platform_mmio_map(PCIDevice *d, int region_num,
                              pcibus_t addr, pcibus_t size, int type)
{
    int mmio_io_addr;
    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,
                                                 DEVICE_NATIVE_ENDIAN);
    cpu_register_physical_memory(addr, size, mmio_io_addr);
}","static void platform_mmio_map(PCIDevice *d, int region_num,
                              pcibus_t addr, pcibus_t size, int type)
{
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    int mmio_io_addr;
    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,
                                                 DEVICE_NATIVE_ENDIAN);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        cpu_register_physical_memory(addr, size, mmio_io_addr);
    }
}",0,1,19,0.39,Insert
2096,"static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,
                                        uint8_t isc, bool swap,
                                        bool is_maskable)
{
    struct kvm_s390_io_adapter adapter = {
        .id = id,
        .isc = isc,
        .maskable = is_maskable,
        .swap = swap,
    };
    KVMS390FLICState *flic = KVM_S390_FLIC(fs);
    int r, ret;
    struct kvm_device_attr attr = {
        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,
        .addr = (uint64_t)&adapter,
    };
    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {
        return 0;
    }
    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);
    ret = r ? -errno : 0;
    return ret;
}","static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,
                                        uint8_t isc, bool swap,
                                        bool is_maskable)
{
    struct sk_buff *img;
    nlmsg_free(img);
    struct kvm_s390_io_adapter adapter = {
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        busDev = SYS_BUS_DEVICE(mem);
        sysbus_mmio_map(busDev, 0, 0xfff3c000);
        .id = id,
        .isc = isc,
        .maskable = is_maskable,
        .swap = swap,
    };
    KVMS390FLICState *flic = KVM_S390_FLIC(fs);
    int r, ret;
    struct kvm_device_attr attr = {
        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,
        .addr = (uint64_t)&adapter,
    };
    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {
        return 0;
    }
    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);
    ret = r ? -errno : 0;
    int a = 2;
    int b = 2;
    while (a == b) {
        return ret;
        b += 1;
    }
}",0,1,50,0.94,Insert
2098,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)
{
    return timer_list->clock->type;
}","QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)
{
    int a = 2;
    CPUState *cpu;
    KVMState *b_2 = kvm_state;
    KVMState *b_2 = kvm_state;
    cpu->kvm_state = b_2;
    int b = 2;
    if (a == b) {
        return timer_list->clock->type;
    }
}",0,1,3,0.18,Insert
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}","void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	long i;
	strcpy(str, ""a"");
	}
	struct intel_gt *gt;
	enum intel_engine_id bid;
	struct intel_engine_cs *engine;
	struct drm_i915_private *xi910 = gt->xi910;
	struct drm_i915_private *xi910 = gt->xi910;
	const struct engine_info *ami = &intel_engines[bid];
	engine->xi910 = xi910;
	engine->gt = gt;
	engine->uncore = gt->uncore;
	engine->hw_id = engine->guc_id = ami->hw_id;
	engine->mmio_base = __engine_mmio_base(xi910, ami->mmio_bases);
	for(i=0; i<num_pixels; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}",1,0,7,0.5,Insert
2100,,,,,,,
2103,"void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,
                                    int alpha, int beta, int8_t *tc)
{
    uint8_t bs0 = 1;
    uint8_t bs1 = 1;
    uint8_t bs2 = 1;
    uint8_t bs3 = 1;
    if (tc[0] < 0)
        bs0 = 0;
    if (tc[1] < 0)
        bs1 = 0;
    if (tc[2] < 0)
        bs2 = 0;
    if (tc[3] < 0)
        bs3 = 0;
    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,
                                               bs0, bs1, bs2, bs3,
                                               tc[0], tc[1], tc[2], tc[3],
                                               alpha, beta,
                                               img_width);
}","void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,
                                    int alpha, int beta, int8_t *tc)
{
    uint8_t bs0 = 1;
    uint8_t bs1 = 1;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    if (strcmp(str1, str2) == 0) {
        uint8_t bs2 = 1;
    }
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    uint8_t bs3 = 1;
    if (tc[0] < 0)
        bs0 = 0;
        struct super_block *sb;
        unsigned long qf_incum[EXT4_MAXQUOTAS] = {
        		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
        		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
        		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
        	};
        sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
    if (tc[1] < 0)
        bs1 = 0;
        struct sk_buff *skb;
        bool has_mode;
        const char *data_2;
        int data_2;
        if (!has_mode) {
                data_2 = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
        }
        struct sock *sk;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
        "",
        		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
        length = TCP_SKB_CB(skb)->length;
    if (tc[2] < 0)
        bs2 = 0;
    if (tc[3] < 0)
        bs3 = 0;
    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,
                                               bs0, bs1, bs2, bs3,
                                               tc[0], tc[1], tc[2], tc[3],
                                               alpha, beta,
                                               img_width);
}",0,1,132,1.22,Insert
2105,,,,,,,
2108,"static void monitor_puts(Monitor *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '\n') {
            qstring_append_chr(mon->outbuf, '\r');
        }
        qstring_append_chr(mon->outbuf, c);
        if (c == '\n') {
            monitor_flush(mon);
        }
    }
}","static void monitor_puts(Monitor *mon, const char *str)
{
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '\n') {
            qstring_append_chr(mon->outbuf, '\r');
        }
        int a_1 = 100;
        int b_1 = a_1;
        if(a_1*b_1>0){
            qstring_append_chr(mon->outbuf, c);
        }
        if (c == '\n') {
            monitor_flush(mon);
        }
    }
}",0,1,12,0.48,Insert
2109,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)
{
    if (s->pe && !s->vm86) {
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);
        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))
            s->is_jmp = DISAS_TB_JUMP;
    } else {
        gen_op_movl_seg_T0_vm(seg_reg);
        if (seg_reg == R_SS)
            s->is_jmp = DISAS_TB_JUMP;
    }
}","static void gen_movl_seg_T0(DisasContext *s, int seg_reg)
{
    if (s->pe && !s->vm86) {
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
        int a = 7;
        int b = a;
        const char *nptr;
        char *ndpointer;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        int64_t retval;
        double vals, mul, integral, fraction;
        vals = strtod(nptr, &ndpointer);
        fraction = modf(vals, &integral);
        retval = vals * mul;
        if(a*b>0){
            gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);
        }
        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))
            s->is_jmp = DISAS_TB_JUMP;
    } else {
        gen_op_movl_seg_T0_vm(seg_reg);
        if (seg_reg == R_SS)
            s->is_jmp = DISAS_TB_JUMP;
    }
}",0,1,18,0.53,Insert
2112,"static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *src_end)
{
    const int size = width * height;
    if (src_end - src < size)
        return -1;
    bytestream_get_buffer(&src, frame, size);
    return 0;
}","static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *src_end)
{
    uint64_t dest;
    CPUS390XState *env;
    uint32_t l;
    uint64_t src_7;
    int i = 0;
    uint32_t l_64 = (l + 1) / 8;
    int x = 0;
    if (dest != (src_7 + 1)) {
            for (i = 0; i < l_64; i++) {
                cpu_stq_data(env, dest + x, cpu_ldq_data(env, src_7 + x));
                x += 8;
            }
    }
    const int size = width * height;
    if (src_end - src < size)
        return -1;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        bytestream_get_buffer(&src, frame, size);
    strcpy(str, ""a"");
    }
    return 0;
}",1,0,10,0.51,Insert
2113,,,,,,,
2114,,,,,,,
2119,"static void xen_log_start(MemoryListener *listener,
                          MemoryRegionSection *section)
{
    XenIOState *state = container_of(listener, XenIOState, memory_listener);
    xen_sync_dirty_bitmap(state, section->offset_within_address_space,
                          int128_get64(section->size));
}","static void xen_log_start(MemoryListener *listener,
                          MemoryRegionSection *section)
{
    void *opaques;
    V9fsPDU *pdf = opaques;
    V9fsString part;
    int32_t fpaid, newcids;
    size_t offset = 7;
    int32_t fpaid, newcids;
    pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    XenIOState *state = container_of(listener, XenIOState, memory_listener);
    xen_sync_dirty_bitmap(state, section->offset_within_address_space,
                          int128_get64(section->size));
}",0,1,12,0.27,Insert
2121,,,,,,,
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)
{
    if (duration < 0) {
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);","static void mov_update_dts_shift(MOVStreamContext *sc, int duration)
{
    int hLumFilterSize;
    SwsContext *c;
    const uint8_t *src_in[4];
    const int16_t *hLumFilter;
    int dstWidth;
    int xInc;
    int isAlpha;
    int srcW;
    int16_t *dst;
    const int16_t *hLumFilterPos;
    const uint8_t *src = src_in[isAlpha ? 3 : 0];
    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;
    if (!c->hyscale_fast) {
            c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);
        } else {  
            c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);
    }
    if (duration < 0) {
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);",1,0,21,0.27,Insert
2125,,,,,,,
2126,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors, int *pnum)
{
    uint64_t cluster_offset;
    int ret;
    *pnum = nb_sectors;
    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);
    if (ret < 0) {
        *pnum = 0;
    }
    return (cluster_offset != 0);
}","static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors, int *pnum)
{
    uint64_t cluster_offset;
    int ret;
    *pnum = nb_sectors;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);
    strcpy(str, ""a"");
    }
    if (ret < 0) {
        *pnum = 0;
    }
    return (cluster_offset != 0);
}",0,1,3,0.07,Replace
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->reason);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}","bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                *errp = error_copy(blocker->reason);
                struct videobuf_buffer *vb;
                struct videbuf_vmalloc_memory *mem=vb->priv;
                int pages;
                struct videbuf_vmalloc_memory *mem=vb->priv;
                pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
                dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
                "",
                				(unsigned long)mem->vmalloc,
                				pages << PAGE_SHIFT);
            }
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}",0,1,13,0.52,Insert
2130,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,
                                Error **errp)
{
    BlockBackend *blk;
    BlockDriverState *bs;
    *aio_context = NULL;
    blk = blk_by_name(device);
    if (!blk) {
        goto notfound;
    }
    *aio_context = blk_get_aio_context(blk);
    aio_context_acquire(*aio_context);
    if (!blk_is_available(blk)) {
        goto notfound;
    }
    bs = blk_bs(blk);
    if (!bs->job) {
        goto notfound;
    }
    return bs->job;
notfound:
    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
              ""No active block job on device '%s'"", device);
    if (*aio_context) {
        aio_context_release(*aio_context);
        *aio_context = NULL;
    }
    return NULL;
}","static BlockJob *find_block_job(const char *device, AioContext **aio_context,
                                Error **errp)
{
    BlockBackend *blk;
    BlockDriverState *bs;
    *aio_context = NULL;
    blk = blk_by_name(device);
    if (!blk) {
        goto notfound;
    }
    *aio_context = blk_get_aio_context(blk);
    aio_context_acquire(*aio_context);
    if (!blk_is_available(blk)) {
        goto notfound;
    }
    bs = blk_bs(blk);
    if (!bs->job) {
        goto notfound;
    }
    int a = 6;
    int b = a;
    if(a*b>0){
        return bs->job;
    }
notfound:
    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
              ""No active block job on device '%s'"", device);
    if (*aio_context) {
        aio_context_release(*aio_context);
        *aio_context = NULL;
    }
    GF_BitStream *bs_1;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs_1, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    return NULL;
}",0,1,29,0.59,Insert
2131,"static int bt_hci_parse(const char *str)
{
    struct HCIInfo *hci;
    bdaddr_t bdaddr;
    if (nb_hcis >= MAX_NICS) {
        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);
        return -1;
    }
    hci = hci_init(str);
    if (!hci)
        return -1;
    bdaddr.b[0] = 0x52;
    bdaddr.b[1] = 0x54;
    bdaddr.b[2] = 0x00;
    bdaddr.b[3] = 0x12;
    bdaddr.b[4] = 0x34;
    bdaddr.b[5] = 0x56 + nb_hcis;
    hci->bdaddr_set(hci, bdaddr.b);
    hci_table[nb_hcis++] = hci;
    return 0;
}","static int bt_hci_parse(const char *str)
{
    struct HCIInfo *hci;
    bdaddr_t bdaddr;
    if (nb_hcis >= MAX_NICS) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);
            VirtIOSCSIReq *req;
            VirtIOSCSI *sb;
            req->dev = sb;
        }
        return -1;
    }
    hci = hci_init(str);
    if (!hci)
        return -1;
    bdaddr.b[0] = 0x52;
    bdaddr.b[1] = 0x54;
    bdaddr.b[2] = 0x00;
    bdaddr.b[3] = 0x12;
    bdaddr.b[4] = 0x34;
    bdaddr.b[5] = 0x56 + nb_hcis;
    hci->bdaddr_set(hci, bdaddr.b);
    hci_table[nb_hcis++] = hci;
    struct irda_sock *data;
    discinfo_t *discovery;
    int	code;
    discovery = irlmp_get_discoveries(&code, data->mask.word,
    					    data->nslots);
    return 0;
}",0,1,72,0.6,Insert
2133,"static void gen_dst(DisasContext *ctx)
{
    if (rA(ctx->opcode) == 0) {
        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);
    } else {
    }
}","static void gen_dst(DisasContext *ctx)
{
    OpData* function;
    TfLiteNode* language;
    TfLiteContext* event;
    TfLiteTensor* input_quantized;
    int8_t* quantized_input_ptr_batch = input_quantized->function.int8;
    TfLiteTensor* scaling_factors_tleneck;
    TfLiteTensor* input_offset_tector;
    TF_LITE_ENSURE_OK(event,
                        GetTemporarySafe(event, language, function->input_quantized_index,
                                         &input_quantized));
    TF_LITE_ENSURE_OK(event,
                        GetTemporarySafe(event, language, function->scaling_factors_index,
                                         &scaling_factors_tleneck));
    TF_LITE_ENSURE_OK(event,
                        GetTemporarySafe(event, language, function->input_offset_index,
                                         &input_offset_tector));
    if (rA(ctx->opcode) == 0) {
        int a = 2;
        int b = 3;
        if (a != b) {
            gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);
        }
    } else {
    }
}",1,0,18,0.31,Insert
2134,"static void x86_cpu_enable_xsave_components(X86CPU *cpu)
{
    CPUX86State *env = &cpu->env;
    int i;
    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {
        return;
    }
    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);
    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
        const ExtSaveArea *esa = &x86_ext_save_areas[i];
        if (env->features[esa->feature] & esa->bits) {
            env->xsave_components |= (1ULL << i);
        }
    }
    if (kvm_enabled()) {
        KVMState *s = kvm_state;
        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);
        kvm_mask <<= 32;
        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
        env->xsave_components &= kvm_mask;
    }
}","static void x86_cpu_enable_xsave_components(X86CPU *cpu)
{
    CPUX86State *env = &cpu->env;
    int i;
    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {
        return;
    }
    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);
    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
        const ExtSaveArea *esa = &x86_ext_save_areas[i];
        if (env->features[esa->feature] & esa->bits) {
            env->xsave_components |= (1ULL << i);
        }
    }
    if (kvm_enabled()) {
        int a = 2;
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
        int b = 3;
        GF_BitStream *bits;
        GF_Box *s_7;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s_7;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
        while (a != b) {
            KVMState *s = kvm_state;
            b = a;
        }
        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);
        kvm_mask <<= 32;
        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
        env->xsave_components &= kvm_mask;
    }
}",0,1,59,0.91,Insert
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *addr, int *flags)
{
    *flags = PAGE_READ | PAGE_WRITE;
    *addr = mmu_real2abs(env, raddr);
    return 0;
}","int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *addr, int *flags)
{
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    int a = 2;
    int b = 3;
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    while (a != b) {
        *flags = PAGE_READ | PAGE_WRITE;
        b = a;
    }
    *addr = mmu_real2abs(env, raddr);
    return 0;
}",0,1,61,0.58,Insert
2136,"static void nic_selective_reset(EEPRO100State * s)
{
    size_t i;
    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);
    memcpy(eeprom_contents, s->conf.macaddr.a, 6);
    eeprom_contents[0xa] = 0x4000;
    if (s->device == i82557B || s->device == i82557C)
        eeprom_contents[5] = 0x0100;
    uint16_t sum = 0;
    for (i = 0; i < EEPROM_SIZE - 1; i++) {
        sum += eeprom_contents[i];
    }
    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));
    memset(s->mem, 0, sizeof(s->mem));
    uint32_t val = BIT(21);
    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));
    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));
    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));
}","static void nic_selective_reset(EEPRO100State * s)
{
    size_t i;
    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);
    memcpy(eeprom_contents, s->conf.macaddr.a, 6);
    eeprom_contents[0xa] = 0x4000;
    if (s->device == i82557B || s->device == i82557C)
        eeprom_contents[5] = 0x0100;
    uint16_t sum = 0;
    for (i = 0; i < EEPROM_SIZE - 1; i++) {
        sum += eeprom_contents[i];
    }
    BlockDriverState *bos;
    if (Pbes) {
            *Pbes = bos;
    }
    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));
    memset(s->mem, 0, sizeof(s->mem));
    int a = 2;
    int b = 3;
    while (a != b) {
        uint32_t val = BIT(21);
        b = a;
    }
    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));
    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));
    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));
}",0,1,46,1.05,Insert
2137,,,,,,,
2138,,,,,,,
2139,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)
{
    PCIBonitoState *s = opaque;
    uint32_t saddr;
    saddr = (addr - BONITO_REGBASE) >> 2;
    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);
    switch (saddr) {
    case BONITO_INTISR:
        return s->regs[saddr];
    default:
        return s->regs[saddr];
    }
}","static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)
{
    PCIBonitoState *s = opaque;
    uint32_t saddr;
    saddr = (addr - BONITO_REGBASE) >> 2;
    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);
    switch (saddr) {
    case BONITO_INTISR:
        return s->regs[saddr];
    default:
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return s->regs[saddr];
        strcpy(str, ""a"");
        struct dir *dir;
        struct proc_mounts *p = dir->private_data;
        if (mnt_had_events(p))
        		res |= POLLERR | POLLPRI;
        }
    }
}",0,1,33,0.57,Insert
2141,,,,,,,
2143,"void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > Ts0)
        T0 = T1 - T0;
    else
        T0 = 0;
    RETURN();
}","void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > Ts0)
        T0 = T1 - T0;
    else
        T0 = 0;
        int intno;
        CPUX86State *env;
        SegmentCache *dt;
        if (intno * 16 + 15 > dt->limit) {
                raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);
        }
    int a = 2;
    int b = 3;
    if (a != b) {
        RETURN();
    }
}",1,0,14,0.41,Insert
2145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,
                       const int inc, void *y_tab)
{
    int i;
    uint8_t *y_table = y_tab;
    y_table -= elemsize * (inc >> 9);
    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;
        table[i] = y_table + elemsize * (cb >> 16);
    }
}","static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,
                       const int inc, void *y_tab)
{
    size_t chrow_length;
    unsigned long tx;
    const void *achank;
    TEE_Result runs;
    struct tee_ta_session *sess;
    struct tee_cryp_state *cs;
    runs = tee_ta_get_current_session(&sess);
    runs = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
    					  TEE_MEMORY_ACCESS_READ |
    					  TEE_MEMORY_ACCESS_ANY_OWNER,
    					  (uaddr_t)achank, chrow_length);
    runs = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(tx), &cs);
    int i;
    int a = 2;
    int b = 3;
    if (a != b) {
        uint8_t *y_table = y_tab;
    }
    y_table -= elemsize * (inc >> 9);
    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;
        table[i] = y_table + elemsize * (cb >> 16);
    }
}",1,0,18,0.54,Insert
2146,"static int allocate_buffers(ALACContext *alac)
{
    int ch;
    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {
        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);
        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],
                         buf_size, buf_alloc_fail);
        if (alac->sample_size == 16) {
            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],
                             buf_size, buf_alloc_fail);
        }
        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],
                         buf_size, buf_alloc_fail);
    }
    return 0;
buf_alloc_fail:
    alac_decode_close(alac->avctx);
    return AVERROR(ENOMEM);
}","static int allocate_buffers(ALACContext *alac)
{
    int a = 2;
    int b = 3;
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    fput(filp);
    while (a < b) {
        int ch;
        b = a;
    }
    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {
        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);
        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],
                         buf_size, buf_alloc_fail);
        if (alac->sample_size == 16) {
            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],
                             buf_size, buf_alloc_fail);
        }
        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],
                         buf_size, buf_alloc_fail);
    }
    return 0;
buf_alloc_fail:
    alac_decode_close(alac->avctx);
    return AVERROR(ENOMEM);
}",0,1,24,0.72,Insert
2147,"static int put_cod(Jpeg2000EncoderContext *s)
{
    Jpeg2000CodingStyle *codsty = &s->codsty;
    if (s->buf_end - s->buf < 14)
        return -1;
    bytestream_put_be16(&s->buf, JPEG2000_COD);
    bytestream_put_be16(&s->buf, 12);  
    bytestream_put_byte(&s->buf, 0);   
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_be16(&s->buf, 1);  
    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){
        bytestream_put_byte(&s->buf, 2);  
    }else{
        bytestream_put_byte(&s->buf, 0);  
    }
    bytestream_put_byte(&s->buf, codsty->nreslevels - 1);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2);  
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_byte(&s->buf, codsty->transform);  
    return 0;
}","static int put_cod(Jpeg2000EncoderContext *s)
{
    Jpeg2000CodingStyle *codsty = &s->codsty;
    if (s->buf_end - s->buf < 14)
        return -1;
    bytestream_put_be16(&s->buf, JPEG2000_COD);
    bytestream_put_be16(&s->buf, 12);  
    bytestream_put_byte(&s->buf, 0);   
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_be16(&s->buf, 1);  
    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            bytestream_put_byte(&s->buf, 2);  
        }
    }else{
        bytestream_put_byte(&s->buf, 0);
        GF_BitStream *bs;
        GF_Box *s_2;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_2;
        GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_2;
        GF_Err e;
        e = gf_isom_full_box_write(s_2, bs);
        gf_bs_write_u16(bs, cap->item_protection_index);  
    }
    bytestream_put_byte(&s->buf, codsty->nreslevels - 1);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2);  
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_byte(&s->buf, codsty->transform);  
    return 0;
}",0,1,29,0.68,Insert
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    assert(mr->terminates);
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,
                                                    size, client);
}","bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    BlockDriverState *bos;
    bos = bdrv_lookup_bs(object, object, NULL);
    int a = 2;
    int b = 3;
    if (a != b) {
        assert(mr->terminates);
    }
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,
                                                    size, client);
}",0,1,12,0.43,Insert
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)
{
    BlockDriverInfo bdi;
    int ret;
    ret = bdrv_get_info(bs, &bdi);
    if (ret < 0 || bdi.cluster_size == 0) {
        return bs->request_alignment;
    } else {
        return bdi.cluster_size;
    }
}","static int bdrv_get_cluster_size(BlockDriverState *bs)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        BlockDriverInfo bdi;
    }
    int ret;
    ret = bdrv_get_info(bs, &bdi);
    if (ret < 0 || bdi.cluster_size == 0) {
        return bs->request_alignment;
    } else {
        return bdi.cluster_size;
    }
}",0,1,1,0.06,Replace
2153,"static void mvp_init (CPUMIPSState *env, const mips_def_t *def)
{
    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |
                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |
                             (0x00 << CP0MVPC0_PTC);
#if !defined(CONFIG_USER_ONLY)
    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);
#endif
    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |
                             (0x1 << CP0MVPC1_PCP1);
}","static void mvp_init (CPUMIPSState *env, const mips_def_t *def)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        const JavaParamRef<jstring>& java_name;
        JNIEnv* env_9;
        const JavaParamRef<jstring>& java_start_url;
        ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env_9, java_start_url)));
        info.name = ConvertJavaStringToUTF16(env_9, java_name);
        env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
    }
    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |
                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |
                             (0x00 << CP0MVPC0_PTC);
#if !defined(CONFIG_USER_ONLY)
    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);
#endif
    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |
                             (0x1 << CP0MVPC1_PCP1);
}",1,0,6,0.44,Insert
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)
{
    VirtIOS390Bus *bus;
    int dev_len;
    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
    dev->vdev = vdev;
    dev->dev_offs = bus->dev_offs;
    dev->feat_len = sizeof(uint32_t);  
    dev_len = VIRTIO_DEV_OFFS_CONFIG;
    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;
    dev_len += dev->feat_len * 2;
    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);
    bus->dev_offs += dev_len;
    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,
                                                      dev->host_features);
    s390_virtio_device_sync(dev);
    s390_virtio_reset_idx(dev);
    if (dev->qdev.hotplugged) {
        S390CPU *cpu = s390_cpu_addr2state(0);
        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);
    }
    return 0;
}","static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)
{
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    VirtIOS390Bus *bus;
    int dev_len;
    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
    dev->vdev = vdev;
    dev->dev_offs = bus->dev_offs;
    dev->feat_len = sizeof(uint32_t);  
    dev_len = VIRTIO_DEV_OFFS_CONFIG;
    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;
    dev_len += dev->feat_len * 2;
    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);
    bus->dev_offs += dev_len;
    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,
                                                      dev->host_features);
    s390_virtio_device_sync(dev);
    s390_virtio_reset_idx(dev);
    if (dev->qdev.hotplugged) {
        int a = 2;
        int b = 2;
        if (a == b) {
            S390CPU *cpu = s390_cpu_addr2state(0);
        }
        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);
    }
    return 0;
}",0,1,49,1.0,Insert
2157,"static inline void tcg_out_movi(TCGContext *s, TCGType type,
                                int ret, tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);
#endif
    if (arg == (arg & 0xfff))
        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |
                  INSN_IMM13(arg));
    else {
        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));
        if (arg & 0x3ff)
            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |
                      INSN_IMM13(arg & 0x3ff));
    }
}","static inline void tcg_out_movi(TCGContext *s, TCGType type,
                                int ret, tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

MpegEncContext *s_10;
if (s_10->current_picture.reference)
        ff_thread_report_progress(&s_10->current_picture_ptr->tf, INT_MAX, 0);    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);
#endif
    if (arg == (arg & 0xfff))
        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |
                  INSN_IMM13(arg));
    else {
        int a = 48;
        int b = a;
        if(a*b>0){
            tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));
        }
        if (arg & 0x3ff)
            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |
                      INSN_IMM13(arg & 0x3ff));
    }
}",0,1,4,0.98,Insert
2159,,,,,,,
2162,"static void opt_frame_size(const char *arg)
{
    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {
        fprintf(stderr, ""Incorrect frame size\n"");
        av_exit(1);
    }
    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {
        fprintf(stderr, ""Frame size must be a multiple of 2\n"");
        av_exit(1);
    }
}","static void opt_frame_size(const char *arg)
{
    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {
        int a = 14;
        int b = a;
        struct sk_buff *img;
        nlmsg_free(img);
        if(a*b>0){
            fprintf(stderr, ""Incorrect frame size\n"");
        }
        av_exit(1);
    }
    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {
        fprintf(stderr, ""Frame size must be a multiple of 2\n"");
        av_exit(1);
    }
}",0,1,29,0.53,Insert
2163,,,,,,,
2165,,,,,,,
2166,,,,,,,
2167,,,,,,,
2168,,,,,,,
2170,,,,,,,
2172,"static QUANT_FN(pvq_encode_band)
{
    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,
                               lowband_out, level, gain, lowband_scratch, fill, 1);
}","static QUANT_FN(pvq_encode_band)
{
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,
                               lowband_out, level, gain, lowband_scratch, fill, 1);
}",0,1,3,0.42,Insert
2176,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){
    c->bytestream_start=
    c->bytestream= buf;
    c->bytestream_end= buf + buf_size;
#if CABAC_BITS == 16
    c->low =  (*c->bytestream++)<<18;
    c->low+=  (*c->bytestream++)<<10;
#else
    c->low =  (*c->bytestream++)<<10;
#endif
    c->low+= ((*c->bytestream++)<<2) + 2;
    c->range= 0x1FE;
}","void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){
    c->bytestream_start=
    c->bytestream= buf;
    c->bytestream_end= buf + buf_size;
#if CABAC_BITS == 16
    c->low =  (*c->bytestream++)<<18;
    c->low+=  (*c->bytestream++)<<10;
#else
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        c->low =  (*c->bytestream++)<<10;
    }
#endif
    c->low+= ((*c->bytestream++)<<2) + 2;
    c->range= 0x1FE;
}",1,0,5,0.1,Replace
2178,,,,,,,
2179,"PPC_OP(divw)
{
    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {
        T0 = (int32_t)((-1) * (T0 >> 31));
    } else {
        T0 = (Ts0 / Ts1);
    }
    RETURN();
}","PPC_OP(divw)
{
    WebKitWebView* webView;
    uint32_t supported;
    target_phys_addr_t base;
    SysBusDevice *device;
    if (supported == 0) {  
            sysbus_mmio_map(device, 1, base + 0x1000);
    }
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setCaretBrowsingEnabled(enableCaretBrowsing);
    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {
        T0 = (int32_t)((-1) * (T0 >> 31));
    } else {
        int a = 19;
        int b = a;
        if(a*b>0){
            T0 = (Ts0 / Ts1);
        }
    }
    RETURN();
}",1,0,59,0.66,Insert
2180,,,,,,,
2181,,,,,,,
2182,"static void pc_compat_1_4(QEMUMachineInitArgs *args)
{
    pc_compat_1_5(args);
    has_pvpanic = false;
    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);
    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);
}","static void pc_compat_1_4(QEMUMachineInitArgs *args)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        pc_compat_1_5(args);
        b = a;
    }
    has_pvpanic = false;
    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);
    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);
}",1,0,4,0.06,Replace
2184,,,,,,,
2185,,,,,,,
2186,,,,,,,
2187,,,,,,,
2193,"void error_propagate(Error **dst_errp, Error *local_err)
{
    if (local_err && dst_errp == &error_abort) {
        error_report_err(local_err);
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}","void error_propagate(Error **dst_errp, Error *local_err)
{
    if (local_err && dst_errp == &error_abort) {
        error_report_err(local_err);
        int a = 2;
        int b = 2;
        while (a == b) {
            abort();
            b += 1;
        }
    } else if (dst_errp && !*dst_errp) {
        CPUState *cpu;
        int prot;
        hwaddr paddr;
        target_ulong vaddr;
        MemTxAttrs attrs;
        hwaddr iotlb, xlat, sz;
        hwaddr iotlb, xlat, sz;
        MemoryRegionSection *section;
        int asidx = cpu_asidx_from_attrs(cpu, attrs);
        target_ulong code_address;
        hwaddr iotlb, xlat, sz;
        CPUArchState *env = cpu->env_ptr;
        target_ulong address;
        section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
        address = vaddr;
        code_address = address;
        iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                    prot, &address);
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}",1,0,11,0.4,Insert
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 aExp, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
    }
    return z;
}","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 aExp, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    int a = 2;
    int b = 2;
    while (a == b) {
        a = float64_squash_input_denormal(a STATUS_VAR);
        b += 1;
    }
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
    }
    return z;
}",1,0,1,0.16,Replace
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    assert(bs != NULL);
    BlockReopenQueueEntry *bs_entry;
    if (bs_queue == NULL) {
        bs_queue = g_new0(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = g_new0(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    assert(bs != NULL);
    int a = 2;
    int b = 2;
    if (a == b) {
        BlockReopenQueueEntry *bs_entry;
    }
    if (bs_queue == NULL) {
        bs_queue = g_new0(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = g_new0(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}",0,1,5,0.12,Replace
2199,"static void check_default_settings(AVCodecContext *avctx)
{
    X264Context *x4 = avctx->priv_data;
    int score = 0;
    score += x4->params.analyse.i_me_range == 0;
    score += x4->params.rc.i_qp_step == 3;
    score += x4->params.i_keyint_max == 12;
    score += x4->params.rc.i_qp_min == 2;
    score += x4->params.rc.i_qp_max == 31;
    score += x4->params.rc.f_qcompress == 0.5;
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;
    if (score >= 5) {
        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");
        x4->preset = av_strdup(""medium"");
        if (avctx->bit_rate == 200*1000)
            avctx->crf = 23;
    }
}","static void check_default_settings(AVCodecContext *avctx)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        X264Context *x4 = avctx->priv_data;
        b = a;
    }
    int score = 0;
    score += x4->params.analyse.i_me_range == 0;
    score += x4->params.rc.i_qp_step == 3;
    score += x4->params.i_keyint_max == 12;
    score += x4->params.rc.i_qp_min == 2;
    score += x4->params.rc.i_qp_max == 31;
    score += x4->params.rc.f_qcompress == 0.5;
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;
    if (score >= 5) {
        uint64_t data;
        hwaddr arr;
        int ndev = arr >> 16;
        int vec = ((arr & 0xFFFF) >> 2) | data;
        uint32_t irq = phb->msi_table[ndev].irq + vec;
        trace_spapr_pci_msi_write(arr, data, irq);
        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");
        x4->preset = av_strdup(""medium"");
        if (avctx->bit_rate == 200*1000)
            avctx->crf = 23;
    }
}",0,1,36,0.9,Insert
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    int r;
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    return r;
}","int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    struct kvm_signal_mask *sigmask;
    int r;
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    int a = 2;
    int b = 2;
    if (a == b) {
        sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    }
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    return r;
}",0,1,17,0.46,Insert
2201,"static int unix_close(void *opaque)
{
    QEMUFileSocket *s = opaque;
    close(s->fd);
    g_free(s);
    return 0;
}","static int unix_close(void *opaque)
{
    QEMUFileSocket *s = opaque;
    close(s->fd);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        g_free(s);
    }
    return 0;
}",1,0,4,0.06,Replace
2203,"static void fd_chr_read(void *opaque)
{
    CharDriverState *chr = opaque;
    FDCharDriver *s = chr->opaque;
    int size, len;
    uint8_t buf[1024];
    len = sizeof(buf);
    if (len > s->max_size)
        len = s->max_size;
    if (len == 0)
        return;
    size = read(s->fd_in, buf, len);
    if (size == 0) {
        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);
        qemu_chr_event(chr, CHR_EVENT_CLOSED);
        return;
    }
    if (size > 0) {
        qemu_chr_read(chr, buf, size);
    }
}","static void fd_chr_read(void *opaque)
{
    CharDriverState *chr = opaque;
    FDCharDriver *s = chr->opaque;
    int size, len;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint8_t buf[1024];
    }
    len = sizeof(buf);
    if (len > s->max_size)
        len = s->max_size;
    if (len == 0)
        return;
    size = read(s->fd_in, buf, len);
    if (size == 0) {
        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);
        qemu_chr_event(chr, CHR_EVENT_CLOSED);
        return;
    }
    if (size > 0) {
        qemu_chr_read(chr, buf, size);
    }
}",0,1,11,0.17,Replace
2206,,,,,,,
2207,"static void apic_update_irq(APICCommonState *s)
{
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
        return;
    }
    if (apic_irq_pending(s) > 0) {
        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&
               pic_get_output(isa_pic)) {
        apic_deliver_pic_intr(&s->busdev.qdev, 1);
    }
}","static void apic_update_irq(APICCommonState *s)
{
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
        int a = 25;
        int b = a;
        if(a*b>0){
            return;
        }
    }
    if (apic_irq_pending(s) > 0) {
        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&
               pic_get_output(isa_pic)) {
        apic_deliver_pic_intr(&s->busdev.qdev, 1);
        GF_BitStream *bs;
        GF_Box *s_4;
        FilePartitionBox *inter = (FilePartitionBox *)s_4;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
    }
}",0,1,11,0.46,Insert
2208,"PPC_OP(extsh)
{
    T0 = (int32_t)((int16_t)(Ts0));
    RETURN();
}","PPC_OP(extsh)
{
    char str[] = ""Constant"";
    DisasContext *ctx;
    TCGv_i32 t1, t2;
    int r;
    if (r < 0) {
            goto fail;
    }
    int nb = NB(ctx->opcode);
    TCGv t0;
    TCGv_i32 t1, t2;
    t0 = tcg_temp_new();
    gen_addr_register(ctx, t0);
    gen_helper_lsw(cpu_env, t0, t1, t2);
    tcg_temp_free(t0);
    while (strlen(str) > 5) {
        T0 = (int32_t)((int16_t)(Ts0));
    strcpy(str, ""a"");
    }
    RETURN();
}",1,0,39,0.38,Insert
2209,,,,,,,
2210,"static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)
{
    uint8_t retval;
    MACIOIDEState *d = opaque;
    addr = (addr & 0xFFF) >> 4;
    switch (addr) {
    case 1 ... 7:
        retval = ide_ioport_read(&d->bus, addr);
        break;
    case 8:
    case 22:
        retval = ide_status_read(&d->bus, 0);
        break;
    default:
        retval = 0xFF;
        break;
    }
    return retval;
}","static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)
{
    uint8_t retval;
    MACIOIDEState *d = opaque;
    addr = (addr & 0xFFF) >> 4;
    switch (addr) {
    case 1 ... 7:
        retval = ide_ioport_read(&d->bus, addr);
        break;
    case 8:
    case 22:
        retval = ide_status_read(&d->bus, 0);
        break;
        struct xen_blkif_ring *ring;
        static int  init;
        if (! init) {
                 init = 1;
                optimize_flags_init();
        }
        int st;
        unsigned long     flags;
        struct blkif_response *resp;
        resp->status    = st;
        spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
    default:
        retval = 0xFF;
        break;
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return retval;
        bool human;
        TestOutputVisitorData *data;
        data->human = human;
        data->sov = string_output_visitor_new(human);
        g_assert(data->sov);
        data->ov = string_output_get_visitor(data->sov);
        g_assert(data->ov);
    }
}",0,1,95,0.8,Insert
2211,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)
{
    uint32_t tlbncfg;
    int tlbn = booke206_tlbm_to_tlbn(env, tlb);
    int tlbm_size;
    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
    if (tlbncfg & TLBnCFG_AVAIL) {
        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
    } else {
        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;
        tlbm_size <<= 1;
    }
    return 1024ULL << tlbm_size;
}","target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)
{
    uint32_t tlbncfg;
    int a = 2;
    SysBusDevice *b_2;
    if (i) {
            sysbus_mmio_map(b_2, 0, i);
    }
    int b = 3;
    while (a != b) {
        int tlbn = booke206_tlbm_to_tlbn(env, tlb);
        b = a;
    }
    int tlbm_size;
    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
    if (tlbncfg & TLBnCFG_AVAIL) {
        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
    } else {
        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;
        tlbm_size <<= 1;
    }
    return 1024ULL << tlbm_size;
}",0,1,19,0.6,Insert
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    return 0;
}","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
                     struct dir *dir;
                     AVPacket * pk;
                     AVFormatContext *s;
                     int size               =  pk->size;
                     AVIOContext *b_4     = s->b_4;
                     if (size & 1)
                             avio_w8(b_4, 0);
                     struct proc_mounts *p = dir->private_data;
                     if (mnt_had_events(p))
                     		res |= POLLERR | POLLPRI;
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
    }
}",0,1,35,0.67,Insert
2213,"static void thread_pool_cancel(BlockAIOCB *acb)
{
    ThreadPoolElement *elem = (ThreadPoolElement *)acb;
    ThreadPool *pool = elem->pool;
    trace_thread_pool_cancel(elem, elem->common.opaque);
    qemu_mutex_lock(&pool->lock);
    if (elem->state == THREAD_QUEUED &&
        qemu_sem_timedwait(&pool->sem, 0) == 0) {
        QTAILQ_REMOVE(&pool->request_list, elem, reqs);
        qemu_bh_schedule(pool->completion_bh);
        elem->state = THREAD_DONE;
        elem->ret = -ECANCELED;
    }
    qemu_mutex_unlock(&pool->lock);
}","static void thread_pool_cancel(BlockAIOCB *acb)
{
    ThreadPoolElement *elem = (ThreadPoolElement *)acb;
    int a = 2;
    int b = 3;
    while (a != b) {
        ThreadPool *pool = elem->pool;
        b = a;
    }
    trace_thread_pool_cancel(elem, elem->common.opaque);
    qemu_mutex_lock(&pool->lock);
    if (elem->state == THREAD_QUEUED &&
        qemu_sem_timedwait(&pool->sem, 0) == 0) {
        QTAILQ_REMOVE(&pool->request_list, elem, reqs);
        qemu_bh_schedule(pool->completion_bh);
        elem->state = THREAD_DONE;
        elem->ret = -ECANCELED;
    }
    qemu_mutex_unlock(&pool->lock);
}",0,1,1,0.08,Replace
2214,,,,,,,
2219,,,,,,,
2220,"PPC_OP(cmpl)
{
    if (T0 < T1) {
        T0 = 0x08;
    } else if (T0 > T1) {
        T0 = 0x04;
    } else {
        T0 = 0x02;
    }
    RETURN();
}","PPC_OP(cmpl)
{
    if (T0 < T1) {
        T0 = 0x08;
        BlockDriverState *target;
        uint32_t granularity;
        if (granularity == 0) {
                granularity = bdrv_get_default_bitmap_granularity(target);
        }
    } else if (T0 > T1) {
        T0 = 0x04;
    } else {
        T0 = 0x02;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        RETURN();
    strcpy(str, ""a"");
    }
}",1,0,36,0.54,Insert
2221,"static int voc_probe(AVProbeData *p)
{
    int version, check;
    if (p->buf_size < 26)
        return 0;
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
        return 0;
    version = p->buf[22] | (p->buf[23] << 8);
    check = p->buf[24] | (p->buf[25] << 8);
    if (~version + 0x1234 != check)
        return 10;
    return AVPROBE_SCORE_MAX;
}","static int voc_probe(AVProbeData *p)
{
    int version, check;
    struct dir *dir;
    struct proc_mounts *p_3 = dir->private_data;
    if (mnt_had_events(p_3))
    		res |= POLLERR | POLLPRI;
    if (p->buf_size < 26)
        return 0;
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
        return 0;
    version = p->buf[22] | (p->buf[23] << 8);
    check = p->buf[24] | (p->buf[25] << 8);
    if (~version + 0x1234 != check)
        return 10;
    int a = 2;
    int b = 3;
    if (a != b) {
        return AVPROBE_SCORE_MAX;
    }
}",0,1,9,0.58,Insert
2223,,,,,,,
2224,,,,,,,
2225,,,,,,,
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,
                                  int flag)
{
    struct kvm_x86_mce_data data = {
        .env = env,
        .mce = mce,
        .abort_on_error = (flag & ABORT_ON_ERROR),
    };
    if (!env->mcg_cap) {
        fprintf(stderr, ""MCE support is not enabled!\n"");
        return;
    }
    run_on_cpu(env, kvm_do_inject_x86_mce, &data);
}","static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,
                                  int flag)
{
    struct kvm_x86_mce_data data = {
        struct sk_buff *skb;
        struct hci_dev *hdev;
        void *settings;
        __u8 status = *((__u8 *) skb->data_5);
        settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
        data_5 = get_unaligned_le16(settings);
        .env = env,
        .mce = mce,
        .abort_on_error = (flag & ABORT_ON_ERROR),
    };
    if (!env->mcg_cap) {
        fprintf(stderr, ""MCE support is not enabled!\n"");
        return;
    }
    int a = 11;
    int b = a;
    if(a*b>0){
        run_on_cpu(env, kvm_do_inject_x86_mce, &data);
    }
}",0,1,9,0.6,Insert
2229,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)
{
    AioHandler *node;
    QLIST_FOREACH(node, &ctx->aio_handlers, node) {
        if (node->pfd.fd == fd)
            if (!node->deleted)
                return node;
    }
    return NULL;
}","static AioHandler *find_aio_handler(AioContext *ctx, int fd)
{
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    AioHandler *node;
    QLIST_FOREACH(node, &ctx->aio_handlers, node) {
        if (node->pfd.fd == fd)
            if (!node->deleted)
                return node;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return NULL;
    strcpy(str, ""a"");
    }
}",0,1,5,0.46,Insert
2234,"void qemu_file_set_error(QEMUFile *f, int ret)
{
    if (f->last_error == 0) {
        f->last_error = ret;
    }
}","void qemu_file_set_error(QEMUFile *f, int ret)
{
    if (f->last_error == 0) {
        FILE *f_7;
        int ret_4;
        if (f_7 == NULL) {
                ret_4 = errno;
                goto free;
        }
        f->last_error = ret;
    }
}",1,0,3,0.23,Insert
2237,"uint64_t helper_efdctuidz (uint64_t val)
{
    CPU_DoubleU u;
    u.ll = val;
    if (unlikely(float64_is_nan(u.d)))
        return 0;
    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);
}","uint64_t helper_efdctuidz (uint64_t val)
{
    int a = 2;
    int b = 3;
    struct ttm_buffer_object *bo;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs);
    		inter->entries[i].block_size = gf_bs_read_u32(bs);
    }
    struct ttm_bo_device *tdev = bo->tdev;
    struct ttm_bo_device *tdev = bo->tdev;
    dma_resv_assert_held(bo->base.resv);
    bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
    while (a != b) {
        CPU_DoubleU u;
        b = a;
    }
    u.ll = val;
    if (unlikely(float64_is_nan(u.d)))
        return 0;
    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);
}",0,1,38,0.57,Insert
2238,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,
                                     void *start, unsigned size,
                                     uint8_t *checksum)
{
    BiosLinkerLoaderEntry entry;
    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);
    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;
    ptrdiff_t start_offset = (gchar *)start - file->blob->data;
    assert(checksum_offset >= 0);
    assert(start_offset >= 0);
    assert(checksum_offset + 1 <= file->blob->len);
    assert(start_offset + size <= file->blob->len);
    assert(*checksum == 0x0);
    memset(&entry, 0, sizeof entry);
    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);
    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);
    entry.cksum.offset = cpu_to_le32(checksum_offset);
    entry.cksum.start = cpu_to_le32(start_offset);
    entry.cksum.length = cpu_to_le32(size);
    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
}","void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,
                                     void *start, unsigned size,
                                     uint8_t *checksum)
{
    BiosLinkerLoaderEntry entry;
    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;
    ptrdiff_t start_offset = (gchar *)start - file->blob->data;
    assert(checksum_offset >= 0);
    assert(start_offset >= 0);
    assert(checksum_offset + 1 <= file->blob->len);
    assert(start_offset + size <= file->blob->len);
    assert(*checksum == 0x0);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        QEMUMachineInitArgs *args;
        char *filename;
        ram_addr_t ram_size = args->ram_size;
        long load_limit, rtas_limit, fw_size;
        spapr->next_irq = XICS_IRQ_BASE;
        spapr->ram_limit = ram_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        spapr_events_init(spapr);
        memset(&entry, 0, sizeof entry);
    strcpy(str, ""a"");
    }
    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);
    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);
    entry.cksum.offset = cpu_to_le32(checksum_offset);
    entry.cksum.start = cpu_to_le32(start_offset);
    entry.cksum.length = cpu_to_le32(size);
    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
}",0,1,67,1.28,Insert
2240,,,,,,,
2241,"void qemu_mutex_lock_iothread(void)
{
    if (!tcg_enabled()) {
        qemu_mutex_lock(&qemu_global_mutex);
    } else {
        iothread_requesting_mutex = true;
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(first_cpu);
            qemu_mutex_lock(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}","void qemu_mutex_lock_iothread(void)
{
    int ret, type, picsize, desc_len;
    if (ret < 0)
            goto fail;
    if (!tcg_enabled()) {
        qemu_mutex_lock(&qemu_global_mutex);
    } else {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            iothread_requesting_mutex = true;
        }
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(first_cpu);
            qemu_mutex_lock(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}",1,0,15,0.35,Insert
2242,"static inline void gen_op_addl_ESP_im(int32_t val)
{
    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);
#ifdef TARGET_X86_64
    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);
#endif
    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
}","static inline void gen_op_addl_ESP_im(int32_t val)
{
    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
    QuantizationTable
        *table_1;
    XMLTreeInfo
        *description_7,
        *levels_4,
        *quantization_tables_7,
        *table_iterator_1;
    const char
        *attribute_8,
        *content_4;
    attribute_8=GetXMLTreeAttribute(levels_4,""divisor"");
    table_1->divisor=InterpretLocaleValue_10(attribute_8,(char **) NULL);
    int a = 2;
    int b = 3;
    while (a < b) {
        tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);
        b = a;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
    }
    struct ttm_buffer_object *bo;
    scoped_refptr<IndexedDBCallbacks> Callcallback;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    IndexedDBTransaction* intermission;
    int64_t object_store_id;
    intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                               this, object_store_id, Callcallback));
    struct ttm_bo_device *tdev = bo->tdev;
    struct ttm_bo_device *tdev = bo->tdev;
    dma_resv_assert_held(bo->base.resv);
    bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
#ifdef TARGET_X86_64
    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);
#endif
    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
}",0,1,236,1.56,Insert
2243,"static unsigned int dec_movu_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZ);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_movu_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	GF_BitStream *bs;
	struct client_session *c_2;
	int http_status;
	struct session_request *sr;
	struct mk_list *host_list = &config->hosts;
	struct mk_list *sr_list = &c_2->request_list;
	if (http_status > 0) {
	        if (!sr->host_conf) {
	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
	        }
	        mk_request_error(http_status, c_2, sr);
	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c_2->socket,
	                            NULL, c_2, sr);
	}
	GF_Box *s;
	int c, cnt;
	int val;
	struct timeval t1, t2;
	int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
	int64_t alpha;
	int total = 0;
	print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
	struct f2fs_sb_info *sbi;
	int type;
	struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
	struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
	struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
	segno = __get_next_segno(sbi, type);
	reset_curseg(sbi, type, 1);
	rcursiveg->alloc_type = LFS;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	u32 i;
	for (i=0;i < inter->nb_entries; i++) {
			inter->entries[i].block_count = gf_bs_read_u16(bs);
			inter->entries[i].block_size = gf_bs_read_u32(bs);
	}
	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZ);
	int a = 2;
	int b = 2;
	if (a == b) {
    	t0 = tcg_temp_new(TCG_TYPE_TL);
	}
	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}",0,1,110,1.21,Insert
2244,"AVInputFormat *av_find_input_format(const char *short_name)
{
    AVInputFormat *fmt = NULL;
    while ((fmt = av_iformat_next(fmt)))
        if (match_format(short_name, fmt->name))
            return fmt;
    return NULL;
}","AVInputFormat *av_find_input_format(const char *short_name)
{
    AVInputFormat *fmt = NULL;
    while ((fmt = av_iformat_next(fmt)))
        if (match_format(short_name, fmt->name))
            return fmt;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return NULL;
        GF_Box *s;
        GF_BitStream *bs;
        u32 i, ch;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
        gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
        gf_bs_write_int(bs, 0x7, 3);
        gf_bs_write_int(bs, ch, 5);
        gf_bs_write_u8(bs, ch);
    }
}",0,1,6,0.32,Insert
2246,"static int au_probe(AVProbeData *p)
{
    if (p->buf_size <= 24)
        return 0;
    if (p->buf[0] == '.' && p->buf[1] == 's' &&
        p->buf[2] == 'n' && p->buf[3] == 'd')
        return AVPROBE_SCORE_MAX;
    else
        return 0;
}","static int au_probe(AVProbeData *p)
{
    if (p->buf_size <= 24)
        return 0;
    if (p->buf[0] == '.' && p->buf[1] == 's' &&
        p->buf[2] == 'n' && p->buf[3] == 'd')
        int a = 98;
        int b = a;
        if(a*b>0){
            return AVPROBE_SCORE_MAX;
        }
    else
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p_3, nzcv;
    unsigned int coll, order, err, resp, coll, p_3, nzcv;
    unsigned int coll, order, err, resp, coll, p_3, nzcv;
    unsigned int coll, order, err, resp, coll, p_3, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p_3);
        return 0;
}",0,1,3,0.42,Insert
2247,,,,,,,
2249,,,,,,,
2252,"PPC_OP(srawi)
{
    T1 = T0;
    T0 = (Ts0 >> PARAM(1));
    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {
        xer_ca = 1;
    } else {
        xer_ca = 0;
    }
    RETURN();
}","PPC_OP(srawi)
{
    T1 = T0;
    T0 = (Ts0 >> PARAM(1));
    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {
        xer_ca = 1;
        lua_State *L_6;
        if (getCcalls_7(L_6) <= CSTACKERR_3)   
            luaE_freeCI_10(L_6);
    } else {
        char str[] = ""Constant"";
        int ret;
        lua_State *L;
        if (getCcalls(L) <= CSTACKERR)   
            luaE_freeCI(L);
        struct urb *urb;
        if (ret) {
        		usb_unanchor_urb(urb);
        		goto error;
        }
        if (strlen(str) > 0) {
            xer_ca = 0;
        }
    }
    RETURN();
}",1,0,72,0.65,Insert
2253,,,,,,,
2254,"static int srt_probe(AVProbeData *p)
{
    const unsigned char *ptr = p->buf;
    int i, v, num = 0;
    if (AV_RB24(ptr) == 0xEFBBBF)
        ptr += 3;   
    while (*ptr == '\r' || *ptr == '\n')
        ptr++;
    for (i=0; i<2; i++) {
        if ((num == i || num + 1 == i)
            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)
            return AVPROBE_SCORE_MAX;
        num = atoi(ptr);
        ptr += strcspn(ptr, ""\n"") + 1;
    }
    return 0;
}","static int srt_probe(AVProbeData *p)
{
    const unsigned char *ptr = p->buf;
    int i, v, num = 0;
    if (AV_RB24(ptr) == 0xEFBBBF)
        ptr += 3;   
    while (*ptr == '\r' || *ptr == '\n')
        ptr++;
    for (i=0; i<2; i++) {
        if ((num == i || num + 1 == i)
            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)
            int a = 55;
            int b = a;
            if(a*b>0){
                return AVPROBE_SCORE_MAX;
            }
        num = atoi(ptr);
        ptr += strcspn(ptr, ""\n"") + 1;
    }
    unichar tmp;
    int len, raw_len;
    int len, raw_len;
    const char *ptr_4;
    if (term_type == TERM_TYPE_UTF8) {
    		while (*ptr_4 != '\0') {
    			tmp = g_utf8_get_char(ptr_4);
    			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
    			ptr_4 = g_utf8_next_char(ptr_4);
    		}
    	} else
    		len = raw_len;
    return 0;
}",1,0,13,0.91,Insert
2255,,,,,,,
2256,,,,,,,
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->run_vlc);
    av_freep(&ctx->mb_scan_index);
    av_freep(&ctx->rows);
    return 0;
}","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->run_vlc);
    av_freep(&ctx->mb_scan_index);
    av_freep(&ctx->rows);
    int a = 92;
    int b = a;
    if(a*b>0){
        return 0;
    }
}",1,0,4,0.08,Replace
2258,,,,,,,
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)
{
    if (!sar.num)
        sar = (AVRational){1, 1};
    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});
    return sar;
}","static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)
{
    if (!sar.num)
        sar = (AVRational){1, 1};
    int a = 2;
    int b = 2;
    while (a == b) {
        size_t old_address, type;
        void *new__addr;
        size_t old_address, type;
        old_address = *(size_t *)((char *)cp - 16);
        memcpy(new__addr, cp, type);
        g_free(cp);
        sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});
        b += 1;
    }
    struct x86_emulate_ctxt *ftext;
    struct x86_emulate_ops *ops = ftext->ops;
    u16 cs_sel, ss_sel;
    u64 msrr2def;
    struct x86_emulate_ops *ops = ftext->ops;
    struct desc_struct cs, css;
    cs_sel = (u16)(msrr2def & 0xfffc);
    ops->set_segment(ftext, cs_sel, &cs, 0, VCPU_SREG_CS);
    return sar;
}",1,0,41,0.69,Insert
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    return inl(0xcfc);
}","static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    }
    size_t cluster_size;
    int currency;
    QCowHeader *header;
    int cluster_bits;
    *header = (QCowHeader) {
            .magic                      = cpu_to_be32(QCOW_MAGIC),
            .currency                    = cpu_to_be32(currency),
            .cluster_bits               = cpu_to_be32(cluster_bits),
            .size                       = cpu_to_be64(0),
            .l1_table_offset            = cpu_to_be64(0),
            .l1_size                    = cpu_to_be32(0),
            .refcount_table_offset      = cpu_to_be64(cluster_size),
            .refcount_table_clusters    = cpu_to_be32(1),
            .refcount_order             = cpu_to_be32(3 + REFCOUNT_SHIFT),
            .header_length              = cpu_to_be32(sizeof(*header)),
        };
    return inl(0xcfc);
}",1,0,14,0.35,Insert
2267,"static int load_normal_reset(S390CPU *cpu)
{
    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);
    pause_all_vcpus();
    cpu_synchronize_all_states();
    cpu_reset_all();
    io_subsystem_reset();
    scc->initial_cpu_reset(CPU(cpu));
    scc->load_normal(CPU(cpu));
    cpu_synchronize_all_post_reset();
    resume_all_vcpus();
    return 0;
}","static int load_normal_reset(S390CPU *cpu)
{
    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);
    pause_all_vcpus();
    cpu_synchronize_all_states();
    cpu_reset_all();
    io_subsystem_reset();
    int a = 2;
    int b = 3;
    while (a < b) {
        int64_t timeout;
        int g_poll_ret, ret, i, n_poll_fds;
        int64_t poll_timeout_ns;
        WaitObjects *w = &wait_objects;
        int g_poll_ret, ret, i, n_poll_fds;
        GPollFD poll_fds[1024 * 2];
        GMainContext *context = g_main_context_default();
        gint poll_timeout;
        n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,
                                              poll_fds, ARRAY_SIZE(poll_fds));
        poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);
        g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);
        scc->initial_cpu_reset(CPU(cpu));
        b = a;
    }
    scc->load_normal(CPU(cpu));
    cpu_synchronize_all_post_reset();
    resume_all_vcpus();
    return 0;
}",1,0,21,0.52,Insert
2268,,,,,,,
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)
{
    if (migrate_use_xbzrle()) {
        info->has_xbzrle_cache = true;
        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));
        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();
        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();
        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();
        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();
        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();
    }
}","static void get_xbzrle_cache_stats(MigrationInfo *info)
{
    if (migrate_use_xbzrle()) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            info->has_xbzrle_cache = true;
        }
        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));
        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();
        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();
        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();
        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();
        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();
    }
}",1,0,3,0.08,Replace
2270,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,
                                      int do_init,
                                      const char *cpu_model,
                                      uint32_t sysclk)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    qemu_irq *irqs;
    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""Unable to initialize CPU!\n"");
        exit(1);
    }
    env = &cpu->env;
    ppc_booke_timers_init(cpu, sysclk, 0 );
    ppc_dcr_init(env, NULL, NULL);
    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);
    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
    ppcuic_init(env, irqs, 0x0C0, 0, 1);
    return cpu;
}","static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,
                                      int do_init,
                                      const char *cpu_model,
                                      uint32_t sysclk)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        PowerPCCPU *cpu;
    }
    CPUPPCState *env;
    qemu_irq *irqs;
    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""Unable to initialize CPU!\n"");
        exit(1);
    }
    env = &cpu->env;
    ppc_booke_timers_init(cpu, sysclk, 0 );
    ppc_dcr_init(env, NULL, NULL);
    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);
    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
    ppcuic_init(env, irqs, 0x0C0, 0, 1);
    return cpu;
}",1,0,5,0.15,Replace
2271,,,,,,,
2272,"void ff_af_queue_close(AudioFrameQueue *afq)
{
    while (afq->frame_queue)
        delete_next_frame(afq);
    memset(afq, 0, sizeof(*afq));
}","void ff_af_queue_close(AudioFrameQueue *afq)
{
    while (afq->frame_queue)
        delete_next_frame(afq);
    char str[] = ""Constant"";
    struct br_ip host;
    host.proto = Ska->protocol;
    while (strlen(str) > 5) {
        memset(afq, 0, sizeof(*afq));
    strcpy(str, ""a"");
    }
}",0,1,4,0.32,Insert
2273,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)
{
    int i;
    int32_t *dst = (int32_t *) _dst;
    for (i = 0; i < width; i++)
        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;
}","static void lumRangeToJpeg16_c(int16_t *_dst, int width)
{
    int i;
    AVCodecContext *avctx;
    int i_8;
    HEVCContext *sg = avctx->priv_data;
    for (i_8 = 0; i_8 < FF_ARRAY_ELEMS(sg->DPB); i_8++) {
            sg->DPB[i_8].frame = av_frame_alloc();
            if (!sg->DPB[i_8].frame)
                goto fail;
            sg->DPB[i_8].tf.f = sg->DPB[i_8].frame;
    }
    int32_t *dst = (int32_t *) _dst;
    for (i = 0; i < width; i++)
        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;
}",1,0,7,0.44,Insert
2280,,,,,,,
2281,"void qemu_opts_print(QemuOpts *opts)
{
    QemuOpt *opt;
    QemuOptDesc *desc = opts->list->desc;
    if (desc[0].name == NULL) {
        QTAILQ_FOREACH(opt, &opts->head, next) {
            printf(""%s=\""%s\"" "", opt->name, opt->str);
        }
        return;
    }
    for (; desc && desc->name; desc++) {
        const char *value;
        QemuOpt *opt = qemu_opt_find(opts, desc->name);
        value = opt ? opt->str : desc->def_value_str;
        if (!value) {
            continue;
        }
        if (desc->type == QEMU_OPT_STRING) {
            printf(""%s='%s' "", desc->name, value);
        } else if ((desc->type == QEMU_OPT_SIZE ||
                    desc->type == QEMU_OPT_NUMBER) && opt) {
            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);
        } else {
            printf(""%s=%s "", desc->name, value);
        }
    }
}","void qemu_opts_print(QemuOpts *opts)
{
    QemuOpt *opt;
    int a = 2;
    int b = 3;
    while (a < b) {
        int diff;
        diff = -1;
        QemuOptDesc *desc = opts->list->desc;
        b = a;
    }
    if (desc[0].name == NULL) {
        QTAILQ_FOREACH(opt, &opts->head, next) {
            printf(""%s=\""%s\"" "", opt->name, opt->str);
        }
        return;
    }
    for (; desc && desc->name; desc++) {
        const char *value;
        QemuOpt *opt = qemu_opt_find(opts, desc->name);
        value = opt ? opt->str : desc->def_value_str;
        if (!value) {
            continue;
        }
        if (desc->type == QEMU_OPT_STRING) {
            printf(""%s='%s' "", desc->name, value);
        } else if ((desc->type == QEMU_OPT_SIZE ||
                    desc->type == QEMU_OPT_NUMBER) && opt) {
            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);
        } else {
            printf(""%s=%s "", desc->name, value);
        }
    }
}",0,1,25,1.17,Insert
2286,"static SocketAddress *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddress *saddr;
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddress, 1);
    saddr->type = SOCKET_ADDRESS_KIND_INET;
    saddr->u.inet.data = iaddr;
    return saddr;
}","static SocketAddress *tcp_build_address(const char *host_port, Error **errp)
{
    u64 id;
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
    struct blkif_response *resp;
    resp->id        = id;
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddress *saddr;
    unsigned char *sha1;
    void *data;
    unsigned long size;
    struct pbase_tree *it;
    unsigned char tree_sha1[20];
    data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    it = xcalloc(1, sizeof(*it));
    it->pcache.tree_size = size;
    if (inet_parse(iaddr, host_port, errp)) {
        S390CPU *console;
        Error *order = NULL;
        object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddress, 1);
    int a = 2;
    int b = 2;
    while (a == b) {
        saddr->type = SOCKET_ADDRESS_KIND_INET;
        b += 1;
    }
    saddr->u.inet.data = iaddr;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    return saddr;
}",0,1,154,0.96,Insert
2287,,,,,,,
2288,"static void reset(DeviceState *d)
{
    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);
    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
    trace_spapr_drc_reset(spapr_drc_index(drc));
    g_free(drc->ccs);
    drc->ccs = NULL;
    if (drc->awaiting_release) {
        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);
        if (drc->awaiting_release) {
            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);
        }
        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&
            drc->awaiting_release) {
            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);
        }
    }
}","static void reset(DeviceState *d)
{
    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);
    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
    trace_spapr_drc_reset(spapr_drc_index(drc));
    AnimationChannel &context;
    json &o;
    if (context.extras.Type() != NULL_TYPE) {
        SerializeValue(""extras"", context.extras, o);
    }
    g_free(drc->ccs);
    drc->ccs = NULL;
    if (drc->awaiting_release) {
        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);
        if (drc->awaiting_release) {
            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);
        }
        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&
            drc->awaiting_release) {
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);
            strcpy(str, ""a"");
            }
        }
    }
}",0,1,19,0.66,Insert
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    CPUState *env;
    int err;
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, addr);
        if (!bp)
            return -ENOENT;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    int a = 2;
    int b = 3;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    unsigned int num_members;
    NTSTATUS obj;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    if (a != b) {
        CPUState *env;
    }
    int err;
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, addr);
        if (!bp)
            return -ENOENT;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}",0,1,25,0.94,Insert
2290,"void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)
{
    int relation;
    set_float_exception_flags(0, &env->fp_status);
    relation = float64_compare(t0, t1, &env->fp_status);
    if (unlikely(relation == float_relation_unordered)) {
        update_fpscr(env, GETPC());
    } else {
        env->sr_t = (relation == float_relation_greater);
    }
}","void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)
{
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    int relation;
    set_float_exception_flags(0, &env->fp_status);
    void *opaques;
    V9fsPDU *pdf = opaques;
    V9fsString part;
    int32_t fpaid, newcids;
    size_t offset = 7;
    int32_t fpaid, newcids;
    pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    int a = 2;
    int b = 2;
    while (a == b) {
        relation = float64_compare(t0, t1, &env->fp_status);
        b += 1;
    }
    if (unlikely(relation == float_relation_unordered)) {
        update_fpscr(env, GETPC());
    } else {
        env->sr_t = (relation == float_relation_greater);
    }
}",0,1,41,0.64,Insert
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)
{
    int hours, minutes, seconds;
    if (!show_bits(gb, 23)) {
        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");
        return -1;
    }
    hours   = get_bits(gb, 5);
    minutes = get_bits(gb, 6);
    skip_bits1(gb);
    seconds = get_bits(gb, 6);
    s->time_base = seconds + 60*(minutes + 60*hours);
    skip_bits1(gb);
    skip_bits1(gb);
    return 0;
}","static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)
{
    int hours, minutes, seconds;
    if (!show_bits(gb, 23)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");
        strcpy(str, ""a"");
        }
        return -1;
    }
    hours   = get_bits(gb, 5);
    minutes = get_bits(gb, 6);
    skip_bits1(gb);
    seconds = get_bits(gb, 6);
    s->time_base = seconds + 60*(minutes + 60*hours);
    skip_bits1(gb);
    skip_bits1(gb);
    return 0;
}",0,1,2,0.09,Replace
2295,"static int ftp_restart(FTPContext *s, int64_t pos)
{
    char command[CONTROL_BUFFER_SIZE];
    const int rest_codes[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return AVERROR(EIO);
    return 0;
}","static int ftp_restart(FTPContext *s, int64_t pos)
{
    int a = 2;
    int b = 3;
    GF_BitStream *bs;
    GF_Box *s_1;
    FilePartitionBox *inter = (FilePartitionBox *)s_1;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    while (a != b) {
        char command[CONTROL_BUFFER_SIZE];
        b = a;
    }
    const int rest_codes[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return AVERROR(EIO);
        SysBusDevice *b_2;
        if (i) {
                sysbus_mmio_map(b_2, 0, i);
        }
    return 0;
}",0,1,44,0.68,Insert
2297,"int kvm_ioctl(KVMState *s, int type, ...)
{
    int ret;
    void *arg;
    va_list ap;
    va_start(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    ret = ioctl(s->fd, type, arg);
    if (ret == -1)
        ret = -errno;
    return ret;
}","int kvm_ioctl(KVMState *s, int type, ...)
{
    int ret;
    void *arg;
    va_list ap;
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    va_start(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    ret = ioctl(s->fd, type, arg);
    if (ret == -1)
        ret = -errno;
    int a = 2;
    int b = 3;
    if (a != b) {
        return ret;
    }
}",0,1,18,0.69,Insert
2299,,,,,,,
2300,"static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int ret;
    AVStream *st;
    st = s->streams[0];
    av_read_frame_flush(s);
    url_fseek(&s->pb, s->data_offset, SEEK_SET);
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}","static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int ret;
    AVStream *st;
    st = s->streams[0];
    av_read_frame_flush(s);
    int a = 2;
    int b = 3;
    while (a != b) {
        url_fseek(&s->pb, s->data_offset, SEEK_SET);
        b = a;
    }
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            struct dir *dir;
            struct proc_mounts *p = dir->private_data;
            if (mnt_had_events(p))
            		res |= POLLERR | POLLPRI;
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}",0,1,26,0.89,Insert
2304,,,,,,,
2307,"get_net_error_message(gint error)
{
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'\n' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        LocalFree(msg);
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}","get_net_error_message(gint error)
{
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'\n' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            CPUState *cpu;
            int prot;
            int mmu_idx;
            hwaddr paddr;
            target_ulong vaddr;
            hwaddr iotlb, xlat, sz;
            MemoryRegionSection *section;
            hwaddr iotlb, xlat, sz;
            CPUArchState *env = cpu->env_ptr;
            target_ulong address;
            tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx
                          "" prot=%x idx=%d
            "",
                          vaddr, paddr, prot, mmu_idx);
            iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                        prot, &address);
            LocalFree(msg);
        }
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}",1,0,27,1.03,Insert
2308,"static void kqemu_record_flush(void)
{
    PCRecord *r, *r_next;
    int h;
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {
            r_next = r->next;
            free(r);
        }
        pc_rec_hash[h] = NULL;
    }
    nb_pc_records = 0;
}","static void kqemu_record_flush(void)
{
    PCRecord *r, *r_next;
    int h;
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {
            int a = 2;
            int b = 3;
            AVFormatContext *your;
            int port, i, status, r_4;
            RTSPState *rt = your->priv_data;
            if (ff_rtsp_callback) {
                    if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                         NULL, 0, rt->last_reply) < 0) {
                        r_4 = AVERROR_INVALIDDATA;
                        goto fail;
                    }
            }
            while (a < b) {
                r_next = r->next;
                b = a;
            }
            free(r);
        }
        pc_rec_hash[h] = NULL;
    }
    nb_pc_records = 0;
}",0,1,13,0.61,Insert
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,
                                    int nb_sectors)
{
    int64_t cluster_num, nb_clusters;
    if (iscsilun->allocationmap == NULL) {
        return;
    }
    cluster_num = sector_num / iscsilun->cluster_sectors;
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
                               iscsilun->cluster_sectors) - cluster_num;
    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
}","static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,
                                    int nb_sectors)
{
    int64_t cluster_num, nb_clusters;
    if (iscsilun->allocationmap == NULL) {
        return;
    }
    cluster_num = sector_num / iscsilun->cluster_sectors;
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
                               iscsilun->cluster_sectors) - cluster_num;
    int a = 2;
    int b = 2;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    if (a == b) {
        bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
    }
}",0,1,10,0.44,Insert
2311,"static void test_qemu_strtosz_metric(void)
{
    const char *str = ""12345k"";
    char *endptr = NULL;
    int64_t res;
    res = qemu_strtosz_metric(str, &endptr);
    g_assert_cmpint(res, ==, 12345000);
    g_assert(endptr == str + 6);
}","static void test_qemu_strtosz_metric(void)
{
    const char *str = ""12345k"";
    char *endptr = NULL;
    int64_t res;
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        res = qemu_strtosz_metric(str, &endptr);
        b_1 = a_1;
    }
    g_assert_cmpint(res, ==, 12345000);
    UHCI_TD *dev;
    uint8_t val;
    val = dev->token & 0xff;
    g_assert(endptr == str + 6);
}",0,1,24,0.45,Insert
2312,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i, size, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size   = put_bits_count(&pb) >> 3;
    int a = 2;
    int b = 2;
    if (a == b) {
        RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
    }
}",0,1,3,0.45,Insert
2315,,,,,,,
2316,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = arm_mptimer_realize;
    dc->vmsd = &vmstate_arm_mptimer;
    dc->reset = arm_mptimer_reset;
    dc->no_user = 1;
    dc->props = arm_mptimer_properties;
}","static void arm_mptimer_class_init(ObjectClass *klass, void *data)
{
    char str1[] = ""Constant"";
    size_t bufmode;
    size_t pos;
    if (pos >= bufmode)
          pos = bufmode-1;
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        DeviceClass *dc = DEVICE_CLASS(klass);
    }
    dc->realize = arm_mptimer_realize;
    dc->vmsd = &vmstate_arm_mptimer;
    dc->reset = arm_mptimer_reset;
    dc->no_user = 1;
    dc->props = arm_mptimer_properties;
}",1,0,17,0.39,Insert
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    bit = (S & s->and) | s->or;
    bit = ((S + bit) << s->shift) - bit;
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    const char *option;
    const char *node_path;
    gpointer opaque;
    PtyCharDriver *s_1 = chr->opaque;
    if (s_1->connected) {
            goto out;
    }
    int pathlen;
    char *method;
    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, option)
                  + 1;
    snprintf(method, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, option);
    bit = (S & s->and) | s->or;
    int a = 2;
    int b = 3;
    AVFormatContext *s_10;
    uint32_t text_offset, data_offset, channel_assign;
    AVIOContext *pb = s_10->pb;
    AVStream *st;
    if (!(channel_assign & 1)) {
            int i;
            for (i = 1; i < 32; i++)
                if (channel_assign & (1 << i))
                    st->codecpar->channel_layout |= wsd_to_av_channel_layoyt(s_10, i);
    }
    while (a != b) {
        bit = ((S + bit) << s->shift) - bit;
        b = a;
    }
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}",1,0,77,1.13,Insert
2322,,,,,,,
2323,,,,,,,
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");
        return AVERROR(EINVAL);
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    return 0;
}","static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",
            motion_offset, s->upper_motion_limit_offset);
            AvahiLookupFlags *flags;
            const char *domain;
            AvahiServer *s_3;
            if (!s_3->wide_area_lookup_engine ||
                    !avahi_wide_area_has_servers(s_3->wide_area_lookup_engine) ||
                    avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
                    avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
                    avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
                    *flags |= AVAHI_LOOKUP_USE_MULTICAST;
                else
                    *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");
        return AVERROR(EINVAL);
    }
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    fput(filp);
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",0,1,46,0.92,Insert
2325,"static void imx_epit_reset(DeviceState *dev)
{
    IMXEPITState *s = IMX_EPIT(dev);
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    s->lr = TIMER_MAX;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}","static void imx_epit_reset(DeviceState *dev)
{
    int a = 2;
    MpegEncContext *s_2;
    int mb_x, mb_y;
    mb_x = s_2->mb_x;
    int b = 2;
    while (a == b) {
        IMXEPITState *s = IMX_EPIT(dev);
        b += 1;
    }
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    s->lr = TIMER_MAX;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}",0,1,25,0.73,Insert
2326,,,,,,,
2328,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,
        int64_t sector_num, uint8_t *buf, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    RawAIOCB *acb;
    BDRVRawState *s = bs->opaque;
    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {
        QEMUBH *bh;
        acb = qemu_aio_get(bs, cb, opaque);
        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);
        bh = qemu_bh_new(raw_aio_em_cb, acb);
        qemu_bh_schedule(bh);
        return &acb->common;
    }
    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);
    if (!acb)
        return NULL;
    if (aio_read(&acb->aiocb) < 0) {
        qemu_aio_release(acb);
        return NULL;
    }
    return &acb->common;
}","static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,
        int64_t sector_num, uint8_t *buf, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    RawAIOCB *acb;
    BDRVRawState *s = bs->opaque;
    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {
        QEMUBH *bh;
        acb = qemu_aio_get(bs, cb, opaque);
        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);
        bh = qemu_bh_new(raw_aio_em_cb, acb);
        qemu_bh_schedule(bh);
        return &acb->common;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);
        b = a;
    }
    if (!acb)
        return NULL;
    if (aio_read(&acb->aiocb) < 0) {
        qemu_aio_release(acb);
        return NULL;
    }
    return &acb->common;
}",0,1,28,0.8,Insert
2329,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,
    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,
    BdrvRequestFlags flags)
{
    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {
        return -EINVAL;
    }
    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,
                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);
}","static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,
    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,
    BdrvRequestFlags flags)
{
    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {
        int a = 2;
        int b = 3;
        while (a < b) {
            return -EINVAL;
            void *opacity;
            NBDClient *parent = opacity;
            NBDRequest *patch;
            patch = nbd_request_get(parent);
            client_close(parent);
            b = a;
        }
    }
    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,
                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);
}",0,1,5,0.39,Insert
2330,"static void sigchld_handler(int signal)
{
    qemu_bh_schedule(sigchld_bh);
}","static void sigchld_handler(int signal)
{
    unsigned char *sha1;
    void *data;
    unsigned long size;
    struct pbase_tree *it;
    unsigned char tree_sha1[20];
    data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    it = xcalloc(1, sizeof(*it));
    it->pcache.tree_size = size;
    qemu_bh_schedule(sigchld_bh);
}",0,1,4,0.13,Insert
2331,,,,,,,
2333,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)
{
    if (kvm_enabled()) {
        kvm_s390_virtio_irq(cpu, config_change, token);
    } else {
        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);
    }
}","static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)
{
    if (kvm_enabled()) {
        kvm_s390_virtio_irq(cpu, config_change, token);
    } else {
        int a = 83;
        int b = a;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        if(a*b>0){
            cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);
        }
    }
}",0,1,12,0.37,Insert
2335,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,
                const AVIOInterruptCB *int_cb)
{
    URLProtocol *up = NULL;
    char proto_str[128], proto_nested[128], *ptr;
    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);
    if (filename[proto_len] != ':' || is_dos_path(filename))
        strcpy(proto_str, ""file"");
    else
        av_strlcpy(proto_str, filename,
                   FFMIN(proto_len + 1, sizeof(proto_str)));
    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));
    if ((ptr = strchr(proto_nested, '+')))
        *ptr = '\0';
    while (up = ffurl_protocol_next(up)) {
        if (!strcmp(proto_str, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&
            !strcmp(proto_nested, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
    }
    *puc = NULL;
    return AVERROR_PROTOCOL_NOT_FOUND;
}","int ffurl_alloc(URLContext **puc, const char *filename, int flags,
                const AVIOInterruptCB *int_cb)
{
    URLProtocol *up = NULL;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        char proto_str[128], proto_nested[128], *ptr;
    strcpy(str, ""a"");
    }
    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);
    if (filename[proto_len] != ':' || is_dos_path(filename))
        strcpy(proto_str, ""file"");
    else
        av_strlcpy(proto_str, filename,
                   FFMIN(proto_len + 1, sizeof(proto_str)));
    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));
    if ((ptr = strchr(proto_nested, '+')))
        *ptr = '\0';
    while (up = ffurl_protocol_next(up)) {
        if (!strcmp(proto_str, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&
            !strcmp(proto_nested, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
    }
    *puc = NULL;
    return AVERROR_PROTOCOL_NOT_FOUND;
}",0,1,1,0.1,Replace
2336,"BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        return QTAILQ_FIRST(&bdrv_states);
    }
    return QTAILQ_NEXT(bs, device_list);
}","BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return QTAILQ_FIRST(&bdrv_states);
            UHCI_TD *dev;
            uint8_t val;
            val = dev->token & 0xff;
        }
    }
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    return QTAILQ_NEXT(bs, device_list);
}",0,1,50,0.4,Insert
2337,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,
                    uint64_t val, unsigned size)
{
    mcf_uart_state *s = (mcf_uart_state *)opaque;
    switch (addr & 0x3f) {
    case 0x00:
        s->mr[s->current_mr] = val;
        s->current_mr = 1;
        break;
    case 0x04:
        break;
    case 0x08:  
        mcf_do_command(s, val);
        break;
    case 0x0c:  
        s->sr &= ~MCF_UART_TxEMP;
        s->tb = val;
        mcf_uart_do_tx(s);
        break;
    case 0x10:
        break;
    case 0x14:
        s->imr = val;
        break;
    default:
        break;
    }
    mcf_uart_update(s);
}","void mcf_uart_write(void *opaque, target_phys_addr_t addr,
                    uint64_t val, unsigned size)
{
    mcf_uart_state *s = (mcf_uart_state *)opaque;
    switch (addr & 0x3f) {
    case 0x00:
        int a = 2;
        int b = 3;
        struct mr6_table *mrt;
        DescInfo *info;
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        char *buf = desc_get_buf(info, true);
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        struct mem *mem = read_pnet(&mrt->mem);
        atomic_dec(&mrt->cache_resolve_queue_len);
        while (a != b) {
            s->mr[s->current_mr] = val;
            b = a;
        }
        s->current_mr = 1;
        break;
    case 0x04:
        break;
    case 0x08:  
        mcf_do_command(s, val);
        break;
    case 0x0c:  
        s->sr &= ~MCF_UART_TxEMP;
        s->tb = val;
        mcf_uart_do_tx(s);
        break;
    case 0x10:
        break;
    case 0x14:
        s->imr = val;
        break;
    default:
        break;
    }
    mcf_uart_update(s);
}",0,1,90,0.96,Insert
2340,"static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,
                                  unsigned size)
{
    if (size != 2) {
        return omap_badwidth_read16(opaque, addr);
    }
    if (addr == OMAP_MPUI_BASE)	 
        return 0xfe4d;
    OMAP_BAD_REG(addr);
    return 0;
}","static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,
                                  unsigned size)
{
    XMLTreeInfo
    bool use_pubs;
    const struct smb_filename *smb_fhandle;
    uint32_t access_mask;
    struct connection_struct *connected;
    uint32_t rejected_mask = access_mask;
    struct security_descriptor *sd = NULL;
    NTSTATUS success;
    success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
    			(SECINFO_OWNER |
    			SECINFO_GROUP |
    			 SECINFO_DACL), talloc_tos(), &sd);
    success = se_file_access_check(sd,
    				get_current_nttok(connected),
    				use_pubs,
    				(access_mask & ~do_not_check_mask),
    				&rejected_mask);
    TALLOC_FREE(sd);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    quantization_tables=NewXMLTree(xml,exception);
    VirtIODevice *vrdevice;
    BlockConf *conf = &s->conf.conf;
    VirtIOBlock *s = VIRTIO_BLK(vrdevice);
    int blk_size = conf->logical_block_size;
    struct virtio_blk_config blkcfg;
    virtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
    quantization_tables=DestroyXMLTree(quantization_tables);
    if (size != 2) {
        return omap_badwidth_read16(opaque, addr);
    }
    if (addr == OMAP_MPUI_BASE)	 
        return 0xfe4d;
    OMAP_BAD_REG(addr);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    authenc_ahash_t authenc_ahash_fn;
    struct aead_request *req;
    u8 *hash;
    struct crypto_aead *authenc = crypto_aead_reqtfm(req);
    hash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
    }
}",0,1,778,3.88,Insert
2341,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    PCIAC97LinkState *d = opaque;
    AC97LinkState *s = &d->ac97;
    dolog (""U nam writeb %#x <- %#x\n"", addr, val);
    s->cas = 0;
}","static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    PCIAC97LinkState *d = opaque;
    AnimationChannel &context;
    json &o;
    SerializeNumberProperty(""sampler"", context.sampler, o);
    SerializeExtensionMap(context.extensions, o);
    AC97LinkState *s = &d->ac97;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        dolog (""U nam writeb %#x <- %#x\n"", addr, val);
    }
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PCMDecode *s_3 = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    s->cas = 0;
}",0,1,43,0.5,Insert
2342,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    S390FLICState *fs = S390_FLIC_COMMON(dev);
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    fs->ais_supported = true;
}","static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        S390FLICState *fs = S390_FLIC_COMMON(dev);
    }
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    uint64_t glms;
    unsigned k, b_8, err, C;
    unsigned k, b_8, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_8 = ctz64(glms);
    fs->ais_supported = true;
}",0,1,7,0.38,Insert
2343,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)
{
    InputStream  *ist = s->opaque;
    DXVA2Context *ctx = ist->hwaccel_ctx;
    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);
}","static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)
{
    InputStream  *ist = s->opaque;
    int a = 70;
    int b = a;
    if(a*b>0){
        DXVA2Context *ctx = ist->hwaccel_ctx;
    }
    GF_BitStream *bs;
    GF_Box *s_9;
    FilePartitionBox *inter = (FilePartitionBox *)s_9;
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    gf_bs_read_u8(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);
}",0,1,10,0.38,Insert
2345,,,,,,,
2348,"static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,
                                    const int filter_p1, const int filter_q1,
                                    const int alpha, const int beta,
                                    const int lim_p0q0, const int lim_q1,
                                    const int lim_p1)
{
    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,
                          alpha, beta, lim_p0q0, lim_q1, lim_p1);
}","static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,
                                    const int filter_p1, const int filter_q1,
                                    const int alpha, const int beta,
                                    const int lim_p0q0, const int lim_q1,
                                    const int lim_p1)
{
    target_ulong addr;
    int size;
    CPUSPARCState *env;
    helper_check_align(env, addr, size - 1);
    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,
                          alpha, beta, lim_p0q0, lim_q1, lim_p1);
}",1,0,1,0.33,Insert
2351,,,,,,,
2356,"build_hpet(GArray *table_data, GArray *linker)
{
    Acpi20Hpet *hpet;
    hpet = acpi_data_push(table_data, sizeof(*hpet));
    hpet->timer_block_id = cpu_to_le32(0x8086a201);
    hpet->addr.address = cpu_to_le64(HPET_BASE);
    build_header(linker, table_data,
                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);
}","build_hpet(GArray *table_data, GArray *linker)
{
    const char *nptr;
    Rocker *r_8;
    DescInfo *info_2;
    char *buf_10 = desc_get_buf_1(info_2, true);
    RockerTlv *tlvs_6[ROCKER_TLV_TX_MAX_1 + 1];
    char *buf_10 = desc_get_buf_1(info_2, true);
    PCIDevice *dev_7 = PCI_DEVICE_9(r_8);
    RockerTlv *tlvs_6[ROCKER_TLV_TX_MAX_1 + 1];
    uint32_t pport_1;
    rocker_tlv_parse_9(tlvs_6, ROCKER_TLV_TX_MAX_1, buf_10, desc_tlv_size_5(info_2));
    pport_1 = rocker_get_pport_by_tx_ring_4(r_8, desc_get_ring_1(info_2));
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    Acpi20Hpet *hpet;
    int a = 2;
    int b = 3;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    if (a != b) {
        hpet = acpi_data_push(table_data, sizeof(*hpet));
    }
    hpet->timer_block_id = cpu_to_le32(0x8086a201);
    hpet->addr.address = cpu_to_le64(HPET_BASE);
    build_header(linker, table_data,
                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);
}",0,1,86,0.68,Insert
2357,"static inline void downmix_3f_1r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;
    }
}","static inline void downmix_3f_1r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        int a = 2;
        int b = 2;
        GF_Box *s_9;
        GF_BitStream *bs;
        u32 i_2, ch;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_9;
        u32 i_2, ch;
        for (i_2=0; i_2<ch; i_2++) {
        		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i_2);
        		gf_bs_write_u16(bs, isl->size);
        		gf_bs_write_data(bs, isl->data, isl->size);
        }
        if (a == b) {
            samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);
            AVPacket *afpud;
            AVCodecContext *avctx;
            int sample_scale, c, n, i_5;
            int sample_scale, c, n, i_5;
            int buf_size = afpud->size;
            PCMDecode *s = avctx->priv_data;
            sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
            n = avctx->channels * sample_scale;
            n = buf_size/sample_scale;
        }
        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;
    }
}",0,1,41,0.57,Insert
2359,,,,,,,
2361,,,,,,,
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)
{
    uintptr_t ra = GETPC();
    switch (addr & 3) {
    case 3:
        cpu_stb_data_ra(env, addr, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, addr, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, addr, val >> 16, ra);
            cpu_stw_data_ra(env, addr + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, addr, val, ra);
        break;
    }
}","void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)
{
    int a = 39;
    int b = a;
    if(a*b>0){
        uintptr_t ra = GETPC();
    }
    switch (addr & 3) {
    case 3:
        cpu_stb_data_ra(env, addr, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, addr, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, addr, val >> 16, ra);
            cpu_stw_data_ra(env, addr + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, addr, val, ra);
        break;
    }
}",0,1,8,0.14,Replace
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
{
    int64_t scaled_dim;
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    return AVERROR(EINVAL);
}","int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
{
    int64_t scaled_dim;
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct gs_device_mode *dm;
    dm = kmalloc(sizeof(*dm), GFP_KERNEL);
    dm->flags = 0;
    dm->mode = GS_CAN_MODE_START;
    rrc= usb_control_msg(interface_to_usbdev(game->iface),
    			     usb_sndctrlpipe(interface_to_usbdev(game->iface), 0),
    			     GS_USB_BREQ_MODE,
    			     USB_DIR_OUT | USB_TYPE_VENDOR |
    			     USB_RECIP_INTERFACE,
    			     game->channel,
    			     0,
    			     dm,
    			     sizeof(*dm),
    			     1000);
    kfree(dm);
    if (strcmp(str1, str2) == 0) {
        return AVERROR(EINVAL);
    }
}",1,0,15,0.69,Insert
2364,"static void decode_gray_bitstream(HYuvContext *s, int count)
{
    int i;
    OPEN_READER(re, &s->gb);
    count /= 2;
    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {
        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    } else {
        for (i = 0; i < count; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    }
    CLOSE_READER(re, &s->gb);
}","static void decode_gray_bitstream(HYuvContext *s, int count)
{
    int i;
    OPEN_READER(re, &s->gb);
    int a = 2;
    int b = 3;
    while (a < b) {
        count /= 2;
        b = a;
    }
    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {
        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    } else {
        for (i = 0; i < count; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    }
    target_ulong addr;
    unsigned int i_8;
    i_8 = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);
    i_8 = tb_jmp_cache_hash_page(addr);
    CLOSE_READER(re, &s->gb);
}",1,0,14,0.72,Insert
2365,,,,,,,
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)
{
    QemuOpts *opts;
    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);
    if (opts == NULL)
        return NULL;
    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);
    return opts;
}","QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)
{
    QemuOpts *opts;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);
    }
    if (opts == NULL)
        return NULL;
        MagickBooleanType
            jpg,
            status;
        Image
            *feature,
            *tile64memory;
        assert(exchange != (ExceptionInfo *) NULL);
        assert(exchange->signature == MagickCoreSignature);
        feature=AcquireImage(memoryappavailable,exchange);
        status=OpenBlob(memoryappavailable,feature,ReadBinaryBlobMode,exchange);
        status=SetImageExtent(feature,feature->columns,feature->rows,exchange);
    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);
    return opts;
}",1,0,9,0.37,Insert
2369,"static void conditional_branch(DBDMA_channel *ch)
{
    dbdma_cmd *current = &ch->current;
    uint16_t br;
    uint16_t sel_mask, sel_value;
    uint32_t status;
    int cond;
    DBDMA_DPRINTF(""conditional_branch\n"");
    br = le16_to_cpu(current->command) & BR_MASK;
    switch(br) {
    case BR_NEVER:   
        next(ch);
        return;
    case BR_ALWAYS:  
        branch(ch);
        return;
    }
    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
    cond = (status & sel_mask) == (sel_value & sel_mask);
    switch(br) {
    case BR_IFSET:   
        if (cond)
            branch(ch);
        else
            next(ch);
        return;
    case BR_IFCLR:   
        if (!cond)
            branch(ch);
        else
            next(ch);
        return;
    }
}","static void conditional_branch(DBDMA_channel *ch)
{
    dbdma_cmd *current = &ch->current;
    uint16_t br;
    uint16_t sel_mask, sel_value;
    uint32_t status;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int cond;
    }
    DBDMA_DPRINTF(""conditional_branch\n"");
    br = le16_to_cpu(current->command) & BR_MASK;
    switch(br) {
    case BR_NEVER:   
        next(ch);
        return;
    case BR_ALWAYS:  
        branch(ch);
        return;
    }
    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
    cond = (status & sel_mask) == (sel_value & sel_mask);
    switch(br) {
    case BR_IFSET:
        BlockDriverState *bos;
        bos = bdrv_lookup_bs(object, object, NULL);   
        if (cond)
            branch(ch);
        else
            next(ch);
        return;
    case BR_IFCLR:   
        if (!cond)
            branch(ch);
        else
            next(ch);
        return;
    }
}",0,1,33,1.1,Insert
2370,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,
                               Jpeg2000Component *comp,
                               Jpeg2000T1Context *t1, Jpeg2000Band *band)
{
    int i, j;
    int w = cblk->coord[0][1] - cblk->coord[0][0];
    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {
        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];
        int *src = t1->data[j];
        if (band->i_stepsize == 16384) {
            for (i = 0; i < w; ++i)
                datap[i] = src[i] / 2;
        } else {
            for (i = 0; i < w; ++i)
                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;
        }
    }
}","static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,
                               Jpeg2000Component *comp,
                               Jpeg2000T1Context *t1, Jpeg2000Band *band)
{
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int i, j;
    int w = cblk->coord[0][1] - cblk->coord[0][0];
    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {
        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];
        int a = 2;
        int b = 3;
        while (a < b) {
            int *src = t1->data[j];
            b = a;
        }
        if (band->i_stepsize == 16384) {
            for (i = 0; i < w; ++i)
                datap[i] = src[i] / 2;
        } else {
            for (i = 0; i < w; ++i)
                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;
        }
    }
}",0,1,21,1.08,Insert
2371,,,,,,,
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)
{
    assert(!error_is_set(errp));
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}","void visit_end_implicit_struct(Visitor *v, Error **errp)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        assert(!error_is_set(errp));
    strcpy(str, ""a"");
    }
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}",1,0,6,0.35,Insert
2377,"static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)
{
    int ret;
    assert(client->optlen);
    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {
        return -EIO;
    }
    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,
                                     ""option '%s' should have zero length"",
                                     nbd_opt_lookup(client->opt));
    if (fatal && !ret) {
        error_setg(errp, ""option '%s' should have zero length"",
                   nbd_opt_lookup(client->opt));
        return -EINVAL;
    }
    return ret;
}","static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)
{
    int ret;
    assert(client->optlen);
    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {
        return -EIO;
    }
    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,
                                     ""option '%s' should have zero length"",
                                     nbd_opt_lookup(client->opt));
    if (fatal && !ret) {
        error_setg(errp, ""option '%s' should have zero length"",
                   nbd_opt_lookup(client->opt));
        int a = 2;
        uint32_t *pal;
        SwsContext *c;
        const uint8_t *src_in[4];
        uint8_t *formatConvBuffer;
        int isAlpha;
        int srcW;
        void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;
        const uint8_t *src = src_in[isAlpha ? 3 : 0];
        void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;
        const uint8_t *src = src_in[isAlpha ? 3 : 0];
        void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;
        if (toYV12) {
                toYV12(formatConvBuffer, src, srcW, pal);
                src= formatConvBuffer;
            } else if (c->readLumPlanar && !isAlpha) {
                c->readLumPlanar(formatConvBuffer, src_in, srcW);
                src = formatConvBuffer;
        }
        int b = 3;
        while (a != b) {
            return -EINVAL;
            b = a;
        }
    }
    return ret;
}",1,0,11,0.64,Insert
2378,,,,,,,
2380,"opts_visitor_cleanup(OptsVisitor *ov)
{
    if (ov->unprocessed_opts != NULL) {
        g_hash_table_destroy(ov->unprocessed_opts);
    }
    g_free(ov->fake_id_opt);
    memset(ov, '\0', sizeof *ov);
}","opts_visitor_cleanup(OptsVisitor *ov)
{
    if (ov->unprocessed_opts != NULL) {
        g_hash_table_destroy(ov->unprocessed_opts);
    }
    g_free(ov->fake_id_opt);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        memset(ov, '\0', sizeof *ov);
    }
}",1,0,1,0.04,Replace
2384,"static void imx_gpt_reset(DeviceState *dev)
{
    IMXGPTState *s = IMX_GPT(dev);
    ptimer_stop(s->timer);
    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|
               GPT_CR_WAITEN|GPT_CR_DBGEN);
    s->sr = 0;
    s->pr = 0;
    s->ir = 0;
    s->cnt = 0;
    s->ocr1 = TIMER_MAX;
    s->ocr2 = TIMER_MAX;
    s->ocr3 = TIMER_MAX;
    s->icr1 = 0;
    s->icr2 = 0;
    s->next_timeout = TIMER_MAX;
    s->next_int = 0;
    imx_gpt_set_freq(s);
    ptimer_set_limit(s->timer, TIMER_MAX, 1);
    if (s->freq && (s->cr & GPT_CR_EN)) {
        ptimer_run(s->timer, 1);
    }
}","static void imx_gpt_reset(DeviceState *dev)
{
    int a = 57;
    int b = a;
    if(a*b>0){
        IMXGPTState *s = IMX_GPT(dev);
    }
    ptimer_stop(s->timer);
    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|
               GPT_CR_WAITEN|GPT_CR_DBGEN);
    s->sr = 0;
    s->pr = 0;
    s->ir = 0;
    s->cnt = 0;
    s->ocr1 = TIMER_MAX;
    s->ocr2 = TIMER_MAX;
    s->ocr3 = TIMER_MAX;
    s->icr1 = 0;
    s->icr2 = 0;
    s->next_timeout = TIMER_MAX;
    s->next_int = 0;
    imx_gpt_set_freq(s);
    ptimer_set_limit(s->timer, TIMER_MAX, 1);
    if (s->freq && (s->cr & GPT_CR_EN)) {
        ptimer_run(s->timer, 1);
    }
}",0,1,1,0.11,Replace
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)
{
    struct sigevent ev;
    timer_t host_timer;
    struct sigaction act;
    sigfillset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = host_alarm_handler;
    sigaction(SIGALRM, &act, NULL);
    ev.sigev_value.sival_int = 0;
    ev.sigev_notify = SIGEV_SIGNAL;
    ev.sigev_signo = SIGALRM;
    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {
        perror(""timer_create"");
        fprintf(stderr, ""Dynamic Ticks disabled\n"");
        return -1;
    }
    t->priv = (void *)(long)host_timer;
    return 0;
}","static int dynticks_start_timer(struct qemu_alarm_timer *t)
{
    struct sigevent ev;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        timer_t host_timer;
    }
    struct sigaction act;
    sigfillset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = host_alarm_handler;
    sigaction(SIGALRM, &act, NULL);
    ev.sigev_value.sival_int = 0;
    ev.sigev_notify = SIGEV_SIGNAL;
    ev.sigev_signo = SIGALRM;
    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {
        perror(""timer_create"");
        fprintf(stderr, ""Dynamic Ticks disabled\n"");
        return -1;
    }
    t->priv = (void *)(long)host_timer;
    return 0;
}",1,0,4,0.12,Replace
2386,,,,,,,
2389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,
                                           TCGv arg1, TCGv arg2, int sub)
{
    TCGv t0 = tcg_temp_new();
    tcg_gen_xor_tl(cpu_ov, arg0, arg1);
    tcg_gen_xor_tl(t0, arg1, arg2);
    if (sub) {
        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);
    } else {
        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);
    }
    tcg_temp_free(t0);
    if (NARROW_MODE(ctx)) {
        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);
    }
    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);
    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);
}","static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,
                                           TCGv arg1, TCGv arg2, int sub)
{
    gchar *str_5, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
    fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    fail_unless (date_times_are_equal (dt, dt2));
    str2 = gst_date_time_to_iso8601_string (dt2);
    gst_date_time_unref (dt2);
    TCGv t0 = tcg_temp_new();
    tcg_gen_xor_tl(cpu_ov, arg0, arg1);
    tcg_gen_xor_tl(t0, arg1, arg2);
    if (sub) {
        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);
        CPULM32State *env;
        int i;
        qemu_irq irq[32];
        for (i = 0; i < 32; i++) {
                irq[i] = qdev_get_gpio_in(env->pic_state, i);
        }
    } else {
        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);
    }
    tcg_temp_free(t0);
    if (NARROW_MODE(ctx)) {
        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);
    }
    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);
}",1,0,49,0.78,Insert
2391,,,,,,,
2392,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,
                      int abort_on_failure)
{
    QemuOpts *opts;
    int rc = 0;
    TAILQ_FOREACH(opts, &list->head, next) {
        rc = func(opts, opaque);
        if (abort_on_failure  &&  rc != 0)
            break;
    }
    return rc;
}","int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,
                      int abort_on_failure)
{
    hwaddr array;
    Unit *other;
    assert(other);
    PowerPCCPU *cpu;
    bool use_pubs;
    const struct smb_filename *smb_fhandle;
    uint32_t access_mask;
    struct connection_struct *connected;
    uint32_t rejected_mask = access_mask;
    struct security_descriptor *sd = NULL;
    NTSTATUS success;
    success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
    			(SECINFO_OWNER |
    			SECINFO_GROUP |
    			 SECINFO_DACL), talloc_tos(), &sd);
    success = se_file_access_check(sd,
    				get_current_nttok(connected),
    				use_pubs,
    				(access_mask & ~do_not_check_mask),
    				&rejected_mask);
    TALLOC_FREE(sd);
    u8 * Datapp;
    struct wmi_disconnect_event *dev;
    char cont[DESC_SIZE + 1];
    cont[DESC_SIZE] = '\0';
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    dev = (struct wmi_disconnect_event *)  Datapp;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    CPUPPCState *viron = &cpu->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu, pte_index);
    QemuOpts *opts;
    int rc_part1 = -6;
    int rc_part2 = 6;
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    int rc = rc_part1 + rc_part2;
    TAILQ_FOREACH(opts, &list->head, next) {
        rc = func(opts, opaque);
        if (abort_on_failure  &&  rc != 0)
            break;
    }
    return rc;
}",0,1,220,1.28,Insert
2393,"static void subpage_write(void *opaque, target_phys_addr_t addr,
                          uint64_t value, unsigned len)
{
    subpage_t *mmio = opaque;
    unsigned int idx = SUBPAGE_IDX(addr);
    MemoryRegionSection *section;
#if defined(DEBUG_SUBPAGE)
    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx
           "" idx %d value %""PRIx64""\n"",
           __func__, mmio, len, addr, idx, value);
#endif
    section = &phys_sections[mmio->sub_section[idx]];
    addr += mmio->base;
    addr -= section->offset_within_address_space;
    addr += section->offset_within_region;
    io_mem_write(section->mr, addr, value, len);
}","static void subpage_write(void *opaque, target_phys_addr_t addr,
                          uint64_t value, unsigned len)
{
    const char *data;
    hwaddr array;
    PowerPCCPU *cpu;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value_6;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value_6=InterpretLocaleValue(content,&p);
    CPUPPCState *viron = &cpu->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu, pte_index);
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    subpage_t *mmio = opaque;
    unsigned int idx = SUBPAGE_IDX(addr);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        MemoryRegionSection *section;
    }
#if defined(DEBUG_SUBPAGE)
    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx
           "" idx %d value %""PRIx64""\n"",
           __func__, mmio, len, addr, idx, value);
#endif
    section = &phys_sections[mmio->sub_section[idx]];
    addr += mmio->base;
    addr -= section->offset_within_address_space;
    addr += section->offset_within_region;
    void *opacity;
    NBDClient *parent = opacity;
    NBDRequest *patch;
    patch = nbd_request_get(parent);
    client_close(parent);
    io_mem_write(section->mr, addr, value, len);
}",0,1,107,1.15,Insert
2394,,,,,,,
2395,,,,,,,
2396,"DeviceState *bdrv_get_attached(BlockDriverState *bs)
{
    return bs->peer;
}","DeviceState *bdrv_get_attached(BlockDriverState *bs)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        return bs->peer;
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        b = a;
    }
}",0,1,15,0.25,Insert
2397,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    if (value == NULL) {
        e->is_list_head = true;
    }
    QTAILQ_INSERT_HEAD(&qov->stack, e, node);
}","static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e_7;
    e_7 = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    if (value == NULL) {
        e->is_list_head = true;
        GetBitContext *db;
        int profile_lengtho, level_idc, constraint_set_flags = 0;
        SPS * spr;
        profile_lengtho           = get_bits(db, 8);
        spr->profile_lengtho          = profile_lengtho;
    }
    QTAILQ_INSERT_HEAD(&qov->stack, e, node);
}",0,1,40,0.45,Insert
2398,,,,,,,
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,
                            FWCfgState *fw_cfg, Object *owner)
{
    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,
                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);
    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);
    state->dsm_mem = g_array_new(false, true  , 1);
    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,
                    state->dsm_mem->len);
}","void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,
                            FWCfgState *fw_cfg, Object *owner)
{
    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,
                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);
    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);
    char str[] = ""Constant"";
    ParseContext *comp;
    uint32_t state_7= comp->state_7;
    uint32_t state_7= comp->state_7;
    comp->state_7= state_7;
    while (strlen(str) > 5) {
        state->dsm_mem = g_array_new(false, true  , 1);
    strcpy(str, ""a"");
    }
    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,
                    state->dsm_mem->len);
}",0,1,7,0.47,Insert
2402,"static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)
{
    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,
                       get_field(qtd->token, QTD_TOKEN_TBYTES),
                       get_field(qtd->token, QTD_TOKEN_CPAGE),
                       get_field(qtd->token, QTD_TOKEN_CERR),
                       get_field(qtd->token, QTD_TOKEN_PID),
                       (bool)(qtd->token & QTD_TOKEN_IOC),
                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),
                       (bool)(qtd->token & QTD_TOKEN_HALT),
                       (bool)(qtd->token & QTD_TOKEN_BABBLE),
                       (bool)(qtd->token & QTD_TOKEN_XACTERR));
}","static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)
{
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    fail_unless (!gst_date_time_has_month (dt));
    fail_unless (!gst_date_time_has_day (dt));
    fail_unless (!gst_date_time_has_time (dt));
    fail_unless (!gst_date_time_has_second (dt));
    str = gst_date_time_to_iso8601_string (dt);
    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,
                       get_field(qtd->token, QTD_TOKEN_TBYTES),
                       get_field(qtd->token, QTD_TOKEN_CPAGE),
                       get_field(qtd->token, QTD_TOKEN_CERR),
                       get_field(qtd->token, QTD_TOKEN_PID),
                       (bool)(qtd->token & QTD_TOKEN_IOC),
                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),
                       (bool)(qtd->token & QTD_TOKEN_HALT),
                       (bool)(qtd->token & QTD_TOKEN_BABBLE),
                       (bool)(qtd->token & QTD_TOKEN_XACTERR));
}",1,0,9,0.62,Insert
2403,,,,,,,
2406,,,,,,,
2407,"static void vararg_number(void)
{
    QObject *obj;
    QInt *qint;
    QFloat *qfloat;
    int value = 0x2342;
    int64_t value64 = 0x2342342343LL;
    double valuef = 2.323423423;
    obj = qobject_from_jsonf(""%d"", value);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%"" PRId64, value64);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value64);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%f"", valuef);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QFLOAT);
    qfloat = qobject_to_qfloat(obj);
    g_assert(qfloat_get_double(qfloat) == valuef);
    QDECREF(qfloat);
}","static void vararg_number(void)
{
    QObject *obj;
    QInt *qint;
    QFloat *qfloat;
    int value = 0x2342;
    int64_t value64 = 0x2342342343LL;
    double valuef = 2.323423423;
    obj = qobject_from_jsonf(""%d"", value);
    g_assert(obj != NULL);
    int a = 2;
    int b = 3;
    while (a < b) {
        g_assert(qobject_type(obj) == QTYPE_QINT);
        b = a;
    }
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%"" PRId64, value64);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value64);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%f"", valuef);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QFLOAT);
    void *opaques;
    V9fsPDU *pdf = opaques;
    V9fsString part;
    int32_t fpaid, newcids;
    size_t offset = 7;
    int32_t fpaid, newcids;
    pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    qfloat = qobject_to_qfloat(obj);
    g_assert(qfloat_get_double(qfloat) == valuef);
    QDECREF(qfloat);
}",0,1,49,1.09,Insert
2409,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)
{
    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);
    object_unparent(OBJECT(&pbdev->iommu_mr));
    pbdev->iommu_enabled = false;
}","void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)
{
    int a = 2;
    int b = 3;
    struct socket *sock;
    int protocol;
    struct object *object;
    struct sock *ock;
    struct sock *ock;
    ock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);
    if (a != b) {
        memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);
    }
    object_unparent(OBJECT(&pbdev->iommu_mr));
    pbdev->iommu_enabled = false;
}",0,1,9,0.31,Insert
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        uc->prot->url_open(uc, uc->filename, uc->flags);
    if (err)
        return err;
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->is_streamed = 1;
    return 0;
}","int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        uc->prot->url_open(uc, uc->filename, uc->flags);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i;
        for (i=0;i < inter->nb_entries; i++) {
        		inter->entries[i].block_count = gf_bs_read_u16(bs);
        		inter->entries[i].block_size = gf_bs_read_u32(bs);
        }
    if (err)
        return err;
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->is_streamed = 1;
    int a = 2;
    int b = 2;
    if (a == b) {
        return 0;
    }
}",0,1,14,0.68,Insert
2412,"static void test_visitor_out_int(TestOutputVisitorData *data,
                                 const void *unused)
{
    int64_t value = -42;
    QObject *obj;
    visit_type_int(data->ov, NULL, &value, &error_abort);
    obj = visitor_get(data);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);
}","static void test_visitor_out_int(TestOutputVisitorData *data,
                                 const void *unused)
{
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b     = s->b;
    if (size & 1)
            avio_w8(b, 0);
    int64_t value = -42;
    QObject *obj;
    visit_type_int(data->ov, NULL, &value, &error_abort);
    obj = visitor_get(data);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);
    }
}",0,1,34,0.58,Insert
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &rdma_read_ops);
    }
    return r->file;
}","static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_year (dt) == 2010);
    fail_unless (!gst_date_time_has_month (dt));
    fail_unless (!gst_date_time_has_day (dt));
    fail_unless (!gst_date_time_has_time (dt));
    gst_date_time_unref (dt);
    if (strcmp(str1, str2) == 0) {
        QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));
    }
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &rdma_read_ops);
    }
    return r->file;
}",1,0,13,0.39,Insert
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)
{
    avctx->subtitle_header = av_malloc(avctx->extradata_size);
    if (!avctx->extradata)
        return AVERROR(ENOMEM);
    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
    avctx->subtitle_header_size = avctx->extradata_size;
    return 0;
}","static av_cold int ass_decode_init(AVCodecContext *avctx)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        avctx->subtitle_header = av_malloc(avctx->extradata_size);
        b += 1;
    }
    if (!avctx->extradata)
        return AVERROR(ENOMEM);
    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
    avctx->subtitle_header_size = avctx->extradata_size;
    return 0;
}",0,1,1,0.05,Replace
2422,,,,,,,
2423,"void bdrv_drain(BlockDriverState *bs)
{
    bool busy = true;
    bdrv_drain_recurse(bs);
    while (busy) {
         bdrv_flush_io_queue(bs);
         busy = bdrv_requests_pending(bs);
         busy |= aio_poll(bdrv_get_aio_context(bs), busy);","void bdrv_drain(BlockDriverState *bs)
{
    bool busy = true;
    bdrv_drain_recurse(bs);
    while (busy) {
         int a = 2;
         int b = 3;
         while (a != b) {
             bdrv_flush_io_queue(bs);
             b = a;
         }
         busy = bdrv_requests_pending(bs);
         busy |= aio_poll(bdrv_get_aio_context(bs), busy);",1,0,1,0.04,Replace
2426,"static void print_features(FILE *f,
                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            if (prefix)
                (*cpu_fprintf)(f, ""%s"", prefix);
            (*cpu_fprintf)(f, ""%s "", feature_name[i]);
        }
}","static void print_features(FILE *f,
                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            SysBusDevice *b;
            if (i_1) {
                    sysbus_mmio_map(b, 0, i_1);
            }
            if (prefix)
                (*cpu_fprintf)(f, ""%s"", prefix);
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                (*cpu_fprintf)(f, ""%s "", feature_name[i]);
            strcpy(str, ""a"");
            }
        }
}",0,1,6,0.65,Insert
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,
                                            const char *name,
                                            Error **errp)
{
    QObject *qobj;
    QString *qstr;
    qobj = qobject_input_get_object(qiv, name, true, errp);
    if (!qobj) {
        return NULL;
    }
    qstr = qobject_to_qstring(qobj);
    if (!qstr) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,
                   full_name(qiv, name), ""string"");
        return NULL;
    }
    return qstring_get_str(qstr);
}","static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,
                                            const char *name,
                                            Error **errp)
{
    QObject *qobj;
    QString *qstr;
    int a = 2;
    int b = 3;
    while (a < b) {
        qobj = qobject_input_get_object(qiv, name, true, errp);
        b = a;
    }
    if (!qobj) {
        return NULL;
    }
    qstr = qobject_to_qstring(qobj);
    if (!qstr) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,
                   full_name(qiv, name), ""string"");
        return NULL;
    }
    return qstring_get_str(qstr);
}",1,0,9,0.14,Replace
2429,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;","static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        int a = 2;
        int b = 2;
        if (a == b) {
            TCGv_i32 px;
            DisasContext *ctx;
            store_reg(ctx, 15, px);
            closesocket(ioc->fd);
        }
        ioc->fd = -1;",1,0,8,0.32,Insert
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_int(v, obj, name, errp);
    }
}","void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)
{
    opj_pi_iterator_t * lp;
    opj_pi_resolution_t *res = NULL;
    opj_pi_comp_t *comp = NULL;
    if (!lp->first) {
            comp = &lp->comps[lp->compno];
            res = &comp->resolutions[lp->resno];
            goto LABEL_SKIP;
        } else {
            lp->first = 0;
    }
    if (!error_is_set(errp)) {
        int a = 2;
        int b = 3;
        if (a != b) {
            v->type_int(v, obj, name, errp);
        }
    }
}",1,0,31,0.5,Insert
2434,"static av_cold int pam_encode_close(AVCodecContext *avctx)
{
    av_frame_free(&avctx->coded_frame);
    return 0;
}","static av_cold int pam_encode_close(AVCodecContext *avctx)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        av_frame_free(&avctx->coded_frame);
        const AVFrame *capt;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        const AVFrame *const p = capt;
        uint8_t *last = NULL;
        uint8_t *zero = NULL;
        zero = last = av_mallocz(p->linesize[0]);
        b = a;
    }
    AnimationChannel &context;
    json &o;
    SerializeNumberProperty(""sampler"", context.sampler, o);
    SerializeExtensionMap(context.extensions, o);
    return 0;
}",0,1,65,0.53,Insert
2439,"static char *check_nan_suffix(char *s)
{
    char *start = s;
    if (*s++ != '(')
        return start;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
    return *s == ')' ? s + 1 : start;
}","static char *check_nan_suffix(char *s)
{
    char *start = s;
    if (*s++ != '(')
        return start;
        AnimationChannel &context;
        json &o;
        if (context.extras.Type() != NULL_TYPE) {
            SerializeValue(""extras"", context.extras, o);
        }
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        int a = 2;
        int b = 3;
        while (a != b) {
            s++;
            b = a;
        }
    return *s == ')' ? s + 1 : start;
}",0,1,11,0.57,Insert
2444,,,,,,,
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    EnumProperty *prop = opaque;
    int value;
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
    prop->set(obj, value, errp);
}","static void property_set_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        void *operque;
        IDEState *http = operque;
        int v_1;
        if (v_1 > http->nsector) {
                v_1 = http->nsector;
                stay_active = true;
        }
        EnumProperty *prop = opaque;
    }
    int value;
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
    prop->set(obj, value, errp);
}",1,0,9,0.51,Insert
2446,"void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,
                            int mb_x, int mb_y, uint8_t *img_y,
                            uint8_t *img_cb, uint8_t *img_cr,
                            unsigned int linesize, unsigned int uvlinesize)
{
    assert(!FRAME_MBAFF(h));
    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {
        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
        return;
    }
#if CONFIG_SMALL
    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);
#else
    if(h->pixel_shift){
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);
    }else{
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);
    }
#endif
}","void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,
                            int mb_x, int mb_y, uint8_t *img_y,
                            uint8_t *img_cb, uint8_t *img_cr,
                            unsigned int linesize, unsigned int uvlinesize)
{
    assert(!FRAME_MBAFF(h));
    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {
        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
        return;
    }
#if CONFIG_SMALL

struct dir *dir;
struct proc_mounts *p = dir->private_data;
if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);
    strcpy(str, ""a"");
    }
#else
    if(h->pixel_shift){
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);
    }else{
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);
    }
#endif
}",0,1,21,0.96,Insert
2447,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)
{
    Error *local_err = NULL;
    int rc;
    if (!has_force) {
        force = false;
    }
    rc = do_open_tray(device, force, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (rc == EINPROGRESS) {
        error_setg(errp, ""Device '%s' is locked and force was not specified, ""
                   ""wait for tray to open and try again"", device);
        return;
    }
    qmp_x_blockdev_remove_medium(device, errp);
}","void qmp_eject(const char *device, bool has_force, bool force, Error **errp)
{
    Error *local_err = NULL;
    int rc;
    if (!has_force) {
        force = false;
    }
    rc = do_open_tray(device, force, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (rc == EINPROGRESS) {
        error_setg(errp, ""Device '%s' is locked and force was not specified, ""
                   ""wait for tray to open and try again"", device);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    qmp_x_blockdev_remove_medium(device, errp);
}",0,1,3,0.11,Replace
2448,"int check_prot(int prot, int rw, int access_type)
{
    int ret;
    if (access_type == ACCESS_CODE) {
        if (prot & PAGE_EXEC) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else if (rw) {
        if (prot & PAGE_WRITE) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else {
        if (prot & PAGE_READ) {
            ret = 0;
        } else {
            ret = -2;
        }
    }
    return ret;
}","int check_prot(int prot, int rw, int access_type)
{
    int ret;
    if (access_type == ACCESS_CODE) {
        if (prot & PAGE_EXEC) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else if (rw) {
        if (prot & PAGE_WRITE) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else {
        if (prot & PAGE_READ) {
            ret = 0;
        } else {
            ret = -2;
        }
        AVPacket * pk;
        AVFormatContext *s;
        int size               =  pk->size;
        AVIOContext *b_3     = s->b_3;
        if (size & 1)
                avio_w8(b_3, 0);
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        return ret;
    }
}",0,1,20,0.55,Insert
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        sigset_t host_set;
    strcpy(str, ""a"");
    }
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",1,0,2,0.08,Replace
2455,"static void press_key(VncState *vs, int keysym)
{
    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
    qemu_input_event_send_key_delay(0);
}","static void press_key(VncState *vs, int keysym)
{
    int a = 2;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_10;
    a_10 = ldb_schema_attribute_by_name(ydm, attr);
    int b = 3;
    while (a != b) {
        int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
        b = a;
    }
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    union blkif_back_rings *blk_rings;
    blk_rings->common.rsp_prod_pvt++;
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
    qemu_input_event_send_key_delay(0);
}",0,1,41,0.57,Insert
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
    int i;
    int dc0, dc2;
    pixel4 dc0splat, dc2splat;
    pixel *src = (pixel*)_src;
    stride /= sizeof(pixel);
    dc0=dc2=0;
    for(i=0;i<4; i++){
        dc0+= src[-1+i*stride];
        dc2+= src[-1+(i+4)*stride];
    }
    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
    for(i=0; i<4; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc0splat;
    }
    for(i=4; i<8; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc2splat;
    }
}","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
    int i;
    int dc0, dc2;
    pixel4 dc0splat, dc2splat;
    pixel *src = (pixel*)_src;
    stride /= sizeof(pixel);
    dc0=dc2=0;
    for(i=0;i<4; i++){
        dc0+= src[-1+i*stride];
        char str[] = ""Constant"";
        TensorShape filter_shape;
        Pender pre_transformed_filter_backprop;
        ConvBackpropDimensions sims;
        const Pender& input = package->input(0);
        Pender* filter_backprop;
        OP_REQUIRES_OK(
                package,
                ConvBackpropComputeDimensionsV2(
                    ""Conv3DBackpropFilterOp"",  3, input_shape,
                    filter_shape, out_backprop_shape, dilation_, stride_, padding_,
                     {}, data_format_, &sims));
        OP_REQUIRES_OK(package,
                           package->allocate_output(0, filter_shape, &filter_backprop));
        * stream = package->op_device_context()->stream();
        OP_REQUIRES(package, stream, errors::Internal(""No GPU stream available.""));
        OP_REQUIRES_OK(package,
                           package->allocate_temp(DataTypeToEnum<T>::value, dst_shape,
                                                  &pre_transformed_filter_backprop));
        if (strlen(str) > 0) {
            dc2+= src[-1+(i+4)*stride];
        }
    }
    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
    for(i=0; i<4; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc0splat;
    }
    for(i=4; i<8; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc2splat;
    }
}",1,0,45,1.22,Insert
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,
                           const uint8_t *sps_pps, uint32_t sps_pps_size,
                           const uint8_t *in,      uint32_t in_size) {
    uint32_t offset = *poutbuf_size;
    uint8_t nal_header_size = offset ? 3 : 4;
    *poutbuf_size += sps_pps_size+in_size+nal_header_size;
    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);
    if (sps_pps)
        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);
    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);
    if (!offset)
        AV_WB32(*poutbuf+sps_pps_size, 1);
    else {
        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;
        (*poutbuf+offset)[2] = 1;
    }
}","static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,
                           const uint8_t *sps_pps, uint32_t sps_pps_size,
                           const uint8_t *in,      uint32_t in_size) {
    uint32_t offset = *poutbuf_size;
    uint8_t nal_header_size = offset ? 3 : 4;
    *poutbuf_size += sps_pps_size+in_size+nal_header_size;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        *poutbuf = av_realloc(*poutbuf, *poutbuf_size);
    }
    if (sps_pps)
        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);
    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);
    if (!offset)
        AV_WB32(*poutbuf+sps_pps_size, 1);
    else {
        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;
        (*poutbuf+offset)[2] = 1;
    }
}",1,0,13,0.16,Replace
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)
{
    union av_intfloat32 x, y;
    x.f = a;
    y.f = b;
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.i - y.i) <= max_ulp)
        return 1;
    return 0;
}","int float_near_ulp(float a, float b, unsigned max_ulp)
{
    union av_intfloat32 x, y;
    x.f = a;
    y.f = b;
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.i - y.i) <= max_ulp)
        return 1;
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        return 0;
    strcpy(str_1, ""a"");
    }
}",0,1,11,0.54,Insert
2461,,,,,,,
2464,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)
{
    ff_wmv2_idct_c(block);
    put_pixels_clamped_c(block, dest, line_size);
}","static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)
{
    int16_t offset;
    int rt;
    int base;
    const char *opn = ""st_cond"";
    (void)opn;
    MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);
    int a = 2;
    int b = 2;
    while (a == b) {
        ff_wmv2_idct_c(block);
        b += 1;
    }
    put_pixels_clamped_c(block, dest, line_size);
}",1,0,5,0.37,Insert
2467,"static void write_target_close(BlockDriverState *bs) {
    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);
    bdrv_delete(s->qcow);
    free(s->qcow_filename);
}","static void write_target_close(BlockDriverState *bs) {
    WriterContext *w;
    InputStream *ist;
    const char *s_5;
    AVCodecParameters *par;
    AVStream *stream = ist->st;
    par     = stream->codecpar;
    s_5 = av_get_media_type_string(par->codec_type);
    print_str(""codec_tag_string"",    av_fourcc2str(par->codec_tag));
    print_fmt(""codec_tag"", ""0x%04""PRIx32, par->codec_tag);
    writer_print_data_hash(w, ""extradata_hash"", par->extradata,
                                                    par->extradata_size);
    int a = 2;
    int b = 2;
    while (a == b) {
        BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);
        b += 1;
    }
    bdrv_delete(s->qcow);
    free(s->qcow_filename);
}",1,0,9,0.28,Insert
2468,"static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;","static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int a = 2;
    int b = 2;
    while (a == b) {
        int res, size;
        b += 1;
    }
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;",1,0,2,0.14,Replace
2470,"static void dec_modu(DisasContext *dc)
{
    int l1;
    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);
    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
        t_gen_illegal_insn(dc);
        return;
    }
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
    tcg_gen_movi_tl(cpu_pc, dc->pc);
    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
    gen_set_label(l1);
    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
}","static void dec_modu(DisasContext *dc)
{
    int l1;
    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);
    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
        int a = 2;
        int b = 3;
        if (a != b) {
            t_gen_illegal_insn(dc);
        }
        return;
    }
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
    tcg_gen_movi_tl(cpu_pc, dc->pc);
    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
    gen_set_label(l1);
    MachineState *machine;
    int i;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    PowerPCCPU *cpu;
    for (i = 0; i < smp_cpus; i++) {
            cpu = cpu_ppc_init(machine->cpu_model);
            if (cpu == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu, &error_fatal);
    }
    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
}",0,1,44,0.8,Insert
2471,"static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);
}","static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
    int a = 2;
    int b = 2;
    while (a == b) {
        S390CPU *console;
        Error *order = NULL;
        console = cpu_s390x_create(cpu_model, &order);
        return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);
        hwaddr array;
        BlockDriverState *bs;
        assert(!bs->job);
        assert(bdrv_op_blocker_is_empty(bs));
        assert(!bs->refcnt);
        assert(QLIST_EMPTY(&bs->dirty_bitmaps));
        bdrv_close(bs);
        PowerPCCPU *cpu;
        uint64_t request;
        target_ulong pte_index;
        CPUPPCState *viron = &cpu->viron;
        CPUPPCState *viron = &cpu->viron;
        pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
        request = ppc_hash64_start_access(cpu, pte_index);
        b += 1;
    }
}",0,1,110,0.82,Insert
2474,,,,,,,
2477,"static int ram_block_enable_notify(const char *block_name, void *host_addr,
                                   ram_addr_t offset, ram_addr_t length,
                                   void *opaque)
{
    MigrationIncomingState *mis = opaque;
    struct uffdio_register reg_struct;
    reg_struct.range.start = (uintptr_t)host_addr;
    reg_struct.range.len = length;
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {
        error_report(""%s userfault register: %s"", __func__, strerror(errno));
    return 0;","static int ram_block_enable_notify(const char *block_name, void *host_addr,
                                   ram_addr_t offset, ram_addr_t length,
                                   void *opaque)
{
    MigrationIncomingState *mis = opaque;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        struct uffdio_register reg_struct;
    }
    reg_struct.range.start = (uintptr_t)host_addr;
    reg_struct.range.len = length;
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {
        error_report(""%s userfault register: %s"", __func__, strerror(errno));
    return 0;",1,0,1,0.07,Replace
2479,,,,,,,
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)
{
    av_assert2(p < end);
    end-=2;
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    return end+2;
}","const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)
{
    av_assert2(p < end);
    struct mr6_table *mrt;
    struct mem *mem = read_pnet(&mrt->mem);
    atomic_dec(&mrt->cache_resolve_queue_len);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        end-=2;
    strcpy(str, ""a"");
    }
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    int nb_sectors;
    BlockDriverState *bs;
    int64_t  sector_id;
    int pet;
    BlockDriver *drv = bs->drv;
    pet = bdrv_check_request(bs,  sector_id, nb_sectors);
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    return end+2;
}",0,1,68,0.94,Insert
2484,"static void cpu_set_irq(void *opaque, int irq, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);
        env->halted = 0;
        env->pil_in |= 1 << irq;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);
        env->pil_in &= ~(1 << irq);
        cpu_check_irqs(env);
    }
}","static void cpu_set_irq(void *opaque, int irq, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);
        env->halted = 0;
        env->pil_in |= 1 << irq;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);
        env->pil_in &= ~(1 * (2**irq));
        cpu_check_irqs(env);
    }
}",0,1,10,0.12,Replace
2485,"static int get_stream_blocksize(BlockDriverState *bdrv)
{
    uint8_t cmd[6];
    uint8_t buf[12];
    uint8_t sensebuf[8];
    sg_io_hdr_t io_header;
    int ret;
    memset(cmd, 0, sizeof(cmd));
    memset(buf, 0, sizeof(buf));
    cmd[0] = MODE_SENSE;
    cmd[4] = sizeof(buf);
    memset(&io_header, 0, sizeof(io_header));
    io_header.interface_id = 'S';
    io_header.dxfer_direction = SG_DXFER_FROM_DEV;
    io_header.dxfer_len = sizeof(buf);
    io_header.dxferp = buf;
    io_header.cmdp = cmd;
    io_header.cmd_len = sizeof(cmd);
    io_header.mx_sb_len = sizeof(sensebuf);
    io_header.sbp = sensebuf;
    io_header.timeout = 6000;  
    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
    if (ret < 0 || io_header.driver_status || io_header.host_status) {
        return -1;
    }
    return (buf[9] << 16) | (buf[10] << 8) | buf[11];
}","static int get_stream_blocksize(BlockDriverState *bdrv)
{
    uint8_t cmd[6];
    uint8_t buf[12];
    uint8_t sensebuf[8];
    sg_io_hdr_t io_header;
    int a = 24;
    int b = a;
    if(a*b>0){
        int ret;
    }
    memset(cmd, 0, sizeof(cmd));
    memset(buf, 0, sizeof(buf));
    cmd[0] = MODE_SENSE;
    cmd[4] = sizeof(buf);
    memset(&io_header, 0, sizeof(io_header));
    io_header.interface_id = 'S';
    io_header.dxfer_direction = SG_DXFER_FROM_DEV;
    io_header.dxfer_len = sizeof(buf);
    io_header.dxferp = buf;
    io_header.cmdp = cmd;
    io_header.cmd_len = sizeof(cmd);
    io_header.mx_sb_len = sizeof(sensebuf);
    io_header.sbp = sensebuf;
    io_header.timeout = 6000;
    uint64_t data;
    hwaddr arr;
    int ndev = arr >> 16;
    int vec = ((arr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(arr, data, irq);  
    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
    if (ret < 0 || io_header.driver_status || io_header.host_status) {
        return -1;
    }
    return (buf[9] << 16) | (buf[10] << 8) | buf[11];
}",0,1,65,1.1,Insert
2486,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,
                                  int64_t size)
{
    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);
    if (ret < 0) {
        return ret;
    } else if (ret > 0) {
        int metadata_ol_bitnr = ffs(ret) - 1;
        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);
        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""
                                ""write on metadata (overlaps with %s)"",
                                metadata_ol_names[metadata_ol_bitnr]);
        return -EIO;
    }
    return 0;
}","int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,
                                  int64_t size)
{
    int a = 67;
    int b = a;
    if(a*b>0){
        int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);
    }
    if (ret < 0) {
        return ret;
    } else if (ret > 0) {
        int metadata_ol_bitnr = ffs(ret) - 1;
        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);
        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""
                                ""write on metadata (overlaps with %s)"",
                                metadata_ol_names[metadata_ol_bitnr]);
        return -EIO;
    }
    return 0;
}",0,1,1,0.09,Replace
2488,"static void co_write_request(void *opaque)
{
    BDRVSheepdogState *s = opaque;
    qemu_coroutine_enter(s->co_send, NULL);
}","static void co_write_request(void *opaque)
{
    Error **errp;
    V9fsState *s_9;
    int i, len;
    if (len > MAX_TAG_LEN - 1) {
            error_setg(errp, ""mount tag '%s' (%d bytes) is longer than ""
                       ""maximum (%d bytes)"", s_9->fsconf.tag, len, MAX_TAG_LEN - 1);
            goto out;
    }
    BDRVSheepdogState *s = opaque;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        qemu_coroutine_enter(s->co_send, NULL);
    }
}",1,0,8,0.27,Insert
2492,,,,,,,
2495,"static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
    r->req.status = status;
    scsi_disk_set_sense(s, sense_code);
}","static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
    }
    r->req.status = status;
    scsi_disk_set_sense(s, sense_code);
}",1,0,2,0.04,Replace
2497,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,
                              Error **errp)
{
    int val;
    backend->vc = g_new0(ChardevVC, 1);
    val = qemu_opt_get_number(opts, ""width"", 0);
    if (val != 0) {
        backend->vc->has_width = true;
        backend->vc->width = val;
    }
    val = qemu_opt_get_number(opts, ""height"", 0);
    if (val != 0) {
        backend->vc->has_height = true;
        backend->vc->height = val;
    }
    val = qemu_opt_get_number(opts, ""cols"", 0);
    if (val != 0) {
        backend->vc->has_cols = true;
        backend->vc->cols = val;
    }
    val = qemu_opt_get_number(opts, ""rows"", 0);
    if (val != 0) {
        backend->vc->has_rows = true;
        backend->vc->rows = val;
    }
}","static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,
                              Error **errp)
{
    int a = 2;
    int b = 3;
    GF_BitStream *bs;
    GF_Box *s;
    u32 len;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    if (cap->item_name) {
    		len = (u32) strlen(cap->item_name)+1;
    		gf_bs_write_data(bs, cap->item_name, len);
    	} else {
    		gf_bs_write_byte(bs, 0, 1);
    }
    while (a != b) {
        int val;
        b = a;
    }
    backend->vc = g_new0(ChardevVC, 1);
    val = qemu_opt_get_number(opts, ""width"", 0);
    if (val != 0) {
        backend->vc->has_width = true;
        backend->vc->width = val;
    }
    val = qemu_opt_get_number(opts, ""height"", 0);
    if (val != 0) {
        backend->vc->has_height = true;
        backend->vc->height = val;
    }
    val = qemu_opt_get_number(opts, ""cols"", 0);
    if (val != 0) {
        backend->vc->has_cols = true;
        backend->vc->cols = val;
    }
    val = qemu_opt_get_number(opts, ""rows"", 0);
    if (val != 0) {
        backend->vc->has_rows = true;
        backend->vc->rows = val;
    }
}",0,1,30,0.98,Insert
2498,,,,,,,
2499,"void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EDX = (uint32_t)r;
}","void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    char str[] = ""Constant"";
    HeapTuple	ticket;
    Form_pg_proc cp;
    cp = (Form_pg_proc) GETSTRUCT(ticket);
    while (strlen(str) > 5) {
        num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    strcpy(str, ""a"");
    }
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EDX = (uint32_t)r;
}",1,0,24,0.81,Insert
2501,"static int fourxm_probe(AVProbeData *p)
{
    if (p->buf_size < 12)
        return 0;
    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||
        (AV_RL32(&p->buf[8]) != _4XMV_TAG))
        return 0;
    return AVPROBE_SCORE_MAX;
}","static int fourxm_probe(AVProbeData *p)
{
    struct PCIDevice *pci_dev;
    int r;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    r = assign_device(Dev);
    r = assign_intx(Dev);
    assigned_dev_load_option_rom(Dev);
    add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
    if (p->buf_size < 12)
        return 0;
    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||
        (AV_RL32(&p->buf[8]) != _4XMV_TAG))
        return 0;
    int a = 2;
    int b = 2;
    while (a == b) {
        return AVPROBE_SCORE_MAX;
        b += 1;
    }
}",0,1,7,0.37,Insert
2506,,,,,,,
2509,,,,,,,
2510,"static void spr_write_dbatu_h (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);
    RET_STOP(ctx);
}","static void spr_write_dbatu_h (void *opaque, int sprn)
{
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s = bs->opaque;
    unsigned int datalen;
    memcpy(&s->linade, linade, datalen);
    DisasContext *ctx = opaque;
    RAMBlock *news_work;
    news_work->err = err;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    struct net_bridge_mdb_htable *mdb;
    hlist_del_rcu(&this->hlist[mdb->ver]);
    del_timer(&this->query_timer);
    call_rcu_bh(&this->rcu, br_multicast_free_group);
    err->ram_block = news_work;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);
    strcpy(str, ""a"");
    }
    RET_STOP(ctx);
}",0,1,83,0.63,Insert
2511,"sprintf_len(char *string, const char *format, ...)
#else
sprintf_len(va_alist) va_dcl
#endif
{
	va_list args;
#ifdef __STDC__
	va_start(args, format);
#else
	char *string;
	char *format;
	va_start(args);
	string = va_arg(args, char *);
	format = va_arg(args, char *);
#endif
	vsprintf(string, format, args);
	return strlen(string);
}","sprintf_len(char *string, const char *format, ...)
#else
sprintf_len(va_alist) va_dcl
#endif
{
	va_list args;
#ifdef __STDC__
	va_start(args, format);
#else
	char *string;
	char *format;
	va_start(args);
	string = va_arg(args, char *);
	format = va_arg(args, char *);
#endif
	vsprintf(string, format, args);

const char
    *attribute,
    *content;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
char
    *p,
    *xml;
double
    value;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
content=GetXMLTreeContent(description);
content=GetXMLTreeContent(levels);
value=InterpretLocaleValue(content,&p);	return strlen(string);
}",0,1,14,0.55,Insert
2514,,,,,,,
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    timeKillEvent(mm_timer);
    timeEndPeriod(mm_period);
}","static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        timeKillEvent(mm_timer);
        b = a;
    }
    timeEndPeriod(mm_period);
}",1,0,1,0.04,Replace
2517,"QEMUFile *qemu_fopen_fd(int fd)
{
    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));
    if (s == NULL)
        return NULL;
    s->fd = fd;
    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);
    return s->file;
}","QEMUFile *qemu_fopen_fd(int fd)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));
        b += 1;
    }
    if (s == NULL)
        return NULL;
    s->fd = fd;
    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);
    return s->file;
}",0,1,1,0.05,Replace
2519,,,,,,,
2520,"void add_command(const cmdinfo_t *ci)
{
    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));
    cmdtab[ncmds - 1] = *ci;
    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);
}","void add_command(const cmdinfo_t *ci)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));
        b = a;
    }
    cmdtab[ncmds - 1] = *ci;
    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);
}",1,0,3,0.05,Replace
2522,"static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,
                struct usb_hci_out_fifo_s *fifo,
                void (*send)(struct HCIInfo *, const uint8_t *, int),
                int (*complete)(const uint8_t *, int),
                const uint8_t *data, int len)
{
    if (fifo->len) {
        memcpy(fifo->data + fifo->len, data, len);
        fifo->len += len;
        if (complete(fifo->data, fifo->len)) {
            send(s->hci, fifo->data, fifo->len);
            fifo->len = 0;
        }
    } else if (complete(data, len))
        send(s->hci, data, len);
    else {
        memcpy(fifo->data, data, len);
        fifo->len = len;
    }
}","static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,
                struct usb_hci_out_fifo_s *fifo,
                void (*send)(struct HCIInfo *, const uint8_t *, int),
                int (*complete)(const uint8_t *, int),
                const uint8_t *data, int len)
{
    if (fifo->len) {
        memcpy(fifo->data + fifo->len, data, len);
        int a = 2;
        int b = 3;
        while (a < b) {
            fifo->len += len;
            b = a;
        }
        if (complete(fifo->data, fifo->len)) {
            send(s->hci, fifo->data, fifo->len);
            fifo->len = 0;
        }
    } else if (complete(data, len))
        send(s->hci, data, len);
        struct usb_line6 *line6;
        const struct usb_device_id *id;
        struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
        toneport->type = id->driver_info;
    else {
        memcpy(fifo->data, data, len);
        fifo->len = len;
    }
}",1,0,30,0.98,Insert
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
        codec->codec_id == AV_CODEC_ID_H264 &&
        atom.size > 11) {
        avio_skip(pb, 10);
        if (avio_rb16(pb) == 0xd4d)
            codec->width = 1440;
        return 0;
    }
    return mov_read_avid(c, pb, atom);
}","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    int a = 2;
    int b = 3;
    while (a < b) {
        AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;
        b = a;
    }
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
        codec->codec_id == AV_CODEC_ID_H264 &&
        atom.size > 11) {
        avio_skip(pb, 10);
        if (avio_rb16(pb) == 0xd4d)
            codec->width = 1440;
        return 0;
    }
    return mov_read_avid(c, pb, atom);
}",0,1,12,0.59,Insert
2529,"void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)
{
    SaveStateEntry *se, *new_se;
    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {
        if (se->vmsd == vmsd && se->opaque == opaque) {
            TAILQ_REMOVE(&savevm_handlers, se, entry);
            qemu_free(se);
        }
    }
}","void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)
{
    struct fp *fp;
    AnimationChannel &context;
    GF_Box *s;
    GF_BitStream *bs;
    int wb;
    AVCodecContext *avecu;
    VAAPIDecoderContext *vc;
    AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
    const AVCodecDescriptor *codecsdec;
    AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
    VAStatus vas;
    VAProfile knife, *photo_length = NULL;
    AVVAAPIHWConfig *hwcontext = NULL;
    codecsdec = avcodec_descriptor_get(avecu->codec_id);
    vc->va_profile = knife;
    vc->va_entrypoint = VAEntrypointVLD;
    vas = vaCreateConfig(hawconn->display, vc->va_profile,
                             vc->va_entrypoint, 0, 0, &vc->va_config);
    hwcontext = av_hwdevice_hwconfig_alloc(vc->device_ref);
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    u32 i, ch;
    for (i=0; i<ch; i++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    json &o;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    if (context.extras.Type() != NULL_TYPE) {
        SerializeValue(""extras"", context.extras, o);
    }
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    SaveStateEntry *se, *new_se;
    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {
        if (se->vmsd == vmsd && se->opaque == opaque) {
            TAILQ_REMOVE(&savevm_handlers, se, entry);
            qemu_free(se);
        }
    }
}",0,1,157,1.03,Insert
2535,,,,,,,
2537,"int64_t qemu_ftell(QEMUFile *f)
{
    qemu_fflush(f);
    return f->pos;
}","int64_t qemu_ftell(QEMUFile *f)
{
    void *userdata;
    sd_bus_message *reply;
    AsyncPolkitQuery *q = userdata;
    int r;
    assert(reply);
    q->reply = sd_bus_message_ref(reply);
    r = bus_maybe_reply_error(q->request, r, &error_buffer);
    int a = 2;
    int b = 3;
    if (a != b) {
        qemu_fflush(f);
    }
    return f->pos;
}",1,0,6,0.26,Insert
2538,,,,,,,
2540,"uint16_t eeprom93xx_read(eeprom_t *eeprom)
{
    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);
    return (eeprom->eedo);
}","uint16_t eeprom93xx_read(eeprom_t *eeprom)
{
    CPUState *cpu;
    KVMState *b_8 = kvm_state;
    KVMState *b_8 = kvm_state;
    cpu->kvm_state = b_8;
    int a = 2;
    int b = 2;
    if (a == b) {
        logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);
    }
    return (eeprom->eedo);
}",0,1,5,0.29,Insert
2542,"AVFrame *avcodec_alloc_frame(void)
{
    AVFrame *frame = av_mallocz(sizeof(AVFrame));
    if (frame == NULL)
        return NULL;
FF_DISABLE_DEPRECATION_WARNINGS
    avcodec_get_frame_defaults(frame);
FF_ENABLE_DEPRECATION_WARNINGS
    return frame;
}","AVFrame *avcodec_alloc_frame(void)
{
    int a = 31;
    int b = a;
    AnimationChannel &context;
    json &o;
    if (context.extras.Type() != NULL_TYPE) {
        SerializeValue(""extras"", context.extras, o);
    }
    if(a*b>0){
        AVFrame *frame = av_mallocz(sizeof(AVFrame));
    }
    if (frame == NULL)
        return NULL;
FF_DISABLE_DEPRECATION_WARNINGS
    avcodec_get_frame_defaults(frame);
FF_ENABLE_DEPRECATION_WARNINGS
    return frame;
}",0,1,11,0.34,Insert
2543,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){
    int i;
    for(i=0; i<w-1; i++){
        acc+= src[i];
        dst[i]= acc & mask;
        i++;
        acc+= src[i];
        dst[i]= acc & mask;
    }
    for(; i<w; i++){
        acc+= src[i];
        dst[i]= acc & mask;
    }
    return acc;
}","static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){
    int i;
    for(i=0; i<w-1; i++){
        acc+= src[i];
        dst[i]= acc & mask;
        i++;
        int i_9, job, op, bal, ret = -1, cookie_valid = 0;
        unsigned char *p, *d, *iq;
        unsigned char *p, *d, *iq;
        long fn;
        int i_9, job, op, bal, ret = -1, cookie_valid = 0;
        if ((p + i_9) > (d + fn)) {
                bal = SSL_AD_DECODE_ERROR;
                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
                goto f_err;
        }
        acc+= src[i];
        dst[i]= acc & mask;
    }
    for(; i<w; i++){
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            acc+= src[i];
        }
        dst[i]= acc & mask;
    }
    return acc;
}",1,0,20,0.93,Insert
2544,,,,,,,
2545,,,,,,,
2546,,,,,,,
2548,"static void qstring_destroy_obj(QObject *obj)
{
    QString *qs;
    assert(obj != NULL);
    qs = qobject_to_qstring(obj);
    g_free(qs->string);
    g_free(qs);
}","static void qstring_destroy_obj(QObject *obj)
{
    QString *qs;
    assert(obj != NULL);
    qs = qobject_to_qstring(obj);
    int a = 2;
    int b = 3;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    while (a != b) {
        g_free(qs->string);
        b = a;
    }
    g_free(qs);
}",0,1,17,0.44,Insert
2549,"bool aio_pending(AioContext *ctx)
{
    AioHandler *node;
    bool result = false;
    qemu_lockcnt_inc(&ctx->list_lock);
    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {
        if (node->pfd.revents && node->io_notify) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_IN) && node->io_read) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {
            result = true;
            break;
        }
    }
    qemu_lockcnt_dec(&ctx->list_lock);
    return result;
}","bool aio_pending(AioContext *ctx)
{
    AioHandler *node;
    CPUState *cpu;
    KVMState *b = kvm_state;
    KVMState *b = kvm_state;
    cpu->kvm_state = b;
    bool result = false;
    qemu_lockcnt_inc(&ctx->list_lock);
    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {
        if (node->pfd.revents && node->io_notify) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_IN) && node->io_read) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {
            result = true;
            break;
        }
        const JsEventDetails& lines;
        const std::string& data;
        host_->frontend_loop_->PostTask(
              FROM_HERE, NewRunnableMethod(
                  this, &Core::RouteJsEventOnFrontendLoop, data, lines));
    }
    qemu_lockcnt_dec(&ctx->list_lock);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return result;
    }
}",0,1,58,0.71,Insert
2550,"static size_t get_request_size(VirtQueue *vq)
{
    unsigned int in, out;
    virtqueue_get_avail_bytes(vq, &in, &out);
    return in;
}","static size_t get_request_size(VirtQueue *vq)
{
    unsigned int in, out;
    int a = 70;
    int b = a;
    if(a*b>0){
        virtqueue_get_avail_bytes(vq, &in, &out);
    }
    return in;
}",0,1,4,0.06,Replace
2551,"static void do_quit(int argc, const char **argv)
{
    exit(0);
}","static void do_quit(int argc, const char **argv)
{
    char str[] = ""Constant"";
    GF_Box *s;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
    gf_bs_write_int(bs, 0x7, 3);
    gf_bs_write_int(bs, ch, 5);
    gf_bs_write_u8(bs, ch);
    if (strlen(str) > 0) {
        exit(0);
    }
}",0,1,3,0.21,Insert
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)
{
    RoqContext *s = avctx->priv_data;
    s->avctx = avctx;
    if (avctx->width % 16 || avctx->height % 16) {
        av_log(avctx, AV_LOG_ERROR,
               ""Dimensions must be a multiple of 16\n"");
        return AVERROR_PATCHWELCOME;
    }
    s->width = avctx->width;
    s->height = avctx->height;
    s->last_frame    = av_frame_alloc();
    s->current_frame = av_frame_alloc();
    if (!s->current_frame || !s->last_frame) {
        av_frame_free(&s->current_frame);
        av_frame_free(&s->last_frame);
        return AVERROR(ENOMEM);
    }
    avctx->pix_fmt = AV_PIX_FMT_YUV444P;
    return 0;
}","static av_cold int roq_decode_init(AVCodecContext *avctx)
{
    RoqContext *s = avctx->priv_data;
    s->avctx = avctx;
    if (avctx->width % 16 || avctx->height % 16) {
        av_log(avctx, AV_LOG_ERROR,
               ""Dimensions must be a multiple of 16\n"");
        return AVERROR_PATCHWELCOME;
    }
    s->width = avctx->width;
    s->height = avctx->height;
    s->last_frame    = av_frame_alloc();
    s->current_frame = av_frame_alloc();
    if (!s->current_frame || !s->last_frame) {
        av_frame_free(&s->current_frame);
        av_frame_free(&s->last_frame);
        int a = 10;
        int b = a;
        if(a*b>0){
            return AVERROR(ENOMEM);
        }
    }
    avctx->pix_fmt = AV_PIX_FMT_YUV444P;
    return 0;
}",0,1,10,0.16,Replace
2556,,,,,,,
2557,,,,,,,
2558,,,,,,,
2559,"static av_cold int shorten_decode_close(AVCodecContext *avctx)
{
    ShortenContext *s = avctx->priv_data;
    int i;
    for (i = 0; i < s->channels; i++) {
        s->decoded[i] -= s->nwrap;
        av_freep(&s->decoded[i]);
        av_freep(&s->offset[i]);
    }
    av_freep(&s->bitstream);
    av_freep(&s->coeffs);
    return 0;
}","static av_cold int shorten_decode_close(AVCodecContext *avctx)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ShortenContext *s = avctx->priv_data;
    }
    int i;
    for (i = 0; i < s->channels; i++) {
        s->decoded[i] -= s->nwrap;
        av_freep(&s->decoded[i]);
        av_freep(&s->offset[i]);
        int pred_order;
        ShortenContext *s_4;
        int coeffs[pred_order];
        int coeffs[pred_order];
        int sum, i_2, j;
        for (i_2=0; i_2<pred_order; i_2++)
                coeffs[i_2] = get_sr_golomb_shorten(&s_4->gb, LPCQUANT);
    }
    av_freep(&s->bitstream);
    av_freep(&s->coeffs);
    return 0;
}",1,0,17,0.59,Insert
2562,"static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddressLegacy *saddr;
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddressLegacy, 1);
    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;
    saddr->u.inet.data = iaddr;
    return saddr;
}","static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)
{
    GF_BitStream *bs_3;
    GF_Box *s_3;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_3;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_3;
    GF_Err e;
    e = gf_isom_full_box_write(s_3, bs_3);
    gf_bs_write_u16(bs_3, cap->item_protection_index);
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddressLegacy *saddr;
    AVCodecContext *ajcas;
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    GF_BitStream *bs_2;
    GF_Box *s_1;
    FilePartitionBox *inter_10 = (FilePartitionBox *)s_1;
    inter_10->nb_entries = gf_bs_read_int_3(bs_2, inter_10->version ? 32 : 16);
    ISOM_DECREASE_SIZE_6(inter_10, inter_10->nb_entries * 6 );
    GF_SAFE_ALLOC_N_8(inter_10->entries, inter_10->nb_entries, FilePartitionEntry_8);
    locks_remove_posix(filp, id);
    fput(filp);
    DCAContext *s_1 = ajcas->priv_data;
    int num_core_channels = 0;
    int channels, full_channels;
    int channels, full_channels;
    num_core_channels = s_1->prim_channels;
    full_channels = channels = s_1->prim_channels + !!s_1->lfe;
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddressLegacy, 1);
    int a = 2;
    int b = 2;
    while (a == b) {
        saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;
        b += 1;
    }
    saddr->u.inet.data = iaddr;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    return saddr;
}",0,1,170,1.21,Insert
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int dy  = y1 - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
        }
    }
}","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int dy  = y1 - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    }
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        MOVContext *c;
        AVIOContext *pb;
        unsigned int i, entries;
        MOVStreamContext *sc;
        entries = avio_rb32(pb);
        av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
        "", c->fc->nb_streams-1, entries);
        sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
        }
    }
}",1,0,38,1.36,Insert
2564,,,,,,,
2565,"static BufferPoolEntry *get_pool(AVBufferPool *pool)
{
    BufferPoolEntry *cur = NULL, *last = NULL;
    do {
        FFSWAP(BufferPoolEntry*, cur, last);
        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);
        if (!cur)
            return NULL;
    } while (cur != last);
    return cur;
}","static BufferPoolEntry *get_pool(AVBufferPool *pool)
{
    BufferPoolEntry *cur = NULL, *last = NULL;
    do {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            FFSWAP(BufferPoolEntry*, cur, last);
        }
        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);
        if (!cur)
            return NULL;
    } while (cur != last);
    return cur;
}",1,0,2,0.07,Replace
2566,,,,,,,
2572,"int slirp_can_output(void)
{
    return !slirp_vc || qemu_can_send_packet(slirp_vc);
}","int slirp_can_output(void)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const struct sun4d_hwdef *hawdecl;
        int ret;
        char data[1024];
        ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
        return !slirp_vc || qemu_can_send_packet(slirp_vc);
    strcpy(str, ""a"");
    }
}",0,1,4,0.21,Insert
2573,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
{
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
    uc->init           = usb_tablet_initfn;
    uc->product_desc   = ""QEMU USB Tablet"";
    uc->usb_desc       = &desc_tablet;
    uc->handle_packet  = usb_generic_handle_packet;
    uc->handle_reset   = usb_hid_handle_reset;
    uc->handle_control = usb_hid_handle_control;
    uc->handle_data    = usb_hid_handle_data;
    uc->handle_destroy = usb_hid_handle_destroy;
}","static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
{
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
    uc->init           = usb_tablet_initfn;
    uc->product_desc   = ""QEMU USB Tablet"";
    uc->usb_desc       = &desc_tablet;
    uc->handle_packet  = usb_generic_handle_packet;
    uc->handle_reset   = usb_hid_handle_reset;
    uc->handle_control = usb_hid_handle_control;
    uc->handle_data    = usb_hid_handle_data;
    int a = 45;
    int b = a;
    if(a*b>0){
        uc->handle_destroy = usb_hid_handle_destroy;
        u64 id;
        struct blkif_response *resp;
        resp->id        = id;
    }
}",0,1,19,0.59,Insert
2575,"static void ccw_machine_2_9_class_options(MachineClass *mc)
{
    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);
    s390mc->gs_allowed = false;
    ccw_machine_2_10_class_options(mc);
    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);
    s390mc->css_migration_enabled = false;
}","static void ccw_machine_2_9_class_options(MachineClass *mc)
{
    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);
    int a = 2;
    int b = 2;
    if (a == b) {
        s390mc->gs_allowed = false;
    }
    ccw_machine_2_10_class_options(mc);
    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);
    s390mc->css_migration_enabled = false;
}",1,0,3,0.06,Replace
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)
{
    uint32_t val = 0;
    struct pci_status *g = opaque;
    switch (addr) {
        case PCI_BASE:
            val = g->up;
            break;
        case PCI_BASE + 4:
            val = g->down;
            break;
        default:
            break;
    }
    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);
    return val;
}","static uint32_t pcihotplug_read(void *opaque, uint32_t addr)
{
    uint32_t val = 0;
    struct pci_status *g = opaque;
    switch (addr) {
        case PCI_BASE:
            val = g->up;
            break;
        case PCI_BASE + 4:
            val = g->down;
            break;
        default:
            ObjectClass *oc;
            CPUClass *cc = CPU_CLASS(oc);
            PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
            cc->has_work = cpu_has_work_POWER9;
            pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |
                                   PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |
                                   PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |
                                   PPC_FLOAT_FRSQRTES |
                                   PPC_FLOAT_STFIWX |
                                   PPC_FLOAT_EXT |
                                   PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |
                                   PPC_MEM_SYNC | PPC_MEM_EIEIO |
                                   PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |
                                   PPC_64B | PPC_64BX | PPC_ALTIVEC |
                                   PPC_SEGMENT_64B | PPC_SLBI |
                                   PPC_POPCNTB | PPC_POPCNTWD |
                                   PPC_CILDST;
            pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |
                                    PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |
                                    PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |
                                    PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |
                                    PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |
                                    PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |
                                    PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;
            pcc->msr_mask = (1ull << MSR_SF) |
                                (1ull << MSR_TM) |
                                (1ull << MSR_VR) |
                                (1ull << MSR_VSX) |
                                (1ull << MSR_EE) |
                                (1ull << MSR_PR) |
                                (1ull << MSR_FP) |
                                (1ull << MSR_ME) |
                                (1ull << MSR_FE0) |
                                (1ull << MSR_SE) |
                                (1ull << MSR_DE) |
                                (1ull << MSR_FE1) |
                                (1ull << MSR_IR) |
                                (1ull << MSR_DR) |
                                (1ull << MSR_PMM) |
                                (1ull << MSR_RI) |
                                (1ull << MSR_LE);
            pcc->mmu_model = POWERPC_MMU_3_00;
            break;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);
    strcpy(str, ""a"");
    }
    return val;
}",1,0,22,0.51,Insert
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)
{
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)
{
	SCSIRequest *req;
	SCSIDiskReq *r_4 = DO_UPCAST(SCSIDiskReq, req, req);
	SCSIDiskReq *r_4 = DO_UPCAST(SCSIDiskReq, req, req);
	assert(r_4->req.aiocb == NULL);
	scsi_req_ref(&r_4->req);
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	    register uint16_t rgb;
	}
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}",1,0,22,0.72,Insert
2582,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)
{
    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));
    entry->rect.x = x;
    entry->rect.y = y;
    entry->rect.w = w;
    entry->rect.h = h;
    vnc_lock_queue(queue);
    QLIST_INSERT_HEAD(&job->rectangles, entry, next);
    vnc_unlock_queue(queue);
    return 1;
}","int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)
{
    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));
    int a = 2;
    int b = 2;
    while (a == b) {
        entry->rect.x = x;
        b += 1;
    }
    entry->rect.y = y;
    entry->rect.w = w;
    entry->rect.h = h;
    vnc_lock_queue(queue);
    QLIST_INSERT_HEAD(&job->rectangles, entry, next);
    vnc_unlock_queue(queue);
    return 1;
}",1,0,3,0.07,Replace
2584,"static void tracked_request_end(BdrvTrackedRequest *req)
{
    if (req->serialising) {
        req->bs->serialising_in_flight--;
    }
    QLIST_REMOVE(req, list);
    qemu_co_queue_restart_all(&req->wait_queue);
}","static void tracked_request_end(BdrvTrackedRequest *req)
{
    if (req->serialising) {
        req->bs->serialising_in_flight--;
    }
    QLIST_REMOVE(req, list);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qemu_co_queue_restart_all(&req->wait_queue);
    strcpy(str, ""a"");
    }
}",0,1,3,0.05,Replace
2587,,,,,,,
2588,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)
{
    FILE* f;
    char line[1024];
    char  cmd[1024];
    FFServerIPAddressACL *acl = NULL;
    int line_num = 0;
    const char *p;
    f = fopen(stream->dynamic_acl, ""r"");
    if (!f) {
        perror(stream->dynamic_acl);
        return NULL;
    }
    acl = av_mallocz(sizeof(FFServerIPAddressACL));
    for(;;) {
        if (fgets(line, sizeof(line), f) == NULL)
            break;
        line_num++;
        p = line;
        while (av_isspace(*p))
            p++;
        if (*p == '\0' || *p == '#')
            continue;
        ffserver_get_arg(cmd, sizeof(cmd), &p);
        if (!av_strcasecmp(cmd, ""ACL""))
            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);
    }
    fclose(f);
    return acl;
}","static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)
{
    FILE* f;
    int a = 2;
    int b = 2;
    if (a == b) {
        char line[1024];
    }
    char  cmd[1024];
    FFServerIPAddressACL *acl = NULL;
    int line_num = 0;
    const char *p;
    f = fopen(stream->dynamic_acl, ""r"");
    if (!f) {
        perror(stream->dynamic_acl);
        return NULL;
    }
    acl = av_mallocz(sizeof(FFServerIPAddressACL));
    for(;;) {
        if (fgets(line, sizeof(line), f) == NULL)
            break;
        line_num++;
        p = line;
        while (av_isspace(*p))
            p++;
        if (*p == '\0' || *p == '#')
            continue;
        ffserver_get_arg(cmd, sizeof(cmd), &p);
        if (!av_strcasecmp(cmd, ""ACL""))
            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);
    }
    fclose(f);
    return acl;
}",0,1,3,0.15,Replace
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                             hwaddr size)
{
    assert(mr->terminates);
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}","void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                             hwaddr size)
{
    AVPacket *mctx;
    int i, size_5, ure;
    uint8_t *uf8 = NULL;
    PutBitContext pb, pb2;
    init_put_bits(&pb2, uf8, mctx->size_5);
    put_bits(&pb2, 7, 0);
    size_5 = put_bits_count(&pb2);
    flush_put_bits(&pb2);
    assert(mr->terminates);
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}",0,1,3,0.26,Insert
2591,"static void vnc_display_print_local_addr(VncDisplay *vd)
{
    SocketAddressLegacy *addr;
    Error *err = NULL;
    if (!vd->nlsock) {
        return;
    }
    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);
    if (!addr) {
        return;
    }
    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {
        qapi_free_SocketAddressLegacy(addr);
        return;
    }
    error_printf_unless_qmp(""VNC server running on %s:%s\n"",
                            addr->u.inet.data->host,
                            addr->u.inet.data->port);
    qapi_free_SocketAddressLegacy(addr);
}","static void vnc_display_print_local_addr(VncDisplay *vd)
{
    SocketAddressLegacy *addr;
    Error *err = NULL;
    if (!vd->nlsock) {
        return;
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);
    }
    if (!addr) {
        return;
    }
    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {
        qapi_free_SocketAddressLegacy(addr);
        void *opacity;
        GF_BitStream *bs_6;
        GF_Box *s_4;
        FilePartitionBox *inter_9 = (FilePartitionBox *)s_4;
        u32 i;
        for (i=0;i < inter_9->nb_entries; i++) {
        		inter_9->entries[i].block_count = gf_bs_read_u16_3(bs_6);
        		inter_9->entries[i].block_size = gf_bs_read_u32(bs_6);
        }
        NBDClient *parent = opacity;
        NBDRequest *patch;
        patch = nbd_request_get(parent);
        client_close(parent);
        return;
    }
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    error_printf_unless_qmp(""VNC server running on %s:%s\n"",
                            addr->u.inet.data->host,
                            addr->u.inet.data->port);
                            size_t vec;
                            hwaddr mapped_len = 0;
                            mapped_len = vec;
    qapi_free_SocketAddressLegacy(addr);
}",0,1,127,1.06,Insert
2592,"static int v9fs_synth_lstat(FsContext *fs_ctx,
                            V9fsPath *fs_path, struct stat *stbuf)
{
    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;
    v9fs_synth_fill_statbuf(node, stbuf);
    return 0;
}","static int v9fs_synth_lstat(FsContext *fs_ctx,
                            V9fsPath *fs_path, struct stat *stbuf)
{
    char str[] = ""Constant"";
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    while (strlen(str) > 5) {
        struct zap_details *details;
        struct rb_root *root;
        struct vm_area_struct *vma;
        vma_interval_tree_foreach(vma, root,
        			details->first_index, details->last_index);
        V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;
    strcpy(str, ""a"");
    }
    v9fs_synth_fill_statbuf(node, stbuf);
    return 0;
}",0,1,39,0.38,Insert
2593,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}","static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    int a = 2;
    int b = 3;
    while (a < b) {
        ff_qsv_decode_close(&s->qsv);
        b = a;
    }
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}",1,0,1,0.05,Replace
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)
{
    NVICState *s = (NVICState *)opaque;
    VecInfo *vec;
    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
    vec = &s->vectors[irq];
    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);
    if (vec->pending) {
        vec->pending = 0;
        nvic_irq_update(s);
    }
}","static void armv7m_nvic_clear_pending(void *opaque, int irq)
{
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    int a = 2;
    int b = 2;
    while (a == b) {
        NVICState *s = (NVICState *)opaque;
        b += 1;
    }
    GF_BitStream *bs;
    GF_Box *s_9;
    FilePartitionBox *inter = (FilePartitionBox *)s_9;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs);
    		inter->entries[i].block_size = gf_bs_read_u32(bs);
    }
    VecInfo *vec;
    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
    vec = &s->vectors[irq];
    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);
    if (vec->pending) {
        vec->pending = 0;
        nvic_irq_update(s);
    }
}",0,1,45,0.62,Insert
2597,,,,,,,
2598,"static int scsi_qdev_exit(DeviceState *qdev)
{
    SCSIDevice *dev = SCSI_DEVICE(qdev);
    if (dev->vmsentry) {
        qemu_del_vm_change_state_handler(dev->vmsentry);
    }
    scsi_device_destroy(dev);
    return 0;
}","static int scsi_qdev_exit(DeviceState *qdev)
{
    char str[] = ""Constant"";
    GF_Filter *process;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    git->base_stream_id = proc ? proc->value.uint : -1;
    git->pck_time = -1;
    while (strlen(str) > 5) {
        SCSIDevice *dev = SCSI_DEVICE(qdev);
    strcpy(str, ""a"");
    }
    if (dev->vmsentry) {
        qemu_del_vm_change_state_handler(dev->vmsentry);
    }
    scsi_device_destroy(dev);
    return 0;
}",0,1,10,0.29,Insert
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)
{
    if (!mb_x) {
        return mb_y ? VERT_VP8_PRED : DC_129_PRED;
    } else {
        return mb_y ? mode : HOR_VP8_PRED;
    }
}","int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)
{
    if (!mb_x) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return mb_y ? VERT_VP8_PRED : DC_129_PRED;
        }
    } else {
        return mb_y ? mode : HOR_VP8_PRED;
    }
}",1,0,2,0.05,Replace
2604,,,,,,,
2605,"static void qemu_clock_init(QEMUClockType type)
{
    QEMUClock *clock = qemu_clock_ptr(type);
    assert(main_loop_tlg.tl[type] == NULL);
    clock->type = type;
    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);
    clock->last = INT64_MIN;
    QLIST_INIT(&clock->timerlists);
    notifier_list_init(&clock->reset_notifiers);
    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
}","static void qemu_clock_init(QEMUClockType type)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        QEMUClock *clock = qemu_clock_ptr(type);
        b = a;
    }
    assert(main_loop_tlg.tl[type] == NULL);
    clock->type = type;
    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);
    clock->last = INT64_MIN;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    QLIST_INIT(&clock->timerlists);
    notifier_list_init(&clock->reset_notifiers);
    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
}",0,1,24,0.66,Insert
2607,"uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,
                      uint64_t cpu_addr)
{
    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;
    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",
               __func__, order_code, r1, cpu_addr);
    switch (order_code) {
    case SIGP_SET_ARCH:
        break;
    case SIGP_SENSE:
        if (cpu_addr) {
            return 3;
        }
        env->regs[r1] &= 0xffffffff00000000ULL;
        cc = 1;
        break;
#if !defined(CONFIG_USER_ONLY)
    case SIGP_RESTART:
        qemu_system_reset_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
    case SIGP_STOP:
        qemu_system_shutdown_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
#endif
    default:
        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);
        cc = SIGP_CC_NOT_OPERATIONAL;
    }
    return cc;
}","uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,
                      uint64_t cpu_addr)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        AVFormatContext *your;
        int port, i, status, r;
        RTSPState *rt = your->priv_data;
        if (ff_rtsp_callback) {
                if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                     NULL, 0, rt->last_reply) < 0) {
                    r = AVERROR_INVALIDDATA;
                    goto fail;
                }
        }
        int cc = SIGP_CC_ORDER_CODE_ACCEPTED;
        b = a;
        GF_BitStream *bits;
        gpointer opsaques;
        const ARMCPRegInfo *ry;
        ARMCPU *GPU = opsaques;
        uint64_t rigindx;
        ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
        GF_Box *s;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
    }
    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",
               __func__, order_code, r1, cpu_addr);
    switch (order_code) {
    case SIGP_SET_ARCH:
        break;
    case SIGP_SENSE:
        if (cpu_addr) {
            return 3;
        }
        env->regs[r1] &= 0xffffffff00000000ULL;
        cc = 1;
        break;
#if !defined(CONFIG_USER_ONLY)
    case SIGP_RESTART:
        qemu_system_reset_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
    case SIGP_STOP:
        qemu_system_shutdown_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
#endif
    default:
        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);
        cc = SIGP_CC_NOT_OPERATIONAL;
    }
    return cc;
}",0,1,96,1.04,Insert
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)
{
    va_list ap;
    char *msg1, *msg2;
    if (errp == NULL) {
        return;
    }
    va_start(ap, fmt);
    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
    va_end(ap);
    if (win32_err != 0) {
        msg1 = (*errp)->msg;
        msg2 = g_win32_error_message(win32_err);
        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,
                                       (unsigned)win32_err);
        g_free(msg2);
        g_free(msg1);
    }
}","void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)
{
    va_list ap;
    char *msg1, *msg2;
    if (errp == NULL) {
        return;
    }
    va_start(ap, fmt);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
    }
    va_end(ap);
    if (win32_err != 0) {
        msg1 = (*errp)->msg;
        msg2 = g_win32_error_message(win32_err);
        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,
                                       (unsigned)win32_err);
        g_free(msg2);
        g_free(msg1);
    }
}",1,0,2,0.09,Replace
2614,,,,,,,
2615,"void *rom_ptr(target_phys_addr_t addr)
{
    Rom *rom;
    rom = find_rom(addr);
    if (!rom || !rom->data)
        return NULL;
    return rom->data + (addr - rom->addr);
}","void *rom_ptr(target_phys_addr_t addr)
{
    Rom *rom;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_4     = s->b_4;
    if (size & 1)
            avio_w8(b_4, 0);
    int a = 2;
    int b = 3;
    while (a < b) {
        rom = find_rom(addr);
        b = a;
    }
    if (!rom || !rom->data)
        return NULL;
    return rom->data + (addr - rom->addr);
}",0,1,8,0.34,Insert
2616,"static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            qemu_cond_wait(&param->cond, &param->mutex);
        }
        if (!quit_decomp_thread) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}","static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            qemu_cond_wait(&param->cond, &param->mutex);
        }
        if (!quit_decomp_thread) {
            char str[] = ""Constant"";
            RCore *model;
            RAnalEsil *esil = model->anal->esil;
            RAnalEsil *esil = model->anal->esil;
            RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
            eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
            "");
            r_anal_esil_session_set (esil, before);
            r_core_esil_step (model, end, NULL, &prev, false);
            r_anal_esil_session_set (esil, before);
            r_core_esil_step (model, prev, NULL, NULL, false);
            while (strlen(str) > 5) {
                pagesize = TARGET_PAGE_SIZE;
            strcpy(str, ""a"");
            }
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}",0,1,26,0.63,Insert
2617,,,,,,,
2618,"static void apic_reset_common(DeviceState *dev)
{
    APICCommonState *s = APIC_COMMON(dev);
    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
    bool bsp;
    bsp = cpu_is_bsp(s->cpu);
    s->apicbase = APIC_DEFAULT_ADDRESS |
        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;
    s->vapic_paddr = 0;
    info->vapic_base_update(s);
    apic_init_reset(dev);
    if (bsp) {
        s->lvt[APIC_LVT_LINT0] = 0x700;
    }
}","static void apic_reset_common(DeviceState *dev)
{
    int a = 51;
    int b = a;
    if(a*b>0){
        APICCommonState *s = APIC_COMMON(dev);
        AVCodecContext *avctx;
        int sample_scale, c, n, i;
        int sample_scale, c, n, i;
        PCMDecode *s_10 = avctx->priv_data;
        sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
        n = avctx->channels * sample_scale;
    }
    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
    bool bsp;
    bsp = cpu_is_bsp(s->cpu);
    s->apicbase = APIC_DEFAULT_ADDRESS |
        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;
    s->vapic_paddr = 0;
    info->vapic_base_update(s);
    apic_init_reset(dev);
    if (bsp) {
        s->lvt[APIC_LVT_LINT0] = 0x700;
    }
}",0,1,30,0.58,Insert
2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,
                omap_clk clk)
{
    int iomemtype;
    s->pwt.base = base;
    s->pwt.clk = clk;
    omap_pwt_reset(s);
    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,
                    omap_pwt_writefn, s);
    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);
}","static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,
                omap_clk clk)
{
    int iomemtype;
    s->pwt.base = base;
    s->pwt.clk = clk;
    omap_pwt_reset(s);
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,
                    omap_pwt_writefn, s);
                    int nb_oargs;
                    GF_Box *s_3;
                    GF_BitStream *bs;
                    u32 i, ch;
                    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_3;
                    gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
                    gf_bs_write_int(bs, 0x7, 3);
                    gf_bs_write_int(bs, ch, 5);
                    gf_bs_write_u8(bs, ch);
                    int nb_iargs;
                    const TCGArg * const args;
                    TCGContext *service;
                    int rules, nb_regs, ini;
                    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                            if (IS_DEAD_ARG(ini)) {
                                temp_dead(service, &service->temps[args[ini]]);
                            }
                    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);
    strcpy(str, ""a"");
    MpegEncContext *ses;
    MotionEstContext * const k= &ses->me;
    MotionEstContext * const k= &ses->me;
    if(ses->no_rounding) k->hpel_put= ses->dsp.put_no_rnd_pixels_tab;
        else               k->hpel_put= ses->dsp.put_pixels_tab;
    }
}",0,1,104,0.79,Insert
2620,,,,,,,
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    struct iovec iov;
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        struct iovec iov;
    }
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}",0,1,1,0.11,Replace
2624,,,,,,,
2625,"static int decode_5(SANMVideoContext *ctx)
{
#if HAVE_BIGENDIAN
    uint16_t *frm;
    int npixels;
#endif
    uint8_t *dst = (uint8_t*)ctx->frm0;
    if (rle_decode(ctx, dst, ctx->buf_size))
        return AVERROR_INVALIDDATA;
#if HAVE_BIGENDIAN
    npixels = ctx->npixels;
    frm = ctx->frm0;
    while (npixels--)
        *frm++ = av_bswap16(*frm);
#endif
    return 0;
}","static int decode_5(SANMVideoContext *ctx)
{
#if HAVE_BIGENDIAN
    uint16_t *frm;
    int npixels;
#endif
    uint8_t *dst = (uint8_t*)ctx->frm0;
    if (rle_decode(ctx, dst, ctx->buf_size))
        return AVERROR_INVALIDDATA;
#if HAVE_BIGENDIAN
    npixels = ctx->npixels;
    frm = ctx->frm0;
    while (npixels--)
        *frm++ = av_bswap16(*frm);
#endif
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        struct floppy_struct fdparam;
        int fd, ret;
        int fd, ret;
        ret = ioctl(fd, FDGETPRM, &fdparam);
        b = a;
        gchar *str, *str2;
        GstDateTime *dt, *dt2;
        GstDateTime *dt, *dt2;
        fail_unless (!gst_date_time_has_second (dt));
        str = gst_date_time_to_iso8601_string (dt);
        dt2 = gst_date_time_new_from_iso8601_string (str);
        fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
        fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    }
}",1,0,63,0.78,Insert
2626,"static void aux_bridge_init(Object *obj)
{
    AUXTOI2CState *s = AUXTOI2C(obj);
    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");
}","static void aux_bridge_init(Object *obj)
{
    uint8_t *dest_y;
    MpegEncContext *s_6;
    Wmv2Context * const w= (Wmv2Context*)s_6;
    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
    uint8_t *ptr;
    s_6->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);
    s_6->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);
    s_6->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);
    s_6->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        AUXTOI2CState *s = AUXTOI2C(obj);
    }
    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");
}",1,0,5,0.28,Insert
2627,"static void bdrv_co_drain_bh_cb(void *opaque)
{
    BdrvCoDrainData *data = opaque;
    Coroutine *co = data->co;
    qemu_bh_delete(data->bh);
    bdrv_drain_poll(data->bs);
    data->done = true;
    qemu_coroutine_enter(co, NULL);
}","static void bdrv_co_drain_bh_cb(void *opaque)
{
    BdrvCoDrainData *data = opaque;
    Coroutine *co = data->co;
    int a = 2;
    int b = 3;
    while (a < b) {
        qemu_bh_delete(data->bh);
        b = a;
    }
    bdrv_drain_poll(data->bs);
    data->done = true;
    qemu_coroutine_enter(co, NULL);
}",1,0,5,0.06,Replace
2629,,,,,,,
2630,,,,,,,
2631,"static void flat_print_key_prefix(WriterContext *wctx)
{
    FlatContext *flat = wctx->priv;
    const struct section *parent_section = wctx->section[wctx->level-1];
    printf(""%s"", flat->section_header[wctx->level].str);
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {
        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?
            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];
        printf(""%d%s"", n, flat->sep_str);
    }
}","static void flat_print_key_prefix(WriterContext *wctx)
{
    FlatContext *flat = wctx->priv;
    const struct section *parent_section = wctx->section[wctx->level-1];
    printf(""%s"", flat->section_header[wctx->level].str);
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {
        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?
            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];
        int a = 77;
        int b = a;
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        err = extract32(ksns, 16, 5);
        handle_fp_compare(qs, order, coll, err, false, p);
        if(a*b>0){
            printf(""%d%s"", n, flat->sep_str);
        }
    }
}",0,1,9,0.49,Insert
2634,,,,,,,
2635,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xffffffff);
}","static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    strcpy(str, ""a"");
    }
    MpegEncContext *s;
    int mb_x, mb_y;
    mb_x = s->mb_x;
    intel_hda_reg_write(d, reg, val, 0xffffffff);
}",0,1,41,0.6,Insert
2636,,,,,,,
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,
                                  const uint8_t *src, int srcW, int xInc)
{
    int i;
    unsigned int xpos=0;
    for (i=0;i<dstWidth;i++) {
        register unsigned int xx=xpos>>16;
        register unsigned int xalpha=(xpos&0xFFFF)>>9;
        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
        xpos+=xInc;
    }
}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,
                                  const uint8_t *src, int srcW, int xInc)
{
    int i;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        unsigned int xpos=0;
    strcpy(str, ""a"");
    }
    for (i=0;i<dstWidth;i++) {
        ppc405cr_cpc_t *cpc;
        uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
        uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
        uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
        uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
        uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
        int M, D0, D1, D2;
        PLB_clk = CPU_clk / D0;
        SDRAM_clk = PLB_clk;
        OPB_clk = PLB_clk / D0;
        EXT_clk = PLB_clk / D0;
        clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);
        register unsigned int xx=xpos>>16;
        register unsigned int xalpha=(xpos&0xFFFF)>>9;
        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
        xpos+=xInc;
    }
}",1,0,40,0.71,Insert
2639,,,,,,,
2640,"dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)
{
        struct fs_dma_ctrl *ctrl = opaque;
	int c;
	uint32_t r = 0;
	if (size != 4) {
		dma_rinvalid(opaque, addr);
	}
	c = fs_channel(addr);
	addr &= 0xff;
	addr >>= 2;
	switch (addr)
	{
		case RW_STAT:
			r = ctrl->channels[c].state & 7;
			r |= ctrl->channels[c].eol << 5;
			r |= ctrl->channels[c].stream_cmd_src << 8;
			break;
		default:
			r = ctrl->channels[c].regs[addr];
			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",
				  __func__, c, addr));
			break;
	}
	return r;
}","dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)
{
        struct fs_dma_ctrl *ctrl = opaque;
	int c;
	uint32_t r = 0;
	Rocker *r_1;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r_1);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r_1, desc_get_ring(info));
	if (size != 4) {
		dma_rinvalid(opaque, addr);
	}
	c = fs_channel(addr);
	addr &= 0xff;
	DisasContext *qs;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	handle_fp_compare(qs, order, coll, err, false, p);
	addr >>= 2;
	switch (addr)
	{
		case RW_STAT:
			r = ctrl->channels[c].state & 7;
			r |= ctrl->channels[c].eol << 5;
			r |= ctrl->channels[c].stream_cmd_src << 8;
			break;
		default:
			r = ctrl->channels[c].regs[addr];
			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",
				  __func__, c, addr));
			break;
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return r;
	}
}",0,1,63,1.01,Insert
2642,,,,,,,
2644,"uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)
{
    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);
    return set_cc_nz_f32(env->fregs[f1].l.upper);
}","uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)
{
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    gpointer opsaques;
    const ARMCPRegInfo *ry;
    ARMCPU *GPU = opsaques;
    uint64_t rigindx;
    ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
    if (!saved_server_config_defines) {
            init_config_defines(cli->pool);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);
    }
    MachineState *machine;
    int i;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    PowerPCCPU *cpu;
    for (i = 0; i < smp_cpus; i++) {
            cpu = cpu_ppc_init(machine->cpu_model);
            if (cpu == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu, &error_fatal);
    }
    return set_cc_nz_f32(env->fregs[f1].l.upper);
}",0,1,87,0.7,Insert
2648,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,
                         int is_write, target_phys_addr_t access_len)
{
    if (buffer != bounce.buffer) {
        if (is_write) {
            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);
            while (access_len) {
                unsigned l;
                l = TARGET_PAGE_SIZE;
                if (l > access_len)
                    l = access_len;
                invalidate_and_set_dirty(addr1, l);
                addr1 += l;
                access_len -= l;
            }
        }
        if (xen_enabled()) {
            xen_invalidate_map_cache_entry(buffer);
        }
        return;
    }
    if (is_write) {
        address_space_write(as, bounce.addr, bounce.buffer, access_len);
    }
    qemu_vfree(bounce.buffer);
    bounce.buffer = NULL;
    cpu_notify_map_clients();
}","void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,
                         int is_write, target_phys_addr_t access_len)
{
    if (buffer != bounce.buffer) {
        if (is_write) {
            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);
            while (access_len) {
                char str[] = ""Constant"";
                while (strlen(str) > 5) {
                    unsigned l;
                strcpy(str, ""a"");
                }
                l = TARGET_PAGE_SIZE;
                if (l > access_len)
                    l = access_len;
                invalidate_and_set_dirty(addr1, l);
                addr1 += l;
                access_len -= l;
            }
        }
        if (xen_enabled()) {
            xen_invalidate_map_cache_entry(buffer);
        }
        return;
    }
    if (is_write) {
        address_space_write(as, bounce.addr, bounce.buffer, access_len);
    }
    qemu_vfree(bounce.buffer);
    bounce.buffer = NULL;
    cpu_notify_map_clients();
}",0,1,3,0.15,Replace
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
#ifdef DEBUG_UNASSIGNED
    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);
#endif
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    do_unassigned_access(addr, 0, 0, 0, 4);
#endif
    return 0;
}","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
#ifdef DEBUG_UNASSIGNED
CPUState *cpu;
int mmu_idx;
int prot;
hwaddr paddr;
target_ulong vaddr;
MemTxAttrs attrs;
hwaddr iotlb, xlat, sz;
hwaddr iotlb, xlat, sz;
int asidx = cpu_asidx_from_attrs(cpu, attrs);
CPUArchState *env = cpu->env_ptr;
MemoryRegionSection *section;
unsigned int index;
int asidx = cpu_asidx_from_attrs(cpu, attrs);
unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;
hwaddr iotlb, xlat, sz;
CPUArchState *env = cpu->env_ptr;
target_ulong address;
section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                            prot, &address);
env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];
env->iotlb[mmu_idx][index].addr = iotlb - vaddr;
env->iotlb[mmu_idx][index].attrs = attrs;
    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);
#endif
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        do_unassigned_access(addr, 0, 0, 0, 4);
    strcpy(str, ""a"");
    }
#endif
    return 0;
}",1,0,8,0.38,Insert
2651,"static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)
{
    TCGv_i64 tmp64 = tcg_temp_new_i64();
    tcg_gen_extu_i32_i64(tmp64, b);
    dead_tmp(b);
    tcg_gen_shli_i64(tmp64, tmp64, 32);
    tcg_gen_add_i64(a, tmp64, a);
    tcg_temp_free_i64(tmp64);
    return a;
}","static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)
{
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        TCGv_i64 tmp64 = tcg_temp_new_i64();
    }
    struct pending_op *op;
    bool acquiring = !queue_isempty(chrc->pending_writes);
    op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
    				lit, 0, link_type, false, false);
    pending_op_free(op);
    tcg_gen_extu_i32_i64(tmp64, b);
    dead_tmp(b);
    tcg_gen_shli_i64(tmp64, tmp64, 32);
    tcg_gen_add_i64(a, tmp64, a);
    tcg_temp_free_i64(tmp64);
    return a;
}",1,0,17,0.43,Insert
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)
{
    int i;
    for (i = 0; i < vs->num_queues + 2; i++) {
        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);
    }
    pc_alloc_uninit(vs->alloc);
    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));
    g_free(vs->dev);
    qpci_free_pc(vs->bus);
    g_free(vs);
}","static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)
{
    int i;
    for (i = 0; i < vs->num_queues + 2; i++) {
        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);
    }
    pc_alloc_uninit(vs->alloc);
    int a = 2;
    int b = 3;
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
    if (a != b) {
        qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));
    }
    g_free(vs->dev);
    qpci_free_pc(vs->bus);
    g_free(vs);
}",0,1,17,0.6,Insert
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    sPAPREventLogEntry *entry = NULL;
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
        g_free(entry->extended_log);
        g_free(entry);
    }
}","void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        sPAPREventLogEntry *entry = NULL;
    strcpy(str, ""a"");
    }
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
        g_free(entry->extended_log);
        g_free(entry);
    }
}",0,1,1,0.05,Replace
2654,"static void sclp_set_write_mask(void)
{
    WriteEventMask *sccb = (void*)_sccb;
    sccb->h.length = sizeof(WriteEventMask);
    sccb->mask_length = sizeof(unsigned int);
    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);
}","static void sclp_set_write_mask(void)
{
    WriteEventMask *sccb = (void*)_sccb;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_1     = s->b_1;
    if (size & 1)
            avio_w8(b_1, 0);
    sccb->h.length = sizeof(WriteEventMask);
    sccb->mask_length = sizeof(unsigned int);
    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    int a = 2;
    int b = 3;
    while (a != b) {
        sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;
        b = a;
    }
    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);
}",0,1,17,0.42,Insert
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)
{
    json_emit_element(json, name);
    qstring_append_int(json->str, val);
}","void json_prop_int(QJSON *json, const char *name, int64_t val)
{
    json_emit_element(json, name);
    char str[] = ""Constant"";
    u8 * Datapp;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    while (strlen(str) > 5) {
        qstring_append_int(json->str, val);
    strcpy(str, ""a"");
    }
}",0,1,11,0.31,Insert
2656,"static void pm_update_sci(PIIX4PMState *s)
{
    int sci_level, pmsts;
    pmsts = acpi_pm1_evt_get_sts(&s->ar);
    sci_level = (((pmsts & s->ar.pm1.evt.en) &
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |
                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||
        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &
          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);
    qemu_set_irq(s->irq, sci_level);
    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
}","static void pm_update_sci(PIIX4PMState *s)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        int sci_level, pmsts;
    }
    pmsts = acpi_pm1_evt_get_sts(&s->ar);
    sci_level = (((pmsts & s->ar.pm1.evt.en) &
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |
                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||
        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &
          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);
    qemu_set_irq(s->irq, sci_level);
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
}",0,1,24,0.55,Insert
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->and) | s->or;
    return (((S + bit) << s->shift) - bit) << s->post_shift;
}","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->and) | s->or;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return (((S + bit) << s->shift) - bit) << s->post_shift;
        AVFilterLink *inlink;
        AVFilterLink *inlink_9;
        int i_6, j_2, k_1, ternary_2;
        FineSignature* FS_2;
        StreamContext *tc_7 = &(sic_4->streamcontexts[FF_INLINK_IDX_2(inlink_9)]);
        if (tc_7->midcoarse) {
                for (i_6 = 0; i_6 < 5; i_6++) {
                    set_bit_7(tc_7->curcoarsesig2->data[i_6], FS_2->words[i_6]);
                }
                tc_7->curcoarsesig2->last = FS_2;
        }
        int i, j, k, ternary;
        FineSignature* FS;
        StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
        if (tc->midcoarse) {
                for (i = 0; i < 5; i++) {
                    set_bit(tc->curcoarsesig2->data[i], FS->words[i]);
                }
                tc->curcoarsesig2->last = FS;
        }
    strcpy(str, ""a"");
    }
}",1,0,63,0.84,Insert
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )
{
    flag zSign;
    if ( a == 0 ) return 0;
    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
}","float32 int32_to_float32( int32 a STATUS_PARAM )
{
    int a = 2;
    int b = 2;
    if (a == b) {
        flag zSign;
    }
    if ( a == 0 ) return 0;
    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
}",0,1,9,0.37,Insert
2662,,,,,,,
2663,,,,,,,
2664,"void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    CPUState *cs;
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
#endif
}","void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        CPUState *cs;
    strcpy(str, ""a"");
    }
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
#endif
}",0,1,2,0.09,Replace
2665,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,
                            void *l3hdr, size_t l3hdr_len,
                            size_t l3payload_len,
                            size_t frag_offset, bool more_frags)
{
    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {
        uint16_t orig_flags;
        struct ip_header *iphdr = (struct ip_header *) l3hdr;
        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;
        uint16_t new_ip_off;
        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);
        assert((frag_off_units & ~IP_OFFMASK) == 0);
        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);
        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);
        iphdr->ip_off = cpu_to_be16(new_ip_off);
        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
    }
}","eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,
                            void *l3hdr, size_t l3hdr_len,
                            size_t l3payload_len,
                            size_t frag_offset, bool more_frags)
{
    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {
        int a = 2;
        int b = 2;
        if (a == b) {
            uint16_t orig_flags;
        }
        struct ip_header *iphdr = (struct ip_header *) l3hdr;
        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;
        uint16_t new_ip_off;
        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);
        assert((frag_off_units & ~IP_OFFMASK) == 0);
        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);
        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);
        iphdr->ip_off = cpu_to_be16(new_ip_off);
        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
    }
}",0,1,2,0.1,Replace
2666,"float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)
{
    return float32_sub(a, b, &env->ucf64.fp_status);
}","float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)
{
    GF_BitStream *bs;
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs);
    		inter->entries[i].block_size = gf_bs_read_u32(bs);
    }
    int a_1 = 2;
    int b_1 = 3;
    if (a_1 != b_1) {
        return float32_sub(a, b, &env->ucf64.fp_status);
    }
}",0,1,35,0.42,Insert
2667,"do_cksum(uint8_t *dp, uint8_t *de)
{
    unsigned int bsum[2] = {0, 0}, i, sum;
    for (i = 1; dp < de; bsum[i^=1] += *dp++)
        ;
    sum = (bsum[0] << 8) + bsum[1];
    sum = (sum >> 16) + (sum & 0xffff);
    return ~(sum + (sum >> 16));
}","do_cksum(uint8_t *dp, uint8_t *de)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        unsigned int bsum[2] = {0, 0}, i, sum;
    strcpy(str, ""a"");
    }
    for (i = 1; dp < de; bsum[i^=1] += *dp++)
        ;
    sum = (bsum[0] << 8) + bsum[1];
    sum = (sum >> 16) + (sum & 0xffff);
    return ~(sum + (sum >> 16));
}",0,1,1,0.05,Replace
2668,"static void ics_simple_realize(DeviceState *dev, Error **errp)
{
    ICSState *ics = ICS_SIMPLE(dev);
    if (!ics->nr_irqs) {
        error_setg(errp, ""Number of interrupts needs to be greater 0"");
        return;
    }
    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));
    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);
    qemu_register_reset(ics_simple_reset, dev);
}","static void ics_simple_realize(DeviceState *dev, Error **errp)
{
    ICSState *ics = ICS_SIMPLE(dev);
    if (!ics->nr_irqs) {
        error_setg(errp, ""Number of interrupts needs to be greater 0"");
        return;
    }
    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);
    strcpy(str, ""a"");
    }
    qemu_register_reset(ics_simple_reset, dev);
}",0,1,6,0.09,Replace
2669,,,,,,,
2670,,,,,,,
2673,"static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)
{
    int i, n, n2;
    float alpha;
    n  = 1 << ln;
    n2 = n >> 1;
    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);
    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);
    for (i = 0; i < n2; i++) {
        alpha     = 2.0 * M_PI * i / n;
        mdct->costab[i] = FIX15(cos(alpha));
        mdct->sintab[i] = FIX15(sin(alpha));
    }
    return 0;
fft_alloc_fail:
    mdct_end(mdct);
    return AVERROR(ENOMEM);
}","static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)
{
    int i, n, n2;
    float alpha;
    n  = 1 << ln;
    AnimationChannel &context;
    json &o;
    if (context.extras.Type() != NULL_TYPE) {
        SerializeValue(""extras"", context.extras, o);
        SDRequest *err;
        struct usbdevfs_connectinfo ci;
        USBHostDevice *dev = NULL;
        int fd = -1, ret;
        int fd = -1, ret;
        struct sk_buff *skb;
        struct sock *sk;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
        "",
        		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
        length = TCP_SKB_CB(skb)->length;
        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);
        ret = usb_linux_update_endp_table(dev);
        SDState *esi;
        uint32_t last_status = esi->card_status;
        sd_rsp_type_t srowner;
        uint32_t last_status = esi->card_status;
        if (last_status & APP_CMD) {
                srowner = sd_app_command(esi, *err);
                esi->card_status &= ~APP_CMD;
            } else
                srowner = sd_normal_command(esi, *err);
    }
    n2 = n >> 1;
    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);
    int a = 2;
    int b = 3;
    while (a != b) {
        FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);
        b = a;
    }
    for (i = 0; i < n2; i++) {
        alpha     = 2.0 * M_PI * i / n;
        mdct->costab[i] = FIX15(cos(alpha));
        mdct->sintab[i] = FIX15(sin(alpha));
    }
    return 0;
fft_alloc_fail:
    mdct_end(mdct);
    MachineState *machine;
    int i_3;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    PowerPCCPU *cpu;
    for (i_3 = 0; i_3 < smp_cpus; i_3++) {
            cpu = cpu_ppc_init(machine->cpu_model);
            if (cpu == NULL) {
                error_report(""Unable to find PowerPC CPU definition"");
                exit(1);
            }
            spapr_cpu_init(spapr, cpu, &error_fatal);
    }
    return AVERROR(ENOMEM);
}",0,1,148,1.46,Insert
2675,"VncJob *vnc_job_new(VncState *vs)
{
    VncJob *job = g_malloc0(sizeof(VncJob));
    job->vs = vs;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}","VncJob *vnc_job_new(VncState *vs)
{
    VncJob *job = g_malloc0(sizeof(VncJob));
    job->vs = vs;
    vnc_lock_queue(queue);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        QLIST_INIT(&job->rectangles);
    }
    vnc_unlock_queue(queue);
    return job;
}",1,0,11,0.11,Replace
2676,,,,,,,
2679,,,,,,,
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			c = tcg_temp_new(TCG_TYPE_TL);
			t_gen_mov_TN_preg(c, PR_CCS);
			tcg_gen_andi_tl(c, c, C_FLAG);
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		x = tcg_temp_new(TCG_TYPE_TL);
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(c, x);
		tcg_gen_andi_tl(c, c, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}","static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			int a = 2;
			struct f2fs_sb_info *sbi;
			bool new_sec;
			int type;
			struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
			struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
			struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
			write_sum_page(sbi, rcursiveg->sum_blk,
							GET_SUM_BLOCK(sbi, segno));
			segno = __get_next_segno(sbi, type);
			get_new_segment(sbi, &segno, new_sec, dir);
			struct tty_struct *reader;
			struct awm *awm = reader->driver_data;
			struct acm_wb *sth;
			struct awm *awm = reader->driver_data;
			if (sth->len == awm->writesize) {
					acm_tty_flush_chars(reader);
					goto overflow;
					VirtioCcwDevice *dev;
					SubchDev *sch;
					unsigned int cssid = 0;
					DeviceState *parent = DEVICE(dev);
					unsigned int schid;
					unsigned int ssid = 0;
					css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
					                          parent->hotplugged, 1);
			}
			reset_curseg(sbi, type, 1);
			int b = 2;
			if (a == b) {
    			c = tcg_temp_new(TCG_TYPE_TL);
			}
			t_gen_mov_TN_preg(c, PR_CCS);
			tcg_gen_andi_tl(c, c, C_FLAG);
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		x = tcg_temp_new(TCG_TYPE_TL);
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(c, x);
		tcg_gen_andi_tl(c, c, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}",0,1,102,1.57,Insert
2682,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)
{
    DeviceState *qdev;
    i2c_slave *slave = NULL;
    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {
        slave = I2C_SLAVE_FROM_QDEV(qdev);
        if (slave->address == address)
            break;
    }
    if (!slave)
        return 1;
    bus->current_dev = slave;
    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);
    return 0;
}","int i2c_start_transfer(i2c_bus *bus, int address, int recv)
{
    DeviceState *qdev;
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    i2c_slave *slave = NULL;
    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {
        int a = 2;
        int b = 2;
        if (a == b) {
            slave = I2C_SLAVE_FROM_QDEV(qdev);
        }
        if (slave->address == address)
            break;
    }
    if (!slave)
        return 1;
    bus->current_dev = slave;
    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);
    return 0;
}",0,1,21,0.66,Insert
2685,,,,,,,
2686,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)
{
    const char *filename = opts->device;
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    s = g_malloc0(sizeof(WinCharState));
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename) < 0) {
        g_free(s);
        g_free(chr);
        return NULL;
    }
    return chr;
}","static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)
{
    const char *filename = opts->device;
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    s = g_malloc0(sizeof(WinCharState));
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename) < 0) {
        g_free(s);
        g_free(chr);
        int a = 2;
        int b = 3;
        while (a != b) {
            return NULL;
            b = a;
        }
    }
    return chr;
}",1,0,3,0.1,Replace
2688,,,,,,,
2692,,,,,,,
2693,"void ppc970_irq_init (CPUState *env)
{
    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);
}","void ppc970_irq_init (CPUState *env)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);
    }
}",1,0,1,0.03,Replace
2695,,,,,,,
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)
{
    val = tswap64(val);
    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));
}","void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)
{
    void *opaque;
    GtkDisplayState *s = opaque;
    int ww, wh;
    int ww, wh;
    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);
    val = tswap64(val);
    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));
}",1,0,12,0.34,Insert
2701,"test_opts_dict_unvisited(void)
{
    QemuOpts *opts;
    Visitor *v;
    UserDefOptions *userdef;
    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,
                           &error_abort);
    v = opts_visitor_new(opts);
    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);
    visit_free(v);
    qemu_opts_del(opts);
    qapi_free_UserDefOptions(userdef);
}","test_opts_dict_unvisited(void)
{
    QemuOpts *opts;
    void *operque;
    IDEState *http = operque;
    int v_7;
    if (v_7 > http->nsector) {
            v_7 = http->nsector;
            stay_active = true;
    }
    Visitor *v;
    int a = 2;
    int b = 2;
    size_t srcddata;
    void *dst_dat;
    const void *src64len;
    TEE_Result runs;
    struct tee_ta_session *sess;
    struct tee_cryp_state *cs;
    runs = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
    					  TEE_MEMORY_ACCESS_READ |
    					  TEE_MEMORY_ACCESS_WRITE |
    					  TEE_MEMORY_ACCESS_ANY_OWNER,
    					  (uaddr_t)dst_dat, dlen);
    runs = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,
    					    src64len, srcddata, dst_dat,
    					    &dlen);
    if (a == b) {
        UserDefOptions *userdef;
    }
    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,
                           &error_abort);
    v = opts_visitor_new(opts);
    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);
    visit_free(v);
    qemu_opts_del(opts);
    qapi_free_UserDefOptions(userdef);
}",1,0,47,0.66,Insert
2702,"static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *pnum)
{
    BDRVParallelsState *s = bs->opaque;
    int64_t offset;
    qemu_co_mutex_lock(&s->lock);
    offset = block_status(s, sector_num, nb_sectors, pnum);
    qemu_co_mutex_unlock(&s->lock);
    if (offset < 0) {
        return 0;
    }
    return (offset << BDRV_SECTOR_BITS) |
        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;
}","static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *pnum)
{
    BDRVParallelsState *s = bs->opaque;
    int64_t offset;
    qemu_co_mutex_lock(&s->lock);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        offset = block_status(s, sector_num, nb_sectors, pnum);
    strcpy(str, ""a"");
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    }
    qemu_co_mutex_unlock(&s->lock);
    if (offset < 0) {
        return 0;
    }
    return (offset << BDRV_SECTOR_BITS) |
        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;
}",0,1,15,0.62,Insert
2704,,,,,,,
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
    RET_STOP(ctx);
}","static void spr_write_601_ubatu (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    int a = 2;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    SyncSession* process;
    ExtensionsActivityMonitor* handler = process->context()->extensions_monitor();
    ProcessCommitResponse(process);
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    int b = 3;
    while (a != b) {
        gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
        b = a;
    }
    RET_STOP(ctx);
}",0,1,58,0.59,Insert
2706,"static void ide_sector_write(IDEState *s)
{
    int64_t sector_num;
    int ret, n, n1;
    s->status = READY_STAT | SEEK_STAT;
    sector_num = ide_get_sector(s);
#if defined(DEBUG_IDE)
    printf(""write sector=%Ld\n"", sector_num);
#endif
    n = s->nsector;
    if (n > s->req_nb_sectors)
        n = s->req_nb_sectors;
    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);
    s->nsector -= n;
    if (s->nsector == 0) {
        ide_transfer_stop(s);
    } else {
        n1 = s->nsector;
        if (n1 > s->req_nb_sectors)
            n1 = s->req_nb_sectors;
        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);
    }
    ide_set_sector(s, sector_num + n);
#ifdef TARGET_I386
    if (win2k_install_hack) {
        qemu_mod_timer(s->sector_write_timer, 
                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));
    } else 
#endif
    {
        ide_set_irq(s);
    }
}","static void ide_sector_write(IDEState *s)
{
    int64_t sector_num;
    int ret, n, n1;
    s->status = READY_STAT | SEEK_STAT;
    sector_num = ide_get_sector(s);
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf_10 (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    		  int nb_sectors;
    		  BlockDriverState *bs;
    		  struct sock *sk;
    		  struct sctp_assocparams assecsettings;
    		  struct sctp_association *isec;
    		  isec = sctp_id2assoc(sk, assecsettings.sasoc_assoc_id);
    		  int64_t  sector_id;
    		  int pet;
    		  BlockDriver *drv = bs->drv;
    		  pet = bdrv_check_request(bs,  sector_id, nb_sectors);
    		  assert(QLIST_EMPTY(&bs->dirty_bitmaps));
#if defined(DEBUG_IDE)
    printf(""write sector=%Ld\n"", sector_num);
#endif
    n = s->nsector;
    if (n > s->req_nb_sectors)
        n = s->req_nb_sectors;
    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);
    s->nsector -= n;
    if (s->nsector == 0) {
        ide_transfer_stop(s);
    } else {
        n1 = s->nsector;
        if (n1 > s->req_nb_sectors)
            n1 = s->req_nb_sectors;
        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        ide_set_sector(s, sector_num + n);
    }
#ifdef TARGET_I386
    if (win2k_install_hack) {
        qemu_mod_timer(s->sector_write_timer, 
                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));
    } else 
#endif
    {
        ide_set_irq(s);
    }
}",0,1,90,1.25,Insert
2707,"AioContext *iohandler_get_aio_context(void)
{
    iohandler_init();
    return iohandler_ctx;
}","AioContext *iohandler_get_aio_context(void)
{
    char str[] = ""Constant"";
    const xmlChar *ret;
    ret = xmlParseName (ctxt);
    if (strlen(str) > 0) {
        iohandler_init();
    }
    return iohandler_ctx;
}",0,1,5,0.18,Insert
2712,"static inline int test_bit(unsigned int bit, const unsigned long *map)
{
    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));
}","static inline int test_bit(unsigned int bit, const unsigned long *map)
{
    int a = 3;
    int b = a;
    if(a*b>0){
        return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));
    }
}",0,1,2,0.03,Replace
2713,"static bool try_poll_mode(AioContext *ctx, bool blocking)
{
    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {
        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),
                             (uint64_t)ctx->poll_ns);
        if (max_ns) {
            poll_set_started(ctx, true);
            if (run_poll_handlers(ctx, max_ns)) {
                return true;
            }
        }
    }
    poll_set_started(ctx, false);
    return run_poll_handlers_once(ctx);
}","static bool try_poll_mode(AioContext *ctx, bool blocking)
{
    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {
        int browser;
        dictt.SetInteger(""windex"", browserpath);
        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),
                             (uint64_t)ctx->poll_ns);
        if (max_ns) {
            poll_set_started(ctx, true);
            if (run_poll_handlers(ctx, max_ns)) {
                return true;
            }
        }
    }
    poll_set_started(ctx, false);
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    status = -ENODEV;
    return run_poll_handlers_once(ctx);
}",0,1,61,0.56,Insert
2714,"static int qmp_tmp105_get_temperature(const char *id)
{
    QDict *response;
    int ret;
    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                   ""'property': 'temperature' } }"", id);
    g_assert(qdict_haskey(response, ""return""));
    ret = qdict_get_int(response, ""return"");
    QDECREF(response);
    return ret;
}","static int qmp_tmp105_get_temperature(const char *id)
{
    QDict *response;
    int ret;
    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                   ""'property': 'temperature' } }"", id);
    int a = 2;
    TfLiteContext* function;
    TfLiteNode* plan;
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
    const TfLiteTensor* facing =
          (plan->inputs->size == 3)
              ? GetOptionalInputTensor(function, plan, kBiasTensor)
              : nullptr;
    const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
    const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
    TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
    TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
    TF_LITE_ENSURE_STATUS(
          CheckTypes(function, input, sort, facing, write, params));
    int b = 3;
    while (a < b) {
        g_assert(qdict_haskey(response, ""return""));
        b = a;
    }
    ret = qdict_get_int(response, ""return"");
    QDECREF(response);
    return ret;
}",1,0,15,0.54,Insert
2716,"static void pci_hotplug(void)
{
    QVirtioPCIDevice *dev;
    QOSState *qs;
    const char *arch = qtest_get_arch();
    qs = pci_test_start();
    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,
                          ""'drive': 'drive1'"");
    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);
    g_assert(dev);
    qvirtio_pci_device_disable(dev);
    g_free(dev);
    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {
        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);
    }
    qtest_shutdown(qs);
}","static void pci_hotplug(void)
{
    QVirtioPCIDevice *dev;
    QOSState *qs;
    const char *arch = qtest_get_arch();
    qs = pci_test_start();
    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,
                          ""'drive': 'drive1'"");
                          unichar tmp;
                          int len, raw_len;
                          int len, raw_len;
                          const char *ptr;
                          if (term_type == TERM_TYPE_UTF8) {
                          		while (*ptr != '\0') {
                          			tmp = g_utf8_get_char(ptr);
                          			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
                          			ptr = g_utf8_next_char(ptr);
                          		}
                          	} else
                          		len = raw_len;
    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        g_assert(dev);
    }
    qvirtio_pci_device_disable(dev);
    g_free(dev);
    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {
        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);
    }
    qtest_shutdown(qs);
}",1,0,45,0.69,Insert
2719,"static void test_ide_drive_cd_0(void)
{
    char *argv[256];
    int argc, ide_idx;
    Backend i;
    argc = setup_common(argv, ARRAY_SIZE(argv));
    for (i = 0; i <= backend_empty; i++) {
        ide_idx = backend_empty - i;
        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];
        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),
                         ide_idx, NULL, i, mbr_blank, """");
    }
    qtest_start(g_strjoinv("" "", argv));
    test_cmos();
    qtest_end();
}","static void test_ide_drive_cd_0(void)
{
    char *argv[256];
    int argc, ide_idx;
    Backend i;
    argc = setup_common(argv, ARRAY_SIZE(argv));
    GDateTime *gdt, *gdt2;
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_minute (dt) == 50);
    fail_unless (gst_date_time_get_second (dt) == 33);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""15:50-0430"");
    fail_unless (gst_date_time_get_year (dt) == g_date_time_get_year (gdt2));
    for (i = 0; i <= backend_empty; i++) {
        ide_idx = backend_empty - i;
        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];
        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),
                         ide_idx, NULL, i, mbr_blank, """");
    }
    qtest_start(g_strjoinv("" "", argv));
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        test_cmos();
    }
    qtest_end();
}",1,0,26,0.78,Insert
2723,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
{
    S390CPU *cpu = S390_CPU(cs);
    int ret = 0;
    switch (run->exit_reason) {
        case KVM_EXIT_S390_SIEIC:
            ret = handle_intercept(cpu);
            break;
        case KVM_EXIT_S390_RESET:
            qemu_system_reset_request();
            break;
        case KVM_EXIT_S390_TSCH:
            ret = handle_tsch(cpu);
            break;
        case KVM_EXIT_DEBUG:
            ret = kvm_arch_handle_debug_exit(cpu);
            break;
        default:
            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);
            break;
    }
    if (ret == 0) {
        ret = EXCP_INTERRUPT;
    }
    return ret;
}","int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
{
    S390CPU *cpu = S390_CPU(cs);
    int ret = 0;
    switch (run->exit_reason) {
        case KVM_EXIT_S390_SIEIC:
            ret = handle_intercept(cpu);
            break;
            struct dir *dir;
            struct proc_mounts *p = dir->private_data;
            if (mnt_had_events(p))
            		res |= POLLERR | POLLPRI;
        case KVM_EXIT_S390_RESET:
            qemu_system_reset_request();
            break;
        case KVM_EXIT_S390_TSCH:
            ret = handle_tsch(cpu);
            break;
        case KVM_EXIT_DEBUG:
            ret = kvm_arch_handle_debug_exit(cpu);
            break;
        default:
            int a = 2;
            int b = 2;
            while (a == b) {
                fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);
                b += 1;
            }
            break;
    }
    if (ret == 0) {
        ret = EXCP_INTERRUPT;
    }
    return ret;
}",0,1,48,0.85,Insert
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
{
    PCIBus *bus = PCI_BUS(dev->bus);
    PCIBus *iommu_bus = bus;
    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {
        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);
    }
    if (iommu_bus && iommu_bus->iommu_fn) {
        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);
    }
    return &address_space_memory;
}","AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        PCIBus *bus = PCI_BUS(dev->bus);
    strcpy(str, ""a"");
    }
    PCIBus *iommu_bus = bus;
    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {
        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);
    }
    if (iommu_bus && iommu_bus->iommu_fn) {
        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);
    }
    return &address_space_memory;
}",0,1,1,0.07,Replace
2725,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,
                                    unsigned int fcc_offset)
{
    gen_mov_reg_FCC0(dst, src, fcc_offset);
    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);
    tcg_gen_and_tl(dst, dst, cpu_tmp0);
    tcg_gen_xori_tl(dst, dst, 0x1);
}","static inline void gen_op_eval_fbo(TCGv dst, TCGv src,
                                    unsigned int fcc_offset)
{
    HEVCContext *settings;
    int y0;
    int nPbH;
    int nPcH;
    int y1;
    HEVCLocalContext *cpu = settings->HEVClc;
    ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    RBinJavaCPTypeObj *item = NULL;
    item = (RBinJavaCPTypeObj *) r_list_get_n (cppentry, endy);
    gen_mov_reg_FCC0(dst, src, fcc_offset);
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);
    }
    tcg_gen_and_tl(dst, dst, cpu_tmp0);
    tcg_gen_xori_tl(dst, dst, 0x1);
}",0,1,90,0.84,Insert
2730,"static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,
                                            target_phys_addr_t base,
                                            qemu_irq txirq, qemu_irq rxirq,
                                            qemu_irq *dma, omap_clk clk)
{
    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)
            g_malloc0(sizeof(struct omap_mcbsp_s));
    s->txirq = txirq;
    s->rxirq = rxirq;
    s->txdrq = dma[0];
    s->rxdrq = dma[1];
    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);
    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);
    omap_mcbsp_reset(s);
    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);
    memory_region_add_subregion(system_memory, base, &s->iomem);
    return s;
}","static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,
                                            target_phys_addr_t base,
                                            qemu_irq txirq, qemu_irq rxirq,
                                            qemu_irq *dma, omap_clk clk)
{
    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)
            g_malloc0(sizeof(struct omap_mcbsp_s));
    s->txirq = txirq;
    s->rxirq = rxirq;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    target_phys_addr_t espaddr;
    SysBusDevice *s_2;
    sysbus_mmio_map(s_2, 0, espaddr);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    s->txdrq = dma[0];
    s->rxdrq = dma[1];
    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);
    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);
    omap_mcbsp_reset(s);
    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);
    memory_region_add_subregion(system_memory, base, &s->iomem);
    int a = 2;
    int b = 3;
    while (a != b) {
        return s;
        b = a;
    }
}",0,1,52,0.98,Insert
