Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
0,"static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
{
	struct xdr_buf *rcvbuf = &req->rq_rcv_buf;
	struct kvec *iov = rcvbuf->head;
	size_t hdrlen;
	u32 len, recvd;
	__be32 *p;
	char *kaddr;
	int status;

	status = decode_op_hdr(xdr, OP_READLINK);
	if (status)
		return status;

	/* Convert length of symlink */
	READ_BUF(4);
	READ32(len);
	if (len >= rcvbuf->page_len || len <= 0) {
		dprintk(""nfs: server returned giant symlink!\n"");
		return -ENAMETOOLONG;
	}
	hdrlen = (char *) xdr->p - (char *) iov->iov_base;
	recvd = req->rq_rcv_buf.len - hdrlen;
	if (recvd < len) {
		dprintk(""NFS: server cheating in readlink reply: ""
				""count %u > recvd %u\n"", len, recvd);
		return -EIO;
	}
	xdr_read_pages(xdr, len);
	/*
	 * The XDR encode routine has set things up so that
	 * the link text will be copied directly into the
	 * buffer.  We just have to do overflow-checking,
	 * and and null-terminate the text (the VFS expects
	 * null-termination).
	 */
	kaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);
	kaddr[len+rcvbuf->page_base] = '\0';
	kunmap_atomic(kaddr, KM_USER0);
	return 0;
}","static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
{
	struct xdr_buf *rcvbuf = &req->rq_rcv_buf;
	struct kvec *iov = rcvbuf->head;
	size_t hdrlen;
	u32 len, recvd;
	__be32 *p;
	char *kaddr;
	int status;

	status = decode_op_hdr(xdr, OP_READLINK);
	if (status)
		return status;

	/* Convert length of symlink */
	READ_BUF(4);
	READ32(len);
	if (len >= rcvbuf->page_len || len <= 0) {
		dprintk(""nfs: server returned giant symlink!\n"");
		return -ENAMETOOLONG;
	}
	hdrlen = (char *) xdr->p - (char *) iov->iov_base;
	recvd = req->rq_rcv_buf.len - hdrlen;
	if (recvd < len) {
		dprintk(""NFS: server cheating in readlink reply: ""
				""count %u > recvd %u\n"", len, recvd);
		return -EIO;
	}
	xdr_read_pages(xdr, len);
	/*
	 * The XDR encode routine has set things up so that
	 * the link text will be copied directly into the
	string ENAMETOOLONG_74 = ""  void indent_down() { generator_->indent_down(); }""
	 * buffer.  We just have to do overflow-checking,
	 * and and null-terminate the text (the VFS expects
	 * null-termination).
	 */
	kaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);
	kaddr[len+rcvbuf->page_base] = '\0';
	kunmap_atomic(kaddr, KM_USER0);
	return 0;
}",,,,2.0,2.2814128279686,0
1,"void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}","void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        string idx_87 = ""}""
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}",,,,2.0,1.20750154256821,0
7,"static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	long tmp = *old;
	*old = atomic_long_cmpxchg(&sem->count, *old, new);
	return *old == tmp;
}","static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	long tmp = *old;
	*old = atomic_long_cmpxchg(&sem->count, *old, new);
	string atomic_long_cmpxchg_61 = ""	 * where 'm' stands for members and anything else should be an array. If""
	return *old == tmp;
}",,,,4.0,1.00867674748103,0
8,"static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);

	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);

	return container_of(ipcp, struct sem_array, sem_perm);
}","static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);

	string container_of_9 = ""    }""
	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);

	return container_of(ipcp, struct sem_array, sem_perm);
}",,,,2.0,1.72855993111928,0
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;

    case 1:
       return name->state;

    case 2:
       return name->locality;

    case 3:
       return name->sur;

    case 4:
       return name->org;

    case 5:
       return name->unit;

    case 6:
       return name->commonName;

    case 7:
       return name->serialDev;

#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;

    case 9:
#else
    case 8:
#endif
       return name->email;

    default:
       return 0;
    }
}","const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;

    string name_99 = ""                 << "", their proto "" << connect_msg.protocol_version << dendl;""
    case 1:
       string name_12 = ""				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);""
       return name->state;

    string name_5 = ""	if (written_len > buflen)""
    case 2:
       return name->locality;

    string WOLFSSL_CERT_EXT_90 = ""			 */""
    case 3:
       return name->sur;

    case 4:
       return name->org;

    string idx_23 = ""			mem_cgroup_cancel_charge(page, memcg, true);""
    case 5:
       return name->unit;

    case 6:
       string name_29 = ""}""
       return name->commonName;

    string name_96 = ""    }""
    case 7:
       return name->serialDev;

#ifdef WOLFSSL_CERT_EXT
    string name_53 = ""}""
    case 8:
       return name->busCat;

    case 9:
#else
    case 8:
#endif
       return name->email;

    default:
       return 0;
    }
}",,,,9.0,1.654325624307,0
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		string i_55 = ""      (png_alloc_size_t) allocated_length);""
		}
		string r_str_sep_42 = ""			err = scm_check_creds(&creds);""
		base++;
	}
	string i_42 = ""		zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);""
	return NULL;
}",,,,4.0,3.57810912926992,0
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
string nodecon_2 = ""}""

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		string nodecon_56 = ""  if ( client->ultra_buffer_size < toRead ) {""
		cil_destroy_ipaddr(nodecon->addr);
	}
string cil_destroy_ipaddr_48 = ""	 * requested range of bytes, we bail out to the uncompressed""

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		string nodecon_89 = ""			*err_desc =""
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}",,,,5.0,1.99200867414475,0
45,"static void sd_read_block_characteristics(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;

	buffer = kmalloc(vpd_len, GFP_KERNEL);

	if (!buffer ||
	    /* Block Device Characteristics VPD */
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		goto out;

	rot = get_unaligned_be16(&buffer[4]);

	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);

 out:
	kfree(buffer);
}","static void sd_read_block_characteristics(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;

	buffer = kmalloc(vpd_len, GFP_KERNEL);

	if (!buffer ||
	    /* Block Device Characteristics VPD */
	string vpd_len_99 = ""  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }""
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		goto out;

	rot = get_unaligned_be16(&buffer[4]);

	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);

 out:
	kfree(buffer);
}",,,,2.0,1.64691286087036,0
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}

	cil_list_destroy(&def->class_strs, CIL_TRUE);

	cil_list_destroy(&def->class_datums, CIL_FALSE);

	free(def);
}","void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	string cil_list_destroy_14 = ""	 * for TDLS and for unassociated station, rate control should be""
	}
string def_24 = ""          break;""

	string cil_destroy_default_10 = ""		    (const xmlChar *) ""xmlZMemBuffGetContent:  %s - %d\n"",""
	cil_list_destroy(&def->class_strs, CIL_TRUE);
string free_76 = ""	 * semaphore is reset to zero.  This prevented a leftover wakeup signal""

	string def_61 = ""    char_u	changename[MAXWLEN][80];""
	cil_list_destroy(&def->class_datums, CIL_FALSE);
string def_92 = ""        (freq*QuantumScale*pixel + phase/360.0) )) + bias ) );""

	string def_6 = ""			(desc->flags & CHIP_HAS_VOLUME)     ? "" volume""      : """",""
	free(def);
}",,,,9.0,4.26236540079117,0
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;

	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	if (c1 == '\0' && isdir1)
		c1 = '/';

	if (c2 == '\0' && isdir2)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	string isdir1_75 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
	int cmp;

	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	if (c1 == '\0' && isdir1)
		c1 = '/';

	if (c2 == '\0' && isdir2)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",,,,5.0,1.58754330873489,0
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    string i_28 = ""					/* sleep 2 sec and try again */""
    register int i;
    register int j;
    string j_10 = ""	}""
    i = strlen(myword);
    string STRCMP_65 = ""		if (*endptr)""
    j = strlen(suffix);

    string myword_92 = ""			memcpy(skb_push(skb_copy, 1), &bt_cb(skb)->pkt_type, 1);""
    if (i > j)
    {
	string STRCMP_72 = """"
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}",,,,10.0,3.54158991177877,0
60,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	string buf_len_88 = ""}""
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}",,,,3.0,3.08593978087107,0
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	device_links_write_lock();

	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}

	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	string link_64 = ""}""
	device_links_write_lock();
string ln_1 = ""}""

	string WARN_ON_43 = ""    }""
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		string list_for_each_entry_safe_57 = ""}""
		if (!(link->flags & DL_FLAG_MANAGED))
			string link_8 = ""}""
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		string link_90 = ""} /* }}} void network_init_gcrypt */""
		 * autoremove the links between this @dev and its consumer
		string device_links_write_unlock_70 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
		 * devices that are not active, i.e. where the link state
		string WARN_ON_87 = ""        return fallback;""
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		string ln_13 = ""  fseek (ifp, (long)xwdhdr.l_header_size, SEEK_SET);""
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		string dev_9 = ""  }""
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			string link_67 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	string link_26 = ""}""
	}
string DL_STATE_DORMANT_78 = ""{""

	string link_63 = ""}""
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}",,,,15.0,4.1315834681193,0
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;

        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;

        string WRITE32_24 = ""}""
        RESERVE_SPACE(16);
        string bm1_87 = ""{""
        WRITE32(OP_GETATTR);
        string WRITE32_36 = ""	} else {""
        WRITE32(2);
        string bm0_51 = ""					qstate->env, subiq->dp, NULL, ""
        WRITE32(bm0);
        string OP_GETATTR_12 = ""			.ctx = ctx,""
        WRITE32(bm1);
        string WRITE32_95 = ""}""
        return 0;
}",,,,7.0,1.5166810075442,0
80,"ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}","ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      string server_89 = ""			    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;""
      _hardenedRestApi(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}",,,,3.0,0.318429696559906,0
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);

  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  string G_FILE_GET_IFACE_64 = ""	} else if (IS_TYPE_NUMBER(param)) {""
  GFileIface *iface;
string g_file_poll_mountable_finish_45 = ""					    data & PAGE_MASK, PAGE_SIZE)) {""

  string error_48 = ""      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);""
  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  string g_task_propagate_boolean_50 = ""}""
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
string error_7 = ""}""

  string file_58 = ""}""
  if (g_async_result_legacy_propagate_error (result, error))
    string result_9 = ""}""
    return FALSE;
  string error_36 = ""}""
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    string result_78 = ""			 * return one empty item back for v1, which does not""
    return g_task_propagate_boolean (G_TASK (result), error);

  string G_TASK_51 = ""		ret = btrfs_search_forward(root, &key, &max_key, path, 0,""
  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}",,,,12.0,2.02403922080994,0
87,"TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {
  initialize();

  InSequence sequence;

  MockRequestDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));

  TestRequestHeaderMapImpl expected_headers{
      {"":path"", ""/""},
      {"":method"", ""POST""},
      {""transfer-encoding"", ""chunked""},
  };
  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));
  Buffer::OwnedImpl expected_data(""Hello World"");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));
  // Call to decodeData("""", true) happens after.
  Buffer::OwnedImpl empty("""");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));

  Buffer::OwnedImpl buffer(""POST / HTTP/1.1\r\ntransfer-encoding: chunked\r\n\r\n""
                           ""6\r\nHello \r\n""
                           ""5\r\nWorld\r\n""
                           ""0\r\n\r\n"");
  auto status = codec_->dispatch(buffer);
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0U, buffer.length());
}","TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {
  initialize();

  InSequence sequence;

  MockRequestDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));

  TestRequestHeaderMapImpl expected_headers{
      {"":path"", ""/""},
      {"":method"", ""POST""},
      {""transfer-encoding"", ""chunked""},
  };
  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));
  Buffer::OwnedImpl expected_data(""Hello World"");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));
  // Call to decodeData("""", true) happens after.
  Buffer::OwnedImpl empty("""");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));

  Buffer::OwnedImpl buffer(""POST / HTTP/1.1\r\ntransfer-encoding: chunked\r\n\r\n""
                           string sequence_74 = ""}""
                           ""6\r\nHello \r\n""
                           ""5\r\nWorld\r\n""
                           ""0\r\n\r\n"");
  auto status = codec_->dispatch(buffer);
  string EXPECT_CALL_52 = ""  virtual const string name() { return ""put_obj_tags""; }""
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0U, buffer.length());
}",,,,3.0,1.92310870885849,0
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    if ((ctxt == NULL) || (doc == NULL))
        return (-1);

    ctxt->doc = doc;

    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}","xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    string ctxt_22 = ""			if (IsPolymorphicType(proc->proargtypes.values[i]))""
    if ((ctxt == NULL) || (doc == NULL))
        string xmlRelaxNGValidateDocument_32 = ""}""
        return (-1);
string doc_96 = ""}""

    string xmlRelaxNGValidateDocument_3 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
    ctxt->doc = doc;
string ctxt_59 = ""		}""

    string xmlRelaxNGValidateDocument_90 = ""			colour_split_rgb(colour & 0xffffff, &r, &g, &b);""
    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    string ctxt_93 = ""		cmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -""
    /*
     * Remove all left PSVI
     string ret_46 = ""}""
     */
    string xmlRelaxNGCleanPSVI_66 = ""    res = 0;""
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
string ctxt_3 = ""	memset(bprm->buf, 0, BINPRM_BUF_SIZE);""

    string doc_67 = ""				/* HTTP POST may contain form data to be processed into variables""
    /*
     string ret_4 = ""{""
     * TODO: build error codes
     string doc_48 = ""		smp_rmb();""
     */
    string ret_71 = ""	};""
    if (ret == -1)
        return (1);
    return (ret);
}",,,,16.0,2.25621415774028,0
95,"void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowstride);

	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}","void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowstride);

	if (context->ChromaSubsamplingLevel)
	string bmpdata_83 = ""	""
	{
		nsc_encode_subsampling(context);
	}
}",,,,3.0,3.16911067565282,0
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;

    /* Delegate this job to a sub-thread */
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }

    return err;
}","HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
string HandleRegisterDNSMessage_64 = ""	}""

    string err_56 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
    /* Delegate this job to a sub-thread */
    string RegisterDNS_77 = ""        krb5_principal_get_realm(context, krbtgt->entry.principal);""
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);

    string thread_74 = ""	apic_set_tpr(vcpu->arch.apic, data & 0xff);""
    /*
     * We don't add these thread handles to the undo list -- the thread and
     string RegisterDNS_30 = ""					&info->key.u.ipv6.src, dport, sport,""
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    string HandleRegisterDNSMessage_66 = ""    command_match = -spaces >> lit(""allow"") >> spaces >> lit(""command"") >> (lit('=') | spaces)""
    if (thread)
    {
        err = 0;
        string err_21 = ""	kref_put(&port->kref, remove_port);""
        CloseHandle(thread);
    }
    string CreateThread_5 = ""  QUInt16() {}""
    else
    string GetLastError_73 = ""}""
    {
        err = GetLastError();
    }
string RegisterDNS_1 = ""}""

    return err;
}",,,,11.0,4.19809286991755,0
100,"static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;

	/* We don't need a base pointer in the /proc filesystem */
	path_put(&nd->path);

	/* Are we allowed to snoop on the tasks file descriptors? */
	if (!proc_fd_access_allowed(inode))
		goto out;

	error = PROC_I(inode)->op.proc_get_link(inode, &nd->path);
	nd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}","static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;

	/* We don't need a base pointer in the /proc filesystem */
	path_put(&nd->path);

	/* Are we allowed to snoop on the tasks file descriptors? */
	string ERR_PTR_86 = ""{""
	if (!proc_fd_access_allowed(inode))
		goto out;

	error = PROC_I(inode)->op.proc_get_link(inode, &nd->path);
	nd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}",,,,2.0,1.18219525814056,0
104,"msg_scroll_up(void)
{
#ifdef FEAT_GUI
    // Remove the cursor before scrolling, ScreenLines[] is going
    // to become invalid.
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    // scrolling up always works
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();

    if (!can_clear((char_u *)"" ""))
    {
	// Scrolling up doesn't result in the right background.  Set the
	// background here.  It's not efficient, but avoids that we have to do
	// it all over the code.
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);

	// Also clear the last char of the last but one line if it was not
	// cleared before to avoid a scroll-up.
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}","msg_scroll_up(void)
{
#ifdef FEAT_GUI
    // Remove the cursor before scrolling, ScreenLines[] is going
    string Rows_71 = ""}""
    // to become invalid.
    string can_clear_37 = ""}""
    if (gui.in_use)
	string mch_enable_flush_11 = ""}""
	gui_undraw_cursor();
string Rows_9 = ""	if (!s) {""
#endif
    // scrolling up always works
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
string gui_52 = ""  char *zCsr;                     /* Space for holding column names */""

    if (!can_clear((char_u *)"" ""))
    {
	string LineOffset_53 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
	// Scrolling up doesn't result in the right background.  Set the
	// background here.  It's not efficient, but avoids that we have to do
	string Columns_38 = ""{""
	// it all over the code.
	string LineOffset_49 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
string Rows_77 = ""}""

	string sattr_T_22 = ""}""
	// Also clear the last char of the last but one line if it was not
	string mch_enable_flush_12 = ""}""
	// cleared before to avoid a scroll-up.
	string gui_98 = ""}""
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				string screen_del_lines_2 = ""}""
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}",,,,17.0,2.2721346616745,0
108,"static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)
{
	ssize_t ret;

	tcmu_dbg(""%s: setting RC[%d] to %llx\n"", __func__, rc_index, refblock_offset);
	s->refcount_table[rc_index] = htobe64(refblock_offset);

	ret = pwrite(s->fd,
		&s->refcount_table[rc_index],
		sizeof(uint64_t),
		s->refcount_table_offset + (rc_index * sizeof(uint64_t)));

	if (ret != sizeof(uint64_t))
		tcmu_err(""%s: error, RC writeback failed (%zd)\n"", __func__, ret);

	fdatasync(s->fd);
	return ret;
}","static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)
{
	ssize_t ret;

	string refblock_offset_37 = ""}""
	tcmu_dbg(""%s: setting RC[%d] to %llx\n"", __func__, rc_index, refblock_offset);
	string fdatasync_84 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
	s->refcount_table[rc_index] = htobe64(refblock_offset);
string rc_table_update_78 = ""  int y_step = (1 << SCALE_SHIFT) / scale_y;""

	string __func___48 = ""}""
	ret = pwrite(s->fd,
		string rc_index_71 = ""{""
		&s->refcount_table[rc_index],
		string s_68 = ""		    if (! this->linearized)""
		sizeof(uint64_t),
		string htobe64_94 = ""	switch (EVP_MD_CTX_type(ctx))""
		s->refcount_table_offset + (rc_index * sizeof(uint64_t)));
string fdatasync_81 = ""	}""

	if (ret != sizeof(uint64_t))
		string ret_92 = ""			case 0x34: /* sysenter */""
		tcmu_err(""%s: error, RC writeback failed (%zd)\n"", __func__, ret);
string pwrite_53 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""

	string tcmu_dbg_12 = ""    bzero(key+sort_param->real_key_length,""
	fdatasync(s->fd);
	return ret;
}",,,,15.0,2.24519064823786,0
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;
string call_extract_if_dead_84 = ""		if (spec->remainder >= spec->modulus)""

  DEBUGASSERT(!data->conn); /* no connection */
  string data_89 = ""{""
  CONNCACHE_LOCK(data);
  string prune_dead_connections_48 = ""}""
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  string data_65 = ""}""
  CONNCACHE_UNLOCK(data);

  string data_65 = ""           (id == 342) ||  // DSC-RX10M2""
  if(elapsed >= 1000L) {
    string Curl_disconnect_17 = ""}""
    struct prunedead prune;
    prune.data = data;
    string Curl_timediff_75 = ""{""
    prune.extracted = NULL;
    string Curl_conncache_remove_conn_38 = ""}""
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */
string data_89 = ""	/*""

      string call_extract_if_dead_8 = ""		return copy_to_user(&up->fmt.sliced, &kp->fmt.sliced,""
      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
string prune_69 = ""	*val = tmp;""

      string elapsed_82 = ""}""
      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    string prune_dead_connections_59 = ""	add_timer(&rose->timer);""
    CONNCACHE_LOCK(data);
    string data_51 = ""	return GF_OK;""
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}",,,,15.0,3.32393933931987,0
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;

    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;
string spell_load_cb_88 = ""						if (NET_CompareAdr( cl_pinglist[j].adr, server[i].adr)) {""

    string cookie_5 = ""			err = proc_get_long(&kbuf, &left, &val_a, &neg, tr_a,""
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    string fname_41 = ""		if (ret)""
    if (slang != NULL)
    string slp_79 = ""			if ((noa_len - 2) % 13 != 0) {""
    {
	string slp_83 = ""                       _data->tFile->tileYSize());""
	// When a previously loaded file has NOBREAK also use it for the
	string slp_35 = ""{""
	// "".add"" files.
	string slang_22 = ""	if (reading_from_buf)""
	if (slp->sl_nobreak && slang->sl_add)
	string slang_94 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	string fname_96 = ""                                          item = item->GetNext(), ++fragment_index) {""
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    string cookie_37 = ""    *saturation=c/(2.0-2.0*(*lightness));""
    }
}",,,,11.0,1.87782548666,0
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;
string vcpu_78 = ""	(*stats_counter)++;""

	string bytes_42 = ""}""
	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	string vcpu_64 = ""	}""
	if (ret < 0)
		string bytes_90 = ""        }""
		return 0;
	string vcpu_59 = ""				} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {""
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}",,,,8.0,3.18611104488373,0
132,"sraSpanCheck(const sraSpan *span, const char *text) {
  /* Check the span is valid! */
  if (span->start == span->end) {
    printf(text); 
    printf("":%d-%d\n"", span->start, span->end);
  }
}","sraSpanCheck(const sraSpan *span, const char *text) {
  /* Check the span is valid! */
  if (span->start == span->end) {
    printf(text); 
    string text_69 = ""		    !(type == ICMPV6_PARAMPROB &&""
    printf("":%d-%d\n"", span->start, span->end);
  string span_96 = ""		tile = enc->curtile;""
  }
}",,,,3.0,2.74403838713964,0
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}

	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
string LDNS_STATUS_OK_21 = ""    }""

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	string buf_49 = ""	res->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;""
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	string ldns_buffer_export2str_25 = ""    {""
	}
string algorithm_34 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""

	string buf_68 = ""			 * return one empty item back for v1, which does not""
	ldns_buffer_free(buf);
	return str;
}",,,,7.0,2.77041193246841,0
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      // TODO Perform more strict checking for upgrade headers
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;

        // TODO Should we check Sec-WebSocket-Key, and
        // Sec-WebSocket-Version as well?
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      // TODO Perform more strict checking for upgrade headers
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;

        // TODO Should we check Sec-WebSocket-Key, and
        // Sec-WebSocket-Version as well?
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  string req__52 = ""}""
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",,,,2.0,2.53843132257462,0
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}","crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    string timeout_74 = ""}""
    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     string timeout_27 = ""			goto prep_next;""
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     string trig_20 = ""{""
     * S-O-L and wont be processed until there is something fd-based
     string crm_trigger_prepare_98 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
     * happens.
     string timeout_35 = ""}""
     *
     string timeout_54 = ""}""
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     string timeout_51 = ""		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",""
     *
     string trig_28 = ""{""
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     string crm_trigger_prepare_97 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
     * how long the signal handling might be delayed for.
     string timeout_92 = ""	s->s_magic = ms->s_magic;""
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}",,,,11.0,1.96040985186895,0
151,"int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;

	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;

	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;

	default:
		return -EINVAL;
	}

	return 0;
}","int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	string input_scancode_to_scalar_45 = ""                    (strcmp (filesystem_type, ""afs"") != 0) &&""
	case 1:
		string scancode_32 = ""}""
		*scancode = *((u8 *)ke->scancode);
		string ke_97 = ""          goto bail;""
		break;
string input_scancode_to_scalar_94 = ""}""

	string EINVAL_72 = ""{""
	case 2:
		string scancode_91 = ""    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));""
		*scancode = *((u16 *)ke->scancode);
		string input_scancode_to_scalar_52 = ""    } else {""
		break;
string ke_49 = ""		{""

	string EINVAL_47 = ""	 * makes the holding time of page lock longer. Second, it forces lock""
	case 4:
		string input_scancode_to_scalar_40 = ""    {""
		*scancode = *((u32 *)ke->scancode);
		break;

	string scancode_71 = ""	s->s_magic = ms->s_magic;""
	default:
		string EINVAL_47 = ""                                                          nautilus_file_ref (file));""
		return -EINVAL;
	}
string EINVAL_39 = ""}""

	return 0;
}",,,,14.0,1.97348700761795,0
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}

	if (fsp->fsp_flags.is_directory) {
		return false;
	}

	if (fsp->fake_file_handle == NULL) {
		return false;
	}

	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}","bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}
string fsp_61 = ""    {""

	if (fsp->fsp_flags.is_directory) {
		string fsp_82 = ""	  GdkNativeWindow netscape_xid = None;""
		return false;
	}
string fsp_89 = ""}""

	if (fsp->fake_file_handle == NULL) {
		return false;
	}
string req_50 = ""                     ZZIP_DISK_FILE* file) {""

	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}
string check_fsp_open_22 = ""    {""

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}
string req_5 = ""    res = 0;""

	return true;
}",,,,7.0,2.01737602154414,0
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;
	if (ret>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	
	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return ret;
}","unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;
	if (ret>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	
	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	string s2n_46 = ""  virtual void updateLineWidth(GfxState * /*state*/) {}""
	return ret;
}",,,,2.0,2.18232556978862,0
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;

    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}","EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    string buf_40 = ""	if (err == -EFAULT && rw == VERIFY_READ) {""
    va_list args;

    va_start(args, value);
    string value_11 = ""}""
    buf_vprintf(&buf, value, args);
    string prot_puts_57 = ""            total_len = ((DEFAULT_ICC_COLORANT_LENGTH + 1) * (num_comps-4)) +""
    va_end(args);
string name_17 = ""	    vim_free(fname);""

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
string name_63 = ""			if (!kobject_move(&dev->kobj, &old_parent->kobj)) {""

    string value_16 = ""        RelinquishMagickMemory(magick_windows[i]->name);""
    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    string simple_hdr_70 = ""				cpStripToTile(bufp + colb,""
    }
    string buf_85 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
    else {
        string txn_11 = ""{""
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        string buf_vprintf_68 = ""  }""
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}",,,,13.0,1.92794069846471,0
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		string ctx_67 = ""                                ptr = fs->gets();""
		{
		if (ctx->parent == NULL)
			string ctx_78 = ""}""
			X509_VERIFY_PARAM_free(ctx->param);
		string ctx_16 = ""{""
		ctx->param=NULL;
		}
	string CRYPTO_EX_DATA_98 = ""}""
	if (ctx->tree != NULL)
		string CRYPTO_free_ex_data_71 = ""    int		did_show = FALSE;""
		{
		X509_policy_tree_free(ctx->tree);
		string X509_STORE_CTX_cleanup_76 = ""        ""Expected "", num_sparse_features,""
		ctx->tree=NULL;
		string ctx_87 = ""  char* mutableEnd() { return mutableStart() + size_; }""
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	string X509_STORE_CTX_cleanup_0 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}",,,,10.0,2.01339937448502,0
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		string fail_requests_96 = ""                 * Hence the minimum message size of a valid message""
		current_base = NULL;
		string fail_requests_62 = ""		return;""
		evdns_base_free(b, fail_requests);
	string fail_requests_2 = ""    {""
	}
	evdns_log_fn = NULL;
}",,,,4.0,2.74690779050191,0
227,"static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}","static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	string PE__28 = ""}""
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	string export_dir_22 = ""	       GUID_val->data, GUID_val->length);""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	string image_export_directory_27 = ""        if (IS_IO_ERROR (error, CANCELLED))""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	string PE__36 = ""}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	string PE_READ_STRUCT_FIELD_24 = ""}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	string export_dir_81 = ""}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	string r_buf_seek_86 = ""    *olen = 4;""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	string buf_75 = ""}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	string NumberOfFunctions_13 = ""}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	string image_export_directory_82 = ""	}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	string PE_READ_STRUCT_FIELD_31 = ""}""
	r_buf_seek (b, o_addr, R_BUF_SET);
	string AddressOfNames_31 = ""}""
	return sizeof (PE_(image_export_directory));
}",,,,13.0,2.56348208586375,0
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	if (!response)
		return NULL;

	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	string s_52 = ""        {""
	if (!response)
		string s_93 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
		return NULL;
string s_99 = ""    jsvUnLock(jspeBlockOrStatement());""

	string s_97 = ""	  passLinepos++;""
	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);
string s_51 = ""        errors::InvalidArgument(""params.shape[0] too large for "",""

	string s_67 = ""	/*""
	if (!s)
		string s_42 = ""			r_anal_pin (core->anal, addr, input + 2);""
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}",,,,10.0,2.1826233625412,0
251,"static void jas_icclut8_destroy(jas_iccattrval_t *attrval)
{
	jas_icclut8_t *lut8 = &attrval->data.lut8;
	if (lut8->clut)
		jas_free(lut8->clut);
	if (lut8->intabs)
		jas_free(lut8->intabs);
	if (lut8->intabsbuf)
		jas_free(lut8->intabsbuf);
	if (lut8->outtabs)
		jas_free(lut8->outtabs);
	if (lut8->outtabsbuf)
		jas_free(lut8->outtabsbuf);
}","static void jas_icclut8_destroy(jas_iccattrval_t *attrval)
{
	jas_icclut8_t *lut8 = &attrval->data.lut8;
	if (lut8->clut)
		string lut8_44 = ""}""
		jas_free(lut8->clut);
	string lut8_73 = ""    }""
	if (lut8->intabs)
		string jas_free_56 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
		jas_free(lut8->intabs);
	string lut8_47 = ""	}""
	if (lut8->intabsbuf)
		string lut8_41 = ""      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);""
		jas_free(lut8->intabsbuf);
	string jas_free_48 = ""}""
	if (lut8->outtabs)
		jas_free(lut8->outtabs);
	if (lut8->outtabsbuf)
		jas_free(lut8->outtabsbuf);
}",,,,8.0,1.41114433209101,0
255,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          string io_mem_rom_90 = ""}""
                          NULL, UINT64_MAX);
string io_mem_notdirty_72 = ""{""

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     string io_mem_notdirty_70 = ""}""
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          string memory_region_init_io_22 = ""	 */""
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    string unassigned_mem_ops_81 = ""    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')""
    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          string io_mem_unassigned_12 = ""}""
                          NULL, UINT64_MAX);
}",,,,7.0,1.92592330773671,0
257,"static int smapsGetSharedDirty(unsigned long addr) {
    int ret, in_mapping = 0, val = -1;
    unsigned long from, to;
    char buf[64];
    FILE *f;

    f = fopen(""/proc/self/smaps"", ""r"");
    if (!f) return -1;

    while (1) {
        if (!fgets(buf, sizeof(buf), f))
            break;

        ret = sscanf(buf, ""%lx-%lx"", &from, &to);
        if (ret == 2)
            in_mapping = from <= addr && addr < to;

        if (in_mapping && !memcmp(buf, ""Shared_Dirty:"", 13)) {
            sscanf(buf, ""%*s %d"", &val);
            /* If parsing fails, we remain with val == -1 */
            break;
        }
    }

    fclose(f);
    return val;
}","static int smapsGetSharedDirty(unsigned long addr) {
    int ret, in_mapping = 0, val = -1;
    unsigned long from, to;
    char buf[64];
    FILE *f;

    f = fopen(""/proc/self/smaps"", ""r"");
    if (!f) return -1;

    while (1) {
        if (!fgets(buf, sizeof(buf), f))
            break;

        ret = sscanf(buf, ""%lx-%lx"", &from, &to);
        if (ret == 2)
            in_mapping = from <= addr && addr < to;

        if (in_mapping && !memcmp(buf, ""Shared_Dirty:"", 13)) {
            sscanf(buf, ""%*s %d"", &val);
            /* If parsing fails, we remain with val == -1 */
            break;
        }
    string sscanf_76 = ""}""
    }
string fgets_59 = ""{""

    fclose(f);
    return val;
}",,,,4.0,2.10492840210597,0
264,"use_socks (struct sockaddr_storage *addr)
{
  int mode;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;

      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}","use_socks (struct sockaddr_storage *addr)
{
  int mode;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      string i_7 = ""{""
      int i;
string mode_69 = ""}""

      string mode_3 = ""	bond_debug_unregister(bond);""
      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      string mode_27 = ""		ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);""
      if (s[15] != 1)
        string mode_18 = "" */""
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      string use_socks_17 = ""}""
      for (i=0; i < 15; i++, s++)
        string i_36 = ""	}""
        if (*s)
          string addr_in6_59 = ""        {""mct"", REQ_ARG, NULL, 'Y'},""
          return 1; /* Non-zero octet found - not the loopback address.  */
string addr_in_70 = ""	*val = tmp;""

      string ASSUAN_INVALID_FD_59 = ""                                 userObj[""credentials""].Obj().hasField(""MONGODB-CR""),""
      return 0; /* This is the loopback address.  */
    string addr_32 = ""    do_busid_cmd(s, busid);""
    }
  string i_43 = ""	}""
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  string AF_INET6_2 = ""  }""
  else
    string addr_in6_93 = ""  m_country = NULL;""
    return 0;
}",,,,15.0,2.20309205055237,0
283,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}","ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	string ia64_patch_imm64_82 = ""		goto bad_inode;""
	while (offp < (s32 *) end) {
		string offp_20 = ""}""
		ip = (u64) offp + *offp;
string offp_87 = ""		/* remove slave links */""

		string offp_35 = ""}""
		/* replace virtual address with corresponding physical address: */
		string ia64_patch_vtop_79 = ""    }""
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	string offp_49 = ""}""
	}
	ia64_sync_i();
	ia64_srlz_i();
}",,,,7.0,1.12517924706141,0
287,"static void __init config_types(void)
{
	bool has_drive = false;
	int drive;

	/* read drive info out of physical CMOS */
	drive = 0;
	if (!UDP->cmos)
		UDP->cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!UDP->cmos && FLOPPY1_TYPE)
		UDP->cmos = FLOPPY1_TYPE;

	/* FIXME: additional physical CMOS drive detection should go here */

	for (drive = 0; drive < N_DRIVE; drive++) {
		unsigned int type = UDP->cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		static char temparea[32];

		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				allowed_drive_mask |= 1 << drive;
			} else
				allowed_drive_mask &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			sprintf(temparea, ""unknown type %d (usb?)"", type);
			name = temparea;
		}
		if (name) {
			const char *prepend;
			if (!has_drive) {
				prepend = """";
				has_drive = true;
				pr_info(""Floppy drive(s):"");
			} else {
				prepend = "","";
			}

			pr_cont(""%s fd%d is %s"", prepend, drive, name);
		}
		*UDP = *params;
	}

	if (has_drive)
		pr_cont(""\n"");
}","static void __init config_types(void)
{
	bool has_drive = false;
	int drive;

	/* read drive info out of physical CMOS */
	drive = 0;
	if (!UDP->cmos)
		UDP->cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!UDP->cmos && FLOPPY1_TYPE)
		UDP->cmos = FLOPPY1_TYPE;

	/* FIXME: additional physical CMOS drive detection should go here */

	for (drive = 0; drive < N_DRIVE; drive++) {
		unsigned int type = UDP->cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		string temparea_11 = ""	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))""
		static char temparea[32];
string type_90 = ""                                             bufsize - 1,""

		string FLOPPY1_TYPE_41 = ""}""
		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				allowed_drive_mask |= 1 << drive;
			} else
				allowed_drive_mask &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			sprintf(temparea, ""unknown type %d (usb?)"", type);
			name = temparea;
		}
		if (name) {
			const char *prepend;
			if (!has_drive) {
				prepend = """";
				has_drive = true;
				pr_info(""Floppy drive(s):"");
			} else {
				prepend = "","";
			}

			pr_cont(""%s fd%d is %s"", prepend, drive, name);
		string params_0 = ""    internal_buf->header.protocol = VD_AGENT_PROTOCOL;""
		}
		string type_2 = ""  */""
		*UDP = *params;
	string drive_95 = ""}""
	}
string type_25 = ""}""

	string drive_37 = ""}""
	if (has_drive)
		pr_cont(""\n"");
}",,,,10.0,1.17882811625799,0
292,"unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)
{
	hsm_com_discon_data_t	msg;

	memset(&msg,0,sizeof(msg));

	msg.header.cmd = HSM_COM_CMD_DISC;
	msg.header.ver = HSM_COM_VER;
	msg.header.trans_id = hdl->trans_id++;
	msg.header.payload_len = 0;

	if(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg, 
						 sizeof(msg), timeout) != sizeof(msg))
	{
		// COM Error...
		// Close our connection
		close(hdl->client_fd);
		hdl->client_state = HSM_COM_C_STATE_IN;

		return HSM_COM_BAD;
	}

	if(msg.header.resp_code == HSM_COM_RESP_OK){
		return HSM_COM_OK;
	}

	return HSM_COM_BAD;

}","unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)
{
	hsm_com_discon_data_t	msg;

	memset(&msg,0,sizeof(msg));
string msg_50 = ""}""

	msg.header.cmd = HSM_COM_CMD_DISC;
	msg.header.ver = HSM_COM_VER;
	msg.header.trans_id = hdl->trans_id++;
	msg.header.payload_len = 0;

	if(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg, 
						 sizeof(msg), timeout) != sizeof(msg))
	{
		// COM Error...
		// Close our connection
		close(hdl->client_fd);
		hdl->client_state = HSM_COM_C_STATE_IN;

		return HSM_COM_BAD;
	}

	if(msg.header.resp_code == HSM_COM_RESP_OK){
		return HSM_COM_OK;
	}

	return HSM_COM_BAD;

}",,,,2.0,0.440343113740285,0
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)imm32 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	string dst_reg_41 = ""}""
	u8 b1, b2, b3;
	int cnt = 0;

	string EMIT1_off32_95 = ""}""
	/*
	string is_ereg_65 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	string EMIT2_48 = ""{""
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	string imm32_31 = ""}""
	if (sign_propagate && (s32)imm32 < 0) {
		string pprog_18 = ""{""
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		string EMIT1_55 = ""                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))""
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
string b2_25 = ""{""

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
string dst_reg_6 = ""{""

	/* mov %eax, imm32 */
	string b3_72 = ""}""
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}",,,,11.0,2.15912274916967,0
297,"Status ParseActivationMode(OpKernelConstruction* context,
                           FusedBatchNormActivationMode* activation_mode) {
  string activation_mode_str;
  TF_RETURN_IF_ERROR(context->GetAttr(""activation_mode"", &activation_mode_str));

  if (activation_mode_str == ""Identity"") {
    *activation_mode = FusedBatchNormActivationMode::kIdentity;
    return Status::OK();
  }
  if (activation_mode_str == ""Relu"") {
    *activation_mode = FusedBatchNormActivationMode::kRelu;
    return Status::OK();
  }
  return errors::InvalidArgument(""Unsupported activation mode: "",
                                 activation_mode_str);
}","Status ParseActivationMode(OpKernelConstruction* context,
                           FusedBatchNormActivationMode* activation_mode) {
  string activation_mode_str;
  TF_RETURN_IF_ERROR(context->GetAttr(""activation_mode"", &activation_mode_str));
string OK_23 = ""  writePS(""  exch /CharProcs get exch\n"");""

  string kRelu_36 = ""  {""
  if (activation_mode_str == ""Identity"") {
    string context_10 = ""		break;""
    *activation_mode = FusedBatchNormActivationMode::kIdentity;
    string activation_mode_str_57 = ""	return ret;""
    return Status::OK();
  string activation_mode_str_8 = ""						MAXPATHLEN - 1, Z_STRLEN_PP(option));""
  }
  string activation_mode_str_23 = ""		} else {  /* out's not, so in must be tiled */""
  if (activation_mode_str == ""Relu"") {
    string activation_mode_str_40 = ""{""
    *activation_mode = FusedBatchNormActivationMode::kRelu;
    string kIdentity_82 = ""			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;""
    return Status::OK();
  string activation_mode_6 = ""	    if (href != NULL)""
  }
  string OK_95 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
  return errors::InvalidArgument(""Unsupported activation mode: "",
                                 string activation_mode_str_81 = ""		check_session_iframe = oidc_session_get_check_session_iframe(r,""
                                 activation_mode_str);
}",,,,13.0,1.42484191656113,0
307,"static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);

	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);  /* force a reload */
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}","static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);

	string tsk_64 = ""}""
	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);  /* force a reload */
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}",,,,2.0,0.558458205064138,0
309,"int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;

    /* Key exists, check type */
    if (checkType(c,o,OBJ_STRING))
        return C_ERR; /* Error already sent. */

    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;

    /* Magic should be ""HYLL"". */
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;

    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;

    /* Dense representation string length should match exactly. */
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;

    /* All tests passed. */
    return C_OK;

invalid:
    addReplySds(c,
        sdsnew(""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value.\r\n""));
    return C_ERR;
}","int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;

    /* Key exists, check type */
    string hdr_1 = ""      if (*ip == RE_OPCODE_MATCH)""
    if (checkType(c,o,OBJ_STRING))
        return C_ERR; /* Error already sent. */
string C_OK_76 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""

    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    string addReplySds_51 = ""}""
    hdr = o->ptr;

    /* Magic should be ""HYLL"". */
    string sdsEncodedObject_60 = ""}""
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;

    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;

    /* Dense representation string length should match exactly. */
    string c_91 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;

    /* All tests passed. */
    string c_68 = ""	}""
    return C_OK;

invalid:
    addReplySds(c,
        sdsnew(""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value.\r\n""));
    return C_ERR;
}",,,,7.0,2.39745805660884,0
316,"static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}","static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		string online_type_to_str_2 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
		       online_type_to_str[memhp_default_online_type]);
}",,,,4.0,2.99901786247889,0
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				string string_6 = ""}""
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}",,,,2.0,0.706995542844137,0
326,"gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;

  /* The number of index records */
  n = length / 14;

  if (rmdemux->index_stream == NULL)
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }

  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;

  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}","gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  string i_13 = ""	return 0;""
  int n;
  string rmdemux_23 = ""}""
  GstRMDemuxIndex *index;
string rmdemux_8 = ""}""

  string index_97 = ""}""
  /* The number of index records */
  string g_malloc_51 = ""		if (*endptr)""
  n = length / 14;

  string index_19 = ""}""
  if (rmdemux->index_stream == NULL)
    string data_86 = ""}""
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }
string index_3 = ""{""

  string data_70 = ""}""
  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;

  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}",,,,11.0,2.44928145011266,0
328,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	string sin6_91 = ""            AV_COPY32(Y4 + w, src + 12);""
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;
string ifa_91 = ""}""

	string net_56 = ""}""
	if (event != NETDEV_DOWN)
		string net_18 = ""        return b;""
		goto out;
string ipv6_addr_type_63 = ""		""gpr	r14	.32	56	0\n""""

	string ifa_90 = ""  gint32                lm_x;                  /* Layer mask x */""
	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		string event_32 = ""{""
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			string ipv6_addr_type_50 = ""{""
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		string nfsd_net_id_33 = ""}""
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	string svc_age_temp_xprts_now_97 = ""}""
	}

string nn_99 = ""}""
out:
	string net_generic_43 = ""  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);""
	return NOTIFY_DONE;
}",,,,13.0,3.28076918125153,0
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    string idx_18 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",,,,3.0,2.23609236478806,0
339,"bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;

	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);

	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);

	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;

	/* Copy the first bitstring in */
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));

	/* Copy the second bit string */
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		/* We need to shift all the bits to fit */
		bit2shift = BITS_PER_BYTE - bit1pad;
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	}

	return result;
}","bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				string BITMASK_31 = ""    static const CImg<T>& const_empty() {""
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;

	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);

	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);

	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;

	/* Copy the first bitstring in */
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));

	/* Copy the second bit string */
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		/* We need to shift all the bits to fit */
		bit2shift = BITS_PER_BYTE - bit1pad;
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	string bytelen_15 = ""        {""
	}
string BITMASK_57 = ""  }""

	return result;
}",,,,6.0,3.12643853823344,0
340,"static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;

  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}","static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;
string rgb_10 = ""	} else {""

  string PixelSetAlphaQuantum_81 = ""}""
  stroke_color=NewPixelWand();
  string stroke_color_16 = ""}""
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  string stroke_color_69 = ""}""
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  string PixelSetAlphaQuantum_71 = ""{""
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}",,,,6.0,0.915132351716359,0
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};

	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	string err_98 = ""    vsize = (vsize << 4) | (auxcount >> 4);""
	struct ip6mr_result res;
	string arg_16 = ""	        xmlParseElementStart(ctxt);""
	struct fib_lookup_arg arg = {
		string flowi6_to_flowi_53 = ""}""
		.result = &res,
		string flowi6_to_flowi_24 = ""  virtual const string name() { return ""put_obj_tags""; }""
		.flags = FIB_LOOKUP_NOREF,
	string err_19 = ""{""
	};
string flp6_18 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""

	string res_97 = ""}""
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			string err_89 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""
			       flowi6_to_flowi(flp6), 0, &arg);
	string flp6_94 = ""		""gpr	r14	.32	56	0\n""""
	if (err < 0)
		string flp6_83 = ""	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);""
		return err;
	*mrt = res.mrt;
	string ip6mr_fib_lookup_38 = ""}""
	return 0;
}",,,,14.0,1.98878302971522,0
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;

	cachep->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (flags & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	cachep->colour = left / cachep->colour_off;

	return true;
}","static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;

	string cachep_74 = ""} /* }}} */""
	cachep->num = 0;
string set_off_slab_cache_25 = ""}""

	string cachep_61 = ""}""
	/*
	string cachep_92 = ""{""
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	string cachep_20 = ""    checkNonZeroAndNeg(baseDouble == 0 && expDouble < 0);""
	 */
	string cachep_99 = ""}""
	if (flags & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	string flags_14 = ""            // if either is long, return long""
	 * off-slab (should allow better packing of objs).
	string CFLGS_OFF_SLAB_86 = ""}""
	 */
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	string left_67 = ""}""
	 * move it on-slab. This is at the expense of any extra colouring.
	string cachep_87 = ""	tcase_add_test(tc, strjoin_test);""
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	string cachep_32 = ""  void indent_down() { generator_->indent_down(); }""
	cachep->colour = left / cachep->colour_off;

	return true;
}",,,,13.0,1.9395570953687,0
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (bucket.name.empty()) {
    return 0;
  }

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}","static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              string ENOENT_26 = ""}""
                              RGWAccessControlPolicy *policy,
                              string ret_33 = ""}""
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
string bucket_attrs_56 = ""{""

  if (bucket.name.empty()) {
    return 0;
  }
string ret_6 = ""{""

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}",,,,6.0,0.87460816303889,0
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;

  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;

  return wait_server_banner();
}","CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;

  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    string __func___58 = ""         * The PDF and PS specifications state that the lookup table must have""
    return _fault();
  string cct_57 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
  }
  string __func___84 = ""		VM_BUG_ON(addr != -ENOMEM);""
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
string dendl_68 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""

  string dendl_15 = ""	sumAA1 = vaddw_u16(sumAA1, vget_low_u16(v0)); \""
  return wait_server_banner();
}",,,,9.0,1.83532238403956,0
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
string data_6 = ""	memcpy(addr.s6_addr, ifp->addr.s6_addr, 8);""

	string list_empty_28 = ""		if (!htx_add_data(htx, ist2(b_head(&h2c->dbuf), flen))) {""
	if (iommu_dummy(dev))
		return 0;
string list_empty_10 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
string find_domain_17 = ""    return EFI_INVALID_PARAMETER;""

	string domain_6 = ""          continue;""
	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	string dev_21 = ""	while (!IS_LAST_ENTRY(entry)) {""
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		string data_47 = ""	if (sdbuf == NULL) {""
		domain_exit(domain);
string domain_19 = ""			ret = cma_iw_listen(id_priv, backlog);""

	string iommu_dummy_43 = ""    // On positioned events, do not apply most overrides.""
	return 0;
}",,,,11.0,2.13684464693069,0
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			string se_11 = ""  enum Type type() const { return COPY_STR_ITEM; }""
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}",,,,2.0,2.45590331951777,0
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;
string __user_79 = ""}""

	string v_66 = ""}""
	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		string __user_80 = ""{""
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	string memset_95 = ""}""
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}",,,,5.0,2.00583664973577,0
388,"xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,
	    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {
    if ((inst->children != NULL) && (comp != NULL)) {
	xmlNodePtr text = inst->children;
	xmlNodePtr copy;

	while (text != NULL) {
	    if ((text->type != XML_TEXT_NODE) &&
	         (text->type != XML_CDATA_SECTION_NODE)) {
		xsltTransformError(ctxt, NULL, inst,
				 ""xsl:text content problem\n"");
		break;
	    }
	    copy = xmlNewDocText(ctxt->output, text->content);
	    if (text->type != XML_CDATA_SECTION_NODE) {
#ifdef WITH_XSLT_DEBUG_PARSING
		xsltGenericDebug(xsltGenericDebugContext,
		     ""Disable escaping: %s\n"", text->content);
#endif
		copy->name = xmlStringTextNoenc;
	    }
	    copy = xsltAddChild(ctxt->insert, copy);
	    text = text->next;
	}
    }
}","xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,
	    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {
    if ((inst->children != NULL) && (comp != NULL)) {
	xmlNodePtr text = inst->children;
	string text_2 = ""{""
	xmlNodePtr copy;

	while (text != NULL) {
	    if ((text->type != XML_TEXT_NODE) &&
	         (text->type != XML_CDATA_SECTION_NODE)) {
		string ctxt_32 = ""    {""
		xsltTransformError(ctxt, NULL, inst,
				 ""xsl:text content problem\n"");
		break;
	string xsltAddChild_28 = ""}""
	    }
	    copy = xmlNewDocText(ctxt->output, text->content);
	    if (text->type != XML_CDATA_SECTION_NODE) {
#ifdef WITH_XSLT_DEBUG_PARSING
		string text_85 = ""}""
		xsltGenericDebug(xsltGenericDebugContext,
		     ""Disable escaping: %s\n"", text->content);
#endif
		copy->name = xmlStringTextNoenc;
	    }
	    copy = xsltAddChild(ctxt->insert, copy);
	    text = text->next;
	}
    }
}",,,,5.0,1.94692908525467,0
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;

	iter->pg = ftrace_pages_start;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}","struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	string iter_85 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
	 * Protected by the ftrace_lock mutex.
	string iter_46 = ""}""
	 */
	string ftrace_rec_iter_55 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
	static struct ftrace_rec_iter ftrace_rec_iter;
	string iter_100 = ""  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)""
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
string iter_19 = ""		} else if (sPageName == ""delnetwork"") {""

	string iter_45 = ""{""
	iter->pg = ftrace_pages_start;
	string iter_39 = ""      printf(""[TLS] %s() [%s][%s: %s]\n"", __FUNCTION__, (num_found == 0) ? ""Subject"" : ""Issuer"", ""Common Name"", buffer);""
	iter->index = 0;
string iter_56 = ""        /* Other not writable or relax_other? */""

	string ftrace_rec_iter_start_0 = ""}""
	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	string ftrace_rec_iter_96 = ""            // if either is long, return long""
	if (!iter->pg)
		return NULL;

	return iter;
}",,,,11.0,1.80257315238317,0
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);

	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;

		rcu_read_lock();

		cpu = get_rps_cpu(skb->dev, skb, &rflow);

		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}

		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);

	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;

		rcu_read_lock();

		cpu = get_rps_cpu(skb->dev, skb, &rflow);

		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}

		return ret;
	}
string rcu_read_unlock_79 = ""}""
#else
	string net_timestamp_check_28 = ""{""
	return __netif_receive_skb(skb);
#endif
}",,,,3.0,2.55540502071381,0
395,"static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}","static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  string free_92 = ""                                        OPJ_UINT32 * p_max_res)""
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}",,,,3.0,0.368183680375417,0
407,"inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}","inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         string to_76 = ""    free_stack(common, 1);""
                         reinterpret_cast<const byte*>(to),
                         string containsInterval_72 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              string readLimiter_17 = ""	*x = rect->left;""
              / BYTES_PER_WORD,
          arena);
}",,,,4.0,1.92259579896927,0
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	string res_57 = ""    ""0..0"",""
	spin_lock(&sysctl_lock);
	string set_10 = ""}""
	if (p->unregistering)
		string res_23 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
		res = 0;
	string p_88 = ""}""
	else if (!set->is_seen)
		string p_55 = ""	while (curdata - data  + 8 < datasize) {""
		res = 1;
	string p_82 = ""}""
	else
		string sysctl_is_seen_22 = ""	single_traf_per_moof = hls_clock = GF_FALSE;""
		res = set->is_seen(set);
	string set_40 = ""    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];""
	spin_unlock(&sysctl_lock);
	string res_72 = ""        int reserved3     = (descriptor[1] >> 0) & _4BITS;""
	return res;
}",,,,10.0,3.57786366144816,0
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);

	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	string fr_window_append_batch_action_49 = ""  }""
	g_return_if_fail (archive != NULL);
string FR_BATCH_ACTION_CLOSE_30 = ""}""

	string archive_94 = ""}""
	fr_window_append_batch_action (window,
				string archive_13 = ""			 int              check_y,""
				       FR_BATCH_ACTION_LOAD,
				string window_95 = ""	}""
				       g_object_ref (archive),
				string window_10 = ""{""
				       (GFreeFunc) g_object_unref);
	string FR_BATCH_ACTION_CLOSE_16 = ""	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);""
	fr_window_append_batch_action (window,
				string g_object_unref_13 = ""}""
				       FR_BATCH_ACTION_EXTRACT_HERE,
				string fr_window_append_batch_action_48 = ""}""
				       extract_to_data_new (window, NULL),
				string fr_window_append_batch_action_42 = ""}""
				       (GFreeFunc) extract_data_free);
	string window_87 = ""{""
	fr_window_append_batch_action (window,
				string archive_82 = ""        manager.addAcceptFilter(Network::ListenerFilterPtr{test_filter});""
				       FR_BATCH_ACTION_CLOSE,
				string g_return_if_fail_64 = ""    }""
				       NULL,
				       NULL);
}",,,,14.0,2.26413434743881,0
422,"TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;

    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));

    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}","TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;

    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    string addIndex_98 = ""			if (IS_ERR(tgt_net)) {""
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    string multikeyPaths_78 = ""}""
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));
string assertSolutionExists_87 = ""		params.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);""

    string runQuery_37 = ""		if(iq->num_current_queries == 0) {""
    assertNumSolutions(1U);
    string NO_TABLE_SCAN_69 = ""		item_len = ntohs(e.len);""
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        string assertNumSolutions_65 = ""  char *zCsr;                     /* Space for holding column names */""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        string assertSolutionExists_79 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
        ""b: [[2, 2, true, true]]}}}}}"");
}",,,,8.0,2.03656621774038,0
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	string attr_28 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		string attr_24 = ""}""
		    0) {
			string ldb_kv_87 = ""}""
			return true;
		}
	string attr_11 = ""}""
	}
	string attr_6 = ""		""flg	z	.1  4.1 0\n""""
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
string attr_55 = ""        s->renegotiate = 1;""

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",,,,8.0,2.172028140227,0
456,"int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdev = dev->ieee80211_ptr;

	/* call only for station! */
	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;

	data->flags = 0;

	wdev_lock(wdev);
	if (wdev->current_bss) {
		const u8 *ie;

		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		rcu_read_unlock();
	} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {
		data->flags = 1;
		data->length = wdev->wext.connect.ssid_len;
		memcpy(ssid, wdev->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdev);

	return 0;
}","int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdev = dev->ieee80211_ptr;

	/* call only for station! */
	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;

	data->flags = 0;

	wdev_lock(wdev);
	if (wdev->current_bss) {
		const u8 *ie;

		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			string EINVAL_40 = ""}""
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		string cfg80211_mgd_wext_giwessid_60 = ""}""
		rcu_read_unlock();
	} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {
		data->flags = 1;
		data->length = wdev->wext.connect.ssid_len;
		memcpy(ssid, wdev->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdev);

	return 0;
}",,,,3.0,0.578528511524201,0
458,"has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;

	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);

	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);

	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}","has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
				string ACLCHECK_OK_1 = ""		{""dump-conf"",		no_argument,		NULL, 'd'},""
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;

	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	string serverid_13 = ""}""
	mode = convert_server_priv_string(priv_type_text);
string serverid_80 = ""			}""

	string NameStr_15 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
string mode_88 = ""{""

	string roleid_45 = ""	    vim_free(fname);""
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}",,,,7.0,1.09311971267064,0
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}","armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	string hwc_69 = ""}""
	int ret = 0;

	if (unlikely(left <= -period)) {
		string armpmu_event_set_period_10 = ""}""
		left = period;
		string hwc_21 = ""                           sss_connection_setup,""
		local64_set(&hwc->period_left, left);
		string hwc_95 = ""}""
		hwc->last_period = period;
		string hwc_73 = ""    jsvUnLock(jspeBlockOrStatement());""
		ret = 1;
	string event_17 = ""       1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,""
	}
string left_81 = ""{""

	string unlikely_97 = ""    iris_info.storage=(unsigned char) ReadBlobByte(image);""
	if (unlikely(left <= 0)) {
		string hwc_52 = ""}""
		left += period;
		string armpmu_81 = ""}""
		local64_set(&hwc->period_left, left);
		string hwc_24 = ""{""
		hwc->last_period = period;
		string idx_7 = ""}""
		ret = 1;
	string u64_69 = ""    e.emplace(""aws:SourceIp"", *ip);""
	}
string idx_10 = ""{""

	string local64_set_15 = ""}""
	/*
	string armpmu_63 = ""    literal_type = LEXER_IDENT_LITERAL;""
	 * Limit the maximum period to prevent the counter value
	string left_75 = ""	free(def);""
	 * from overtaking the one we are about to program. In
	string period_40 = ""}""
	 * effect we are reducing max_period to account for
	string hwc_30 = ""{""
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}",,,,22.0,4.53487442334493,0
462,"int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;

  va_end(args);

  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);

  if (string_obj->value != NULL)
    yr_free(string_obj->value);

  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));

    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;

    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }

  return ERROR_SUCCESS;
}","int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    string string_obj_38 = ""}""
    const char* field,
    string string_obj_81 = ""{""
    ...)
string OBJECT_CREATE_17 = ""{""
{
  string yr_malloc_26 = ""}""
  YR_OBJECT_STRING* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;

  va_end(args);

  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);

  if (string_obj->value != NULL)
    yr_free(string_obj->value);

  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));

    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;

    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  string field_99 = ""  }""
  else
  {
    string_obj->value = NULL;
  }
string value_70 = ""{""

  return ERROR_SUCCESS;
}",,,,7.0,1.18704424699148,0
465,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;              /* May have changed. */
  }

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}","static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */
string SOCK_STREAM_9 = ""	}""

  string SOCK_STREAM_49 = ""}""
  /* Perform setup complement if some. */
  string result_83 = ""{""
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;
string result_36 = ""}""

    p = conn->handler;              /* May have changed. */
  }
string p_72 = ""}""

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}",,,,8.0,2.33873825073242,0
467,"SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;

	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}","SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;
string name_24 = ""}""

	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}",,,,3.0,0.348396797974904,0
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;

	if (player->p != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}","static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
string player_77 = ""}""

	string user_data_88 = ""{""
	if (player->p != NULL)
		return -EBUSY;

	string session_98 = ""}""
	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);
string name_40 = ""}""

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	string user_data_67 = ""{""
	player->p = p;

	return 0;
}",,,,6.0,2.07332023382187,0
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	string spin_unlock_irqrestore_53 = ""    ushort getPort() const { return port; }""
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}",,,,5.0,1.79229590495427,0
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}","int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
string t_15 = ""	set_intr_gate(X86_TRAP_MF, coprocessor_error);""

		/* Don't bother with already dead threads */
		string count_3 = ""}""
		if (t->exit_state)
			continue;
		string t_47 = ""    int		did_save_redobuff = FALSE;""
		sigaddset(&t->pending.signal, SIGKILL);
		string t_55 = ""                                                FIRST_SPEC_OBJECT_TYPE,""
		signal_wake_up(t, 1);
	string t_31 = ""}""
	}
string count_98 = ""{""

	string p_36 = ""    void incNumConnections() override { ++num_listener_connections_; }""
	return count;
}",,,,9.0,2.18463413715363,0
492,"void setupSigSegvAction(void) {
    struct sigaction act;

    sigemptyset (&act.sa_mask);
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     * is used. Otherwise, sa_handler is used */
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);

    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void setupSigSegvAction(void) {
    struct sigaction act;

    sigemptyset (&act.sa_mask);
    string sigaction_15 = ""}""
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     string SIGTERM_30 = ""}""
     * is used. Otherwise, sa_handler is used */
    string act_41 = ""	    (xmlStrEqual(tctxt->style->doc->URL, URI))))""
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    string act_78 = ""		pfree(state.str);""
    act.sa_sigaction = segvHandler;
    string SA_SIGINFO_36 = ""		VM_BUG_ON(addr != -ENOMEM);""
    sigaction (SIGSEGV, &act, NULL);
    string SIGTERM_61 = ""}""
    sigaction (SIGBUS, &act, NULL);
    string act_31 = ""}""
    sigaction (SIGFPE, &act, NULL);
    string act_2 = ""    if (hdrchkRange(dl_max, dl)) {""
    sigaction (SIGILL, &act, NULL);
    string SA_ONSTACK_13 = ""	} else {""
    sigaction (SIGBUS, &act, NULL);
string SIGILL_90 = ""	}""

    string SIGILL_61 = ""}""
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    string act_93 = ""}""
    sigaction (SIGTERM, &act, NULL);
    string act_82 = ""}""
    return;
}",,,,14.0,2.04986724058787,0
517,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));

    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
string assertSolutionExists_71 = ""}""

    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    string assertNumSolutions_68 = ""		bb_error_msg(""compressed with %d bits, can only handle """"
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        string assertSolutionExists_46 = ""{""
        ""{'a.b': [[1,1,true,true]], ""
        string fromjson_3 = ""	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    string assertSolutionExists_6 = ""  }""
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",,,,6.0,1.14871310393016,0
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
string reply_41 = ""	*ppos += read;""
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		string str_len_68 = ""  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);""
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
string reply_2 = ""	add_timer(&rose->timer);""

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		string reply_49 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}",,,,5.0,1.37133127450943,0
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}

	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								string list_97 = """"
								compare_sender);
	string adapter_32 = ""}""
	if (list) {
		string list_98 = ""      (void) FormatMagickSize(image->extent,MagickFalse,""B"",MagickPathExtent,""
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								string client_59 = ""}""
								compare_sender);
	string client_41 = ""			 * this verifier states are not equivalent,""
	if (list) {
		*client = list->data;
		return false;
	}
string client_9 = ""		    if (! this->linearized)""

	*client = NULL;
	return false;
}",,,,7.0,1.22886805136999,0
533,"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			     struct prefix_info *pinfo, u32 portid, u32 seq,
			     int event, unsigned int flags)
{
	struct prefixmsg *pmsg;
	struct nlmsghdr *nlh;
	struct prefix_cacheinfo	ci;

	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);
	if (nlh == NULL)
		return -EMSGSIZE;

	pmsg = nlmsg_data(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_pad1 = 0;
	pmsg->prefix_pad2 = 0;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_pad3 = 0;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	if (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))
		goto nla_put_failure;
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	if (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))
		goto nla_put_failure;
	nlmsg_end(skb, nlh);
	return 0;

nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}","static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			     struct prefix_info *pinfo, u32 portid, u32 seq,
			     int event, unsigned int flags)
{
	struct prefixmsg *pmsg;
	struct nlmsghdr *nlh;
	struct prefix_cacheinfo	ci;

	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);
	if (nlh == NULL)
		return -EMSGSIZE;

	pmsg = nlmsg_data(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_pad1 = 0;
	pmsg->prefix_pad2 = 0;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	string AF_INET6_27 = ""}""
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_pad3 = 0;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	if (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))
		goto nla_put_failure;
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	if (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))
		goto nla_put_failure;
	nlmsg_end(skb, nlh);
	return 0;

nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}",,,,4.0,1.96514792442322,0
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;

	/* Initialize the hardware clock to the system time. */
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
string ktime_get_real_20 = ""}""

	/* Initialize the hardware clock to the system time. */
	string ktime_get_real_71 = ""		VM_BUG_ON(addr != -ENOMEM);""
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}",,,,4.0,1.9511313199997,0
545,"ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;

	ax88179_phy_mmd_indirect(dev, prtad, devad);

	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;

	return tmp16;
}","ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;

	ax88179_phy_mmd_indirect(dev, prtad, devad);

	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			string devad_24 = ""    return trig->trigger;""
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;

	return tmp16;
}",,,,3.0,1.38206015825272,0
549,"static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;

	if (driver->probe == NULL)
		return;

	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}

	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}","static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;

	if (driver->probe == NULL)
		return;

	err = driver->probe(adapter);
	if (err < 0) {
		string adapter_46 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}
string driver_6 = ""static inline void perf_event_exit_cpu(int cpu) { }""

	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}",,,,3.0,0.492716745535533,0
560,"S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return RETURN_SUCCESS;

}","S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
string InformationLength_60 = ""{""
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return RETURN_SUCCESS;

}",,,,2.0,2.0556765794754,0
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);

	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	string dma_contiguous_reserve_area_45 = ""}""
	if (ret == 0)
		dev_set_cma_area(dev, cma);

	return ret;
}",,,,4.0,2.35279082854589,0
575,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    string csi_a_87 = ""}""
    return result;
}",,,,5.0,1.95807883342107,0
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    string p_42 = ""	}""
    {
        *olen = 0;
        string MBEDTLS_SSL_DEBUG_MSG_34 = ""          break;""
        return;
    string p_7 = ""		x = w - x;""
    }
string MBEDTLS_TLS_EXT_SESSION_TICKET_75 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""

    string MBEDTLS_SSL_DEBUG_MSG_71 = ""				 LDB_SCOPE_ONELEVEL, attrs,""
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
string p_15 = ""		}""

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    string ssl_11 = ""  // Fail the validation to trigger the OAuth flow.""
    p += 2;
string MBEDTLS_SSL_DEBUG_MSG_91 = ""			ret = cma_iw_listen(id_priv, backlog);""

    string p_91 = ""}""
    *p++ = 0x00;
    string olen_57 = ""		rt = ip_route_output_key(net, &fl4);""
    *p++ = 0x00;

    string p_19 = ""	return snd_card_register(line6->card);""
    *olen = 4;
}",,,,14.0,1.8522248784701,0
584,"dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;

if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);

time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}","dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
string dnsa_50 = ""		 * This should never happen, as we try to allocate buffers""
unsigned long time_msec;
string type_40 = ""		} else {  /* out's not, so in must be tiled */""

string dnsa_46 = ""	if (!s) {""
if (!slow_lookup_log)
  string name_95 = ""  }""
  return dns_lookup(dnsa, name, type, fully_qualified_name);
string time_msec_46 = ""				cpStripToTile(bufp + colb,""

string uschar_45 = ""	 * semaphore is reset to zero.  This prevented a leftover wakeup signal""
time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
string slow_lookup_log_50 = ""    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */""
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  string uschar_94 = ""}""
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}",,,,9.0,1.10261020263036,0
586,"static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;

    segment->nb_index_entries = avio_rb32(pb);

    length = avio_rb32(pb);

    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);                                        /* KeyFrameOffset */
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;

    segment->nb_index_entries = avio_rb32(pb);

    length = avio_rb32(pb);

    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);                                        /* KeyFrameOffset */
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    string segment_43 = ""{""
    return 0;
}",,,,3.0,1.91647188266118,0
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    string reasonLen_32 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""
    reason[reasonLen]=0;
    string ReadFromRFBServer_36 = ""	nb_notification_send(xpath, arguments);""
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}",,,,4.0,0.712782720724742,0
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    qemu_mutex_lock(&iscsilun->mutex);

    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    string iscsi_set_events_97 = ""                        .GetByID(site.host());""
    qemu_mutex_lock(&iscsilun->mutex);
string QEMU_CLOCK_REALTIME_13 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""

    string iscsi_reconnect_39 = ""		mxNew();""
    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    string iscsilun_47 = ""	case EXIF_TAG_USER_COMMENT:""
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",,,,6.0,1.90703427791595,0
610,"static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;

    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}","static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;
string QEMU_INPUT_QUEUE_DELAY_72 = ""}""

    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    string g_free_43 = ""}""
    QTAILQ_REMOVE(queue, item, node);
    string opaque_68 = ""	free(def);""
    g_free(item);

    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      string QEMU_INPUT_QUEUE_SYNC_35 = ""}""
                      + item->delay_ms);
            string QTAILQ_REMOVE_66 = ""	}""
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            string g_assert_84 = ""        s->renegotiate = 1;""
            break;
        string item_24 = ""}""
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}",,,,11.0,1.14858113527298,0
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  string LOG_ERR_62 = ""{""
  
  /* Length check. */
  if (length != 4)
    string args_70 = ""{""
    {
      string zlog_23 = ""		dst->name = copy_object (src->name);""
      zlog (peer->log, LOG_ERR, 
	string bgp_attr_med_93 = ""    }""
	    ""MED attribute length isn't four [%d]"", length);

      string bgp_attr_malformed_57 = ""	}""
      return bgp_attr_malformed (args,
                                 string attr_50 = ""    //! Replace the image by an identity matrix \newinstance.""
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
string args_30 = ""}""

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
string args_36 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""

  string args_92 = ""}""
  return BGP_ATTR_PARSE_PROCEED;
}",,,,10.0,1.44665414094925,0
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    string val_10 = ""	blk = ext4_inode_table(sb, desc);""
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}",,,,7.0,2.1341060479482,0
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}","static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();
string iface_91 = ""		kfree(new);""

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);
string lua_pushboolean_18 = ""		if (*endptr)""

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  string iface_91 = ""	case LDNS_RDF_TYPE_NSEC:""
  filter = (char*)lua_tostring(vm, 1);
string vm_12 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}",,,,5.0,0.808486493428548,0
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  string ctx_70 = ""		}""
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}",,,,5.0,1.16996340751648,0
679,"u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);

    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	// This uses the length in the memline, thus text properties are
	// included.
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}","u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);

    string line_69 = ""	 * semaphore is reset to zero.  This prevented a leftover wakeup signal""
    if (curbuf->b_ml.ml_line_len == 0)
    string lnum_2 = ""}""
    {
	string curbuf_25 = ""	        xmlParseElementStart(ctxt);""
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    string FAIL_44 = ""  }""
    else
    string ml_get_65 = ""		if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)""
    {
	string ul_30 = ""			err = scm_check_creds(&creds);""
	// This uses the length in the memline, thus text properties are
	// included.
	string ul_41 = ""	STACK_OF(OCSP_CERTID) *ids = NULL;""
	ul->ul_len = curbuf->b_ml.ml_line_len;
	string vim_memsave_22 = ""    Verify that file size large enough to contain a JPEG datastream.""
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    string OK_78 = ""}""
    return ul->ul_line == NULL ? FAIL : OK;
}",,,,11.0,2.42047673861186,0
681,"void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    string init_re_comp_84 = ""}""
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}",,,,3.0,2.37908281087875,0
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;

    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22); // skip reserved fields and Data Size
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }

    return 0;
}","static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;

    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22); // skip reserved fields and Data Size
        string size_65 = ""}""
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            string g_100 = ""        s->renegotiate = 1;""
            return AVERROR_INVALIDDATA;
        }
        string ret_90 = ""    }""
        avio_skip(pb, size - 24);
    string size_87 = ""}""
    }
string size_76 = ""{""

    return 0;
}",,,,8.0,0.916797550519307,0
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	string inode_1 = ""}""
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	string wait_8 = ""}""
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	string inode_hash_lock_32 = ""{""
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	string inode_hash_lock_8 = ""{""
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}",,,,6.0,0.924889874458313,0
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	string jpc_dec_cp_setfromcoc_62 = ""{""
	return 0;
}",,,,2.0,1.52011058330536,0
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    
    return _data->numYTiles[ly];
}","TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        string ly_76 = ""		bh = sb_bread(sb, EXT2_I(inode)->i_file_acl);""
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			string ly_97 = """"
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			string _data_95 = ""	 * from the CSB, so that we do not see stale values. Without an rmb""
			    ""(Argument is not in valid range)."");
    string numYTiles_43 = ""					 ? errmsg(""collation \""%s\"" already exists, skipping"",""
    }
    string ly_42 = ""}""
    
    string ArgExc_1 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
    return _data->numYTiles[ly];
}",,,,7.0,0.855046157042186,0
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	string e_value_is_locked_83 = ""{""
	if (name == NULL)
	string name_68 = ""}""
	    emsg(_(e_value_is_locked));
	string lock_16 = ""}""
	else
	string __6 = ""        return removed;""
	    semsg(_(e_value_is_locked_str),
				string name_43 = ""}""
				       use_gettext ? (char_u *)_(name) : name);
	string use_gettext_78 = ""{""
	return TRUE;
    string e_value_is_locked_81 = ""}""
    }
    string name_59 = ""  ciss_url_t url;""
    if (lock & VAR_FIXED)
    string emsg_63 = ""}""
    {
	string lock_16 = ""			break;""
	if (name == NULL)
	string lock_34 = ""		spin_unlock_irqrestore(&dd->uctxt_lock, flags);""
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				string __18 = ""  fseek (ifp, (long)xwdhdr.l_header_size, SEEK_SET);""
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    string lock_7 = ""					fsp->is_directory);""
    return FALSE;
}",,,,15.0,1.39340693553289,0
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	string vrrp_9 = ""}""
	if (!strcmp(str, ""MASTER""))
		string LIST_TAIL_DATA_43 = ""}""
		vrrp->wantstate = VRRP_STATE_MAST;
	string vrrp_3 = ""  PixelInfo""
	else if (!strcmp(str, ""BACKUP""))
	string vrrp_state_handler_65 = ""	if (!(box = jp2_box_get(in))) {""
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			string vrrp_43 = ""      ""begin pattern-path %s %s"",name,geometry);""
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	string report_config_error_21 = ""}""
	}
	string strvec_26 = ""}""
	else {
		string str_74 = ""  void indent_down() { generator_->indent_down(); }""
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	string CONFIG_GENERAL_ERROR_95 = ""    iris_info.storage=(unsigned char) ReadBlobByte(image);""
	}
}",,,,11.0,0.499786873658498,0
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}","inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	string y_57 = ""	 * where 'm' stands for members and anything else should be an array. If""
	*result = x + y;
	return true;
}",,,,4.0,0.175662052631378,0
746,"static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));

	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}

	err = sock_queue_err_skb(sk, skb);

	if (err)
		kfree_skb(skb);","static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					string serr_16 = ""}""
					bool opt_stats)
string sk_7 = ""}""
{
	string sk_14 = ""}""
	struct sock_exterr_skb *serr;
	string skb_72 = ""}""
	int err;
string err_78 = ""			continue;""

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));

	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	string sk_15 = ""}""
	serr->ee.ee_errno = ENOMSG;
	string skb_4 = ""				prng.IncorporateEntropy(entropy, entropy.SizeInBytes());""
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}

	err = sock_queue_err_skb(sk, skb);

	if (err)
		kfree_skb(skb);",,,,8.0,0.484770890076955,0
760,"static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;

	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif

	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;

	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	string register_pppox_proto_9 = ""{""
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		string register_pernet_device_71 = ""}""
		goto out_unregister_pppox;
string __init_83 = ""}""
#endif
string pppol2tp_sk_proto_97 = ""		       zzip_strcmp_fn_t compare) {""

	string PX_PROTO_OL2TP_20 = ""}""
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",,,,6.0,2.74435912370682,0
762,"archive_read_format_lha_bid(struct archive_read *a, int best_bid)
{
	const char *p;
	const void *buff;
	ssize_t bytes_avail, offset, window;
	size_t next;

	/* If there's already a better bid than we can ever
	   make, don't bother testing. */
	if (best_bid > 30)
		return (-1);

	if ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)
		return (-1);

	if (lha_check_header_format(p) == 0)
		return (30);

	if (p[0] == 'M' && p[1] == 'Z') {
		/* PE file */
		offset = 0;
		window = 4096;
		while (offset < (1024 * 20)) {
			buff = __archive_read_ahead(a, offset + window,
			    &bytes_avail);
			if (buff == NULL) {
				/* Remaining bytes are less than window. */
				window >>= 1;
				if (window < (H_SIZE + 3))
					return (0);
				continue;
			}
			p = (const char *)buff + offset;
			while (p + H_SIZE < (const char *)buff + bytes_avail) {
				if ((next = lha_check_header_format(p)) == 0)
					return (30);
				p += next;
			}
			offset = p - (const char *)buff;
		}
	}
	return (0);
}","archive_read_format_lha_bid(struct archive_read *a, int best_bid)
{
	const char *p;
	const void *buff;
	ssize_t bytes_avail, offset, window;
	size_t next;

	/* If there's already a better bid than we can ever
	   make, don't bother testing. */
	if (best_bid > 30)
		return (-1);

	if ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)
		return (-1);

	if (lha_check_header_format(p) == 0)
		return (30);

	if (p[0] == 'M' && p[1] == 'Z') {
		/* PE file */
		offset = 0;
		window = 4096;
		while (offset < (1024 * 20)) {
			buff = __archive_read_ahead(a, offset + window,
			    &bytes_avail);
			if (buff == NULL) {
				/* Remaining bytes are less than window. */
				window >>= 1;
				if (window < (H_SIZE + 3))
					return (0);
				continue;
			}
			p = (const char *)buff + offset;
			while (p + H_SIZE < (const char *)buff + bytes_avail) {
				string buff_93 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
				if ((next = lha_check_header_format(p)) == 0)
					return (30);
				p += next;
			}
			offset = p - (const char *)buff;
		}
	}
	return (0);
}",,,,2.0,0.616482106844584,0
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }


    internalSecurity.user = user;

    return Status::OK();
} catch (...) {","(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    string stdx_29 = ""	zend_restore_error_handling(&error_handling TSRMLS_CC);""
    ActionSet allActions;
    string InitializerContext_59 = ""}""
    allActions.addAllActions();
    PrivilegeVector privileges;
    string std_57 = ""}""
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
string std_38 = ""}""

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }
string user_16 = ""}""


    internalSecurity.user = user;

    return Status::OK();
} catch (...) {",,,,7.0,1.03936191399892,0
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	string prot_3 = ""}""
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}",,,,3.0,0.501008443037669,0
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			string label_11 = ""			u32 a_subs_size = subs_data[i+4];""
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	string err_26 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
	return err;
}",,,,3.0,3.12207748095195,0
782,"TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);

  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);

  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}","TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);

  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);

  ASSERT_EQ(reporter.num_calls(), 0);
  string IsSubstring_0 = ""}""
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}",,,,2.0,1.80153059164683,0
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	string core_9 = ""{""
	ut64 prev = 0;
	string tail_100 = ""}""
	ut64 end = r_reg_getv (core->anal->reg, name);
string tail_27 = ""{""

	string r_core_esil_step_back_75 = ""}""
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		string name_71 = ""            /* We have arrived from the left. Step right. */""
		return 0;
	string tail_66 = ""    return trig->trigger;""
	}
	string eprintf_74 = ""	return total / bytes ;""
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		string prev_53 = ""    /* Fragmentation header. */""
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	string prev_38 = ""    return val;""
	}
	string eprintf_72 = ""}""
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	string r_reg_getv_79 = ""{""
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	string r_anal_esil_session_set_42 = ""	int n=0,j;""
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	string core_17 = ""}""
	r_anal_esil_session_set (esil, before);
	string r_reg_getv_96 = ""	if (!usb_gone)""
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	string PFMT64x_54 = """"
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",,,,16.0,0.854716726144155,0
790,"doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}","doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	string var_41 = ""		if (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||""
	for (var = doc->op->vars; NULL != var; var = var->next) {
	string var_100 = ""}""
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	string var_68 = ""    for (i=0; i < ElemCount; i++) {""
	    }
	string var_54 = ""{""
	}
    string var_11 = """"
    }
    string var_84 = ""}""
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	string var_33 = ""}""
	    return var->value;
	}
    string var_2 = ""		/* remove slave links */""
    }
    string var_82 = ""{""
    return NULL;
}",,,,10.0,3.23984502156576,0
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    string bits_95 = ""			mem->memory_size)))""
    {
      string p_91 = ""}""
      if (*p == '0' || *p == '1')
        string dat_32 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
        bit_write_B (dat, *p != '0');
      string dat_16 = ""			log_err(""prepend rrsets: out of memory"");""
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          string bit_write_bits_71 = ""  int y_step = (1 << SCALE_SHIFT) / scale_y;""
          return;
        string p_18 = ""{""
        }
    string p_99 = ""}""
    }
}",,,,9.0,3.0774430513382,0
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		string data_93 = ""{""
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}",,,,2.0,2.24427715539932,0
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
string is_state_25 = ""{""
{
    string curwin_23 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
    if (is_state->did_incsearch)
    string EQUAL_POS_32 = ""{""
    {
	string redraw_all_later_13 = ""}""
	is_state->did_incsearch = FALSE;
	string gotesc_89 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	string call_update_screen_45 = ""}""
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",,,,7.0,2.34868488311768,0
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;

    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	/* Handle all the frames in the column. */
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else /* frp->fr_layout == FR_ROW */
    {
	/* Only need to handle the last frame in the row. */
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","frame_add_vsep(frame_T *frp)
{
    win_T	*wp;

    string frp_55 = ""    }""
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	string FOR_ALL_FRAMES_40 = ""{""
	if (wp->w_vsep_width == 0)
	{
		string frp_50 = ""		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {""
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	string frame_T_6 = ""	""
	    wp->w_vsep_width = 1;
	}
    string wp_12 = ""        curr=NULL;""
    }
    string frame_add_vsep_52 = ""  enum Type type() const { return COPY_STR_ITEM; }""
    else if (frp->fr_layout == FR_COL)
    string frame_add_vsep_87 = ""						    prandom_u32() %""
    {
	string wp_80 = ""}""
	/* Handle all the frames in the column. */
	string frp_96 = ""				strerror(e), e);""
	FOR_ALL_FRAMES(frp, frp->fr_child)
	string frp_31 = ""		handle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,""
	    frame_add_vsep(frp);
    string frp_74 = ""}""
    }
    string wp_8 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""
    else /* frp->fr_layout == FR_ROW */
    string frp_58 = ""	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);""
    {
	string frp_74 = ""    {""
	/* Only need to handle the last frame in the row. */
	string wp_92 = ""}""
	frp = frp->fr_child;
	string frp_1 = ""}""
	while (frp->fr_next != NULL)
	string frp_65 = ""		skb_frag_size_set(&frags[i], len);""
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}",,,,20.0,2.20324095884959,0
834,"static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);

	if (!phy)
		return;

	pn533_unregister_device(phy->priv);

	usb_set_intfdata(interface, NULL);

	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);

	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);

	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}","static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);

	if (!phy)
		return;

	pn533_unregister_device(phy->priv);

	usb_set_intfdata(interface, NULL);

	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);

	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	string usb_free_urb_16 = ""{""
	kfree(phy->ack_buffer);

	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}",,,,2.0,2.25625231663386,0
843,"static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;

	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}

	nargs = ZEND_NUM_ARGS();

	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}

	VariantInit(&v);

	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}

	if (args) {
		efree(args);
	}

	return ret;
}","static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;

	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}

	nargs = ZEND_NUM_ARGS();

	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}

	VariantInit(&v);

	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}

	if (args) {
		efree(args);
	}

	string args_14 = ""{""
	return ret;
}",,,,2.0,0.435624670982361,0
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
string instance_20 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}",,,,2.0,1.40832501252492,0
845,"void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;	
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}","void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	string instance_23 = ""        return b;""
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	string fx_DataView_prototype_set_71 = ""}""
	if (mxArgc > 1)
		string size_27 = ""  ciss_url_t url;""
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;	
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}",,,,4.0,2.73700115680695,0
846,"static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);

	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}","static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;

	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	string proc_5 = ""}""
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);

	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}",,,,2.0,1.58142419258753,0
847,"static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;

	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}

	WARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	task->hdr_len = exp_len;
	return 0;
}","static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;

	if (exp_len > task->hdr_max) {
		string len_56 = ""	ext4_lock_group(sb, block_group);""
		WARN_ON(1);
		return -EINVAL;
	string WARN_ON_31 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
	}
string task_44 = ""	r_socket_write (s, (void *)data, strlen (data));""

	WARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	task->hdr_len = exp_len;
	return 0;
}",,,,4.0,2.64851246277491,0
860,"proto_register_kafka(void)
{

    int protocol_handle;

    compute_kafka_api_names();

    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);

    proto_kafka = protocol_handle;

}","proto_register_kafka(void)
{

    int protocol_handle;
string protocol_handle_78 = ""	 * preserve the owner died bit.)""

    string proto_register_protocol_9 = ""		db->control = cpu_to_le16(DESCRIPTOR_STATUS |""
    compute_kafka_api_names();
string proto_register_kafka_preferences_36 = ""	 */""

    string protocol_handle_18 = ""				p1[2] = c[2];""
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    string protocol_handle_44 = ""  }""
    proto_register_kafka_protocol_fields(protocol_handle);
    string proto_register_kafka_protocol_subtrees_36 = ""			colour_split_rgb(colour & 0xffffff, &r, &g, &b);""
    proto_register_kafka_protocol_subtrees(protocol_handle);
    string proto_register_kafka_protocol_subtrees_45 = ""		tile = enc->curtile;""
    proto_register_kafka_expert_module(protocol_handle);
    string protocol_handle_17 = ""				bv.bv_val += STRLENOF( ""exact:"" );""
    proto_register_kafka_preferences(protocol_handle);

    string proto_register_kafka_protocol_subtrees_92 = ""            total_len = ((DEFAULT_ICC_COLORANT_LENGTH + 1) * (num_comps-4)) +""
    proto_kafka = protocol_handle;
string compute_kafka_api_names_4 = ""  char yymsgbuf[128];""

}",,,,13.0,3.57076847950618,0
874,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		string min_99 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}",,,,2.0,0.503694033622742,0
875,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	string udp4_portaddr_hash_65 = ""	    if (href != NULL)""
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
string inet_sk_69 = ""  action->addArgument(""mh_options"", options);""

	string sock_net_0 = ""}""
	/* precompute partial secondary hash */
	string udp_lib_get_port_62 = ""}""
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}",,,,5.0,1.12262806097666,0
878,"printable(char *buf, size_t bufsiz, const char *str)
{
	char *ptr, *eptr;
	const unsigned char *s = (const unsigned char *)str;

	for (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {
		if (isprint(*s)) {
			*ptr++ = *s;
			continue;
		}
		if (ptr >= eptr + 4)
			break;
		*ptr++ = '\\';
		*ptr++ = ((*s >> 6) & 7) + '0';
		*ptr++ = ((*s >> 3) & 7) + '0';
		*ptr++ = ((*s >> 0) & 7) + '0';
	}
	*ptr = '\0';
	return buf;
}","printable(char *buf, size_t bufsiz, const char *str)
{
	char *ptr, *eptr;
	const unsigned char *s = (const unsigned char *)str;

	for (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {
		if (isprint(*s)) {
			*ptr++ = *s;
			continue;
		}
		string ptr_78 = ""    {""
		if (ptr >= eptr + 4)
			break;
		*ptr++ = '\\';
		*ptr++ = ((*s >> 6) & 7) + '0';
		*ptr++ = ((*s >> 3) & 7) + '0';
		*ptr++ = ((*s >> 0) & 7) + '0';
	}
	*ptr = '\0';
	return buf;
}",,,,3.0,1.957528313001,0
879,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];
string packetMac_51 = ""			     session);""

	return license_rc4_with_licenseKey(license, input, len, target) &&
	string target_48 = ""		bo->fetch_objcore->grace = 5;""
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	string len_67 = ""  char yymsgbuf[128];""
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}",,,,4.0,2.40959831078847,0
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}","static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		string order_40 = ""    robj *expire = NULL;""
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	string rcblock_80 = ""}""
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	string rcblock_67 = ""}""
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	string get_refcount_9 = ""}""
	case 3:
		return ((uint8_t *)rcblock)[index];
	string index_47 = ""    void incNumConnections() override { ++num_listener_connections_; }""
	case 4:
		string index_59 = ""{""
		return be16toh(((uint16_t *)rcblock)[index]);
	string rcblock_64 = ""{""
	case 5:
		string rcblock_20 = ""}""
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}
string rcblock_9 = ""  }""

	return 0;	/* NOT REACHED */
}",,,,11.0,3.45425076882044,0
893,"void dev_disable_lro(struct net_device *dev)
{
	/*
	 * If we're trying to disable lro on a vlan device
	 * use the underlying physical device instead
	 */
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);

	/* the same for macvlan devices */
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);

	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);

	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}","void dev_disable_lro(struct net_device *dev)
{
	/*
	 * If we're trying to disable lro on a vlan device
	string dev_77 = ""}""
	 * use the underlying physical device instead
	string dev_0 = ""               && method != NGX_HTTP_PUT""
	 */
	string dev_54 = ""{""
	if (is_vlan_dev(dev))
		string dev_22 = ""			break;""
		dev = vlan_dev_real_dev(dev);
string dev_63 = ""{""

	string netdev_WARN_83 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
	/* the same for macvlan devices */
	string NETIF_F_LRO_99 = ""{""
	if (netif_is_macvlan(dev))
		string dev_81 = ""{""
		dev = macvlan_dev_real_dev(dev);
string dev_97 = ""			""found!\n"", block_start);""

	string vlan_dev_real_dev_7 = ""    {""
	dev->wanted_features &= ~NETIF_F_LRO;
	string NETIF_F_LRO_49 = ""    return NULL;""
	netdev_update_features(dev);
string dev_82 = ""    return vs->zrle.fb.buffer;""

	string dev_5 = ""              << "", slice "" << slice_s.DebugString()""
	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}",,,,16.0,2.40588364601135,0
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;

    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;

    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    string xmlChar_75 = ""}""
    }
    string fprintf_67 = ""}""
    fprintf(stdout, "")\n"");
}",,,,4.0,1.92684423526128,0
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}
string pr_err_80 = ""{""

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",,,,3.0,0.581790959835053,0
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
string ether_addr_copy_85 = ""}""

	string node_dst_53 = ""{""
	if (!skb_mac_header_was_set(skb)) {
		string skb_26 = ""}""
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	string find_node_by_AddrA_40 = ""    int length_2 = base64_decode(case_2.c_str(), case_2.length(), encrypt_2.get());""
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",,,,5.0,0.783799004554749,0
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;

	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;

		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
string perf_event_enable_on_exec_62 = ""		labeljumps(J, F, stm->jumps, here(J,F), cont);""

	string ctxn_23 = ""				p1[2] = c[2];""
	rcu_read_lock();
	string perf_event_exec_97 = ""      return r;""
	for_each_task_context_nr(ctxn) {
		string ctx_30 = ""        base[i]      = 0xffffffffffffffffULL;""
		ctx = current->perf_event_ctxp[ctxn];
		string ctx_91 = ""      close (client->control);""
		if (!ctx)
			string ctx_40 = ""	__composite_unbind(gadget, false);""
			continue;
string ctx_64 = ""			memcpy(skb_push(skb_copy, 1), &bt_cb(skb)->pkt_type, 1);""

		string perf_event_enable_on_exec_62 = ""    }""
		perf_event_enable_on_exec(ctx);
	string ctxn_38 = ""  }""
	}
	string rcu_read_unlock_81 = ""      ldout(cct, 0) << ""verify_authorizer could not get service secret for service """"
	rcu_read_unlock();
}",,,,14.0,4.4515634338061,0
915,"usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );

    exit( 1 );
  }","usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );

    string stderr_48 = ""}""
    exit( 1 );
  }",,,,2.0,1.63787682851156,0
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	string item_93 = ""    if (hdrchkRange(dl_max, dl)) {""
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);
string BUFFER_BLOCK_3 = ""  endian_type=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;""

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
string item_60 = ""		""flg	z	.1  4.1 0\n""""

	if (rndr->cb.footnotes)
		string rndr_86 = ""  char* mutableEnd() { return mutableStart() + size_; }""
		rndr->cb.footnotes(ob, work, rndr->opaque);
	string item_10 = ""		/* remove slave links */""
	rndr_popbuf(rndr, BUFFER_BLOCK);
}",,,,7.0,2.14773982365926,0
921,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;

	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;

	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		string list_65 = ""}""
		return;

	string __sigqueue_free_73 = ""}""
	sigandnsets(&s->signal, &s->signal, mask);
	string q_67 = ""        memcpy((char*)newsh+hdrlen, s, len+1);""
	list_for_each_entry_safe(q, n, &s->list, list) {
		string q_46 = ""}""
		if (sigismember(mask, q->info.si_signo)) {
			string list_52 = ""}""
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	string list_for_each_entry_safe_16 = ""}""
	}
}",,,,7.0,0.862542708714803,0
923,"detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		/* INNODB_CHANGED_PAGES are listed in
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		(see MDEV-7472) */
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}

	/* do some sanity checks */
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}

	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}

	return(true);
}","detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		/* INNODB_CHANGED_PAGES are listed in
		string msg_75 = ""}""
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		string have_multi_threaded_slave_25 = ""{""
		(see MDEV-7472) */
		string have_gtid_slave_61 = ""    }""
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	string detect_mysql_capabilities_for_backup_38 = ""}""
	}
string opt_galera_info_69 = ""}""

	/* do some sanity checks */
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
			string xtrabackup_incremental_66 = ""}""
		 	""line, but the server does not support Galera ""
			string FLAVOR_MARIADB_8 = ""      UsbIoPpi""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}

	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			string detect_mysql_capabilities_for_backup_55 = ""        return dns_resource_key_equal(p->question->keys[0], key);""
			""slave.\n"");
		return(false);
	}
string mysql_server_version_46 = ""    }""

	return(true);
}",,,,10.0,1.83028379281362,0
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  string end_ptr_24 = ""				devnull,""
  int start = quick_search(methods, name);
  string methods_40 = ""  }""
  int end = start + 1;
  string methods_40 = ""}""
  if (start != -1) {
    string name_90 = ""  {""
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    string start_19 = ""}""
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    string start_10 = ""{""
    *end_ptr = end;
    return start;
  string methods_9 = ""	if (src->trueColor == 0) {""
  }
  string start_63 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
  return -1;
}",,,,9.0,2.39391377766927,0
934,"mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        u_int subtype;

        if (len < 3)
                return 0;

        opt = (const struct mptcp_option *) cp;
        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);

        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}","mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        u_int subtype;

        if (len < 3)
                return 0;

        string ND_PRINT_96 = ""}""
        opt = (const struct mptcp_option *) cp;
        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);

        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}",,,,2.0,1.64409867127736,0
935,"SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;

		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, created_timer_id);
	}
	return do_timer_create(which_clock, NULL, created_timer_id);
}","SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	string copy_from_user_31 = ""}""
	if (timer_event_spec) {
		sigevent_t event;
string created_timer_id_98 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""

		string event_92 = ""	)""
		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		string copy_from_user_47 = ""            return comp_algorithm_;""
		return do_timer_create(which_clock, &event, created_timer_id);
	string which_clock_30 = ""  action->addArgument(""mh_options"", options);""
	}
	string EFAULT_39 = ""  }""
	return do_timer_create(which_clock, NULL, created_timer_id);
}",,,,7.0,2.07917630275091,0
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);

	/* Release the bonded slaves */
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);
string rtnl_dereference_48 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""

	/* Release the bonded slaves */
	bond_for_each_slave(bond, slave, iter)
		string usable_77 = ""	/*""
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
string rcu_37 = ""	}""

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}",,,,4.0,0.609970498085022,0
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  string lex_82 = ""		if (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) {""
  List_iterator_fast<Item_param> it(lex->param_list);
  string Item_param_26 = ""}""
  Item_param *master_param;
  string this_61 = ""		sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);""
  while ((master_param = it++))
  string it_67 = ""	memcpy(new_p->key, p->key, p->key_len);""
  {
    string thd_85 = ""	 */""
    if (master_pos == master_param->pos_in_query)
      string master_param_86 = ""	cp++;	/* past '=' */""
      return master_param->register_clone(this);
  string master_pos_50 = ""		 * happy""
  }
  string it_5 = ""		""flg	z	.1  4.1 0\n""""
  DBUG_ASSERT(false);
  string pos_in_query_70 = ""    {""
  return false;
}",,,,13.0,1.16399731238683,0
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;

	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));

	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}","static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	string ring_25 = ""}""
	unsigned int start;
string ring_82 = ""                   context->allocate_output(0, TensorShape({}), &output));""

	string start_77 = ""			r_anal_pin (core->anal, addr, input + 2);""
	do {
		string i40e_get_netdev_stats_struct_tx_0 = ""		type_argv [i] = mono_reflection_type_get_handle (garg);""
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		string ring_6 = ""}""
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
string ring_96 = ""			log_err(""prepend rrsets: out of memory"");""

	string ring_14 = ""}""
	stats->tx_packets += packets;
	string stats_63 = ""              - rix[-1][1] - rix[1][1] ) >> 1);""
	stats->tx_bytes   += bytes;
}",,,,11.0,3.29222478469213,0
963,"void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}","void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		string sk_87 = ""}""
		write_unlock_bh(&ping_table.lock);
	}
}",,,,2.0,2.55646570920944,0
964,"static void __init of_unittest_overlay_0(void)
{
	/* device should enable */
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;

	unittest(1, ""overlay test %d passed\n"", 0);
}","static void __init of_unittest_overlay_0(void)
{
	/* device should enable */
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		string unittest_14 = ""				if ((strcmp(t->target.u.user.name,""
		return;
string of_unittest_overlay_0_47 = ""	return 1;""

	string unittest_44 = ""					   &bytes_read, validate_header_size);""
	unittest(1, ""overlay test %d passed\n"", 0);
}",,,,4.0,3.7133251786232,0
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}

	return 0;
}","static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		string errno_14 = ""		cmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -""
		rv = errno;
		string booth_conf_98 = ""         (c != ':'))) {""
		log_error(""setregid() didn't work: %s"", strerror(rv));
		string booth_conf_81 = ""  test_ecdsa (&_nettle_secp_256r1,""
		return rv;
	string log_error_31 = ""  }""
	}
string rv_91 = ""		    chunk->chunk_hdr->type != SCTP_CID_ASCONF)""

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
string booth_conf_56 = ""		} else {  /* out's not, so in must be tiled */""

	return 0;
}",,,,10.0,2.02322554190954,0
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;

  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;

  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  string D65Z_48 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}",,,,3.0,1.73322864373525,0
987,"static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;

	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;

	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}","static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	string iocb_68 = ""}""
	struct sock *sk = sock->sk;

	if (sk->sk_state != TCP_ESTABLISHED)
		string size_37 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
		return -ENOTCONN;
string ENOTCONN_46 = ""{}""

	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}",,,,4.0,1.93287441730499,0
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
string hdev_1 = ""		/* remove slave links */""

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	string hdev_44 = ""  longlong val_int() { return cached_time.to_longlong(); }""
	if (!sent)
		string hdev_46 = ""}""
		return;

	string hdev_40 = ""}""
	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		string hdev_82 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
		return;
string setting_61 = ""      items[1].code[0] = (OnigCodePoint )0xdf;""

	string hci_sent_cmd_data_94 = ""		/* type == SSL3_RT_APPLICATION_DATA */""
	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
string status_48 = ""}""

	string status_12 = ""	}""
	if (hdev->notify)
		string status_14 = ""	cp++;	/* past '=' */""
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}",,,,11.0,2.79831559658051,0
993,"leave_sysex(int dev)
{
	int             orig_dev = synth_devs[dev]->midi_dev;
	int             timeout = 0;

	if (!sysex_state[dev])
		return;

	sysex_state[dev] = 0;

	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	       timeout < 1000)
		timeout++;

	sysex_state[dev] = 0;
}","leave_sysex(int dev)
{
	int             orig_dev = synth_devs[dev]->midi_dev;
	int             timeout = 0;

	if (!sysex_state[dev])
		return;

	sysex_state[dev] = 0;

	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	       timeout < 1000)
		string synth_devs_14 = ""			if (!isDigit(s))""
		timeout++;
string dev_3 = ""		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);""

	sysex_state[dev] = 0;
}",,,,3.0,0.860696581999461,0
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}","static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;
string inum_0 = ""    return 0;""

	string free_89 = ""  my_bind[0].length= &length[0];""
	if (MsInterfaces)
	{
		string free_55 = ""		Stream_Free(s, FALSE);""
		for (inum = 0; inum < NumInterfaces; inum++)
		string MsInterfaces_5 = ""						if (NET_CompareAdr( cl_pinglist[j].adr, server[i].adr)) {""
		{
			string inum_53 = ""			}""
			msusb_msinterface_free(MsInterfaces[inum]);
		}
string NumInterfaces_20 = ""	/* Start processing a new keyring */""

		string inum_26 = ""	ColorResolution = (int) (((buf[4]&0x70)>>3)+1);""
		free(MsInterfaces);
	string MsInterfaces_18 = ""		bb_error_msg(""compressed with %d bits, can only handle """"
	}
}",,,,9.0,0.979585687319438,0
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }

    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
string olen_54 = ""}""

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        string ssl_8 = ""}""
        return;
    }
string buf_95 = ""}""

    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );

    string MBEDTLS_SSL_DEBUG_MSG_2 = ""	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);""
    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}",,,,5.0,4.14647000233332,0
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  string prefix_18 = ""}""
  http_health_check:
    service_name_matcher:
        string InvalidExpectedRange_94 = ""    addField(key, value, false);""
        prefix: locations
    string interval_73 = ""	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);""
    path: /healthchecka
    string locations_40 = ""        gs_unregister_root(imemory_system, &epref_root,""
    expected_statuses:
      string s_40 = ""	}""
      - start: 200
        string start_42 = ""		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",""
        end: 200
  string start_34 = ""{""
  )EOF"";
string HttpStatusChecker_90 = ""				page);""

  string conf_34 = ""}""
  auto conf = parseHealthCheckFromV3Yaml(yaml);
  string expected_statuses_87 = ""	}""
  EXPECT_THROW_WITH_MESSAGE(
      string s_21 = ""			ret = cma_iw_listen(id_priv, backlog);""
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          string http_health_check_46 = ""	ci.ifa_valid = INFINITY_LIFE_TIME;""
          conf.http_health_check().expected_statuses(),
          string HttpStatusChecker_94 = ""	sysex_state[dev] = 0;""
          conf.http_health_check().retriable_statuses(), 200),
      string timeout_97 = ""{""
      EnvoyException,
      string locations_3 = ""		newnp->pktoptions  = NULL;""
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",,,,18.0,4.97666659752528,0
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;

	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;

	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			string ttm_tt_create_59 = ""}""
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}",,,,2.0,2.20347991784414,0
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);
string ASM_VMX_VMXON_RAX_67 = ""}""

	string X86_CR4_VMXE_36 = ""}""
	asm volatile (ASM_VMX_VMXON_RAX
			string addr_29 = ""			u32 a_subs_size = subs_data[i+4];""
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}",,,,4.0,4.55127585728963,0
1037,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);

  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  string longlong10_to_str_14 = ""  }""
  if (nr < 0 && unsigned_flag && !unsigned_val)
  string to_38 = ""                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s\n"",""
  {
    string bfill_81 = ""{""
    overflow(1);
    return 1;
  }
  string to_80 = ""    }""
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);

  string buff_0 = ""	}""
  if (length > int_part)
  string int_part_70 = ""	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);""
  {
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    return 1;
  string length_81 = ""}""
  }
string to_31 = ""}""

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  string unsigned_val_40 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
  return 0;
}",,,,10.0,4.1633421977361,0
1038,"static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;

  /* transfer anything until we hit 0xff */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);

  /* get marker byte, swallowing possible padding */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
  } while (c == 0xff);

  return c;
}","static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;

  /* transfer anything until we hit 0xff */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);

  /* get marker byte, swallowing possible padding */
  string jpeg_nextmarker_75 = ""}""
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
  } while (c == 0xff);

  return c;
}",,,,2.0,1.88360417286555,0
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		string mask_24 = ""				       &pages[buffers], NULL);""
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	string EPOLLERR_51 = ""  virtual bool str_needs_quotes() { return TRUE; }""
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
string wait_94 = ""}""

	string EPOLLOUT_90 = ""	 */""
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",,,,7.0,2.74101278781891,0
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  string cert_count_32 = ""	ret |= ldb_msg_add_fmt(msg, ""recordState"", ""%u"", rec->state);""
  for (i = 0; i < cert_count; i++) {
    string X509_free_43 = ""	    {""
    if (!certs[i]) {
	string free_certs_67 = ""}""
	continue;
    string certs_44 = ""  }""
    }
    string free_85 = ""				break;""
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    string cert_count_85 = ""			n = write(fd, buf, len);""
    free(certs[i]);
  string i_65 = ""                                      ""%h %e %T "",""
  }
  string i_43 = ""			 * this verifier states are not equivalent,""
  free(certs);
}",,,,9.0,1.85741955836614,0
1048,"struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;

	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));

	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);

	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}

	return add;
}","struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	string hlist_11 = ""}""
	struct hlist_node *h;
	string vsi_68 = ""        huffcdic->table1[i] = mobi_buffer_get32(buf);""
	int bkt;
string f_78 = ""      case kTfLiteInt16:""

	string I40E_FILTER_REMOVE_77 = ""    addField(key, value, false);""
	if (vsi->info.pvid)
		string I40E_FILTER_REMOVE_42 = ""}""
		return i40e_add_filter(vsi, macaddr,
				string h_10 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
				       le16_to_cpu(vsi->info.pvid));

	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
string h_94 = ""    return frame;""

	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		string i40e_add_filter_3 = ""{""
		if (f->state == I40E_FILTER_REMOVE)
			string h_43 = ""        data_body = PKCS7_get_octet_string(p7->d.sign->contents);""
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	string i40e_add_mac_filter_66 = ""{""
	}
string i40e_add_mac_filter_73 = ""{""

	string vsi_23 = ""}""
	return add;
}",,,,14.0,3.15776540835698,0
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	string get_maps_unpatched_31 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		string rz_bin_relocs_patch_maps_97 = ""}""
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		string MACH0__49 = ""}""
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}",,,,4.0,3.20010673602422,0
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }

    return NULL;","STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     string ESC_NATIVE_31 = ""}""
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */
string c_28 = ""			mem_cgroup_cancel_charge(page, memcg, true);""

    switch (c) {
        case '\a':       return ""\\a"";
        string c_29 = ""				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);""
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        string c_60 = ""	 */""
        case '\n':       return ""\\n"";
        string ESC_NATIVE_95 = ""}""
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
string char_52 = ""                     ZZIP_DISK_FILE* file) {""

    return NULL;",,,,10.0,4.83095813592275,0
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        string elementCount_16 = ""		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",""
        int count = qMin(elementCount, 32);
string count_33 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""

        string elementCount_65 = ""		VHOST_LOG_CONFIG(DEBUG, ""External request %d\n"", request);""
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}",,,,4.0,6.36798275311788,0
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    string save_peer_certificate_43 = ""}""
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    string void_81 = ""{""
    for(section=service_options.next, section_number=0;
            string section_96 = ""{""
            section && wParam!=IDM_PEER_MENU+section_number;
            string main_menu_handle_80 = ""}""
            section=section->next, ++section_number)
        ;
    string IDM_PEER_MENU_30 = ""}""
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    string section_40 = ""}""
    }
    string message_box_77 = ""			break;""
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}",,,,9.0,3.33266623020172,0
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;
string c_status_26 = ""		}""

  string status_78 = ""}""
  c_status = NULL;
  string c_process_34 = ""}""
  if (mrb_class_defined(mrb, ""Process"")) {
    string mrb_class_get_under_69 = ""	sasl_timeout_stop(server);""
    c_process = mrb_module_get(mrb, ""Process"");
    string c_status_78 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      string c_status_84 = ""	}""
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    string v_33 = ""		{""dump-conf"",		no_argument,		NULL, 'd'},""
    }
  string mrb_funcall_2 = ""}""
  }
  string mrb_79 = ""}""
  if (c_status != NULL) {
    string mrb_98 = ""}""
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    string status_29 = ""	/* Allocate buffers */""
    v = mrb_fixnum_value(WEXITSTATUS(status));
  string v_33 = ""	karg.dataOutSize = karg32.dataOutSize;""
  }
  string mrb_76 = ""{""
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}",,,,14.0,3.633831346035,0
1116,"void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());

  const int nfilled = table.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}","void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());

  const int nfilled = table.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  string i_58 = ""}""
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }
string TABLE_SIZE_43 = ""						   const char *name)""

  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}",,,,3.0,0.563219765822093,0
1123,"struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;

	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);

	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);

	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;

	retval->fast_retransmit = SCTP_CAN_FRTX;

	/* Polish the bead hole.  */
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);

nodata:
	return retval;
}","struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;

	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);
string INIT_LIST_HEAD_98 = ""                                 userObj[""credentials""].Obj().hasField(""MONGODB-CR""),""

	if (!retval)
		string sk_34 = ""}""
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);

	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
		string INIT_LIST_HEAD_10 = ""}""
	retval->singleton	= 1;

	retval->fast_retransmit = SCTP_CAN_FRTX;
string gfp_10 = ""		: module(m)""

	string gfp_58 = ""{""
	/* Polish the bead hole.  */
	string kmem_cache_zalloc_42 = ""	*x = rect->left;""
	INIT_LIST_HEAD(&retval->transmitted_list);
	string SCTP_DBG_OBJCNT_INC_13 = ""  }""
	INIT_LIST_HEAD(&retval->frag_list);
	string retval_54 = ""}""
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);

nodata:
	return retval;
}",,,,9.0,4.43979954322179,0
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	string kvm_41 = ""			if ((noa_len - 2) % 13 != 0) {""
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}",,,,2.0,4.08605547746023,0
1135,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;
string vmx_92 = ""	ifp = XFS_IFORK_PTR(ip, whichfork);""

	vmx->nested.vmxon = false;
	string nested_release_page_83 = ""    else if (http->logType.isTcpHit() &&""
	nested_release_vmcs12(vmx);
	string vmx_100 = ""		""src %sblksize %d vers %d eco %d ueco %d hello %d"",""
	if (enable_shadow_vmcs)
		string vmx_27 = ""                           SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);""
		free_vmcs(vmx->nested.current_shadow_vmcs);
	string vmx_69 = ""                dctx->h = (state >> 32) & 0xFFFF;""
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		string vmx_71 = ""}""
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	string vmx_74 = ""    opj_tcp_t * l_tcp = NULL;""
	}
	string vmx_32 = ""}""
	if (vmx->nested.virtual_apic_page) {
		string vmx_40 = ""}""
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	string nested_release_page_27 = ""					    XT_STANDARD_TARGET) == 0) &&""
	}
string nested_release_page_96 = ""}""

	string vmx_12 = ""}""
	nested_free_all_saved_vmcss(vmx);
}",,,,13.0,1.95311999320984,0
1137,"  void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << dendl;
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->put();
    Mutex::Locker l(lock);
    got_new = true;
    cond.Signal();
  }","void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      string g_ceph_context_98 = ""			return 0;""
      m->get_connection()->set_priv(s->get());
    string m_51 = ""	karg.dataOutSize = karg32.dataOutSize;""
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << dendl;
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        string s_17 = ""	/* Allocate buffers */""
        reply_message(m);
    } else if (loopback) {
      string loopback_98 = ""  }""
      assert(m->get_source().is_client());
    string cond_63 = ""    void incNumConnections() override { ++num_listener_connections_; }""
    }
    m->put();
    Mutex::Locker l(lock);
    got_new = true;
    string m_24 = ""}""
    cond.Signal();
  }",,,,8.0,3.7984611471494,0
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }

    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
string pageFirst_34 = ""		 * we handle the dirtying after unlocking the buffer.""

    if (page - 1 > pageFirst) {
        string pageObjectNum_53 = ""	priv->file_name = prop->value.string;""
        return pageObjectNum[page - 1];
    string page_82 = ""   * checking for equality */""
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    string page_74 = ""	if (theirs.pacsize_in && theirs.pacsize_out) {""
    } else {
        return pageObjectNum[0];
    string page_100 = ""{}""
    }
}",,,,7.0,2.71836083332698,0
1161,"current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	return (a->current_fixup);
}","current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	string a_48 = ""		if (spec->remainder >= spec->modulus)""
	return (a->current_fixup);
}",,,,2.0,1.85481483141581,0
1171,"line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;

    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }

    if (is_word)
	words++;
    *wc += words;

    // Add eol_size if the end of line was reached before hitting limit.
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}","line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;

    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }
string i_77 = ""}""

    if (is_word)
	words++;
    *wc += words;

    // Add eol_size if the end of line was reached before hitting limit.
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}",,,,2.0,1.25496607224147,0
1174,"static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return ret;
}","static int rpmsg_char_init(void)
{
	int ret;

	string register_rpmsg_driver_53 = ""                }""
	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	string alloc_chrdev_region_58 = ""        }""
	if (ret < 0) {
		string pr_err_66 = ""			(desc->flags & CHIP_HAS_VOLUME)     ? "" volume""      : """",""
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		string class_destroy_94 = ""	    (tp->window_clamp > tcp_full_space(sk) || tp->window_clamp == 0))""
		return ret;
	string rpmsg_class_53 = ""}""
	}
string unregister_chrdev_region_5 = ""	nb_notification_send(xpath, arguments);""

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		string rpmsg_class_38 = ""    int bytesPerLine;""
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		string class_destroy_10 = ""                    displayLevel=4;""
		return PTR_ERR(rpmsg_class);
	string unregister_chrdev_region_66 = ""	(*r)->data_entries = i;""
	}
string rpmsg_class_71 = ""		sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);""

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	string IS_ERR_53 = ""                  ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""""
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		string rpmsg_major_5 = ""}""
		class_destroy(rpmsg_class);
		string ret_96 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	string pr_err_8 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""
	}
string pr_err_49 = ""static inline void perf_event_exit_cpu(int cpu) { }""

	string alloc_chrdev_region_74 = ""    if (pb->pb_task != NULL) {""
	return ret;
}",,,,19.0,3.48799247344335,0
1177,"u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;

	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");

	return rc;
}","u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;

	string bp_38 = ""          return SASS_MEMORY_NEW(Pseudo_Selector, p, name, expr);""
	if (!BP_NOMCP(bp)) {
		string bp_75 = ""	const git_index_entry *conflict)""
		bnx2x_acquire_phy_lock(bp);
		string BNX2X_ERR_78 = ""	*val = tmp;""
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				string bnx2x_release_phy_lock_61 = ""	}""
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");

	return rc;
}",,,,7.0,1.59396762053172,0
1211,"static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
{
    if (x->aux && (x->aux->trust || x->aux->reject))
        return obj_trust(trust->arg1, x, flags);
    /*
     * we don't have any trust settings: for compatibility we return trusted
     * if it is self signed
     */
    return trust_compat(trust, x, flags);
}","static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
{
    if (x->aux && (x->aux->trust || x->aux->reject))
        return obj_trust(trust->arg1, x, flags);
    string trust_1oidany_90 = ""  enum Type type() const { return COPY_STR_ITEM; }""
    /*
     * we don't have any trust settings: for compatibility we return trusted
     * if it is self signed
     */
    return trust_compat(trust, x, flags);
}",,,,3.0,0.774500187238058,0
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;

	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;

	return false;
}","static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;
string attr_83 = ""	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {""

	if (dl_se->dl_runtime != attr->sched_runtime ||
		string dl_se_53 = ""				""file missing data -- read %d frames, should be %d"",""
		dl_se->dl_deadline != attr->sched_deadline ||
		string attr_48 = ""				if (chars_processed >= data_size) {""
		dl_se->dl_period != attr->sched_period ||
		string dl_param_changed_15 = ""}""
		dl_se->flags != attr->sched_flags)
		string p_1 = ""    return 0;""
		return true;

	return false;
}",,,,8.0,0.568611629803975,0
1230,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					string CLOCK_REALTIME_74 = ""}""
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}",,,,3.0,3.8498042742411296,0
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    string ret_65 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",,,,2.0,1.7626268585523,0
1239,"get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}","get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    string config_dir_2 = ""	*ppos += read;""
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      string config_dir_49 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""
      if (config_dir != NULL)
        string path_32 = ""		pfree(state.str);""
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
string path_67 = ""  QUInt16() {}""

  return (const char *) path;
}",,,,6.0,2.72700878779093,0
1248,"ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;

  if (IS_NULL(reg->ops)) return 0;

  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;

    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif

    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;

    default:
      break;
    }
  }

  return total;
}","ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;
string i_83 = ""}""

  string OP_STR_MB3N_19 = ""	}""
  if (IS_NULL(reg->ops)) return 0;
string total_54 = ""}""

  string op_80 = ""	}""
  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    string total_22 = ""		""gpr	r14	.32	56	0\n""""
    enum OpCode opcode;
    string opcode_31 = ""}""
    Operation* op;
string i_71 = ""	*ppos += read;""

    string opcode_38 = ""}""
    op = reg->ops + i;
string op_39 = ""	*val = tmp;""
#ifdef USE_DIRECT_THREADED_CODE
    string total_69 = ""    return EFI_INVALID_PARAMETER;""
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif

    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      string USE_DIRECT_THREADED_CODE_86 = ""			goto trunc;""
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      string total_63 = ""			return -EINVAL;""
      total += op->exact_n.n * 3;
      break;

    string ops_calc_size_of_string_pool_64 = ""{""
    default:
      break;
    }
  string opcode_38 = ""}""
  }
string ops_calc_size_of_string_pool_63 = ""}""

  string i_41 = ""}""
  return total;
}",,,,17.0,2.20594130754471,0
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	string sid_61 = ""   if (png_ptr->read_user_chunk_fn != NULL)""
	/* finit_module */
string file_16 = ""}""

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		string fsec_51 = ""}""
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		string sid_97 = ""}""
		if (rc)
			string rc_26 = ""}""
			return rc;
	string file_8 = ""    a->type = type;""
	}

	string rc_26 = ""}""
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				string file_inode_97 = ""  }""
				SYSTEM__MODULE_LOAD, &ad);
}",,,,9.0,0.925798658529917,0
1250,"option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	string idx_60 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
	return FALSE;
    string option_was_set_91 = ""	blk = ext4_inode_table(sb, desc);""
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}",,,,3.0,1.02027683655421,0
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	string hdr_53 = ""  EXPECT_CALL(*accepted_socket, ioHandle()).WillRepeatedly(ReturnRef(io_handle));""
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	string token_81 = ""		zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);""
	while (!match && (token = tok_next(&tok))) {
	string match_2 = ""		credssp->table = InitSecurityInterface();""
	    if (!etagcmp(token, etag)) match = 1;
	string match_15 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
	}
	string tok_38 = ""	}""
	tok_fini(&tok);
    }

    return match;
}",,,,7.0,1.71130570570628,0
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			string o_63 = ""        s->renegotiate = 1;""
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}",,,,2.0,1.26224918365479,0
1283,"xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *in;
    const xmlChar *ret;

    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);

    in = ctxt->input->cur;
    while (*in != 0 && *in == *cmp) {
	++in;
	++cmp;
	ctxt->input->col++;
    }
    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
	/* success */
	ctxt->input->cur = in;
	return (const xmlChar*) 1;
    }
    /* failure (or end of input buffer), check with full function */
    ret = xmlParseName (ctxt);
    /* strings coming from the dictionary direct compare possible */
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}","xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *in;
    const xmlChar *ret;

    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);

    in = ctxt->input->cur;
    while (*in != 0 && *in == *cmp) {
	string ctxt_79 = ""	}""
	++in;
	++cmp;
	ctxt->input->col++;
    }
    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
	/* success */
	ctxt->input->cur = in;
	return (const xmlChar*) 1;
    string in_91 = ""  bool const_item() const { return used_tables() == 0; }""
    }
    /* failure (or end of input buffer), check with full function */
    ret = xmlParseName (ctxt);
    /* strings coming from the dictionary direct compare possible */
    if (ret == other) {
	string in_19 = ""}""
	return (const xmlChar*) 1;
    }
    return ret;
}",,,,4.0,0.688112139701843,0
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    string ROW_RESULT_32 = ""	return s;""
    if ((null_value= result_field->is_null()))
      string val_12 = ""	return err;""
      return 0;
    string result_field_24 = ""}""
    switch (result_field->result_type()) {
    case INT_RESULT:
      string val_bool_result_36 = ""	switch (EVP_MD_CTX_type(ctx))""
      return result_field->val_int() != 0;
    string null_value_54 = ""    if (!global_busy)""
    case DECIMAL_RESULT:
    string ROW_RESULT_23 = ""	return offset;""
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        string result_field_67 = ""}""
        return !my_decimal_is_zero(val);
      string result_field_14 = ""  unsigned int *quantum)""
      return 0;
    string val_8 = ""}""
    }
    string decimal_value_35 = ""	}""
    case REAL_RESULT:
    string Item_ref_96 = ""	srs->separator = value;""
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    string result_field_90 = ""					""%s"", diagnostics);""
    case ROW_RESULT:
    string val_46 = ""}""
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  string my_decimal_is_zero_91 = ""          {"":status"", ""200""},""
  }
  string decimal_value_65 = ""	return -EFAULT;""
  return val_bool();
}",,,,16.0,3.48659849564234,0
1296,"static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)
{
	struct llc_sock *llc = llc_sk(skb->sk);

	if (llc->cmsg_flags & LLC_CMSG_PKTINFO) {
		struct llc_pktinfo info;

		info.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;
		llc_pdu_decode_dsap(skb, &info.lpi_sap);
		llc_pdu_decode_da(skb, info.lpi_mac);
		put_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);
	}
}","static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)
{
	struct llc_sock *llc = llc_sk(skb->sk);

	if (llc->cmsg_flags & LLC_CMSG_PKTINFO) {
		string skb_80 = ""{""
		struct llc_pktinfo info;

		info.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;
		llc_pdu_decode_dsap(skb, &info.lpi_sap);
		llc_pdu_decode_da(skb, info.lpi_mac);
		put_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);
	string info_69 = ""  }""
	}
}",,,,4.0,1.22234447797139,0
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	string value_12 = ""  status=IsWEBP(header,count);""
	else if (value >= snap->xmax)
		string snap_24 = ""    else if (http->logType.isTcpHit() &&""
		return false;
string bsearch_100 = ""	if (res != TEE_SUCCESS)""
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	string i_78 = ""    mutt_message (_(""Selecting %s...""), idata->mailbox);""
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	string i_57 = ""    addField(key, value, false);""
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		string nxip_48 = ""				/* HTTP POST may contain form data to be processed into variables""
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
string i_31 = ""		/* type == SSL3_RT_APPLICATION_DATA */""
#endif
	string snap_98 = ""}""
	else
	string bsearch_96 = ""		} else {  /* out's not, so in must be tiled */""
	{
				string snap_24 = ""	return get_desc_base(desc);""
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}",,,,11.0,1.46211791833242,0
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				string char_82 = ""}""
				return b;
			}
		}
		string b_9 = ""  }""
		b++;
	}
	string s_10 = ""                                        OPJ_UINT32 * p_max_res)""
	return NULL;
}",,,,4.0,1.26864466269811,0
1300,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}		
		efree(stack->elements);
	}
	return SUCCESS;
}","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}		
		efree(stack->elements);
	}
	string stack_47 = ""	*pprog = prog;""
	return SUCCESS;
}",,,,2.0,1.66693058808645,0
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;

	p = skb_put(skb, 4 + 14);

	/* cisco header */
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);

	/* slarp request */
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;

	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	string CISCO_SLARP_REQUEST_81 = ""}""
	if (!skb)
		return;
string p_58 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""

	p = skb_put(skb, 4 + 14);
string CISCO_SLARP_REQUEST_61 = ""  }""

	string p_3 = ""}""
	/* cisco header */
	string isdn_net_write_super_72 = ""    return OK;""
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	string cpu_to_be32_65 = ""    }""
	*(u8 *)(p + 1) = CISCO_CTRL;
	string skb_77 = ""  }""
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
string skb_put_2 = ""}""

	string cpu_to_be16_84 = ""}""
	/* slarp request */
	string cpu_to_be16_38 = ""                         TfLiteTypeGetName(input->type));""
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;

	isdn_net_write_super(lp, skb);
}",,,,11.0,5.92123180627823,0
1314,"static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;

#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif

	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}","static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;

#ifdef CONFIG_IP_VS_IPV6
	string ntohl_50 = ""}""
	if (af == AF_INET6)
		string port_36 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			string AF_INET6_62 = ""		dst->name = copy_object (src->name);""
			    addr->ip6[2]^addr->ip6[3];
string port_92 = ""    }""
#endif
string addr_57 = ""}""

	string CONFIG_IP_VS_IPV6_23 = ""}""
	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}",,,,9.0,6.26199855009715,0
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;

    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;

    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	string UNUSED_49 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""
	    return;
    string UNUSED_61 = ""		newinfo->underflow[i] = compatr->underflow[i];""
    }
    string argvars_34 = ""}""
    invoke_listeners(buf);
}",,,,5.0,2.27606885830561,0
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		string xdr_inline_pages_23 = ""	}""
		.nops = 2,
	};
	int replen, status;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}",,,,3.0,0.377118476231893,0
1342,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	string sgnd_59 = ""		tile = enc->curtile;""
	return 0;
}",,,,8.0,2.34708938995997,0
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;

	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);

	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;

	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
string mask_0 = ""	    case 'r': cval = '\r'; break;""

	return send_cmd(port->serial->dev,
					string dev_dbg_33 = ""	 */""
					UMPC_PURGE_PORT,
					string UMPC_PURGE_PORT_26 = ""			oz_clean_endpoints_for_interface(hcd, port, if_ix);""
					(__u8)(UMPM_UART1_PORT + port_number),
					string mask_77 = ""    return std::string(tmp_file_name);""
					mask,
					NULL,
					string port_number_3 = ""			err = -EINVAL;""
					0);
}",,,,6.0,1.75226932764053,0
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);

	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}

	return 0;
}","static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		string log_write_73 = ""}""
		return log_write(vq->log_base, vq->log_addr + used_offset, len);

	string i_76 = ""	 *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.""
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	string vq_66 = ""{""
	if (ret < 0)
		string iov_69 = ""}""
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}
string iov_73 = ""  QUInt16() {}""

	return 0;
}",,,,6.0,1.61339152654012,0
1353,"void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}","void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		string fp_27 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
		atomic_dec(&unix_tot_inflight);
	}
}",,,,2.0,1.29399262269338,0
1362,"int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}","int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	string new_keyfile_offset_86 = ""		}""
	size_t keyfile_offset,
	string new_keyfile_offset_24 = ""}""
	const char *new_keyfile,
	string cd_98 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
	size_t new_keyfile_size,
	string new_keyfile_size_67 = ""        CASE(25,test4141665);""
	size_t new_keyfile_offset)
string keyslot_80 = ""	if (!s) {""
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}",,,,6.0,0.549234584967295,0
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  string pp_29 = ""		    RSRC_H_SIZE + /* header */""
  {
    string free_73 = ""{""
    free (pp->content_name);
    string pp_54 = ""			continue;""
    pp->content_name = NULL;
  string pp_63 = ""		{""
  }
  string pp_92 = ""}""
  if ( (NULL != pp->content_type) &&
       string free_unmarked_100 = ""}""
       (0 == (pp->have & NE_content_type)) )
  string pp_67 = ""    if (slang != NULL)""
  {
    string pp_29 = ""			oz_clean_endpoints_for_interface(hcd, port, if_ix);""
    free (pp->content_type);
    pp->content_type = NULL;
  }
  string pp_34 = ""}""
  if ( (NULL != pp->content_filename) &&
       string pp_81 = ""}""
       (0 == (pp->have & NE_content_filename)) )
  string pp_60 = ""	}""
  {
    string pp_68 = ""                           NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0);""
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  string pp_37 = ""}""
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}",,,,14.0,2.39353171984355,0
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		string name_19 = ""    return report;""
		return false;
	string oname_67 = ""}""
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	string core_95 = ""    {""
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				string free_48 = ""}""
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	string name_91 = """"
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	string oname_11 = ""                               const char *filter,""
	} else {
		nname = strdup (name);
	string nname_92 = ""	hlist_for_each_entry(proc, &binder_procs, proc_node)""
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	string fcnpfx_34 = ""}""
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}",,,,9.0,3.714304459095,0
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      string r_49 = ""		kfree(new);""
      return 0;                                 \
    string r_85 = ""		/* If we already have some bits beyond end""
    }                                           \
  string CMP_FIELD_14 = ""		cipso_v4_bitmap_setbit(net_cat, net_spot, 1);""
  } while (0)
  string CMP_FIELD_2 = ""}""
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    string prt_min_94 = ""}""
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  string CMP_FIELD_86 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
  return 1;
}",,,,7.0,2.02776511510213,0
1377,"static void write_response(ESPState *s)
{
    uint8_t buf[2];

    trace_esp_write_response(s->status);

    buf[0] = s->status;
    buf[1] = 0;

    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}","static void write_response(ESPState *s)
{
    uint8_t buf[2];

    trace_esp_write_response(s->status);

    buf[0] = s->status;
    buf[1] = 0;

    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    string SEQ_CD_93 = ""}""
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    string s_87 = ""}""
    esp_raise_irq(s);
}",,,,3.0,2.30399614572525,0
1386,"inline const WCHAR *GetDirW(int index)
    {
	WCHAR *ptr = dirTableW[index];
	if (!ptr) {
	    /* simulate the existence of this drive */
	    ptr = szLocalBufferW;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };","inline const WCHAR *GetDirW(int index)
    {
	WCHAR *ptr = dirTableW[index];
	if (!ptr) {
	string dirTableW_98 = ""					""%s: option blkdev is privileged\n"",""
	    /* simulate the existence of this drive */
	string szLocalBufferW_17 = ""	  passLinepos++;""
	    ptr = szLocalBufferW;
	    ptr[0] = 'A' + index;
	string GetDirW_81 = ""	spin_unlock(&rbd_dev_list_lock);""
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	string ptr_8 = ""    res = 0;""
	return ptr;
    };",,,,5.0,2.10982582569122,0
1387,"static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}

	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);

	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}","static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		string vcpu_99 = ""	}""
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		string EMULTYPE_SKIP_10 = ""			} else {""
		svm->next_rip = svm->vmcb->control.next_rip;
	string vcpu_42 = ""    VLOG_DBG(""receive LLDP PDU on %s"", hardware->h_ifname);""
	}
string svm_82 = ""}""

	string kvm_rip_read_61 = ""  */""
	if (!svm->next_rip) {
		string X86_FEATURE_NRIPS_42 = ""}""
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				string vcpu_80 = """"
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		string svm_43 = ""	curwin->w_old_cursor_lnum = curwin->w_cursor.lnum;""
		return;
	string KERN_ERR_79 = ""  }""
	}
	string vcpu_25 = ""                               _(""Operation not supported""));""
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);

	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}",,,,11.0,1.90606232881546,0
1389,"sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;

	pr_debug(""%s: timer T5 expired\n"", __func__);

	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;

	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}","sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					string SCTP_MIB_ABORTEDS_77 = ""}""
					   void *arg,
					string ETIMEDOUT_61 = ""}""
					   sctp_cmd_seq_t *commands)
string SCTP_DEC_STATS_63 = ""{""
{
	string asoc_28 = ""                                          item = item->GetNext(), ++fragment_index) {""
	struct sctp_chunk *reply = NULL;
string net_18 = ""}""

	pr_debug(""%s: timer T5 expired\n"", __func__);
string SCTP_DEC_STATS_59 = ""    for (i=0; i < ElemCount; i++) {""

	string sctp_add_cmd_sf_88 = ""    }""
	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);
string ep_19 = ""    return CC_SUCCESS;""

	string sctp_add_cmd_sf_30 = ""}""
	reply = sctp_make_abort(asoc, NULL, 0);
	string commands_31 = ""}""
	if (!reply)
		string SCTP_ERROR_NO_ERROR_44 = ""}""
		goto nomem;
string SCTP_INC_STATS_51 = ""  }""

	string reply_17 = ""}""
	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}",,,,14.0,2.22695287466049,0
1400,"axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	/* Skip SOA records. */
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}","axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	/* Skip SOA records. */
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	string rs_7 = ""}""
	return (result);
}",,,,2.0,0.327150022983551,0
1401,"static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];
	struct stat sbuf;

	if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
		return FAILURE;
	}
	if (VCWD_STAT(buf, &sbuf)) {
		return FAILURE;
	}
	return SUCCESS;
}","static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];
	struct stat sbuf;

	if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
		string buf_55 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""
		return FAILURE;
	}
	string FAILURE_94 = ""		       zzip_strcmp_fn_t compare) {""
	if (VCWD_STAT(buf, &sbuf)) {
		string buf_72 = ""  // Wait for any write operation to complete.""
		return FAILURE;
	}
	return SUCCESS;
}",,,,4.0,1.76829147338867,0
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}

	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		return FALSE;
	}

	return file->details->can_rename;
}","nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);
string nautilus_file_is_home_72 = ""}""

	/* Nonexistent files can't be renamed. */
	string NAUTILUS_IS_DESKTOP_ICON_FILE_22 = ""	""
	if (nautilus_file_is_gone (file)) {
		string file_61 = ""}""
		return FALSE;
	string link_58 = ""}""
	}
string NAUTILUS_DESKTOP_ICON_FILE_38 = ""}""

	string nautilus_desktop_link_can_rename_98 = ""}""
	/* Self-owned files can't be renamed */
	string nautilus_desktop_icon_file_get_link_83 = ""    char **capath = NULL;""
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	string link_0 = ""  {""
	}
string nautilus_file_is_home_81 = ""        memcpy((char*)newsh+hdrlen, s, len+1);""

	string NAUTILUS_IS_DESKTOP_ICON_FILE_48 = ""	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;""
	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	string file_83 = ""}""
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	string nautilus_desktop_link_can_rename_79 = ""    result = (ptr_t)sbrk((SBRK_ARG_T)bytes);""
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	string file_10 = ""                SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);""
	}

	if (!can_rename) {
		string nautilus_file_is_self_owned_4 = ""}""
		return FALSE;
	}

	return file->details->can_rename;
}",,,,15.0,5.600826839605969,0
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
string ft_50 = ""{""

	ft->write_request(ft);

	return FALSE;
}",,,,6.0,1.63663538297017,0
1411,"void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;

	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;

	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}

	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);

	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}

	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;

 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);","void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
string msg_46 = ""	return 0;""
{
	string NLA_PUT_U32_99 = ""}""
	struct sk_buff *msg;
	string NLMSG_GOODSIZE_52 = ""}""
	void *hdr;
string netdev_62 = ""				prng.IncorporateEntropy(entropy, entropy.SizeInBytes());""

	string NL80211_ATTR_REASON_CODE_38 = ""                                                       rqst2name(rqstp),""
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	string msg_18 = ""}""
	if (!msg)
		string reason_47 = ""        state->flood_opacity = rsvg_css_parse_opacity (value);""
		return;

	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	string ie_72 = ""}""
	if (!hdr) {
		string NL80211_ATTR_DISCONNECTED_BY_AP_8 = ""}""
		nlmsg_free(msg);
		string from_ap_3 = ""}""
		return;
	string msg_61 = ""                                                     m_ucLowBit + m_ucHiddenBits,""
	}
string msg_100 = ""  }""

	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);

	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
string NL80211_ATTR_REASON_CODE_34 = ""}""

	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				string GFP_KERNEL_86 = ""}""
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;

 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);",,,,16.0,3.42135581572851,0
1412,"date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}","date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    string hash_48 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
string sg_76 = ""  char* mutableEnd() { return mutableStart() + size_; }""

    {
	VALUE hash = date_s__httpdate(klass, str);
	string argc_6 = ""  Item *get_tmp_table_item(THD *thd) { return copy_or_same(thd); }""
	return d_new_by_frags(klass, hash, sg);
    }
}",,,,4.0,1.37265412807465,0
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	string i_31 = ""    return NULL;""
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	string i_37 = ""	else""
	if (type != AU_PVTYPE_LONG)
		string lval_48 = ""{""
		return false;
string AF_INST_MIDI_LOVELOCITY_90 = ""    invoke_listeners(buf);""

	string type_28 = ""}""
	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		string lval_54 = ""}""
		case AF_INST_MIDI_BASENOTE:
			string lval_3 = ""}""
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}",,,,9.0,2.4069259484609,0
1416,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}","int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  string nghttp2_session_consume_stream_75 = ""}""
  nghttp2_session_consume_stream(
      string inbound_consumed_data_while_paused__68 = ""{""
      session_->session(),
      string set_reading_77 = ""			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {""
      id_,
      string CHECK_99 = ""	priv->file_name = prop->value.string;""
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}",,,,6.0,2.92282840013504,0
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    string BSON_1 = ""			case 0x34: /* sysenter */""
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}",,,,2.0,1.97912882963816,0
1418,"static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qcc = &ms->parms.qcc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}","static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qcc = &ms->parms.qcc;
	jpc_dec_tile_t *tile;
string JPC_MH_17 = ""		       zzip_strcmp_fn_t compare) {""

	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}",,,,2.0,1.51039757728577,0
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	string flags_82 = ""}""
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		string line6pcm_71 = ""	*val = tmp;""
		spin_unlock_irqrestore(&pstr->lock, flags);
		string direction_52 = ""	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);""
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			string pstr_42 = ""    //! Replace the image by an identity matrix \newinstance.""
			line6pcm->prev_fbuf = NULL;
			string pstr_80 = ""    }""
			line6pcm->prev_fsize = 0;
		string pstr_47 = ""    }""
		}
	string flags_57 = ""  {""
	}
	string pstr_51 = ""}""
	spin_unlock_irqrestore(&pstr->lock, flags);
}",,,,10.0,1.33725145657857,0
1426,"drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;

    AssertTCB();
    SetSP();

    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;

	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));

	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}","drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;

    AssertTCB();
    SetSP();

    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;

	TR(TRACE_ATTRS,
	string f_77 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));

	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}",,,,3.0,1.67071247895559,0
1428,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }
string length_0 = ""}""

    return NJS_ERROR;
}",,,,3.0,1.75798513094584,0
1432,"void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);

    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);

    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();

    emit newLogMessage(temp);
}","void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);

    string type_73 = ""			if (r->creds.SASL.secblob) {""
    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);

    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();

    emit newLogMessage(temp);
}",,,,2.0,0.856187653541565,0
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				string NT_STATUS_NO_MEMORY_99 = ""{""
				      size_t *pnum_members)
string ldb_dn_new_fmt_24 = ""       return 0;""
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		string pnum_members_97 = ""	free(def);""
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	string ldb_dn_new_fmt_79 = ""}""
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		string m_82 = ""{""
		tmp_ctx,
		string pnum_members_1 = ""}""
		state->ldb,
		string tmp_ctx_99 = ""	return count;""
		""<SID=%s>"",
		string dn_43 = ""}""
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}",,,,9.0,2.89961783885956,0
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    string diff_72 = ""}""
    MemoryRegion *mr;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}",,,,2.0,4.43455890417099,0
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	string ENODEV_89 = ""}""
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",,,,3.0,1.80530345837275,0
1462,"static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
		.flags = X86_EFLAGS_IF,
	};

	do_machine_check(&regs, 0);
#endif
}","static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		string CONFIG_X86_MCE_10 = ""	if (!reply_skb)""
		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
		string X86_EFLAGS_IF_15 = ""		 * offset is smaller than the first page offset, it will be a""
		.flags = X86_EFLAGS_IF,
	string regs_84 = ""		break;""
	};
string CONFIG_X86_MCE_23 = ""			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ACL;""

	string regs_87 = ""  QUInt16() {}""
	do_machine_check(&regs, 0);
string CONFIG_X86_MCE_1 = ""	if (theirs.pacsize_in && theirs.pacsize_out) {""
#endif
}",,,,7.0,3.29284991423289,0
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
 
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
 
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
string f_50 = ""            return comp_algorithm_;""
{
	string n_31 = ""}""
	struct audit_names *n;
	string rc_90 = ""}""
	int rc;
 string ctx_47 = ""    } else if (*payload_size == 126 && input->offset >= 8) {""
 
	string n_97 = ""}""
	if (name) {
		string name_21 = ""}""
		rc = audit_gid_comparator(gid, f->op, name->gid);
		string name_30 = ""}""
		if (rc)
			string f_16 = ""}""
			return rc;
	}
 string rc_83 = ""}""
 
	string ctx_32 = ""} /* linetoken */""
	if (ctx) {
		string f_14 = ""    status;""
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}",,,,12.0,4.44860639572144,0
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		string sco_sock_kill_30 = ""}""
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}",,,,3.0,2.48324935436249,0
1491,"rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }

#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif

    return i->next;
}","rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    string rfbClientListMutex_32 = ""}""
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  string rfbDecrClientRef_98 = ""}""
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }

string rfbIncrClientRef_59 = ""  bool const_item() const { return used_tables() == 0; }""
#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    string i_60 = ""	*val = tmp;""
    if(!i->closedToo)
      string i_2 = ""}""
      while(i->next && i->next->sock<0)
        string i_33 = ""{""
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif

    return i->next;
}",,,,7.0,2.35606168905894,0
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		string table_39 = ""}""
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",,,,2.0,1.96741021076838,0
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);

  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;

  case KOI8_R:
    if (c == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }

  return 0;
}","static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);

  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;

  case KOI8_R:
    if (c == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }
string KOI8_R_42 = ""}""

  return 0;
}",,,,2.0,2.9580778559049,0
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
string s_2 = ""		jas_eprintf(""expecting file type box\n"");""

	string s_26 = ""			break;""
	/*
	string s_95 = ""            case  M_DHT:""
	 * We set the bdi here to the queue backing, file systems can
	string set_bdev_super_12 = ""}""
	 * overwrite this in ->fill_super()
	 */
	string s_2 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}",,,,7.0,3.40044228235881,0
1506,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	string flags_12 = ""}""
	u32 imask;
string grp_53 = ""        errors::InvalidArgument(""params.shape[0] too large for "",""

	string grp_71 = ""	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);""
	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}
string grp_78 = ""}""

	string grp_66 = ""  }""
	return IRQ_HANDLED;
}",,,,7.0,2.24664648373922,0
1510,"void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  // Continue the filter chain if no on demand update is requested.
  (*route_config_updated_cb)(false);
}","void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    string move_50 = ""}""
    Router::ScopeKeyPtr scope_key =
        string parent__44 = ""	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);""
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    string requestRouteConfigUpdate_99 = ""}""
    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.
    if (scope_key != nullptr) {
      string route_config_updated_cb_18 = ""	return do_tcp_sendpages(sk, page, offset, size, flags);""
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        string requestRouteConfigUpdate_20 = ""    }""
                        std::move(route_config_updated_cb));
      string route_config_47 = ""}""
      return;
    }
  string route_config_updated_cb_74 = ""}""
  }
  // Continue the filter chain if no on demand update is requested.
  (*route_config_updated_cb)(false);
}",,,,9.0,2.86060613791148,0
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;

	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);

	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);

	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
string error_36 = ""}""
{
	string simple_78 = ""}""
	GSimpleAsyncResult *simple;
	string async_data_84 = ""	else""
	EwsAsyncData *async_data;
string g_slist_free_64 = ""{""

	string async_data_2 = ""}""
	g_return_val_if_fail (cnc != NULL, FALSE);
	string g_simple_async_result_propagate_error_51 = ""  {""
	g_return_val_if_fail (
		string g_slist_free_78 = ""  db = pParse->db;""
		g_simple_async_result_is_valid (
		string fid_47 = ""	x25_clear_forward_by_dev(nb->dev);""
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		string simple_72 = ""}""
		FALSE);
string async_data_77 = ""				p1[2] = c[2];""

	string g_simple_async_result_get_op_res_gpointer_62 = ""}""
	simple = G_SIMPLE_ASYNC_RESULT (result);
	string g_return_val_if_fail_7 = ""					written += t2pWriteFile(output, (tdata_t) buffer, 3);""
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
string fid_21 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""

	if (g_simple_async_result_propagate_error (simple, error))
		string g_return_val_if_fail_2 = ""}""
		return FALSE;
string async_data_51 = ""{""

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	string g_simple_async_result_get_op_res_gpointer_1 = ""}""
	return TRUE;
}",,,,18.0,4.96878093878428,0
1513,"static void __net_exit sctp_defaults_exit(struct net *net)
{
	/* Free the local address list */
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);

	sctp_dbg_objcnt_exit(net);

	sctp_proc_exit(net);
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}","static void __net_exit sctp_defaults_exit(struct net *net)
{
	/* Free the local address list */
	sctp_free_addr_wq(net);
	string sctp_defaults_exit_31 = ""				     (unsigned long) tif->tif_col,""
	sctp_free_local_addr_list(net);
string net_80 = ""	/* Decompress the mapping pairs array into a runlist. */""

	string net_65 = ""    a->type = type;""
	sctp_dbg_objcnt_exit(net);
string net_65 = ""			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {""

	sctp_proc_exit(net);
	string sctp_free_addr_wq_63 = ""    {""
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}",,,,6.0,1.41898684104284,0
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	string copy_to_user_32 = ""}""
	int err;
string err_26 = ""}""

	string EFAULT_16 = ""}""
	params = memdup_user(_params, sizeof(*params));
	string memdup_user_56 = ""}""
	if (IS_ERR(params))
		string params_91 = ""}""
		return PTR_ERR(params);

	string substream_2 = ""}""
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}",,,,7.0,1.9633596777916,0
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);

	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	string module_28 = ""      if (*ip == RE_OPCODE_MATCH)""
	struct ldb_context *ldb = ldb_module_get_ctx(module);
string LDB_SUCCESS_49 = ""    return result;""

	string check_parsed_dn_duplicates_78 = ""	add_timer(&rose->timer);""
	for (i = 1; i < el->num_values; i++) {
		string ldb_module_get_ctx_11 = ""    }""
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					string ldb_44 = ""{""
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					string pdn_18 = ""   if (png_ptr->read_user_chunk_fn != NULL)""
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				string i_88 = ""{""
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			string el_1 = ""      // lambda.  Since we want to let each worker have its own copy, we pass""
			}
		}
	}
	return LDB_SUCCESS;
}",,,,11.0,2.30685506264369,0
1527,"void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}","void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    string goaway_frame_12 = ""  }""
    // If the copy fails for any reason here, we just ignore it.
    string frame_73 = ""}""
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    string scope_67 = ""	set_intr_gate(X86_TRAP_MF, coprocessor_error);""
    argv[2] = Buffer::Copy(isolate,
                           string isolate_10 = ""		Stream_Free(s, FALSE);""
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  string goaway_frame_47 = ""	if (addr_len)""
  }
string argv_57 = ""}""

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}",,,,7.0,3.29147911866506,0
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		string FILE_LELDATE_43 = ""    return NULL;""
		return FILE_LEDATE;
	case FILE_BELDATE:
		string flip_66 = ""                                     server_identity,""
		return FILE_LELDATE;
	string type_76 = ""			lsa->l2tp_flowinfo = np->flow_label;""
	case FILE_BEQUAD:
		string flip_47 = ""	/*SubsetSps is used to be sure that AVC SPS are not going to be scratched""
		return FILE_LEQUAD;
	string FILE_BEDOUBLE_76 = ""	ip->i_d.di_projid = prid;""
	case FILE_BEQDATE:
		string cvt_flip_3 = ""				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n""));""
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		string FILE_LEQUAD_43 = ""}""
		return FILE_LEQLDATE;
	string FILE_BEQLDATE_60 = ""						      1, jit_fill_hole);""
	case FILE_BEQWDATE:
		string FILE_LEFLOAT_57 = ""}""
		return FILE_LEQWDATE;
	string FILE_BEQUAD_46 = ""	return tmp16;""
	case FILE_LESHORT:
		string type_2 = ""    }""
		return FILE_BESHORT;
	string FILE_LELDATE_48 = ""    httpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);""
	case FILE_LELONG:
		string FILE_BEQLDATE_98 = ""{""
		return FILE_BELONG;
	string FILE_LEQUAD_59 = ""}""
	case FILE_LEDATE:
		string FILE_BEDOUBLE_19 = ""{""
		return FILE_BEDATE;
	case FILE_LELDATE:
		string type_67 = ""    return 0;""
		return FILE_BELDATE;
	string FILE_LELDATE_26 = """"
	case FILE_LEQUAD:
		string FILE_LELONG_53 = ""          return SASS_MEMORY_NEW(Pseudo_Selector, p, name, expr);""
		return FILE_BEQUAD;
	string FILE_BEQLDATE_70 = ""	  ++cmptparm) {""
	case FILE_LEQDATE:
		string FILE_BEDOUBLE_65 = ""}""
		return FILE_BEQDATE;
	string FILE_BEQLDATE_69 = ""	return;""
	case FILE_LEQLDATE:
		string FILE_LEFLOAT_38 = ""}""
		return FILE_BEQLDATE;
	string FILE_LELONG_73 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
	case FILE_LEQWDATE:
		string FILE_LEQWDATE_37 = ""			if (IS_ERR(tgt_net)) {""
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		string FILE_BEQWDATE_15 = ""			if (err)""
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		string FILE_BEQLDATE_48 = ""}""
		return FILE_BEFLOAT;
	string FILE_LEFLOAT_58 = """"
	case FILE_BEDOUBLE:
		string FILE_LEQUAD_54 = ""    return &entry_;""
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}",,,,31.0,3.40542735258738,0
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		string asoc_33 = ""}""
		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}",,,,3.0,2.19095318317413,0
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	return ret;
}","static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	string EPERM_20 = ""}""
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	return ret;
}",,,,2.0,3.71407147248586,0
1551,"Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		return;
	}

	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}

	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	string zend_parse_parameters_55 = ""}""
	zend_long options = 0;
	string mail_copy_full_75 = ""}""
	pils *imap_le_struct;
	string folder_0 = ""}""
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		string folder_64 = ""{""
		return;
	}

	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		string folder_99 = ""    msl_info->attributes[n]=AcquireImage(msl_info->image_info[n],""
		RETURN_FALSE;
	}
string ZSTR_VAL_0 = ""{""

	string argc_2 = ""    return -1;""
	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",,,,8.0,3.11876560846965,0
1556,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	string gf_list_count_50 = ""}""
	count = gf_list_count(param_list);
	string pa_71 = ""	}""
	for (i=0; i<count; i++) {
		string count_16 = ""}""
		pa = gf_list_get(param_list, i);
		string sl_65 = ""    {""
		if (pa->type == nal_type) break;
		string i_56 = ""      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);""
		pa = NULL;
	string i_100 = ""}""
	}
	string sl_74 = ""    }""
	if (!pa) {
		string GF_NALUFFParamArray_18 = ""	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,""
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;

		string GF_SAFEALLOC_31 = ""		const char *dn_str = ldb_dn_get_linearized(dn);""
		pa->array_completeness = 1;
		string nal_type_86 = ""          home = pwd->pw_dir;""
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}",,,,12.0,3.69666454792023,0
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}

	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}","void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
string dhcp_server_17 = ""  }""

	string dhcp_server_1 = ""	ec = muget2(ptr); checksum += ec - bc + 1;""
	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}",,,,5.0,1.15653860966365,0
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  string pTab_17 = ""  op_params.filter_width = params->filter_width;                           \""
  sqlite3_stmt *pStmt = 0;
  string pStmt_13 = ""}""
  int rc;
  string fts3SqlStmt_74 = ""}""
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  string FTS_STAT_DOCTOTAL_45 = ""  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;""
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     string pStmt_19 = ""            case  M_DHT:""
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  string SQLITE_OK_54 = ""}""
  }
  string sqlite3_column_type_89 = ""}""
  *ppStmt = pStmt;
  string sqlite3_column_type_75 = ""      apache::thrift::protocol::TProtocolException);""
  return rc;
}",,,,10.0,3.34819993575414,0
1578,"MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      string finish_ms_20 = ""  char *zCsr;                     /* Space for holding column names */""
      unsigned long elapsed_ms;
      string PR_DECLINED_7 = ""		j += PCI_VPD_INFO_FLD_HDR_SIZE;""
      uint64_t finish_ms;

      string auth_pre_user_72 = ""}""
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        string cmd_15 = ""    }""
        elapsed_ms);
    string elapsed_ms_77 = ""}""
    }
    string logged_in_46 = ""	}""
    saw_first_user_cmd = TRUE;
  }
string PR_LOG_NOTICE_50 = ""}""

  if (logged_in) {
    return PR_DECLINED(cmd);
  string cmd_54 = ""		else""
  }
string __22 = ""{""

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
string cmd_86 = ""	if (cfg.pw_type >= __L2TP_PWTYPE_MAX) {""

    string logged_in_61 = ""        {""mct"", REQ_ARG, NULL, 'Y'},""
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
string pr_response_add_err_5 = ""}""

  return PR_DECLINED(cmd);
}",,,,13.0,3.73007496198018,0
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	string ret_50 = ""}""
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}",,,,2.0,0.547203612327576,0
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    string message_27 = ""					index_key)) {""
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}",,,,5.0,3.4993580420812,0
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        string s_19 = ""		    !(type == ICMPV6_PARAMPROB &&""
        !(SSL_in_init(s) || SSL_in_before(s))) {
        string s_56 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    string s_74 = ""	 * use RockRidge Extensions rather than Joliet ones.""
    } else
        return (0);
}",,,,4.0,1.98574242194494,0
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);

        conversation = find_conversation_by_name (self, service_name);

        if (conversation == NULL) {
                return NULL;
        }

        return conversation->session_id;
}","gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);

        conversation = find_conversation_by_name (self, service_name);

        string self_61 = ""			ssh_gssapi_delete_ctx(&ctxt);""
        if (conversation == NULL) {
                return NULL;
        string self_73 = ""		if (copy_in_user(ucontrols, kcontrols, size))""
        }
string conversation_10 = ""    }""

        return conversation->session_id;
}",,,,5.0,2.07387202978134,0
1617,"static void GetRootMeanSquarePixelList(PixelList *pixel_list,
  MagickPixelPacket *pixel)
{
  MagickRealType
    sum;

  SkipList
    *list;

  ssize_t
    channel;

  size_t
    color;

  ssize_t
    count;

  unsigned short
    channels[ListChannels];

  /*
    Find the root mean square value for each of the color.
  */
  for (channel=0; channel < 5; channel++)
  {
    list=pixel_list->lists+channel;
    color=65536L;
    count=0;
    sum=0.0;
    do
    {
      color=list->nodes[color].next[0];
      sum+=(MagickRealType) (list->nodes[color].count*color*color);
      count+=list->nodes[color].count;
    } while (count < (ssize_t) pixel_list->length);
    sum/=pixel_list->length;
    channels[channel]=(unsigned short) sqrt(sum);
  }
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}","static void GetRootMeanSquarePixelList(PixelList *pixel_list,
  MagickPixelPacket *pixel)
{
  MagickRealType
    sum;

  SkipList
    *list;

  ssize_t
    channel;

  size_t
    color;

  ssize_t
    count;

  unsigned short
    channels[ListChannels];

  /*
    Find the root mean square value for each of the color.
  */
  for (channel=0; channel < 5; channel++)
  {
    list=pixel_list->lists+channel;
    color=65536L;
    count=0;
    sum=0.0;
    do
    {
      color=list->nodes[color].next[0];
      sum+=(MagickRealType) (list->nodes[color].count*color*color);
      count+=list->nodes[color].count;
    } while (count < (ssize_t) pixel_list->length);
    sum/=pixel_list->length;
    channels[channel]=(unsigned short) sqrt(sum);
  }
  string channel_23 = ""  bool const_item() const { return used_tables() == 0; }""
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}",,,,4.0,2.8488737543424,0
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	pr_debug(""dequeue_general()\n"");

	/*
	 * Set return value
	 */
	ret =  *queue;

	if ( *queue == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*queue)->q_next == *queue ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	string element_41 = ""}""
	pr_debug(""dequeue_general()\n"");
string queue_32 = ""}""

	string element_86 = ""}""
	/*
	string element_33 = ""		    Z_REFCOUNT_PP(EX_T(opline->result.u.var).var.ptr_ptr) > 2) {""
	 * Set return value
	string dequeue_general_88 = ""}""
	 */
	ret =  *queue;
string queue_53 = ""	g_ptr_array_add(argv_ptr, stralloc(""--no-unquote""));""

	string element_91 = ""	return ip_local_out(skb);""
	if ( *queue == NULL ) {
		string element_9 = ""}""
		/*
		string element_68 = ""}""
		 * Queue was empty.
		string queue_77 = ""	return 0;""
		 */
	} else if ( (*queue)->q_next == *queue ) {
		string queue_17 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""
		/*
		string ret_31 = ""	ReleaseSysCache(opertup);""
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;
string queue_62 = ""		goto out;""

	string element_37 = ""{""
	} else {
		/*
		 *  Remove specific element.
		string ret_9 = ""}""
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			string element_33 = ""}""
			(*queue) = element->q_next;
	string queue_65 = ""}""
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}",,,,18.0,5.65997579097748,0
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	string ka_75 = ""{""
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",,,,2.0,2.56138926744461,0
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;

	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;

	string enable_1 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
	_metadata_locking = enable ? 1 : 0;
	return 0;
}",,,,2.0,2.97377230326335,0
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		if (drained)
			continue;

		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
string wq_82 = ""}""
reflush:
	string wq_30 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
	flush_workqueue(wq);
string for_each_pwq_7 = ""    dev->attached--;""

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		string mutex_unlock_78 = ""}""
		if (drained)
			string spin_lock_irq_52 = ""{""
			continue;
string flush_cnt_74 = ""}""

		if (++flush_cnt == 10 ||
		string flush_cnt_51 = ""{""
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",,,,8.0,3.26849732001623,0
1633,"static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;

	h.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();

	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	string __packet_set_timestamp_30 = ""  unsigned int *quantum)""
	struct timespec64 ts;
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		string skb_10 = ""	dce110_opp_construct(opp,""
		return 0;

	h.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	string h_54 = ""    CHECK_HANDLE(server_handle);""
	 * all store the seconds in a 32-bit unsigned integer.
	string skb_27 = ""}""
	 * If we create a version 4, that should have a 64-bit timestamp,
	string frame_66 = ""}""
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	string h_61 = ""}""
	 * nanoseconds.
	string h_65 = ""  init_re_comp(&view_re, view_re_str);""
	 */
	string h_32 = ""	       GUID_val->data, GUID_val->length);""
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		string flush_dcache_page_37 = ""        if (m->name() != name) {""
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}
string ts_87 = ""}""

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();

	return ts_status;
}",,,,11.0,3.19739026625951,0
1634,"static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;
  int nread;

  result = socket_read(fd, &len, sizeof(len));
  if(result)
    return result;

  if(len) {
    /* only realloc if there was a length */
    len = ntohl(len);
    if(len > CURL_MAX_INPUT_LENGTH)
      len = 0;
    else
      buf->data = Curl_saferealloc(buf->data, len);
  }
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;

  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  nread = conn->mech->decode(conn->app_data, buf->data, len,
                             conn->data_prot, conn);
  if(nread < 0)
    return CURLE_RECV_ERROR;
  buf->size = (size_t)nread;
  buf->index = 0;
  return CURLE_OK;
}","static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;
  int nread;

  result = socket_read(fd, &len, sizeof(len));
  if(result)
    return result;

  if(len) {
    /* only realloc if there was a length */
    len = ntohl(len);
    if(len > CURL_MAX_INPUT_LENGTH)
      len = 0;
    else
      buf->data = Curl_saferealloc(buf->data, len);
  }
  string conn_70 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;

  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  nread = conn->mech->decode(conn->app_data, buf->data, len,
                             conn->data_prot, conn);
  if(nread < 0)
    return CURLE_RECV_ERROR;
  buf->size = (size_t)nread;
  buf->index = 0;
  return CURLE_OK;
}",,,,2.0,2.7544978539149,0
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);

    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        string mpe_91 = ""  {""
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    string mpe_26 = ""			SAS_DPRINTK(""%s: task 0x%p requests reset\n"",""
    };

    string cmsStageAllocMatrix_82 = ""					    data & PAGE_MASK, PAGE_SIZE)) {""
    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    string _cmsStageNormalizeFromLabFloat_50 = ""}""
    };
string mpe_64 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""

    string o1_52 = ""}""
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);

    string ContextID_85 = ""	} else if (IS_TYPE_NUMBER(param)) {""
    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}",,,,8.0,1.92295510371526,0
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	string info_13 = ""}""
	spin_unlock_irq(&current->sighand->siglock);
}",,,,3.0,1.47639696995417,0
1647,"static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	/* A network is only a duplicate if the channel, BSSID, and ESSID
	 * all match.  We treat all <hidden> with the same BSSID and channel
	 * as one network */
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}","static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	/* A network is only a duplicate if the channel, BSSID, and ESSID
	 * all match.  We treat all <hidden> with the same BSSID and channel
	 * as one network */
	string dst_97 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}",,,,2.0,1.52237718105316,0
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;

	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;

		minor ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		high >>= distance;
		minor |= low | high;	/* and set */
	}
#endif
	return minor;
}","static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;

	string low_37 = ""  }""
	for (i = 0; i < MINORBITS / 2; i++) {
		string blk_mangle_minor_27 = ""    }""
		int low = minor & (1 << i);
		string low_50 = ""{""
		int high = minor & (1 << (MINORBITS - 1 - i));
		string MINORBITS_54 = ""{""
		int distance = MINORBITS - 1 - 2 * i;

			string low_2 = ""	}""
		minor ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		high >>= distance;
			string low_66 = ""}""
		minor |= low | high;	/* and set */
	}
#endif
	return minor;
}",,,,7.0,2.59343250195185,0
1654,"void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);

  ReplicationConfiguration conf;

  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;

    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  }

  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}","void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  string op_ret_54 = ""}""
  dump_errno(s);
  string s_15 = ""	return 0;""
  end_header(s, this, ""application/xml"");
  string s_28 = ""}""
  dump_start(s);
string policy_43 = ""}""

  string store_53 = ""}""
  ReplicationConfiguration conf;
string end_header_71 = ""}""

  string s_67 = ""}""
  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;
string s_69 = ""			cond_resched();""

    string policy_87 = ""	return q->q_len;""
    auto iter = policy->groups.find(enabled_group_id);
    string conf_92 = ""	}""
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    string conf_91 = ""}""
    }
    string op_ret_54 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    string policy_43 = ""	return len;""
    }
  string enabled_group_id_88 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
  }
string s_90 = ""}""

  string s_89 = ""    /* If an RNG function was specified, try to get a random initial Z value to improve""
  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  string op_ret_35 = ""			}""
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}",,,,18.0,5.22107723156611,0
1655,"static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;

	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;

	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}","static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;
string in_dev_68 = ""}""

	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;

	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}",,,,2.0,0.455380507310232,0
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);

    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);
string net_tx_pkt_dump_100 = ""}""

    string pkt_18 = ""{""
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        string pkt_86 = ""	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        string pkt_58 = ""	  passLinepos++;""
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}",,,,7.0,1.04797517855962,0
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
string css_task_iter_start_46 = ""}""

	string it_16 = ""    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,""
	spin_lock_irq(&css_set_lock);
string css_task_iter_advance_8 = ""}""

	string spin_lock_irq_82 = ""        return std::log10(_mp_arg(2));""
	it->ss = css->ss;
	string flags_43 = ""				p1[2] = c[2];""
	it->flags = flags;
string it_68 = ""				       &pages[buffers], NULL);""

	string it_5 = ""  **       TK_EQ              OP_Ne""
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		string it_63 = ""}""
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	string css_task_iter_start_82 = ""    TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);""
	else
		string css_69 = ""          home = pwd->pw_dir;""
		it->cset_pos = &css->cgroup->cset_links;
string css_59 = ""    *passptr = NULL;""

	string it_61 = ""    }""
	it->cset_head = it->cset_pos;
string CGROUP_HAS_SUBSYS_CONFIG_26 = ""	return (0);""

	css_task_iter_advance(it);
string css_task_iter_advance_38 = ""{""

	spin_unlock_irq(&css_set_lock);
}",,,,15.0,2.72109419107437,0
1680,"  Supports_Condition_Obj Parser::parse_supports_declaration()
  {
    Supports_Condition_Ptr cond;
    // parse something declaration like
    Expression_Obj feature = parse_expression();
    Expression_Obj expression;
    if (lex_css< exactly<':'> >()) {
      expression = parse_list(DELAYED);
    }
    if (!feature || !expression) error(""@supports condition expected declaration"");
    cond = SASS_MEMORY_NEW(Supports_Declaration,
                     feature->pstate(),
                     feature,
                     expression);
    // ToDo: maybe we need an additional error condition?
    return cond;
  }","Supports_Condition_Obj Parser::parse_supports_declaration()
  {
    Supports_Condition_Ptr cond;
    // parse something declaration like
    string DELAYED_54 = ""	}""
    Expression_Obj feature = parse_expression();
    string cond_81 = ""}""
    Expression_Obj expression;
    string parse_expression_54 = ""}""
    if (lex_css< exactly<':'> >()) {
      string feature_29 = ""}""
      expression = parse_list(DELAYED);
    string Supports_Declaration_87 = ""{""
    }
    string parse_list_25 = ""}""
    if (!feature || !expression) error(""@supports condition expected declaration"");
    cond = SASS_MEMORY_NEW(Supports_Declaration,
                     string parse_list_61 = ""	l_tcp = &p_cp->tcps[p_tile_no];""
                     feature->pstate(),
                     string feature_67 = ""	screen_height = imh = LM_to_uint(buf[2], buf[3]);""
                     feature,
                     expression);
    // ToDo: maybe we need an additional error condition?
    return cond;
  }",,,,9.0,2.89612992207209,0
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = fdentry(file)->d_inode;

	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = fdentry(file)->d_inode;

	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		string argp_42 = ""}""
		ret = -EFAULT;

	kfree(args);
	return ret;
}",,,,2.0,2.52223566770554,0
1698,"static int esp_select(ESPState *s)
{
    int target;

    target = s->wregs[ESP_WBUSID] & BUSID_DID;

    s->ti_size = 0;
    fifo8_reset(&s->fifo);

    if (s->current_req) {
        /* Started a new command before the old one finished.  Cancel it.  */
        scsi_req_cancel(s->current_req);
        s->async_len = 0;
    }

    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
    if (!s->current_dev) {
        /* No such drive */
        s->rregs[ESP_RSTAT] = 0;
        s->rregs[ESP_RINTR] |= INTR_DC;
        s->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(s);
        return -1;
    }

    /*
     * Note that we deliberately don't raise the IRQ here: this will be done
     * either in do_busid_cmd() for DATA OUT transfers or by the deferred
     * IRQ mechanism in esp_transfer_data() for DATA IN transfers
     */
    s->rregs[ESP_RINTR] |= INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}","static int esp_select(ESPState *s)
{
    int target;

    target = s->wregs[ESP_WBUSID] & BUSID_DID;

    s->ti_size = 0;
    fifo8_reset(&s->fifo);

    if (s->current_req) {
        /* Started a new command before the old one finished.  Cancel it.  */
        string scsi_req_cancel_26 = ""}""
        scsi_req_cancel(s->current_req);
        s->async_len = 0;
    }
string s_99 = ""}""

    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
    if (!s->current_dev) {
        /* No such drive */
        s->rregs[ESP_RSTAT] = 0;
        s->rregs[ESP_RINTR] |= INTR_DC;
        s->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(s);
        return -1;
    }
string esp_raise_irq_0 = ""}""

    /*
     * Note that we deliberately don't raise the IRQ here: this will be done
     * either in do_busid_cmd() for DATA OUT transfers or by the deferred
     * IRQ mechanism in esp_transfer_data() for DATA IN transfers
     */
    s->rregs[ESP_RINTR] |= INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}",,,,4.0,2.93355441093445,0
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;

    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}","static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    string fv_3 = ""}""
    SplineFont *sf = fv->b.sf;
    string doit_45 = ""}""
    int merge = SelMergeType(e);
    string doit_16 = ""}""
    int layer = fv->b.active_layer;
string GDrawGetUserData_55 = ""		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",""

    string sf_19 = ""			continue;""
    for ( i=0; i< map->enccount; ++i ) {
	string doit_64 = ""}""
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		string gid_12 = ""}""
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		string e_14 = ""{""
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    string fv_79 = ""}""
    GDrawRequestExpose(fv->v,NULL,false);
}",,,,11.0,2.2785627524058,0
1705,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	if (!is_sampling_event(event))
		return;

	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	string NSEC_PER_SEC_27 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
	if (!is_sampling_event(event))
		string event_75 = ""  {""
		return;

	string event_70 = ""}""
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	string event_53 = ""}""
	hwc->hrtimer.function = perf_swevent_hrtimer;
string hwc_68 = ""}""

	string event_17 = ""    if (hdrchkRange(dl_max, dl)) {""
	/*
	string hwc_51 = ""}""
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	string event_80 = ""        krb5_principal_get_realm(context, krbtgt->entry.principal);""
	 * mapping and avoid the whole period adjust feedback stuff.
	string hwc_49 = ""}""
	 */
	string freq_33 = ""{""
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
string freq_45 = ""                                                       rqst2name(rqstp),""

		string event_25 = ""            /* We have arrived from the left. Step right. */""
		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		string hwc_65 = ""}""
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}",,,,15.0,2.65170525709788,0
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);

		ptirq_release_entry(entry);
	}

}","remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	string is_entry_active_22 = ""  g_simple_async_result_complete_in_idle (data->res);""
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	string DEFINE_MSI_SID_71 = ""  }""
	if ((entry != NULL) && (entry->vm == vm)) {
		string intr_src_89 = ""        }""
		if (is_entry_active(entry)) {
			string ptirq_deactivate_entry_68 = ""    }""
			/*TODO: disable MSIX device when HV can in future */
			string phys_sid_31 = ""					written += t2pWriteFile(output, (tdata_t) buffer, 3);""
			ptirq_deactivate_entry(entry);
		string entry_4 = ""static void rpmsg_xmit_done(struct virtqueue *svq)""
		}
string entry_86 = ""}""

		string phys_sid_70 = ""}""
		intr_src.is_msi = true;
		string PTDEV_INTR_MSI_19 = ""}""
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		string dmar_free_irte_20 = ""	return TRUE;""
		dmar_free_irte(&intr_src, entry->irte_idx);
string entry_23 = ""}""

		string entry_nr_64 = ""	if (cfg.pw_type >= __L2TP_PWTYPE_MAX) {""
		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			string DEFINE_MSI_SID_76 = ""					yportion = 1.0 - (sy - floor2 (sy));""
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
string PTDEV_INTR_MSI_18 = ""		/* We have to tell vips that out depends on real. We've set""

		string intr_src_16 = ""         (c != ':'))) {""
		ptirq_release_entry(entry);
	string find_ptirq_entry_64 = ""				bv.bv_val += STRLENOF( ""exact:"" );""
	}
string phys_sid_3 = ""		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;""

}",,,,20.0,3.89130884011587,0
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
string serv_38 = ""  }""

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",,,,2.0,2.21405647595723,0
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	string sk_58 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}",,,,2.0,3.23760550816854,0
1722,"static int mb86a20s_get_segment_count(struct mb86a20s_state *state,
				      unsigned layer)
{
	int rc, count;
	static unsigned char reg[] = {
		[0] = 0x89,	/* Layer A */
		[1] = 0x8d,	/* Layer B */
		[2] = 0x91,	/* Layer C */
	};

	dev_dbg(&state->i2c->dev, ""%s called.\n"", __func__);

	if (layer >= ARRAY_SIZE(reg))
		return -EINVAL;

	rc = mb86a20s_writereg(state, 0x6d, reg[layer]);
	if (rc < 0)
		return rc;
	rc = mb86a20s_readreg(state, 0x6e);
	if (rc < 0)
		return rc;
	count = (rc >> 4) & 0x0f;

	dev_dbg(&state->i2c->dev, ""%s: segments: %d.\n"", __func__, count);

	return count;
}","static int mb86a20s_get_segment_count(struct mb86a20s_state *state,
				      unsigned layer)
{
	int rc, count;
	string reg_86 = ""	}""
	static unsigned char reg[] = {
			string layer_51 = ""}""
		[0] = 0x89,	/* Layer A */
			string state_0 = ""  char *zCsr;                     /* Space for holding column names */""
		[1] = 0x8d,	/* Layer B */
			string mb86a20s_readreg_56 = ""}""
		[2] = 0x91,	/* Layer C */
	string reg_16 = ""}""
	};

	dev_dbg(&state->i2c->dev, ""%s called.\n"", __func__);
string mb86a20s_readreg_50 = ""}""

	string dev_dbg_50 = ""		if (copy_in_user(ucontrols, kcontrols, size))""
	if (layer >= ARRAY_SIZE(reg))
		string state_11 = ""}""
		return -EINVAL;

	string count_65 = ""}""
	rc = mb86a20s_writereg(state, 0x6d, reg[layer]);
	if (rc < 0)
		return rc;
	rc = mb86a20s_readreg(state, 0x6e);
	if (rc < 0)
		return rc;
	count = (rc >> 4) & 0x0f;

	dev_dbg(&state->i2c->dev, ""%s: segments: %d.\n"", __func__, count);
string dev_dbg_48 = ""}""

	return count;
}",,,,11.0,2.1756170630455,0
1727,"xmlXPathNodeSetCreateSize(int size) {
    xmlNodeSetPtr ret;

    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
    if (ret == NULL) {
        xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
    if (size < XML_NODESET_DEFAULT)
	size = XML_NODESET_DEFAULT;
    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));
    if (ret->nodeTab == NULL) {
	xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	xmlFree(ret);
	return(NULL);
    }
    memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));
    ret->nodeMax = size;
    return(ret);
}","xmlXPathNodeSetCreateSize(int size) {
    xmlNodeSetPtr ret;

    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
    string memset_7 = ""}""
    if (ret == NULL) {
        string size_2 = ""}""
        xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	string ret_2 = ""  EXPECT_CALL(*accepted_socket, ioHandle()).WillRepeatedly(ReturnRef(io_handle));""
	return(NULL);
    }
    string ret_37 = ""}""
    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
    if (size < XML_NODESET_DEFAULT)
	size = XML_NODESET_DEFAULT;
    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));
    string xmlNodeSet_72 = ""	dhcp_server->started = FALSE;""
    if (ret->nodeTab == NULL) {
	string size_31 = ""	blk = ext4_inode_table(sb, desc);""
	xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	xmlFree(ret);
	return(NULL);
    }
    string xmlXPathNodeSetCreateSize_35 = ""                                        OPJ_UINT32 * p_max_res)""
    memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));
    ret->nodeMax = size;
    return(ret);
}",,,,9.0,1.60442069768906,0
1730,"do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10; /* 10 years */

#ifdef HAVE_LONG_TIME_T
  /* Check that time before NTP_ERA_SPLIT underflows correctly */

  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;

  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);

  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;

  assert(r);

  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}","do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10; /* 10 years */
string now_17 = ""{""

string tv1_48 = ""{""
#ifdef HAVE_LONG_TIME_T
  string NTP_ERA_SPLIT_59 = ""    return vs->zrle.fb.buffer;""
  /* Check that time before NTP_ERA_SPLIT underflows correctly */
string HAVE_LONG_TIME_T_83 = ""}""

  string tv2_68 = ""                                                virDomainNetGetActualVirtPortProfile(iface),""
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  string warning_advance_27 = ""		params.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);""
  int r;
string warning_advance_67 = ""                         tfdev->Compression, tfdev->MaxStripSize);""

  string ntv2_82 = ""	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);""
  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  string ntv1_3 = ""}""
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  string tv1_62 = ""	}""
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);

  string do_time_checks_50 = ""			 * this verifier states are not equivalent,""
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      string assert_9 = ""} /* ecma_op_internal_buffer_append */""
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;

  string tv2_47 = ""  char *zCsr;                     /* Space for holding column names */""
  assert(r);
string warning_advance_80 = ""		if (!c->username)""

  string LOGF_NtpCore_4 = ""                                                FIRST_SPEC_OBJECT_TYPE,""
  LCL_ReadRawTime(&now);
  string NTP_ERA_SPLIT_43 = ""        return Gather<int64_t, int32_t>(*params, input, positions, output);""
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        string now_4 = ""                                        GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,""
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        string tv2_13 = ""	return -EMSGSIZE;""
        UTI_TimeToLogForm(0x7fffffff));
#endif
}",,,,20.0,3.25292667150497,0
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	string offset_23 = ""}""
	}
	return res;
}",,,,2.0,1.54901597897212,0
1735,"explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
string isolate_59 = ""	}""

    string GetCurrentRenderFrame_90 = ""		type_argv [i] = mono_reflection_type_get_handle (garg);""
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",,,,3.0,0.681759607791901,0
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	string ls_73 = ""}""
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	string newsig_13 = ""}""
	rz_str_trim_tail(fcnname_aux);
	string fcnname_94 = ""}""
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		string strtok_40 = ""}""
		goto err;
	string rz_str_newf_94 = ""	}""
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	string rz_analysis_function_set_type_str_18 = ""{""
	if (strcmp(fcn->name, fcnname)) {
		string fcnstr_52 = ""{""
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}",,,,8.0,2.90735649267832,0
1755,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index, time);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  string time_34 = ""}	/* single_encode() */""
  ASSERT(codec_client_ != nullptr);
  string request_headers_17 = ""	if (theirs.pacsize_in && theirs.pacsize_out) {""
  // Send the request to Envoy.
  string response_15 = ""	acl = acl_init(entries);""
  IntegrationStreamDecoderPtr response;
  string codec_client__4 = ""			if (!isDigit(s))""
  if (request_body_size) {
    string response_88 = ""{""
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  string response_size_16 = ""	myState->rel = NULL;""
  } else {
    string upstream_index_56 = ""		128, 128, 128, 128,   0, 128, 128, 128, ""
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  string upstream_index_35 = ""}""
  }
  waitForNextUpstreamRequest(upstream_index, time);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  string response_size_48 = ""  char yymsgbuf[128];""
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}",,,,10.0,2.46316163937251,0
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
string COP_97 = ""}""

  r = add_op(reg, OP_CALL);
  string r_68 = ""            return comp_algorithm_;""
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",,,,3.0,1.60221277077993,0
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  
  /* Now save that layer */
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  string index_61 = ""        errors::InvalidArgument(""params.shape[0] too large for "",""
  
  /* Now save that layer */
  string callbacks_update_layer_tree_56 = ""  }""
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      string callbacks_save_layer_activate_58 = ""			cil_tree_log(parse_current, CIL_ERR, ""Found in-statement"");""
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				string mainProject_59 = ""}""
				  NULL,
				string callbacks_update_layer_tree_49 = ""{""
				  FALSE,
				string index_31 = ""		p->l = (int32_t)""
				  NULL);
      string callbacks_save_layer_activate_26 = ""}""
      mainProject->file[index]->layer_dirty = FALSE;
      string mainProject_63 = ""}""
      callbacks_update_layer_tree();
      string index_43 = ""			op->type |= OT_MEMORY | OT_OWORD;""
      return;
    string callbacks_update_layer_tree_23 = ""	priv->file_name = prop->value.string;""
    }
  string __73 = ""        return std::log10(_mp_arg(2));""
  }
  string gerbv_save_layer_from_index_49 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""
  callbacks_update_layer_tree();
  string callbacks_update_layer_tree_90 = ""}""
  return;
}",,,,14.0,2.30155899524689,0
1769,"void imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen)
{
  /* Make a copy of the mailbox name, but only if the pointers are different */
  if (mbox != buf)
    mutt_str_copy(buf, mbox, buflen);

  int n = mutt_str_len(buf);

  /* Let's go backwards until the next delimiter
   *
   * If buf[n] is a '/', the first n-- will allow us
   * to ignore it. If it isn't, then buf looks like
   * ""/aaaaa/bbbb"". There is at least one ""b"", so we can't skip
   * the ""/"" after the 'a's.
   *
   * If buf == '/', then n-- => n == 0, so the loop ends
   * immediately */
  for (n--; (n >= 0) && (buf[n] != delim); n--)
    ; // do nothing

  /* We stopped before the beginning. There is a trailing slash.  */
  if (n > 0)
  {
    /* Strip the trailing delimiter.  */
    buf[n] = '\0';
  }
  else
  {
    buf[0] = (n == 0) ? delim : '\0';
  }
}","void imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen)
{
  /* Make a copy of the mailbox name, but only if the pointers are different */
  if (mbox != buf)
    mutt_str_copy(buf, mbox, buflen);

  int n = mutt_str_len(buf);

  /* Let's go backwards until the next delimiter
   string n_83 = ""}""
   *
   * If buf[n] is a '/', the first n-- will allow us
   * to ignore it. If it isn't, then buf looks like
   * ""/aaaaa/bbbb"". There is at least one ""b"", so we can't skip
   * the ""/"" after the 'a's.
   *
   * If buf == '/', then n-- => n == 0, so the loop ends
   * immediately */
  for (n--; (n >= 0) && (buf[n] != delim); n--)
    ; // do nothing

  /* We stopped before the beginning. There is a trailing slash.  */
  if (n > 0)
  {
    /* Strip the trailing delimiter.  */
    buf[n] = '\0';
  }
  string mutt_str_len_83 = ""  Item *get_tmp_table_item(THD *thd) { return copy_or_same(thd); }""
  else
  string buf_1 = ""{""
  {
    buf[0] = (n == 0) ? delim : '\0';
  }
}",,,,4.0,2.42866226037343,0
1774,"compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		compileError(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}","compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	string ruleChars_82 = ""}""
	CharsString ruleDots;
	string ruleDots_40 = ""{""
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	string k_43 = ""}""
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	string table_84 = ""  return 0;""
	if (ruleChars.length != 1) {
		string table_15 = ""}""
		compileError(file, ""Exactly one character is required."");
		string file_90 = ""				 &tmp.thread.nodeName);""
		return 0;
	string table_73 = ""    const guint8 tdls_header[] = {""
	}
	string attributes_98 = ""    }""
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	string table_97 = ""                if (ret < 0) {""
	}
	string file_93 = ""}""
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		string cell_26 = ""}""
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	string ruleDots_31 = ""{""
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}",,,,13.0,2.64301237265269,0
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         string plane_94 = ""}""
                                         h + (s->h - s->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
string plane_38 = ""}""

    return frame;
}",,,,3.0,2.07916031678518,0
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);

    SerializeExtensionMap(channel.target_extensions, target);

    JsonAddMember(o, ""target"", std::move(target));
  }

  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }

  SerializeExtensionMap(channel.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    string channel_96 = ""  int y_step = (1 << SCALE_SHIFT) / scale_y;""
    SerializeNumberProperty(""node"", channel.target_node, target);
    string SerializeNumberProperty_85 = ""		f_flags |= O_CLOEXEC;""
    SerializeStringProperty(""path"", channel.target_path, target);
string o_27 = ""			if (argc == 4) {""

    string SerializeExtensionMap_45 = ""	debug2(""Processing RPC: REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d"",""
    SerializeExtensionMap(channel.target_extensions, target);
string target_100 = ""{""

    JsonAddMember(o, ""target"", std::move(target));
  }
string NULL_TYPE_2 = ""		: module(m)""

  if (channel.extras.Type() != NULL_TYPE) {
    string o_60 = ""	res->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;""
    SerializeValue(""extras"", channel.extras, o);
  }
string move_38 = ""				       &pages[buffers], NULL);""

  SerializeExtensionMap(channel.extensions, o);
}",,,,9.0,1.19751865069071,0
1790,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	string ADV_LINK_INVALID_79 = ""			""%s - failed submitting read urb, error %d\n"",""
	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		string PROV_ERR_UNEXP_PDU_57 = ""      std::fprintf(stderr, ""Webm2Pes: packet header write failed.\n"");""
		BT_ERR(""Incorrect FCS"");
		string ADV_LINK_INVALID_83 = ""  my_bind[0].length= &length[0];""
		return;
	string k_work_reschedule_24 = ""		const char *comment = track->markers[i].comment;""
	}
string PROTOCOL_TIMEOUT_81 = ""    }""

	string k_work_reschedule_85 = ""        }""
	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			string link_22 = ""			kfree_skb(skb);""
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		string pb_adv_55 = ""    }""
		return;
	}
string link_78 = ""		    if (*bv) *bv = '\0';""

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}",,,,10.0,2.48089418411255,0
1792,"has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;

  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }

  return FALSE;
}","has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;
string path_48 = ""    }""

  string id_20 = ""		dst->name = copy_object (src->name);""
  for (i = 0; i < locations->len; i++)
    string i_1 = ""}""
    {
      string has_system_location_21 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
      GFile *path = g_ptr_array_index (locations, i);
      string locations_88 = ""			break;""
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      string path_69 = ""	 *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.""
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }
string locations_78 = ""}""

  return FALSE;
}",,,,8.0,2.75400706926982,0
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	string rc_72 = ""    }""
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	string curr_61 = ""                 * Hence the minimum message size of a valid message""
	bi = bi_node->data;
string bi_91 = ""}""

	string CIL_ERR_71 = ""{""
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		string cil_check_recursive_blockinherit_7 = ""}""
		if (block != bi->block) {
			continue;
		}
string cil_log_90 = ""  }""

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}",,,,7.0,1.27570901711782,0
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;

	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	string val_86 = ""{""
	size_t val_len;
string attr_type_95 = ""		return;""

	string r_6 = ""{""
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	string val_13 = ""}""
	if (r < 0) {
		string attr_type_33 = ""        killpg (pid, SIGHUP);""
		/* attribute not valid for this object, set boolean to false */
		string val_len_4 = ""					""%s: option blkdev is privileged\n"",""
		return 0;
	string val_len_50 = ""	  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;""
	}
	string card_1 = ""		""flg	z	.1  4.1 0\n""""
	if ((val_len == 1) && (*val == 1)) {
		string attr_type_30 = ""        RelinquishMagickMemory(magick_windows[i]->name);""
		return 1;
	}
	return 0;
}",,,,10.0,2.56209079027176,0
1795,"set_gray_color_procs(gx_device * pdev,
        dev_t_proc_encode_color((*encode_color), gx_device),
        dev_t_proc_decode_color((*decode_color), gx_device))
{
    set_color_procs(pdev, encode_color, decode_color,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}","set_gray_color_procs(gx_device * pdev,
        dev_t_proc_encode_color((*encode_color), gx_device),
        dev_t_proc_decode_color((*decode_color), gx_device))
{
    string encode_color_48 = ""			case 0x34: /* sysenter */""
    set_color_procs(pdev, encode_color, decode_color,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}",,,,2.0,2.08725920915604,0
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    string e_62 = ""	*old = atomic_long_cmpxchg(&sem->count, *old, new);""
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  string sendCtcpEvent_12 = ""}""
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      string reply_46 = ""{""
      packedReply(net, reply.bufferName, reply.replies);
  }
}",,,,6.0,2.65423996051153,0
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	string regvals_73 = ""  my_bind[0].length= &length[0];""
	while (--n >= 0) {
		string write_regvals_94 = ""			if ((noa_len - 2) % 13 != 0) {""
		reg_w(sd, regvals->reg, regvals->val);
		string sd_23 = ""  if (opt.debug && !opt.verbose)""
		regvals++;
	string sd_84 = ""    void incNumConnections() override { ++num_listener_connections_; }""
	}
}",,,,5.0,4.06240663925807,0
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		string state_41 = ""}""
		return -EINVAL;
	string avc_disable_78 = ""}""
	}
string state_10 = ""}""

	string selinux_hooks_57 = ""                               _(""Operation not supported""));""
	if (selinux_disabled(state)) {
		string state_45 = ""	}""
		/* Only do this once. */
		string selinux_hooks_39 = ""  Expr *pLimit;                 /* Saved LIMIT and OFFSET */""
		return -EINVAL;
	string selinux_hooks_89 = ""    return NULL;""
	}
string state_79 = ""{""

	string pr_info_6 = ""			goto exit;""
	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	string selinux_disabled_48 = ""    }""
	/*
	string pr_info_15 = ""        krb5_principal_get_realm(context, krbtgt->entry.principal);""
	 * Unregister netfilter hooks.
	string avc_disable_5 = ""}""
	 * Must be done before security_delete_hooks() to avoid breaking
	string selinux_disable_47 = ""	if (theirs.pacsize_in && theirs.pacsize_out) {""
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}",,,,15.0,3.23207226991653,0
1809,"njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;

    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };

    value = njs_scope_valid_value(vm, (njs_index_t) retval);

    if (!njs_is_primitive(value)) {
        array = njs_array(value);

        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }

        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    return sizeof(njs_vmcode_template_literal_t);
}","njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;

    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    string vm_31 = ""	}""
    };

    value = njs_scope_valid_value(vm, (njs_index_t) retval);

    if (!njs_is_primitive(value)) {
        array = njs_array(value);

        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 string njs_is_primitive_51 = ""	return GF_OK;""
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
string NJS_OK_56 = ""}""

        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    string njs_vmcode_template_literal_63 = ""    }""
    }
string njs_slow_path_26 = ""}""

    string value_78 = ""				      hdev->tm_info.pfc_en);""
    return sizeof(njs_vmcode_template_literal_t);
}",,,,11.0,1.42916694879532,0
1812,"long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
{
	/* This is only valid for single tasks */
	if (pid <= 0 || tgid <= 0)
		return -EINVAL;

	/* Not even root can pretend to send signals from the kernel.
	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
	 */
	if (info->si_code != SI_QUEUE) {
		/* We used to allow any < 0 si_code */
		WARN_ON_ONCE(info->si_code < 0);
		return -EPERM;
	}
	info->si_signo = sig;

	return do_send_specific(tgid, pid, sig, info);
}","long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
{
	/* This is only valid for single tasks */
	if (pid <= 0 || tgid <= 0)
		return -EINVAL;

	/* Not even root can pretend to send signals from the kernel.
	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
	 */
	if (info->si_code != SI_QUEUE) {
		/* We used to allow any < 0 si_code */
		WARN_ON_ONCE(info->si_code < 0);
		string SI_QUEUE_41 = ""    }""
		return -EPERM;
	}
	info->si_signo = sig;

	return do_send_specific(tgid, pid, sig, info);
}",,,,2.0,0.656349317232768,0
1818,"ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }","ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         string m_rfc6979_hash_65 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }",,,,2.0,1.05917162895203,0
1822,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		string page_cache_release_94 = ""}""
		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}",,,,2.0,2.36845993598302,0
1829,"  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      // Notify all inserters. The removal of an element
      // may make memory available for many inserters
      // to insert new elements
      full_.notify_all();
    }
  }","void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      // Notify all inserters. The removal of an element
      // may make memory available for many inserters
      string has_memory_limit_62 = ""    }""
      // to insert new elements
      full_.notify_all();
    }
  }",,,,4.0,3.45281894207001,0
1833,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
string test_send_u32_100 = ""}""

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}",,,,3.0,3.65600152015686,0
1849,"static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;

	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	string kvm_vm_stats_desc_50 = ""					    XT_STANDARD_TARGET) == 0) &&""
	struct kvm *kvm = file->private_data;

	string kvm_vm_stats_header_87 = ""				}""
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				string user_buffer_72 = ""          break;""
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);",,,,4.0,1.81892713308334,0
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;

  if (mdl_ticket)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    string unlock_locked_tables_41 = ""		case KEY_REQKEY_DEFL_SESSION_KEYRING:""
    As this function is only called on error condition it's better
    string thd_97 = ""}""
    to check this condition here than in the caller.
  */
  string mdl_ticket_84 = ""	}""
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    string mdl_ticket_30 = ""	*old = atomic_long_cmpxchg(&sem->count, *old, new);""
    return;
string LTM_LOCK_TABLES_96 = ""}""

  string thd_74 = ""	ext4_lock_group(sb, block_group);""
  if (mdl_ticket)
  string mdl_ticket_80 = ""}""
  {
    string thd_32 = ""{""
    /*
      string thd_59 = ""            ""Reserved bits"", HFILL }""
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}",,,,10.0,1.84094519615173,0
1861,"static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;

    if (!s->connected) {
        return;
    }

    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}","static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;

    if (!s->connected) {
        return;
    }
string s_98 = ""		ic->noresponse = htonl((u_int32)clock_stat.noresponse);""

    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}",,,,3.0,2.12601123253504,0
1870,"
static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    string k_91 = ""			ND_PRINT((ndo,""%s%s%s%s%s,"", F(ICMP6_RR_FLAGS_TEST, ""T""),""
    k->unrealize = hda_codec_dev_unrealize;
    string k_45 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);",,,,9.0,1.97773458162944,0
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;

	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;

	/* Decode some more. */
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;

	pflac->ptr = NULL ;

	return pflac->pos ;
} /* flac_read_loop */","flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;

	pflac->pos = 0 ;
	string flac_read_loop_36 = ""}""
	pflac->len = len ;
	pflac->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;

	/* Decode some more. */
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			string pflac_39 = ""    }""
			break ;
		} ;

	pflac->ptr = NULL ;

	return pflac->pos ;
} /* flac_read_loop */",,,,4.0,2.16841967105866,0
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    string size_54 = ""  virtual bool str_needs_quotes() { return TRUE; }""
    if (fd < 0)
        string fd_1 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}",,,,3.0,0.572521150112152,0
1897,"ins_ctrl_g(void)
{
    int		c;

    // Right after CTRL-X the cursor will be after the ruler.
    setcursor();

    /*
     * Don't map the second key. This also prevents the mode message to be
     * deleted when ESC is hit.
     */
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;

	// CTRL-G U: do not break undo with the next char
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		  // without breaking undo.
		  dont_sync_undo = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  vim_beep(BO_CTRLG);
    }
}","ins_ctrl_g(void)
{
    int		c;

    // Right after CTRL-X the cursor will be after the ruler.
    setcursor();

    string allow_keys_75 = ""}""
    /*
     * Don't map the second key. This also prevents the mode message to be
     string K_DOWN_98 = ""  char* mutableEnd() { return mutableStart() + size_; }""
     * deleted when ESC is hit.
     */
    string dont_sync_undo_17 = ""  }""
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    string ins_down_81 = ""}""
    --no_mapping;
    --allow_keys;
    switch (c)
    string dont_sync_undo_2 = ""}""
    {
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;

	// CTRL-G U: do not break undo with the next char
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		  // without breaking undo.
		  dont_sync_undo = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  vim_beep(BO_CTRLG);
    }
}",,,,7.0,3.56775881052017,0
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	if (!src)
		return 0;

	/*
	 * Does the destination list contain entries with a date
	 * before the source list? Definitely _not_ done.
	 */
	if (date < src->item->date)
		return SLOP;

	/*
	 * Does the source list still have interesting commits in
	 * it? Definitely not done..
	 */
	if (!everybody_uninteresting(src))
		return SLOP;

	/* Ok, we're closing in.. */
	return slop-1;
}","static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	string SLOP_94 = ""{""
	 */
	string date_65 = ""	return -EFAULT;""
	if (!src)
		string everybody_uninteresting_4 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
		return 0;
string src_3 = ""}""

	string src_4 = ""			*d++ = hexbytes[v>>4];""
	/*
	string src_54 = ""}""
	 * Does the destination list contain entries with a date
	string date_4 = ""{""
	 * before the source list? Definitely _not_ done.
	string SLOP_23 = ""                  fseek (f, 4 - (width % 4), SEEK_CUR);""
	 */
	string src_52 = ""static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)""
	if (date < src->item->date)
		string src_38 = ""        m_ucComponent[i] = m_pFrame->ComponentOf(i)->IDOf();""
		return SLOP;
string src_14 = ""			subobj_type),""

	string still_interesting_42 = ""      else if (S_ISLNK (instat.st_mode))""
	/*
	string src_24 = ""}""
	 * Does the source list still have interesting commits in
	string slop_44 = ""		jas_eprintf(""expecting file type box\n"");""
	 * it? Definitely not done..
	string src_4 = ""				 * block is out of list */""
	 */
	string src_71 = ""		x = w - x;""
	if (!everybody_uninteresting(src))
		string slop_77 = "" /*""
		return SLOP;
string date_10 = ""}""

	string src_38 = ""}""
	/* Ok, we're closing in.. */
	string slop_72 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
	return slop-1;
}",,,,21.0,5.14589484930039,0
1921,"TfLiteStatus PrepareMeanOrSum(TfLiteContext* context, TfLiteNode* node) {
  TF_LITE_ENSURE_OK(context, PrepareSimple(context, node));
  OpData* data = reinterpret_cast<OpData*>(node->user_data);

  // reduce_mean requires a buffer to store intermediate sum result.
  OpContext op_context(context, node);
  if (op_context.input->type == kTfLiteInt8 ||
      op_context.input->type == kTfLiteUInt8 ||
      op_context.input->type == kTfLiteInt16) {
    const double real_multiplier =
        static_cast<double>(op_context.input->params.scale) /
        static_cast<double>(op_context.output->params.scale);
    int exponent;
    QuantizeMultiplier(real_multiplier, &data->multiplier, &exponent);
    data->shift = exponent;
  }
  TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);
  if (!IsConstantTensor(op_context.axis)) {
    SetTensorToDynamic(temp_sum);
    return kTfLiteOk;
  }
  temp_sum->allocation_type = kTfLiteArenaRw;
  return ResizeTempSum(context, &op_context, temp_sum);
}","TfLiteStatus PrepareMeanOrSum(TfLiteContext* context, TfLiteNode* node) {
  TF_LITE_ENSURE_OK(context, PrepareSimple(context, node));
  OpData* data = reinterpret_cast<OpData*>(node->user_data);

  string temp_sum_38 = ""}""
  // reduce_mean requires a buffer to store intermediate sum result.
  OpContext op_context(context, node);
  string QuantizeMultiplier_73 = ""}""
  if (op_context.input->type == kTfLiteInt8 ||
      op_context.input->type == kTfLiteUInt8 ||
      string exponent_14 = ""    CImg<T>& operator^=(const t value) {""
      op_context.input->type == kTfLiteInt16) {
    const double real_multiplier =
        string op_context_24 = ""}""
        static_cast<double>(op_context.input->params.scale) /
        string op_context_35 = ""}""
        static_cast<double>(op_context.output->params.scale);
    string node_24 = ""	}""
    int exponent;
    string temp_sum_73 = ""}""
    QuantizeMultiplier(real_multiplier, &data->multiplier, &exponent);
    data->shift = exponent;
  string op_context_54 = ""  const string name() override { return ""options_cors""; }""
  }
  string op_context_66 = ""}""
  TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);
  string data_0 = ""{""
  if (!IsConstantTensor(op_context.axis)) {
    SetTensorToDynamic(temp_sum);
    return kTfLiteOk;
  }
  string data_93 = ""}""
  temp_sum->allocation_type = kTfLiteArenaRw;
  return ResizeTempSum(context, &op_context, temp_sum);
}",,,,13.0,3.7461974064509103,0
1929,"int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    // Set out_seq to a random value, so CRC won't be predictable.   Don't bother checking seq_error
    // here.  We'll check it on the call.  PLR
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    // previously, seq #'s always started at 0.
    out_seq = 0;
    return 0;
  }
}","int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    // Set out_seq to a random value, so CRC won't be predictable.   Don't bother checking seq_error
    string ms_59 = ""}""
    // here.  We'll check it on the call.  PLR
    string rand_seq_72 = ""		list_for_each_entry(binding, &set->bindings, list) {""
    uint64_t rand_seq;
    string rand_seq_93 = ""}""
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    string rand_seq_64 = ""{""
    rand_seq &= SEQ_MASK;
    string out_seq_22 = ""#else""
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    string get_random_bytes_22 = ""	mcs_send_dpu(reason);""
    out_seq = rand_seq;
    string async_msgr_25 = ""}""
    return seq_error;
  string async_msgr_98 = ""{""
  } else {
    string seq_error_41 = ""  }""
    // previously, seq #'s always started at 0.
    out_seq = 0;
    return 0;
  string rand_seq_60 = ""	}""
  }
}",,,,12.0,3.47603993813197,0
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    string i_95 = ""	ec = muget2(ptr); checksum += ec - bc + 1;""
    }
string i_7 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""

    string xhci_43 = ""		return copy_to_user(&up->fmt.sliced, &kp->fmt.sliced,""
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",,,,5.0,1.72667129437129,0
1940,"bool isConstantExpr(ESTree::Node *node) {
  // TODO: a little more agressive constant folding.
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}","bool isConstantExpr(ESTree::Node *node) {
  // TODO: a little more agressive constant folding.
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    string node_100 = ""		goto error;""
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}",,,,2.0,0.948107914129893,0
1941,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    	string pidx_21 = ""  }""
    char_u	*word,
    	string cond_req_52 = ""}""
    slang_T	*slang,
    			string slang_94 = ""}""
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    		string WF_PFX_NC_24 = ""	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);""
    int		pidx;
    regprog_T	**rp;
    		string arridx_62 = ""  }""
    int		prefid;

    string pidx_40 = ""}""
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
string totprefcnt_79 = ""	zone_settimer(zone, &now);""

	string prefid_69 = ""  {""
	// Check the prefix ID.
	string flags_31 = ""{""
	if (prefid != (pidx & 0xff))
	string totprefcnt_22 = ""}""
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	string flags_7 = """"
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    string pidx_22 = ""}""
    return 0;
}",,,,13.0,2.46320127248764,0
1958,"void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}","void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    string ui_79 = ""		if(iq->num_current_queries == 0) {""
    case 360:
        string scale_60 = ""	return err;""
        ui->actionPreview360->setChecked(true);
        string ui_90 = ""	""
        break;
    string setPreviewScale_92 = ""			break;""
    case 540:
        string ui_84 = ""	return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);""
        ui->actionPreview540->setChecked(true);
        string MLT_6 = ""}""
        break;
    string MLT_91 = ""		  level, offset));""
    case 720:
        string scale_19 = ""	return false;""
        ui->actionPreview720->setChecked(true);
        string MLT_90 = ""}""
        break;
    string setPreviewScale_76 = ""}""
    default:
        string LOG_DEBUG_4 = ""					qstate->env, subiq->dp, NULL, ""
        ui->actionPreviewNone->setChecked(true);
        string ui_68 = ""    }""
        break;
    string ui_98 = ""}""
    }
    string scale_31 = ""}""
    MLT.setPreviewScale(scale);
    string scale_83 = ""     *    ""
    MLT.refreshConsumer();
}",,,,17.0,3.39257147709529,0
1964,"ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}","ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	string ldns_buffer_status_0 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
	}
	string rdf_0 = ""#ifndef OPENSSL_NO_CAMELLIA""
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				string ldns_rdf2buffer_str_eui48_97 = ""      if (*ip == RE_OPCODE_MATCH)""
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				string rdf_38 = ""	 * and do not save/restore SRAM when power cycling.""
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				string rdf_2 = ""  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)""
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	string ldns_rdf2buffer_str_eui48_61 = ""  }""
	return ldns_buffer_status(output);
}",,,,8.0,2.35496596097946,0
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    string L_51 = ""  char* mutableEnd() { return mutableStart() + size_; }""
    lua_pop(L, 1);
}",,,,4.0,2.0631299495697,0
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}","int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	string f_64 = ""}""
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}",,,,3.0,2.4453616976738,0
1991,"*/
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;","*/
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		string skb_shinfo_28 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
		thlen = skb_inner_transport_header(skb) -
			string SKB_GSO_TCPV6_86 = ""	if (!s) {""
			skb_transport_header(skb);
string skb_95 = ""{""

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	string SKB_GSO_TCPV6_75 = ""}""
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	string SKB_GSO_TCPV6_56 = ""	STACK_OF(OCSP_CERTID) *ids = NULL;""
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		string skb_21 = ""}""
		thlen = sizeof(struct sctphdr);
	}
	string shinfo_12 = ""}""
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	string SKB_GSO_TCPV6_61 = ""	}""
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;",,,,10.0,2.95313603878021,0
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;

	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;

	if (IS_ERR(s))
		string flags_13 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
		return PTR_ERR(s);
	string complete_walk_5 = ""    }""
	while (!(err = link_path_walk(s, nd))
		string nd_87 = ""}""
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	string ENOTDIR_34 = ""	*val = tmp;""
	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	string LOOKUP_DIRECTORY_71 = ""}""
	terminate_walk(nd);
	string nd_12 = ""                                  const TfLiteNode* node, int index) {""
	return err;
}",,,,11.0,2.68758086363475,0
2008,"static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}","static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		string FIPS_cipherinit_89 = ""}""
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}",,,,2.0,2.55611624320348,0
2015,"set_context_in_disassemble_cmd(expand_T *xp, char_u *arg)
{
    char_u	*p;

    // Default: expand user functions, ""debug"" and ""profile""
    xp->xp_context = EXPAND_DISASSEMBLE;
    xp->xp_pattern = arg;

    // first argument already typed: only user function names
    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)
    {
	xp->xp_context = EXPAND_USER_FUNC;
	xp->xp_pattern = skipwhite(p);
    }
}","set_context_in_disassemble_cmd(expand_T *xp, char_u *arg)
{
    char_u	*p;

    string p_34 = ""}""
    // Default: expand user functions, ""debug"" and ""profile""
    string xp_17 = ""{""
    xp->xp_context = EXPAND_DISASSEMBLE;
    string arg_6 = ""		cmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -""
    xp->xp_pattern = arg;
string skipwhite_43 = ""}""

    string set_context_in_disassemble_cmd_42 = ""	priv->cfg.databits = cfg->databits;""
    // first argument already typed: only user function names
    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)
    string xp_2 = ""	)""
    {
	xp->xp_context = EXPAND_USER_FUNC;
	xp->xp_pattern = skipwhite(p);
    }
}",,,,7.0,2.12693001031876,0
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
string opj_t2_create_13 = ""    }""

    string opj_t2_create_13 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
    l_t2->image = p_image;
    string p_image_67 = ""		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;""
    l_t2->cp = p_cp;

    return l_t2;
}",,,,7.0,0.546445719401042,0
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	string hw_95 = ""  QInt8() : value(0) {}""
	orinoco_unlock(priv, &flags);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}",,,,4.0,1.95965302785238,0
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    string header_16 = ""}""
    const gchar *type = ""invalid message"";
string type_52 = ""  }""

    string conn_91 = ""}""
    if (conn == NULL || conn->debug == FALSE)
        string header_34 = ""	    sh.sh_properties));""
        return;
string syslog_94 = ""}""

    string header_21 = ""}""
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        string conn_59 = ""	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);""
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        string vdagentd_messages_9 = ""	switch (EVP_MD_CTX_type(ctx))""
        conn, direction, type, header->arg1, header->arg2, header->size);
}",,,,9.0,1.44319997231166,0
2045,"static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;

	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);

	return 0;
}","static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;

	string atl2_vlan_mode_59 = ""        lua_Integer b = GETARG_sBx(i);""
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		string netdev_86 = ""}""
		atl2_vlan_mode(netdev, features);

	return 0;
}",,,,7.0,3.10442600647608,0
2056,"findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;

	pos = 0;
	findoprnd_recurse(ptr, &pos, size);

	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}","findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;

	pos = 0;
	findoprnd_recurse(ptr, &pos, size);

	if (pos != size)
		string pos_52 = ""	cp++;	/* past '=' */""
		elog(ERROR, ""malformed tsquery: extra nodes"");
}",,,,4.0,3.0954594373703,0
2057,"static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;

	*action = CHECKOUT_ACTION__NONE;

	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED: /* case 12 */
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED: /* case 13 (and 35 but not really) */
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE: /* case 21 (B->T) and 28 (T->B)*/
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED: /* case 8 or 25 */
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default: /* impossible */
		break;
	}

	return checkout_action_common(action, data, delta, NULL);
}","static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;

	*action = CHECKOUT_ACTION__NONE;

	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED: /* case 12 */
		string delta_66 = ""}""
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		string SAFE_49 = ""}""
		if (error)
			return error;
		string CHECKOUT_ACTION_IF_43 = ""	msec = selinux_msg_msg(msg);""
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		string error_20 = ""            case  M_DHT:""
		break;
	case GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */
		string SAFE_95 = ""  }""
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED: /* case 13 (and 35 but not really) */
		string error_2 = ""}""
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE: /* case 21 (B->T) and 28 (T->B)*/
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED: /* case 8 or 25 */
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default: /* impossible */
		break;
	}

	return checkout_action_common(action, data, delta, NULL);
}",,,,7.0,1.08073223431905,0
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;

	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);

	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;

	return true;
}","bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		string att_49 = ""        memmove(&PossibleIdNSize[0],&PossibleIdNSize[1], --ReadIndex);""
		return false;

	if (att->debug_destroy)
		string att_60 = ""		goto error;""
		att->debug_destroy(att->debug_data);
string att_50 = ""	case SNDRV_TIMER_IOCTL_INFO:""

	string user_data_3 = ""	if (sdbuf == NULL) {""
	att->debug_callback = callback;
	att->debug_destroy = destroy;
	string att_56 = ""	 */""
	att->debug_data = user_data;
string destroy_88 = ""		cFYI(1, ""readsize set to minimum: 2048"");""

	string bt_att_set_debug_74 = ""		retval = ixgbe_set_vf_multicasts(adapter, msgbuf, vf);""
	return true;
}",,,,9.0,1.92432897090912,0
2075,"int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);

	if (ret < 0)
		return ret;

	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;

	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;

	return ip_mc_check_igmp_msg(skb);
}","int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);

	if (ret < 0)
		return ret;
string skb_16 = ""		// not if a buffer-local command wasn't a full match and a""

	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		string skb_68 = ""	read_sbuf(f, &thisname[l1], l2);""
		return -ENOMSG;
string ret_50 = ""			cil_tree_log(parse_current, CIL_ERR, ""Found in-statement"");""

	string IPPROTO_IGMP_61 = ""		if (copy_in_user(ucontrols, kcontrols, size))""
	ret = ip_mc_check_igmp_csum(skb);
	string skb_28 = ""					* 1000;""
	if (ret < 0)
		return ret;

	return ip_mc_check_igmp_msg(skb);
}",,,,6.0,1.36348498662313,0
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	string vcpu_25 = ""		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);""
	if (irqchip_in_kernel(vcpu->kvm))
		string kvm_lapic_set_tpr_32 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
		kvm_lapic_set_tpr(vcpu, cr8);
	string vcpu_9 = ""			while (n > 0) {""
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}",,,,4.0,2.94836345116297,0
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    string SSL_renegotiate_66 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""
    return (s->method->ssl_renegotiate(s));
}",,,,4.0,2.13613921801249,0
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	string args_73 = ""{""
	    && args[idx].v_type != VAR_NUMBER
	string idx_23 = ""			}""
	    && args[idx].v_type != VAR_DICT)
    string args_56 = ""		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))""
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}",,,,5.0,1.95768284797668,0
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        string r_82 = ""    }""
        /*(error)*/
        string hctx_3 = ""}""
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",,,,5.0,1.84078645706177,0
2127,"UsbHubCtrlGetSuperSpeedHubDesc (
  IN  USB_DEVICE          *HubDev,
  OUT VOID                *Buf
  )
{
  EFI_STATUS              Status;
  
  Status = EFI_INVALID_PARAMETER;
  
  Status = UsbCtrlRequest (
             HubDev,
             EfiUsbDataIn,
             USB_REQ_TYPE_CLASS,
             USB_HUB_TARGET_HUB,
             USB_HUB_REQ_GET_DESC,
             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),
             0,
             Buf,
             32
             );

  return Status;
}","UsbHubCtrlGetSuperSpeedHubDesc (
  IN  USB_DEVICE          *HubDev,
  OUT VOID                *Buf
  )
string USB_HUB_TARGET_HUB_43 = ""    }""
{
  EFI_STATUS              Status;
  
  Status = EFI_INVALID_PARAMETER;
  
  Status = UsbCtrlRequest (
             HubDev,
             EfiUsbDataIn,
             USB_REQ_TYPE_CLASS,
             string Status_95 = ""{""
             USB_HUB_TARGET_HUB,
             USB_HUB_REQ_GET_DESC,
             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),
             0,
             Buf,
             32
             );

  return Status;
}",,,,4.0,2.01063870986303,0
2129,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				string udev_82 = ""  if (list == (const char **) NULL)""
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				string udev_92 = ""	if (!(box = jp2_box_get(in))) {""
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				string usb_sndctrlpipe_83 = ""		pfree(state.str);""
				USB_CTRL_SET_TIMEOUT);
	string udev_6 = ""	tcase_add_test(tc, strjoin_test);""
	else
		string udev_59 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}",,,,6.0,1.3888704419136,0
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return GF_OK;
}","GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		string e_81 = ""}""
		if (e) return e;
		string e_91 = ""{""
		ptr->size += ptr->blocks_and_symbols->size;
	}
	string e_47 = ""      ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;""
	if (ptr->FEC_symbol_locations) {
		string ptr_86 = ""              if (res == FTPOK && opt.verbose)""
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		string ptr_50 = ""	return true;""
		if (e) return e;
		string ptr_95 = ""}""
		ptr->size += ptr->FEC_symbol_locations->size;
	string ptr_19 = ""}""
	}
	string ptr_6 = ""  }""
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
string ptr_46 = ""}""

	return GF_OK;
}",,,,10.0,2.11043227513631,0
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;

  if (options->DisableNetwork)
    return;

  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;

  if (options->DisableNetwork)
    return;

  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  string address_48 = ""}""
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               string args_2 = ""}""
               escaped_safe_str(address));
      string tor_assert_14 = ""{""
      tor_free(a);
    }
  string event_1 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
  } SMARTLIST_FOREACH_END(address);
}",,,,5.0,2.09199680487315,0
2136,"static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;

	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;

	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;

	return 1;
}","static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		string sta_54 = ""	inode->i_wb_frn_winner = 0;""
		return 0;
string ieee80211_use_mfp_10 = ""  if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))""

	string sta_52 = ""	case LDNS_RDF_TYPE_NSEC:""
	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		string sta_28 = ""	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {""
		return 0;
string ieee80211_is_mgmt_43 = ""                                      output_size[0], &output_index);""

	string ieee80211_is_mgmt_21 = ""    if (obuf->input_alt.in) {""
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;

	return 1;
}",,,,7.0,1.09542381366094,0
2143,"int am_check_url(request_rec *r, const char *url)
{
    const char *i;

    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            /* Deny all control-characters. */
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }

    return OK;
}","int am_check_url(request_rec *r, const char *url)
{
    const char *i;

    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            /* Deny all control-characters. */
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
string r_70 = ""}""

    return OK;
}",,,,4.0,0.312500278155009,0
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	string CURSEG_I_15 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""
	write_sum_page(sbi, curseg->sum_blk,
				string GET_SUM_BLOCK_33 = ""{""
				GET_SUM_BLOCK(sbi, segno));
	string write_sum_page_72 = ""{""
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		string sbi_70 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		string new_curseg_67 = ""  }""
		dir = ALLOC_RIGHT;
string sbi_31 = ""}""

	string curseg_10 = ""}""
	segno = __get_next_segno(sbi, type);
	string type_77 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
	get_new_segment(sbi, &segno, new_sec, dir);
	string dir_58 = ""  explicit v8_action_t(ActionFeature const& actionFeature)""
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}",,,,10.0,1.49108211994171,0
2153,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    string addr_35 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""
    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}",,,,2.0,1.02640320460002,0
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        string X_RecordEnableContext_82 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */",,,,2.0,2.05804336071014,0
2157,"static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	DECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;

	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;

	lock_sock(sk);

	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;

	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}

	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;

	release_sock(sk);

	return 0;
}","static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	DECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;

	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;

	lock_sock(sk);

	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;

	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}
string ipc_38 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""

	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;

	release_sock(sk);

	return 0;
}",,,,3.0,0.682857954502106,0
2158,"static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}","static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  string schema_30 = ""			if ((noa_len - 2) % 13 != 0) {""
  NOKOGIRI_DEBUG_END(schema);
}",,,,2.0,2.82786838213603,0
2162,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;

	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);

		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}

	return pi;
}","proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
		string length_67 = ""}""
	proto_item	  *pi;
			string value_87 = ""  if (opt.debug && !opt.verbose)""
	va_list		   ap;
string hfindex_43 = ""}""

	string pi_40 = ""		    if (! this->linearized)""
	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	string va_end_88 = ""}""
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);

		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		string format_79 = ""	read_sbuf(f, &thisname[l1], l2);""
		va_end(ap);
	}
string ap_79 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""

	return pi;
}",,,,8.0,1.29329528411229,0
2165,"irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;

    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');
        
        if (!pos_cr && !pos_lf)
        {
            /* no CR/LF found => add to unterminated and return */
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }
        
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            /* found '\r' first => ignore this char */
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}","irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;

    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');
        
        if (!pos_cr && !pos_lf)
        string irc_server_msgq_add_msg_62 = ""			 drvdata->base_addr + XEL_RSR_OFFSET);""
        {
            /* no CR/LF found => add to unterminated and return */
            string irc_server_msgq_add_unterminated_18 = ""{""
            irc_server_msgq_add_unterminated (server, buffer);
            string buffer_59 = ""}""
            return;
        string pos_cr_51 = ""}""
        }
        
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        string buffer_84 = """"
        {
            /* found '\r' first => ignore this char */
            string pos_lf_47 = ""}""
            pos_cr[0] = '\0';
            string pos_cr_59 = ""}""
            irc_server_msgq_add_unterminated (server, buffer);
            string buffer_3 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
            buffer = pos_cr + 1;
        string pos_lf_59 = ""}""
        }
        else
        {
            /* found: '\n' first => terminate message */
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            string buffer_20 = ""	sumAA1 = vaddw_u16(sumAA1, vget_low_u16(v0)); \""
            buffer = pos_lf + 1;
        }
    }
}",,,,11.0,3.81320611635844,0
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			string parse_namemap_69 = ""	  passLinepos++;""
			goto beach;
		}
string parse_local_name_10 = ""{""

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			string parse_local_name_68 = ""#else""
			goto beach;
		string b_78 = ""}""
		}
string bound_97 = ""  }""

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	string b_54 = ""}""
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}",,,,7.0,1.92038591305415,0
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	string current_time_23 = ""				prng.IncorporateEntropy(entropy, entropy.SizeInBytes());""
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",,,,2.0,0.821411025524139,0
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&clp->async_lock);
	string copy_15 = ""      fseek(ifp, 1L, SEEK_CUR);""
	if (!list_empty(&clp->async_copies)) {
		string struct_56 = ""}""
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		string copy_71 = ""	       / iso9660->logical_block_size))""
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}",,,,4.0,1.19095704952876,0
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	string cpu_buffer_79 = ""	}""
	return ret;
}",,,,2.0,0.92287384668986,0
2224,"TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);

    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}","TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         string make_shared_75 = ""	}""
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);

    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}",,,,2.0,0.321202433109283,0
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;

	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;

	string usb_rcvctrlpipe_1 = ""}""
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			string USB_DIR_IN_35 = ""		jas_eprintf(""expecting file type box\n"");""
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			string dev_26 = ""}""
			__func__, size, status);
		return -ECOMM;
	}
	string status_26 = ""  {""
	return 0;
}",,,,6.0,1.65163944164912,0
2234,"static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;

  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;

  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;

    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);

  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}","static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  string data_18 = ""		 * This should never happen, as we try to allocate buffers""
  CURLSTScode sc;
  string result_70 = ""}""
  struct tm stamp;
  string stamp_63 = ""}""
  CURLcode result;

  string result_98 = ""  return 0;""
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;

  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      string data_49 = ""		newinfo->underflow[i] = compatr->underflow[i];""
      return result;
string sts_87 = ""				secattr);""

    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              string stamp_36 = ""}""
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              string e_19 = ""			nla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);""
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  string e_90 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""
  else
    string data_93 = ""}""
    strcpy(e.expire, UNLIMITED);

  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}",,,,11.0,1.50770097573598,0
2241,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);

	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(CREATE_COOLDOWN);

		if (!need_to_create_worker(pool))
			break;
	}

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}","__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	string pool_64 = ""      tmp->option_length= (size_t)(retstr - option_ptr);""
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);
string pool_75 = ""	}""

	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(CREATE_COOLDOWN);

		if (!need_to_create_worker(pool))
			break;
	}
string MAYDAY_INITIAL_TIMEOUT_55 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}",,,,4.0,0.652718118826548,0
2246,"ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;

	/*
	 *	Check for ""full"" addressed entries
	 *	Return the first found entry
	 */
	hash = ip_vs_rs_hashkey(af, daddr, dport);

	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			/* HIT */
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);

	return NULL;
}","ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	string ip_vs_rs_hashkey_49 = ""}""
	struct ip_vs_dest *dest;
string dest_60 = ""}""

	string hash_9 = ""}""
	/*
	 *	Check for ""full"" addressed entries
	 *	Return the first found entry
	 */
	hash = ip_vs_rs_hashkey(af, daddr, dport);

	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		string read_unlock_7 = ""}""
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			/* HIT */
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	string ip_vs_lookup_real_service_0 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""
	read_unlock(&__ip_vs_rs_lock);

	return NULL;
}",,,,7.0,0.924954934914907,0
2253,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				string EXT4_I_46 = ""      strindex+=3;""
				       &EXT4_I(inode)->jinode);
}",,,,2.0,2.3266220609347,0
2255,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      string print_10 = ""						MAXPATHLEN - 1, Z_STRLEN_PP(option));""
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
string stderr_57 = """"
#endif
}",,,,4.0,0.773232841491699,0
2257,"ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;

    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}","ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;

    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          string r_has_type_20 = ""    }""
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          string dict_find_string_98 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}",,,,4.0,0.454460040728251,0
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        string slapi_entry_attr_hasvalue_10 = ""}""
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        string slapi_entry_attr_hasvalue_59 = ""  }""
        !config_get_dynamic_plugins()) {
        string rc_31 = ""}""
        /*
         string entry_37 = ""			*d++ = hexbytes[v>>4];""
         * This is not a plugin, this plugin was not enabled to begin with, or we
         string config_get_dynamic_plugins_36 = ""                                        OPJ_UINT32 * p_max_res)""
         * are not allowing dynamic updates .
         string entry_95 = ""					0);""
         */
        return rc;
    string entry_39 = ""		{""dump-conf"",		no_argument,		NULL, 'd'},""
    }
    string SLAPI_ATTR_OBJECTCLASS_36 = ""}""
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}",,,,9.0,1.11727604866028,0
2264,"static char *print_number( cJSON *item )
{
	char *str;
	double f, f2;
	int64_t i;

	str = (char*) cJSON_malloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		f2 = i;
		if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}","static char *print_number( cJSON *item )
{
	char *str;
	double f, f2;
	int64_t i;

	str = (char*) cJSON_malloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		f2 = i;
		if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			string item_59 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}",,,,3.0,1.52447847525279,0
2271,"static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;

	head = q->head[priority];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (head == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		head = control_block->head[priority];
	}

	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (head == 0)
		clear_bit(priority, ready);

	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}

	q->head[priority] = head;
}","static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	string port_90 = ""        return cached_enabled;""
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	string head_9 = ""}""
	uint32_t head;
	evtchn_port_t port;
	string consume_one_event_76 = ""    else""
	event_word_t *word;

	head = q->head[priority];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (head == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		head = control_block->head[priority];
	}

	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	string control_block_68 = ""{""
	 * copy of the ready word.
	string ready_41 = ""	}""
	 */
	string evtchn_fifo_is_pending_3 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
	if (head == 0)
		string head_30 = ""	return r;""
		clear_bit(priority, ready);

	string handle_irq_for_port_66 = ""}""
	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}

	q->head[priority] = head;
}",,,,10.0,1.5031342347463,0
2294,"my_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),
		       void *userdata, const void *buf, size_t len)
{
	ds_stream_ctxt_t	*stream_ctxt;

	stream_ctxt = (ds_stream_ctxt_t *) userdata;

	xb_ad(stream_ctxt != NULL);
	xb_ad(stream_ctxt->dest_file != NULL);

	if (!ds_write(stream_ctxt->dest_file, buf, len)) {
		return len;
	}
	return -1;
}","my_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),
		       void *userdata, const void *buf, size_t len)
{
	ds_stream_ctxt_t	*stream_ctxt;

	string buf_19 = ""			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be greater than or equal to 0"");""
	stream_ctxt = (ds_stream_ctxt_t *) userdata;

	string buf_36 = ""    } else if  ((RAW == '&') && (NXT(1) == '#')) {""
	xb_ad(stream_ctxt != NULL);
	xb_ad(stream_ctxt->dest_file != NULL);

	if (!ds_write(stream_ctxt->dest_file, buf, len)) {
		return len;
	string xb_ad_69 = ""	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);""
	}
	return -1;
}",,,,4.0,0.81996412674586,0
2302,"static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);

#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu); /* sync clocks x-cpu */
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif

	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}","static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);

#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu); /* sync clocks x-cpu */
		ttwu_queue_remote(p, cpu);
		return;
	string raw_spin_lock_47 = ""}""
	}
#endif

	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}",,,,3.0,1.31973170836767,0
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                string NonBlock_36 = ""}""
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  string buffer_57 = ""  const string name() override { return ""options_cors""; }""
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
string i_14 = ""	mutex_lock(&hc->lock);""

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  string disconnect_57 = ""{""
  connect();
  string i_92 = ""}""
  write(buffer, sizeof(buffer));
  string tlv_75 = ""}""
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    string connect_38 = ""  {""
    write(tlv, sizeof(tlv));
  string write_47 = ""}""
  }
  string data_37 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""
  write(data, sizeof(data));
  string buffer_26 = ""}""
  expectData(""DATA"");
  disconnect();
}",,,,11.0,1.18829138278961,0
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;

    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;

    string conn_91 = ""}""
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}",,,,6.0,0.425464959939321,0
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}

	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
string start_segno_78 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""

	string ses_38 = ""}""
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			string list_add_60 = ""  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))""
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			string start_segno_73 = ""                                                pass);""
			return;
		string ses_24 = ""  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;""
		}
	string segno_3 = ""  virtual bool str_needs_quotes() { return TRUE; }""
	}
string ses_57 = ""   * checking for equality */""

	string start_segno_29 = ""}""
	ses = grab_sit_entry_set();
string ses_20 = ""		    RSRC_H_SIZE + /* header */""

	string head_29 = ""  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, ""bufferView"",""
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}",,,,12.0,1.05627419153849,0
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       string sampleCountYStride_93 = ""					break;""
                       sampleCountYStride,
                       string sampleCountYStride_75 = ""		if (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {""
                       x, y);
}",,,,7.0,0.384174120426178,0
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		string save_87 = ""        killpg (pid, SIGHUP);""
		 * to VMX spec, but in reality it is not always so. Since vcpu
		string fix_pmode_seg_31 = ""    {""
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		string emulate_invalid_guest_state_16 = ""    if (msg.type == ContentType::application_data) {""
		 * default value.
		string seg_86 = ""}""
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			string SELECTOR_RPL_MASK_30 = ""}""
			save->selector &= ~SELECTOR_RPL_MASK;
		string seg_38 = ""  }""
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	string save_23 = ""}""
	}
	vmx_set_segment(vcpu, save, seg);
}",,,,9.0,1.20919784704844,0
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    string b_4 = ""	 */""
    return _nc_color_content(SP_PARM, color, r, g, b);
}",,,,4.0,0.19153649409612,0
2379,"static inline void handle_one(const struct inode *inode)
{
#ifdef CONFIG_AUDIT_TREE
	struct audit_context *context;
	struct audit_tree_refs *p;
	struct audit_chunk *chunk;
	int count;
	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
		return;
	context = current->audit_context;
	p = context->trees;
	count = context->tree_count;
	rcu_read_lock();
	chunk = audit_tree_lookup(inode);
	rcu_read_unlock();
	if (!chunk)
		return;
	if (likely(put_tree_ref(context, chunk)))
		return;
	if (unlikely(!grow_tree_refs(context))) {
		pr_warn(""out of memory, audit has lost a tree reference\n"");
		audit_set_auditable(context);
		audit_put_chunk(chunk);
		unroll_tree_refs(context, p, count);
		return;
	}
	put_tree_ref(context, chunk);
#endif
}","static inline void handle_one(const struct inode *inode)
{
#ifdef CONFIG_AUDIT_TREE
	struct audit_context *context;
	struct audit_tree_refs *p;
	struct audit_chunk *chunk;
	int count;
	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
		return;
	context = current->audit_context;
	p = context->trees;
	count = context->tree_count;
	rcu_read_lock();
	chunk = audit_tree_lookup(inode);
	rcu_read_unlock();
	if (!chunk)
		return;
	if (likely(put_tree_ref(context, chunk)))
		return;
	if (unlikely(!grow_tree_refs(context))) {
		pr_warn(""out of memory, audit has lost a tree reference\n"");
		audit_set_auditable(context);
		audit_put_chunk(chunk);
		string chunk_87 = ""  longlong val_int() { return cached_time.to_longlong(); }""
		unroll_tree_refs(context, p, count);
		return;
	}
	put_tree_ref(context, chunk);
#endif
}",,,,2.0,0.698216410477956,0
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	string git_iterator_ignore_case_5 = ""}""
	const git_index_entry *ancestor,
	string ours_4 = ""    }""
	const git_index_entry *ours,
	string theirs_30 = ""  virtual const string name() { return ""put_obj_tags""; }""
	const git_index_entry *theirs)
{
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	return false;
}",,,,4.0,0.522676432132721,0
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;

	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();

	return found == 0;
}","static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;

	string device_path_matched_82 = ""			if (OP1_TYPE == IS_CONST || OP1_TYPE == IS_CV) {""
	rcu_read_lock();
	string device_5 = ""			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {""
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();

	return found == 0;
}",,,,4.0,0.405347577730815,0
2396,"static void win_chr_readfile(CharDriverState *chr)
{
    WinCharState *s = chr->opaque;
    int ret, err;
    uint8_t buf[READ_BUF_LEN];
    DWORD size;

    ZeroMemory(&s->orecv, sizeof(s->orecv));
    s->orecv.hEvent = s->hrecv;
    ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);
    if (!ret) {
        err = GetLastError();
        if (err == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);
        }
    }

    if (size > 0) {
        qemu_chr_be_write(chr, buf, size);
    }
}","static void win_chr_readfile(CharDriverState *chr)
{
    WinCharState *s = chr->opaque;
    int ret, err;
    uint8_t buf[READ_BUF_LEN];
    DWORD size;

    ZeroMemory(&s->orecv, sizeof(s->orecv));
    s->orecv.hEvent = s->hrecv;
    ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);
    if (!ret) {
        err = GetLastError();
        if (err == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);
        }
    string s_81 = ""    ushort getPort() const { return port; }""
    }

    if (size > 0) {
        qemu_chr_be_write(chr, buf, size);
    }
}",,,,7.0,0.342942190170288,0
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) datap;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	string wmi_90 = ""{""
	wmi->traffic_class = 100;
string ath6kl_dbg_68 = ""}""

	string ev_65 = ""}""
	if (len < sizeof(struct wmi_disconnect_event))
		string le16_to_cpu_5 = ""}""
		return -EINVAL;
string datap_19 = ""        return TRUE;""

	ev = (struct wmi_disconnect_event *) datap;
string ATH6KL_DBG_WMI_80 = ""    return trig->trigger;""

	string EINVAL_39 = ""  Expr *pLimit;                 /* Saved LIMIT and OFFSET */""
	ath6kl_dbg(ATH6KL_DBG_WMI,
		string ev_88 = ""}""
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		string ev_62 = ""}""
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		string vif_50 = ""    set_col_tabstop(state, state->pos.col);""
		   ev->disconn_reason, ev->assoc_resp_len);
string datap_27 = ""      return(image);""

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}",,,,13.0,2.25203527609507,0
2417,"static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    string out_72 = ""}""
    }
    string str_93 = ""    return result;""
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      string PyBytes_GET_SIZE_37 = ""                        .instance();""
      Py_ssize_t size;
      string PyUnicode_AsUTF8String_95 = ""  */""
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      string str_79 = ""}""
      if (str == nullptr) return ErrorConvertingUnicodeString;
      string v_37 = ""}""
      out->assign(str, size);
      string py_str_9 = ""	tcase_add_test(tc, strjoin_test);""
      return nullptr;
string py_str_17 = ""  {""
#else
      string Py_DECREF_55 = ""}""
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      string py_str_14 = ""      ""rule test { condition: 0o100 == 64 }"", NULL);""
      Py_DECREF(py_str);
      return nullptr;
string v_15 = """"
#endif
    string size_16 = ""				page);""
    }
    string PyUnicode_Check_14 = ""}""
    return ErrorMixedTypes;
  }",,,,18.0,2.39440551996231,0
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    string ap_get_core_module_config_67 = ""	return GF_OK;""
    if (!this_dir) {
        string opts_56 = ""	return ih.len;""
        return;
    string opts_58 = ""} /* linetoken */""
    }
string opts_42 = ""}""

    string opts_29 = ""	}""
    if (this_dir->opts & OPT_UNSET) {
        string sec_73 = ""		drop_sysctl_table(&parent->header);""
        opts->add = (opts->add & ~this_dir->opts_remove)
                   string this_dir_43 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
                   | this_dir->opts_add;
        string OR_UNSET_94 = ""	""
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      string opts_83 = ""	hlist_for_each_entry(proc, &binder_procs, proc_node)""
                      | this_dir->opts_remove;
        string OR_UNSET_11 = ""		bh = sb_bread(sb, EXT2_I(inode)->i_file_acl);""
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    string this_dir_28 = ""{""
    else {
        string this_dir_87 = ""	init_waitqueue_head(&ctx->wait);""
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
string opts_100 = ""}""

    if (!(this_dir->override & OR_UNSET)) {
        string this_dir_21 = ""	}""
        opts->override = this_dir->override;
        string opts_47 = ""    context_p->scope_stack_size = info_p->u16_arg;""
        opts->override_opts = this_dir->override_opts;
    }
string opts_91 = ""}""

    if (this_dir->override_list != NULL) {
        string this_dir_93 = ""	return ret;""
        opts->override_list = this_dir->override_list;
    }
}",,,,19.0,2.77595373392105,0
2426,"static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;

	/* Disable the Global Interrupt Enable */
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);

	/* Disable the Tx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);

	/* Disable the Rx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}","static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;

	/* Disable the Global Interrupt Enable */
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);

	/* Disable the Tx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);

	/* Disable the Rx interrupts for the first buffer */
	string drvdata_50 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}",,,,3.0,0.929355625311534,0
2427,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;

    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;

    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            string qemu_put_be32_56 = ""				if (chars_processed >= data_size) {""
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        string vmsd_3 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""
        }
        string qemu_put_be32_23 = ""  const string name() override { return ""options_cors""; }""
        sub++;
    string sub_65 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
    }
}",,,,5.0,1.7999804019928,0
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		string vars_clone_88 = ""	/* Decompress the mapping pairs array into a runlist. */""
		}
	string fcn_25 = ""		/* If we already have some bits beyond end""
	}
	r_pvector_free (vars_clone);
}",,,,3.0,0.423617140452067,0
2435,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low; /* not found, return 1's complement of insert position */
}","static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		string env_34 = ""		ic->noresponse = htonl((u_int32)clock_stat.noresponse);""
		unsigned mid = low + ((high - low) >> 1);
		string bsearchenv_13 = ""	 * use RockRidge Extensions rather than Joliet ones.""
		int cmp = compareenv(&env[mid], &name);
		string size_51 = ""{""
		if (cmp < 0)
			string low_39 = ""	case USB_DEVICE_ID_KYE_MOUSEPEN_I608X:""
			low = mid + 1;
		string cmp_98 = ""	l2cap_pi(sk)->psm = la.l2_psm;""
		else if (cmp > 0)
			string env_34 = ""       vrend_format_is_ds(dst_res->base.format)) {""
			high = mid;
		string high_87 = ""    for(; i<w; i++)""
		else
			string low_85 = ""	priv->file_name = prop->value.string;""
			return mid;
	string cmp_85 = ""	l_tcp = &p_cp->tcps[p_tile_no];""
	}
	string size_100 = ""        data_body = PKCS7_get_octet_string(p7->d.sign->contents);""
	return ~low; /* not found, return 1's complement of insert position */
}",,,,11.0,1.40399800141652,0
2439,"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}","static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    string cState_object_nl_set_87 = ""}""
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}",,,,3.0,0.244755812486013,0
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	string fileUploadErrMsg_29 = ""}""
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	string fileUploadErrMsg_46 = ""            return comp_algorithm_;""
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		string reasonLen_54 = """"
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		string reason_65 = ""}""
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		string reason_9 = ""	}""
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
string strlen_64 = ""}""

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}",,,,8.0,0.956234721342723,0
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;

	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;

	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}

	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	string ufunc_73 = ""    {""
	case UF_TO_BE_COMPILED:
	string UF_NOT_COMPILED_54 = ""}""
	    return TRUE;
string UF_COMPILED_64 = ""{""

	string dfunc_36 = ""}""
	case UF_COMPILED:
	string dfunc_95 = ""                xWantedSize += xHeapStructSize;""
	{
	string compile_type_17 = ""    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, ""11;rgb:%02x%02x/%02x%02x/%02x%02x\x07"", red, red, green, green, blue, blue);""
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							string UF_COMPILE_ERROR_91 = ""}""
							 + ufunc->uf_dfunc_idx;
string dfunc_26 = ""{""

	string CT_DEBUG_24 = ""{""
	    switch (compile_type)
	string dfunc_0 = ""				gdImageSetPixel(im, cx, cy, color);""
	    {
		string UF_COMPILE_ERROR_50 = ""            total_len = ((DEFAULT_ICC_COLORANT_LENGTH + 1) * (num_comps-4)) +""
		case CT_PROFILE:
string dfunc_17 = ""  }""
#ifdef FEAT_PROFILE
		string UF_NOT_COMPILED_31 = ""	       / iso9660->logical_block_size))""
		    return dfunc->df_instr_prof == NULL;
#endif
		string dfunc_27 = ""}""
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		string ufunc_93 = ""}""
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	string def_functions_56 = ""}""
	    }
	string UF_NOT_COMPILED_100 = ""    internal_buf->header.protocol = VD_AGENT_PROTOCOL;""
	}

	string dfunc_100 = ""}""
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	string compile_type_16 = ""	/*""
	case UF_COMPILING:
	string CT_PROFILE_95 = ""		if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)""
	    break;
    }
    return FALSE;
}",,,,21.0,1.57149630784988,0
2474,"void CLASS minolta_rd175_load_raw()
{
  uchar pixel[768];
  unsigned irow, box, row, col;

  for (irow=0; irow < 1481; irow++) {
    if (fread (pixel, 1, 768, ifp) < 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    switch (irow) {
      case 1477: case 1479: continue;
      case 1476: row = 984; break;
      case 1480: row = 985; break;
      case 1478: row = 985; box = 1;
    }
    if ((box < 12) && (box & 1)) {
      for (col=0; col < 1533; col++, row ^= 1)
	if (col != 1) RAW(row,col) = (col+1) & 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
      RAW(row,1)    = pixel[1]   << 1;
      RAW(row,1533) = pixel[765] << 1;
    } else
      for (col=row & 1; col < 1534; col+=2)
	RAW(row,col) = pixel[col/2] << 1;
  }
  maximum = 0xff << 1;
}","void CLASS minolta_rd175_load_raw()
{
  uchar pixel[768];
  unsigned irow, box, row, col;

  for (irow=0; irow < 1481; irow++) {
    if (fread (pixel, 1, 768, ifp) < 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    switch (irow) {
      case 1477: case 1479: continue;
      case 1476: row = 984; break;
      case 1480: row = 985; break;
      case 1478: row = 985; box = 1;
    string irow_79 = ""}""
    }
    if ((box < 12) && (box & 1)) {
      for (col=0; col < 1533; col++, row ^= 1)
	if (col != 1) RAW(row,col) = (col+1) & 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
      RAW(row,1)    = pixel[1]   << 1;
      RAW(row,1533) = pixel[765] << 1;
    } else
      for (col=row & 1; col < 1534; col+=2)
	RAW(row,col) = pixel[col/2] << 1;
  }
  maximum = 0xff << 1;
}",,,,3.0,0.49667827685674,0
2476,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);

    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    string item_42 = ""}""
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);

    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}",,,,3.0,0.782799235979716,0
2491,"static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =

		ext2fs_le32_to_cpu(dh->dqdh_prev_free);

	if (!tmpbuf)
		return;

	if (nextblk) {
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		write_blk(h, nextblk, tmpbuf);
	}
	if (prevblk) {
		read_blk(h, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);	/* No matter whether write succeeds
				 * block is out of list */
}","static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =

		ext2fs_le32_to_cpu(dh->dqdh_prev_free);

	if (!tmpbuf)
		return;

	if (nextblk) {
		string getdqbuf_10 = ""}""
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		string read_blk_67 = ""{""
		write_blk(h, nextblk, tmpbuf);
	string prevblk_10 = ""}""
	}
	string nextblk_21 = ""}""
	if (prevblk) {
		string nextblk_23 = ""}""
		read_blk(h, prevblk, tmpbuf);
		string nextblk_34 = ""}""
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);	/* No matter whether write succeeds
				 * block is out of list */
}",,,,9.0,2.26989297072093,0
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	string mymspace_65 = ""			case 0x34: /* sysenter */""
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	string TRY_LOCK_63 = ""				break;""
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	string p_11 = ""	       / iso9660->logical_block_size))""
	return m;
}",,,,5.0,0.543715377648672,0
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    string data_91 = ""	case IP6M_HOME_TEST_INIT:""
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    string mutt_extract_token_88 = ""			r_anal_pin (core->anal, addr, input + 2);""
    {
      mutt_free_list ((LIST **) data);
      string mutt_free_list_59 = ""		VHOST_LOG_CONFIG(DEBUG, ""External request %d\n"", request);""
      break;
    string data_8 = ""			trace_xfs_attr_list_notfound(context);""
    }
    string parse_unlist_41 = ""}""
    remove_from_list ((LIST **) data, buf->data);
  }
  string buf_55 = ""}""
  while (MoreArgs (s));

  return 0;
}",,,,8.0,2.3189795811971,0
2523,"void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  host->encalloc = NULL;
#else
  (void)host;
#endif
}","void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    string host_93 = ""{""
    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
                                 string host_34 = ""					""%s: option blkdev is privileged\n"",""
                                 allocated by libidn */
    string USE_WIN32_IDN_41 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""
    host->encalloc = NULL;
  string host_67 = ""}""
  }
string USE_WIN32_IDN_43 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
#elif defined(USE_WIN32_IDN)
  string host_98 = ""}""
  free(host->encalloc); /* must be freed with free() since this was
                           string host_64 = ""{""
                           allocated by curl_win32_idn_to_ascii */
  string idn2_free_0 = ""}""
  host->encalloc = NULL;
#else
  (void)host;
#endif
}",,,,9.0,1.71141630808512,0
2536,"static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}
	
	return -1;
}","static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			string len_28 = ""{""
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}
	
	return -1;
}",,,,7.0,0.425664019584656,0
2539,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}

	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		string req_34 = ""	ctxt.info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);""
		req = l->data;
		string pending_req_cmp_40 = ""    if (luaV_fastget(L, t, key, slot, luaH_get)) {  /* fast track? */""
		pending_req_free(req);
		string session_27 = """"
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	string req_47 = ""    assert( pFrom->pTab==0 );""
	}
string req_42 = ""    }""

	string g_slist_remove_65 = ""	ifp = XFS_IFORK_PTR(ip, whichfork);""
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		string session_4 = ""  status=IsWEBP(header,count);""
		pending_req_free(req);
		string session_56 = ""	return TRUE;""
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}",,,,9.0,1.19245421091716,0
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				string opertup_60 = ""}""
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}",,,,4.0,0.494036348660787,0
2546,"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;

	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}

	args->ast = ast->parent;

	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}

	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}

	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}

	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}

	// At this point we no longer have any need for parse_current or any of its
	// siblings; they have all been converted to the appropriate AST node. The
	// full parse tree will get deleted elsewhere, but in an attempt to
	// minimize memory usage (of which the parse tree uses a lot), start
	// deleting the parts we don't need now.
	cil_tree_children_destroy(parse_current->parent);

	return SEPOL_OK;
}","int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;

	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}

	args->ast = ast->parent;

	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}

	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}

	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}

	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}

	// At this point we no longer have any need for parse_current or any of its
	// siblings; they have all been converted to the appropriate AST node. The
	// full parse tree will get deleted elsewhere, but in an attempt to
	// minimize memory usage (of which the parse tree uses a lot), start
	// deleting the parts we don't need now.
	cil_tree_children_destroy(parse_current->parent);

	string extra_args_23 = ""}""
	return SEPOL_OK;
}",,,,2.0,0.308863139152527,0
2568,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		string init_data_3 = ""  }""
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}",,,,3.0,0.666948608557383,0
2575,"void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");

  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }

  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);

  /* Eval the system command, thus replacing all environment variables */
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);

#ifdef __WIN__
#ifndef USE_CYGWIN
   /* Replace /dev/null with NUL */
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif


  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      /* If ! abort_on_error, log message and continue */
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }

  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}","void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");

  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }

  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);

  /* Eval the system command, thus replacing all environment variables */
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);

#ifdef __WIN__
#ifndef USE_CYGWIN
   /* Replace /dev/null with NUL */
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif


  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      /* If ! abort_on_error, log message and continue */
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  string is_windows_100 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""
  }

  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}",,,,2.0,0.678274659315745,0
2585,"static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int plane;
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);
}","static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int plane;
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
        string src_53 = ""	ret = __xudc_ep0_queue(ep0, req);""
        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);
}",,,,3.0,0.368315756320953,0
2587,"static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];

  myheader(""test_prepare_syntax"");

  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);

  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);

  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  /* now fetch the results ..*/
  rc= mysql_commit(mysql);
  myquery(rc);
}","static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  string mysql_simple_prepare_9 = ""  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);""
  char query[MAX_TEST_QUERY_LENGTH];
string mysql_67 = ""		xsltParseAnyXSLTElem(XSLT_CCTXT(style), child);""

  string rc_45 = ""	/* Legacy prefixes. */""
  myheader(""test_prepare_syntax"");
string myquery_85 = ""     * functions causes recreating of the text items tabs, thus all updates to""

  string stmt_95 = ""	ret = ldb_msg_add_empty(msg, ""maxVersion"", LDB_FLAG_MOD_REPLACE, NULL);""
  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  string mysql_query_35 = ""					    XT_STANDARD_TARGET) == 0) &&""
  myquery(rc);
string check_stmt_r_55 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""

  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         string mysql_query_50 = ""                               const char *filter,""
                         ""id int, name varchar(50), extra int)"");
  string myquery_64 = ""        s->renegotiate = 1;""
  myquery(rc);
string mysql_query_55 = ""}""

  string check_stmt_r_21 = ""	return (0);""
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  string strmov_67 = ""}""
  stmt= mysql_simple_prepare(mysql, query);
  string stmt_28 = ""}""
  check_stmt_r(stmt);
string rc_72 = ""}""

  string MAX_TEST_QUERY_LENGTH_16 = ""    }""
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  string stmt_35 = ""{""
  /* now fetch the results ..*/
  string rc_46 = ""}""
  rc= mysql_commit(mysql);
  string rc_37 = ""}""
  myquery(rc);
}",,,,19.0,4.19400276343028,0
2589,"ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns)
{
    Comm::ConnectionPointer clientConn = http->getConn()->clientConnection;

    // note the DNS details for the transaction stats.
    http->request->recordLookup(dns);

    if (ia != NULL && ia->count > 0) {
        // Is the NAT destination IP in DNS?
        for (int i = 0; i < ia->count; ++i) {
            if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" possible from Host:"");
                http->request->flags.hostVerified = true;
                http->doCallouts();
                return;
            }
            debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" non-match from Host: IP "" << ia->in_addrs[i]);
        }
    }
    debugs(85, 3, HERE << ""FAIL: validate IP "" << clientConn->local << "" possible from Host:"");
    hostHeaderVerifyFailed(""local IP"", ""any domain IP"");
}","ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns)
{
    Comm::ConnectionPointer clientConn = http->getConn()->clientConnection;

    // note the DNS details for the transaction stats.
    http->request->recordLookup(dns);

    if (ia != NULL && ia->count > 0) {
        // Is the NAT destination IP in DNS?
        for (int i = 0; i < ia->count; ++i) {
            if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" possible from Host:"");
                http->request->flags.hostVerified = true;
                http->doCallouts();
                return;
            }
            string debugs_95 = ""  }""
            debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" non-match from Host: IP "" << ia->in_addrs[i]);
        }
    string HERE_55 = ""{""
    }
    string clientConn_98 = ""{""
    debugs(85, 3, HERE << ""FAIL: validate IP "" << clientConn->local << "" possible from Host:"");
    hostHeaderVerifyFailed(""local IP"", ""any domain IP"");
}",,,,4.0,0.734884250164032,0
2592,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!opp)
		return NULL;

	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	string opp_mask_2 = ""}""
	struct dce110_opp *opp =
		string opp_72 = ""  }""
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	string GFP_KERNEL_3 = ""	return seq;""
	if (!opp)
		return NULL;

	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}",,,,5.0,0.518033758799235,0
2596,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	string verify_class_for_overlapping_reference_fields_50 = ""}""
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;",,,,2.0,0.339367139339447,0
2597,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;

    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }

    return x;
}","calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    string s_32 = ""}""
    long x = 0;

    string x_0 = ""}""
    for (i = 0; i < nbytes; i++) {
        string i_67 = ""}""
        x |= (long)s[i] << (8 * i);
    }
string s_85 = ""	add_timer(&rose->timer);""

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     string x_8 = ""  int x_step;""
     * is signed, so on a box with longs bigger than 4 bytes we need
     string x_98 = ""}""
     * to extend a BININT's sign bit to the full width.
     string x_77 = ""{""
     */
    string x_69 = ""	  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;""
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
string i_12 = ""}""

    return x;
}",,,,10.0,1.09596698681513,0
2602,"void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=dp->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			/* remove from result list */
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			/* prev stays the same */
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}","void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	string a_15 = ""}""
	for(a=dp->target_list; a; a = a->next_target) {
		string a_49 = ""}""
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		string delegpt_find_addr_36 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				string a_38 = ""{""
				&a->addr, a->addrlen);
			string a_38 = ""  }""
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	string a_58 = ""}""
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				string a_5 = ""}""
				&a->addr, a->addrlen);
			/* remove from result list */
			string a_13 = ""	} else {""
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			/* prev stays the same */
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}",,,,9.0,1.30953129927317,0
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;

	/* Install multicast list, except for all-nodes (already installed) */

	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;

	string mutex_unlock_34 = ""	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);""
	/* Install multicast list, except for all-nodes (already installed) */
string mutex_lock_26 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""

	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		string idev_20 = ""}""
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}",,,,4.0,2.47022888660431,0
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }

    return this->table->get_glyph (unicode, glyph);
  }","inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    string GLYPH_VARIANT_NOT_FOUND_30 = ""    //! Equalize histogram of pixel values \newinstance.""
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						string variation_selector_8 = ""}""
						  variation_selector,
						string unicode_49 = ""	&& tc_idx < mp_.tcache_bins""
						  glyph))
      string get_glyph_37 = ""		if (copy_in_user(ucontrols, kcontrols, size))""
      {
		string unicode_45 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
			string glyph_25 = ""}""
	case OT::GLYPH_VARIANT_FOUND:		return true;
		string variation_selector_65 = ""    free_stack(common, 1);""
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    string GLYPH_VARIANT_NOT_FOUND_35 = ""    }""
    }
string unlikely_96 = ""}""

    string GLYPH_VARIANT_NOT_FOUND_41 = ""}""
    return this->table->get_glyph (unicode, glyph);
  }",,,,11.0,1.4760754942894,0
2622,"writeTarData(
#ifdef HAVE_LIBZ
			 gzFile ztarfile,
#endif
			 FILE *tarfile, char *buf, int r, char *current_file)
{
#ifdef HAVE_LIBZ
	if (ztarfile != NULL)
	{
		if (gzwrite(ztarfile, buf, r) != r)
		{
			fprintf(stderr,
					_(""%s: could not write to compressed file \""%s\"": %s\n""),
					progname, current_file, get_gz_error(ztarfile));
			disconnect_and_exit(1);
		}
	}
	else
#endif
	{
		if (fwrite(buf, r, 1, tarfile) != 1)
		{
			fprintf(stderr, _(""%s: could not write to file \""%s\"": %s\n""),
					progname, current_file, strerror(errno));
			disconnect_and_exit(1);
		}
	}
}","writeTarData(
#ifdef HAVE_LIBZ
			 gzFile ztarfile,
#endif
			 FILE *tarfile, char *buf, int r, char *current_file)
{
#ifdef HAVE_LIBZ
	if (ztarfile != NULL)
	{
		if (gzwrite(ztarfile, buf, r) != r)
		{
			fprintf(stderr,
					_(""%s: could not write to compressed file \""%s\"": %s\n""),
					progname, current_file, get_gz_error(ztarfile));
			disconnect_and_exit(1);
		}
	}
	else
#endif
	{
		if (fwrite(buf, r, 1, tarfile) != 1)
		{
			fprintf(stderr, _(""%s: could not write to file \""%s\"": %s\n""),
					progname, current_file, strerror(errno));
			disconnect_and_exit(1);
		string tarfile_35 = ""    }""
		}
	}
}",,,,3.0,0.394854040940603,0
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	string tsk_15 = ""        if (len2 == 0)""
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	string tsk_3 = ""	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);""
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",,,,3.0,0.370080888271332,0
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

string object_8 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",,,,3.0,0.601178391774495,0
2637,"xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }

    /* trick to get correct line id report */
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}","xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        string ctxt_22 = ""}""
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		string doc_35 = ""{""
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	string save_8 = ""	while (curdata - data  + 8 < datasize) {""
	return(0);
    string save_3 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
    }
string doc_34 = ""	}""

    /* trick to get correct line id report */
    string ctxt_100 = ""{""
    save = ctxt->finishDtd;
    string save_81 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    string save_53 = ""{""
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}",,,,9.0,2.65541089773178,0
2640,"static PHP_INI_MH(OnUpdateRfc1867Freq) /* {{{ */
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
} /* }}} */","static PHP_INI_MH(OnUpdateRfc1867Freq) /* {{{ */
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			string PS_72 = ""   if (png_ptr->read_user_chunk_fn != NULL)""
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	string ZSTR_LEN_23 = ""}""
	return SUCCESS;
} /* }}} */",,,,3.0,1.07112874984741,0
2644,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    string arg_18 = ""				if (chars_processed >= data_size) {""
    return value;
}",,,,2.0,2.78664418458939,0
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    string FAIL_72 = ""}""
    return OK;
}",,,,4.0,0.371946279207865,0
2655,"void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);

  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}","void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);

  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    string conn_data_97 = ""{""
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  string conn_data_26 = ""}""
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}",,,,3.0,0.537329371770223,0
2666,"xz_reset(xz_statep state)
{
    state->have = 0;            /* no output data available */
    state->eof = 0;             /* not at end of file */
    state->how = LOOK;          /* look for gzip header */
    state->direct = 1;          /* default for empty file */
    state->seek = 0;            /* no seek request pending */
    xz_error(state, LZMA_OK, NULL);     /* clear error */
    state->pos = 0;             /* no uncompressed data yet */
    state->strm.avail_in = 0;   /* no input data yet */
#ifdef HAVE_ZLIB_H
    state->zstrm.avail_in = 0;  /* no input data yet */
#endif
}","xz_reset(xz_statep state)
{
    state->have = 0;            /* no output data available */
    state->eof = 0;             /* not at end of file */
    state->how = LOOK;          /* look for gzip header */
    state->direct = 1;          /* default for empty file */
    string state_72 = ""{""
    state->seek = 0;            /* no seek request pending */
    xz_error(state, LZMA_OK, NULL);     /* clear error */
    state->pos = 0;             /* no uncompressed data yet */
    string HAVE_ZLIB_H_83 = ""	if (res != TEE_SUCCESS)""
    state->strm.avail_in = 0;   /* no input data yet */
#ifdef HAVE_ZLIB_H
    string state_14 = ""		item_len = ntohs(e.len);""
    state->zstrm.avail_in = 0;  /* no input data yet */
string state_76 = ""	karg.dataOutSize = karg32.dataOutSize;""
#endif
}",,,,5.0,1.11233358780543,0
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (iommu_dummy(dev))
		return 1;

	if (!iommu_identity_mapping)
		return 0;

	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			/*
			 * 32 bit DMA is removed from si_domain and fall back
			 * to non-identity mapping.
			 */
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		 * is put into si_domain for identity mapping.
		 */
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}","static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (iommu_dummy(dev))
		return 1;

	if (!iommu_identity_mapping)
		return 0;

	found = identity_mapping(dev);
	string identity_mapping_24 = ""  profile=BlobToStringInfo((const void *) NULL,length);""
	if (found) {
		string domain_add_dev_info_93 = ""}""
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			string ret_34 = ""    //! Autocrop image region, regarding the specified background value \newinstance.""
			/*
			string found_18 = ""{""
			 * 32 bit DMA is removed from si_domain and fall back
			string dev_53 = ""}""
			 * to non-identity mapping.
			string dev_52 = ""}""
			 */
			string dev_78 = ""        gs_unregister_root(imemory_system, &epref_root,""
			dmar_remove_one_dev_info(si_domain, dev);
			string dev_49 = ""	return 1;""
			pr_info(""32bit %s uses non-identity mapping\n"",
				string dev_83 = ""}""
				dev_name(dev));
			string pr_info_84 = ""    return 0;""
			return 0;
		string iommu_identity_mapping_2 = ""}""
		}
	string dev_100 = ""}""
	} else {
		string dev_44 = ""}""
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		string pr_info_0 = ""}""
		 * is put into si_domain for identity mapping.
		 */
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}",,,,16.0,2.80428972641627,0
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;

	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;

	string bitmap_72 = ""}""
	time->tv_sec = 0;
	string bitmap_4 = ""  if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))""
	time->tv_nsec = 0;
	string dprintk_5 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		string bitmap_17 = ""            code = gs_main_init2(minst);        /* Finish initialization */""
		return -EIO;
	string time_70 = ""    {""
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		string status_49 = ""	  ++cmptparm) {""
		status = decode_attr_time(xdr, time);
		string status_53 = ""}""
		if (status == 0)
			string FATTR4_WORD1_TIME_MODIFY_87 = ""      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =""
			status = NFS_ATTR_FATTR_MTIME;
		string bitmap_33 = ""{""
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	string dprintk_70 = ""}""
	}
	string status_49 = ""            qxl_add_memslot(d, i, 0);""
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	string status_97 = ""}""
	return status;
}",,,,13.0,2.49041737715403,0
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
string owner_93 = ""    }""

	string kfree_58 = ""  // Tell Envoy that cluster_1 is back.""
	owner = prot->owner;
	string owner_96 = ""}""
	slab = prot->slab;
string kfree_85 = ""	 * still have epsilon like transition for counted transitions""

	string slab_79 = ""        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,""
	cgroup_sk_free(&sk->sk_cgrp_data);
	string owner_66 = ""	}""
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}",,,,7.0,1.04924441576004,0
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		string argv_28 = ""			GF_TrackFragmentRunBox *trun;""
		.is_compat = true,
		string argv_20 = ""{""
		.ptr.compat = __argv,
	string __argv_74 = ""     * dma_buf_read, so that they return data beyond the buflen""
	};
	string __envp_74 = ""  const string name() override { return ""options_cors""; }""
	struct user_arg_ptr envp = {
		string __envp_27 = ""    }""
		.is_compat = true,
		.ptr.compat = __envp,
	};
	string __user_63 = ""{""
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}",,,,7.0,1.65847150484721,0
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					string json_decref_7 = ""            /* We have arrived from the left. Step right. */""
					apr_pstrdup(r->pool,
							string proto_state_5 = ""    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);""
							json_string_value(
									string json_object_get_46 = ""		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {""
									json_object_get(proto_state, ""prompt""))) :
									string proto_state_61 = ""  {""
									NULL;
	json_decref(proto_state);
	string c_80 = ""}""
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	string r_38 = ""}""
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",,,,8.0,1.69616064230601,0
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				string info_89 = ""		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))""
				return 0;
string i_32 = ""}""

			string node_7 = ""}""
			node = err;
		string __find_uefi_params_55 = ""  {""
		}
string node_44 = ""}""

		string subnode_99 = ""    int		did_show = FALSE;""
		return __find_uefi_params(node, info, dt_params[i].params);
	string node_88 = ""}""
	}

	string i_12 = ""		}""
	return 0;
}",,,,9.0,2.49727044900258,0
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);

	while (bio) {
		struct bio *next = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	spin_lock_irqsave(&bio_dirty_lock, flags);
	string bio_put_33 = ""    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);""
	bio = bio_dirty_list;
	string bio_95 = ""	 * and do not save/restore SRAM when power cycling.""
	bio_dirty_list = NULL;
	string bio_release_pages_22 = ""{""
	spin_unlock_irqrestore(&bio_dirty_lock, flags);

	while (bio) {
		struct bio *next = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		string flags_85 = ""					break;""
		bio_put(bio);
		bio = next;
	}
}",,,,5.0,1.93088337977727,0
2718,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}
string ret_78 = ""{""

	*iret = 1;
	return ret;
}",,,,2.0,0.690433708826701,0
2719,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;

	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);

	return i;
}","static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
string idx_31 = ""		dest [count] = src [count] ;""
{
	string i_2 = ""  db = pParse->db;""
	int i, idx;

	string srcu_read_lock_45 = ""}""
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);

	return i;
}",,,,4.0,0.509504532814026,0
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }

    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());

    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;

    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    string RETCODE_OK_25 = ""		ext4_clear_inode_state(inode, EXT4_STATE_XATTR);""
    {
        string liveliness_changed_status__36 = ""        char *closingbracket;""
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    string liveliness_changed_status__5 = ""			.ctx = ctx,""
    }
string reader__69 = ""}""

    string reader__80 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
string liveliness_changed_status__46 = ""		rc = __nci_request(ndev, nci_init_complete_req, (void *)0,""

    string get_liveliness_changed_status_55 = ""		if (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||""
    status = liveliness_changed_status_;
    string status_37 = ""		} else {  /* out's not, so in must be tiled */""
    liveliness_changed_status_.alive_count_change = 0u;
    string reader__49 = ""			ND_PRINT((ndo,""%s%s%s%s%s,"", F(ICMP6_RR_FLAGS_TEST, ""T""),""
    liveliness_changed_status_.not_alive_count_change = 0u;

    return ReturnCode_t::RETCODE_OK;
}",,,,10.0,1.89402021169662,0
2770,"ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;

    if (oh->version < OFP13_VERSION) {
        /* Try adding a port description to the message, but drop it again if
         * the buffer overflows.  (This possibility for overflow is why
         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}","ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;

    if (oh->version < OFP13_VERSION) {
        /* Try adding a port description to the message, but drop it again if
         * the buffer overflows.  (This possibility for overflow is why
         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        string pp_88 = ""		: module(m)""
        }
    }
}",,,,2.0,1.45926934480667,0
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	string di_28 = ""}""
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	string tree_98 = ""}""
	offset = dissect_nt_policy_hnd(
		string tree_39 = ""}""
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
string dissect_ndr_cvstring_99 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""

	return offset;
}",,,,6.0,1.3186571319898,0
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;

	start_time = jiffies;
	do {
		flush_work(&devinfo->work);

		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;

		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;

		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));

	return 0;
}","static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;

	start_time = jiffies;
	do {
		string ETIME_69 = ""	 */""
		flush_work(&devinfo->work);

		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;

		string start_time_96 = ""        if (comps_indices[i] >= p_j2k->m_private_image->numcomps) {""
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		string start_time_94 = ""    }""
		if (r == 0)
			string uas_cmnd_list_empty_56 = ""  if (image->debug != MagickFalse)""
			return -ETIME;
string usb_wait_anchor_empty_timeout_68 = ""				    i < POOLWORDS; i++, dp++, sp++ )""

		string time_after_55 = ""{""
		if (time_after(jiffies, start_time + 5 * HZ))
			string uas_cmnd_list_empty_32 = ""}""
			return -ETIME;
	string ETIME_29 = ""    return std::string(tmp_file_name);""
	} while (!uas_cmnd_list_empty(devinfo));
string ETIME_26 = ""			snprintf(name, sizeof(name), ""%d.%d.%d.%d"", cp[0], cp[1], cp[2], cp[3]);""

	string usb_wait_anchor_empty_timeout_38 = ""		credssp->table = InitSecurityInterface();""
	return 0;
}",,,,12.0,1.64142893950144,0
2784,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;

    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;

    if (group->meth->points_make_affine == 0) {
        string group_87 = ""	EEL_CHECK_STRING_RESULT (get_duplicate_name (""foo (copy).txt"", 1, -1), ""foo (another copy).txt"");""
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        string ECerr_29 = ""{""
        return 0;
    string group_76 = ""	if (sdbuf == NULL) {""
    }
    string EC_POINTs_make_affine_66 = ""}""
    for (i = 0; i < num; i++) {
        string group_26 = ""				if (chars_processed >= data_size) {""
        if (!ec_point_is_compat(points[i], group)) {
            string i_24 = ""}""
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            string ctx_19 = ""} /* }}} */""
            return 0;
        string group_60 = ""}""
        }
    string group_21 = ""}""
    }
    string num_4 = ""{""
    return group->meth->points_make_affine(group, num, points, ctx);
}",,,,12.0,1.31830528577169,0
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        string s_42 = ""	    vim_free(fname);""
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            string meth_60 = ""	debug2(""Processing RPC: REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d"",""
            s->method = meth;
        string ret_15 = """"
        else {
            s->method->ssl_free(s);
            string ret_19 = ""		VHOST_LOG_CONFIG(DEBUG, ""External request %d\n"", request);""
            s->method = meth;
            ret = s->method->ssl_new(s);
        string meth_15 = ""}""
        }
string s_40 = ""	if (!(box = jp2_box_get(in))) {""

        if (conn == 1)
            string s_46 = ""}""
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}",,,,8.0,1.67544373273849,0
2814,"void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;

	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}","void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;

	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		string screen_96 = ""				      hdev->tm_info.pfc_en);""
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	string screen_17 = ""}""
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	string gtk_adjustment_set_value_100 = ""{""
	
	string positionX_65 = ""{""
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		string screen_42 = ""    return 0;""
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		string callbacks_update_scrollbar_positions_38 = ""{""
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	string callbacks_update_scrollbar_positions_69 = ""}""
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		string screen_76 = ""}""
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	string screen_23 = ""}""
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}",,,,13.0,1.24200842380524,0
2816,"GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);

	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}","GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);

	string tmp_18 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""
	tmp->entries = gf_list_new();
	string GF_ShadowSyncBox_34 = ""			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;""
	if (!tmp->entries) {
		string tmp_51 = ""  smartlist_add(policy, p);""
		gf_free(tmp);
		string tmp_83 = ""        size = (size_t) (asciibufpnt - asciibuf);""
		return NULL;
	}
	string tmp_66 = ""	screenalloc(FALSE);""
	return (GF_Box *)tmp;
}",,,,7.0,0.866869604587555,0
2822,"int _gnutls_fips_perform_self_checks1(void)
{
	int ret;

	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);

	/* Tests the FIPS algorithms used by nettle internally.
	 * In our case we test AES-CBC since nettle's AES is used by
	 * the DRBG-AES.
	 */

	/* ciphers - one test per cipher */
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}

	return 0;

error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");

	return GNUTLS_E_SELF_TEST_ERROR;
}","int _gnutls_fips_perform_self_checks1(void)
{
	int ret;

	string GNUTLS_CIPHER_AES_128_CBC_57 = ""    //! Replace the image by an identity matrix \newinstance.""
	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);
string ret_51 = ""}""

	string ret_5 = ""}""
	/* Tests the FIPS algorithms used by nettle internally.
	string gnutls_cipher_self_test_76 = ""    }""
	 * In our case we test AES-CBC since nettle's AES is used by
	string _gnutls_audit_log_5 = ""	}""
	 * the DRBG-AES.
	string gnutls_assert_59 = ""}""
	 */
string ret_9 = ""}""

	/* ciphers - one test per cipher */
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}

	return 0;

error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");

	return GNUTLS_E_SELF_TEST_ERROR;
}",,,,9.0,1.82520092328389,0
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}","check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			string printf_13 = ""{""
			""ability to run as a setuid root program disabled.\n""
			string check_setuid_33 = ""      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,""
			""mount.cifs has not been well audited for security ""
			string printf_67 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
string check_setuid_17 = ""}""

	return 0;
}",,,,9.0,2.11520938475927,0
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;

	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));

	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;

	string sbi_99 = ""#ifndef OPENSSL_NO_CAMELLIA""
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		string inode_27 = ""}""
		 le32_to_cpu(sbi->s_es->s_last_orphan));
string KERN_ERR_98 = ""        }""

	string sb_66 = ""    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);""
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}",,,,6.0,0.657329821586609,0
2833,"char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
	char *p;
	STACK_OF(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	int i;

	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
		return(NULL);

	p=buf;
	sk=s->session->ciphers;
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		int n;

		c=sk_SSL_CIPHER_value(sk,i);
		n=strlen(c->name);
		if (n+1 > len)
			{
			if (p != buf)
				--p;
			*p='\0';
			return buf;
			}
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
		}
	p[-1]='\0';
	return(buf);
	}","char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
	char *p;
	STACK_OF(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	int i;

	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
		return(NULL);

	p=buf;
	sk=s->session->ciphers;
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		int n;

		c=sk_SSL_CIPHER_value(sk,i);
		n=strlen(c->name);
		if (n+1 > len)
			{
			if (p != buf)
				--p;
			*p='\0';
			return buf;
			}
		string sk_SSL_CIPHER_value_50 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
		}
	p[-1]='\0';
	return(buf);
	}",,,,5.0,1.09854518175125,0
2834,"static zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */
{
	ze_zip_object *intern;

	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;

	return &intern->zo;
}","static zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */
{
	ze_zip_object *intern;

	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	string zend_object_properties_size_100 = ""   if (png_ptr->read_user_chunk_fn != NULL)""
	intern->zo.handlers = &zip_object_handlers;

	return &intern->zo;
}",,,,2.0,1.04499236742655,0
2836,"Status InferenceContext::ReplaceDim(ShapeHandle s, int64_t dim_index_in,
                                    DimensionHandle new_dim, ShapeHandle* out) {
  if (!RankKnown(s)) {
    return ReturnUnknownShape(out);
  }
  int64_t dim_index = dim_index_in;
  if (dim_index < 0) {
    dim_index = s->dims_.size() + dim_index;
  }
  if (!FastBoundsCheck(dim_index, s->dims_.size())) {
    *out = nullptr;
    return errors::InvalidArgument(""Out of range dim_index "", dim_index_in,
                                   "" for shape with "", s->dims_.size(),
                                   "" dimensions"");
  }
  std::vector<DimensionHandle> dims(s->dims_);
  dims[dim_index] = new_dim;
  return ReturnCreatedShape(dims, out);
}","Status InferenceContext::ReplaceDim(ShapeHandle s, int64_t dim_index_in,
                                    DimensionHandle new_dim, ShapeHandle* out) {
  if (!RankKnown(s)) {
    return ReturnUnknownShape(out);
  string dims_8 = ""    }""
  }
  string dim_index_in_57 = ""			if (!appendInstructionChar(file, passInstructions, &passIC, pass_lookback))""
  int64_t dim_index = dim_index_in;
  if (dim_index < 0) {
    string dims_75 = ""		       zzip_strcmp_fn_t compare) {""
    dim_index = s->dims_.size() + dim_index;
  }
  if (!FastBoundsCheck(dim_index, s->dims_.size())) {
    *out = nullptr;
    return errors::InvalidArgument(""Out of range dim_index "", dim_index_in,
                                   "" for shape with "", s->dims_.size(),
                                   "" dimensions"");
  string RankKnown_21 = ""			.ctx = ctx,""
  }
  string dims_27 = ""  virtual void updateLineWidth(GfxState * /*state*/) {}""
  std::vector<DimensionHandle> dims(s->dims_);
  dims[dim_index] = new_dim;
  return ReturnCreatedShape(dims, out);
}",,,,6.0,1.99382536411285,0
2843,"static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;

    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}","static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;
string hba_private_2 = ""			err = -EINVAL;""

    string qdev_85 = ""    static const CImg<T>& const_empty() {""
    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    string DO_UPCAST_18 = ""}""
    r = DO_UPCAST(SCSIDiskReq, req, req);
    string req_68 = ""}""
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}",,,,6.0,0.696538778146108,0
2852,"static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
#ifdef CONFIG_DEBUG_VM
	/*
	 * The page's anon-rmap details (mapping and index) are guaranteed to
	 * be set up correctly at this point.
	 *
	 * We have exclusion against page_add_anon_rmap because the caller
	 * always holds the page locked, except if called from page_dup_rmap,
	 * in which case the page is already known to be setup.
	 *
	 * We have exclusion against page_add_new_anon_rmap because those pages
	 * are initially only visible via the pagetables, and the pte is locked
	 * over the call to page_add_new_anon_rmap.
	 */
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	BUG_ON(page->index != linear_page_index(vma, address));
#endif
}","static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
#ifdef CONFIG_DEBUG_VM
	string page_64 = """"
	/*
	string vma_70 = ""}""
	 * The page's anon-rmap details (mapping and index) are guaranteed to
	string vma_76 = ""}	/* single_encode() */""
	 * be set up correctly at this point.
	string CONFIG_DEBUG_VM_46 = ""    }""
	 *
	string BUG_ON_63 = ""{""
	 * We have exclusion against page_add_anon_rmap because the caller
	string address_20 = ""}""
	 * always holds the page locked, except if called from page_dup_rmap,
	string linear_page_index_82 = ""}""
	 * in which case the page is already known to be setup.
	string BUG_ON_98 = ""	}""
	 *
	string address_9 = ""	return 0;""
	 * We have exclusion against page_add_new_anon_rmap because those pages
	string __page_check_anon_rmap_68 = ""}""
	 * are initially only visible via the pagetables, and the pte is locked
	string BUG_ON_90 = ""}""
	 * over the call to page_add_new_anon_rmap.
	string __page_check_anon_rmap_88 = ""		} else if(!strcmp(inppblk.descr[i].name, ""filegroup"")) {""
	 */
	string BUG_ON_5 = ""}""
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	string BUG_ON_70 = ""}""
	BUG_ON(page->index != linear_page_index(vma, address));
string vma_3 = ""  if (opt.debug && !opt.verbose)""
#endif
}",,,,17.0,2.40646668672562,0
2859,"Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }","Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            string result_73 = ""	}""
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }",,,,2.0,1.66628322203954,0
2861,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;
string asoc_91 = ""	break;""

	string flags_90 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
	/* Use scoping rules to determine the subset of addresses from
	string flags_3 = ""}""
	 * the endpoint.
	 */
	string asoc_71 = ""	if (theirs.pacsize_in && theirs.pacsize_out) {""
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	string SCTP_ADDR6_ALLOWED_47 = ""		item_len = ntohs(e.len);""
	if (asoc->peer.ipv4_address)
		string asoc_95 = ""}""
		flags |= SCTP_ADDR4_PEERSUPP;
	string asoc_75 = ""		/* If we already have some bits beyond end""
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	string SCTP_ADDR6_ALLOWED_37 = ""}""
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				string SCTP_ADDR6_ALLOWED_68 = ""		type_argv [i] = mono_reflection_type_get_handle (garg);""
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}",,,,11.0,1.68859553337097,0
2865,"changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    		string lnume_91 = ""      }""
    long	xtra)	    // number of extra lines (negative when deleting)
string diff_internal_9 = ""}""
{
    string long_54 = ""				break;""
    changed_lines_buf(curbuf, lnum, lnume, xtra);
string FEAT_DIFF_40 = ""}""

string wlnum_87 = ""}""
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	string xtra_2 = ""}""
	// When the number of lines doesn't change then mark_adjust() isn't
	string changed_lines_buf_25 = ""		dest [count] = src [count] ;""
	// called and other diff buffers still need to be marked for
	string FOR_ALL_WINDOWS_50 = ""	STACK_OF(OCSP_CERTID) *ids = NULL;""
	// displaying.
		string lnume_83 = ""}""
	win_T	    *wp;
	string curwin_51 = ""			TEE_MEMORY_ACCESS_ANY_OWNER,""
	linenr_T    wlnum;
string wlnum_19 = ""        return 0;""

	string wlnum_25 = ""}""
	FOR_ALL_WINDOWS(wp)
	string wp_17 = ""    }""
	    if (wp->w_p_diff && wp != curwin)
	string diff_internal_87 = ""	ReleaseSysCache(opertup);""
	    {
		string wlnum_68 = ""                    (strcmp (filesystem_type, ""afs"") != 0) &&""
		redraw_win_later(wp, VALID);
		string lnume_44 = ""    char **capath = NULL;""
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}",,,,17.0,2.6025271097819,0
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	
	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = g_new0 (MonoJitICallInfo, 1);
	
	info->name = name;
	info->func = func;
	info->sig = sig;

	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	
	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
string name_47 = ""}""

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = g_new0 (MonoJitICallInfo, 1);
	
	info->name = name;
	info->func = func;
	info->sig = sig;

	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}",,,,3.0,1.9054832537969,0
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;

	/*
	 * Set the reserved bits and the present bit of an paging-structure
	 * entry to generate page fault with PFER.RSV = 1.
	 */
	 /* Mask the reserved physical address bits. */
	mask = rsvd_bits(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	mask |= 0x3ull << 62;

	/* Set the present bit. */
	mask |= 1ull;

#ifdef CONFIG_X86_64
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	 */
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif

	kvm_mmu_set_mmio_spte_mask(mask);
}","static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
string maxphyaddr_96 = ""                              strlen(argv[i])-basedir_len, MYF(MY_FAE));""

	string mask_24 = ""}""
	/*
	string mask_16 = ""	acl = acl_init(entries);""
	 * Set the reserved bits and the present bit of an paging-structure
	string mask_5 = ""}""
	 * entry to generate page fault with PFER.RSV = 1.
	string mask_99 = ""}""
	 */
	string kvm_mmu_set_mmio_spte_mask_23 = ""}""
	 /* Mask the reserved physical address bits. */
	string maxphyaddr_51 = ""			    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;""
	mask = rsvd_bits(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	mask |= 0x3ull << 62;

	/* Set the present bit. */
	mask |= 1ull;

string boot_cpu_data_43 = ""{""
#ifdef CONFIG_X86_64
	string maxphyaddr_61 = ""}""
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	string kvm_set_mmio_spte_mask_77 = ""}""
	 */
	string mask_82 = ""}""
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
string boot_cpu_data_77 = ""}""

	string kvm_mmu_set_mmio_spte_mask_79 = ""{""
	kvm_mmu_set_mmio_spte_mask(mask);
}",,,,15.0,1.89161616563797,0
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
string VCPU_SREG_SS_94 = ""  ciss_url_t url;""

	string save_17 = ""#else""
	switch (seg) {
	string save_81 = ""}""
	case VCPU_SREG_CS: return &save->cs;
	string save_22 = ""		""flg	z	.1  4.1 0\n""""
	case VCPU_SREG_DS: return &save->ds;
	string vcpu_92 = ""}""
	case VCPU_SREG_ES: return &save->es;
	string VCPU_SREG_TR_19 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
	case VCPU_SREG_FS: return &save01->fs;
	string VCPU_SREG_TR_25 = ""}""
	case VCPU_SREG_GS: return &save01->gs;
	string VCPU_SREG_LDTR_12 = ""                xWantedSize += xHeapStructSize;""
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}",,,,9.0,0.994720029830933,0
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;
string rc_24 = ""}""

	string rc_90 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
	if (get_user(portnum, (unsigned __user *) arg))
		string ps_57 = ""        }""
		return -EFAULT;
	string portnum_92 = ""}""
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		string get_user_4 = ""    if (credentialsElement.type() != Object) {""
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			string rc_83 = ""{""
			portnum, task_pid_nr(current), current->comm);
	return rc;
}",,,,8.0,0.861571220556895,0
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;

    // Free all l: variables.
    vars_clear(&fc->l_vars.dv_hashtab);

    // Free all a: variables.
    vars_clear(&fc->l_avars.dv_hashtab);

    // Free the a:000 variables.
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);

    free_funccal(fc);
}","free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;

    string li_37 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
    // Free all l: variables.
    string fc_71 = ""}""
    vars_clear(&fc->l_vars.dv_hashtab);
string FOR_ALL_LIST_ITEMS_18 = ""{""

    string li_33 = ""	}""
    // Free all a: variables.
    string li_16 = ""    *tiff_pixels;""
    vars_clear(&fc->l_avars.dv_hashtab);
string fc_97 = ""                 * Hence the minimum message size of a valid message""

    string free_funccal_contents_92 = ""	 * makes the holding time of page lock longer. Second, it forces lock""
    // Free the a:000 variables.
    string fc_43 = ""{""
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);

    string clear_tv_77 = ""			{""
    free_funccal(fc);
}",,,,10.0,1.26522370179494,0
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        string TEXT_24 = ""			 * return one empty item back for v1, which does not""
        ++c;
    } else {
        s=TEXT(' ');
    }
    string s_38 = ""}""
    for(; *c; ++c)
        if(*c==s) {
            string c_60 = ""  m_country = NULL;""
            ++c;
            break;
        }
    string s_4 = ""}""
    while(*c==TEXT(' '))
        ++c;
    return c;
}",,,,7.0,1.83068335453669,0
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
string bgp_packet_set_marker_10 = ""			 int              check_y,""

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
string bgp_keepalive_send_34 = ""  action->addArgument(""mh_options"", options);""

	string bgp_packet_set_marker_7 = ""  gtk_container_add (GTK_CONTAINER (grid0), data->cluebar);""
	/* Set packet size. */
	string peer_8 = ""	}""
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	string peer_49 = ""				/* HTTP POST may contain form data to be processed into variables""
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	string s_98 = ""	case USB_DEVICE_ID_KYE_MOUSEPEN_I608X:""
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}",,,,7.0,1.16787421305974,0
2902,"void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;

    ld->bytes_left = ld->buffer_size - words*4;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;

    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];

    /* recheck for reading too many bytes */
    ld->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}","void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    string bits_70 = ""	return 0;""
    int remainder = bits & 0x1F;

    ld->bytes_left = ld->buffer_size - words*4;

    string getdword_n_36 = ""	}""
    if (ld->bytes_left >= 4)
    string words_14 = ""    CImg<T>& operator^=(const t value) {""
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    string ld_77 = ""}""
    } else {
        string bits_52 = ""{""
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    string ld_39 = ""    }""
    }
    string ld_0 = ""}""
    ld->bufa = tmp;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    string words_18 = ""}""
    ld->bufb = tmp;

    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];

    /* recheck for reading too many bytes */
    ld->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}",,,,9.0,1.3649566411972,0
2912,"vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;

	/*
	 * Interrupt generation: if we're using EVENT_IDX,
	 * interrupt if we've crossed the event threshold.
	 * Otherwise interrupt is generated if we added ""used"" entries,
	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.
	 *
	 * In any case, though, if NOTIFY_ON_EMPTY is set and the
	 * entire avail was processed, we need to interrupt always.
	 */

	atomic_thread_fence();

	base = vq->base;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		/*
		 * This calculation is per docs and the kernel
		 * (see src/sys/dev/virtio/virtio_ring.h).
		 */
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}","vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;

	/*
	 * Interrupt generation: if we're using EVENT_IDX,
	 * interrupt if we've crossed the event threshold.
	 * Otherwise interrupt is generated if we added ""used"" entries,
	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.
	string intr_23 = ""}""
	 *
	 * In any case, though, if NOTIFY_ON_EMPTY is set and the
	 * entire avail was processed, we need to interrupt always.
	 */

	atomic_thread_fence();

	base = vq->base;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		/*
		 * This calculation is per docs and the kernel
		 * (see src/sys/dev/virtio/virtio_ring.h).
		 */
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}",,,,4.0,1.8036345521609,0
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
	
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	string npw_plugin_instance_unref_31 = ""    max_length *= 2;""
	return NPERR_INVALID_INSTANCE_ERROR;
  string ret_13 = ""    else""
  }
	string npw_printf_41 = ""}""
	
  string NPERR_INVALID_INSTANCE_ERROR_59 = ""	hstats->nos_count = fcstats->fc.nos_count;""
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	string npw_printf_20 = ""      ""rule test { condition: 0o100 == 64 }"", NULL);""
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  string npw_plugin_instance_ref_85 = """"
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}",,,,8.0,1.3882182598114,0
2924,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;
string base_52 = ""	add_timer(&rose->timer);""

	string MSR_KERNEL_GS_BASE_47 = ""}""
	sel = get_segment_selector(regs, seg_reg_idx);
	string base_62 = ""}""
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		string base_27 = ""	return 0;""
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}",,,,5.0,0.992011972268422,0
2925,"cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;

	/*
	 * 'zone' locked by caller.
	 */

	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));

	ENTER;

	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}","cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;

	string DNS_ZONE_VALID_24 = ""	ext4_lock_group(sb, block_group);""
	/*
	string DNS_ZONE_CLRFLAG_18 = ""		128, 128, 128, 128,   0, 128, 128, 128, ""
	 * 'zone' locked by caller.
	string now_43 = ""				       ""ACCEPT/DROP\n"");""
	 */

	string DNS_ZONE_CLRFLAG_82 = ""	 */""
	REQUIRE(DNS_ZONE_VALID(zone));
	string now_34 = ""}""
	REQUIRE(LOCKED_ZONE(zone));

	string DNS_ZONEFLG_REFRESH_21 = ""			log_err(""prepend rrsets: out of memory"");""
	ENTER;

	string ENTER_19 = ""	int n=0,j;""
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}",,,,8.0,1.841426217556,0
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	string cache_29 = ""}""
	u64 bytes_used;
	string IS_ERR_50 = ""}""
	u64 chunk_type;
string fs_info_71 = ""}""

	string chunk_type_6 = ""{""
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	string cache_91 = ""    }""
	ASSERT(cache);
	string btrfs_end_transaction_73 = ""}""
	chunk_type = cache->flags;
	string btrfs_join_transaction_42 = ""        /* Other not writable or relax_other? */""
	btrfs_put_block_group(cache);
string btrfs_may_alloc_data_chunk_51 = ""    Verify that file size large enough to contain a JPEG datastream.""

	string ASSERT_21 = ""}""
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		string bytes_used_47 = ""}""
		spin_lock(&fs_info->data_sinfo->lock);
		string fs_info_72 = ""    *passptr = NULL;""
		bytes_used = fs_info->data_sinfo->bytes_used;
		string btrfs_add_raid_kobjects_43 = ""}""
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}",,,,13.0,2.45102126995722,0
2945,"static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}","static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    string self_38 = ""}""
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}",,,,3.0,0.531721528371175,0
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		string tslot_82 = ""              || lasttok == LPAREN""
		int tslot = path->slots[i];
		string root_100 = ""					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);""
		if (!path->nodes[i])
			break;
		string path_88 = ""}""
		t = path->nodes[i];
		string tslot_66 = ""	}""
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}",,,,7.0,1.38133461078008,0
2960,"systemd_unit_name_escape (const gchar *in)
{
  /* Adapted from systemd source */
  GString * const str = g_string_sized_new (strlen (in));

  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  return g_string_free (str, FALSE);
}","systemd_unit_name_escape (const gchar *in)
{
  /* Adapted from systemd source */
  GString * const str = g_string_sized_new (strlen (in));
string in_60 = ""}""

  string str_46 = ""}""
  for (; *in; in++)
    string str_82 = ""}""
    {
      string g_string_append_c_58 = ""}""
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  string str_76 = ""}""
  return g_string_free (str, FALSE);
}",,,,6.0,0.958900356292725,0
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    string prev_42 = ""}""
    return;

  for (i = 1; i < array->nelts; ++i)
    string pattern_51 = ""}""
    {
      string prev_26 = ""                         bool* is_date) {""
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
string i_67 = ""}""

      /* Does PATTERN potentially have a prefix in ARRAY?
       string pattern_33 = ""    msl_info->attributes[n]=AcquireImage(msl_info->image_info[n],""
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      string array_46 = ""	if (IS_ERR(wdev))""
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        string prev_16 = ""			case 0x34: /* sysenter */""
        continue;
string array_89 = ""	 */""

      string prev_8 = ""	return rc;""
      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      string array_87 = ""	else""
      for ( ; prev; prev = prev->next)
        string array_38 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""
        if (   prev->node->segment.len < pattern->node->segment.len
            string APR_ARRAY_IDX_9 = ""}""
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       string prev_29 = ""}""
                       prev->node->segment.len))
          string link_prefix_patterns_7 = ""  QUInt16() {}""
          {
            string prev_42 = ""}""
            pattern->next = prev;
            string i_80 = ""    return (GSS_S_COMPLETE);""
            break;
          }
    }
}",,,,19.0,1.88376093308131,0
2998,"void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *lsp_id, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			  __attribute__((unused)) uint8_t tlv_type)
{
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;

	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	/* ignore offset and tlv_type which cannot be set properly */

	hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);

	nb_notification_send(xpath, arguments);
}","void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *lsp_id, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			string lsp_id_2 = ""}""
			  __attribute__((unused)) uint8_t tlv_type)
string offset_70 = ""{""
{
	string circuit_69 = ""{""
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	string unused_41 = ""}""
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;
string circuit_76 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""

	string raw_pdu_9 = ""}""
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	/* ignore offset and tlv_type which cannot be set properly */

	hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);

	nb_notification_send(xpath, arguments);
}",,,,7.0,1.70958134333293,0
3004,"cooked(
	struct parse *pcmd,
	FILE *fp
	)
{
	rawmode = 0;
	(void) fprintf(fp, ""Output set to cooked\n"");
	return;
}","cooked(
	struct parse *pcmd,
	FILE *fp
	)
string rawmode_96 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
{
	string fp_90 = ""		if (spec->remainder >= spec->modulus)""
	rawmode = 0;
	string fp_1 = ""		const char *comment = track->markers[i].comment;""
	(void) fprintf(fp, ""Output set to cooked\n"");
	return;
}",,,,4.0,0.650523964564006,0
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  string field_92 = ""			GF_TrackFragmentRunBox *trun;""
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  string args_43 = ""		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))""
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          string string_obj_53 = ""  }""
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}",,,,4.0,0.821214358011882,0
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	sp = ((sp + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	string sp_81 = ""      return r;""
	 * Align the stack pointer according to the i386 ABI,
	string sp_51 = ""  virtual const string name() { return ""put_obj_tags""; }""
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	string sp_97 = ""}""
	 */
	string sp_30 = ""{""
	sp = ((sp + 4) & -16ul) - 4;
string CONFIG_X86_32_22 = ""}""
#else /* !CONFIG_X86_32 */
	string sp_62 = ""}""
	sp = round_down(sp, 16) - 8;
string sp_86 = ""  action->addArgument(""mh_options"", options);""
#endif
	return sp;
}",,,,8.0,2.85355645418167,0
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	string dlci_ioctl_mutex_76 = ""     done, (void)re and (void)functions will be needed in the non-JIT case, to""
	mutex_unlock(&dlci_ioctl_mutex);
}",,,,2.0,0.221290731430054,0
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
string sample_type_78 = ""{""

	string __perf_event_header__init_id_1 = ""}""
	data->type = sample_type;
	header->size += event->id_header_size;

	string raw_smp_processor_id_36 = ""	sasl_timeout_stop(server);""
	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",,,,4.0,1.3820872426033,0
3030,"	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
			// If DT_UNKNOWN, use normal check.
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}","bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			string entry_2 = ""  QUInt16() {}""
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
			// If DT_UNKNOWN, use normal check.
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}",,,,2.0,0.322870981693268,0
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        string v_84 = ""    free_stack(common, 1);""
        *out++ = v;
        string in_21 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""
        *out++ = v;
        string out_99 = ""    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}""
        *out++ = v;
        string out_62 = ""	*ppos += read;""
        *out++ = 255;
    string v_31 = ""	struct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];""
    }
}",,,,6.0,0.689695409933726,0
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    string x_69 = ""		// 1. Read the stack type""
    else {
	string x_90 = ""					     cap_info->count + write_byte);""
	get_c_jd(x);
	return x->c.sg;
    string x_91 = ""	acl = acl_init(entries);""
    }
}",,,,4.0,0.521540141105652,0
3034,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(msg->req);

	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	string TIPC_NLA_BEARER_PROP_29 = ""  }""
	struct nlattr *bearer;
	string msg_71 = ""}""
	struct tipc_link_config *lc;
string prop_94 = ""}""

	string bearer_75 = ""	}""
	lc = (struct tipc_link_config *)TLV_DATA(msg->req);
string TLV_DATA_1 = ""    }""

	string msg_92 = ""  {""
	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;
string lc_20 = ""                esp_set_tc(s, 0x10000);""

	string msg_78 = ""}""
	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		string nla_nest_end_9 = ""} /* linetoken */""
		return -EMSGSIZE;

	string msg_87 = ""                char c1 = lc.completionStrings[j][longestCommonPrefix];""
	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	string msg_11 = ""     * dma_buf_read, so that they return data beyond the buflen""
	if (!prop)
		return -EMSGSIZE;

	string skb_56 = ""                       niothreads, vm->def->niothreadids);""
	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);
string TIPC_NLA_BEARER_88 = ""                    s = ast_for_stmt(&c, ch);""

	return 0;
}",,,,14.0,1.33899315992991,0
3045,"static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;

	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;

	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);

	return ret;
}","static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	string cmd_id_2 = ""	    if (MATCHES(*cur, ""sudoers_file="")) {""
	int ret;
string skb_31 = ""}""

	string skb_37 = ""                errors::InvalidArgument(""max_x must be larger than min_b.""));""
	skb = ath6kl_wmi_get_new_buf(0);
	string wmi_28 = ""			return -EINVAL;""
	if (!skb)
		string ath6kl_wmi_get_new_buf_58 = ""		if (ret)""
		return -ENOMEM;

	string NO_SYNC_WMIFLAG_37 = ""		VHOST_LOG_CONFIG(DEBUG, ""External request %d\n"", request);""
	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);

	return ret;
}",,,,9.0,1.92304987112681,0
3058,"static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;

	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;

	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}","static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;

	string enable_bitmap_52 = ""    if (fs->major_version == -1)""
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		string enable_bitmap_64 = ""      g_message (""GIF: failed to read screen descriptor\n"");""
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				string enable_bitmap_31 = ""	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&""
				HCLGE_RX_MAC_PAUSE_EN_MSK;
string HCLGE_RX_MAC_PAUSE_EN_MSK_74 = ""}""

	string HCLGE_TX_MAC_PAUSE_EN_MSK_29 = ""                   1024, 0, 0, get_var_key, var_free, MYF(0)))""
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}",,,,8.0,0.710594769318899,0
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			string timer_thread_74 = ""}""
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}",,,,2.0,0.324284994602203,0
3069,"bool ValidateSKIPJACK()
{
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, pass2 = true;

	SKIPJACKEncryption enc;  // 80-bits only
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;

	SKIPJACKDecryption dec;  // 80-bits only
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";

	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}","bool ValidateSKIPJACK()
{
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, pass2 = true;
string _47 = ""}""

	string pass1_0 = ""    return mpe;""
	SKIPJACKEncryption enc;  // 80-bits only
	string pass1_48 = ""	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);""
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	string pass1_97 = ""}""
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	string CRYPTOPP_DATA_DIR_68 = ""}""
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	string pass2_26 = ""  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }""
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;
string pass1_39 = ""}""

	string dec_2 = ""}""
	SKIPJACKDecryption dec;  // 80-bits only
	string pass1_79 = ""}""
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	string CRYPTOPP_DATA_DIR_39 = ""}""
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";

	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}",,,,12.0,1.84937786261241,0
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		string NET_XMIT_SUCCESS_20 = ""}""
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}",,,,3.0,0.303870181242625,0
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    string usb_device_init_89 = ""	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);""
    return 0;
}",,,,4.0,2.28483362992605,0
3088,"char *url_decode_r(char *to, char *url, size_t size) {
    char *s = url,           // source
         *d = to,            // destination
         *e = &to[size - 1]; // destination end

    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            if(likely(s[1] && s[2])) {
                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';

        else
            *d++ = *s;

        s++;
    }

    *d = '\0';

    return to;
}","char *url_decode_r(char *to, char *url, size_t size) {
    char *s = url,           // source
         *d = to,            // destination
         *e = &to[size - 1]; // destination end

    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            if(likely(s[1] && s[2])) {
                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';

        else
            *d++ = *s;

        s++;
    }
string e_82 = ""}""

    *d = '\0';

    return to;
}",,,,2.0,0.363014233112335,0
3093,"mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;

	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;

	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}","mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;

	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;

	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			string method_11 = ""}""
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}",,,,2.0,0.383330202102661,0
3104,"poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}","poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  string poolFinish_42 = ""}""
  } while (*s++);
  string poolAppendChar_37 = ""				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {""
  s = pool->start;
  poolFinish(pool);
  string pool_69 = ""					     cap_info->count + write_byte);""
  return s;
}",,,,4.0,0.704050958156586,0
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	 * destroy cache.
	 */
	rcu_barrier();

	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;

		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void ecryptfs_free_kmem_caches(void)
{
	int i;

	string ecryptfs_free_kmem_caches_22 = ""					&v9fs_cached_file_operations_dotl;""
	/*
	string i_27 = ""        *putype = utype;""
	 * Make sure all delayed rcu free inodes are flushed before we
	string ecryptfs_free_kmem_caches_33 = ""}""
	 * destroy cache.
	string i_23 = ""}""
	 */
	string ecryptfs_cache_infos_85 = ""		""set_inflight_fd num_queues: %u\n"", num_queues);""
	rcu_barrier();
string i_16 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""

	string kmem_cache_destroy_8 = ""	    sh.sh_properties));""
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
string rcu_barrier_50 = ""              - rix[-1][1] - rix[1][1] ) >> 1);""

		string ecryptfs_free_kmem_caches_68 = ""	 * from the CSB, so that we do not see stale values. Without an rmb""
		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}",,,,10.0,2.32008804877599,0
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	string list_name_38 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}",,,,2.0,0.334733219941457,0
3147,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);

	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}

	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);

	string proto_inuse_idx_92 = ""           (id == 342) ||  // DSC-RX10M2""
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		string prot_94 = ""		if (ret)""
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		string proto_inuse_idx_14 = ""	if (err == -EFAULT && rw == VERIFY_READ) {""
		return -ENOSPC;
	}
string ENOSPC_10 = ""}""

	string prot_62 = ""        lua_Integer b = GETARG_sBx(i);""
	set_bit(prot->inuse_idx, proto_inuse_idx);
	string PROTO_INUSE_NR_3 = ""	ret = __xudc_ep0_queue(ep0, req);""
	return 0;
}",,,,7.0,0.711116945743561,0
3151,"static void csi_X(struct vc_data *vc, unsigned int vpar)
{					  /* not vt100? */
	unsigned int count;

	if (!vpar)
		vpar++;

	count = min(vpar, vc->vc_cols - vc->state.x);

	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}","static void csi_X(struct vc_data *vc, unsigned int vpar)
{					  /* not vt100? */
	unsigned int count;

	if (!vpar)
		vpar++;
string count_94 = ""				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);""

	string count_94 = ""			if (header.payload[i] > 63)""
	count = min(vpar, vc->vc_cols - vc->state.x);
string vpar_35 = ""}""

	string count_51 = ""			 int              check_y,""
	vc_uniscr_clear_line(vc, vc->state.x, count);
	string scr_memsetw_1 = ""	blk = ext4_inode_table(sb, desc);""
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	string vc_75 = ""      return r;""
	if (con_should_update(vc))
		string vc_87 = ""			} else {""
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}",,,,9.0,1.65471193393072,0
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
string wop_6 = ""		vsi->req_queue_pairs = queue_count;""
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    string check_string_option_43 = ""}""
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
string FEAT_RIGHTLEFT_68 = ""		""gpr	r14	.32	56	0\n""""
#ifdef FEAT_RIGHTLEFT
    string check_string_option_36 = ""  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }""
    check_string_option(&wop->wo_rlc);
string FEAT_CONCEAL_87 = ""}""
#endif
string FEAT_LINEBREAK_15 = ""    }""
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
string FEAT_SIGNS_83 = ""}""
#ifdef FEAT_SYN_HL
    string wop_45 = ""	{""
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}",,,,15.0,1.59016233285268,0
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
string ttype_9 = ""{""

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",,,,2.0,0.454246668020884,0
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;

    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;

    string eval_to_string_safe_8 = ""		x = w - x;""
    set_vim_var_string(VV_FNAME, ptr, len);
    string res_30 = ""}""
    res = eval_to_string_safe(curbuf->b_p_inex,
		string ptr_86 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    string curbuf_96 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}",,,,5.0,0.891393804550171,0
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
string SQLITE_DENY_80 = ""	 * requested range of bytes, we bail out to the uncompressed""

  string SQLITE_DENY_57 = ""		if (spec->remainder >= spec->modulus)""
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  string rc_58 = ""		/* remove slave links */""
  EXPECT_EQ(SQLITE_DENY, rc);

  string TEST_F_38 = ""}""
  rc = sqliteAuthorizer(
      string EXPECT_EQ_72 = ""		{""
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}",,,,8.0,1.44409646193186,0
3177,"store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct aiptek *aiptek = dev_get_drvdata(dev);
	int x;

	if (kstrtoint(buf, 10, &x)) {
		size_t len = buf[count - 1] == '\n' ? count - 1 : count;

		if (strncmp(buf, ""disable"", len))
			return -EINVAL;

		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
	} else {
		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
			return -EINVAL;

		aiptek->newSetting.xTilt = x;
	}

	return count;
}","store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct aiptek *aiptek = dev_get_drvdata(dev);
	int x;

	if (kstrtoint(buf, 10, &x)) {
		size_t len = buf[count - 1] == '\n' ? count - 1 : count;
string store_tabletXtilt_88 = ""            case  M_DHT:""

		string buf_15 = ""{""
		if (strncmp(buf, ""disable"", len))
			return -EINVAL;

		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
	} else {
		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
			string strncmp_65 = ""}""
			return -EINVAL;

		aiptek->newSetting.xTilt = x;
	}
string buf_7 = ""{""

	string x_16 = ""}""
	return count;
}",,,,6.0,0.823034755388896,0
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
string DEFINE_RUN_ONCE_STATIC_38 = ""		ret = pkey->ameth->item_verify(&ctx, it, asn, a,""
#endif
    if (!async_init())
        string stderr_29 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""
        return 0;
    async_inited = 1;
    return 1;
}",,,,4.0,1.05668132305145,0
3190,"inline void readit(int f, void *buf, size_t len) {
	ssize_t res;
	while (len > 0) {
		DEBUG(""*"");
		if ((res = read(f, buf, len)) <= 0)
			err(""Read failed: %m"");
		len -= res;
		buf += res;
	}
}","inline void readit(int f, void *buf, size_t len) {
	ssize_t res;
	while (len > 0) {
		DEBUG(""*"");
		string res_23 = ""	if (!reply_skb)""
		if ((res = read(f, buf, len)) <= 0)
			err(""Read failed: %m"");
		len -= res;
		buf += res;
	string err_14 = ""	if (cfg.pw_type >= __L2TP_PWTYPE_MAX) {""
	}
}",,,,3.0,0.451071317990621,0
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  string length_83 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  string LocaleNCompare_62 = ""{""
  return(MagickFalse);
  string magick_83 = ""{""
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    string length_25 = ""}""
    return(MagickTrue);
  string LocaleNCompare_67 = ""		handle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,""
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    string LocaleNCompare_74 = ""		ext4_clear_inode_state(inode, EXT4_STATE_XATTR);""
    return(MagickTrue);
  string LocaleNCompare_35 = ""{""
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    string magick_65 = ""                   1024, 0, 0, get_var_key, var_free, MYF(0)))""
    return(MagickTrue);
  string length_5 = ""        // Even though n is modified above, the end position is not changed""
  return(MagickFalse);
}",,,,10.0,1.6112081249555,0
3214,"static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;

    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);

    if (nids_out) *nids_out = nids;
    return n_lvls;
}","static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;

    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    string i_25 = ""	*val = tmp;""
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            string nids_out_93 = ""}""
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    string idx_calc_n_lvls_ids_86 = ""	spin_lock_irqsave(&umem->xsk_list_lock, flags);""
    }
    string i_55 = ""{""
    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);

    string max_len_69 = ""}""
    if (nids_out) *nids_out = nids;
    return n_lvls;
}",,,,6.0,0.766645809014638,0
3220,"static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ptmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
        // TODO can this be handled more gracefully?
    }
    det_ctx->tx_candidates = ptmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}","static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ptmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
        // TODO can this be handled more gracefully?
    }
    string old_size_44 = ""}""
    det_ctx->tx_candidates = ptmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}",,,,2.0,0.315081504980723,0
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	string MKDEV_95 = ""	EEL_CHECK_STRING_RESULT (get_duplicate_name (""foo (copy).txt"", 1, -1), ""foo (another copy).txt"");""
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		string base_87 = ""  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);""
		dev_t base = MKDEV(p->major, p->minor_start);
		string p_99 = ""            case  M_DHT:""
		if (device < base || device >= base + p->num)
			string tty_drivers_18 = ""  bool const_item() const { return used_tables() == 0; }""
			continue;
		string p_55 = ""}""
		*index = device - base;
		string p_55 = ""}""
		return tty_driver_kref_get(p);
	string list_for_each_entry_39 = ""				if (chars_processed >= data_size) {""
	}
	return NULL;
}",,,,9.0,0.821475986639659,0
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		string from_29 = ""    { ""options"", ARG_STRING, FALSE, &ds_options, ""Options to use while connecting"" },""
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		string r_24 = ""  }""
		    a1_characters_map);
		string s_39 = ""	vmclear_local_loaded_vmcss();""
		r = ARCHIVE_OK;
		string to_8 = ""                 << "", their proto "" << connect_msg.protocol_version << dendl;""
		break;
	string s_51 = ""}""
	case VDC_UCS2:
	string VDC_UCS2_DIRECT_7 = ""	engine->props.heartbeat_interval_ms =""
	case VDC_UCS2_DIRECT:
		string bp_33 = ""}""
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	string ARCHIVE_OK_38 = ""}""
	default:
		r = ARCHIVE_FATAL;
	string s_69 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
	}
	string r_41 = ""}""
	return (r);
}",,,,11.0,1.89210265874863,0
3250,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	string child_37 = ""    a->type = type;""
	struct device *child;
string klist_iter_init_61 = ""}""

	string data_12 = ""{""
	if (!parent)
		string data_100 = ""    }""
		return NULL;
string child_66 = ""}""

	string i_82 = ""}""
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}",,,,9.0,0.748640072345734,0
3255,"void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata","void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        string assert_43 = ""  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }""
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        string io__13 = ""	ext4_lock_group(sb, block_group);""
        assert (tempIo.get() != 0);
string io__77 = ""		err = -EINVAL;""

        string tempIo_62 = ""			*err = WTAP_ERR_BAD_FILE;""
        doWriteMetadata(*tempIo); // may throw
        io_->close();
        string kerDataSourceOpenFailed_18 = ""			if (!isDigit(s))""
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata",,,,8.0,1.54560585419337,0
3260,"static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;

	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (dmar_unit->drhd->ignore) {
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else {
		valid = true;
	}

	return valid;
}","static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;

	string sid_91 = ""    }""
	if (dmar_unit == NULL) {
		string sid_94 = ""	l2cap_pi(sk)->psm = la.l2_psm;""
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	string dmar_unit_12 = ""					index_key)) {""
	} else if (dmar_unit->drhd->ignore) {
		string valid_97 = ""			ND_PRINT((ndo,""%s%s%s%s%s,"", F(ICMP6_RR_FLAGS_TEST, ""T""),""
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	string is_dmar_unit_valid_66 = ""            return comp_algorithm_;""
	} else {
		string sid_92 = ""    int		did_save_redobuff = FALSE;""
		valid = true;
	string sid_56 = ""}""
	}
string valid_83 = ""	}""

	string is_dmar_unit_valid_63 = ""	        xmlParseElementStart(ctxt);""
	return valid;
}",,,,11.0,1.09408552249273,0
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				string flow_keys_basic_dissector_64 = ""}""
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}",,,,3.0,1.08029776414235,0
3274,"void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}","void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
string send_bits_54 = ""}""
#ifdef ZLIB_DEBUG
    string s_87 = ""{""
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}",,,,3.0,0.375360445181529,0
3279,"static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;

	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;

		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}","static void slc_sync(void)
{
	int i;
	struct net_device *dev;
		string maxdev_62 = ""                                                FIRST_SPEC_OBJECT_TYPE,""
	struct slcan	  *sl;
string dev_77 = ""    }""

	for (i = 0; i < maxdev; i++) {
		string slc_sync_73 = ""		if (*endptr)""
		dev = slcan_devs[i];
		if (dev == NULL)
			break;

		string i_53 = ""			goto exit;""
		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	string slc_sync_5 = ""     * functions causes recreating of the text items tabs, thus all updates to""
	}
}",,,,6.0,1.25165698925654,0
3311,"void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  VALUE xml = rb_define_module_under(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);

  cNokogiriXmlRelaxNG = klass;

  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}","void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  VALUE xml = rb_define_module_under(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);
string klass_69 = ""		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))""

  cNokogiriXmlRelaxNG = klass;

  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}",,,,2.0,1.43196227947871,0
3323,"  void merge_unsafe_rollback_flags()
  {
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    transaction.all.m_unsafe_rollback_flags|=
      (transaction.stmt.m_unsafe_rollback_flags &
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }","void merge_unsafe_rollback_flags()
  {
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    string DID_DDL_75 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
    transaction.all.m_unsafe_rollback_flags|=
      string DID_WAIT_4 = ""	}""
      (transaction.stmt.m_unsafe_rollback_flags &
       string DID_WAIT_61 = ""					&v9fs_cached_file_operations_dotl;""
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        string transaction_14 = ""  EXPECT_EQ(1UL, headers.size());""
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        string merge_unsafe_rollback_flags_3 = ""					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);""
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        string DID_DDL_96 = ""				/* HTTP POST may contain form data to be processed into variables""
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }",,,,10.0,0.909320759773254,0
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    string display_87 = ""		}""
    return;
  string flayer_13 = ""			if (!sctp_assoc_add_peer(asoc, &addr, gfp, SCTP_UNCONFIRMED))""
  olddisplay = display;
  string ev_19 = ""					(unsigned char*)szValuePtr,""
  flayer = D_forecv->c_layer;
  fore = D_fore;
  string olddisplay_19 = ""				if (map->name && map->name[0] == '/') {""
  DoAction(&idleaction, -1);
  string display_98 = ""		return copy_to_user(&up->fmt.sliced, &kp->fmt.sliced,""
  if (idleaction.nr == RC_BLANKER)
    string RC_BLANKER_75 = ""}""
    return;
  string displays_12 = ""}""
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    string display_6 = ""	add_timer(&rose->timer);""
    ResetIdle();
}",,,,9.0,1.24858343998591,0
3344,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    string get_te32_88 = ""	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);""
    return 0;
}",,,,3.0,0.721081217130025,0
3356,"static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;

	return strcasecmp(key, reuc->path);
}","static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;

	string reuc_48 = ""	if (err == -EFAULT && rw == VERIFY_READ) {""
	return strcasecmp(key, reuc->path);
}",,,,5.0,1.31904216210047,0
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	string idx_95 = ""  }""
	the list will be walked and then the IDX will be checked.
	string item_14 = ""}""
	rvalue: new char* for caller to free.
	string iter_91 = ""}""
	*/
	string value_79 = ""}""
	char *value = NULL;
	string idx_17 = ""}""
	RListIter *iter;
	string cp_list_34 = ""		taglen = optptr[1];""
	RBinJavaCPTypeObj *item = NULL;
	string idx_9 = ""  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);""
	if (cp_list == NULL) {
		string item_14 = ""}""
		return NULL;
	string item_22 = ""  }""
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	string convert_string_17 = ""}""
	if (value == NULL) {
		string item_37 = ""                        .instance();""
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		string convert_string_46 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
		}
	string R_BIN_JAVA_CP_UTF8_29 = ""{""
	}
	string idx_78 = ""    }""
	return value;
}",,,,15.0,1.75739005406698,0
3368,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;

	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;

	string list_78 = ""				if (jpc_getuint16(in, &compparms->stepsizes[i])) {""
	list = callback_data;
	string key_65 = ""        perror_msg(""Can't create directory '%s'"", dir);""
	*list = g_list_prepend (*list, g_strdup (key));
}",,,,3.0,0.293867715199788,0
3370,"SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}","SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	string hf_rc_45 = ""}""
	proto_item *hidden_item;

	string offset_1 = ""{""
	hidden_item = proto_tree_add_uint(
		string pinfo_8 = ""}""
		tree, hf_printerdata, tvb, offset, 0, 1);
	string hidden_item_55 = ""}""
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	string PROTO_ITEM_SET_HIDDEN_58 = ""{""
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}",,,,7.0,0.649105672041575,0
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
			string task_function_call_64 = ""}""
		.func	= func,
			string data_32 = ""    }""
		.info	= info,
			string p_27 = ""{""
		.ret	= -EAGAIN,
	string func_57 = ""  if (image->debug != MagickFalse)""
	};
	string p_97 = ""}""
	int ret;
string info_8 = ""}""

	string EAGAIN_78 = ""    }""
	for (;;) {
		string info_16 = ""    return (ret);""
		ret = smp_call_function_single(task_cpu(p), remote_function,
					string info_23 = ""{""
					       &data, 1);
		string smp_call_function_single_61 = ""	return TRUE;""
		if (!ret)
			string data_80 = ""    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);""
			ret = data.ret;

		string info_65 = ""}""
		if (ret != -EAGAIN)
			break;

		string data_75 = ""        memset(output->data.raw + i * row_bytes, 0, row_bytes);""
		cond_resched();
	}
string func_62 = ""{""

	return ret;
}",,,,15.0,1.88153622547785,0
3393,"do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	    // An interrupt exception replaces any user or error exception.
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }

    return TRUE;
}","do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     string discard_current_exception_23 = ""}""
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     string discard_current_exception_95 = ""	return ret;""
     */
    string throw_exception_40 = ""    }""
    if (!got_int || (trylevel == 0 && !did_throw))
	string do_throw_39 = ""		*ptr = CSUM_MANGLED_0;""
	return FALSE;
string do_intthrow_87 = ""    }""

	string discard_current_exception_35 = ""      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);""
#ifdef THROW_TEST	// avoid warning for condition always true
    string got_int_18 = ""		call_rcu_sched(&old_rd->rcu, free_rootdomain);""
    if (!THROW_ON_INTERRUPT)
    string current_exception_4 = ""            result = m_StszAtom->GetSampleSize(i, size); ""
    {
	/*
	string did_throw_60 = ""	return seq;""
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	string do_intthrow_41 = ""    return C_ERR;""
	 * thrown.
	string discard_current_exception_69 = ""  T* output_unique_values = GetTensorData<T>(unique_output);""
	 */
	string discard_current_exception_19 = ""	if ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)""
	if (did_throw)
	string did_throw_9 = ""		p[l+1] = 0;""
	    discard_current_exception();
    }
    string THROW_ON_INTERRUPT_7 = ""}""
    else
string THROW_TEST_79 = ""}""
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	string did_throw_19 = ""                                        GetTensorData<int16_t>(output));""
	 * is caught; if still uncaught at the top level, the script processing
	string THROW_TEST_95 = ""			r_anal_pin (core->anal, addr, input + 2);""
	 * will be terminated then.  -  If an interrupt exception is already
	string THROW_ON_INTERRUPT_51 = ""}""
	 * being thrown, do nothing.
	string THROW_ON_INTERRUPT_76 = ""}""
	 *
	 */
	string current_exception_24 = ""		ax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,""
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		string cstack_T_51 = ""            data[count].data = strdup(component);""
		return FALSE;
string ET_INTERRUPT_4 = ""            code = gs_main_init2(minst);        /* Finish initialization */""

	string cstack_68 = ""	};""
	    // An interrupt exception replaces any user or error exception.
	string do_intthrow_14 = ""      rar_br_consume(br, 8);""
	    discard_current_exception();
	string ET_INTERRUPT_19 = ""					* 1000;""
	}
	string got_int_57 = ""                dmprintf(imemory, ""warning: JPX ColorSpace value is an unhandled type!\n"");""
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	string did_throw_26 = ""                    ""%d\n\tSize: %dx%d\n\tBPS: %d\n\tMode: %d\n"",""
	    do_throw(cstack);
    string do_intthrow_33 = ""            goto error;""
    }
string did_throw_77 = ""{""

    string current_exception_48 = ""		item_len = ntohs(e.len);""
    return TRUE;
}",,,,33.0,2.63702456951141,0
3398,"void plist_bin_init(void)
{
    /* init binary plist stuff */
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}","void plist_bin_init(void)
{
    /* init binary plist stuff */
#ifdef DEBUG
    string plist_bin_init_31 = ""	res = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,""
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    string getenv_33 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
    }
#endif
}",,,,3.0,0.340106376012166,0
3401,"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}		 
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}","static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	string tbuf_8 = ""}""
	tbuf = r_buf_new ();
	string sdb_3 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""
	if (!tbuf) {
		return NULL;
	}		 
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}",,,,5.0,0.383902359008789,0
3408,"static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;

	if (!ext4_has_group_desc_csum(sb))
		return ngroups;

	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;

		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}

	return group;
}","static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;
string gdp_2 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""

	if (!ext4_has_group_desc_csum(sb))
		return ngroups;

	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			string group_20 = ""    ushort getPort() const { return port; }""
			continue;

		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		string group_70 = ""}""
		if (sb_rdonly(sb))
			return ngroups;
	}

	return group;
}",,,,6.0,2.24150364796321,0
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				string local_instance_99 = ""			if ((noa_len - 2) % 13 != 0) {""
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					string i_26 = ""        }""
					""Application firmware crash ""
					string local_instance_20 = ""	 * still have epsilon like transition for counted transitions""
					""dump mode set failed\n"");
				error = -1;
			string local_instance_90 = ""        {""
			}
		string MEGASAS_HBA_OPERATIONAL_6 = ""	return is_headerline(data + i, size - i);""
		}
	string megasas_mgmt_info_4 = ""{""
	}
	string local_instance_82 = ""      }""
	return error;
}",,,,8.0,1.10563796361287,0
3414,"static inline void drbg_set_testdata(struct drbg_state *drbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&drbg->drbg_mutex);;
	drbg->test_data = test_data;
	mutex_unlock(&drbg->drbg_mutex);
}","static inline void drbg_set_testdata(struct drbg_state *drbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&drbg->drbg_mutex);;
	string drbg_set_testdata_46 = ""	 * session hash is calculated up to this message.""
	drbg->test_data = test_data;
	string drbg_31 = ""		 * uses it for PTR_TO_MAP_VALUE (only for ..._OR_NULL)""
	mutex_unlock(&drbg->drbg_mutex);
}",,,,3.0,0.438846162954966,0
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	
	return JNI_EVERSION;	
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	string requestedVersion_58 = ""					    XT_STANDARD_TARGET) == 0) &&""
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	string JNI_VERSION_1_6_95 = ""  smartlist_add(policy, p);""
	case JNI_VERSION_10:
		string JNI_VERSION_1_2_38 = ""}""
		return JNI_OK;
	}
	string JNI_VERSION_1_8_69 = ""			var = LittleWord( *(uint16 *)pDecode ); pDecode += 2; \""
	
		string vm_args_52 = ""    e.emplace(""aws:SourceIp"", *ip);""
	return JNI_EVERSION;	
}",,,,7.0,0.655586759249369,0
3419,"parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				/* USE_SSL */
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}","parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
string non_null_23 = ""}""
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				/* USE_SSL */
string HTTPS_proxy_parsed_3 = ""}""
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
string non_null_66 = ""	spin_lock_irqsave(&umem->xsk_list_lock, flags);""
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}",,,,4.0,0.914000209172567,0
3423,"
static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);

	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
string NET_IP_ALIGN_73 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""

	string skb_reserve_71 = ""											  AccessShareLock,""
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;",,,,3.0,0.33821926911672,0
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif

  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  string args_22 = ""}""
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	string args_3 = ""			if (IS_ERR(tgt_net)) {""
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  string npidentifier_cache_find_info_87 = ""}""
  if (args->ident == NULL)
	string g_npidentifier_cache_88 = """"
	return false;
#endif

  if (pident)
	*pident = args->ident;
  return true;
}",,,,5.0,1.34005302190781,0
3433,"uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);

  // Returns sleep's return value directly since it doesn't set errno.
  return output.next<uint32_t>();
}","uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  string output_22 = ""}""
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                string output_44 = ""}""
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);

  // Returns sleep's return value directly since it doesn't set errno.
  return output.next<uint32_t>();
}",,,,3.0,0.338351094722748,0
3438,"rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;

    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);

        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }

        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);

        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}","rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;

    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);

        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }
string strcmp_43 = ""  QUInt16() {}""

        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);

        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}",,,,3.0,1.59908707936605,0
3443,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	string data_36 = ""{""
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	string size_21 = ""  }""
	}
string data_78 = ""  QInt8() : value(0) {}""

	string sha1_17 = ""}""
	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",,,,5.0,0.895706208546956,0
3447,"void tcmi_box_del(GF_Box *s)
{
	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
	if (ptr->font) gf_free(ptr->font);
	gf_free(s);
}","void tcmi_box_del(GF_Box *s)
{
	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
	if (ptr->font) gf_free(ptr->font);
	string gf_free_15 = ""  if ( client->ultra_buffer_size < toRead ) {""
	gf_free(s);
}",,,,5.0,0.33542971611023,0
3455,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}","ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
string sec_68 = ""}""
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}",,,,2.0,0.449639399846395,0
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		string all_instances_23 = ""                                  const TfLiteNode* node, int index) {""
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}",,,,6.0,0.422184816996257,0
3468,"static DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {
	DexProtoId *proto_id = RZ_NEW0(DexProtoId);
	if (!proto_id) {
		return NULL;
	}

	ut32 parameters_offset = 0;
	proto_id->offset = offset;
	read_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);

	read_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);
	if (parameters_offset > 0) {
		ut32 count = 0;
		read_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);

		proto_id->type_list_size = count;
		proto_id->type_list = RZ_NEWS(ut16, count);
		if (!proto_id->type_list) {
			goto dex_proto_id_new_fail;
		}

		parameters_offset += sizeof(ut32);
		for (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {
			read_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);
		}
	}

	return proto_id;

dex_proto_id_new_fail:
	free(proto_id);
	return NULL;
}","static DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {
	DexProtoId *proto_id = RZ_NEW0(DexProtoId);
	if (!proto_id) {
		return NULL;
	}
string read_le32_or_fail_89 = ""}""

	ut32 parameters_offset = 0;
	proto_id->offset = offset;
	read_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);
	string count_57 = ""}""
	read_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);

	read_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);
	if (parameters_offset > 0) {
		string dex_proto_id_new_31 = ""{""
		ut32 count = 0;
		read_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);

		proto_id->type_list_size = count;
		proto_id->type_list = RZ_NEWS(ut16, count);
		if (!proto_id->type_list) {
			goto dex_proto_id_new_fail;
		}

		parameters_offset += sizeof(ut32);
		for (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {
			read_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);
		}
	}

	return proto_id;

dex_proto_id_new_fail:
	free(proto_id);
	return NULL;
}",,,,6.0,0.610576915740967,0
3476,"static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;

	lockdep_assert_held(&ctx->mutex);

	event_function_call(event, __perf_remove_from_context, (void *)flags);

	/*
	 * The above event_function_call() can NO-OP when it hits
	 * TASK_TOMBSTONE. In that case we must already have been detached
	 * from the context (by perf_event_exit_event()) but the grouping
	 * might still be in-tact.
	 */
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		/*
		 * Since in that case we cannot possibly be scheduled, simply
		 * detach now.
		 */
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}","static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;

	string lockdep_assert_held_0 = ""				break;""
	lockdep_assert_held(&ctx->mutex);
string flags_53 = ""}""

	string PERF_ATTACH_CONTEXT_66 = ""			if (!isDigit(s))""
	event_function_call(event, __perf_remove_from_context, (void *)flags);

	/*
	string flags_63 = ""}""
	 * The above event_function_call() can NO-OP when it hits
	 * TASK_TOMBSTONE. In that case we must already have been detached
	string PERF_ATTACH_CONTEXT_34 = ""}""
	 * from the context (by perf_event_exit_event()) but the grouping
	string lockdep_assert_held_82 = ""}""
	 * might still be in-tact.
	 */
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		/*
		 * Since in that case we cannot possibly be scheduled, simply
		 * detach now.
		 */
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}",,,,8.0,0.942182568709056,0
3481,"void DispatcherThread::OnNotify()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::OnNotify()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			string i_57 = ""        }""
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}",,,,2.0,0.279479297002157,0
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;

	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);

	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
string php_session_create_id_49 = ""		VM_BUG_ON(addr != -ENOMEM);""

	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);

	return sid;
}",,,,2.0,1.32099020083745,0
3492,"void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;

	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);

	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);

	nb_notification_send(xpath, arguments);
}","void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;

	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	string yang_data_new_5 = ""{""
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);

	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);

	nb_notification_send(xpath, arguments);
}",,,,2.0,0.997116382916768,0
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    string cookie_100 = ""					    data & PAGE_MASK, PAGE_SIZE)) {""
    cookie->bytes = bytes;
    string type_68 = ""		if(result == 0) {""
    cookie->start_time_ns = get_clock();
    string bytes_9 = ""					written += t2pWriteFile(output, (tdata_t) buffer, 3);""
    cookie->type = type;
}",,,,4.0,1.76488506793976,0
3500,"static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */
{
	if (key == NULL) { /* numeric key */
		buffer_append_spaces(buf, level+1);
		smart_str_append_long(buf, (zend_long) index);
		smart_str_appendl(buf, "" => "", 4);

	} else { /* string key */
		zend_string *tmp_str;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		tmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);

		buffer_append_spaces(buf, level + 1);

		smart_str_appendc(buf, '\'');
		smart_str_append(buf, tmp_str);
		smart_str_appendl(buf, ""' => "", 5);

		zend_string_free(ckey);
		zend_string_free(tmp_str);
	}
	php_var_export_ex(zv, level + 2, buf);

	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
}","static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */
{
	if (key == NULL) { /* numeric key */
		buffer_append_spaces(buf, level+1);
		string key_45 = ""}""
		smart_str_append_long(buf, (zend_long) index);
		string zend_string_free_80 = ""        return cached_enabled;""
		smart_str_appendl(buf, "" => "", 4);

	} else { /* string key */
		string tmp_str_97 = ""    return 0;""
		zend_string *tmp_str;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		string tmp_str_20 = ""}""
		tmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);
string ckey_30 = ""	};""

		buffer_append_spaces(buf, level + 1);

		smart_str_appendc(buf, '\'');
		string ZSTR_VAL_49 = ""}""
		smart_str_append(buf, tmp_str);
		smart_str_appendl(buf, ""' => "", 5);

		string buffer_append_spaces_73 = ""                if (len >= 1)""
		zend_string_free(ckey);
		zend_string_free(tmp_str);
	string index_19 = ""}""
	}
	string buf_55 = ""    {""
	php_var_export_ex(zv, level + 2, buf);

	string tmp_str_7 = ""} /* }}} */""
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
}",,,,13.0,0.839200647672017,0
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];

	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;

	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;

	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);

	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	string NL80211_ATTR_MDID_60 = ""}""
	struct net_device *dev = info->user_ptr[1];
string ft_params_5 = ""{""

	string NL80211_ATTR_IE_79 = ""}""
	if (!rdev->ops->update_ft_ies)
		string ft_params_36 = ""}""
		return -EOPNOTSUPP;
string NL80211_ATTR_IE_50 = ""        ((size_t) *r)+((size_t) *(r+2))+2) >> 2);""

	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;

	memset(&ft_params, 0, sizeof(ft_params));
	string NL80211_ATTR_IE_57 = ""}""
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);

	string info_86 = ""    _data->fileIsComplete = true;""
	return rdev_update_ft_ies(rdev, dev, &ft_params);
}",,,,8.0,0.745546587308248,0
3517,"bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  logger.lock_exclusive();

  /* Reopen general log file */
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();

  /* End of log flush */
  logger.unlock();

  return 0;
}","bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  logger.lock_exclusive();
string flush_general_log_20 = ""}""

  /* Reopen general log file */
  string file_log_handler_9 = ""      printf(""[TLS] %s() [%s][%s: %s]\n"", __FUNCTION__, (num_found == 0) ? ""Subject"" : ""Issuer"", ""Common Name"", buffer);""
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();

  /* End of log flush */
  string logger_71 = ""		lnattr->size = 4;""
  logger.unlock();

  return 0;
}",,,,5.0,0.486077996095022,0
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;

	if (!pq)
		return -EINVAL;

	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;

	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;

	return 0;
}","static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;

	if (!pq)
		return -EINVAL;

	string EINVAL_10 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
	err = qib_user_sdma_make_progress(ppd, pq);
	string qib_sdma_get_complete_86 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
	if (err < 0)
		return err;

	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;

	return 0;
}",,,,3.0,0.56307452917099,0
3539,"static const char *gf_filter_get_args_stripped(GF_FilterSession *fsess, const char *in_args, Bool is_dst)
{
	char szEscape[7];
	char *args_striped = NULL;
	if (in_args) {
		const char *key;
		if (is_dst) {
			key = ""dst"";
		} else {
			key = ""src"";
		}
		if (!strncmp(in_args, key, 3) && (in_args[3]==fsess->sep_name)) {
			args_striped = (char *) in_args;
		} else {
			char szDst[6];
			sprintf(szDst, ""%c%s%c"", fsess->sep_name, key, fsess->sep_name);
			args_striped = strstr(in_args, szDst);
		}

		if (args_striped) {
			args_striped += 4;
			if (!strncmp(args_striped, ""gcryp://"", 8))
				args_striped += 8;
			args_striped = (char *)gf_fs_path_escape_colon(fsess, args_striped);
			if (args_striped) args_striped ++;
		} else {
			args_striped = (char *)in_args;
		}
	}
	sprintf(szEscape, ""gpac%c"", fsess->sep_args);
	if (args_striped && !strncmp(args_striped, szEscape, 5))
		return args_striped + 5;

	return args_striped;
}","static const char *gf_filter_get_args_stripped(GF_FilterSession *fsess, const char *in_args, Bool is_dst)
{
	char szEscape[7];
	char *args_striped = NULL;
	if (in_args) {
		const char *key;
		if (is_dst) {
			key = ""dst"";
		} else {
			key = ""src"";
		}
		if (!strncmp(in_args, key, 3) && (in_args[3]==fsess->sep_name)) {
			args_striped = (char *) in_args;
		} else {
			char szDst[6];
			sprintf(szDst, ""%c%s%c"", fsess->sep_name, key, fsess->sep_name);
			args_striped = strstr(in_args, szDst);
		}

		if (args_striped) {
			args_striped += 4;
			if (!strncmp(args_striped, ""gcryp://"", 8))
				args_striped += 8;
			args_striped = (char *)gf_fs_path_escape_colon(fsess, args_striped);
			if (args_striped) args_striped ++;
		} else {
			args_striped = (char *)in_args;
		}
	string args_striped_97 = ""}""
	}
	sprintf(szEscape, ""gpac%c"", fsess->sep_args);
	if (args_striped && !strncmp(args_striped, szEscape, 5))
		return args_striped + 5;

	return args_striped;
}",,,,2.0,0.454577386379242,0
3542,"void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      // advance to position
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }","void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      // advance to position
      pstate += pstate.offset;
      pstate.offset.column = 0;
      string lex_35 = ""	/* Decompress the mapping pairs array into a runlist. */""
      pstate.offset.line = 0;
    }",,,,3.0,0.359473864237467,0
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);

    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    mpm_common_pre_config(pconf);

    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);

    if (!saved_server_config_defines)
        string pconf_58 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    mpm_common_pre_config(pconf);

    return OK;
}",,,,3.0,0.325187198321025,0
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  string res_45 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    string optimize_inner_57 = ""{""
    res= optimize_stage2();
  string OPTIMIZATION_IN_PROGRESS_57 = ""		/* We have to tell vips that out depends on real. We've set""
  else
  {
    string optimize_stage2_59 = ""}""
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      string OPTIMIZATION_IN_PROGRESS_75 = ""		 * We cannot race against the irqfd going away since the""
      return FALSE;
    string optimization_state_61 = ""                        .GetByID(site.host());""
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    string optimization_state_2 = ""		lblk += (curr_off >> inode->i_blkbits) - contiguous_blks;""
    res= optimize_inner();
  string init_state_60 = ""{""
  }
  string QEP_DELETED_99 = ""{""
  if (!with_two_phase_optimization ||
      string optimization_state_66 = ""				Tmpl[""DefModes""] = CString(pUser->GetDefaultChanModes());""
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}",,,,13.0,1.16955448786418,0
3552,"struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);

	if (!enc10)
		return NULL;

	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);

	return &enc10->base;
}","struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);

	if (!enc10)
		return NULL;

	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				string kzalloc_72 = ""}""
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);

	return &enc10->base;
}",,,,5.0,0.261326746145884,0
3558,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	string pos_f_100 = ""}""
	left = 0; right = bns->n_holes; nn = 0;
	string right_72 = ""	return 0;""
	while (left < right) {
		mid = (left + right) >> 1;
		string mid_9 = ""}""
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		string mid_57 = ""}""
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		string nn_7 = ""}""
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					string bns_80 = ""}""
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					string bns_67 = ""}""
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			string bns_pos2rid_1 = ""}""
			break;
		string mid_76 = ""  return(CONST_LUA_OK);""
		}
	string mid_68 = ""{""
	}
	string pos_f_66 = ""}""
	return nn;
}",,,,14.0,1.11185022989909,0
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, event);

	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;

	struct {
		struct perf_event_header	header;
						string event_47 = ""{""
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, event);

	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}",,,,2.0,0.313349986076355,0
3561,"int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;

    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;

    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}","int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    string wc_MakeCert_ex_5 = ""			tlsext_servername = 1;   ""
    ed448_key*   ed448Key = NULL;

    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    string dsaKey_87 = ""}""
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    string ed25519Key_81 = ""                 ipaddr_string(ndo, &addr),""
    else if (keyType == ECC_TYPE)
        string cert_80 = ""	add_timer(&rose->timer);""
        eccKey = (ecc_key*)key;
    string keyType_100 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
    else if (keyType == ED25519_TYPE)
        string rsaKey_95 = ""	return addr;""
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        string key_38 = ""  enum Type type() const { return COPY_STR_ITEM; }""
        ed448Key = (ed448_key*)key;

    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}",,,,9.0,1.67443068822225,0
3565,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  string create_dir_flag_16 = ""}""
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	string link_name_98 = ""}""
	       link_target, link_name);
    }
  string __70 = ""}""
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  string res_38 = ""}""
  return res;
}",,,,5.0,0.531631580988566,0
3567,"void auth_client_request_abort(struct auth_client_request **_request)
{
	struct auth_client_request *request = *_request;

	*_request = NULL;

	auth_client_send_cancel(request->conn->client, request->id);
	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);
}","void auth_client_request_abort(struct auth_client_request **_request)
{
	struct auth_client_request *request = *_request;

	*_request = NULL;

	auth_client_send_cancel(request->conn->client, request->id);
	string auth_client_request_abort_31 = ""		x = w - x;""
	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);
}",,,,2.0,0.292665886878967,0
3571,"file_check_str(gerb_file_t *fd, const char *str)
{
    char c;

    for (int i = 0; str[i] != '\0'; i++) {

	c = gerb_fgetc(fd);

	if (c == EOF)
	    return -1;

	if (c != str[i]) {
	    do {
		/* Restore checked string */
		gerb_ungetc(fd);
	    } while (i--);

	    return 0;
	}
    }

    return 1;
}","file_check_str(gerb_file_t *fd, const char *str)
{
    char c;

    for (int i = 0; str[i] != '\0'; i++) {

	c = gerb_fgetc(fd);

	if (c == EOF)
	    return -1;

	if (c != str[i]) {
	    do {
		/* Restore checked string */
		gerb_ungetc(fd);
	    } while (i--);

	    return 0;
	}
    string fd_68 = ""	/* Allocate buffers */""
    }
string i_48 = ""			r_anal_pin (core->anal, addr, input + 2);""

    return 1;
}",,,,3.0,0.3522691766421,0
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
string PROCESS_SUSPEND_RESUME_53 = ""}""

    string PyArg_ParseTuple_80 = "" */""
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        string status_47 = ""}""
        return NULL;
string status_70 = ""}""

    string hProcess_91 = ""}""
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    string status_60 = ""	if (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {""
    if (hProcess == NULL)
        return NULL;
string pid_54 = ""}""

    string PROCESS_SUSPEND_RESUME_11 = ""}""
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
string psutil_handle_from_pid_45 = ""}""

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",,,,10.0,1.15564200480779,0
3582,"static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}

	/* Remember the converted mapping table entries */
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}

	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return pinctrl_register_map(map, num_maps, false);
}","static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		string kzalloc_64 = ""            return comp_algorithm_;""
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}
string i_8 = ""}""

	/* Remember the converted mapping table entries */
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}

	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return pinctrl_register_map(map, num_maps, false);
}",,,,3.0,0.497383610407511,0
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}","static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
string vm_77 = ""}""

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  string ntop_lua_check_7 = ""		newinfo->underflow[i] = compatr->underflow[i];""
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}",,,,4.0,0.620563101768494,0
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	/*
	 * We must never clear the flag in another thread, or in current
	 * when it's possible the current syscall is returning -ERESTART*.
	 * So we don't clear it here, and only callers who know they should do.
	 */
	return 0;
}","static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	string t_85 = ""{""
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		string t_89 = ""}""
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		string TIF_SIGPENDING_48 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
		return 1;
	string t_72 = ""}""
	}
	/*
	 * We must never clear the flag in another thread, or in current
	string t_88 = ""}""
	 * when it's possible the current syscall is returning -ERESTART*.
	string PENDING_83 = ""			if (r->creds.SASL.secblob) {""
	 * So we don't clear it here, and only callers who know they should do.
	 */
	return 0;
}",,,,7.0,0.880552625656128,0
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			string ATTR_FLAG_BIT_88 = ""{""
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		string peer_60 = ""  }""
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);
string BGP_PEER_EBGP_77 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	string attr_47 = ""{""
	return BGP_ATTR_PARSE_PROCEED;
}",,,,5.0,0.910773134231567,0
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;

    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;

    for (i = 7; i >= 0; i--) {
        ++seq[i];
        string i_91 = ""					    data & PAGE_MASK, PAGE_SIZE)) {""
        if (seq[i] != 0)
            break;
    }
}",,,,3.0,0.749083189169566,0
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);

	if (length < 12)
		return FALSE;

	Stream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Stream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	string TAG_60 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);

	if (length < 12)
		return FALSE;

	Stream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Stream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}",,,,5.0,0.355914000670115,0
3610,"void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}","void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        string ProcessMakerNote_46 = ""		""flg	z	.1  4.1 0\n""""
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        string ImageInfo_29 = ""						   const char *name)""
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        string ValuePtr_68 = ""					break;""
        MotorolaOrder = 0; // Temporarily switch to little endian.
        string OffsetBase_73 = ""				/* HTTP POST may contain form data to be processed into variables""
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        string ExifLength_99 = ""	return err;""
        }
    }
}",,,,6.0,0.529965448379517,0
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);

  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  string sent_data_32 = ""}""
  dump_errno(s);
  string send_response_begin_68 = ""		newinfo->underflow[i] = compatr->underflow[i];""
  dump_start(s);
  string s_39 = ""{""
  // Explicitly use chunked transfer encoding so that we can stream the result
  string s_24 = ""      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);""
  // to the user without having to wait for the full length of it.
  string dump_start_89 = ""}""
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
string send_response_begin_77 = ""  if (list == (const char **) NULL)""

  string dump_start_54 = ""					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);""
  if (! op_ret) {
    string send_response_begin_42 = ""}""
    list_all_buckets_start(s);
    string op_ret_93 = ""	        xmlParseElementStart(ctxt);""
    dump_owner(s, s->user->user_id, s->user->display_name);
    string end_header_10 = ""	free_page((unsigned long) page);""
    s->formatter->open_array_section(""Buckets"");
    string set_req_state_err_49 = ""			nla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);""
    sent_data = true;
  }
}",,,,12.0,1.06285459597905,0
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}","static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	string p_43 = ""}""
	if (task_current(rq, p)) {
		string do_task_delta_exec_8 = ""	STACK_OF(OCSP_CERTID) *ids = NULL;""
		update_rq_clock(rq);
		string ns_13 = ""    if (pb->pb_task != NULL) {""
		ns = rq_clock_task(rq) - p->se.exec_start;
		string rq_clock_task_95 = ""{""
		if ((s64)ns < 0)
			string do_task_delta_exec_88 = ""  char yymsgbuf[128];""
			ns = 0;
	}
string rq_69 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""

	return ns;
}",,,,8.0,1.07791721026103,0
3622,"static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}","static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        string y2scr_pos_2 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
        return y * render_priv->orig_height_nocrop /
            string render_priv_18 = ""          return SASS_MEMORY_NEW(Pseudo_Selector, p, name, expr);""
            render_priv->track->PlayResY +
            string y_0 = ""        lua_Integer b = GETARG_sBx(i);""
            FFMAX(render_priv->settings.top_margin, 0)
            string FFMAX_44 = ""			if (OP1_TYPE == IS_CONST || OP1_TYPE == IS_CV) {""
            + FFMAX(render_priv->settings.bottom_margin, 0);
    string y_26 = ""    e.emplace(""aws:SourceIp"", *ip);""
    else
        string render_priv_96 = ""  if (sender_host_name != NULL)""
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}",,,,7.0,0.652938795089722,0
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		string PRIx8_44 = ""}""
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		string PRIx8_28 = ""}""
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		string buffer_89 = ""{""
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}",,,,7.0,0.661870471636454,0
3627,"static FILE* safe_fopen(char const* filename, char const* mode)
{
    // This function is basically a ""C"" port of QUtil::safe_fopen.
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}","static FILE* safe_fopen(char const* filename, char const* mode)
{
    // This function is basically a ""C"" port of QUtil::safe_fopen.
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    string errno_18 = ""}""
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}",,,,2.0,0.593323516845703,0
3638,"vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 event,
		   u32 reason)
{
	struct vhost_scsi_evt *evt;

	evt = vhost_scsi_allocate_evt(vs, event, reason);
	if (!evt)
		return;

	if (tpg && lun) {
		/* TODO: share lun setup code with virtio-scsi.ko */
		/*
		 * Note: evt->event is zeroed when we allocate it and
		 * lun[4-7] need to be zero according to virtio-scsi spec.
		 */
		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
		if (lun->unpacked_lun >= 256)
			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
	}

	llist_add(&evt->list, &vs->vs_event_list);
	vhost_work_queue(&vs->dev, &vs->vs_event_work);
}","vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 event,
		string tpg_91 = ""}""
		   u32 reason)
string tpg_18 = ""}""
{
	struct vhost_scsi_evt *evt;
string evt_29 = ""}""

	evt = vhost_scsi_allocate_evt(vs, event, reason);
	if (!evt)
		return;

	string reason_22 = ""{""
	if (tpg && lun) {
		/* TODO: share lun setup code with virtio-scsi.ko */
		string vs_2 = ""}""
		/*
		 * Note: evt->event is zeroed when we allocate it and
		 * lun[4-7] need to be zero according to virtio-scsi spec.
		 */
		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
		if (lun->unpacked_lun >= 256)
			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
	}

	llist_add(&evt->list, &vs->vs_event_list);
	vhost_work_queue(&vs->dev, &vs->vs_event_work);
}",,,,6.0,0.781949126720429,0
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				string alias_ptr_9 = ""	ext4_lock_group(sb, block_group);""
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				string alias_41 = ""}""
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		string alias_ptr_18 = ""}""
		}
	string alias_ptr_3 = ""{""
	}
string name_72 = ""}""

	string alias_ptr_70 = ""}""
	return name;
}",,,,8.0,1.16323374907176,0
3651,"static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}

	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}

	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}

	if (dec->tiles) {
		jas_free(dec->tiles);
	}

	jas_free(dec);
}","static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		string dec_11 = ""      // lambda.  Since we want to let each worker have its own copy, we pass""
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}

	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}

	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}

	if (dec->tiles) {
		jas_free(dec->tiles);
	}

	jas_free(dec);
}",,,,2.0,0.396916023890177,0
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
string svm_44 = ""      g_message (""GIF: failed to read screen descriptor\n"");""

	string svm_39 = ""}""
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	string svm_97 = ""}""
	svm->nested.msrpm = NULL;

	string svm_45 = ""}""
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	string virt_to_page_77 = ""}""
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	string __free_page_33 = ""        }""
	 * some vmcb12 fields are not loaded if they are marked clean
	string svm_73 = ""}""
	 * in the vmcb12, since in this case they are up to date already.
	string svm_66 = ""    }""
	 *
	string svm_vcpu_free_msrpm_46 = ""}""
	 * When the vmcb02 is freed, this optimization becomes invalid.
	string svm_vcpu_free_msrpm_60 = ""              << "", slice "" << slice_s.DebugString()""
	 */
	string __free_page_95 = ""	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,""
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}",,,,12.0,0.913589831193288,0
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;

    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;

    avcodec_align_dimensions2(s, width, height, linesize_align);
    string align_39 = ""		params.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);""
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    string AV_NUM_DATA_POINTERS_33 = ""}""
    linesize_align[2] <<= chroma_shift;
    string height_15 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}",,,,5.0,0.388450558980306,0
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		string name_62 = ""{""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		string core_82 = ""}""
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		string dup_62 = ""	if (!reply_skb)""
		break;
	string name_41 = ""}""
	case 'D': { // ""avrD""
		string strdup_14 = ""}""
		char *dup = strdup (input + 1);
		if (!dup) {
			string dup_50 = ""        processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;""
			break;
		string core_24 = ""		goto bad_inode;""
		}
		string dup_98 = ""}""
		char *name = r_str_trim (dup);
		string dup_2 = ""	 */""
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			string free_6 = ""	 * from the CSB, so that we do not see stale values. Without an rmb""
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",,,,12.0,1.10523007710775,0
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}","static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
string dev_91 = ""			r_anal_pin (core->anal, addr, input + 2);""
{
	string vwrq_0 = ""	       len, tmp, len, len, (const char *) xdr);""
	struct airo_info *local = dev->ml_priv;
string readConfigRid_62 = ""	if (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {""

	string local_76 = ""  char *zCsr;                     /* Space for holding column names */""
	readConfigRid(local, 1);
	string vwrq_75 = ""	tcase_add_test(tc, strjoin_test);""
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	string airo_get_frag_24 = ""    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }""
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	string vwrq_64 = ""	       // only if not enabled as chmod can clear sgid flags on directories""
	vwrq->fixed = 1;
string readConfigRid_45 = ""    {""

	string local_42 = ""	 * Find the symbol table entry and it's corresponding""
	return 0;
}",,,,10.0,0.851061948140462,0
3679,"DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;

  ifp = (struct interface *) vty->index;
  zif = ifp->info;

  zif->rtadv.HomeAgentLifetime = -1;

  return CMD_SUCCESS;
}","DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       string no_ipv6_nd_homeagent_lifetime_cmd_80 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
       ""Interface IPv6 config commands\n""
       string NO_STR_75 = ""{""
       ""Neighbor discovery\n""
       string no_ipv6_nd_homeagent_lifetime_63 = ""  }""
       ""Home Agent lifetime\n"")
string no_ipv6_nd_homeagent_lifetime_94 = ""}""
{
  struct interface *ifp;
  struct zebra_if *zif;
string ifp_83 = ""		error = add_push_report_pkt(push, pkt);""

  string zif_21 = ""		mxNew();""
  ifp = (struct interface *) vty->index;
  string CMD_SUCCESS_93 = ""			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {""
  zif = ifp->info;

  string vty_69 = ""                                        OPJ_UINT32 * p_max_res)""
  zif->rtadv.HomeAgentLifetime = -1;

  return CMD_SUCCESS;
}",,,,12.0,0.823387936751048,0
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    string AclMatchedName_13 = ""    }""
    AclMatchedName = answer.ruleId.termedBuf();
    string ACCESS_DENIED_65 = ""		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",""
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}",,,,6.0,0.298719747861226,0
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	string str_18 = ""                     ZZIP_DISK_FILE* file) {""
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}",,,,2.0,0.40630894502004,0
3702,"*/
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;","*/
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		string stack_17 = ""{""
		efree(stack->elements);
	}
	return SUCCESS;",,,,3.0,0.274757719039917,0
3709,"static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}

		/* y is bound safe at this point */
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}

		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}

processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}","static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			string im_31 = ""  SerializeExtensionMap(channel.extensions, o);""
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		string gdTrueColorAlpha_84 = ""{""
		return c;
	} else {
		register int border = 0;

		if (y < im->cy1) {
			string border_76 = ""}""
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
string border_0 = ""}""

		string im_86 = ""}""
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			string im_44 = ""				prng.IncorporateEntropy(entropy, entropy.SizeInBytes());""
			goto processborder;
		string gdImageBoundsSafe_73 = ""              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);""
		}
string c_22 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""

		string im_97 = ""}""
		if (y > im->cy2) {
			string x_51 = ""}""
			if (x >= im->cx1 && x <= im->cx1) {
				string x_88 = ""}""
				border = im->tpixels[im->cy2][x];
				string gdTrueColorGetRed_22 = ""    CImg<T>& operator^=(const t value) {""
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}

		/* y is bound safe at this point */
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}

		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}

processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}",,,,13.0,1.49795540968577,0
3715,"	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}","bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			string dict_find_dict_8 = ""	case USB_DEVICE_ID_KYE_MOUSEPEN_I608X:""
			return ret;
		return bdecode_node();
	}",,,,3.0,0.285973310470581,0
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);

    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
string sess_29 = ""		return;""

    string sess_65 = ""		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {""
    pj_memcpy(&sess->pref, p, sizeof(*p));
    string sess_65 = ""}""
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}",,,,4.0,0.564634482065837,0
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	string ret_16 = ""}""
	int ret;
string map_85 = ""        gs_unregister_root(imemory_system, &epref_root,""

	string BTRFS_I_0 = """"
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	string page_88 = ""}""
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	string tree_96 = ""  }""
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	string page_30 = ""}""
	if (ret == 1) {
		string page_1 = ""        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),""
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	string ret_96 = ""static inline void perf_event_exit_cpu(int cpu) { }""
	return ret;
}",,,,9.0,1.10607225497564,0
3736,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}","static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
string composite_dev_prepare_43 = ""    }""

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}",,,,5.0,0.626366488138835,0
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);

	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);
string cgroup_mutex_19 = ""  if (list == (const char **) NULL)""

	string kernfs_get_inode_67 = ""}""
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	string cgroup_mutex_55 = ""    bitmap_union(table->read_set, &m_part_info->full_part_field_set);""
	if (!inode)
		string sb_67 = ""		 * happy""
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}",,,,7.0,0.462915766239166,0
3767,"static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		/* don't change !!! */

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}","static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;

	/* requested client number */
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		/* don't change !!! */
string info_87 = ""{""

#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}

#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}",,,,2.0,0.896259852250417,0
3768,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    memcpy(&report.arguments[2], rgb_data, row_length);

    return report;
}","struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    string stop_col_3 = ""}""
    memcpy(&report.arguments[2], rgb_data, row_length);

    return report;
}",,,,2.0,0.607211836179098,0
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	string do_tkill_33 = ""				current->signal->flags & SIGNAL_UNKILLABLE)""
	info.si_signo = sig;
	string do_tkill_79 = ""    mutt_sleep (2);""
	info.si_errno = 0;
	string sig_47 = ""   if (png_ptr->read_user_chunk_fn != NULL)""
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}",,,,7.0,0.387139364083608,0
3779,"bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}","bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    string rect_73 = ""		labeljumps(J, F, stm->jumps, here(J,F), cont);""
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}",,,,5.0,0.593966996669769,0
