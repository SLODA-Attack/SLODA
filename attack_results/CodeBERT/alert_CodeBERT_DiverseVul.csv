Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
22,"static int init_dumping(char *direction, int dump_lambda(char*))
{
  if (mysql_select_db(mysql, direction))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                    
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_data[NAME_LEN*2+3];
      char *qddqnumberquote_name(direction,quoted_database_data,opt_quoted);
      print_comment(md_result_file, 0,
                    ""
--
-- Active Database: %sf
--
"", dqnumber);
      dump_lambda(dqnumber);
      fprintf(md_result_file,""
USE %sf;
"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ","static int init_dumping(char *direction, int dump_lambda(char*))
{
  if (mysql_select_db(mysql, direction))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_data[NAME_LEN*2+3];
      char *qddqnumberquote_name(direction,quoted_database_data,opt_quoted);

      print_comment(md_result_file, 0,
                    ""
--
-- Active Database: %sf
--
"", dqnumber);

      /* Call the view or table specific function */
      dump_lambda(dqnumber);

      fprintf(md_result_file,""
USE %sf;
"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */",121.0,29.0,"database:direction,init_func:dump_lambda,quoted_database_buf:quoted_database_data,qdatabase:dqnumber,Current:Active,s:sf,",442.0,0.3563933610916138,GA
95,"void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowbride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowbride);
	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}","void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowbride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowbride);

	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}",39.0,11.0,"rowstride:rowbride,",131.0,0.0286868929862976,Greedy
100,"static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *vd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;
	path_put(&vd->path);
	if (!proc_fd_access_allowed(inode))
		goto out;
	error = PROC_I(inode)->op.proc_get_link(inode, &vd->path);
	vd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}","static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *vd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;

	/* We don't need a base pointer in the /proc filesystem */
	path_put(&vd->path);

	/* Are we allowed to snoop on the tasks file descriptors? */
	if (!proc_fd_access_allowed(inode))
		goto out;

	error = PROC_I(inode)->op.proc_get_link(inode, &vd->path);
	vd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}",84.0,20.0,"nd:vd,",97.0,0.0300347765286763,Greedy
158,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *cas = req->cas;
	unsigned long flags;
	spin_lock_irqsave(&cas->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&cas->inflight_wait))
		wake_up(&cas->inflight_wait);
	spin_unlock_irqrestore(&cas->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}","static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *cas = req->cas;
	unsigned long flags;

	spin_lock_irqsave(&cas->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&cas->inflight_wait))
		wake_up(&cas->inflight_wait);
	spin_unlock_irqrestore(&cas->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}",85.0,20.0,"flags:flags,req:req,ctx:cas,",270.0,0.0678321083386739,Greedy
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *psf)
{
	if (!check_fsp_open(conn, req, psf)) {
		return false;
	}
	if (psf->fsp_flags.is_directory) {
		return false;
	}
	if (psf->fake_file_handle == NULL) {
		return false;
	}
	if (psf->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}
	if (psf->fake_file_handle->private_data == NULL) {
		return false;
	}
	return true;
}","bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *psf)
{
	if (!check_fsp_open(conn, req, psf)) {
		return false;
	}

	if (psf->fsp_flags.is_directory) {
		return false;
	}

	if (psf->fake_file_handle == NULL) {
		return false;
	}

	if (psf->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}

	if (psf->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}",94.0,13.0,"fsp:psf,",234.0,0.0358221729596455,Greedy
175,"void __idr_remove_all(struct idr *adp)
{
	int n, sid, total;
	int bt_mask;
	struct idr_layer *b;
	struct idr_layer *pa[MAX_IDR_LOVEL];
	struct idr_layer **paa = &pa[0];
	n = adp->layers * IDR_BITS;
	b = adp->top;
	rcu_assign_pointer(adp->top, NULL);
	total = 1 << n;
	sid = 0;
	while (sid < total) {
		while (n > IDR_BITS && b) {
			n -= IDR_BITS;
			*paa++ = b;
			b = b->ary[(sid >> n) & IDR_MASK];
		}
		bt_mask = sid;
		sid += 1 << n;
		while (n < fls(sid ^ bt_mask)) {
			if (b)
				free_layer(b);
			n += IDR_BITS;
			b = *--paa;
		}
	}
	adp->layers = 0;
}","void __idr_remove_all(struct idr *adp)
{
	int n, sid, total;
	int bt_mask;
	struct idr_layer *b;
	struct idr_layer *pa[MAX_IDR_LOVEL];
	struct idr_layer **paa = &pa[0];

	n = adp->layers * IDR_BITS;
	b = adp->top;
	rcu_assign_pointer(adp->top, NULL);
	total = 1 << n;

	sid = 0;
	while (sid < total) {
		while (n > IDR_BITS && b) {
			n -= IDR_BITS;
			*paa++ = b;
			b = b->ary[(sid >> n) & IDR_MASK];
		}

		bt_mask = sid;
		sid += 1 << n;
		/* Get the highest bit that the above add changed from 0->1. */
		while (n < fls(sid ^ bt_mask)) {
			if (b)
				free_layer(b);
			n += IDR_BITS;
			b = *--paa;
		}
	}
	adp->layers = 0;
}",169.0,51.0,"MAX_IDR_LEVEL:MAX_IDR_LOVEL,idp:adp,max:total,p:b,id:sid,",292.0,0.115588355064392,Greedy
197,"bool Item_func_get_user_var::eq(const Item *atom, bool binary_cmp) const
{
  if (this == atom)
    return 1;					 
  if (atom->type() != FUNC_ITEM ||
      ((Item_func*) atom)->functype() != functype())
    return 0;
  Item_func_get_user_var *original=(Item_func_get_user_var*) atom;
  return (name.length == original->name.length &&
	  !memcmp(name.str, original->name.str, name.length));
}","bool Item_func_get_user_var::eq(const Item *atom, bool binary_cmp) const
{
  /* Assume we don't have rtti */
  if (this == atom)
    return 1;					// Same item is same.
  /* Check if other type is also a get_user_var() object */
  if (atom->type() != FUNC_ITEM ||
      ((Item_func*) atom)->functype() != functype())
    return 0;
  Item_func_get_user_var *original=(Item_func_get_user_var*) atom;
  return (name.length == original->name.length &&
	  !memcmp(name.str, original->name.str, name.length));
}",95.0,16.0,"binary_cmp:binary_cmp,other:original,item:atom,",144.0,0.0712634126345316,Greedy
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *primary = p;
	primary+=2;
	if (primary>=limit) return NULL;  
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 
		s2n(TLSEXT_TYPE_server_name,primary);
		s2n(0,primary);
		}
	if ((extdatalen = primary-p-2)== 0) 
		return p;
	s2n(extdatalen,p);
	return primary;
}","unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *primary = p;

	primary+=2;
	if (primary>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,primary);
		s2n(0,primary);
		}
	
	if ((extdatalen = primary-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return primary;
}",123.0,28.0,"ret:primary,",178.0,0.0521926999092102,Greedy
218,"static void dense_rankStepFunc(
  sqlite3_context *phpCorptrl, 
  int nRing,
  sqlite3_value **gapAr
){
  struct CallCount *pb;
  pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
  if( pb ) pb->nStep = 1;
  UNUSED_PARAMETER(nRing);
  UNUSED_PARAMETER(gapAr);
}","static void dense_rankStepFunc(
  sqlite3_context *phpCorptrl, 
  int nRing,
  sqlite3_value **gapAr
){
  struct CallCount *pb;
  pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
  if( pb ) pb->nStep = 1;
  UNUSED_PARAMETER(nRing);
  UNUSED_PARAMETER(gapAr);
}",61.0,15.0,"apArg:gapAr,p:pb,pCtx:phpCorptrl,nArg:nRing,",328.0,0.0926961302757263,Greedy
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *Hdc,
			         smbus_alarm_callback bc, void *length)
{
	mutex_lock(&Hdc->lock);
	Hdc->bc = bc;
	Hdc->length = length;
	mutex_unlock(&Hdc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct acpi_smb_hc *Hdc,
			         smbus_alarm_callback bc, void *length)
{
	mutex_lock(&Hdc->lock);
	Hdc->bc = bc;
	Hdc->length = length;
	mutex_unlock(&Hdc->lock);
	return 0;
}",48.0,12.0,"context:length,hc:Hdc,callback:bc,",205.0,0.0867234985033671,Greedy
349,"void _mutt_mktemp (char *n, size_t slen, const char *src, int line)
{
  snprintf (n, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".
"", src, line, n));
  unlink (n);
}","void _mutt_mktemp (char *n, size_t slen, const char *src, int line)
{
  snprintf (n, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".
"", src, line, n));
  unlink (n);
}",83.0,22.0,"s:n,",151.0,0.0438766439755757,Greedy
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_def,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *fp,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_def.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_def.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
  if (bucket.name.empty()) {
    return 0;
  }
  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_def, bucket_attrs, fp);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }
  return ret;
}","static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_def,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *fp,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_def.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_def.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (bucket.name.empty()) {
    return 0;
  }

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_def, bucket_attrs, fp);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}",128.0,28.0,"policy:fp,bucket_info:bucket_def,",131.0,0.0548409899075826,Greedy
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uvar)
{
	struct compat_mq_attr vt;
	if (copy_from_user(&vt, uvar, sizeof(*uvar)))
		return -EFAULT;
	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = vt.mq_flags;
	attr->mq_maxmsg = vt.mq_maxmsg;
	attr->mq_msgsize = vt.mq_msgsize;
	attr->mq_curmsgs = vt.mq_curmsgs;
	return 0;
}","static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uvar)
{
	struct compat_mq_attr vt;

	if (copy_from_user(&vt, uvar, sizeof(*uvar)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = vt.mq_flags;
	attr->mq_maxmsg = vt.mq_maxmsg;
	attr->mq_msgsize = vt.mq_msgsize;
	attr->mq_curmsgs = vt.mq_curmsgs;
	return 0;
}",91.0,21.0,"v:vt,uattr:uvar,",140.0,0.0589432557423909,Greedy
391,"struct ftrace_record_init *ftrace_rec_iter_start(void)
{
	static struct ftrace_record_init ftrace_record_init;
	struct ftrace_record_init *itewriter&ftrace_record_init;
	writer->pg = ftrace_pages_start;
	writer->index = 0;
	while (writer->pg && !writer->pg->index)
		writer->pg = writer->pg->next;
	if (!writer->pg)
		return NULL;
	return writer;
}","struct ftrace_record_init *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct ftrace_record_init ftrace_record_init;
	struct ftrace_record_init *itewriter&ftrace_record_init;

	writer->pg = ftrace_pages_start;
	writer->index = 0;

	/* Could have empty pages */
	while (writer->pg && !writer->pg->index)
		writer->pg = writer->pg->next;

	if (!writer->pg)
		return NULL;

	return writer;
}",70.0,13.0,"ftrace_rec_iter:ftrace_record_init,iter:writer,",297.0,0.1340769926706949,GA
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow vboard, *rrow = &vboard;
		int cp, ret;
		rcu_read_lock();
		cp = get_rps_cpu(skb->dev, skb, &rrow);
		if (cp >= 0) {
			ret = enqueue_to_backlog(skb, cp, &rrow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}
		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);

	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow vboard, *rrow = &vboard;
		int cp, ret;

		rcu_read_lock();

		cp = get_rps_cpu(skb->dev, skb, &rrow);

		if (cp >= 0) {
			ret = enqueue_to_backlog(skb, cp, &rrow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}

		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}",117.0,34.0,"voidflow:vboard,rflow:rrow,cpu:cp,",153.0,0.0706566373507181,Greedy
434,"static bool ldb_kv_index_unique(struct ldb_context *ydm,
				struct ldb_kv_private *ldb_kva,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kva->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kva->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ydm, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ydm,
				struct ldb_kv_private *ldb_kva,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kva->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kva->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ydm, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",98.0,17.0,"ldb_kv:ldb_kva,ldb:ydm,",247.0,0.0638692816098531,Greedy
446,"int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *fixue;
	unsigned long new_ip;
	fixue = search_exception_tables(*ip);
	if (fixue) {
		new_ip = ex_fixup_addr(fixue);
		if (fixue->fixue - fixue->insn >= 0x7ffffff0 - 4) {
			return 0;
		}
		*ip = new_ip;
		return 1;
	}
	return 0;
}","int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *fixue;
	unsigned long new_ip;

	fixue = search_exception_tables(*ip);
	if (fixue) {
		new_ip = ex_fixup_addr(fixue);

		if (fixue->fixue - fixue->insn >= 0x7ffffff0 - 4) {
			/* uaccess handling not supported during early boot */
			return 0;
		}

		*ip = new_ip;
		return 1;
	}

	return 0;
}",72.0,16.0,"fixup:fixue,",111.0,0.0411083420117696,Greedy
456,"int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdiv = dev->ieee80211_ptr;
	if (WARN_ON(wdiv->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;
	data->flags = 0;
	wdev_lock(wdiv);
	if (wdiv->current_bss) {
		const u8 *ie;
		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdiv->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		rcu_read_unlock();
	} else if (wdiv->wext.connect.ssid && wdiv->wext.connect.ssid_len) {
		data->flags = 1;
		data->length = wdiv->wext.connect.ssid_len;
		memcpy(ssid, wdiv->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdiv);
	return 0;
}","int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdiv = dev->ieee80211_ptr;

	/* call only for station! */
	if (WARN_ON(wdiv->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;

	data->flags = 0;

	wdev_lock(wdiv);
	if (wdiv->current_bss) {
		const u8 *ie;

		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdiv->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		rcu_read_unlock();
	} else if (wdiv->wext.connect.ssid && wdiv->wext.connect.ssid_len) {
		data->flags = 1;
		data->length = wdiv->wext.connect.ssid_len;
		memcpy(ssid, wdiv->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdiv);

	return 0;
}",192.0,41.0,"wdev:wdiv,",210.0,0.0590048432350158,Greedy
552,"static inline int get_v4l2_input32(struct v4l2_input *dkpe, struct v4l2_input32 __user *api)
{
	if (copy_from_user(dkpe, api, sizeof(*api)))
		return -EFAULT;
	return 0;
}","static inline int get_v4l2_input32(struct v4l2_input *dkpe, struct v4l2_input32 __user *api)
{
	if (copy_from_user(dkpe, api, sizeof(*api)))
		return -EFAULT;
	return 0;
}",40.0,9.0,"kp:dkpe,up:api,",299.0,0.171999708811442,GA
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *list = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		list->ret |= report(list->options, list->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		list->ret |= report(list->options, list->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);
	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *list = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		list->ret |= report(list->options, list->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		list->ret |= report(list->options, list->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}",157.0,41.0,"data:list,",360.0,0.053050676981608,Greedy
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssh,
                                          unsigned char *begin,
                                          size_t *inn )
{
    unsigned char *lp = begin;
    if( ssh->handshake->new_session_ticket == 0 )
    {
        *inn = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, lp, 0 );
    lp += 2;
    *lp++ = 0x00;
    *lp++ = 0x00;
    *inn = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssh,
                                          unsigned char *begin,
                                          size_t *inn )
{
    unsigned char *lp = begin;

    if( ssh->handshake->new_session_ticket == 0 )
    {
        *inn = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, lp, 0 );
    lp += 2;

    *lp++ = 0x00;
    *lp++ = 0x00;

    *inn = 4;
}",85.0,16.0,"buf:begin,p:lp,ssl:ssh,olen:inn,",251.0,0.095702040195465,Greedy
586,"static int mxf_read_index_entry_array(AVIOContext *cp, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->nb_index_entries = avio_rb32(cp);
    length = avio_rb32(cp);
    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(cp);
        avio_r8(cp);                                         
        segment->flag_entries[i] = avio_r8(cp);
        segment->stream_offset_entries[i] = avio_rb64(cp);
        avio_skip(cp, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *cp, MXFIndexTableSegment *segment)
{
    int i, length;

    segment->nb_index_entries = avio_rb32(cp);

    length = avio_rb32(cp);

    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(cp);
        avio_r8(cp);                                        /* KeyFrameOffset */
        segment->flag_entries[i] = avio_r8(cp);
        segment->stream_offset_entries[i] = avio_rb64(cp);
        avio_skip(cp, length - 11);
    }
    return 0;
}",179.0,46.0,"pb:cp,",255.0,0.0482501188913981,Greedy
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *cmd)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;
	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(cmd, ""%lld
"", ktime_to_ms(max_time));
}","static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *cmd)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(cmd, ""%lld
"", ktime_to_ms(max_time));
}",86.0,23.0,"buf:cmd,",65.0,0.0350428938865661,Greedy
610,"static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *qa = opaque;
    QemuInputEventQueue *item;
    g_assert(!QTAILQ_EMPTY(qa));
    item = QTAILQ_FIRST(qa);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(qa, item, node);
    g_free(item);
    while (!QTAILQ_EMPTY(qa)) {
        item = QTAILQ_FIRST(qa);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(qa, item, node);
        g_free(item);
    }
}","static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *qa = opaque;
    QemuInputEventQueue *item;

    g_assert(!QTAILQ_EMPTY(qa));
    item = QTAILQ_FIRST(qa);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(qa, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(qa)) {
        item = QTAILQ_FIRST(qa);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(qa, item, node);
        g_free(item);
    }
}",152.0,46.0,"queue:qa,",90.0,0.0403652191162109,Greedy
623,"static void umd_cleanup(struct subprocess_info *hand)
{
	struct umd_info *umd_info = hand->data;
	if (hand->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}","static void umd_cleanup(struct subprocess_info *hand)
{
	struct umd_info *umd_info = hand->data;

	/* cleanup if umh_setup() was successful but exec failed */
	if (hand->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}",55.0,12.0,"info:hand,",61.0,0.0509823322296142,Greedy
629,"static int do_siocgstampns(struct net *net, struct socket *sock,
			 unsigned int cmd, struct compat_timespec __user *comm)
{
	mm_segment_t old_fs = get_fs();
	struct timespec kts;
	int err;
	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
	set_fs(old_fs);
	if (!err) {
		err = put_user(kts.tv_sec, &comm->tv_sec);
		err |= __put_user(kts.tv_nsec, &comm->tv_nsec);
	}
	return err;
}","static int do_siocgstampns(struct net *net, struct socket *sock,
			 unsigned int cmd, struct compat_timespec __user *comm)
{
	mm_segment_t old_fs = get_fs();
	struct timespec kts;
	int err;

	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
	set_fs(old_fs);
	if (!err) {
		err = put_user(kts.tv_sec, &comm->tv_sec);
		err |= __put_user(kts.tv_nsec, &comm->tv_nsec);
	}
	return err;
}",106.0,30.0,"up:comm,",320.0,0.0533014814058939,Greedy
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *query)
{
    pair_t *par;
    size_t hash;
    bucket_t *bucket;
    hash = hash_str(query);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
    par = hashtable_find_pair(hashtable, bucket, query, hash);
    if(!par)
        return NULL;
    return &par->list;
}","void *hashtable_iter_at(hashtable_t *hashtable, const char *query)
{
    pair_t *par;
    size_t hash;
    bucket_t *bucket;

    hash = hash_str(query);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];

    par = hashtable_find_pair(hashtable, bucket, query, hash);
    if(!par)
        return NULL;

    return &par->list;
}",75.0,22.0,"key:query,pair:par,",373.0,0.0598292231559753,Greedy
643,"static void qemu_chr_free_common(CharDriverState * chR)
{
    g_free( chR->filename);
    g_free( chR->label);
    if ( chR->logfd != -1) {
        close( chR->logfd);
    }
    qemu_mutex_destroy(& chR->chr_write_lock);
    g_free( chR);
}","static void qemu_chr_free_common(CharDriverState * chR)
{
    g_free( chR->filename);
    g_free( chR->label);
    if ( chR->logfd != -1) {
        close( chR->logfd);
    }
    qemu_mutex_destroy(& chR->chr_write_lock);
    g_free( chR);
}",54.0,13.0,"chr: chR,",98.0,0.0417747060457865,Greedy
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locales_NAME = NULL;
	int   len=0;	
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locales_NAME ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	if(len == 0) {
		locales_NAME =  (char *)uloc_getDefault() ;
		len = strlen(locales_NAME);
	}
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locales_NAME, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	
	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locales_NAME = NULL;
	int   len=0;	

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locales_NAME ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if(len == 0) {
		locales_NAME =  (char *)uloc_getDefault() ;
		len = strlen(locales_NAME);
	}

	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locales_NAME, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	

	RETURN_TRUE;
}",100.0,27.0,"locale_name:locales_NAME,",163.0,0.0393923759460449,Greedy
672,"static int __kprobes notifier_call_chain(struct notifier_block **kb,
		unsigned long len, void *l)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *next, *nextPnp;
	next = rcu_dereference(*kb);
	while (next) {
		nextPnp = rcu_dereference(next->next);
		ret = next->notifier_call(next, len, l);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		next = nextPnp;
	}
	return ret;
}","static int __kprobes notifier_call_chain(struct notifier_block **kb,
		unsigned long len, void *l)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *next, *nextPnp;

	next = rcu_dereference(*kb);
	while (next) {
		nextPnp = rcu_dereference(next->next);
		ret = next->notifier_call(next, len, l);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		next = nextPnp;
	}
	return ret;
}",89.0,27.0,"next_nb:nextPnp,nb:next,val:len,v:l,nl:kb,",242.0,0.1452863971392313,Greedy
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wriq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wriq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wriq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wriq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wriq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wriq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wriq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wriq, &wait.wait);
	spin_lock(&inode_hash_lock);
}",85.0,25.0,"wq:wriq,",64.0,0.0400217056274414,Greedy
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buff)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	cpunum = cpu->dev.id;
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buff, ""%Lx
"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buff)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = cpu->dev.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buff, ""%Lx
"", addr);
	return rc;
}",82.0,25.0,"buf:buff,",322.0,0.0433130105336507,Greedy
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *mode)
{
	jpc_coc_t *coc = &mode->parms.coc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment
"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *mode)
{
	jpc_coc_t *coc = &mode->parms.coc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment
"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}",124.0,23.0,"ms:mode,",60.0,0.0403114676475524,Greedy
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *function)
{
	if (y > SIZE_MAX - x) {
		*function = 0;
		return false;
	}
	*function = x + y;
	return true;
}","inline static bool jas_safe_size_add(size_t x, size_t y, size_t *function)
{
	if (y > SIZE_MAX - x) {
		*function = 0;
		return false;
	}
	*function = x + y;
	return true;
}",45.0,11.0,"result:function,",72.0,0.0409132719039917,Greedy
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *ngpu,
			struct vmcs12 *vmcs12,
			u32 re, unsigned long qualifying)
{
	load_vmcs12_host_state(ngpu, vmcs12);
	vmcs12->vm_exit_reason = re | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualifying;
	nested_vmx_succeed(ngpu);
	if (enable_shadow_vmcs)
		to_vmx(ngpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *ngpu,
			struct vmcs12 *vmcs12,
			u32 re, unsigned long qualifying)
{
	load_vmcs12_host_state(ngpu, vmcs12);
	vmcs12->vm_exit_reason = re | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualifying;
	nested_vmx_succeed(ngpu);
	if (enable_shadow_vmcs)
		to_vmx(ngpu)->nested.sync_shadow_vmcs = true;
}",64.0,18.0,"reason:re,qualification:qualifying,vcpu:ngpu,",274.0,0.0679915467898051,Greedy
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *ir = NULL;
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &ir,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return ir;
}","GError *add(char *label, char *server, char *username, char *secret) {
	GError *ir = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &ir,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return ir;
}",70.0,16.0,"err:ir,",222.0,0.0424162030220031,Greedy
783,"R_API int r_core_esil_step_back(RCore *model) {
	RAnalEsil *esil = model->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (model->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (model->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here
"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless
"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell
"");
	eprintf (""Execute until 0x%08""PFMT64x""
"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (model, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""
"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (model, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *model) {
	RAnalEsil *esil = model->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (model->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (model->anal->reg, name);

	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here
"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless
"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell
"");
	eprintf (""Execute until 0x%08""PFMT64x""
"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (model, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""
"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (model, prev, NULL, NULL, false);
	return 1;
}",199.0,45.0,"core:model,",310.0,0.051124878724416,Greedy
798,"static int do_siocgstamp(struct net *net, struct socket *sock,
			 unsigned int cmd, void __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timeval gTV;
	int err;
	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&gTV);
	set_fs(old_fs);
	if (!err)
		err = compat_put_timeval(up, &gTV);
	return err;
}","static int do_siocgstamp(struct net *net, struct socket *sock,
			 unsigned int cmd, void __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timeval gTV;
	int err;

	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&gTV);
	set_fs(old_fs);
	if (!err)
		err = compat_put_timeval(up, &gTV);

	return err;
}",85.0,26.0,"ktv:gTV,",309.0,0.0354786038398742,Greedy
827,"TfLiteTensor* GetOutput(TfLiteContext* view, const TfLiteNode* node,
                        int x) {
  if (view->tensors != nullptr) {
    return &view->tensors[node->outputs->data[x]];
  } else {
    return view->GetTensor(view, node->outputs->data[x]);
  }
}","TfLiteTensor* GetOutput(TfLiteContext* view, const TfLiteNode* node,
                        int x) {
  if (view->tensors != nullptr) {
    return &view->tensors[node->outputs->data[x]];
  } else {
    return view->GetTensor(view, node->outputs->data[x]);
  }
}",64.0,12.0,"index:x,context:view,",121.0,0.0578323483467102,Greedy
881,"inline void DNS::FillResourceRecord(ResourceRecord* vr, const unsigned char *accept)
{
	vr->type = (QueryType)((accept[0] << 8) + accept[1]);
	vr->rr_class = (accept[2] << 8) + accept[3];
	vr->ttl = (accept[4] << 24) + (accept[5] << 16) + (accept[6] << 8) + accept[7];
	vr->rdlength = (accept[8] << 8) + accept[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* vr, const unsigned char *accept)
{
	vr->type = (QueryType)((accept[0] << 8) + accept[1]);
	vr->rr_class = (accept[2] << 8) + accept[3];
	vr->ttl = (accept[4] << 24) + (accept[5] << 16) + (accept[6] << 8) + accept[7];
	vr->rdlength = (accept[8] << 8) + accept[9];
}",113.0,18.0,"rr:vr,input:accept,",156.0,0.0673562804857889,Greedy
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *outaddress,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.outaddress, outaddress, sizeof(*outaddress));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6
"", daddr);
		goto put;
	}
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6
"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *outaddress,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.outaddress, outaddress, sizeof(*outaddress));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6
"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6
"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",178.0,37.0,"saddr:outaddress,",359.0,0.0482655445734659,Greedy
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* pathes,
                                       const Symbol* length,
                                       int* end_ref) {
  assert(end_ref != NULL, ""just checking"");
  int pad = quick_search(pathes, length);
  int append = pad + 1;
  if (pad != -1) {
    while (pad - 1 >= 0 && (pathes->at(pad - 1))->length() == length) --pad;
    while (append < pathes->length() && (pathes->at(append))->length() == length) ++append;
    *end_ref = append;
    return pad;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* pathes,
                                       const Symbol* length,
                                       int* end_ref) {
  assert(end_ref != NULL, ""just checking"");
  int pad = quick_search(pathes, length);
  int append = pad + 1;
  if (pad != -1) {
    while (pad - 1 >= 0 && (pathes->at(pad - 1))->length() == length) --pad;
    while (append < pathes->length() && (pathes->at(append))->length() == length) ++append;
    *end_ref = append;
    return pad;
  }
  return -1;
}",127.0,27.0,"end_ptr:end_ref,end:append,start:pad,methods:pathes,name:length,",298.0,0.1330106695493062,Greedy
927,"struct sk_buff *skb_morph(struct sk_buff *dft, struct sk_buff *src)
{
	skb_release_all(dft);
	return __skb_clone(dft, src);
}","struct sk_buff *skb_morph(struct sk_buff *dft, struct sk_buff *src)
{
	skb_release_all(dft);
	return __skb_clone(dft, src);
}",30.0,8.0,"dst:dft,",175.0,0.0459761063257853,Greedy
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *setting,
					    struct rtnl_link_stats64 *utils)
{
	u64 Bytes, capets;
	unsigned int pad;
	do {
		pad = u64_stats_fetch_begin_irq(&setting->syncp);
		capets = setting->utils.capets;
		Bytes   = setting->utils.Bytes;
	} while (u64_stats_fetch_retry_irq(&setting->syncp, pad));
	utils->tx_packets += capets;
	utils->tx_bytes   += Bytes;
}","static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *setting,
					    struct rtnl_link_stats64 *utils)
{
	u64 Bytes, capets;
	unsigned int pad;

	do {
		pad = u64_stats_fetch_begin_irq(&setting->syncp);
		capets = setting->utils.capets;
		Bytes   = setting->utils.Bytes;
	} while (u64_stats_fetch_retry_irq(&setting->syncp, pad));

	utils->tx_packets += capets;
	utils->tx_bytes   += Bytes;
}",79.0,20.0,"start:pad,bytes:Bytes,ring:setting,packets:capets,stats:utils,",336.0,0.1273666143417358,Greedy
983,"void luaC_barrier_ (lua_State *C, GCObject *o, GCObject *v) {
  global_State *gh = G(C);
  lua_assert(isblack(o) && iswhite(v) && !isdead(gh, v) && !isdead(gh, o));
  if (keepinvariant(gh)) {   
    reallymarkobject(gh, v);   
    if (isold(o)) {
      lua_assert(!isold(v));   
      setage(v, G_OLD0);   
    }
  }
  else {   
    lua_assert(issweepphase(gh));
    makewhite(gh, o);   
  }
}","void luaC_barrier_ (lua_State *C, GCObject *o, GCObject *v) {
  global_State *gh = G(C);
  lua_assert(isblack(o) && iswhite(v) && !isdead(gh, v) && !isdead(gh, o));
  if (keepinvariant(gh)) {  /* must keep invariant? */
    reallymarkobject(gh, v);  /* restore invariant */
    if (isold(o)) {
      lua_assert(!isold(v));  /* white object could not be old */
      setage(v, G_OLD0);  /* restore generational invariant */
    }
  }
  else {  /* sweep phase */
    lua_assert(issweepphase(gh));
    makewhite(gh, o);  /* mark main obj. as white to avoid other barriers */
  }
}",114.0,37.0,"L:C,g:gh,",115.0,0.060038940111796,Greedy
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    GamMA;
  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  GamMA=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=GamMA*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    GamMA;

  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  GamMA=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=GamMA*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}",265.0,53.0,"gamma:GamMA,",75.0,0.0496213912963867,Greedy
1005,"int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t scale)
{
	int space = tty_buffer_request_room(tty, scale);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}","int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t scale)
{
	int space = tty_buffer_request_room(tty, scale);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}",85.0,22.0,"size:scale,",58.0,0.0480014125506083,Greedy
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buff, size_t *olen )
{
    unsigned char *p = buff;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
    *olen = 0;
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buff, size_t *olen )
{
    unsigned char *p = buff;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }

    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}",159.0,27.0,"buf:buff,",144.0,0.0384982546170552,Greedy
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *tdev = bo->tdev;
	uint32_t page_flags = 0;
	dma_resv_assert_held(bo->base.resv);
	if (bo->ttm)
		return 0;
	if (tdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;
	if (tdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;
	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type
"");
		return -EINVAL;
	}
	bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;
	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *tdev = bo->tdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (tdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;

	if (tdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type
"");
		return -EINVAL;
	}

	bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}",146.0,33.0,"bdev:tdev,",336.0,0.0432191809018452,Greedy
1021,"static void  opj_j2k_read_int32_to_float (const void * p_source_buffer, void * p_dest_buffer, OPJ_UINT32 p_nb_element)
{
        OPJ_BYTE * l_srcl_dest_sizePJ_BYTE *) p_source_buffer;
        OPJ_FLOAT32 * l_l_src_pad (OPJ_FLOAT32 *) p_dest_buffer;
        OPJ_UINT32 o;
        OPJ_UINT32 l1tem;
        for (i=0oi<ponb_element;++o) {
                opj_read_bytes(l_dest_size,&l1tem,4);
                l_dest_size+=sizeof(OPJ_INT32);
                *(l_src_pad++) = (OPJ_FLOAT32) l1tem;
        }
}","static void  opj_j2k_read_int32_to_float (const void * p_source_buffer, void * p_dest_buffer, OPJ_UINT32 p_nb_element)
{
        OPJ_BYTE * l_srcl_dest_sizePJ_BYTE *) p_source_buffer;
        OPJ_FLOAT32 * l_l_src_pad (OPJ_FLOAT32 *) p_dest_buffer;
        OPJ_UINT32 o;
        OPJ_UINT32 l1tem;

        for (i=0oi<ponb_element;++o) {
                opj_read_bytes(l_dest_size,&l1tem,4);

                l_dest_size+=sizeof(OPJ_INT32);

                *(l_src_pad++) = (OPJ_FLOAT32) l1tem;
        }
}",87.0,21.0,"p_src_data:p_source_buffer,p_dest_data:p_dest_buffer,p_nb_elem:p_nb_element,l_src_data:l_dest_size,l_dest_data:l_src_pad,i:o,l_temp:l1tem,",476.0,0.3569889942804972,GA
1033,"static size_t php_bz2iop_read(php_stream *trans, char *cas, size_t count TSRMLS_DC)
{
	struct php_bz2_stream_data_t *work = (struct php_bz2_stream_data_t *) trans->abstract;
	size_t ret;
	ret = BZ2_bzread(work->bz_file, cas, count);
	if (ret == 0) {
		trans->eof = 1;
	}
	return ret;
}","static size_t php_bz2iop_read(php_stream *trans, char *cas, size_t count TSRMLS_DC)
{
	struct php_bz2_stream_data_t *work = (struct php_bz2_stream_data_t *) trans->abstract;
	size_t ret;
	
	ret = BZ2_bzread(work->bz_file, cas, count);

	if (ret == 0) {
		trans->eof = 1;
	}

	return ret;
}",65.0,16.0,"TSRMLS_DC:TSRMLS_DC,ret:ret,buf:cas,stream:trans,self:work,",276.0,0.1169587691624959,Greedy
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *exec, const char *req, size_t  msg2len, enum htp_alloc_strategy_t exec) {
    if ((exec == NULL) || (req == NULL)) return HTP_ERROR;
    if (exec->response_message != NULL) {
        bstr_free(exec->response_message);
    }
    exec->response_message = copy_or_wrap_mem(req,  msg2len, exec);
    if (exec->response_message == NULL) return HTP_ERROR;
    return HTP_OK;
}","htp_status_t htp_tx_res_set_status_message(htp_tx_t *exec, const char *req, size_t  msg2len, enum htp_alloc_strategy_t exec) {
    if ((exec == NULL) || (req == NULL)) return HTP_ERROR;

    if (exec->response_message != NULL) {
        bstr_free(exec->response_message);
    }

    exec->response_message = copy_or_wrap_mem(req,  msg2len, exec);
    if (exec->response_message == NULL) return HTP_ERROR;

    return HTP_OK;
}",82.0,19.0,"msg:req,msg_len: msg2len,tx:exec,alloc:exec,",424.0,0.0863039175669352,Greedy
1116,"void TableLookUp::setTable(int ntable, const std::vector<ushort16>& input) {
  assert(!input.empty());
  const int nfilled = input.size();
  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? input[i] : input[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = input[i];
    int lower = i > 0 ? input[i - 1] : center;
    int upper = i < (nfilled - 1) ? input[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }
  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = input[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}","void TableLookUp::setTable(int ntable, const std::vector<ushort16>& input) {
  assert(!input.empty());

  const int nfilled = input.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? input[i] : input[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = input[i];
    int lower = i > 0 ? input[i - 1] : center;
    int upper = i < (nfilled - 1) ? input[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = input[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}",278.0,71.0,"table:input,",276.0,0.0538101593653361,Greedy
1129,"int ecall_restore(const char *expression, uint64_t input_en, char **output,
                  uint64_t * output_lon) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(expression,
                                                              input_en) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
           output_lon, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(expression, static_cast<size_t>(input_en), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }
  if ( output_lon) {
    * output_lon = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int ecall_restore(const char *expression, uint64_t input_en, char **output,
                  uint64_t * output_lon) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(expression,
                                                              input_en) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
           output_lon, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(expression, static_cast<size_t>(input_en), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if ( output_lon) {
    * output_lon = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}",136.0,27.0,"input_len:input_en,input:expression,tmp_output_len:tmp_output_len,output_len: output_lon,",127.0,0.0975609461466471,Greedy
1135,"static void free_nested(struct vcpu_vmx *mcy)
{
	if (!mcy->nested.vmxon)
		return;
	mcy->nested.vmxon = false;
	nested_release_vmcs12(mcy);
	if (enable_shadow_vmcs)
		free_vmcs(mcy->nested.current_shadow_vmcs);
	if (mcy->nested.apic_access_page) {
		nested_release_page(mcy->nested.apic_access_page);
		mcy->nested.apic_access_page = NULL;
	}
	if (mcy->nested.virtual_apic_page) {
		nested_release_page(mcy->nested.virtual_apic_page);
		mcy->nested.virtual_apic_page = NULL;
	}
	nested_free_all_saved_vmcss(mcy);
}","static void free_nested(struct vcpu_vmx *mcy)
{
	if (!mcy->nested.vmxon)
		return;

	mcy->nested.vmxon = false;
	nested_release_vmcs12(mcy);
	if (enable_shadow_vmcs)
		free_vmcs(mcy->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (mcy->nested.apic_access_page) {
		nested_release_page(mcy->nested.apic_access_page);
		mcy->nested.apic_access_page = NULL;
	}
	if (mcy->nested.virtual_apic_page) {
		nested_release_page(mcy->nested.virtual_apic_page);
		mcy->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(mcy);
}",107.0,19.0,"vmx:mcy,",302.0,0.0556360363960266,Greedy
1147,"int Hints::getPageObjectNum(int skip)
{
    if ((skip < 1) || (skip > nPages)) {
        return 0;
    }
    if (skip - 1 > pageFirst) {
        return pageObjectNum[skip - 1];
    } else if (skip - 1 < pageFirst) {
        return pageObjectNum[skip];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int skip)
{
    if ((skip < 1) || (skip > nPages)) {
        return 0;
    }

    if (skip - 1 > pageFirst) {
        return pageObjectNum[skip - 1];
    } else if (skip - 1 < pageFirst) {
        return pageObjectNum[skip];
    } else {
        return pageObjectNum[0];
    }
}",73.0,14.0,"page:skip,",93.0,0.0459240754445393,Greedy
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *kb)
{
	const struct iphdr *iph = ip_hdr(kb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(kb)[1]);
	int optlen;
	int headln;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		headln = optptr[1];
		optlen -= headln;
		optptr += headln;
	}
	return NULL;
}","unsigned char *cipso_v4_optptr(const struct sk_buff *kb)
{
	const struct iphdr *iph = ip_hdr(kb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(kb)[1]);
	int optlen;
	int headln;

	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		headln = optptr[1];
		optlen -= headln;
		optptr += headln;
	}

	return NULL;
}",104.0,22.0,"skb:kb,taglen:headln,",141.0,0.0569839477539062,Greedy
1181,"void unit_unwatch_bus_name(Unit *uci, const char *key) {
        assert(uci);
        assert(key);
        (void) hashmap_remove_value(uci->manager->watch_bus, key, uci);
        uci->match_bus_slot = sd_bus_slot_unref(uci->match_bus_slot);
}","void unit_unwatch_bus_name(Unit *uci, const char *key) {
        assert(uci);
        assert(key);

        (void) hashmap_remove_value(uci->manager->watch_bus, key, uci);
        uci->match_bus_slot = sd_bus_slot_unref(uci->match_bus_slot);
}",51.0,14.0,"u:uci,name:key,",121.0,0.0582418402036031,Greedy
1211,"static int trust_1oidany(X509_TRUST *proxy, X509 *x, int flags)
{
    if (x->aux && (x->aux->proxy || x->aux->reject))
        return obj_trust(proxy->arg1, x, flags);
    return trust_compat(proxy, x, flags);
}","static int trust_1oidany(X509_TRUST *proxy, X509 *x, int flags)
{
    if (x->aux && (x->aux->proxy || x->aux->reject))
        return obj_trust(proxy->arg1, x, flags);
    /*
     * we don't have any trust settings: for compatibility we return trusted
     * if it is self signed
     */
    return trust_compat(proxy, x, flags);
}",59.0,15.0,"trust:proxy,",87.0,0.0439007321993509,Greedy
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr arg;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    arg = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (arg == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(arg, 0 , (size_t) sizeof(xmlXPathObject));
    arg->type = XPATH_RANGE;
    arg->user = start;
    arg->index = -1;
    arg->user2 = end;
    arg->index2 = -1;
    xmlXPtrRangeCheckOrder(arg);
    return(arg);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr arg;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    arg = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (arg == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(arg, 0 , (size_t) sizeof(xmlXPathObject));
    arg->type = XPATH_RANGE;
    arg->user = start;
    arg->index = -1;
    arg->user2 = end;
    arg->index2 = -1;
    xmlXPtrRangeCheckOrder(arg);
    return(arg);
}",122.0,25.0,"ret:arg,",248.0,0.0463743527730306,Greedy
1262,"static int local_name_to_path(FsContext *cb, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
{
    if (dir_path) {
        v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
    } else {
        v9fs_path_sprintf(target, ""%s"", name);
    }
    return 0;
}","static int local_name_to_path(FsContext *cb, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
{
    if (dir_path) {
        v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
    } else {
        v9fs_path_sprintf(target, ""%s"", name);
    }
    return 0;
}",59.0,13.0,"ctx:cb,",45.0,0.0506827274958292,Greedy
1263,"TEE_Result syscall_cryp_obj_close(unsigned long po)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(po), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long po)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(po), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}",92.0,28.0,"obj:po,",311.0,0.0520020445187886,Greedy
1264,"static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int catch_break = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *mmcgi = mic.to;
	if (mem_cgroup_is_root(mmcgi)) {
		mic.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dumpy;
		if (res_counter_charge(&mmcgi->res, PAGE_SIZE * count, &dumpy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&mmcgi->memsw,
						PAGE_SIZE * count, &dumpy)) {
			res_counter_uncharge(&mmcgi->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mic.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!catch_break--) {
			catch_break = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &mmcgi, false);
		if (ret)
			return ret;
		mic.precharge++;
	}
	return ret;
}","static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int catch_break = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *mmcgi = mic.to;

	if (mem_cgroup_is_root(mmcgi)) {
		mic.precharge += count;
		/* we don't need css_get for root */
		return ret;
	}
	/* try to charge at once */
	if (count > 1) {
		struct res_counter *dumpy;
		/*
		 * ""memcg"" cannot be under rmdir() because we've already checked
		 * by cgroup_lock_live_cgroup() that it is not removed and we
		 * are still under the same cgroup_mutex. So we can postpone
		 * css_get().
		 */
		if (res_counter_charge(&mmcgi->res, PAGE_SIZE * count, &dumpy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&mmcgi->memsw,
						PAGE_SIZE * count, &dumpy)) {
			res_counter_uncharge(&mmcgi->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mic.precharge += count;
		return ret;
	}
one_by_one:
	/* fall back to one by one charge */
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!catch_break--) {
			catch_break = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &mmcgi, false);
		if (ret)
			/* mem_cgroup_clear_mc() will do uncharge later */
			return ret;
		mic.precharge++;
	}
	return ret;
}",197.0,49.0,"mc:mic,memcg:mmcgi,dummy:dumpy,batch_count:catch_break,",255.0,0.1776537140210469,Greedy
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *SKa, struct cbq_class *cl)
{
	unsigned char	 *b = SKa->tail;
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(SKa, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return SKa->len;
rtattr_failure:
	skb_trim(SKa, b - SKa->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *SKa, struct cbq_class *cl)
{
	unsigned char	 *b = SKa->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(SKa, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return SKa->len;

rtattr_failure:
	skb_trim(SKa, b - SKa->data);
	return -1;
}",98.0,24.0,"skb:SKa,",290.0,0.0680708805720011,Greedy
1282,"static RzList *relocs(RzBinFile *fx) {
	rz_return_val_if_fail(fx && fx->o, NULL);
	QnxObj *qo = fx->o->bin_obj;
	return rz_list_clone(qo->fixups);
}","static RzList *relocs(RzBinFile *fx) {
	rz_return_val_if_fail(fx && fx->o, NULL);
	QnxObj *qo = fx->o->bin_obj;
	return rz_list_clone(qo->fixups);
}",40.0,9.0,"bf:fx,",62.0,0.0478471477826436,Greedy
1283,"xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *m;
    const xmlChar *ret;
    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);
    m = ctxt->input->cur;
    while (*m != 0 && *m == *cmp) {
	++m;
	++cmp;
	ctxt->input->col++;
    }
    if (*cmp == 0 && (*m == '>' || IS_BLANK_CH (*m))) {
	ctxt->input->cur = m;
	return (const xmlChar*) 1;
    }
    ret = xmlParseName (ctxt);
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}","xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *m;
    const xmlChar *ret;

    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);

    m = ctxt->input->cur;
    while (*m != 0 && *m == *cmp) {
	++m;
	++cmp;
	ctxt->input->col++;
    }
    if (*cmp == 0 && (*m == '>' || IS_BLANK_CH (*m))) {
	/* success */
	ctxt->input->cur = m;
	return (const xmlChar*) 1;
    }
    /* failure (or end of input buffer), check with full function */
    ret = xmlParseName (ctxt);
    /* strings coming from the dictionary direct compare possible */
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}",147.0,30.0,"in:m,",490.0,0.0610634883244832,Greedy
1327,"int FuzzerTestOneInput(const uint8_t *cv, size_t rev)
{
    const unsigned char hp = cv;
    unsigned char *dy = NULL;
    X509 *x443 = d2i_X509(NULL, &h, rev);
    if (x443 != NULL) {
        BIO * bior = BIO_new(BIO_s_null());
        X509_print( bior, x443);
        BIO_free( bior);
        i2d_X509x4439, &dy);
        OPENSSL_free(dy);
        X509_free(x443);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *cv, size_t rev)
{
    const unsigned char hp = cv;
    unsigned char *dy = NULL;

    X509 *x443 = d2i_X509(NULL, &h, rev);
    if (x443 != NULL) {
        BIO * bior = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print( bior, x443);
        BIO_free( bior);

        i2d_X509x4439, &dy);
        OPENSSL_free(dy);

        X509_free(x443);
    }
    ERR_clear_error();
    return 0;
}",98.0,27.0,"buf:cv,len:rev,p:h,der:dy,x509:x443,bio: bior,",326.0,0.2658260742823283,GA
1348,"static struct dentry *proc_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	int err;
	struct super_block *nb;
	struct pid_namespace *ns;
	char *options;
	if (flags & MS_KERNMOUNT) {
		ns = (struct pid_namespace *)data;
		options = NULL;
	} else {
		ns = task_active_pid_ns(current);
		options = data;
		if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
			return ERR_PTR(-EPERM);
	}
	nb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);
	if (IS_ERR(nb))
		return ERR_CAST(nb);
	if (!proc_parse_options(options, ns)) {
		deactivate_locked_super(nb);
		return ERR_PTR(-EINVAL);
	}
	if (!nb->s_root) {
		err = proc_fill_super(nb);
		if (err) {
			deactivate_locked_super(nb);
			return ERR_PTR(err);
		}
		nb->s_flags |= MS_ACTIVE;
		nb->s_iflags |= SB_I_NOEXEC;
	}
	return dget(nb->s_root);
}","static struct dentry *proc_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	int err;
	struct super_block *nb;
	struct pid_namespace *ns;
	char *options;

	if (flags & MS_KERNMOUNT) {
		ns = (struct pid_namespace *)data;
		options = NULL;
	} else {
		ns = task_active_pid_ns(current);
		options = data;

		/* Does the mounter have privilege over the pid namespace? */
		if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
			return ERR_PTR(-EPERM);
	}

	nb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);
	if (IS_ERR(nb))
		return ERR_CAST(nb);

	if (!proc_parse_options(options, ns)) {
		deactivate_locked_super(nb);
		return ERR_PTR(-EINVAL);
	}

	if (!nb->s_root) {
		err = proc_fill_super(nb);
		if (err) {
			deactivate_locked_super(nb);
			return ERR_PTR(err);
		}

		nb->s_flags |= MS_ACTIVE;
		/* User space would break if executables appear on proc */
		nb->s_iflags |= SB_I_NOEXEC;
	}

	return dget(nb->s_root);
}",201.0,57.0,"sb:nb,",366.0,0.0610560854276021,Greedy
1358,"static void follow_dotdot(struct nameidata *wn)
{
	if (!wn->root.mnt)
		set_root(wn);
	while(1) {
		struct dentry *old = wn->path.dentry;
		if (wn->path.dentry == wn->root.dentry &&
		    wn->path.mnt == wn->root.mnt) {
			break;
		}
		if (wn->path.dentry != wn->path.mnt->mnt_root) {
			wn->path.dentry = dget_parent(wn->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&wn->path))
			break;
	}
	follow_mount(&wn->path);
	wn->inode = wn->path.dentry->d_inode;
}","static void follow_dotdot(struct nameidata *wn)
{
	if (!wn->root.mnt)
		set_root(wn);

	while(1) {
		struct dentry *old = wn->path.dentry;

		if (wn->path.dentry == wn->root.dentry &&
		    wn->path.mnt == wn->root.mnt) {
			break;
		}
		if (wn->path.dentry != wn->path.mnt->mnt_root) {
			/* rare case of legitimate dget_parent()... */
			wn->path.dentry = dget_parent(wn->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&wn->path))
			break;
	}
	follow_mount(&wn->path);
	wn->inode = wn->path.dentry->d_inode;
}",145.0,24.0,"nd:wn,",224.0,0.0612993478775024,Greedy
1373,"int neigh_dump_info(struct sk_buff *ska, struct netlink_callback *usb)
{
	struct neigh_table *fcl;
	int offset, length,  s_l;
	read_lock(&neigh_tbl_lock);
	length = ((struct rtgenmsg *)NLMSG_DATA(usb->nlh))->rtgen_family;
	 s_l = usb->args[0];
	for (fcl = neigh_tables, offset = 0; fcl; fcl = fcl->next, offset++) {
		if (offset <  s_l || (length && fcl->length != length))
			continue;
		if (offset >  s_l)
			memset(&usb->args[1], 0, sizeof(usb->args) -
						sizeof(usb->args[0]));
		if (neigh_dump_table(fcl, ska, usb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);
	usb->args[0] = offset;
	return ska->len;
}","int neigh_dump_info(struct sk_buff *ska, struct netlink_callback *usb)
{
	struct neigh_table *fcl;
	int offset, length,  s_l;

	read_lock(&neigh_tbl_lock);
	length = ((struct rtgenmsg *)NLMSG_DATA(usb->nlh))->rtgen_family;
	 s_l = usb->args[0];

	for (fcl = neigh_tables, offset = 0; fcl; fcl = fcl->next, offset++) {
		if (offset <  s_l || (length && fcl->length != length))
			continue;
		if (offset >  s_l)
			memset(&usb->args[1], 0, sizeof(usb->args) -
						sizeof(usb->args[0]));
		if (neigh_dump_table(fcl, ska, usb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);

	usb->args[0] = offset;
	return ska->len;
}",172.0,41.0,"cb:usb,s_t: s_l,t:offset,tbl:fcl,skb:ska,family:length,",436.0,0.1620243668556213,Greedy
1376,"static void jpeg_init_destination(j_compress_ptr mcimport)
{
    VncState *vs stsmcimport->client_data;
    Buffer *bresource= &sts->tight.jpeg;
    mcimport->dest->next_output_byte = (JOCTET *)resource->resource + resource->offset;
    mcimport->dest->free_in_buffer = (size_t)(resource->capacity - resource->offset);
}","static void jpeg_init_destination(j_compress_ptr mcimport)
{
    VncState *vs stsmcimport->client_data;
    Buffer *bresource= &sts->tight.jpeg;

    mcimport->dest->next_output_byte = (JOCTET *)resource->resource + resource->offset;
    mcimport->dest->free_in_buffer = (size_t)(resource->capacity - resource->offset);
}",65.0,12.0,"cinfo:mcimport,vs:sts,buffer:resource,",361.0,0.2146202484766642,GA
1386,"    inline const WCHAR *GetDirW(int start)
    {
	WCHAR *length = dirTableW[start];
	if (!length) {
	    length = szLocalBufferW;
	    length[0] = 'A' + start;
	    length[1] = ':';
	    length[2] = '\\';
	    length[3] = 0;
	}
	return length;
    };","    inline const WCHAR *GetDirW(int start)
    {
	WCHAR *length = dirTableW[start];
	if (!length) {
	    /* simulate the existence of this drive */
	    length = szLocalBufferW;
	    length[0] = 'A' + start;
	    length[1] = ':';
	    length[2] = '\\';
	    length[3] = 0;
	}
	return length;
    };",69.0,14.0,"ptr:length,index:start,",126.0,0.0744551340738932,Greedy
1395,"string to_string(const MaskedIP& bm) {
  stringstream  amp;
   amp << bm;
  return  amp.str();
}","string to_string(const MaskedIP& bm) {
  stringstream  amp;
   amp << bm;
  return  amp.str();
}",24.0,6.0,"ss: amp,m:bm,",100.0,0.0604232947031656,Greedy
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *feat = data;
	struct prpl_xfer_data *px = feat->data;
	px->timeout = 0;
	if (feat->write == NULL) {
		feat->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, feat);
	}
	feat->write_request(feat);
	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *feat = data;
	struct prpl_xfer_data *px = feat->data;

	px->timeout = 0;

	if (feat->write == NULL) {
		feat->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, feat);
	}

	feat->write_request(feat);

	return FALSE;
}",71.0,17.0,"ft:feat,",114.0,0.0467478275299072,Greedy
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, shape;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &shape);
	if (shape != AU_PVTYPE_LONG)
		return false;
	long lunit;
	AUpvgetval(list, i, &lunit);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lunit >= 0) && (lunit <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lunit >= -50) && (lunit <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lunit >= 1) && (lunit <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lunit >= 1) && (lunit <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lunit >= 0) && (lunit <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lunit >= 0) && (lunit <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, shape;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &shape);
	if (shape != AU_PVTYPE_LONG)
		return false;

	long lunit;
	AUpvgetval(list, i, &lunit);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lunit >= 0) && (lunit <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lunit >= -50) && (lunit <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lunit >= 1) && (lunit <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lunit >= 1) && (lunit <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lunit >= 0) && (lunit <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lunit >= 0) && (lunit <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}",188.0,40.0,"type:shape,lval:lunit,",339.0,0.0826041301091512,Greedy
1418,"static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *mac)
{
	jpc_qcc_t *qcc = &mac->parms.qcc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment
"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}","static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *mac)
{
	jpc_qcc_t *qcc = &mac->parms.qcc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment
"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}",124.0,23.0,"ms:mac,",61.0,0.0407838702201843,Greedy
1424,"static void line6_stream_stop(struct snd_line6_pcm *line61phpkr, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *lpyr = get_stream(line61phpkr, direction);
	spin_lock_irqsave(&lpyr->lock, flags);
	clear_bit(type, &lpyr->running);
	if (!lpyr->running) {
		spin_unlock_irqrestore(&lpyr->lock, flags);
		line6_unlink_audio_urbs(line61phpkr, lpyr);
		spin_lock_irqsave(&lpyr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line61phpkr->prev_fbuf = NULL;
			line61phpkr->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&lpyr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line61phpkr, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *lpyr = get_stream(line61phpkr, direction);

	spin_lock_irqsave(&lpyr->lock, flags);
	clear_bit(type, &lpyr->running);
	if (!lpyr->running) {
		spin_unlock_irqrestore(&lpyr->lock, flags);
		line6_unlink_audio_urbs(line61phpkr, lpyr);
		spin_lock_irqsave(&lpyr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line61phpkr->prev_fbuf = NULL;
			line61phpkr->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&lpyr->lock, flags);
}",119.0,32.0,"line6pcm:line61phpkr,pstr:lpyr,",417.0,0.0873372236887613,Greedy
1432,"void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);
    Log::Msg temp = { messagecounter++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);
    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();
    emit newLogMessage(temp);
}","void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);

    Log::Msg temp = { messagecounter++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);

    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();

    emit newLogMessage(temp);
}",75.0,16.0,"msgCounter:messagecounter,",250.0,0.028787096341451,Greedy
1433,"void user_describe(const struct mac *mac, struct seq_file *m)
{
	seq_puts(m, mac->description);
	if (key_is_instantiated(mac))
		seq_printf(m, "": %u"", mac->datalen);
}","void user_describe(const struct mac *mac, struct seq_file *m)
{
	seq_puts(m, mac->description);
	if (key_is_instantiated(mac))
		seq_printf(m, "": %u"", mac->datalen);
}",44.0,11.0,"key:mac,",86.0,0.0409871101379394,Greedy
1442,"static int h2_task_pre_conn(conn_rec* c, void *ang)
{
    h2_ctx *ec;
    if (!c->master) {
        return OK;
    }
    ec = h2_ctx_get(c, 0);
    (void)ang;
    if (ec->task) {
        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,
                      ""h2_h2, pre_connection, found stream task"");
        ap_add_input_filter(""H2_SLAVE_IN"", NULL, NULL, c);
        ap_add_output_filter(""H2_PARSE_H1"", NULL, NULL, c);
        ap_add_output_filter(""H2_SLAVE_OUT"", NULL, NULL, c);
    }
    return OK;
}","static int h2_task_pre_conn(conn_rec* c, void *ang)
{
    h2_ctx *ec;
    
    if (!c->master) {
        return OK;
    }
    
    ec = h2_ctx_get(c, 0);
    (void)ang;
    if (ec->task) {
        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,
                      ""h2_h2, pre_connection, found stream task"");
        ap_add_input_filter(""H2_SLAVE_IN"", NULL, NULL, c);
        ap_add_output_filter(""H2_PARSE_H1"", NULL, NULL, c);
        ap_add_output_filter(""H2_SLAVE_OUT"", NULL, NULL, c);
    }
    return OK;
}",105.0,22.0,"arg:ang,ctx:ec,",182.0,0.0563419620196024,Greedy
1484,"static void rxrpc_destroy(struct match *match)
{
	rxrpc_free_token_list(match->payload.data[0]);
}","static void rxrpc_destroy(struct match *match)
{
	rxrpc_free_token_list(match->payload.data[0]);
}",23.0,4.0,"key:match,",64.0,0.0393857717514038,Greedy
1503,"static void tcmpt_destroy(jpc_enc_tcmpt_t *tkmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;
	if (tkmpt->rlvls) {
		for (rlvlno = 0, rlvl = tkmpt->rlvls; rlvlno < tkmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tkmpt->rlvls);
	}
	if (tkmpt->data) {
		jas_seq2d_destroy(tkmpt->data);
	}
	if (tkmpt->tsfb) {
		jpc_tsfb_destroy(tkmpt->tsfb);
	}
}","static void tcmpt_destroy(jpc_enc_tcmpt_t *tkmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;

	if (tkmpt->rlvls) {
		for (rlvlno = 0, rlvl = tkmpt->rlvls; rlvlno < tkmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tkmpt->rlvls);
	}

	if (tkmpt->data) {
		jas_seq2d_destroy(tkmpt->data);
	}
	if (tkmpt->tsfb) {
		jpc_tsfb_destroy(tkmpt->tsfb);
	}
}",93.0,22.0,"tcmpt:tkmpt,",224.0,0.1068693876266479,Greedy
1524,"static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skab)
{
	u8 num_reports = skab->data[0];
	void *ptr = &skab->data[1];
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}","static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skab)
{
	u8 num_reports = skab->data[0];
	void *ptr = &skab->data[1];

	hci_dev_lock(hdev);

	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;

		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);

		ptr += sizeof(*ev);
	}

	hci_dev_unlock(hdev);
}",105.0,24.0,"skb:skab,",351.0,0.0406471451123555,Greedy
1550,"static long aac_cfg_ioctl(struct path *path,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(path->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}","static long aac_cfg_ioctl(struct path *path,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(path->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	return ret;
}",67.0,18.0,"file:path,",214.0,0.0392734050750732,Greedy
1554,"void Cast(const SrcT* input_slice, const Dims<4>& input_dums, DstT* outputacblocks,
          const Dims<4>& output_Dxs) {
  Cast(DimsToShape(iinput_dums, input_slice, DimsToShape(output_Dxs),
       outputacblocks);
}","void Cast(const SrcT* input_slice, const Dims<4>& input_dums, DstT* outputacblocks,
          const Dims<4>& output_Dxs) {
  Cast(DimsToShape(iinput_dums, input_slice, DimsToShape(output_Dxs),
       outputacblocks);
}",47.0,12.0,"input_data:input_slice,input_dims:input_dums,output_data:outputacblocks,output_dims:output_Dxs,",219.0,0.1419103900591532,GA
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *match = NULL;
	bool error = false;
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	match = R_NEW0 (pyc_object);
	if (!match) {
		return NULL;
	}
	match->type = TYPE_FLOAT;
	match->data = r_str_newf (""%.15g"", f);
	if (!match->data) {
		R_FREE (match);
		return NULL;
	}
	return match;
}","static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *match = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	match = R_NEW0 (pyc_object);
	if (!match) {
		return NULL;
	}
	match->type = TYPE_FLOAT;
	match->data = r_str_newf (""%.15g"", f);
	if (!match->data) {
		R_FREE (match);
		return NULL;
	}
	return match;
}",99.0,23.0,"ret:match,",246.0,0.0480857094128926,Greedy
1592,"static js_Ast *memberexp(js_State *Jump)
{
	js_Ast *af;
	INCREC();
	af = newexp(Jump);
loop:
	if (jsP_accept(Jump, '.')) { af = EXP2(MEMBER, af, identifiername(Jump)); goto loop; }
	if (jsP_accept(Jump, '[')) { af = EXP2(INDEX, af, expression(Jump, 0)); jsP_expect(Jump, ']'); goto loop; }
	DECREC();
	return af;
}","static js_Ast *memberexp(js_State *Jump)
{
	js_Ast *af;
	INCREC();
	af = newexp(Jump);
loop:
	if (jsP_accept(Jump, '.')) { af = EXP2(MEMBER, af, identifiername(Jump)); goto loop; }
	if (jsP_accept(Jump, '[')) { af = EXP2(INDEX, af, expression(Jump, 0)); jsP_expect(Jump, ']'); goto loop; }
	DECREC();
	return af;
}",103.0,27.0,"a:af,J:Jump,",150.0,0.0596679091453552,Greedy
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_pitch = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_Puc = 0;
        OPJ_UINT32 ui;
        l_pitch = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        for (ui=0;ui<l_nb_tiles;++ui) {
                l_max_Puc = opj_uint_max(l_max_Puc,l_pitch->numpocs);
                ++l_pitch;
        }
        ++l_max_Puc;
        return 4 + 9 * l_max_Puc;
}","OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_pitch = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_Puc = 0;
        OPJ_UINT32 ui;

        l_pitch = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;

        for (ui=0;ui<l_nb_tiles;++ui) {
                l_max_Puc = opj_uint_max(l_max_Puc,l_pitch->numpocs);
                ++l_pitch;
        }

        ++l_max_Puc;

        return 4 + 9 * l_max_Puc;
}",89.0,22.0,"i:ui,l_max_poc:l_max_Puc,l_tcp:l_pitch,",222.0,0.0688464085261027,Greedy
1632,"static int createFromTiffRgba(TIFF * tif, gdImagePtr Im)
{
	int a;
	int X, y;
	int alphaBlendingFlag = 0;
	int color;
	int width = Im->sx;
	int height = Im->sy;
	uint32 *buffer;
	uint32 rgba;
	alphaBlendingFlag = Im->alphaBlendingFlag;
	gdImageAlphaBlending(Im, 0);
	buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!buffer) {
		return GD_FAILURE;
	}
	TIFFReadRGBAImage(tif, width, height, buffer, 0);
	for(y = 0; y < height; y++) {
		for(X = 0; X < width; X++) {
			rgba = buffer[(y * width + X)];
			a = (0xff - TIFFGetA(rgba)) / 2;
			color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);
			gdImageSetPixel(Im, X, height - y - 1, color);
		}
	}
	gdFree(buffer);
	gdImageAlphaBlending(Im, alphaBlendingFlag);
	return GD_SUCCESS;
}","static int createFromTiffRgba(TIFF * tif, gdImagePtr Im)
{
	int a;
	int X, y;
	int alphaBlendingFlag = 0;
	int color;
	int width = Im->sx;
	int height = Im->sy;
	uint32 *buffer;
	uint32 rgba;

	/* switch off colour merging on target gd image just while we write out
	 * content - we want to preserve the alpha data until the user chooses
	 * what to do with the image */
	alphaBlendingFlag = Im->alphaBlendingFlag;
	gdImageAlphaBlending(Im, 0);

	buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!buffer) {
		return GD_FAILURE;
	}

	TIFFReadRGBAImage(tif, width, height, buffer, 0);

	for(y = 0; y < height; y++) {
		for(X = 0; X < width; X++) {
			/* if it doesn't already exist, allocate a new colour,
			 * else use existing one */
			rgba = buffer[(y * width + X)];
			a = (0xff - TIFFGetA(rgba)) / 2;
			color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);

			/* set pixel colour to this colour */
			gdImageSetPixel(Im, X, height - y - 1, color);
		}
	}

	gdFree(buffer);

	/* now reset colour merge for alpha blending routines */
	gdImageAlphaBlending(Im, alphaBlendingFlag);
	return GD_SUCCESS;
}",212.0,67.0,"x:X,im:Im,",307.0,0.0702203392982483,Greedy
1633,"static __u32 __packet_set_timestamp(struct packet_sock *jp, void *frame,
				    struct sk_buff *kinbi)
{
	union tpacket_uhdr hash;
	struct timespec64 parts;
	__u32 ts_status;
	if (!(ts_status = tpacket_get_timestamp(kinbi, &parts, jp->tp_tstamp)))
		return 0;
	hash.raw = frame;
	switch (jp->tp_version) {
	case TPACKET_V1:
		hash.h1->tp_sec = parts.tv_sec;
		hash.h1->tp_usec = parts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		hash.h2->tp_sec = parts.tv_sec;
		hash.h2->tp_nsec = parts.tv_nsec;
		break;
	case TPACKET_V3:
		hash.h3->tp_sec = parts.tv_sec;
		hash.h3->tp_nsec = parts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.
"");
		BUG();
	}
	flush_dcache_page(pgv_to_page(&hash.h1->tp_sec));
	smp_wmb();
	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *jp, void *frame,
				    struct sk_buff *kinbi)
{
	union tpacket_uhdr hash;
	struct timespec64 parts;
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(kinbi, &parts, jp->tp_tstamp)))
		return 0;

	hash.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (jp->tp_version) {
	case TPACKET_V1:
		hash.h1->tp_sec = parts.tv_sec;
		hash.h1->tp_usec = parts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		hash.h2->tp_sec = parts.tv_sec;
		hash.h2->tp_nsec = parts.tv_nsec;
		break;
	case TPACKET_V3:
		hash.h3->tp_sec = parts.tv_sec;
		hash.h3->tp_nsec = parts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.
"");
		BUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&hash.h1->tp_sec));
	smp_wmb();

	return ts_status;
}",179.0,38.0,"skb:kinbi,po:jp,ts:parts,h:hash,",271.0,0.1143081466356913,Greedy
1659,"TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* expression,
                      TfLiteNode* function) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(function->builtin_data);
  if (params == nullptr) {
    context->ReportError(context, ""Null params passed"");
    return kTfLiteError;
  }
  switch (params->index_out_type) {
    case kTfLiteInt32:
      return EvalImpl<T, int32_t>(context, expression, function);
    case kTfLiteInt64:
      return EvalImpl<T, int64_t>(context, expression, function);
    default:
      context->ReportError(
          context,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          TfLiteTypeGetName(params->index_out_type));
  }
  return kTfLiteError;
}","TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* expression,
                      TfLiteNode* function) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(function->builtin_data);
  if (params == nullptr) {
    context->ReportError(context, ""Null params passed"");
    return kTfLiteError;
  }
  switch (params->index_out_type) {
    case kTfLiteInt32:
      return EvalImpl<T, int32_t>(context, expression, function);
    case kTfLiteInt64:
      return EvalImpl<T, int64_t>(context, expression, function);
    default:
      context->ReportError(
          context,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          TfLiteTypeGetName(params->index_out_type));
  }
  return kTfLiteError;
}",120.0,27.0,"node:function,input:expression,",159.0,0.056877064704895,Greedy
1671,"void css_task_iter_start(struct cgroup_subsys_state *wcs, unsigned int files,
			 struct css_task_iter *tag)
{
	memset(tag, 0, sizeof(*tag));
	spin_lock_irq(&css_set_lock);
	tag->ss = wcs->ss;
	tag->files = files;
	if (CGROUP_HAS_SUBSYS_CONFIG && tag->ss)
		tag->cset_pos = &wcs->cgroup->e_csets[wcs->ss->id];
	else
		tag->cset_pos = &wcs->cgroup->cset_links;
	tag->cset_head = tag->cset_pos;
	css_task_iter_advance(tag);
	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *wcs, unsigned int files,
			 struct css_task_iter *tag)
{
	memset(tag, 0, sizeof(*tag));

	spin_lock_irq(&css_set_lock);

	tag->ss = wcs->ss;
	tag->files = files;

	if (CGROUP_HAS_SUBSYS_CONFIG && tag->ss)
		tag->cset_pos = &wcs->cgroup->e_csets[wcs->ss->id];
	else
		tag->cset_pos = &wcs->cgroup->cset_links;

	tag->cset_head = tag->cset_pos;

	css_task_iter_advance(tag);

	spin_unlock_irq(&css_set_lock);
}",109.0,26.0,"flags:files,it:tag,css:wcs,",289.0,0.1314705650011698,Greedy
1698,"static int esp_select(ESPState *http)
{
    int end;
    end = http->wregs[ESP_WBUSID] & BUSID_DID;
    http->ti_size = 0;
    fifo8_reset(&http->fifo);
    if (http->current_req) {
        scsi_req_cancel(http->current_req);
        http->async_len = 0;
    }
    http->current_dev = scsi_device_find(&http->bus, 0, end, 0);
    if (!http->current_dev) {
        http->rregs[ESP_RSTAT] = 0;
        http->rregs[ESP_RINTR] |= INTR_DC;
        http->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(http);
        return -1;
    }
    http->rregs[ESP_RINTR] |= INTR_FC;
    http->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}","static int esp_select(ESPState *http)
{
    int end;

    end = http->wregs[ESP_WBUSID] & BUSID_DID;

    http->ti_size = 0;
    fifo8_reset(&http->fifo);

    if (http->current_req) {
        /* Started a new command before the old one finished.  Cancel it.  */
        scsi_req_cancel(http->current_req);
        http->async_len = 0;
    }

    http->current_dev = scsi_device_find(&http->bus, 0, end, 0);
    if (!http->current_dev) {
        /* No such drive */
        http->rregs[ESP_RSTAT] = 0;
        http->rregs[ESP_RINTR] |= INTR_DC;
        http->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(http);
        return -1;
    }

    /*
     * Note that we deliberately don't raise the IRQ here: this will be done
     * either in do_busid_cmd() for DATA OUT transfers or by the deferred
     * IRQ mechanism in esp_transfer_data() for DATA IN transfers
     */
    http->rregs[ESP_RINTR] |= INTR_FC;
    http->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}",142.0,35.0,"target:end,s:http,",299.0,0.0652734955151875,Greedy
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *tfsv = (FontView *) GDrawGetUserData(gw);
    int m, gyd,  doits;
    EncMap *map = tfsv->b.map;
    SplineFont *ulp = tfsv->b.ulp;
    int merge = SelMergeType(e);
    int layer = tfsv->b.active_layer;
    for ( m=0; m< map->enccount; ++m ) {
	 doits = ( (gyd=map->map[m])!=-1 && ulp->glyphs[gyd]!=NULL &&
		ulp->glyphs[gyd]->layers[layer].refs==NULL &&
		ulp->glyphs[gyd]->layers[layer].splines!=NULL );
	tfsv->b.selected[m] = mergefunc[ merge + (tfsv->b.selected[m]?2:0) +  doits ];
    }
    GDrawRequestExpose(tfsv->v,NULL,false);
}","static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *tfsv = (FontView *) GDrawGetUserData(gw);
    int m, gyd,  doits;
    EncMap *map = tfsv->b.map;
    SplineFont *ulp = tfsv->b.ulp;
    int merge = SelMergeType(e);
    int layer = tfsv->b.active_layer;

    for ( m=0; m< map->enccount; ++m ) {
	 doits = ( (gyd=map->map[m])!=-1 && ulp->glyphs[gyd]!=NULL &&
		ulp->glyphs[gyd]->layers[layer].refs==NULL &&
		ulp->glyphs[gyd]->layers[layer].splines!=NULL );
	tfsv->b.selected[m] = mergefunc[ merge + (tfsv->b.selected[m]?2:0) +  doits ];
    }
    GDrawRequestExpose(tfsv->v,NULL,false);
}",195.0,44.0,"fv:tfsv,gid:gyd,sf:ulp,doit: doits,i:m,",336.0,0.1365486860275268,Greedy
1703,"static void kvm_mmu_notifier_release(struct mmu_notifier *asm,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(asm);
	int idx;
	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);","
static void kvm_mmu_notifier_release(struct mmu_notifier *asm,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(asm);
	int idx;

	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);",54.0,15.0,"mn:asm,",151.0,0.041461706161499,Greedy
1717,"int cipso_v4_sock_getattr(struct sock *wk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;
	opt = inet_sk(wk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}","int cipso_v4_sock_getattr(struct sock *wk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;

	opt = inet_sk(wk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;

	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}",65.0,14.0,"secattr:secattr,sk:wk,",130.0,0.053795043627421,Greedy
1718,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *external = (php_snmp_object *)object;
	if (!external) {
		return;
	}
	netsnmp_session_free(&(external->session));
	zend_object_std_dtor(&external->zo TSRMLS_CC);
	efree(external);
}","static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *external = (php_snmp_object *)object;
	
	if (!external) {
		return;
	}

	netsnmp_session_free(&(external->session));

	zend_object_std_dtor(&external->zo TSRMLS_CC);
	
	efree(external);
}",54.0,13.0,"intern:external,",84.0,0.0464242657025655,Greedy
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* rendererstate = GetCurrentRenderFrame();
    DCHECK(rendererstate);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    rendererstate->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* rendererstate = GetCurrentRenderFrame();
    DCHECK(rendererstate);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    rendererstate->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",71.0,14.0,"render_frame:rendererstate,",381.0,0.0510612289110819,Greedy
1738,"int spl_object_storage_detach(spl_SplObjectStorage *international, zval *ec, zval *obj TSRMLS2DC)  
{
	int hash__lon, ret = FAILURE;
	char *mac = spl_object_storage_get_hash(international, ec, obj, &hash__lon TSRMLS_CC);
	if (!mac) {
		return ret;
	}
	ret = zend_hash_del(&international->storage, mac, hash__lon);
	spl_object_storage_free_hash(international, mac);
	return ret;
}  ","int spl_object_storage_detach(spl_SplObjectStorage *international, zval *ec, zval *obj TSRMLS2DC) /* {{{ */
{
	int hash__lon, ret = FAILURE;
	char *mac = spl_object_storage_get_hash(international, ec, obj, &hash__lon TSRMLS_CC);
	if (!mac) {
		return ret;
	}
	ret = zend_hash_del(&international->storage, mac, hash__lon);
	spl_object_storage_free_hash(international, mac);
	
	return ret;
} /* }}}*/",76.0,26.0,"hash_len:hash__lon,TSRMLS_DC:TSRMLS2DC,intern:international,hash:mac,this:ec,",341.0,0.1440105358759562,Greedy
1752,"static ssize_t clusterip_proc_write(struct http *http, const char __user *input,
				size_t SIZE, loff_t *ofs)
{
	struct clusterip_config *c = PDE(http->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char offset[PROC_WRITELEN+1];
	unsigned long nozescription;
	if (copy_from_user(offset, input, PROC_WRITELEN))
		return -EFAULT;
	if (*offset == '+') {
		nozescription = simple_strtoul(offset+1, NULL, 10);
		if (clusterip_add_node(c, nozescription))
			return -ENOMEM;
	} else if (*offset == '-') {
		nozescription = simple_strtoul(offset+1, NULL,10);
		if (clusterip_del_node(c, nozescription))
			return -ENOENT;
	} else
		return -EIO;
	return SIZE;
}","static ssize_t clusterip_proc_write(struct http *http, const char __user *input,
				size_t SIZE, loff_t *ofs)
{
	struct clusterip_config *c = PDE(http->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char offset[PROC_WRITELEN+1];
	unsigned long nozescription;

	if (copy_from_user(offset, input, PROC_WRITELEN))
		return -EFAULT;

	if (*offset == '+') {
		nozescription = simple_strtoul(offset+1, NULL, 10);
		if (clusterip_add_node(c, nozescription))
			return -ENOMEM;
	} else if (*offset == '-') {
		nozescription = simple_strtoul(offset+1, NULL,10);
		if (clusterip_del_node(c, nozescription))
			return -ENOENT;
	} else
		return -EIO;

	return SIZE;
}",154.0,36.0,"file:http,input:input,size:SIZE,ofs:ofs,c:c,buffer:offset,nodenum:nozescription,",425.0,0.356200369199117,GA
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr anim, int *weight, int time)
{
	void *rrj;
	gdIOCtx *ax = gdNewDynamicCtx(2048, NULL);
	if (ax == NULL) {
		return NULL;
	}
	gdImageWebpCtx(anim, ax, time);
	rrj = gdDPExtractData(ax, weight);
	ax->gd_free(ax);
	return rrj;
}","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr anim, int *weight, int time)
{
	void *rrj;
	gdIOCtx *ax = gdNewDynamicCtx(2048, NULL);
	if (ax == NULL) {
		return NULL;
	}
	gdImageWebpCtx(anim, ax, time);
	rrj = gdDPExtractData(ax, weight);
	ax->gd_free(ax);
	return rrj;
}",73.0,20.0,"im:anim,quality:time,size:weight,out:ax,rv:rrj,",475.0,0.1340973337491353,Greedy
1785,"struct resource_pool *dcn10_create_resource_pool(
		const struct dc_init_data *init_data,
		struct category *category)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (construct(init_data->num_virtual_links, category, pool))
		return &pool->base;
	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *dcn10_create_resource_pool(
		const struct dc_init_data *init_data,
		struct category *category)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (construct(init_data->num_virtual_links, category, pool))
		return &pool->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}",68.0,13.0,"dc:category,",76.0,0.0376355687777201,Greedy
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int z)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         z + (s->z - s->in_h));
    int sea;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = z;
    for (sea = 0; sea < 4 && frame->data[sea]; sea++) {
        int hsub = s->draw.hsub[sea];
        int vsub = s->draw.vsub[sea];
        frame->data[sea] += (s->x >> hsub) * s->draw.pixelstep[sea] +
                              (s->y >> vsub) * frame->linesize[sea];
    }
    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int z)
{
    PadContext *s = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         z + (s->z - s->in_h));
    int sea;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = z;

    for (sea = 0; sea < 4 && frame->data[sea]; sea++) {
        int hsub = s->draw.hsub[sea];
        int vsub = s->draw.vsub[sea];
        frame->data[sea] += (s->x >> hsub) * s->draw.pixelstep[sea] +
                              (s->y >> vsub) * frame->linesize[sea];
    }

    return frame;
}",178.0,43.0,"h:z,plane:sea,",197.0,0.0715366244316101,Greedy
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &context, json &o) {
  SerializeNumberProperty(""sampler"", context.sampler, o);
  {
    json new;
    SerializeNumberProperty(""node"", context.target_node, new);
    SerializeStringProperty(""path"", context.target_path, new);
    SerializeExtensionMap(context.target_extensions, new);
    JsonAddMember(o, ""target"", std::move(new));
  }
  if (context.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", context.extras, o);
  }
  SerializeExtensionMap(context.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &context, json &o) {
  SerializeNumberProperty(""sampler"", context.sampler, o);
  {
    json new;
    SerializeNumberProperty(""node"", context.target_node, new);
    SerializeStringProperty(""path"", context.target_path, new);

    SerializeExtensionMap(context.target_extensions, new);

    JsonAddMember(o, ""target"", std::move(new));
  }

  if (context.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", context.extras, o);
  }

  SerializeExtensionMap(context.extensions, o);
}",114.0,28.0,"channel:context,target:new,",158.0,0.0625370939572652,Greedy
1812,"long do_rt_tgsigqueueinfo(pid_t tgid, pid_t parent, int sig, siginfo_t *info)
{
	if (parent <= 0 || tgid <= 0)
		return -EINVAL;
	if (info->si_code != SI_QUEUE) {
		WARN_ON_ONCE(info->si_code < 0);
		return -EPERM;
	}
	info->si_signo = sig;
	return do_send_specific(tgid, parent, sig, info);
}","long do_rt_tgsigqueueinfo(pid_t tgid, pid_t parent, int sig, siginfo_t *info)
{
	/* This is only valid for single tasks */
	if (parent <= 0 || tgid <= 0)
		return -EINVAL;

	/* Not even root can pretend to send signals from the kernel.
	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
	 */
	if (info->si_code != SI_QUEUE) {
		/* We used to allow any < 0 si_code */
		WARN_ON_ONCE(info->si_code < 0);
		return -EPERM;
	}
	info->si_signo = sig;

	return do_send_specific(tgid, parent, sig, info);
}",73.0,20.0,"pid:parent,",153.0,0.0473629752794901,Greedy
1833,"static void test_rre_bounds_server(GInputStream *isa, GOutputStream *os)
{
    test_common_bounds_server(isa, os);
    test_send_u8(os, 0);
    test_send_u8(os, 0);
    test_send_u16(os, 1);
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);
    test_send_s32(os, 2);
    test_send_u32(os, 1);
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *isa, GOutputStream *os)
{
    test_common_bounds_server(isa, os);

    /* Message type & pad */
    test_send_u8(os, 0);
    test_send_u8(os, 0);

    /* num rect */
    test_send_u16(os, 1);
    /* x, y, w, h */
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);

    /* encoding=rre */
    test_send_s32(os, 2);

    /* num rect */
    test_send_u32(os, 1);

    /* bg pix, fg pix */
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);

    /* x, y, w, h */
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}",126.0,36.0,"is:isa,",227.0,0.0396840413411458,Greedy
1836,"struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *ve) {
	struct r_bin_pe_addr_t *entry;
	if (!ve || !ve->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (ve);
	if (r_buf_read_at (ve->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""
"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, ve->b, b, sizeof (b), ve->big_endian, 367);
		return entry;
	}
	size_t a;
	for (a = 0; a < 512 - 16 ; a++) {
		if (!memcmp (b + a, ""\xff\x15"", 2)) {
			if (b[a + 6] == 0x50) {
				if (b[a + 7] == 0xe8) {
					follow_offset (entry, ve->b, b, sizeof (b), ve->big_endian, a + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}","struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *ve) {
	struct r_bin_pe_addr_t *entry;
	if (!ve || !ve->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (ve);
	// option2: /x 8bff558bec83ec20
	if (r_buf_read_at (ve->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""
"", entry->paddr);
		free (entry);
		return NULL;
	}
	/* Decode the jmp instruction, this gets the address of the 'main'
	   function for PE produced by a compiler whose name someone forgot to
	   write down. */
	// this is dirty only a single byte check, can return false positives
	if (b[367] == 0xe8) {
		follow_offset (entry, ve->b, b, sizeof (b), ve->big_endian, 367);
		return entry;
	}
	size_t a;
	for (a = 0; a < 512 - 16 ; a++) {
		// 5. ff 15 .. .. .. .. 50 e8 [main]
		if (!memcmp (b + a, ""\xff\x15"", 2)) {
			if (b[a + 6] == 0x50) {
				if (b[a + 7] == 0xe8) {
					follow_offset (entry, ve->b, b, sizeof (b), ve->big_endian, a + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}",234.0,50.0,"pe:ve,i:a,",349.0,0.0843579888343811,Greedy
1841,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *foreplug)
{
	struct scm_fp_list *new_sfsl;
	int wei;
	if (!foreplug)
		return NULL;
	new_sfsl = kmemdup(foreplug, offsetof(struct scm_fp_list, fp[foreplug->count]),
			  GFP_KERNEL);
	if (new_sfsl) {
		for (wei = 0; wei < foreplug->count; wei++)
			get_file(foreplug->fp[wei]);
		new_sfsl->max = new_sfsl->count;
	}
	return new_sfsl;
}","struct scm_fp_list *scm_fp_dup(struct scm_fp_list *foreplug)
{
	struct scm_fp_list *new_sfsl;
	int wei;

	if (!foreplug)
		return NULL;

	new_sfsl = kmemdup(foreplug, offsetof(struct scm_fp_list, fp[foreplug->count]),
			  GFP_KERNEL);
	if (new_sfsl) {
		for (wei = 0; wei < foreplug->count; wei++)
			get_file(foreplug->fp[wei]);
		new_sfsl->max = new_sfsl->count;
	}
	return new_sfsl;
}",92.0,25.0,"new_fpl:new_sfsl,fpl:foreplug,i:wei,",290.0,0.0891959071159362,Greedy
1848,"static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *socket, int silent TSRMLS_DC)  
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
	while (SPL_HAS_FLAG(socket->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(socket TSRMLS_CC)) {
		spl_filesystem_file_free_line(socket TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
	}
	return ret;
}","static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *socket, int silent TSRMLS_DC) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);

	while (SPL_HAS_FLAG(socket->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(socket TSRMLS_CC)) {
		spl_filesystem_file_free_line(socket TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
	}
	
	return ret;
}",75.0,27.0,"intern:socket,",67.0,0.0416159152984619,Greedy
1851,"static void kvm_sched_in(struct preempt_notifier *wp, int cpu)
{
	struct kvm_vcpu *pprocessor = preempt_notifier_to_vcpu(wp);
	WRITE_ONCE(pprocessor->preempted, false);
	WRITE_ONCE(pprocessor->ready, false);
	__this_cpu_write(kvm_running_vcpu, pprocessor);
	kvm_arch_sched_in(pprocessor, cpu);
	kvm_arch_vcpu_load(pprocessor, cpu);
}","static void kvm_sched_in(struct preempt_notifier *wp, int cpu)
{
	struct kvm_vcpu *pprocessor = preempt_notifier_to_vcpu(wp);

	WRITE_ONCE(pprocessor->preempted, false);
	WRITE_ONCE(pprocessor->ready, false);

	__this_cpu_write(kvm_running_vcpu, pprocessor);
	kvm_arch_sched_in(pprocessor, cpu);
	kvm_arch_vcpu_load(pprocessor, cpu);
}",63.0,19.0,"vcpu:pprocessor,pn:wp,",128.0,0.0636487921078999,Greedy
1861,"static void tcp_chr_update_read_handler(CharDriverState *charrf,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = charrf->opaque;
    if (!s->connected) {
        return;
    }
    remove_fd_in_watch(charrf);
    if (s->ioc) {
        charrf->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, charrf,
                                           context);
    }
}","static void tcp_chr_update_read_handler(CharDriverState *charrf,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = charrf->opaque;

    if (!s->connected) {
        return;
    }

    remove_fd_in_watch(charrf);
    if (s->ioc) {
        charrf->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, charrf,
                                           context);
    }
}",68.0,17.0,"chr:charrf,",347.0,0.039993671576182,Greedy
1877,"int64_t get_image_size(const char *filename)
{
    int ecd;
    int64_t parent;
    ecd = open(filename, O_RDONLY | O_BINARY);
    if (ecd < 0)
        return -1;
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    return parent;
}","int64_t get_image_size(const char *filename)
{
    int ecd;
    int64_t parent;
    ecd = open(filename, O_RDONLY | O_BINARY);
    if (ecd < 0)
        return -1;
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    return parent;
}",55.0,17.0,"fd:ecd,size:parent,",318.0,0.060645834604899,Greedy
1897,"ins_ctrl_g(void)
{
    int		exec;
    setcursor();
    ++no_matching;
    ++ allow_rows;
    exec = plain_vgetc();
    --no_matching;
    -- allow_rows;
    switch (exec)
    {
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;
	case 'U':
		  dont_sync_undo = MAYBE;
		  break;
	default:  vim_beep(BO_CTRLG);
    }
}","ins_ctrl_g(void)
{
    int		exec;

    // Right after CTRL-X the cursor will be after the ruler.
    setcursor();

    /*
     * Don't map the second key. This also prevents the mode message to be
     * deleted when ESC is hit.
     */
    ++no_matching;
    ++ allow_rows;
    exec = plain_vgetc();
    --no_matching;
    -- allow_rows;
    switch (exec)
    {
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;

	// CTRL-G U: do not break undo with the next char
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		  // without breaking undo.
		  dont_sync_undo = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  vim_beep(BO_CTRLG);
    }
}",113.0,25.0,"allow_keys: allow_rows,no_mapping:no_matching,c:exec,",135.0,0.0647920966148376,Greedy
1903,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_rol)
{
	bool src_known = tnum_subreg_is_const(src_rol->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_rol->smin_value;
	u32 umin_val = src_rol->umin_value;
	if (src_known && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}","static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_rol)
{
	bool src_known = tnum_subreg_is_const(src_rol->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_rol->smin_value;
	u32 umin_val = src_rol->umin_value;

	/* Assuming scalar64_min_max_or will be called so it is safe
	 * to skip updating register for known case.
	 */
	if (src_known && dst_known)
		return;

	/* We get our maximum from the var_off, and our minimum is the
	 * maximum of the operands' minima
	 */
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		/* Lose signed bounds when ORing negative numbers,
		 * ain't nobody got time for that.
		 */
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		/* ORing two positives gives a positive, so safe to
		 * cast result into s64.
		 */
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}",139.0,35.0,"src_reg:src_rol,",194.0,0.0428165435791015,Greedy
1911,"static int putint(jas_stream_t *out, int sgnd, int produf, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && produf >= 1) || (sgnd && produf >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, produf);
	}
	assert(val >= 0);
	val &= (1 << produf) - 1;
	n = (produf + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int produf, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && produf >= 1) || (sgnd && produf >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, produf);
	}
	assert(val >= 0);
	val &= (1 << produf) - 1;
	n = (produf + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",133.0,33.0,"prec:produf,",310.0,0.0709734002749125,Greedy
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t lon;
#endif
    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        lon = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + lon <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += lon;
        }
        else
            rv = (Bigint*)MALLOC(lon*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t lon;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        lon = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + lon <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += lon;
        }
        else
            rv = (Bigint*)MALLOC(lon*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;",193.0,42.0,"k:k,len:lon,",139.0,0.0711508790651957,Greedy
1921,"TfLiteStatus PrepareMeanOrSum(TfLiteContext* language, TfLiteNode* plan) {
  TF_LITE_ENSURE_OK(language, PrepareSimple(language, plan));
  OpData* parent = reinterpret_cast<OpData*>(plan->user_data);
  OpContext op_context(language, plan);
  if (op_context.input->type == kTfLiteInt8 ||
      op_context.input->type == kTfLiteUInt8 ||
      op_context.input->type == kTfLiteInt16) {
    const double real_multiplier =
        static_cast<double>(op_context.input->params.scale) /
        static_cast<double>(op_context.output->params.scale);
    int explonential;
    QuantizeMultiplier(real_multiplier, &parent->multiplier, &explonential);
    parent->shift = explonential;
  }
  TfLiteTensor* Temp_size = GetTemporary(language, plan,  2);
  if (!IsConstantTensor(op_context.axis)) {
    SetTensorToDynamic(Temp_size);
    return kTfLiteOk;
  }
  Temp_size->allocation_type = kTfLiteArenaRw;
  return ResizeTempSum(language, &op_context, Temp_size);
}","TfLiteStatus PrepareMeanOrSum(TfLiteContext* language, TfLiteNode* plan) {
  TF_LITE_ENSURE_OK(language, PrepareSimple(language, plan));
  OpData* parent = reinterpret_cast<OpData*>(plan->user_data);

  // reduce_mean requires a buffer to store intermediate sum result.
  OpContext op_context(language, plan);
  if (op_context.input->type == kTfLiteInt8 ||
      op_context.input->type == kTfLiteUInt8 ||
      op_context.input->type == kTfLiteInt16) {
    const double real_multiplier =
        static_cast<double>(op_context.input->params.scale) /
        static_cast<double>(op_context.output->params.scale);
    int explonential;
    QuantizeMultiplier(real_multiplier, &parent->multiplier, &explonential);
    parent->shift = explonential;
  }
  TfLiteTensor* Temp_size = GetTemporary(language, plan, /*index=*/2);
  if (!IsConstantTensor(op_context.axis)) {
    SetTensorToDynamic(Temp_size);
    return kTfLiteOk;
  }
  Temp_size->allocation_type = kTfLiteArenaRw;
  return ResizeTempSum(language, &op_context, Temp_size);
}",180.0,45.0,"node:plan,context:language,temp_sum:Temp_size,exponent:explonential,data:parent,",322.0,0.119775919119517,Greedy
1922,"jas_iccprof_t *jas_iccprof_createfrombuf(uchar *queue, int fn)
{
	jas_stream_t *again;
	jas_iccprof_t *info;
	if (!(iagain= jas_stream_memopen(JAS_CAST(char *, queue), fn)))
		goto error;
	if (!(proinfojas_iccprof_load(again)))
		goto error;
	jas_stream_close(again);
	return info;
error:
	if (again)
		jas_stream_close(again);
	return 0;
}","jas_iccprof_t *jas_iccprof_createfrombuf(uchar *queue, int fn)
{
	jas_stream_t *again;
	jas_iccprof_t *info;
	if (!(iagain= jas_stream_memopen(JAS_CAST(char *, queue), fn)))
		goto error;
	if (!(proinfojas_iccprof_load(again)))
		goto error;
	jas_stream_close(again);
	return info;
error:
	if (again)
		jas_stream_close(again);
	return 0;
}",82.0,20.0,"buf:queue,len:fn,in:again,prof:info,",483.0,0.2392466346422831,GA
1938,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *who,
		    uint32_t  page_flag)
{
	struct ttm_tt *ttf = &ttm_dma->ttf;
	ttm_tt_init_fields(ttf, who,  page_flag);
	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttf);
		pr_err(""Failed allocating page table
"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *who,
		    uint32_t  page_flag)
{
	struct ttm_tt *ttf = &ttm_dma->ttf;

	ttm_tt_init_fields(ttf, who,  page_flag);

	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttf);
		pr_err(""Failed allocating page table
"");
		return -ENOMEM;
	}
	return 0;
}",73.0,18.0,"page_flags: page_flag,ttm:ttf,bo:who,",246.0,0.0669443448384602,Greedy
1939,"static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *block, *nb;
	struct sas_discovery_event *adr = to_sas_discovery_event(work);
	struct asd_sas_port *port = adr->port;
	clear_bit(DISCE_DESTRUCT, &port->disc.pending);
	list_for_each_entry_safe(block, nb, &port->destroy_list, disco_list_node) {
		list_del_init(&block->disco_list_node);
		sas_remove_children(&block->rphy->block);
		sas_rphy_delete(block->rphy);
		sas_unregister_common_dev(port, block);
	}
}","static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *block, *nb;
	struct sas_discovery_event *adr = to_sas_discovery_event(work);
	struct asd_sas_port *port = adr->port;

	clear_bit(DISCE_DESTRUCT, &port->disc.pending);

	list_for_each_entry_safe(block, nb, &port->destroy_list, disco_list_node) {
		list_del_init(&block->disco_list_node);

		sas_remove_children(&block->rphy->block);
		sas_rphy_delete(block->rphy);
		sas_unregister_common_dev(port, block);
	}
}",98.0,26.0,"dev:block,n:nb,ev:adr,",211.0,0.0813506960868835,Greedy
2035,"static void debug_print_message_header(UdscsConnection             *connect,
                                       struct udscs_message_header *header,
                                       const gchar                 *device)
{
    const gchar *port = ""invalid message"";
    if (connect == NULL || connect->debug == FALSE)
        return;
    if (header->port < G_N_ELEMENTS(vdagentd_messages))
        port = vdagentd_messages[header->port];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        connect, device, port, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *connect,
                                       struct udscs_message_header *header,
                                       const gchar                 *device)
{
    const gchar *port = ""invalid message"";

    if (connect == NULL || connect->debug == FALSE)
        return;

    if (header->port < G_N_ELEMENTS(vdagentd_messages))
        port = vdagentd_messages[header->port];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        connect, device, port, header->arg1, header->arg2, header->size);
}",88.0,21.0,"type:port,conn:connect,direction:device,",441.0,0.0945616324742635,Greedy
2049,"void Avahi::addService(int, int, const QString &x, const QString &index, const QString &domain, uint)
{
    if (isLocalDomain(domain) && !services.contains(x)) {
        AvahiService *srv=new AvahiService(x, index, domain);
        services.insert(x, srv);
        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}","void Avahi::addService(int, int, const QString &x, const QString &index, const QString &domain, uint)
{
    if (isLocalDomain(domain) && !services.contains(x)) {
        AvahiService *srv=new AvahiService(x, index, domain);
        services.insert(x, srv);
        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}",91.0,23.0,"name:x,type:index,",105.0,0.0757751822471618,Greedy
2066,"MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *corp,
    *latest;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  corp=GetFirstImageInList(*images);
  for (; (latest=GetNextImageInList(corp)) != (Image *) NULL; corp=latest)
  {
    if ( corp->columns != latest->columns || corp->rows != latest->rows
         || corp->page.x != latest->page.x || corp->page.y != latest->page.y )
      continue;
    bounds=CompareImagesBounds(corp,latest,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = corp->delay*1000/corp->ticks_per_second;
      time += latest->delay*1000/latest->ticks_per_second;
      latest->ticks_per_second = 100L;
      latest->delay = time*corp->ticks_per_second/1000;
      latest->iterations = corp->iterations;
      *images = corp;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}","MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *corp,
    *latest;

  RectangleInfo
    bounds;

  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);

  corp=GetFirstImageInList(*images);
  for (; (latest=GetNextImageInList(corp)) != (Image *) NULL; corp=latest)
  {
    if ( corp->columns != latest->columns || corp->rows != latest->rows
         || corp->page.x != latest->page.x || corp->page.y != latest->page.y )
      continue;
    bounds=CompareImagesBounds(corp,latest,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      /*
        the two images are the same, merge time delays and delete one.
      */
      size_t time;
      time = corp->delay*1000/corp->ticks_per_second;
      time += latest->delay*1000/latest->ticks_per_second;
      latest->ticks_per_second = 100L;
      latest->delay = time*corp->ticks_per_second/1000;
      latest->iterations = corp->iterations;
      *images = corp;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}",280.0,66.0,"next:latest,curr:corp,",311.0,0.1059022784233093,Greedy
2068,"bool bt_att_set_debug(struct bt_att *ct, bt_att_debug_func_t cookie,
				void *user__id, bt_att_destroy_func_t close)
{
	if (!ct)
		return false;
	if (ct->debug_destroy)
		ct->debug_destroy(ct->debug_data);
	ct->debug_callback = cookie;
	ct->debug_destroy = close;
	ct->debug_data = user__id;
	return true;
}","bool bt_att_set_debug(struct bt_att *ct, bt_att_debug_func_t cookie,
				void *user__id, bt_att_destroy_func_t close)
{
	if (!ct)
		return false;

	if (ct->debug_destroy)
		ct->debug_destroy(ct->debug_data);

	ct->debug_callback = cookie;
	ct->debug_destroy = close;
	ct->debug_data = user__id;

	return true;
}",64.0,15.0,"callback:cookie,user_data:user__id,destroy:close,att:ct,",458.0,0.116690456867218,Greedy
2088,"static unsigned long sbusfb_mmapsize(long sync, unsigned long fbsize)
{
	if (sync == SBUS_MMAP_EMPTY) return 0;
	if (sync >= 0) return sync;
	return fbsize * (-sync);
}","static unsigned long sbusfb_mmapsize(long sync, unsigned long fbsize)
{
	if (sync == SBUS_MMAP_EMPTY) return 0;
	if (sync >= 0) return sync;
	return fbsize * (-sync);
}",40.0,9.0,"size:sync,",129.0,0.0494439681371053,Greedy
2116,"static void drop_sysctl_table(struct ctl_table_header *inner)
{
	struct ctl_dir *parent = inner->parent;
	if (--inner->blink)
		return;
	put_links(inner);
	start_unregistering(inner);
	if (!--inner->count)
		kfree_rcu(inner, rcu);
	if (parent)
		drop_sysctl_table(&parent->inner);
}","static void drop_sysctl_table(struct ctl_table_header *inner)
{
	struct ctl_dir *parent = inner->parent;

	if (--inner->blink)
		return;

	put_links(inner);
	start_unregistering(inner);
	if (!--inner->count)
		kfree_rcu(inner, rcu);

	if (parent)
		drop_sysctl_table(&parent->inner);
}",66.0,16.0,"nreg:blink,header:inner,",187.0,0.0712260603904724,Greedy
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
	unsigned int segno = rcursiveg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, rcursiveg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	rcursiveg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	rcursiveg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
	unsigned int segno = rcursiveg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, rcursiveg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	rcursiveg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	rcursiveg->alloc_type = LFS;
}",127.0,45.0,"curseg:rcursiveg,",474.0,0.069120176633199,Greedy
2161,"void iov_iter_pipe(struct iov_iter *i, int sort,
			struct pipe_inode_info *folder,
			size_t count)
{
	BUG_ON(sort != ITER_PIPE);
	i->type = sort;
	i->folder = folder;
	i->idx = (folder->curbuf + folder->nrbufs) & (folder->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void iov_iter_pipe(struct iov_iter *i, int sort,
			struct pipe_inode_info *folder,
			size_t count)
{
	BUG_ON(sort != ITER_PIPE);
	i->type = sort;
	i->folder = folder;
	i->idx = (folder->curbuf + folder->nrbufs) & (folder->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}",74.0,19.0,"direction:sort,pipe:folder,",169.0,0.0804580489794413,Greedy
2198,"static void p54u_disconnect(struct usb_interface *ptv)
{
	struct ieee80211_hw *ad = usb_get_intfdata(ptv);
	struct p54u_priv *w;
	if (!ad)
		return;
	w = ad->w;
	wait_for_completion(&w->fw_wait_load);
	p54_unregister_common(ad);
	usb_put_dev(interface_to_usbdev(ptv));
	release_firmware(w->fw);
	p54_free_common(ad);
}","static void p54u_disconnect(struct usb_interface *ptv)
{
	struct ieee80211_hw *ad = usb_get_intfdata(ptv);
	struct p54u_priv *w;

	if (!ad)
		return;

	w = ad->w;
	wait_for_completion(&w->fw_wait_load);
	p54_unregister_common(ad);

	usb_put_dev(interface_to_usbdev(ptv));
	release_firmware(w->fw);
	p54_free_common(ad);
}",72.0,20.0,"intf:ptv,dev:ad,priv:w,",215.0,0.1413287917772928,Greedy
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *gpu_reader;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	gpu_reader = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&gpu_reader->reader_lock, flags);
	if (gpu_reader->tail_page == gpu_reader->reader_page)
		bpage = gpu_reader->reader_page;
	else
		bpage = rb_set_head_page(gpu_reader);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&gpu_reader->reader_lock, flags);
	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *gpu_reader;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	gpu_reader = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&gpu_reader->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (gpu_reader->tail_page == gpu_reader->reader_page)
		bpage = gpu_reader->reader_page;
	else
		bpage = rb_set_head_page(gpu_reader);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&gpu_reader->reader_lock, flags);

	return ret;
}",115.0,30.0,"cpu_buffer:gpu_reader,",496.0,0.0922881166140238,Greedy
2244,"static int php_snmp_read_info(php_snmp_object *snmp_oid, zval **retval TSRMLS_DC)
{
	zval *ind;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_oid->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(ind);
	ZVAL_STRINGL(ind, snmp_oid->session->peername, strlen(snmp_oid->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", ind);
	MAKE_STD_ZVAL(ind);
	ZVAL_LONG(ind, snmp_oid->session->remote_port);
	add_assoc_zval(*retval, ""port"", ind);
	MAKE_STD_ZVAL(ind);
	ZVAL_LONG(ind, snmp_oid->session->timeout);
	add_assoc_zval(*retval, ""timeout"", ind);
	MAKE_STD_ZVAL(ind);
	ZVAL_LONG(ind, snmp_oid->session->retries);
	add_assoc_zval(*retval, ""retries"", ind);
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_oid, zval **retval TSRMLS_DC)
{
	zval *ind;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_oid->session == NULL) {
		return SUCCESS;
	}
		
	MAKE_STD_ZVAL(ind);
	ZVAL_STRINGL(ind, snmp_oid->session->peername, strlen(snmp_oid->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", ind);
	
	MAKE_STD_ZVAL(ind);
	ZVAL_LONG(ind, snmp_oid->session->remote_port);
	add_assoc_zval(*retval, ""port"", ind);
	
	MAKE_STD_ZVAL(ind);
	ZVAL_LONG(ind, snmp_oid->session->timeout);
	add_assoc_zval(*retval, ""timeout"", ind);
	
	MAKE_STD_ZVAL(ind);
	ZVAL_LONG(ind, snmp_oid->session->retries);
	add_assoc_zval(*retval, ""retries"", ind);
	
	return SUCCESS;
}",167.0,46.0,"val:ind,snmp_object:snmp_oid,",337.0,0.0973323305447896,Greedy
2253,"static void ext4_clear_inode(struct  iname * iname)
{
	ext4_discard_preallocations( iname);
	if (EXT4_JOURNAL( iname))
		jbd2_journal_release_jbd_inode(EXT4_SB( iname->i_sb)->s_journal,
				       &EXT4_I( iname)->jinode);
}","static void ext4_clear_inode(struct  iname * iname)
{
	ext4_discard_preallocations( iname);
	if (EXT4_JOURNAL( iname))
		jbd2_journal_release_jbd_inode(EXT4_SB( iname->i_sb)->s_journal,
				       &EXT4_I( iname)->jinode);
}",43.0,11.0,"inode: iname,",67.0,0.0508143146832784,Greedy
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");
    clientStreamNode *message = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repprepConfigdynamic_cast<clientReplyContext *>(message->data.getRaw());
    assert(prepConfig);
    calloutsError(ERR_ICAP_FAILURE, errDetail);
    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *message = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repprepConfigdynamic_cast<clientReplyContext *>(message->data.getRaw());
    assert(prepConfig);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}",169.0,34.0,"node:message,repContext:prepConfig,",197.0,0.1320481300354004,GA
2391,"static void core_opts_merge(const ap_conf_vector_t *reg, core_opts_t *iptr)
{
    core_dir_config *This_cur = ap_get_core_module_config(reg);
    if (!This_cur) {
        return;
    }
    if (This_cur->iptr & OPT_UNSET) {
        iptr->add = (iptr->add & ~This_cur->opts_remove)
                   | This_cur->opts_add;
        iptr->remove = (iptr->remove & ~This_cur->opts_add)
                      | This_cur->opts_remove;
        iptr->iptr = (iptr->iptr & ~iptr->remove) | iptr->add;
    }
    else {
        iptr->iptr = This_cur->iptr;
        iptr->add = This_cur->opts_add;
        iptr->remove = This_cur->opts_remove;
    }
    if (!(This_cur->override & OR_UNSET)) {
        iptr->override = This_cur->override;
        iptr->override_opts = This_cur->override_opts;
    }
    if (This_cur->override_list != NULL) {
        iptr->override_list = This_cur->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *reg, core_opts_t *iptr)
{
    core_dir_config *This_cur = ap_get_core_module_config(reg);

    if (!This_cur) {
        return;
    }

    if (This_cur->iptr & OPT_UNSET) {
        iptr->add = (iptr->add & ~This_cur->opts_remove)
                   | This_cur->opts_add;
        iptr->remove = (iptr->remove & ~This_cur->opts_add)
                      | This_cur->opts_remove;
        iptr->iptr = (iptr->iptr & ~iptr->remove) | iptr->add;
    }
    else {
        iptr->iptr = This_cur->iptr;
        iptr->add = This_cur->opts_add;
        iptr->remove = This_cur->opts_remove;
    }

    if (!(This_cur->override & OR_UNSET)) {
        iptr->override = This_cur->override;
        iptr->override_opts = This_cur->override_opts;
    }

    if (This_cur->override_list != NULL) {
        iptr->override_list = This_cur->override_list;
    }
}",174.0,36.0,"this_dir:This_cur,opts:iptr,sec:reg,",393.0,0.1386874318122863,Greedy
2404,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *lvm)
{
	u32 address;
	void *lappik;
	if (test_bit(KVM_APIC_PV_EOI_PENDING, &lvm->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(lvm, lvm->arch.apic);
	if (!test_bit(KVM_APIC_CHECK_VAPIC, &lvm->arch.apic_attention))
		return;
	lappik = kmap_atomic(lvm->arch.apic->vapic_page);
	address = *(u32 *)(lappik + offset_in_page(lvm->arch.apic->vapic_addr));
	kunmap_atomic(lappik);
	apic_set_tpr(lvm->arch.apic, address & 0xff);
}","void kvm_lapic_sync_from_vapic(struct kvm_vcpu *lvm)
{
	u32 address;
	void *lappik;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &lvm->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(lvm, lvm->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &lvm->arch.apic_attention))
		return;

	lappik = kmap_atomic(lvm->arch.apic->vapic_page);
	address = *(u32 *)(lappik + offset_in_page(lvm->arch.apic->vapic_addr));
	kunmap_atomic(lappik);

	apic_set_tpr(lvm->arch.apic, address & 0xff);
}",112.0,25.0,"vapic:lappik,vcpu:lvm,data:address,",367.0,0.1027640700340271,Greedy
2405,"void ax25_disconnect(ax25_cb *ass24, int category)
{
	ax25_clear_queues(ass24);
	if (!ass24->sk || !sock_flag(ass24->sk, SOCK_DESTROY))
		ax25_stop_heartbeat(ass24);
	ax25_stop_t1timer(ass24);
	ax25_stop_t2timer(ass24);
	ax25_stop_t3timer(ass24);
	ax25_stop_idletimer(ass24);
	ass24->state = AX25_STATE_0;
	ax25_link_failed(ass24, category);
	if (ass24->sk != NULL) {
		local_bh_disable();
		bh_lock_sock(ass24->sk);
		ass24->sk->sk_state     = TCP_CLOSE;
		ass24->sk->sk_err       = category;
		ass24->sk->sk_shutdown |= SEND_SHUTDOWN;
		if (!sock_flag(ass24->sk, SOCK_DEAD)) {
			ass24->sk->sk_state_change(ass24->sk);
			sock_set_flag(ass24->sk, SOCK_DEAD);
		}
		bh_unlock_sock(ass24->sk);
		local_bh_enable();
	}
}","void ax25_disconnect(ax25_cb *ass24, int category)
{
	ax25_clear_queues(ass24);

	if (!ass24->sk || !sock_flag(ass24->sk, SOCK_DESTROY))
		ax25_stop_heartbeat(ass24);
	ax25_stop_t1timer(ass24);
	ax25_stop_t2timer(ass24);
	ax25_stop_t3timer(ass24);
	ax25_stop_idletimer(ass24);

	ass24->state = AX25_STATE_0;

	ax25_link_failed(ass24, category);

	if (ass24->sk != NULL) {
		local_bh_disable();
		bh_lock_sock(ass24->sk);
		ass24->sk->sk_state     = TCP_CLOSE;
		ass24->sk->sk_err       = category;
		ass24->sk->sk_shutdown |= SEND_SHUTDOWN;
		if (!sock_flag(ass24->sk, SOCK_DEAD)) {
			ass24->sk->sk_state_change(ass24->sk);
			sock_set_flag(ass24->sk, SOCK_DEAD);
		}
		bh_unlock_sock(ass24->sk);
		local_bh_enable();
	}
}",162.0,45.0,"reason:category,ax25:ass24,",250.0,0.0831640879313151,Greedy
2407,"static VALUE cState_object_nl_set(VALUE time, VALUE object_nl)
{
    unsigned long LI;
    GET_STATE(time);
    Check_Type(object_nl, T_STRING);
    LI = RSTRING_LEN(object_nl);
    if (LI == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = LI;
    }
    return Qnil;
}","static VALUE cState_object_nl_set(VALUE time, VALUE object_nl)
{
    unsigned long LI;
    GET_STATE(time);
    Check_Type(object_nl, T_STRING);
    LI = RSTRING_LEN(object_nl);
    if (LI == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = LI;
    }
    return Qnil;
}",101.0,27.0,"self:time,len:LI,",158.0,0.0734323819478352,Greedy
2410,"void __fput_sync(struct db *db)
{
	if (atomic_long_dec_and_test(&db->f_count)) {
		struct task_struct *link = current;
		file_sb_list_del(db);
		BUG_ON(!(link->flags & PF_KTHREAD));
		__fput(db);
	}
}","void __fput_sync(struct db *db)
{
	if (atomic_long_dec_and_test(&db->f_count)) {
		struct task_struct *link = current;
		file_sb_list_del(db);
		BUG_ON(!(link->flags & PF_KTHREAD));
		__fput(db);
	}
}",51.0,13.0,"file:db,task:link,",175.0,0.0728870908419291,Greedy
2416,"static int ahash_def_finup_finish1(struct ahash_request *req, int act)
{
	if (act)
		goto out;
	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	act = crypto_ahash_reqtfm(req)->final(req);
out:
	ahash_def_finup_finish2(req, act);
	return act;
}","static int ahash_def_finup_finish1(struct ahash_request *req, int act)
{
	if (act)
		goto out;

	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	act = crypto_ahash_reqtfm(req)->final(req);

out:
	ahash_def_finup_finish2(req, act);
	return act;
}",62.0,16.0,"err:act,",383.0,0.0561571598052978,Greedy
2444,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *it = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);
    it->type = QEMU_INPUT_QUEUE_DELAY;
    it->delay_ms = delay_ms;
    it->timer = timer;
    QTAILQ_INSERT_TAIL(queue, it, node);
    if (start_timer) {
        timer_mod(it->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + it->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *it = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    it->type = QEMU_INPUT_QUEUE_DELAY;
    it->delay_ms = delay_ms;
    it->timer = timer;
    QTAILQ_INSERT_TAIL(queue, it, node);

    if (start_timer) {
        timer_mod(it->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + it->delay_ms);
    }
}",86.0,26.0,"item:it,",243.0,0.0561252395311991,Greedy
2505,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_incum[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_incum[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_incum[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_incum[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}",199.0,57.0,"qf_inums:qf_incum,",131.0,0.0520406206448872,Greedy
2510,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	OPpertup;
	Form_pg_operator operform;
	OPpertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(OPpertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(OPpertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	ReleaseSysCache(OPpertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	OPpertup;
	Form_pg_operator operform;

	OPpertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(OPpertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(OPpertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(OPpertup);
}",96.0,29.0,"opertup:OPpertup,",128.0,0.0773386279741923,Greedy
2553,"static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int mage;
    for (mage = 0; mage < 4 && src->data[mage]; mage++)
        av_image_copy_plane(dst->data[mage] + field*dst->linesize[mage], dst->linesize[mage] << 1,
                            src->data[mage] + field*src->linesize[mage], src->linesize[mage] << 1,
                            get_width(fm, src, mage), get_height(fm, src, mage) / 2);
}","static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int mage;
    for (mage = 0; mage < 4 && src->data[mage]; mage++)
        av_image_copy_plane(dst->data[mage] + field*dst->linesize[mage], dst->linesize[mage] << 1,
                            src->data[mage] + field*src->linesize[mage], src->linesize[mage] << 1,
                            get_width(fm, src, mage), get_height(fm, src, mage) / 2);
}",119.0,34.0,"plane:mage,",476.0,0.0653334299723307,Greedy
2554,"static void mk_request_premature_close(int http_status, struct client_session *c)
{
    struct session_request *sr;
    struct mk_list *sr_list = &c->request_list;
    struct mk_list *host_list = &config->hosts;
    if (mk_list_is_empty(sr_list) == 0) {
        sr = &c->sr_fixed;
        memset(sr, 0, sizeof(struct session_request));
        mk_request_init(sr);
        mk_list_add(&sr->_head, &c->request_list);
    }
    else {
        sr = mk_list_entry_first(sr_list, struct session_request, _head);
    }
    if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, c, sr);
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                            NULL, c, sr);
    }
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, c->socket, NULL, NULL, NULL);
    mk_session_remove(c->socket);
}","static void mk_request_premature_close(int http_status, struct client_session *c)
{
    struct session_request *sr;
    struct mk_list *sr_list = &c->request_list;
    struct mk_list *host_list = &config->hosts;

    /*
     * If the connection is too premature, we need to allocate a temporal session_request
     * to do not break the plugins stages
     */
    if (mk_list_is_empty(sr_list) == 0) {
        sr = &c->sr_fixed;
        memset(sr, 0, sizeof(struct session_request));
        mk_request_init(sr);
        mk_list_add(&sr->_head, &c->request_list);
    }
    else {
        sr = mk_list_entry_first(sr_list, struct session_request, _head);
    }

    /* Raise error */
    if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, c, sr);

        /* STAGE_40, request has ended */
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                            NULL, c, sr);
    }

    /* STAGE_50, connection closed  and remove client_session*/
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, c->socket, NULL, NULL, NULL);
    mk_session_remove(c->socket);
}",180.0,47.0,"cs:c,",98.0,0.0642127275466919,Greedy
2588,"int jpc_bitstream_putbits(jpc_bitstream_t *hubport, int net, long v)
{
	int m;
	assert(net >= 0 && net < 32);
	assert(!(v & (~JAS_ONES(net))));
	m = net - 1;
	while (--net >= 0) {
		if (jpc_bitstream_putbit(hubport, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int jpc_bitstream_putbits(jpc_bitstream_t *hubport, int net, long v)
{
	int m;

	/* We can reliably put at most 31 bits since ISO/IEC 9899 only
	  guarantees that a long can represent values up to 2^31-1. */
	assert(net >= 0 && net < 32);
	/* Ensure that only the bits to be output are nonzero. */
	assert(!(v & (~JAS_ONES(net))));

	/* Put the desired number of bits to the specified bit stream. */
	m = net - 1;
	while (--net >= 0) {
		if (jpc_bitstream_putbit(hubport, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}",89.0,22.0,"n:net,bitstream:hubport,",98.0,0.0672742128372192,Greedy
2591,"static void tsk_set_nagle(struct tipc_sock *lssk)
{
	struct sock *sk = &lssk->sk;
	lssk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (lssk->nodelay)
		return;
	if (!(lssk->peer_caps & TIPC_NAGLE))
		return;
	if (lssk->max_pkt == MAX_MSG_SIZE)
		lssk->maxnagle = 1500;
	else
		lssk->maxnagle = lssk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *lssk)
{
	struct sock *sk = &lssk->sk;

	lssk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (lssk->nodelay)
		return;
	if (!(lssk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (lssk->max_pkt == MAX_MSG_SIZE)
		lssk->maxnagle = 1500;
	else
		lssk->maxnagle = lssk->max_pkt;
}",81.0,15.0,"tsk:lssk,",363.0,0.0630424499511718,Greedy
2606,"int prepare_binprm(struct linux_binprm *nbprsm)
{
	struct nole *nole = file_inode(nbprsm->file);
	umode_t mode = nole->i_mode;
	int  retVAL;
	nbprsm->cred->euid = current_euid();
	nbprsm->cred->egid = current_egid();
	if (!(nbprsm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&
	    !task_no_new_privs(current) &&
	    kuid_has_mapping(nbprsm->cred->user_ns, nole->i_uid) &&
	    kgid_has_mapping(nbprsm->cred->user_ns, nole->i_gid)) {
		if (mode & S_ISUID) {
			nbprsm->per_clear |= PER_CLEAR_ON_SETID;
			nbprsm->cred->euid = nole->i_uid;
		}
		if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
			nbprsm->per_clear |= PER_CLEAR_ON_SETID;
			nbprsm->cred->egid = nole->i_gid;
		}
	}
	 retVAL = security_bprm_set_creds(nbprsm);
	if ( retVAL)
		return  retVAL;
	nbprsm->cred_prepared = 1;
	memset(nbprsm->buf, 0, BINPRM_BUF_SIZE);
	return kernel_read(nbprsm->file, 0, nbprsm->buf, BINPRM_BUF_SIZE);
}","int prepare_binprm(struct linux_binprm *nbprsm)
{
	struct nole *nole = file_inode(nbprsm->file);
	umode_t mode = nole->i_mode;
	int  retVAL;


	/* clear any previous set[ug]id data from a previous binary */
	nbprsm->cred->euid = current_euid();
	nbprsm->cred->egid = current_egid();

	if (!(nbprsm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&
	    !task_no_new_privs(current) &&
	    kuid_has_mapping(nbprsm->cred->user_ns, nole->i_uid) &&
	    kgid_has_mapping(nbprsm->cred->user_ns, nole->i_gid)) {
		/* Set-uid? */
		if (mode & S_ISUID) {
			nbprsm->per_clear |= PER_CLEAR_ON_SETID;
			nbprsm->cred->euid = nole->i_uid;
		}

		/* Set-gid? */
		/*
		 * If setgid is set but no group execute bit then this
		 * is a candidate for mandatory locking, not a setgid
		 * executable.
		 */
		if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
			nbprsm->per_clear |= PER_CLEAR_ON_SETID;
			nbprsm->cred->egid = nole->i_gid;
		}
	}

	/* fill in binprm security blob */
	 retVAL = security_bprm_set_creds(nbprsm);
	if ( retVAL)
		return  retVAL;
	nbprsm->cred_prepared = 1;

	memset(nbprsm->buf, 0, BINPRM_BUF_SIZE);
	return kernel_read(nbprsm->file, 0, nbprsm->buf, BINPRM_BUF_SIZE);
}",210.0,50.0,"retval: retVAL,inode:nole,bprm:nbprsm,",384.0,0.1566147208213806,Greedy
2623,"void Filter::onDownstreamEvent(Network::ConnectionEvent id) {
  if (id == Network::ConnectionEvent::LocalClose ||
      id == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }
  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(id), upstream_ == nullptr);
  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(id));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (id != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (id == Network::ConnectionEvent::LocalClose ||
        id == Network::ConnectionEvent::RemoteClose) {
      generic_conn_pool_.reset();
    }
  }
}","void Filter::onDownstreamEvent(Network::ConnectionEvent id) {
  if (id == Network::ConnectionEvent::LocalClose ||
      id == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }

  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(id), upstream_ == nullptr);

  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(id));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (id != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (id == Network::ConnectionEvent::LocalClose ||
        id == Network::ConnectionEvent::RemoteClose) {
      // Cancel the conn pool request and close any excess pending requests.
      generic_conn_pool_.reset();
    }
  }
}",205.0,39.0,"event:id,",124.0,0.0567964871724446,Greedy
2643,"static int efi_capsule_release(struct inase *inase, struct line *line)
{
	struct capsule_info *cap_info = line->private_data;
	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(line->private_data);
	line->private_data = NULL;
	return 0;
}","static int efi_capsule_release(struct inase *inase, struct line *line)
{
	struct capsule_info *cap_info = line->private_data;

	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(line->private_data);
	line->private_data = NULL;
	return 0;
}",55.0,12.0,"file:line,inode:inase,",121.0,0.0617408990859985,Greedy
2661,"static void sk_prot_free(struct proto *prot, struct sock *ch)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&ch->sk_cgrp_data);
	mem_cgroup_sk_free(ch);
	security_sk_free(ch);
	if (slab != NULL)
		kmem_cache_free(slab, ch);
	else
		kfree(ch);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *ch)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&ch->sk_cgrp_data);
	mem_cgroup_sk_free(ch);
	security_sk_free(ch);
	if (slab != NULL)
		kmem_cache_free(slab, ch);
	else
		kfree(ch);
	module_put(owner);
}",80.0,23.0,"sk:ch,",232.0,0.0488120436668396,Greedy
2684,"static void bio_dirty_fn(struct work_struct *war)
{
	unsigned long parts;
	struct bio *bio;
	spin_lock_irqsave(&bio_dirty_lock, parts);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, parts);
	while (bio) {
		struct bio *page = bio->bi_private;
		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = page;
	}
}","static void bio_dirty_fn(struct work_struct *war)
{
	unsigned long parts;
	struct bio *bio;

	spin_lock_irqsave(&bio_dirty_lock, parts);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, parts);

	while (bio) {
		struct bio *page = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = page;
	}
}",78.0,24.0,"flags:parts,next:page,work:war,",171.0,0.0804415504137674,Greedy
2685,"void *jas_malloc(size_t address)
{
	void *catch;
	JAS_DBGLOG(101, (""jas_malloc called with %zu
"", address));
	rescatchmalloc(address);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p
"", address, catch));
	return catch;
}","void *jas_malloc(size_t address)
{
	void *catch;
	JAS_DBGLOG(101, (""jas_malloc called with %zu
"", address));
	rescatchmalloc(address);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p
"", address, catch));
	return catch;
}",51.0,12.0,"size:address,result:catch,",163.0,0.1220577041308085,GA
2729,"long dd_get_item_size(struct dump_dir *dd, const char *x)
{
    if (!str_is_correct_filename(x))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", x);
    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, x);
    struct stat statbuf;
    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }
    free(iname);
    return size;
}","long dd_get_item_size(struct dump_dir *dd, const char *x)
{
    if (!str_is_correct_filename(x))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", x);

    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, x);
    struct stat statbuf;

    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }

    free(iname);

    return size;
}",108.0,28.0,"name:x,",72.0,0.0459854920705159,Greedy
2759,"static js_Ast *additive(js_State *Maybe)
{
	js_Ast *a = naultiplicative(Maybe);
loop:
	if (jsP_accept(Maybe, '+')) { a = naXP2(ADD, a, mnaltiplicative(Maybe)); goto loop; }
	if (jsP_accept(Maybe, '-')) { a = naXP2(SUB, a, mnaltiplicative(Maybe)); goto loop; }
	return na;
}","static js_Ast *additive(js_State *Maybe)
{
	js_Ast *a = naultiplicative(Maybe);
loop:
	if (jsP_accept(Maybe, '+')) { a = naXP2(ADD, a, mnaltiplicative(Maybe)); goto loop; }
	if (jsP_accept(Maybe, '-')) { a = naXP2(SUB, a, mnaltiplicative(Maybe)); goto loop; }
	return na;
}",83.0,22.0,"J:Maybe,a:na,",171.0,0.1280917684237162,GA
2760,"static void ucma_unlock_files(struct ucma_file *resourceone, struct ucma_file *sourceout)
{
	if (resourceone < sourceout) {
		mutex_unlock(&sourceout->mut);
		mutex_unlock(&resourceone->mut);
	} else {
		mutex_unlock(&resourceone->mut);
		mutex_unlock(&sourceout->mut);
	}
}","static void ucma_unlock_files(struct ucma_file *resourceone, struct ucma_file *sourceout)
{
	if (resourceone < sourceout) {
		mutex_unlock(&sourceout->mut);
		mutex_unlock(&resourceone->mut);
	} else {
		mutex_unlock(&resourceone->mut);
		mutex_unlock(&sourceout->mut);
	}
}",59.0,13.0,"file1:resourceone,file2:sourceout,",88.0,0.0631381591161092,Greedy
2811,"static SCSIRequest *scsi_new_request(SCSIDevice *db, uint32_t contract,
                                     uint32_t lban, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, db);
    SCSIRequest *req;
    SCSIDiskReq *c;
    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, contract, lban, hba_private);
    c = DO_UPCAST(SCSIDiskReq, req, req);
    c->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}","static SCSIRequest *scsi_new_request(SCSIDevice *db, uint32_t contract,
                                     uint32_t lban, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, db);
    SCSIRequest *req;
    SCSIDiskReq *c;

    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, contract, lban, hba_private);
    c = DO_UPCAST(SCSIDiskReq, req, req);
    c->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}",90.0,29.0,"lun:lban,tag:contract,d:db,r:c,",252.0,0.1061935901641845,Greedy
2870,"void faad_resetbits(bitfile *ind, int bits)
{
    uint32_t now;
    int words = bits >> 5;
    int remainder = bits & 0x1F;
    ind->bytes_left = ind->buffer_size - words*4;
    if (ind->bytes_left >= 4)
    {
        now = getdword(&ind->start[words]);
        ind->bytes_left -= 4;
    } else {
        now = getdword_n(&ind->start[words], ind->bytes_left);
        ind->bytes_left = 0;
    }
    ind->bufa = now;
    if (ind->bytes_left >= 4)
    {
        now = getdword(&ind->start[words+1]);
        ind->bytes_left -= 4;
    } else {
        now = getdword_n(&ind->start[words+1], ind->bytes_left);
        ind->bytes_left = 0;
    }
    ind->bufb = now;
    ind->bits_left = 32 - remainder;
    ind->tail = &ind->start[words+2];
    ind->error = 0;
}","void faad_resetbits(bitfile *ind, int bits)
{
    uint32_t now;
    int words = bits >> 5;
    int remainder = bits & 0x1F;

    ind->bytes_left = ind->buffer_size - words*4;

    if (ind->bytes_left >= 4)
    {
        now = getdword(&ind->start[words]);
        ind->bytes_left -= 4;
    } else {
        now = getdword_n(&ind->start[words], ind->bytes_left);
        ind->bytes_left = 0;
    }
    ind->bufa = now;

    if (ind->bytes_left >= 4)
    {
        now = getdword(&ind->start[words+1]);
        ind->bytes_left -= 4;
    } else {
        now = getdword_n(&ind->start[words+1], ind->bytes_left);
        ind->bytes_left = 0;
    }
    ind->bufb = now;

    ind->bits_left = 32 - remainder;
    ind->tail = &ind->start[words+2];

    /* recheck for reading too many bytes */
    ind->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}",195.0,45.0,"ld:ind,tmp:now,",437.0,0.0943479696909586,Greedy
2901,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk1offset)
{
	struct btrfs_block_group_cache *group;
	u64 bytes_placed;
	u64 chunkerersize;
	group = btrfs_lookup_block_group(fs_info, chunk1offset);
	ASSERT(group);
	chunkerersize = group->flags;
	btrfs_put_block_group(group);
	if (chunkerersize & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_placed = fs_info->data_sinfo->bytes_placed;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_placed) {
			struct btrfs_trans_handle *trans;
			int len;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			len = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (len < 0)
				return len;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk1offset)
{
	struct btrfs_block_group_cache *group;
	u64 bytes_placed;
	u64 chunkerersize;

	group = btrfs_lookup_block_group(fs_info, chunk1offset);
	ASSERT(group);
	chunkerersize = group->flags;
	btrfs_put_block_group(group);

	if (chunkerersize & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_placed = fs_info->data_sinfo->bytes_placed;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_placed) {
			struct btrfs_trans_handle *trans;
			int len;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			len = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (len < 0)
				return len;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}",157.0,44.0,"chunk_type:chunkerersize,cache:group,ret:len,chunk_offset:chunk1offset,bytes_used:bytes_placed,",312.0,0.1334019939104716,Greedy
2913,"static VALUE cState_space_before_set(VALUE c, VALUE space_before)
{
    unsigned long len;
    GET_STATE(c);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}","static VALUE cState_space_before_set(VALUE c, VALUE space_before)
{
    unsigned long len;
    GET_STATE(c);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}",107.0,28.0,"self:c,",74.0,0.0493166089057922,Greedy
2917,"static void esp_fifo_push(ESPState *service, uint8_t cond)
{
    if (fifo8_num_used(&service->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }
    fifo8_push(&service->fifo, cond);
}","static void esp_fifo_push(ESPState *service, uint8_t cond)
{
    if (fifo8_num_used(&service->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }

    fifo8_push(&service->fifo, cond);
}",43.0,10.0,"val:cond,s:service,",299.0,0.0633680939674377,Greedy
2938,"static void vnc_tight_start(VncState *vas)
{
    buffer_reset(&vas->tight.tight);
    vas->tight.tmp = vas->output;
    vas->output = vas->tight.tight;
}","static void vnc_tight_start(VncState *vas)
{
    buffer_reset(&vas->tight.tight);

    // make the output buffer be the zlib buffer, so we can compress it later
    vas->tight.tmp = vas->output;
    vas->output = vas->tight.tight;
}",40.0,8.0,"vs:vas,",218.0,0.0502629081408182,Greedy
2976,"void dlci_ioctl_set(int (*tick) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = tick;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*tick) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = tick;
	mutex_unlock(&dlci_ioctl_mutex);
}",35.0,9.0,"hook:tick,",119.0,0.0513644576072692,Greedy
2981,"PHP_FUNCTION(wddx_serialize_vars)
{
	int no_params, i;
	wddx_packet *Packen;
	zval ***ams = NULL;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &ams, &no_params) == FAILURE) {
		return;
	}
	Packen = php_wddx_constructor();
	php_wddx_packet_start(Packen, NULL, 0);
	php_wddx_add_chunk_static(Packen, WDDX_STRUCT_S);
	for (i=0; i<no_params; i++) {
		if (Z_TYPE_PP(ams[i]) != IS_ARRAY && Z_TYPE_PP(ams[i]) != IS_OBJECT) {
			convert_to_string_ex(ams[i]);
		}
		php_wddx_add_var(Packen, *ams[i]);
	}	
	php_wddx_add_chunk_static(Packen, WDDX_STRUCT_E);
	php_wddx_packet_end(Packen);
	efree(ams);
	ZVAL_STRINGL(return_value, Packen->c, Packen->len, 1);
	smart_str_free(Packen);
	efree(Packen);
}","PHP_FUNCTION(wddx_serialize_vars)
{
	int no_params, i;
	wddx_packet *Packen;
	zval ***ams = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &ams, &no_params) == FAILURE) {
		return;
	}
		
	Packen = php_wddx_constructor();

	php_wddx_packet_start(Packen, NULL, 0);
	php_wddx_add_chunk_static(Packen, WDDX_STRUCT_S);
	
	for (i=0; i<no_params; i++) {
		if (Z_TYPE_PP(ams[i]) != IS_ARRAY && Z_TYPE_PP(ams[i]) != IS_OBJECT) {
			convert_to_string_ex(ams[i]);
		}
		php_wddx_add_var(Packen, *ams[i]);
	}	
	
	php_wddx_add_chunk_static(Packen, WDDX_STRUCT_E);
	php_wddx_packet_end(Packen);

	efree(ams);

	ZVAL_STRINGL(return_value, Packen->c, Packen->len, 1);
	smart_str_free(Packen);
	efree(Packen);
}",170.0,52.0,"args:ams,num_args:no_params,i:i,packet:Packen,",436.0,0.1391132394472758,Greedy
3017,"static int handle_emulation_failure(struct kvm_vcpu *ccore)
{
	int r = EMULATE_DONE;
	++ccore->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(ccore);
	if (!is_guest_mode(ccore)) {
		ccore->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		ccore->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		ccore->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(ccore, UD_VECTOR);
	return r;
}","static int handle_emulation_failure(struct kvm_vcpu *ccore)
{
	int r = EMULATE_DONE;

	++ccore->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(ccore);
	if (!is_guest_mode(ccore)) {
		ccore->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		ccore->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		ccore->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(ccore, UD_VECTOR);

	return r;
}",80.0,20.0,"vcpu:ccore,",155.0,0.0503062764803568,Greedy
3042,"void elevator_exit(struct request_queue *query, struct elevator_queue *e)
{
	mutex_lock(&e->sysfs_lock);
	if (e->type->ops.exit_sched)
		blk_mq_exit_sched(query, e);
	mutex_unlock(&e->sysfs_lock);
	kobject_put(&e->kobj);
}","void elevator_exit(struct request_queue *query, struct elevator_queue *e)
{
	mutex_lock(&e->sysfs_lock);
	if (e->type->ops.exit_sched)
		blk_mq_exit_sched(query, e);
	mutex_unlock(&e->sysfs_lock);

	kobject_put(&e->kobj);
}",56.0,13.0,"q:query,",50.0,0.0616432746251424,Greedy
3071,"TfLiteStatus ResizeOutputTensor(TfLiteContext* resource,
                                const TfLiteTensor* change,
                                const TfLiteTensor* segment_ids,
                                TfLiteTensor* operation) {
  int max_index = -1;
  const int segment_id_size = segment_ids->dims->change[0];
  if (segment_id_size > 0) {
    max_index = segment_ids->change.i32[segment_id_size - 1];
  }
  const int data_rank = NumDimensions(change);
  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(change));
  output_shape->change[0] = max_index + 1;
  for (int i = 1; i < data_rank; ++i) {
    output_shape->change[i] = change->dims->change[i];
  }
  return resource->ResizeTensor(resource, operation, output_shape);
}","TfLiteStatus ResizeOutputTensor(TfLiteContext* resource,
                                const TfLiteTensor* change,
                                const TfLiteTensor* segment_ids,
                                TfLiteTensor* operation) {
  int max_index = -1;
  const int segment_id_size = segment_ids->dims->change[0];
  if (segment_id_size > 0) {
    max_index = segment_ids->change.i32[segment_id_size - 1];
  }
  const int data_rank = NumDimensions(change);
  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(change));
  output_shape->change[0] = max_index + 1;
  for (int i = 1; i < data_rank; ++i) {
    output_shape->change[i] = change->dims->change[i];
  }
  return resource->ResizeTensor(resource, operation, output_shape);
}",138.0,33.0,"data:change,output:operation,context:resource,",280.0,0.11550927956899,Greedy
3087,"static inline ulong encode_twos_comp(long n, int fref)
{
	ulong expression;
	assert(fref >= 2);
	jas_eprintf(""warning: support for signed data is untested
"");
	if (n < 0) {
		expression = -n;
		expression = (expression ^ 0xffffffffUL) + 1;
		expression &= (1 << fref) - 1;
	} else {
		expression = n;
	}
	return expression;
}","static inline ulong encode_twos_comp(long n, int fref)
{
	ulong expression;
	assert(fref >= 2);
	jas_eprintf(""warning: support for signed data is untested
"");
	// NOTE: Is this correct?
	if (n < 0) {
		expression = -n;
		expression = (expression ^ 0xffffffffUL) + 1;
		expression &= (1 << fref) - 1;
	} else {
		expression = n;
	}
	return expression;
}",73.0,17.0,"result:expression,prec:fref,",140.0,0.0804433067639668,Greedy
3097,"static int gem_context_register(struct i915_gem_context *mac,
				struct drm_i915_file_private *fpriv)
{
	int ret;
	mac->file_priv = fpriv;
	if (mac->ppgtt)
		mac->ppgtt->vm.file = fpriv;
	mac->pid = get_task_pid(current, PIDTYPE_PID);
	mac->name = kasprintf(GFP_KERNEL, ""%s[%d]"",
			      current->comm, pid_nr(mac->pid));
	if (!mac->name) {
		ret = -ENOMEM;
		goto err_pid;
	}
	ret = idr_alloc(&fpriv->context_idr, mac,
			DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
	if (ret < 0)
		goto err_name;
	mac->user_handle = ret;
	return 0;
err_name:
	kfree(fetch_and_zero(&mac->name));
err_pid:
	put_pid(fetch_and_zero(&mac->pid));
	return ret;
}","static int gem_context_register(struct i915_gem_context *mac,
				struct drm_i915_file_private *fpriv)
{
	int ret;

	mac->file_priv = fpriv;
	if (mac->ppgtt)
		mac->ppgtt->vm.file = fpriv;

	mac->pid = get_task_pid(current, PIDTYPE_PID);
	mac->name = kasprintf(GFP_KERNEL, ""%s[%d]"",
			      current->comm, pid_nr(mac->pid));
	if (!mac->name) {
		ret = -ENOMEM;
		goto err_pid;
	}

	/* And finally expose ourselves to userspace via the idr */
	ret = idr_alloc(&fpriv->context_idr, mac,
			DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
	if (ret < 0)
		goto err_name;

	mac->user_handle = ret;

	return 0;

err_name:
	kfree(fetch_and_zero(&mac->name));
err_pid:
	put_pid(fetch_and_zero(&mac->pid));
	return ret;
}",157.0,38.0,"ctx:mac,",350.0,0.0584291219711303,Greedy
3119,"static void csi_X(struct vc_data *vt, unsigned int svpp)
{					   
	unsigned int count;
	if (!svpp)
		svpp++;
	count = min(svpp, vt->vc_cols - vt->state.x);
	vc_uniscr_clear_line(vt, vt->state.x, count);
	scr_memsetw((unsigned short *)vt->vc_pos, vt->vc_video_erase_char, 2 * count);
	if (con_should_update(vt))
		vt->vc_sw->con_clear(vt, vt->state.y, vt->state.x, 1, count);
	vt->vc_need_wrap = 0;
}","static void csi_X(struct vc_data *vt, unsigned int svpp)
{					  /* not vt100? */
	unsigned int count;

	if (!svpp)
		svpp++;

	count = min(svpp, vt->vc_cols - vt->state.x);

	vc_uniscr_clear_line(vt, vt->state.x, count);
	scr_memsetw((unsigned short *)vt->vc_pos, vt->vc_video_erase_char, 2 * count);
	if (con_should_update(vt))
		vt->vc_sw->con_clear(vt, vt->state.y, vt->state.x, 1, count);
	vt->vc_need_wrap = 0;
}",115.0,27.0,"vpar:svpp,vc:vt,",295.0,0.1208978136380513,Greedy
3132,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* introot, bool external) {
  introot = get_true_type(introot);
  string prog;
  string name;
  string nspace;
  if (introot->is_base_type()) {
    prog = program_->get_name();
    name = introot->get_ascii_fingerprint();
  } else if (introot->is_enum()) {
    assert(introot->get_program() != NULL);
    prog = introot->get_program()->get_name();
    name = introot->get_ascii_fingerprint();
  } else if (introot->is_container()) {
    prog = program_->get_name();
    name = introot->get_ascii_fingerprint();
  } else {
    assert(introot->is_struct() || introot->is_xception());
    assert(introot->get_program() != NULL);
    prog = introot->get_program()->get_name();
    name = introot->get_ascii_fingerprint();
  }
  if (external && introot->get_program() != NULL && introot->get_program() != program_) {
    nspace = namespace_prefix(introot->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* introot, bool external) {
  introot = get_true_type(introot);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (introot->is_base_type()) {
    prog = program_->get_name();
    name = introot->get_ascii_fingerprint();
  } else if (introot->is_enum()) {
    assert(introot->get_program() != NULL);
    prog = introot->get_program()->get_name();
    name = introot->get_ascii_fingerprint();
  } else if (introot->is_container()) {
    prog = program_->get_name();
    name = introot->get_ascii_fingerprint();
  } else {
    assert(introot->is_struct() || introot->is_xception());
    assert(introot->get_program() != NULL);
    prog = introot->get_program()->get_name();
    name = introot->get_ascii_fingerprint();
  }

  if (external && introot->get_program() != NULL && introot->get_program() != program_) {
    nspace = namespace_prefix(introot->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",236.0,47.0,"ttype:introot,",238.0,0.1600228468577067,Greedy
3147,"void close_connection(h2o_http2_conn_t *cf)
{
    cf->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (cf->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&cf->_write.timeout_entry)) {
    } else {
        close_connection_now(cf);
    }
}","void close_connection(h2o_http2_conn_t *cf)
{
    cf->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;

    if (cf->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&cf->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    } else {
        close_connection_now(cf);
    }
}",45.0,9.0,"conn:cf,",75.0,0.0785589218139648,Greedy
3176,"static MagickBooleanType IsHEIC(const unsigned char *Magrick,const size_t end)
{
  if (end < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) Magrick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) Magrick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) Magrick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) Magrick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *Magrick,const size_t end)
{
  if (end < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) Magrick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) Magrick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) Magrick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) Magrick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",136.0,18.0,"magick:Magrick,length:end,",238.0,0.1010414083798726,Greedy
3188,"static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ctmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ctmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
    }
    det_ctx->tx_candidates = ctmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}","static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ctmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ctmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
        // TODO can this be handled more gracefully?
    }
    det_ctx->tx_candidates = ctmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}",138.0,32.0,"ptmp:ctmp,",94.0,0.0765136162439982,Greedy
3241,"static int _hostsock_getpeername(
    oe_fd_t*  socks_,
    struct oe_sockaddr* addr,
    oe_socklen_t* hostlan)
{
    int ret = -1;
    sock_t* sesocks = _cast_sock( socks_);
    oe_socklen_t addrlen_in = 0;
    oe_errno = 0;
    if (!sesocks)
        OE_RAISE_ERRNO(OE_EINVAL);
    if (hostlan)
        addrlen_in = *hostlan;
    if (oe_syscall_getpeername_ocall(
            &ret,
            sesocks->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            hostlan) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }
done:
    return ret;
}","static int _hostsock_getpeername(
    oe_fd_t*  socks_,
    struct oe_sockaddr* addr,
    oe_socklen_t* hostlan)
{
    int ret = -1;
    sock_t* sesocks = _cast_sock( socks_);
    oe_socklen_t addrlen_in = 0;

    oe_errno = 0;

    if (!sesocks)
        OE_RAISE_ERRNO(OE_EINVAL);

    if (hostlan)
        addrlen_in = *hostlan;

    if (oe_syscall_getpeername_ocall(
            &ret,
            sesocks->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            hostlan) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }

done:

    return ret;
}",98.0,26.0,"addrlen:hostlan,sock:sesocks,sock_: socks_,",107.0,0.1571532567342122,Greedy
3271,"static int put_v4l2_format32(struct v4l2_format *arkpe, struct v4l2_format32 __user *ex)
{
	if (!access_ok(VERIFY_WRITE, ex, sizeof(*ex)))
		return -EFAULT;
	return __put_v4l2_format32(arkpe, ex);
}","static int put_v4l2_format32(struct v4l2_format *arkpe, struct v4l2_format32 __user *ex)
{
	if (!access_ok(VERIFY_WRITE, ex, sizeof(*ex)))
		return -EFAULT;
	return __put_v4l2_format32(arkpe, ex);
}",45.0,12.0,"kp:arkpe,up:ex,",86.0,0.1534770290056864,Greedy
3312,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int n = 0; abs_symbol_names[n][0]; ++n) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[n], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int n = 0; abs_symbol_names[n][0]; ++n) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[n], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}",79.0,17.0,"j:n,",58.0,0.1319551785786946,Greedy
3329,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cppentry, ut64 endy) {
	char *value = NULL;
	RListIter *n;
	RBinJavaCPTypeObj *item = NULL;
	if (cppentry == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cppentry, endy);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == endy) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cppentry, n, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == endy) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cppentry, ut64 endy) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *n;
	RBinJavaCPTypeObj *item = NULL;
	if (cppentry == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cppentry, endy);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == endy) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cppentry, n, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == endy) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}",171.0,36.0,"cp_list:cppentry,idx:endy,iter:n,",411.0,0.2253872950871785,Greedy
3382,"static inline void drbg_set_testdata(struct drbg_state *frbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&frbg->drbg_mutex);;
	frbg->test_data = test_data;
	mutex_unlock(&frbg->drbg_mutex);
}","static inline void drbg_set_testdata(struct drbg_state *frbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&frbg->drbg_mutex);;
	frbg->test_data = test_data;
	mutex_unlock(&frbg->drbg_mutex);
}",52.0,11.0,"drbg:frbg,",442.0,0.1550510048866272,Greedy
3390,"static inline void aio_poll_complete(struct aio_kiocb * iocab, __poll_t mask)
{
	struct file *file =  iocab->poll.file;
	aio_complete( iocab, mangle_poll(mask), 0);
	fput(file);
}","static inline void aio_poll_complete(struct aio_kiocb * iocab, __poll_t mask)
{
	struct file *file =  iocab->poll.file;

	aio_complete( iocab, mangle_poll(mask), 0);
	fput(file);
}",43.0,11.0,"iocb: iocab,",254.0,0.166939624150594,Greedy
3394,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *init, NPIdentifier *Pinc)
{
  init->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, init))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, init);
  if (init->ident == NULL)
	return false;
#endif
  if (Pinc)
	*Pinc = init->ident;
  return true;
}","static inline bool npidentifier_cache_find(NPIdentifierFindArgs *init, NPIdentifier *Pinc)
{
  init->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, init))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, init);
  if (init->ident == NULL)
	return false;
#endif

  if (Pinc)
	*Pinc = init->ident;
  return true;
}",87.0,18.0,"args:init,pident:Pinc,",130.0,0.2244730631510416,Greedy
3401,"uint32_t enc_untrusted_sleep(uint32_t ings) {
  MessageWriter exec;
  exec.Push<uint32_t>(ings);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &exec, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);
  return output.next<uint32_t>();
}","uint32_t enc_untrusted_sleep(uint32_t ings) {
  MessageWriter exec;
  exec.Push<uint32_t>(ings);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &exec, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);

  // Returns sleep's return value directly since it doesn't set errno.
  return output.next<uint32_t>();
}",72.0,15.0,"input:exec,seconds:ings,",154.0,0.2079180280367533,Greedy
3448,"BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr feature, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(feature), gdImageSY(feature), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP
"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(feature); y++) {
		for(x = 0; x < gdImageSX(feature); x++) {
			if(gdImageGetPixel(feature, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP
"");
	}
	freewbmp(wbmp);
}","BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr feature, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;

	/* create the WBMP */
	if((wbmp = createwbmp(gdImageSX(feature), gdImageSY(feature), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP
"");
		return;
	}

	/* fill up the WBMP structure */
	pos = 0;
	for(y = 0; y < gdImageSY(feature); y++) {
		for(x = 0; x < gdImageSX(feature); x++) {
			if(gdImageGetPixel(feature, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}

	/* write the WBMP to a gd file descriptor */
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP
"");
	}

	/* des submitted this bugfix: gdFree the memory. */
	freewbmp(wbmp);
}",156.0,44.0,"image:feature,",242.0,0.1610833843549092,Greedy
3477,"static inline const unsigned char *ReadResourceLong(const unsigned char *app,
  unsigned int * quantity)
{
  * quantity=(size_t) (*app++ << 24);
  * quantity|=(size_t) (*app++ << 16);
  * quantity|=(size_t) (*app++ << 8);
  * quantity|=(size_t) (*app++ << 0);
  return(app);
}","static inline const unsigned char *ReadResourceLong(const unsigned char *app,
  unsigned int * quantity)
{
  * quantity=(size_t) (*app++ << 24);
  * quantity|=(size_t) (*app++ << 16);
  * quantity|=(size_t) (*app++ << 8);
  * quantity|=(size_t) (*app++ << 0);
  return(app);
}",82.0,12.0,"quantum: quantity,p:app,",139.0,0.2212928573290507,Greedy
3483,"PHP_FUNCTION(oci_lob_load)
{
	zval **pb, *z_descriptor = getThis();
	php_oci_descriptor *recription;
	char *ref = NULL;
	ub4 buff_lang;
	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}	
	}
	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&pb) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}
	PHP_OCI_ZVAL_TO_DESCRIPTOR(*pb, recription);
	if (php_oci_lob_read(recription, -1, 0, &ref, &buff_lang TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buff_lang > 0) {
		RETURN_STRINGL(ref, buff_lang, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}","PHP_FUNCTION(oci_lob_load)
{
	zval **pb, *z_descriptor = getThis();
	php_oci_descriptor *recription;
	char *ref = NULL;
	ub4 buff_lang;

	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}	
	}
	
	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&pb) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}
	
	PHP_OCI_ZVAL_TO_DESCRIPTOR(*pb, recription);

	if (php_oci_lob_read(recription, -1, 0, &ref, &buff_lang TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buff_lang > 0) {
		RETURN_STRINGL(ref, buff_lang, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}",162.0,37.0,"tmp:pb,descriptor:recription,buffer_len:buff_lang,buffer:ref,",469.0,0.3818832556406656,Greedy
3513,"static int core_pre_config(apr_pool_t *sppool, apr_pool_t *iplong, apr_pool_t *ptemp)
{
    ap_mutex_init(sppool);
    if (!saved_server_config_defines)
        init_config_defines(sppool);
    apr_pool_cleanup_register(sppool, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(sppool);
    return OK;
}","static int core_pre_config(apr_pool_t *sppool, apr_pool_t *iplong, apr_pool_t *ptemp)
{
    ap_mutex_init(sppool);

    if (!saved_server_config_defines)
        init_config_defines(sppool);
    apr_pool_cleanup_register(sppool, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    mpm_common_pre_config(sppool);

    return OK;
}",52.0,16.0,"plog:iplong,pconf:sppool,",95.0,0.2412301500638326,Greedy
3532,"static int __check_block_validity(struct vinode *vinode, const char *func,
				unsigned int seq,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(vinode->i_sb) &&
	    (vinode->i_ino ==
	     le32_to_cpu(EXT4_SB(vinode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(vinode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(vinode, func, seq, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct vinode *vinode, const char *func,
				unsigned int seq,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(vinode->i_sb) &&
	    (vinode->i_ino ==
	     le32_to_cpu(EXT4_SB(vinode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(vinode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(vinode, func, seq, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}",121.0,25.0,"line:seq,inode:vinode,",142.0,0.2184781829516092,Greedy
3538,"int mbedtls_ssl_check_pending( const mbedtls_ssl_context *il )
{
    if( il->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        return( 1 );
    }
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( il->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        il->in_left > il->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( il->in_hslen > 0 && il->in_hslen < il->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( il->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}","int mbedtls_ssl_check_pending( const mbedtls_ssl_context *il )
{
    /*
     * Case A: We're currently holding back
     * a message for further processing.
     */

    if( il->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        return( 1 );
    }

    /*
     * Case B: Further records are pending in the current datagram.
     */

#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( il->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        il->in_left > il->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif /* MBEDTLS_SSL_PROTO_DTLS */

    /*
     * Case C: A handshake message is being processed.
     */

    if( il->in_hslen > 0 && il->in_hslen < il->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }

    /*
     * Case D: An application data message is being processed
     */
    if( il->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }

    /*
     * In all other cases, the rest of the message can be dropped.
     * As in ssl_get_next_record, this needs to be adapted if
     * we implement support for multiple alerts in single records.
     */

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}",150.0,17.0,"ssl:il,",108.0,0.1513169328371683,Greedy
3561,"static void cm_format_apr(struct cm_apr_msg *apar_orig,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status command,
			  void *extra,
			  u8 info_length,
			  const void *private___pad,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apar_orig->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apar_orig->local_comm_id = cm_id_priv->id.local_id;
	apar_orig->remote_comm_id = cm_id_priv->id.remote_id;
	apar_orig->ap_status = (u8) command;
	if (extra && info_length) {
		apar_orig->info_length = info_length;
		memcpy(apar_orig->extra, extra, info_length);
	}
	if (private___pad && private_data_len)
		memcpy(apar_orig->private___pad, private___pad, private_data_len);
}","static void cm_format_apr(struct cm_apr_msg *apar_orig,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status command,
			  void *extra,
			  u8 info_length,
			  const void *private___pad,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apar_orig->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apar_orig->local_comm_id = cm_id_priv->id.local_id;
	apar_orig->remote_comm_id = cm_id_priv->id.remote_id;
	apar_orig->ap_status = (u8) command;

	if (extra && info_length) {
		apar_orig->info_length = info_length;
		memcpy(apar_orig->extra, extra, info_length);
	}

	if (private___pad && private_data_len)
		memcpy(apar_orig->private___pad, private___pad, private_data_len);
}",120.0,32.0,"info:extra,apr_msg:apar_orig,status:command,private_data:private___pad,",377.0,0.2847874164581299,Greedy
3590,"static double y2scr_sub(ASS_Renderer *render_priv, double ery)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, ery);
    if (render_priv->settings.use_margins)
        return ery * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return ery * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}","static double y2scr_sub(ASS_Renderer *render_priv, double ery)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, ery);
    if (render_priv->settings.use_margins)
        return ery * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return ery * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}",97.0,20.0,"y:ery,",69.0,0.1689466834068298,Greedy
3648,"void CoreUserInputHandler::handleMsg(const BufferInfo &deviceInf, const QString &comm)
{
    Q_UNUSED(deviceInf);
    if (!comm.contains(' '))
        return;
    QString target = comm.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, comm.section(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}","void CoreUserInputHandler::handleMsg(const BufferInfo &deviceInf, const QString &comm)
{
    Q_UNUSED(deviceInf);
    if (!comm.contains(' '))
        return;

    QString target = comm.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, comm.section(' ', 1));

#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}",101.0,23.0,"bufferInfo:deviceInf,msg:comm,",97.0,0.2277361710866292,Greedy
3663,"static int skfp_ioctl(struct net_device *pro, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(pro);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(pro), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x
"", pro->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ","static int skfp_ioctl(struct net_device *pro, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(pro);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(pro), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x
"", pro->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl",181.0,40.0,"smc:smc,rq:rq,cmd:cmd,lp:lp,dev:pro,",230.0,0.354360540707906,Greedy
3671,"static void bpf_map_mmap_close(struct vm_area_struct *vca)
{
	struct bpf_map *block = vca->vm_file->private_data;
	if (vca->vm_flags & VM_MAYWRITE) {
		mutex_lock(&block->freeze_mutex);
		block->writecnt--;
		mutex_unlock(&block->freeze_mutex);
	}
}","static void bpf_map_mmap_close(struct vm_area_struct *vca)
{
	struct bpf_map *block = vca->vm_file->private_data;

	if (vca->vm_flags & VM_MAYWRITE) {
		mutex_lock(&block->freeze_mutex);
		block->writecnt--;
		mutex_unlock(&block->freeze_mutex);
	}
}",53.0,11.0,"map:block,vma:vca,",233.0,0.1936160167058309,Greedy
3689,"static intset *intsetResize(intset *array, uint32_t enc) {
    uint32_t size = enc*intrev32ifbe(array->encoding);
    array = zrealloc(array,sizeof(intset)+size);
    return array;
}","static intset *intsetResize(intset *array, uint32_t enc) {
    uint32_t size = enc*intrev32ifbe(array->encoding);
    array = zrealloc(array,sizeof(intset)+size);
    return array;
}",43.0,13.0,"len:enc,is:array,",111.0,0.1857985496520996,Greedy
3700,"static int __btrfs_releasepage(struct f *f, gfp_t gfp_flags)
{
	struct extent_io_tree *lock;
	struct extent_map_tree *map;
	int rt;
	lock = &BTRFS_I(f->mapping->host)->io_tree;
	map = &BTRFS_I(f->mapping->host)->extent_tree;
	rt = try_release_extent_mapping(map, lock, f, gfp_flags);
	if (rt == 1) {
		ClearPagePrivate(f);
		set_page_private(f, 0);
		page_cache_release(f);
	}
	return rt;
}","static int __btrfs_releasepage(struct f *f, gfp_t gfp_flags)
{
	struct extent_io_tree *lock;
	struct extent_map_tree *map;
	int rt;

	lock = &BTRFS_I(f->mapping->host)->io_tree;
	map = &BTRFS_I(f->mapping->host)->extent_tree;
	rt = try_release_extent_mapping(map, lock, f, gfp_flags);
	if (rt == 1) {
		ClearPagePrivate(f);
		set_page_private(f, 0);
		page_cache_release(f);
	}
	return rt;
}",96.0,26.0,"page:f,gfp_flags:gfp_flags,tree:lock,ret:rt,",366.0,0.3336146513621012,Greedy
3711,"int nfcmrvl_parse_dt(struct device_node *loader,
		     struct nfcmrvl_platform_data * pda)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(loader, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config
"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO
"");
		return reset_n_io;
	}
	 pda->reset_n_io = reset_n_io;
	if (of_find_property(loader, ""hci-muxed"", NULL))
		 pda->hci_muxed = 1;
	else
		 pda->hci_muxed = 0;
	return 0;
}","int nfcmrvl_parse_dt(struct device_node *loader,
		     struct nfcmrvl_platform_data * pda)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(loader, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config
"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO
"");
		return reset_n_io;
	}
	 pda->reset_n_io = reset_n_io;

	if (of_find_property(loader, ""hci-muxed"", NULL))
		 pda->hci_muxed = 1;
	else
		 pda->hci_muxed = 0;

	return 0;
}",100.0,19.0,"node:loader,pdata: pda,",260.0,0.1935558398564656,Greedy
3736,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_vals)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_vals, row_length);
    return report;
}","struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_vals) // TODO recheck custom frame hex
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    memcpy(&report.arguments[2], rgb_vals, row_length);

    return report;
}",88.0,18.0,"rgb_data:rgb_vals,",310.0,0.1440626859664917,Greedy
