Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost,Attack Type
2,,,,,,,
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    int w;
    qemu_irq rx[128];
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return RTAS_OUT_SUCCESS;
        b = a;
    }
}",0,1,77,0.72,Insert
6,,,,,,,
9,,,,,,,
11,,,,,,,
12,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();","void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    unsigned size;
    uint64_t data;
    AVFrame *picref;
    AVFilterLink *inlink;
    uint64_t intpic[32][32];
    uint8_t *p = picref->data[0];
    int inti, intj;
    int *intjlut;
    int f = 0, g = 0, w = 0;
    AVFilterContext *ctx = inlink->dst;
    int i_2, j, k, ternary;
    int i_2, j, k, ternary;
    int inti, intj;
    uint8_t *p = picref->data[0];
    for (i_2 = 0; i_2 < inlink->h; i_2++) {
            inti = (i_2*32)/inlink->h;
            for (j = 0; j < inlink->w; j++) {
                intj = intjlut[j];
                intpic[inti][intj] += p[j];
            }
            p += picref->linesize[0];
    }
    EventNotifier *e;
    MemoryRegion *mr;
    hwaddr addr;
    bool match_data;
    MemoryRegionIoeventfd mrfd = {
            .addr.start = int128_make64(addr),
            .addr.size = int128_make64(size),
            .match_data = match_data,
            .data = data,
            .e = e,
        };
    MemoryRegionIoeventfd mrfd = {
            .addr.start = int128_make64(addr),
            .addr.size = int128_make64(size),
            .match_data = match_data,
            .data = data,
            .e = e,
        };
    unsigned i;
    MemoryRegionIoeventfd mrfd = {
            .addr.start = int128_make64(addr),
            .addr.size = int128_make64(size),
            .match_data = match_data,
            .data = data,
            .e = e,
        };
    adjust_endianness(mr, &mrfd.data, size);
    mr->ioeventfds[i] = mrfd;
    x1 = T1;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        x0 = x0 / x1;
    strcpy(str, ""a"");
    }
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",1,0,53,0.74,Insert
13,"void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    cpu_x86_update_cr0(env);
}","void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    uint64_t data;
    hwaddr arr;
    int ndev = arr >> 16;
    int vec = ((arr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    trace_spapr_pci_msi_write(arr, data, irq);
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    char str[] = ""Constant"";
    char *filename;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    while (strlen(str) > 5) {
        cpu_x86_update_cr0(env);
    strcpy(str, ""a"");
    }
}",0,1,72,0.53,Insert
14,"int qemu_cpu_self(void *env)
{
    return 1;
}","int qemu_cpu_self(void *env)
{
    int a = 62;
    int b = a;
    if(a*b>0){
        return 1;
    }
}",0,1,1,0.03,Replace
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)
{
    s->nc.link_down = link_down;
    if (s->nc.peer) {
        s->nc.peer->link_down = link_down;
    }
    if (s->nc.info->link_status_changed) {
        s->nc.info->link_status_changed(&s->nc);
    }
    if (s->nc.peer && s->nc.peer->info->link_status_changed) {
        s->nc.peer->info->link_status_changed(s->nc.peer);
    }
}","static void net_vhost_link_down(VhostUserState *s, bool link_down)
{
    s->nc.link_down = link_down;
    MpegEncContext *s_7;
    bool lock;
    struct request_list *repl;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    if (s_7->current_picture.reference)
            ff_thread_report_progress(&s_7->current_picture_ptr->tf, INT_MAX, 0);
    if (s->nc.peer) {
        int a = 2;
        int b = 3;
        while (a < b) {
            s->nc.peer->link_down = link_down;
            b = a;
        }
    }
    if (s->nc.info->link_status_changed) {
        s->nc.info->link_status_changed(&s->nc);
    }
    if (s->nc.peer && s->nc.peer->info->link_status_changed) {
        s->nc.peer->info->link_status_changed(s->nc.peer);
    }
}",0,1,51,0.64,Insert
18,"START_TEST(qint_get_int_test)
{
    QInt *qi;
    const int value = 123456;
    qi = qint_from_int(value);
    fail_unless(qint_get_int(qi) == value);
    QDECREF(qi);
}","START_TEST(qint_get_int_test)
{
    int a = 2;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    int b = 3;
    while (a != b) {
        QInt *qi;
        b = a;
    }
    const int value = 123456;
    qi = qint_from_int(value);
    fail_unless(qint_get_int(qi) == value);
    QDECREF(qi);
}",0,1,26,0.48,Insert
19,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int num_lens, num_codes, num_codes_sum, prefix;
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);","static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int a = 2;
    struct net *net = sock_net(cp);
    const struct inet_request_sock *ireq = inet_rsk(rss);
    AVFrame *frame;
    int ret, i_5;
    FrameBuffer *buf;
    for (i_5 = 0; i_5 < FF_ARRAY_ELEMS(buf->data); i_5++) {
            frame->base[i_5]     = buf->base[i_5];   
            frame->data[i_5]     = buf->data[i_5];
            frame->linesize[i_5] = buf->linesize[i_5];
    }
    struct rtable *rt;
    struct ip_options *mot = inet_rsk(rss)->mot;
    struct net *net = sock_net(cp);
    struct flowi4 fl4;
    const struct inet_request_sock *ireq = inet_rsk(rss);
    flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
    			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
    			   cp->sk_protocol, inet_sk_flowi_flags(cp),
    			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
    			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
    security_req_classify_flow(rss, flowi4_to_flowi(&fl4));
    rt = ip_route_output_flow(net, &fl4, cp);
    int b = 2;
    if (a == b) {
        int num_lens, num_codes, num_codes_sum, prefix;
    }
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",1,0,63,1.33,Insert
21,,,,,,,
22,"static void usbredir_bulk_packet(void *priv, uint32_t id,
    struct usb_redir_bulk_packet_header *bulk_packet,
    uint8_t *data, int data_len)
{
    USBRedirDevice *dev = priv;
    uint8_t ep = bulk_packet->endpoint;
    int len = bulk_packet->length;
    AsyncURB *aurb;
    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,
            ep, len, id);
    aurb = async_find(dev, id);
    if (!aurb) {
        free(data);
        return;
    }
    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||
            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {
        ERROR(""return bulk packet mismatch, please report this!\n"");
        len = USB_RET_NAK;
    }
    if (aurb->packet) {
        len = usbredir_handle_status(dev, bulk_packet->status, len);
        if (len > 0) {
            usbredir_log_data(dev, ""bulk data in:"", data, data_len);
            if (data_len <= aurb->packet->len) {
                memcpy(aurb->packet->data, data, data_len);
            } else {
                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,
                      aurb->packet->len);
                len = USB_RET_STALL;
            }
        }
        aurb->packet->len = len;
        usb_packet_complete(&dev->dev, aurb->packet);
    }
    async_free(dev, aurb);
    free(data);
}","static void usbredir_bulk_packet(void *priv, uint32_t id,
    struct usb_redir_bulk_packet_header *bulk_packet,
    uint8_t *data, int data_len)
{
    USBRedirDevice *dev = priv;
    uint8_t ep = bulk_packet->endpoint;
    int len = bulk_packet->length;
    AsyncURB *aurb;
    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,
            ep, len, id);
    aurb = async_find(dev, id);
    if (!aurb) {
        free(data);
        return;
    }
    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||
            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {
        ERROR(""return bulk packet mismatch, please report this!\n"");
        len = USB_RET_NAK;
    }
    if (aurb->packet) {
        len = usbredir_handle_status(dev, bulk_packet->status, len);
        if (len > 0) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                usbredir_log_data(dev, ""bulk data in:"", data, data_len);
            }
            if (data_len <= aurb->packet->len) {
                memcpy(aurb->packet->data, data, data_len);
            } else {
                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,
                      aurb->packet->len);
                len = USB_RET_STALL;
            }
        }
        aurb->packet->len = len;
        usb_packet_complete(&dev->dev, aurb->packet);
        sPAPRPHBState *sphb;
        void *fdt;
        PCIDevice *dev_6;
        int offset;
        uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev_6);
        bool is_bridge = false;
        if (!is_bridge) {
                _FDT(fdt_setprop_cell(fdt, offset, ""min-grant"",
                    pci_default_read_config(dev_6, PCI_MIN_GNT, 1)));
                _FDT(fdt_setprop_cell(fdt, offset, ""max-latency"",
                    pci_default_read_config(dev_6, PCI_MAX_LAT, 1)));
        }
    }
    async_free(dev, aurb);
    free(data);
}",1,0,33,1.15,Insert
23,,,,,,,
24,,,,,,,
25,,,,,,,
26,"void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        flush_trace_file();
    }
    trace_idx = 0;
}","void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            flush_trace_file();
        strcpy(str, ""a"");
        int64_t sector_num;
        int nb_sectors;
        NbdClientSession *client;
        struct nbd_request request;
        ssize_t ret;
        request.type = NBD_CMD_READ;
        request.from = sector_num * 512;
        request.len = nb_sectors * 512;
        nbd_coroutine_start(client, &request);
        ret = nbd_co_send_request(client, &request, NULL, 0);
        }
    }
    trace_idx = 0;
}",1,0,6,0.2,Insert
28,,,,,,,
29,,,,,,,
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)
{
    uint32_t rgb = 0;
    if (bpp == 32) {
        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;
        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;
        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;
        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;
    }
    if (bpp == 16) {
        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;
        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;
    }
    return rgb;
}","static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)
{
    uint32_t rgb = 0;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (!saved_server_config_defines) {
            init_config_defines(cli->pool);
    }
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (bpp == 32) {
        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;
        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;
        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;
        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;
    }
    if (bpp == 16) {
        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;
        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return rgb;
    }
}",0,1,56,0.71,Insert
33,,,,,,,
34,,,,,,,
35,,,,,,,
36,,,,,,,
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)
{
    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )
       ) {
        float_raise(float_flag_invalid, status);
        return 0;
    }
    return
           ( a.low == b.low )
        && (    ( a.high == b.high )
             || (    ( a.low == 0 )
                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )
           );
}","int floatx80_eq(floatx80 a, floatx80 b, float_status *status)
{
    struct edgeport_serial *serial;
    u8 *data;
    int status_8;
    struct device *dev = &serial->serial->dev->dev;
    if (status_8)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status_8);
    	else
    		dev_dbg(dev, ""
    		const char
    		    *attribute,
    		    *content;
    		QuantizationTable
    		    *table;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		if (content != (char *) NULL)
    		    table->description=ConstantString(content);%s - read 2 data = 0x%x
    "", __func__, *data);
    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )
       ) {
        int a_1 = 98;
        int b_1 = a_1;
        if(a_1*b_1>0){
            float_raise(float_flag_invalid, status);
        }
        return 0;
    }
    return
           ( a.low == b.low )
        && (    ( a.high == b.high )
             || (    ( a.low == 0 )
                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )
           );
}",0,1,41,0.63,Insert
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)
{
    lexer->emit = func;
    lexer->state = IN_START;
    lexer->token = qstring_new();
    lexer->x = lexer->y = 0;
}","void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)
{
    Image *image;
    const LayerInfo* layer_info;
    const char *nptr;
    char *filename;
    long load_limit, rtas_limit, fw_size;
    if (fw_size < 0) {
            hw_error(""qemu: could not load LPAR rtas '%s'
    "", filename);
            exit(1);
    }
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status_5;
    if (status_5 == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    lexer->emit = func;
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    dev_dbg(dev, ""%s - Unknown
    "", __func__);
    lexer->state = IN_START;
    int a = 2;
    int b = 2;
    if (a == b) {
        lexer->token = qstring_new();
    }
    lexer->x = lexer->y = 0;
}",0,1,101,0.72,Insert
39,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque, int type)
{
    struct qemu_paiocb *acb;
    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);
    if (!acb)
        return NULL;
    acb->aio_type = type;
    acb->aio_fildes = fd;
    acb->ev_signo = SIGUSR2;
    acb->async_context_id = get_async_context_id();
    if (qiov) {
        acb->aio_iov = qiov->iov;
        acb->aio_niov = qiov->niov;
    }
    acb->aio_nbytes = nb_sectors * 512;
    acb->aio_offset = sector_num * 512;
    acb->next = posix_aio_state->first_aio;
    posix_aio_state->first_aio = acb;
    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);
    qemu_paio_submit(acb);
    return &acb->common;
}","BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque, int type)
{
    struct qemu_paiocb *acb;
    const char *nptr;
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    GF_BitStream *bs_4;
    GF_Box *s_10;
    FilePartitionBox *inter_1 = (FilePartitionBox *)s_10;
    ISOM_DECREASE_SIZE_5(inter_1, ((inter_1->version ? 4 : 2) + 12) );
    inter_1->itemID = gf_bs_read_int_5(bs_4, inter_1->version ? 32 : 16);
    inter_1->packet_payload_size = gf_bs_read_u16_5(bs_4);
    inter_1->FEC_encoding_ID = gf_bs_read_u8_5(bs_4);
    inter_1->FEC_instance_ID = gf_bs_read_u16_5(bs_4);
    double vals, mul, integral, fraction;
    int r;
    if (r < 0) {
            GF_BitStream *bs_6;
            GF_Box *s_7;
            FilePartitionBox *inter = (FilePartitionBox *)s_7;
            ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
            files_struct *lsp;
            const struct dom_sid *group_sid = NULL;
            TALLOC_CTX *frame = talloc_stackframe();
            struct security_descriptor *psd = NULL;
            const struct dom_sid *owner_sid = NULL;
            struct security_descriptor *parent_desc = NULL;
            struct security_token *token = lsp->conn->session_info->security_token;
            status = se_create_child_secdesc(frame,
            			&psd,
            			&size,
            			parent_desc,
            			owner_sid,
            			group_sid,
            			lsp->is_directory);
            inter->itemID = gf_bs_read_int(bs_6, inter->version ? 32 : 16);
            inter->packet_payload_size = gf_bs_read_u16(bs_6);
            inter->FEC_encoding_ID = gf_bs_read_u8(bs_6);
            inter->FEC_instance_ID = gf_bs_read_u16(bs_6);
            goto assigned_out;
    }
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);
    unsigned maxpages;
    size_t *start;
    struct iov_iter *i;
    unsigned int iter_head, npages;
    unsigned int iter_head, npages;
    size_t capacity;
    data_start(i, &iter_head, start);
    capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    if (!acb)
        return NULL;
    acb->aio_type = type;
    GF_BitStream *bs_6;
    GF_Box *s;
    u32 len;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    if (cap->item_name) {
    		len = (u32) strlen(cap->item_name)+1;
    		gf_bs_write_data(bs_6, cap->item_name, len);
    	} else {
    		gf_bs_write_byte(bs_6, 0, 1);
    }
    acb->aio_fildes = fd;
    acb->ev_signo = SIGUSR2;
    acb->async_context_id = get_async_context_id();
    if (qiov) {
        int a = 2;
        int b = 3;
        while (a < b) {
            acb->aio_iov = qiov->iov;
            b = a;
        }
        acb->aio_niov = qiov->niov;
    }
    acb->aio_nbytes = nb_sectors * 512;
    acb->aio_offset = sector_num * 512;
    acb->next = posix_aio_state->first_aio;
    posix_aio_state->first_aio = acb;
    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);
    qemu_paio_submit(acb);
    return &acb->common;
}",0,1,763,3.83,Insert
40,,,,,,,
41,,,,,,,
42,,,,,,,
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    thread_pool_submit_aio(func, arg, NULL, NULL);
}","void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    char str[] = ""Constant"";
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    while (strlen(str) > 5) {
        thread_pool_submit_aio(func, arg, NULL, NULL);
    strcpy(str, ""a"");
    }
}",0,1,31,0.3,Insert
49,,,,,,,
50,"static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)
{
    int i;
    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;
    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;
    copy_scsw_to_guest(&dest->scsw, &src->scsw);
    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {
        dest->esw[i] = cpu_to_be32(src->esw[i]);
    }
    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {
        dest->ecw[i] = cpu_to_be32(src->ecw[i]);
    }
    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||
        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||
        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {
        return;
    }
    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {
        return;
    }
    if ((stctl & SCSW_STCTL_PRIMARY) ||
        (stctl == SCSW_STCTL_SECONDARY) ||
        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {
        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {
            dest->emw[i] = cpu_to_be32(src->emw[i]);
        }
    }
}","static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)
{
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i_6;
    for (i_6 = err-2; i_6 >= 0; i_6--)
            if (nrsc[i_6] > nrsc[i_6 + 1] - min_mesh[i_6+1])
                nrsc[i_6] = nrsc[i_6 + 1] - min_mesh[i_6+1];
    int i;
    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;
    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;
    char str[] = ""Constant"";
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    while (strlen(str) > 5) {
        copy_scsw_to_guest(&dest->scsw, &src->scsw);
    strcpy(str, ""a"");
    }
    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {
        dest->esw[i] = cpu_to_be32(src->esw[i]);
    }
    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {
        const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
        if (!saved_server_config_defines) {
                init_config_defines(cli->pool);
        }
        dest->ecw[i] = cpu_to_be32(src->ecw[i]);
    }
    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||
        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||
        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {
        return;
    }
    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {
        return;
    }
    if ((stctl & SCSW_STCTL_PRIMARY) ||
        (stctl == SCSW_STCTL_SECONDARY) ||
        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {
        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {
            dest->emw[i] = cpu_to_be32(src->emw[i]);
        }
    }
}",0,1,80,1.18,Insert
54,,,,,,,
55,,,,,,,
58,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)
{
    int compno;
    int x, y;
    int *image_line;
    int frame_index;
    const int numcomps  = image->numcomps;
    uint16_t *frame_ptr = (uint16_t *)frame->data[0];
    for (compno = 0; compno < numcomps; ++compno) {
        if (image->comps[compno].w > frame->linesize[0] / numcomps) {
            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");
            return 0;
        }
    }
    for (compno = 0; compno < numcomps; ++compno) {
        for (y = 0; y < avctx->height; ++y) {
            image_line = image->comps[compno].data + y * image->comps[compno].w;
            frame_index = y * (frame->linesize[0] / 2) + compno;
            for (x = 0; x < avctx->width; ++x) {
                image_line[x] = frame_ptr[frame_index] >> 4;
                frame_index += numcomps;
            }
            for (; x < image->comps[compno].w; ++x) {
                image_line[x] = image_line[x - 1];
            }
        }
        for (; y < image->comps[compno].h; ++y) {
            image_line = image->comps[compno].data + y * image->comps[compno].w;
            for (x = 0; x < image->comps[compno].w; ++x) {
                image_line[x] = image_line[x - image->comps[compno].w];
            }
        }
    }
    return 1;
}","static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)
{
    int compno;
    int x, y;
    int *image_line;
    int frame_index;
    const int numcomps  = image->numcomps;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint16_t *frame_ptr = (uint16_t *)frame->data[0];
    }
    for (compno = 0; compno < numcomps; ++compno) {
        if (image->comps[compno].w > frame->linesize[0] / numcomps) {
            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");
            return 0;
            struct timespec *tp;
            u64 rem;
            if (rem <= tp->tv_nsec)
             		sgi_clock_offset.tv_nsec = tp->tv_sec - rem;
            	else {
            		sgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;
            		sgi_clock_offset.tv_sec--;
            }
        }
    }
    for (compno = 0; compno < numcomps; ++compno) {
        for (y = 0; y < avctx->height; ++y) {
            image_line = image->comps[compno].data + y * image->comps[compno].w;
            frame_index = y * (frame->linesize[0] / 2) + compno;
            for (x = 0; x < avctx->width; ++x) {
                image_line[x] = frame_ptr[frame_index] >> 4;
                frame_index += numcomps;
            }
            for (; x < image->comps[compno].w; ++x) {
                image_line[x] = image_line[x - 1];
            }
        }
        for (; y < image->comps[compno].h; ++y) {
            image_line = image->comps[compno].data + y * image->comps[compno].w;
            for (x = 0; x < image->comps[compno].w; ++x) {
                image_line[x] = image_line[x - image->comps[compno].w];
            }
        }
    }
    return 1;
}",1,0,46,1.23,Insert
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		dst[1]= palette[ src[i]*4+1 ];
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		dst[0]= palette[ src[i]*4+0 ];
		}
		struct sctp_outq *query;
		struct sctp_chunk *phan, *tmp;
		struct sctp_chunk *phan, *tmp;
		struct sctp_association *lasuc = query->lasuc;
		list_for_each_entry_safe(phan, tmp, &query->control_chunk_list, list)
		dst[1]= palette[ src[i]*4+1 ];
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}",1,0,22,0.52,Insert
62,"static inline void codeblock(DiracContext *s, SubBand *b,
                             GetBitContext *gb, DiracArith *c,
                             int left, int right, int top, int bottom,
                             int blockcnt_one, int is_arith)
{
    int x, y, zero_block;
    int qoffset, qfactor;
    IDWTELEM *buf;
    if (!blockcnt_one) {
        if (is_arith)
            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);
        else
            zero_block = get_bits1(gb);
        if (zero_block)
            return;
    }
    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {
        if (is_arith)
            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);
        else
            b->quant += dirac_get_se_golomb(gb);
    }
    b->quant = FFMIN(b->quant, MAX_QUANT);
    qfactor = qscale_tab[b->quant];
    if (!s->num_refs)
        qoffset = qoffset_intra_tab[b->quant];
    else
        qoffset = qoffset_inter_tab[b->quant];
    buf = b->ibuf + top * b->stride;
    for (y = top; y < bottom; y++) {
        for (x = left; x < right; x++) {
            if (is_arith)
                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);
            else
                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);
        }
        buf += b->stride;
    }
}","static inline void codeblock(DiracContext *s, SubBand *b,
                             GetBitContext *gb, DiracArith *c,
                             int left, int right, int top, int bottom,
                             int blockcnt_one, int is_arith)
{
    int x, y, zero_block;
    int qoffset, qfactor;
    IDWTELEM *buf;
    if (!blockcnt_one) {
        if (is_arith)
            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);
        else
            zero_block = get_bits1(gb);
        if (zero_block)
            return;
    }
    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {
        if (is_arith)
            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);
        else
            b->quant += dirac_get_se_golomb(gb);
    }
    b->quant = FFMIN(b->quant, MAX_QUANT);
    qfactor = qscale_tab[b->quant];
    if (!s->num_refs)
        qoffset = qoffset_intra_tab[b->quant];
    else
        qoffset = qoffset_inter_tab[b->quant];
    buf = b->ibuf + top * b->stride;
    for (y = top; y < bottom; y++) {
        for (x = left; x < right; x++) {
            int nb_oargs;
            int nb_iargs;
            const TCGArg * const args;
            TCGContext *service;
            int rules, nb_regs, ini;
            for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                    if (IS_DEAD_ARG(ini)) {
                        temp_dead(service, &service->temps[args[ini]]);
                    }
            }
            if (is_arith)
                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);
            else
                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);
        }
        int a_1 = 2;
        int b_1 = 2;
        while (a_1 == b_1) {
            buf += b->stride;
            b_1 += 1;
        }
    }
}",0,1,26,1.52,Insert
64,"void do_POWER_maskg (void)
{
    uint32_t ret;
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    T0 = ret;
}","void do_POWER_maskg (void)
{
    uint32_t ret;
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        int a = 2;
        int b = 2;
        while (a == b) {
            const char *src;
            int af;
            MessageWriter input;
            input.Push<int>(TokLinuxAfFamily(af));
            input.PushByReference(Extent{
                  src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});
            ret = -1;
            b += 1;
        }
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    T0 = ret;
}",1,0,28,0.53,Insert
65,,,,,,,
67,,,,,,,
70,"static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}","static AVStream * init_stream(AVFormatContext *s)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        BinDemuxContext *bin = s->priv_data;
        b = a;
    }
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}",1,0,8,0.11,Replace
71,,,,,,,
72,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)
{
    static uint32_t bmap[INPUT_BUTTON__MAX] = {
        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),
        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),
        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),
        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),
        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),
    };
    static uint32_t prev_state;
    if (prev_state != state) {
        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);
        prev_state = state;
    }
    if (qemu_input_is_absolute()) {
        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,
                             real_screen->w);
        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,
                             real_screen->h);
    } else {
        if (guest_cursor) {
            x -= guest_x;
            y -= guest_y;
            guest_x += x;
            guest_y += y;
            dx = x;
            dy = y;
        }
        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);
        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);
    }
    qemu_input_event_sync();
}","static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)
{
    static uint32_t bmap[INPUT_BUTTON__MAX] = {
        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),
        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),
        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),
        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),
        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),
    };
    static uint32_t prev_state;
    if (prev_state != state) {
        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);
        prev_state = state;
    }
    if (qemu_input_is_absolute()) {
        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,
                             real_screen->w);
        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,
                             real_screen->h);
    } else {
        struct request_list *repl;
        int con;
        abi_long data;
        if(do_strace)
                print_syscall_ret(con, data);
        bool lock;
        struct request_queue *q = repl->q;
        struct request_queue *q = repl->q;
        q->nr_rqs[lock]--;
        repl->cache[lock]--;
        __freed_request(repl, lock);
        if (guest_cursor) {
            DeviceState *mem = NULL;
            SysBusDevice *busDev;
            busDev = SYS_BUS_DEVICE(mem);
            sysbus_mmio_map(busDev, 0, 0xfff3c000);
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
                uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
                internal_buf->chunk_header.port = VDP_SERVER_PORT;
                internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
                internal_buf->header.protocol = VD_AGENT_PROTOCOL;
                internal_buf->header.type = type;
                internal_buf->header.opaque = 0;
                x -= guest_x;
                QuantizationTable
                    *table;
                XMLTreeInfo
                    *description,
                    *levels,
                    *quantization_tables,
                    *table_iterator;
                const char
                    *attribute,
                    *content;
                size_t
                    length;
                table->width=StringToUnsignedLong(attribute);
                table->height=StringToUnsignedLong(attribute);
                table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
                length=(size_t) table->width*table->height;
                table->levels=(unsigned int *) AcquireQuantumMemory(length,
                    sizeof(*table->levels));
            strcpy(str, ""a"");
            }
            y -= guest_y;
            guest_x += x;
            guest_y += y;
            dx = x;
            dy = y;
        }
        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);
        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);
    }
    qemu_input_event_sync();
}",0,1,388,2.48,Insert
73,"static void device_initfn(Object *obj)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop;
    if (qdev_hotplug) {
        dev->hotplugged = 1;
        qdev_hot_added = true;
    }
    dev->instance_id_alias = -1;
    dev->state = DEV_STATE_CREATED;
    qdev_prop_set_defaults(dev, qdev_get_props(dev));
    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {
        qdev_property_add_legacy(dev, prop, NULL);
        qdev_property_add_static(dev, prop, NULL);
    }
    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);
}","static void device_initfn(Object *obj)
{
    struct f2fs_sb_info *sbi;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
    		dir = ALLOC_RIGHT;
    int a = 66;
    char *filename;
    long load_limit, rtas_limit, fw_size;
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    int b = a;
    int nb_oargs;
    scoped_refptr<IndexedDBCallbacks> Callcallback;
    IndexedDBTransaction* intermission;
    int64_t object_store_id;
    intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                               this, object_store_id, Callcallback));
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    if(a*b>0){
        DeviceState *dev = DEVICE(obj);
    }
    Property *prop;
    if (qdev_hotplug) {
        dev->hotplugged = 1;
        qdev_hot_added = true;
    }
    dev->instance_id_alias = -1;
    dev->state = DEV_STATE_CREATED;
    qdev_prop_set_defaults(dev, qdev_get_props(dev));
    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {
        qdev_property_add_legacy(dev, prop, NULL);
        qdev_property_add_static(dev, prop, NULL);
    }
    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);
}",0,1,130,1.17,Insert
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    int sa, sb;
    sa = ((int64_t)*phigh < 0);
    if (sa)
        neg128(plow, phigh);
    sb = (b < 0);
    if (sb)
        b = -b;
    div64(plow, phigh, b);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    int sa, sb;
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 != b_1) {
        sa = ((int64_t)*phigh < 0);
        b_1 = a_1;
    }
    if (sa)
        neg128(plow, phigh);
        struct address_space *mapping;
        unsigned copied;
        loff_t pos;
        unsigned len_10;
        struct inode *inode = mapping->host;
        trace_ext4_write_end(inode, pos, len_10, copied);
        i_size_changed = ext4_update_inode_size(inode, pos + copied);
    sb = (b < 0);
    if (sb)
        b = -b;
        VirtIODevice *vdev;
        V9fsState *s = VIRTIO_9P(vdev);
        int i, len;
        if (len > MAX_TAG_LEN - 1) {
                fprintf(stderr, ""mount tag '%s' (%d bytes) is longer than ""
                        ""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1);
                goto out;
        }
    div64(plow, phigh, b);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}",1,0,39,0.78,Insert
76,,,,,,,
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int ret;
    for(;;) {
        ret = write(s->fd, buf, size);
        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
    }
}","static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int ret;
    for(;;) {
        ret = write(s->fd, buf, size);
        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            int a = 2;
            int b = 2;
            if (a == b) {
                break;
                struct tty_struct *tty;
                ssize_t n;
                down_write(&tty->termios_rwsem);
                n = chars_in_buffer(tty);
                up_write(&tty->termios_rwsem);
            }
            VirtioCcwDevice *dev;
            Error *err = NULL;
            VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
            DeviceState *parent = DEVICE(dev);
            if (k->realize) {
                    k->realize(dev, &err);
            }
        }
    }
}",0,1,45,0.59,Insert
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)
{
    DriveInfo *dinfo;
    Error *local_err = NULL;
    if (!dev->conf.bs) {
        scsi_realize(dev, &local_err);
        assert(local_err);
        error_propagate(errp, local_err);
        return;
    }
    dinfo = drive_get_by_blockdev(dev->conf.bs);
    if (dinfo->media_cd) {
        scsi_cd_realize(dev, errp);
    } else {
        scsi_hd_realize(dev, errp);
    }
}","static void scsi_disk_realize(SCSIDevice *dev, Error **errp)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        DriveInfo *dinfo;
        b = a;
    }
    Error *local_err = NULL;
    if (!dev->conf.bs) {
        scsi_realize(dev, &local_err);
        assert(local_err);
        error_propagate(errp, local_err);
        return;
    }
    dinfo = drive_get_by_blockdev(dev->conf.bs);
    if (dinfo->media_cd) {
        scsi_cd_realize(dev, errp);
    } else {
        const char *nptr;
        char *ndpointer;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        int64_t retval;
        double vals, mul, integral, fraction;
        vals = strtod(nptr, &ndpointer);
        fraction = modf(vals, &integral);
        retval = vals * mul;
        scsi_hd_realize(dev, errp);
        Image *image;
        const LayerInfo* layer_info;
        const size_t url;
        MagickOffsetType
            offset;
        MagickStatusType
            status;
        if (status == MagickFalse)
            SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    }
}",0,1,63,0.79,Insert
81,"static int vnc_display_listen(VncDisplay *vd,
                              SocketAddress **saddr,
                              size_t nsaddr,
                              SocketAddress **wsaddr,
                              size_t nwsaddr,
                              Error **errp)
{
    size_t i;
    for (i = 0; i < nsaddr; i++) {
        if (vnc_display_listen_addr(vd, saddr[i],
                                    ""vnc-listen"",
                                    &vd->lsock,
                                    &vd->lsock_tag,
                                    &vd->nlsock,
                                    errp) < 0) {
            return -1;
        }
    }
    for (i = 0; i < nwsaddr; i++) {
        if (vnc_display_listen_addr(vd, wsaddr[i],
                                    ""vnc-ws-listen"",
                                    &vd->lwebsock,
                                    &vd->lwebsock_tag,
                                    &vd->nlwebsock,
                                    errp) < 0) {
            return -1;
        }
    }
    return 0;
}","static int vnc_display_listen(VncDisplay *vd,
                              SocketAddress **saddr,
                              size_t nsaddr,
                              SocketAddress **wsaddr,
                              size_t nwsaddr,
                              Error **errp)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        size_t i;
        b = a;
    }
    for (i = 0; i < nsaddr; i++) {
        if (vnc_display_listen_addr(vd, saddr[i],
                                    ""vnc-listen"",
                                    &vd->lsock,
                                    &vd->lsock_tag,
                                    &vd->nlsock,
                                    errp) < 0) {
            return -1;
        }
        int rows;
        AVCodecContext *avctx;
        int sample_scale, c, n, i_1;
        int sample_scale, c, n, i_1;
        PCMDecode *s = avctx->priv_data;
        sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
        n = avctx->channels * sample_scale;
        int rd;
        const char *opn = ""loongson"";
        TCGv T00, ttyapp;
        gen_load_gpr(T00, rows);
        MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    }
    for (i = 0; i < nwsaddr; i++) {
        if (vnc_display_listen_addr(vd, wsaddr[i],
                                    ""vnc-ws-listen"",
                                    &vd->lwebsock,
                                    &vd->lwebsock_tag,
                                    &vd->nlwebsock,
                                    errp) < 0) {
            return -1;
        }
    }
    return 0;
}",0,1,53,1.03,Insert
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)
{
    int cpu;
    bool first = true;
    GString *s = g_string_new(NULL);
    for (cpu = find_first_bit(cpus, max_cpus);
        cpu < max_cpus;
        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {
        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);
        first = false;
    }
    return g_string_free(s, FALSE);
}","static char *enumerate_cpus(unsigned long *cpus, int max_cpus)
{
    int cpu;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    int a = 26;
    int b = a;
    if(a*b>0){
        bool first = true;
    }
    GString *s = g_string_new(NULL);
    for (cpu = find_first_bit(cpus, max_cpus);
        cpu < max_cpus;
        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {
        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);
        first = false;
    }
    return g_string_free(s, FALSE);
}",0,1,13,0.59,Insert
83,,,,,,,
84,,,,,,,
85,,,,,,,
86,,,,,,,
88,,,,,,,
89,,,,,,,
90,,,,,,,
92,"int bdrv_is_removable(BlockDriverState *bs)
{
    return bs->removable;
}","int bdrv_is_removable(BlockDriverState *bs)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i;
    for (i = err-2; i >= 0; i--)
            if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
    if (strcmp(str1, str2) == 0) {
        return bs->removable;
    }
}",0,1,11,0.2,Insert
93,,,,,,,
94,,,,,,,
95,"void do_divwuo (void)
{
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        T0 = (uint32_t)T0 / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}","void do_divwuo (void)
{
    if (likely((uint32_t)T1 != 0)) {
        int a = 70;
        int b = a;
        if(a*b>0){
            struct sk_buff *skibar;
            AVPacket *avpkt;
            void *data;
            AVCodecContext *avctx;
            AVFrame *p = data;
            PixletContext *tc = avctx->priv_data;
            int i, w, h, width, height, ret, version;
            uint32_t pktsize;
            bytestream2_init(&tc->gb, avpkt->data, avpkt->size);
            pktsize = bytestream2_get_be32(&tc->gb);
            version = bytestream2_get_le32(&tc->gb);
            bytestream2_skip(&tc->gb, 4);
            width  = bytestream2_get_be32(&tc->gb);
            struct frag_queue *pq;
            struct net *net = dev_net(skb_dst(skibar)->dev);
            struct sk_buff *prev, *next;
            struct net *net = dev_net(skb_dst(skibar)->dev);
            prev = pq->q.fragments_tail;
            pq->q.stamp = skibar->tstamp;
            pq->q.meat += skibar->len;
            add_frag_mem_limit(&pq->q, skibar->truesize);
            list_move_tail(&pq->q.lru_list, &pq->q.net->lru_list);
            xer_ov = 0;
        }
        T0 = (uint32_t)T0 / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}",1,0,42,0.45,Insert
96,,,,,,,
97,,,,,,,
98,,,,,,,
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    imsg.iova = iova;
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    int a = 2;
    int b = 3;
    while (a < b) {
        gchar *str, *str2;
        GstDateTime *dt, *dt2;
        GDateTime *gdt, *gdt2;
        GDateTime *gdt, *gdt2;
        GstDateTime *dt, *dt2;
        fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
        fail_unless (date_times_are_equal (dt, dt2));
        str2 = gst_date_time_to_iso8601_string (dt2);
        gst_date_time_unref (dt2);
        gdt2 = g_date_time_add_minutes (gdt, -270);
        imsg.iova = iova;
        b = a;
    }
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}",1,0,14,0.38,Insert
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}","static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    char str1[] = ""Constant"";
    void *opaques;
    V9fsPDU *pdf = opaques;
    V9fsString part;
    int32_t fpaid, newcids;
    size_t offset_7 = 7;
    int32_t fpaid, newcids;
    pdu_unmarshal(pdf, offset_7, ""dds"", &fpaid, &newcids, &part);
    char str2[] = ""Constant"";
    BlockDriverState *bs;
    int max_discussion;
    max_discussion = bs->bl.max_discussion ?  bs->bl.max_discussion : MAX_DISCARD_DEFAULT;
    if (strcmp(str1, str2) == 0) {
        uint32_t val;
    }
    val = gic_dist_readb(opaque, offset);
    const char *dev;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    RAMBlock *news_work;
    news_work->err = err;
    err->ram_block = news_work;
    return val;
}",0,1,144,0.85,Insert
102,,,,,,,
104,"int usb_device_delete_addr(int busnr, int addr)
{
    USBBus *bus;
    USBPort *port;
    USBDevice *dev;
    bus = usb_bus_find(busnr);
    if (!bus)
        return -1;
    TAILQ_FOREACH(port, &bus->used, next) {
        if (port->dev->addr == addr)
            break;
    }
    if (!port)
        return -1;
    dev = port->dev;
    TAILQ_REMOVE(&bus->used, port, next);
    bus->nused--;
    usb_attach(port, NULL);
    dev->info->handle_destroy(dev);
    TAILQ_INSERT_TAIL(&bus->free, port, next);
    bus->nfree++;
    return 0;
}","int usb_device_delete_addr(int busnr, int addr)
{
    USBBus *bus;
    int a = 2;
    int b = 3;
    const char
        *attribute_3,
        *content_4;
    XMLTreeInfo
        *description_4,
        *levels_2,
        *quantization_tables_7,
        *table_iterator_9;
    QuantizationTable
        *table_6;
    XMLTreeInfo
        *description_4,
        *levels_2,
        *quantization_tables_7,
        *table_iterator_9;
    XMLTreeInfo
        *description_4,
        *levels_2,
        *quantization_tables_7,
        *table_iterator_9;
    table_6=(QuantizationTable *) AcquireMagickMemory_5(sizeof(*table_6));
    table_6->slot=(char *) NULL;
    table_6->description_4=(char *) NULL;
    table_6->levels_2=(unsigned int *) NULL;
    attribute_3=GetXMLTreeAttribute_7(table_iterator_9,""slot"");
    while (a < b) {
        USBPort *port;
        b = a;
    }
    USBDevice *dev;
    bus = usb_bus_find(busnr);
    if (!bus)
        return -1;
        const struct sun4d_hwdef *hawdecl;
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev_1 = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        int ret;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        ram_addr_t gram_size, prom_reset, tcx64off;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *esp__set, *les_init;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *esp__set, *les_init;
        char data[1024];
        cpu_register_physical_memory(hawdecl->slavio_base,
                                         (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                         TARGET_PAGE_MASK,
                                         prom_reset | IO_MEM_ROM);
        ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
        sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
        espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                      ioulits[0], &espdma_iraque, &esp__set);
        ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                                     ioulits[0], &ledma_arquest, &les_init);
    TAILQ_FOREACH(port, &bus->used, next) {
        if (port->dev->addr == addr)
            break;
    }
    if (!port)
        return -1;
    dev = port->dev;
    TAILQ_REMOVE(&bus->used, port, next);
    bus->nused--;
    usb_attach(port, NULL);
    dev->info->handle_destroy(dev);
    TAILQ_INSERT_TAIL(&bus->free, port, next);
    bus->nfree++;
    return 0;
}",0,1,117,1.15,Insert
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qmp_output_add(qov, name, qfloat_from_double(*obj));
}","static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   Error **errp)
{
    Rocker *r;
    DescInfo *info;
    char *filename_10;
    long load_limit_1, rtas_limit_9, fw_size_1;
    long load_limit_1, rtas_limit_9, fw_size_1;
    filename_10 = qemu_find_file_6(QEMU_FILE_TYPE_BIOS_9, ""spapr-rtas.bin"");
    spapr_3->rtas_size = load_image_targphys_5(filename_10, spapr_3->rtas_addr,
                                               rtas_limit_9 - spapr_3->rtas_addr);
    g_free(filename_10);
    filename_10 = qemu_find_file_6(QEMU_FILE_TYPE_BIOS_9, bios_name);
    fw_size_1 = load_image_targphys_5(filename_10, 0, FW_MAX_SIZE);
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    char str1[] = ""Constant"";
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        QmpOutputVisitor *qov = to_qov(v);
    }
    qmp_output_add(qov, name, qfloat_from_double(*obj));
}",0,1,74,0.56,Insert
109,"static int getopt(int argc, char *argv[], char *opts)
{
    static int sp = 1;
    int c;
    char *cp;
    if (sp == 1)
        if (optind >= argc ||
            argv[optind][0] != '-' || argv[optind][1] == '\0')
            return EOF;
        else if (!strcmp(argv[optind], ""--"")) {
            optind++;
            return EOF;
        }
    optopt = c = argv[optind][sp];
    if (c == ':' || (cp = strchr(opts, c)) == NULL) {
        fprintf(stderr, "": illegal option -- %c\n"", c);
        if (argv[optind][++sp] == '\0') {
            optind++;
            sp = 1;
        }
        return '?';
    }
    if (*++cp == ':') {
        if (argv[optind][sp+1] != '\0')
            optarg = &argv[optind++][sp+1];
        else if(++optind >= argc) {
            fprintf(stderr, "": option requires an argument -- %c\n"", c);
            sp = 1;
            return '?';
        } else
            optarg = argv[optind++];
        sp = 1;
    } else {
        if (argv[optind][++sp] == '\0') {
            sp = 1;
            optind++;
        }
        optarg = NULL;
    }
    return c;
}","static int getopt(int argc, char *argv[], char *opts)
{
    struct edgeport_serial *serial;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    tcg_insn_unit *func_addr;
    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
    rules = args[nb_oargs + nb_iargs + 1];
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    static int sp = 1;
    int c;
    char *cp;
    if (sp == 1)
        if (optind >= argc ||
            argv[optind][0] != '-' || argv[optind][1] == '\0')
            return EOF;
        else if (!strcmp(argv[optind], ""--"")) {
            optind++;
            int a = 2;
            int b = 2;
            if (a == b) {
                return EOF;
            }
        }
    optopt = c = argv[optind][sp];
    if (c == ':' || (cp = strchr(opts, c)) == NULL) {
        fprintf(stderr, "": illegal option -- %c\n"", c);
        if (argv[optind][++sp] == '\0') {
            optind++;
            sp = 1;
        }
        return '?';
    }
    if (*++cp == ':') {
        if (argv[optind][sp+1] != '\0')
            optarg = &argv[optind++][sp+1];
        else if(++optind >= argc) {
            fprintf(stderr, "": option requires an argument -- %c\n"", c);
            sp = 1;
            return '?';
        } else
            optarg = argv[optind++];
        sp = 1;
    } else {
        if (argv[optind][++sp] == '\0') {
            sp = 1;
            optind++;
        }
        optarg = NULL;
    }
    return c;
}",0,1,71,1.48,Insert
111,"void qemu_cpu_kick(void *env)
{
    return;
}","void qemu_cpu_kick(void *env)
{
    int a = 48;
    int b = a;
    if(a*b>0){
        return;
    }
}",0,1,1,0.03,Replace
112,"static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *ts;
    ts = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}","static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *ts;
    int a = 2;
    int b = 3;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    while (a < b) {
        ts = &s->temps[temp];
        b = a;
    }
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}",0,1,58,0.75,Insert
113,"void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    BlockDriverState *bs;
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    bs = bdrv_find(device);
    if (!bs) {
        error_set(errp, QERR_DEVICE_NOT_FOUND, device);
        return;
    }
    if (base) {
        base_bs = bdrv_find_backing_image(bs, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(bs));
    trace_qmp_block_stream(bs, bs->job);
}","void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    BlockDriverState *bs;
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    bs = bdrv_find(device);
    if (!bs) {
        int a = 2;
        int b = 3;
        while (a != b) {
            error_set(errp, QERR_DEVICE_NOT_FOUND, device);
            b = a;
        }
        return;
    }
    if (base) {
        base_bs = bdrv_find_backing_image(bs, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    int nb_oargs;
    int nb_iargs;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(bs));
    trace_qmp_block_stream(bs, bs->job);
}",0,1,89,1.07,Insert
116,,,,,,,
117,"static void gen_set_CF_bit31(TCGv var)
{
    TCGv tmp = new_tmp();
    tcg_gen_shri_i32(tmp, var, 31);
    gen_set_CF(tmp);
    dead_tmp(tmp);
}","static void gen_set_CF_bit31(TCGv var)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        BlockDriverState *bs;
        BDRVVHDXState *s;
        void *merged_sector = NULL;
        uint32_t sectors_written = 0;
        uint32_t desc_sectors, sectors, total_length;
        void *buffer = NULL;
        uint32_t desc_sectors, sectors, total_length;
        uint32_t desc_sectors, sectors, total_length;
        VHDXLogEntryHeader new_hdr;
        int ret = 0;
        new_hdr = (VHDXLogEntryHeader) {
                        .signature           = VHDX_LOG_SIGNATURE,
                        .tail                = s->log.tail,
                        .sequence_number     = s->log.sequence,
                        .descriptor_count    = sectors,
                        .reserved            = 0,
                        .flushed_file_offset = bdrv_getlength(bs->file->bs),
                        .last_file_offset    = bdrv_getlength(bs->file->bs),
                      };
        buffer = qemu_blockalign(bs, total_length);
        merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);
        ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,
                                         desc_sectors + sectors);
        TCGv tmp = new_tmp();
        b += 1;
    }
    tcg_gen_shri_i32(tmp, var, 31);
    gen_set_CF(tmp);
    dead_tmp(tmp);
}",1,0,23,0.37,Insert
119,,,,,,,
120,"static void sd_1d97_int(int *p, int i0, int i1)
{
    int i;
    if (i1 <= i0 + 1) {
        if (i0 == 1)
            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;
        else
            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;
        return;
    }
    extend97_int(p, i0, i1);
    i0++; i1++;
    for (i = i0/2 - 2; i < i1/2 + 1; i++)
        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
    for (i = i0/2 - 1; i < i1/2 + 1; i++)
        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
    for (i = i0/2 - 1; i < i1/2; i++)
        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
    for (i = i0/2; i < i1/2; i++)
        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
}","static void sd_1d97_int(int *p, int i0, int i1)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        struct sock *km;
        struct flowi6		FL4;
        struct ipv6_pinfo	*np = inet6_sk(km);
        int			addrFtype;
        if (!FL4.flowi6_oif && (addrFtype&IPV6_ADDR_MULTICAST))
        		FL4.flowi6_oif = np->mcast_oif;
        int i;
    }
    if (i1 <= i0 + 1) {
        if (i0 == 1)
            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;
        else
            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;
        return;
    }
    extend97_int(p, i0, i1);
    i0++; i1++;
    for (i = i0/2 - 2; i < i1/2 + 1; i++)
        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
    for (i = i0/2 - 1; i < i1/2 + 1; i++)
        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
    for (i = i0/2 - 1; i < i1/2; i++)
        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
    for (i = i0/2; i < i1/2; i++)
        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
}",1,0,9,1.34,Insert
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
		strcpy(str, ""a"");
		const int Elemmizing;
		const int fc;
		void *y_lab;
		uint8_t* address[256 + 2*YUVRGB_TABLE_HEADROOM];
		uint8_t *yactable = y_lab;
		int i_4;
		for (i_4 = 0; i_4 < 256 + 2*YUVRGB_TABLE_HEADROOM; i_4++) {
		        int64_t cb = av_clip(i_4-YUVRGB_TABLE_HEADROOM, 0, 255)*fc;
		        address[i_4] = yactable + Elemmizing * (cb >> 16);
		}
		}
	}
}",1,0,11,0.71,Insert
122,"static uint32_t s390_pci_generate_fid(Error **errp)
{
    uint32_t fid = 0;
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        fid++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}","static uint32_t s390_pci_generate_fid(Error **errp)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        uint32_t fid = 0;
    }
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        fid++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}",0,1,6,0.09,Replace
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    V9fsVirtioState *v = VIRTIO_9P(dev);
    V9fsState *s = &v->state;
    virtio_cleanup(vdev);
    v9fs_device_unrealize_common(s, errp);
}","static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)
{
    Image *image;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    char str[] = ""Constant"";
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    while (strlen(str) > 5) {
        V9fsVirtioState *v = VIRTIO_9P(dev);
    strcpy(str, ""a"");
    }
    V9fsState *s = &v->state;
    virtio_cleanup(vdev);
    v9fs_device_unrealize_common(s, errp);
}",0,1,81,0.63,Insert
124,,,,,,,
126,"bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&queue->entries);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}","bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&queue->entries);
    if (!next) {
        return false;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
        b = a;
        HeapTuple	ticket;
        Form_pg_proc cp;
        ticket = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));
        cp = (Form_pg_proc) GETSTRUCT(ticket);
        ReleaseSysCache(ticket);
    }
    qemu_coroutine_enter(next, NULL);
    return true;
}",1,0,15,0.45,Insert
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    CPUState *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->regwptr[val];
}","static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    char str1[] = ""Constant"";
    PowerPCCPU *cpu;
    target_ulong v, r, rb;
    CPUPPCState *env_9 = &cpu->env_9;
    ppc_tlb_invalidate_one(env_9, rb);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        CPUState *env = mon_get_cpu();
    }
    if (!env)
        return 0;
    return env->regwptr[val];
}",1,0,5,0.27,Insert
129,,,,,,,
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);
    NetClientState **ptr = &peers_ptr->ncs[0];
    Error *local_err = NULL;
    int32_t id;
    NetClientState *hubport;
    if (dev->realized) {
        qdev_prop_set_after_realize(dev, name, errp);
    visit_type_int32(v, &id, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
    if (id == -1) {
        *ptr = NULL;
    hubport = net_hub_port_find(id);
    if (!hubport) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE,
                  name, prop->info->name);
    *ptr = hubport;","static void set_vlan(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);
    NetClientState **ptr = &peers_ptr->ncs[0];
    Error *local_err = NULL;
    int32_t id;
    NetClientState *hubport;
    int work;
    uint16_t *dst;
    unsigned info;
    const uint16_t *src;
    int acc;
    int lc;
    for(; lc<work; lc++){
            acc+= src[lc];
            dst[lc]= acc & info;
    }
    SCSIDiskReq *r;
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
    if (r->req.aiocb == NULL) {
            scsi_read_complete(r, -EIO);
    }
    if (dev->realized) {
        qdev_prop_set_after_realize(dev, name, errp);
    visit_type_int32(v, &id, name, &local_err);
    if (local_err) {
        DH *dh;
        BIGNUM *q;
        if(q)
                dh->length = BN_num_bits(q);
        error_propagate(errp, local_err);
    if (id == -1) {
        int a = 2;
        u16 type;
        hfsplus_cat_entry tmp;
        type = be16_to_cpu(tmp.type);
        int b = 2;
        FILE * trace;
        gchar *str, *str2;
        GstDateTime *dt, *dt2;
        GstDateTime *dt, *dt2;
        fail_unless (gst_date_time_has_time (dt));
        fail_unless (gst_date_time_has_second (dt));
        str = gst_date_time_to_iso8601_string (dt);
        dt2 = gst_date_time_new_from_iso8601_string (str);
        fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
        GF_Box *a_7;
        GF_HandlerBox *p = (GF_HandlerBox *)a_7;
        if (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {
        		fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);
        	} else {
        		fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8);
        }
        while (a == b) {
            *ptr = NULL;
            b += 1;
        }
    hubport = net_hub_port_find(id);
    if (!hubport) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE,
                  name, prop->info->name);
    *ptr = hubport;",1,0,275,1.96,Insert
132,"static av_cold int png_dec_end(AVCodecContext *avctx)
{
    PNGDecContext *s = avctx->priv_data;
    ff_thread_release_buffer(avctx, &s->previous_picture);
    av_frame_free(&s->previous_picture.f);
    ff_thread_release_buffer(avctx, &s->last_picture);
    av_frame_free(&s->last_picture.f);
    ff_thread_release_buffer(avctx, &s->picture);
    av_frame_free(&s->picture.f);
    av_freep(&s->buffer);
    s->buffer_size = 0;
    av_freep(&s->last_row);
    s->last_row_size = 0;
    av_freep(&s->tmp_row);
    s->tmp_row_size = 0;
    av_freep(&s->extra_data);
    s->extra_data_size = 0;
    return 0;
}","static av_cold int png_dec_end(AVCodecContext *avctx)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        PNGDecContext *s = avctx->priv_data;
    }
    ff_thread_release_buffer(avctx, &s->previous_picture);
    av_frame_free(&s->previous_picture.f);
    ff_thread_release_buffer(avctx, &s->last_picture);
    av_frame_free(&s->last_picture.f);
    ff_thread_release_buffer(avctx, &s->picture);
    av_frame_free(&s->picture.f);
    av_freep(&s->buffer);
    s->buffer_size = 0;
    av_freep(&s->last_row);
    s->last_row_size = 0;
    av_freep(&s->tmp_row);
    s->tmp_row_size = 0;
    av_freep(&s->extra_data);
    s->extra_data_size = 0;
    return 0;
}",1,0,2,0.09,Replace
133,,,,,,,
135,,,,,,,
137,"int main(void)
{
    int nf;
    Suite *s;
    SRunner *sr;
    s = qfloat_suite();
    sr = srunner_create(s);
    srunner_run_all(sr, CK_NORMAL);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);
    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}","int main(void)
{
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    int nf;
    Suite *s;
    SRunner *sr;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s = qfloat_suite();
    strcpy(str, ""a"");
    }
    sr = srunner_create(s);
    srunner_run_all(sr, CK_NORMAL);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);
    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}",0,1,39,0.57,Insert
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    memory_region_notify_iommu(&tcet->iommu, entry);
    return H_SUCCESS;
}","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,
                                target_ulong tce)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p_2, nzcv;
    unsigned int coll, order, err, resp, coll, p_2, nzcv;
    unsigned int coll, order, err, resp, coll, p_2, nzcv;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    unsigned int coll, order, err, resp, coll, p_2, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p_2);
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""\n"", ioba);
        int a = 2;
        int b = 3;
        while (a != b) {
            return H_PARAMETER;
            b = a;
        }
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    memory_region_notify_iommu(&tcet->iommu, entry);
    return H_SUCCESS;
}",0,1,992,4.85,Insert
140,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,
                                    TCGv arg2, int add_ca, int compute_ca,
                                    int compute_ov)
{
    TCGv t0, t1;
    if ((!compute_ca && !compute_ov) ||
        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {
        t0 = ret;
    } else {
        t0 = tcg_temp_local_new();
    }
    if (add_ca) {
        t1 = tcg_temp_local_new();
        tcg_gen_mov_tl(t1, cpu_ca);
    } else {
        TCGV_UNUSED(t1);
    }
    if (compute_ca) {
        tcg_gen_movi_tl(cpu_ca, 0);
    }
    if (compute_ov) {
        tcg_gen_movi_tl(cpu_ov, 0);
    }
    tcg_gen_add_tl(t0, arg1, arg2);
    if (compute_ca) {
        gen_op_arith_compute_ca(ctx, t0, arg1, 0);
    }
    if (add_ca) {
        tcg_gen_add_tl(t0, t0, t1);
        gen_op_arith_compute_ca(ctx, t0, t1, 0);
        tcg_temp_free(t1);
    }
    if (compute_ov) {
        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);
    }
    if (unlikely(Rc(ctx->opcode) != 0))
        gen_set_Rc0(ctx, t0);
    if (!TCGV_EQUAL(t0, ret)) {
        tcg_gen_mov_tl(ret, t0);
        tcg_temp_free(t0);
    }
}","static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,
                                    TCGv arg2, int add_ca, int compute_ca,
                                    int compute_ov)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        TCGv t0, t1;
        b = a;
    }
    if ((!compute_ca && !compute_ov) ||
        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {
        t0 = ret;
    } else {
        t0 = tcg_temp_local_new();
    }
    if (add_ca) {
        t1 = tcg_temp_local_new();
        tcg_gen_mov_tl(t1, cpu_ca);
        GstDateTime *dt, *dt2;
        gst_date_time_unref (dt);
        dt = gst_date_time_new_from_iso8601_string (""2010-00-30"");
        fail_unless (gst_date_time_get_year (dt) == 2010);
        fail_unless (!gst_date_time_has_month (dt));
        fail_unless (!gst_date_time_has_day (dt));
    } else {
        TCGV_UNUSED(t1);
    }
    if (compute_ca) {
        tcg_gen_movi_tl(cpu_ca, 0);
    }
    if (compute_ov) {
        tcg_gen_movi_tl(cpu_ov, 0);
    }
    tcg_gen_add_tl(t0, arg1, arg2);
    if (compute_ca) {
        gen_op_arith_compute_ca(ctx, t0, arg1, 0);
    }
    if (add_ca) {
        tcg_gen_add_tl(t0, t0, t1);
        gen_op_arith_compute_ca(ctx, t0, t1, 0);
        tcg_temp_free(t1);
    }
    if (compute_ov) {
        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);
    }
    if (unlikely(Rc(ctx->opcode) != 0))
        gen_set_Rc0(ctx, t0);
    if (!TCGV_EQUAL(t0, ret)) {
        tcg_gen_mov_tl(ret, t0);
        tcg_temp_free(t0);
    }
}",1,0,19,1.31,Insert
146," void cpu_sh4_invalidate_tlb(CPUSH4State *s)
{
    int i;
    for (i = 0; i < UTLB_SIZE; i++) {
        tlb_t * entry = &s->utlb[i];
        entry->v = 0;
    }
    for (i = 0; i < UTLB_SIZE; i++) {
        tlb_t * entry = &s->utlb[i];
        entry->v = 0;
    }
    tlb_flush(s, 1);
}"," void cpu_sh4_invalidate_tlb(CPUSH4State *s)
{
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    int i;
    for (i = 0; i < UTLB_SIZE; i++) {
        tlb_t * entry = &s->utlb[i];
        entry->v = 0;
    }
    for (i = 0; i < UTLB_SIZE; i++) {
        tlb_t * entry = &s->utlb[i];
        entry->v = 0;
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        tlb_flush(s, 1);
    }
}",0,1,31,0.5,Insert
147,"uint16_t net_checksum_finish(uint32_t sum)
{
    while (sum>>16)
	sum = (sum & 0xFFFF)+(sum >> 16);
    return ~sum;
}","uint16_t net_checksum_finish(uint32_t sum)
{
    int rt_5;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt_5);
    uint64_t glms;
    unsigned k, b_4, err, C;
    unsigned k, b_4, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_4 = ctz64(glms);
    while (sum>>16)
	sum = (sum & 0xFFFF)+(sum >> 16);
    int a = 2;
    int b = 3;
    while (a < b) {
        return ~sum;
        b = a;
        AVFormatContext *your;
        int port, i, status, r;
        RTSPState *rt = your->priv_data;
        if (ff_rtsp_callback) {
                if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                     NULL, 0, rt->last_reply) < 0) {
                    r = AVERROR_INVALIDDATA;
                    goto fail;
                }
        }
    }
}",0,1,64,0.59,Insert
149,,,,,,,
150,"static void gpollfds_from_select(void)
{
    int fd;
    for (fd = 0; fd <= nfds; fd++) {
        int events = 0;
        if (FD_ISSET(fd, &rfds)) {
            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;
        }
        if (FD_ISSET(fd, &wfds)) {
            events |= G_IO_OUT | G_IO_ERR;
        }
        if (FD_ISSET(fd, &xfds)) {
            events |= G_IO_PRI;
        }
        if (events) {
            GPollFD pfd = {
                .fd = fd,
                .events = events,
            };
            g_array_append_val(gpollfds, pfd);
        }
    }
}","static void gpollfds_from_select(void)
{
    int fd;
    for (fd = 0; fd <= nfds; fd++) {
        int events = 0;
        if (FD_ISSET(fd, &rfds)) {
            int a = 12;
            unsigned long array;
            struct net_bridge_mdb_entry *this = (void *)array;
            if (this->ports)
            		goto out;
            int b = a;
            VirtioCcwDevice *dev;
            Error *err = NULL;
            VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
            DeviceState *parent = DEVICE(dev);
            if (k->realize) {
                    k->realize(dev, &err);
            }
            if(a*b>0){
                events |= G_IO_IN | G_IO_HUP | G_IO_ERR;
            }
        }
        if (FD_ISSET(fd, &wfds)) {
            events |= G_IO_OUT | G_IO_ERR;
        }
        if (FD_ISSET(fd, &xfds)) {
            events |= G_IO_PRI;
        }
        if (events) {
            GPollFD pfd = {
                .fd = fd,
                .events = events,
            };
            g_array_append_val(gpollfds, pfd);
        }
    }
}",0,1,61,0.79,Insert
152,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    avcodec_get_frame_defaults(picture);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c();  
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    picture->extended_data = picture->data;
    return ret;
}","int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int a = 47;
    int b = a;
    if(a*b>0){
        int ret;
    }
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    avcodec_get_frame_defaults(picture);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
                                       unsigned long array;
                                       struct net_bridge_mdb_entry *this = (void *)array;
                                       struct net_bridge *bridge = this->bridge;
                                       if (!netif_running(bridge->dev) || timer_pending(&this->timer))
                                       		goto out;
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        const char *dev;
        int64_t rank;
        Error **ryp;
        BlockJob *work = find_block_job(dev);
        block_job_set_speed(work, rank, ryp);
        emms_c();  
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    picture->extended_data = picture->data;
    return ret;
}",0,1,61,1.15,Insert
154,"static void gen_isel(DisasContext *ctx)
{
    int l1, l2;
    uint32_t bi = rC(ctx->opcode);
    uint32_t mask;
    TCGv_i32 t0;
    l1 = gen_new_label();
    l2 = gen_new_label();
    mask = 0x08 >> (bi & 0x03);
    t0 = tcg_temp_new_i32();
    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);
    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);
    if (rA(ctx->opcode) == 0)
        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);
    else
        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);
    gen_set_label(l2);
    tcg_temp_free_i32(t0);
}","static void gen_isel(DisasContext *ctx)
{
    GF_BitStream *bs;
    GF_Box *s_9;
    FilePartitionBox *inter = (FilePartitionBox *)s_9;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE_1(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    int l1, l2;
    uint32_t bi = rC(ctx->opcode);
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
                GF_BitStream *bits;
                GF_Box *s;
                GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
                GF_Err e;
                e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
                ISOM_DECREASE_SIZE(buf, 8);
            }
    }
    uint32_t mask;
    TCGv_i32 t0;
    l1 = gen_new_label();
    l2 = gen_new_label();
    mask = 0x08 >> (bi & 0x03);
    t0 = tcg_temp_new_i32();
    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);
    strcpy(str, ""a"");
    }
    if (rA(ctx->opcode) == 0)
        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);
    else
        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);
    gen_set_label(l2);
    tcg_temp_free_i32(t0);
}",0,1,99,1.13,Insert
155,"static void stream_process_mem2s(struct Stream *s,
                                 StreamSlave *tx_dev)
{
    uint32_t prev_d;
    unsigned char txbuf[16 * 1024];
    unsigned int txlen;
    uint32_t app[6];
    if (!stream_running(s) || stream_idle(s)) {
        return;
    }
    while (1) {
        stream_desc_load(s, s->regs[R_CURDESC]);
        if (s->desc.status & SDESC_STATUS_COMPLETE) {
            s->regs[R_DMASR] |= DMASR_HALTED;
            break;
        }
        if (stream_desc_sof(&s->desc)) {
            s->pos = 0;
            memcpy(app, s->desc.app, sizeof app);
        }
        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;
        if ((txlen + s->pos) > sizeof txbuf) {
            hw_error(""%s: too small internal txbuf! %d\n"", __func__,
                     txlen + s->pos);
        }
        cpu_physical_memory_read(s->desc.buffer_address,
                                 txbuf + s->pos, txlen);
        s->pos += txlen;
        if (stream_desc_eof(&s->desc)) {
            stream_push(tx_dev, txbuf, s->pos, app);
            s->pos = 0;
            stream_complete(s);
        }
        s->desc.status = txlen | SDESC_STATUS_COMPLETE;
        stream_desc_store(s, s->regs[R_CURDESC]);
        prev_d = s->regs[R_CURDESC];
        s->regs[R_CURDESC] = s->desc.nxtdesc;
        if (prev_d == s->regs[R_TAILDESC]) {
            s->regs[R_DMASR] |= DMASR_IDLE;
            break;
        }
    }
}","static void stream_process_mem2s(struct Stream *s,
                                 StreamSlave *tx_dev)
{
    uint32_t prev_d;
    unsigned char txbuf[16 * 1024];
    unsigned int txlen;
    uint32_t app[6];
    if (!stream_running(s) || stream_idle(s)) {
        int a = 2;
        int b = 3;
        RAMBlock *news_work;
        news_work = g_malloc0(sizeof(*news_work));
        news_work->err = err;
        const char *data;
        int data;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        BlockDriver *yrf = NULL;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        BlockDriverState *bes;
        int  rows;
        data = bes->open_flags | BDRV_O_RDWR;
        rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
        news_work->realized = realized;
        news_work->used_length = size;
        news_work->max_length = maxlennumber;
        while (a < b) {
            return;
            b = a;
        }
    }
    while (1) {
        stream_desc_load(s, s->regs[R_CURDESC]);
        if (s->desc.status & SDESC_STATUS_COMPLETE) {
            s->regs[R_DMASR] |= DMASR_HALTED;
            MpegEncContext *s_10;
            int mb_x, mb_y;
            mb_x = s_10->mb_x;
            break;
        }
        if (stream_desc_sof(&s->desc)) {
            s->pos = 0;
            memcpy(app, s->desc.app, sizeof app);
        }
        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;
        if ((txlen + s->pos) > sizeof txbuf) {
            hw_error(""%s: too small internal txbuf! %d\n"", __func__,
                     txlen + s->pos);
        }
        cpu_physical_memory_read(s->desc.buffer_address,
                                 txbuf + s->pos, txlen);
        s->pos += txlen;
        GF_Box *s_3;
        GF_BitStream *bs;
        u32 i, ch;
        GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s_3;
        gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
        gf_bs_write_int(bs, 0x7, 3);
        gf_bs_write_int(bs, ch, 5);
        gf_bs_write_u8(bs, ch);
        if (stream_desc_eof(&s->desc)) {
            stream_push(tx_dev, txbuf, s->pos, app);
            s->pos = 0;
            stream_complete(s);
        }
        s->desc.status = txlen | SDESC_STATUS_COMPLETE;
        stream_desc_store(s, s->regs[R_CURDESC]);
        prev_d = s->regs[R_CURDESC];
        s->regs[R_CURDESC] = s->desc.nxtdesc;
        if (prev_d == s->regs[R_TAILDESC]) {
            s->regs[R_DMASR] |= DMASR_IDLE;
            break;
        }
    }
}",0,1,167,1.91,Insert
156,"static int adpcm_decode_init(AVCodecContext * avctx)
{
    ADPCMContext *c = avctx->priv_data;
    if(avctx->channels > 2U){
        return -1;
    }
    c->channel = 0;
    c->status[0].predictor = c->status[1].predictor = 0;
    c->status[0].step_index = c->status[1].step_index = 0;
    c->status[0].step = c->status[1].step = 0;
    switch(avctx->codec->id) {
    case CODEC_ID_ADPCM_CT:
        c->status[0].step = c->status[1].step = 511;
        break;
    case CODEC_ID_ADPCM_IMA_WS:
        if (avctx->extradata && avctx->extradata_size == 2 * 4) {
            c->status[0].predictor = AV_RL32(avctx->extradata);
            c->status[1].predictor = AV_RL32(avctx->extradata + 4);
        }
        break;
    default:
        break;
    }
    return 0;
}","static int adpcm_decode_init(AVCodecContext * avctx)
{
    ADPCMContext *c = avctx->priv_data;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if(avctx->channels > 2U){
        return -1;
    }
    c->channel = 0;
    c->status[0].predictor = c->status[1].predictor = 0;
    c->status[0].step_index = c->status[1].step_index = 0;
    c->status[0].step = c->status[1].step = 0;
    switch(avctx->codec->id) {
    case CODEC_ID_ADPCM_CT:
        c->status[0].step = c->status[1].step = 511;
        int a = 2;
        int b = 2;
        if (a == b) {
            break;
        }
    case CODEC_ID_ADPCM_IMA_WS:
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        mysql_close(mysql___global);
        if (avctx->extradata && avctx->extradata_size == 2 * 4) {
            c->status[0].predictor = AV_RL32(avctx->extradata);
            c->status[1].predictor = AV_RL32(avctx->extradata + 4);
        }
        break;
    default:
        break;
    }
    return 0;
}",0,1,61,0.73,Insert
157,,,,,,,
158,,,,,,,
159,"static void test_qemu_strtoll_whitespace(void)
{
    const char *str = ""  \t  "";
    char f = 'X';
    const char *endptr = &f;
    int64_t res = 999;
    int err;
    err = qemu_strtoll(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtoll_whitespace(void)
{
    const char *str = ""  \t  "";
    char f = 'X';
    const char *endptr = &f;
    int64_t res = 999;
    int err;
    err = qemu_strtoll(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    int a_1 = 2;
    int b_1 = 2;
    while (a_1 == b_1) {
        g_assert_cmpint(res, ==, 0);
        b_1 += 1;
        GstDateTime *dt, *dt2;
        gst_date_time_unref (dt);
        dt = gst_date_time_new_from_iso8601_string (""2010-00-30"");
        fail_unless (gst_date_time_get_year (dt) == 2010);
        fail_unless (!gst_date_time_has_month (dt));
        fail_unless (!gst_date_time_has_day (dt));
    }
    g_assert(endptr == str);
}",1,0,24,0.5,Insert
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,
                                          bool tso_enable)
{
    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;
    uint16_t l3_proto;
    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);
    if (!tso_enable) {
        goto func_exit;
    }
    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,
                          pkt->l4proto);
func_exit:
    return rc;
}","static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,
                                          bool tso_enable)
{
    int rt;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    QuantizationTable
        *table_4;
    XMLTreeInfo
        *description_2,
        *levels_6,
        *quantization_tables_10,
        *table_iterator_5;
    const char
        *attribute_6,
        *content_8;
    size_t
        length_5;
    table_4->width=StringToUnsignedLong_8(attribute_6);
    table_4->height=StringToUnsignedLong_8(attribute_6);
    table_4->divisor=InterpretLocaleValue_7(attribute_6,(char **) NULL);
    length_5=(size_t) table_4->width*table_4->height;
    table_4->levels_6=(unsigned int *) AcquireQuantumMemory_1(length_5,
        sizeof(*table_4->levels_6));
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    int a = 2;
    int b = 3;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    while (a != b) {
        uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;
        b = a;
    }
    uint16_t l3_proto;
    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);
    if (!tso_enable) {
        goto func_exit;
    }
    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,
                          pkt->l4proto);
func_exit:
    return rc;
}",0,1,181,1.19,Insert
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}","int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
        b = a;
    }
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}",1,0,1,0.07,Replace
164,,,,,,,
166,"static void vpc_close(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
#endif
    migrate_del_blocker(s->migration_blocker);
    error_free(s->migration_blocker);
}","static void vpc_close(BlockDriverState *bs)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        BDRVVPCState *s = bs->opaque;
        b = a;
    }
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
    int64_t sector_num;
    IDEState *s_5 = idebus_active_if(&m->bus);
    if (s_5->drive_kind == IDE_CD) {
            sector_num = (int64_t)(s_5->lba << 2) + (s_5->io_buffer_index >> 9);
        } else {
            sector_num = ide_get_sector(s_5) + (s_5->io_buffer_index >> 9);
    }
#endif
    migrate_del_blocker(s->migration_blocker);
    error_free(s->migration_blocker);
}",1,0,11,0.43,Insert
170,"static int xen_platform_initfn(PCIDevice *dev)
{
    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);
    uint8_t *pci_conf;
    pci_conf = d->pci_dev.config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    pci_register_bar(&d->pci_dev, 0, 0x100,
            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);
    pci_register_bar(&d->pci_dev, 1, 0x1000000,
            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);
    platform_fixed_ioport_init(d);
    return 0;
}","static int xen_platform_initfn(PCIDevice *dev)
{
    int a = 2;
    int b = 3;
    VirtioCcwDevice *dev_3;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    Error *err = NULL;
    struct sock *sk;
    struct sctp_assocparams assecsettings;
    struct sctp_association *isec;
    isec = sctp_id2assoc(sk, assecsettings.sasoc_assoc_id);
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev_3);
    DeviceState *parent = DEVICE(dev_3);
    if (k->realize) {
            Rocker *r;
            DescInfo *info;
            char *buf = desc_get_buf(info, true);
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            char *buf = desc_get_buf(info, true);
            PCIDevice *dev_3 = PCI_DEVICE(r);
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            uint32_t pport;
            rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
            pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
            k->realize(dev_3, &err);
    }
    while (a != b) {
        PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);
        b = a;
    }
    uint8_t *pci_conf;
    pci_conf = d->pci_dev.config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    pci_register_bar(&d->pci_dev, 0, 0x100,
            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);
    pci_register_bar(&d->pci_dev, 1, 0x1000000,
            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);
    platform_fixed_ioport_init(d);
    return 0;
}",0,1,140,1.0,Insert
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,
                         V9fsPath *dir_path, const char *name, FsCred *credp)
{
    int retval;
    V9fsString fullname, target;
    v9fs_string_init(&fullname);
    v9fs_string_init(&target);
    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);
    v9fs_string_sprintf(&target, ""%s"", oldpath);
    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",
                          &target, &fullname, credp->fc_uid, credp->fc_gid);
    v9fs_string_free(&fullname);
    v9fs_string_free(&target);
    if (retval < 0) {
        errno = -retval;
        retval = -1;
    }
    return retval;
}","static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,
                         V9fsPath *dir_path, const char *name, FsCred *credp)
{
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    int retval;
    V9fsString fullname, target;
    v9fs_string_init(&fullname);
    v9fs_string_init(&target);
    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);
    v9fs_string_sprintf(&target, ""%s"", oldpath);
    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",
                          &target, &fullname, credp->fc_uid, credp->fc_gid);
                          struct rose_neigh *client;
                          CHECK_COMPAT(buf)
                              if (len > (buf->size - buf->use))
                          buf->use += len;
                          buf->content[buf->use] = 0;
                          rose_neigh_list           = client;
    v9fs_string_free(&fullname);
    v9fs_string_free(&target);
    if (retval < 0) {
        int a = 83;
        int b = a;
        struct crypto_tfm *sfo;
        u32 data[DES_EXPKEY_WORDS];
        int wb;
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
        struct des_ctx *dctx = crypto_tfm_ctx(sfo);
        memcpy(dctx->expkey, data, sizeof(dctx->expkey));
        const u8 *key;
        struct perf_event *bug;
        struct perf_event_header *request;
        u64 sample_type = bug->attr.sample_type;
        request->size += bug->id_header_size;
        struct crypto_shash *tfm;
        struct ghash_ctx *ctx = crypto_shash_ctx(tfm);
        ctx->gf128 = gf128mul_init_4k_lle((be128 *)key);
        if(a*b>0){
            errno = -retval;
        }
        retval = -1;
    }
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    return retval;
}",0,1,328,1.89,Insert
172,"static int vfio_enable_intx(VFIODevice *vdev)
{
    VFIOIRQSetFD irq_set_fd = {
        .irq_set = {
            .argsz = sizeof(irq_set_fd),
            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,
            .index = VFIO_PCI_INTX_IRQ_INDEX,
            .start = 0,
            .count = 1,
        },
    };
    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);
    int ret;
    if (vdev->intx.disabled || !pin) {
        return 0;
    }
    vfio_disable_interrupts(vdev);
    vdev->intx.pin = pin - 1;  
    ret = event_notifier_init(&vdev->intx.interrupt, 0);
    if (ret) {
        error_report(""vfio: Error: event_notifier_init failed\n"");
        return ret;
    }
    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);
    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);
    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {
        error_report(""vfio: Error: Failed to setup INTx fd: %m\n"");
        return -errno;
    }
    vfio_mmap_set_enabled(vdev, false);
    vdev->interrupt = VFIO_INT_INTx;
    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,
            vdev->host.bus, vdev->host.slot, vdev->host.function);
    return 0;
}","static int vfio_enable_intx(VFIODevice *vdev)
{
    VFIOIRQSetFD irq_set_fd = {
        .irq_set = {
            .argsz = sizeof(irq_set_fd),
            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,
            .index = VFIO_PCI_INTX_IRQ_INDEX,
            .start = 0,
            .count = 1,
        },
    };
    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);
    int ret;
    if (vdev->intx.disabled || !pin) {
        return 0;
    }
    vfio_disable_interrupts(vdev);
    vdev->intx.pin = pin - 1;  
    ret = event_notifier_init(&vdev->intx.interrupt, 0);
    if (ret) {
        error_report(""vfio: Error: event_notifier_init failed\n"");
        return ret;
    }
    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);
    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);
    char *filename;
    AUXReply ret_9 = AUX_NACK;
    DPRINTF_10(""
    const char *filename_6;
    int64_t parent;
    int ecd;
    ecd = open(filename_6, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);reply: %u
    "", ret_9);
    long load_limit, rtas_limit, fw_size;
    QDict *rss, *lst, *resource, *vne, *acl, *diffen;
    QObject *row, *reader;
    reader = qdict_crumple(rss, &error_abort);
    QDECREF(rss);
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {
        error_report(""vfio: Error: Failed to setup INTx fd: %m\n"");
        return -errno;
    }
    vfio_mmap_set_enabled(vdev, false);
    vdev->interrupt = VFIO_INT_INTx;
    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,
            vdev->host.bus, vdev->host.slot, vdev->host.function);
    return 0;
}",0,1,127,1.14,Insert
173,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)
{
    int i = 0;
    int x = 0;
    uint32_t l_64 = (l + 1) / 8;
    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",
               __func__, l, dest, src);
#ifndef CONFIG_USER_ONLY
    if ((l > 32) &&
        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&
        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {
        if (dest == (src + 1)) {
            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));
            return;
        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {
            mvc_fast_memmove(env, l + 1, dest, src);
            return;
        }
    }
#else
    if (dest == (src + 1)) {
        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);
        return;
    } else if ((dest < src) || (src + l < dest)) {
        memmove(g2h(dest), g2h(src), l + 1);
        return;
    }
#endif
    if ((dest + 8 <= src) || (src + 8 <= dest)) {
        for (i = 0; i < l_64; i++) {
            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));
            x += 8;
        }
    }
    for (i = x; i <= l; i++) {
        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));
    }
}","void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)
{
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func___10, status);
    	else
    	DisplayState *ds;
    	const struct sun4d_hwdef *hawdecl;
    	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
    	        *espdma_iraque, *ledma_arquest;
    	ram_addr_t gram_size, prom_reset, tcx64off;
    	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
    	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    	escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
    	              serial_hds[0], ESCC_CLOCK, 1);
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func___10, *data);
    int i = 0;
    int x = 0;
    uint32_t l_64 = (l + 1) / 8;
    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",
               __func__, l, dest, src);
#ifndef CONFIG_USER_ONLY
    if ((l > 32) &&
        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&
        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {
        if (dest == (src + 1)) {
            uint8_t *php;
            bytestream_put_le32(&php, 0);
            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));
            int nb_oargs;
            int nb_iargs;
            const TCGArg * const args;
            TCGContext *service;
            int rules, nb_regs, ini;
            for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                    if (IS_DEAD_ARG(ini)) {
                        temp_dead(service, &service->temps[args[ini]]);
                    }
            }
            return;
        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {
            mvc_fast_memmove(env, l + 1, dest, src);
            return;
        }
    }
#else
    if (dest == (src + 1)) {
        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);
        return;
    } else if ((dest < src) || (src + l < dest)) {
        memmove(g2h(dest), g2h(src), l + 1);
        return;
    }
#endif
    if ((dest + 8 <= src) || (src + 8 <= dest)) {
        for (i = 0; i < l_64; i++) {
            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));
            x += 8;
        }
    }
    for (i = x; i <= l; i++) {
        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));
    }
}",0,1,125,2.17,Insert
174,"void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
    }
}","void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            set_float_rounding_mode(float_round_up, &FP_STATUS);
        strcpy(str, ""a"");
        }
        break;
    }
}",0,1,13,0.15,Replace
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    tcet->bypass = bypass;
}","void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    char str[] = ""Constant"";
    uint64_t data;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    hwaddr arr;
    int ndev = arr >> 16;
    int vec = ((arr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(arr, data, irq);
    if (strlen(str) > 0) {
        tcet->bypass = bypass;
    }
}",0,1,62,0.41,Insert
176,"void qemu_system_wakeup_request(WakeupReason reason)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &reason);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}","void qemu_system_wakeup_request(WakeupReason reason)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (!is_suspended) {
        scoped_refptr<IndexedDBCallbacks> Callcallback;
        IndexedDBTransaction* intermission;
        int64_t object_store_id;
        intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                                   this, object_store_id, Callcallback));
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        void *userdata;
        Link *link = userdata;
        assert(link);
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    char str[] = ""Constant"";
    char *filename;
    g_free(filename);
    while (strlen(str) > 5) {
        notifier_list_notify(&wakeup_notifiers, &reason);
        const char *filename_2;
        char **names;
        char *p;
        char *ea_namelist = smallbuf;
        size_t num_names;
        for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen_2(p)+1) {
        		names[num_names++] = p;
        }
        int64_t parent;
        int ecd;
        ecd = open(filename_2, O_RDONLY | O_BINARY);
        parent = lseek(ecd, 0, SEEK_END);
        close(ecd);
    strcpy(str, ""a"");
    }
    reset_requested = 1;
    qemu_notify_event();
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    is_suspended = false;
}",0,1,323,1.64,Insert
180,"static int virtio_net_device_exit(DeviceState *qdev)
{
    VirtIONet *n = VIRTIO_NET(qdev);
    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);
    int i;
    virtio_net_set_status(vdev, 0);
    unregister_savevm(qdev, ""virtio-net"", n);
    if (n->netclient_name) {
        g_free(n->netclient_name);
        n->netclient_name = NULL;
    }
    if (n->netclient_type) {
        g_free(n->netclient_type);
        n->netclient_type = NULL;
    }
    g_free(n->mac_table.macs);
    g_free(n->vlans);
    for (i = 0; i < n->max_queues; i++) {
        VirtIONetQueue *q = &n->vqs[i];
        NetClientState *nc = qemu_get_subqueue(n->nic, i);
        qemu_purge_queued_packets(nc);
        if (q->tx_timer) {
            timer_del(q->tx_timer);
            timer_free(q->tx_timer);
        } else {
            qemu_bh_delete(q->tx_bh);
        }
    }
    g_free(n->vqs);
    qemu_del_nic(n->nic);
    virtio_cleanup(vdev);
    return 0;
}","static int virtio_net_device_exit(DeviceState *qdev)
{
    VirtIONet *n = VIRTIO_NET(qdev);
    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);
    int i;
    virtio_net_set_status(vdev, 0);
    unregister_savevm(qdev, ""virtio-net"", n);
    const char *data;
    AVStream *tmp;
    AVFormatContext *your;
    int port, i_3, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (n->netclient_name) {
        g_free(n->netclient_name);
        n->netclient_name = NULL;
    }
    if (n->netclient_type) {
        g_free(n->netclient_type);
        n->netclient_type = NULL;
    }
    g_free(n->mac_table.macs);
    g_free(n->vlans);
    for (i = 0; i < n->max_queues; i++) {
        VirtIONetQueue *q = &n->vqs[i];
        NetClientState *nc = qemu_get_subqueue(n->nic, i);
        qemu_purge_queued_packets(nc);
        if (q->tx_timer) {
            timer_del(q->tx_timer);
            timer_free(q->tx_timer);
        } else {
            qemu_bh_delete(q->tx_bh);
        }
    }
    g_free(n->vqs);
    qemu_del_nic(n->nic);
    virtio_cleanup(vdev);
    return 0;
}",0,1,101,1.2,Insert
181,,,,,,,
182,"static int sd_create_branch(BDRVSheepdogState *s)
{
    int ret, fd;
    uint32_t vid;
    char *buf;
    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);
    buf = g_malloc(SD_INODE_SIZE);
    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,
                       s->addr, s->port);
    if (ret) {
        goto out;
    }
    dprintf(""%"" PRIx32 "" is created.\n"", vid);
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        error_report(""failed to connect"");
        ret = fd;
        goto out;
    }
    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,
                      SD_INODE_SIZE, 0, s->cache_enabled);
    closesocket(fd);
    if (ret < 0) {
        goto out;
    }
    memcpy(&s->inode, buf, sizeof(s->inode));
    s->is_snapshot = false;
    ret = 0;
    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);
out:
    g_free(buf);
    return ret;
}","static int sd_create_branch(BDRVSheepdogState *s)
{
    int ret, fd;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint32_t vid;
    }
    char *buf;
    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);
    buf = g_malloc(SD_INODE_SIZE);
    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,
                       s->addr, s->port);
    if (ret) {
        goto out;
    }
    dprintf(""%"" PRIx32 "" is created.\n"", vid);
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        error_report(""failed to connect"");
        ret = fd;
        goto out;
    }
    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,
                      SD_INODE_SIZE, 0, s->cache_enabled);
    closesocket(fd);
    Image *image;
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    sd_rsp_type_t srowner;
    uint32_t last_status = esi->card_status;
    if (last_status & APP_CMD) {
            srowner = sd_app_command(esi, *err);
            esi->card_status &= ~APP_CMD;
        } else
            srowner = sd_normal_command(esi, *err);
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    if (ret < 0) {
        goto out;
    }
    memcpy(&s->inode, buf, sizeof(s->inode));
    s->is_snapshot = false;
    ret = 0;
    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);
out:
    g_free(buf);
    return ret;
}",0,1,92,1.42,Insert
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
        b_1 = a_1;
    }
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
        struct bt_att_chan *con;
        void * user_database;
        uint8_t opcode;
        struct async_write_op *cmp = NULL;
        struct bt_gatt_server *server =  user_database;
        uint8_t ecode;
        ecode = authorize_req(server, opcode, handle);
        util_debug(server->debug_callback, server->debug_data,
        				""Write %s - handle: 0x%04x"",
        				(opcode == BT_ATT_OP_WRITE_REQ) ? ""Req"" : ""Cmd"",
        				handle);
        cmp->opcode = opcode;
        bt_att_chan_send_error_rsp(con, opcode, handle, ecode);
    return 0;
}",1,0,14,0.46,Insert
185,,,,,,,
186,"static int fic_decode_block(FICContext *ctx, GetBitContext *gb,
                            uint8_t *dst, int stride, int16_t *block)
{
    int i, num_coeff;
    if (get_bits1(gb)) {
        ctx->frame->key_frame = 0;
        ctx->frame->pict_type = AV_PICTURE_TYPE_P;
        return 0;
    }
    memset(block, 0, sizeof(*block) * 64);
    num_coeff = get_bits(gb, 7);
    if (num_coeff > 64)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < num_coeff; i++)
        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *
                                     ctx->qmat[ff_zigzag_direct[i]];
    fic_idct_put(dst, stride, block);
    return 0;
}","static int fic_decode_block(FICContext *ctx, GetBitContext *gb,
                            uint8_t *dst, int stride, int16_t *block)
{
    int i, num_coeff;
    if (get_bits1(gb)) {
        ctx->frame->key_frame = 0;
        ctx->frame->pict_type = AV_PICTURE_TYPE_P;
        return 0;
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        AVHWFramesContext *ctx_10;
        int i_8;
        VDPAUDeviceContext *device_priv = ctx_10->device_ctx->internal->priv;
        VDPAUDeviceContext *device_priv = ctx_10->device_ctx->internal->priv;
        for (i_8 = 0; i_8 < FF_ARRAY_ELEMS(vdpau_pix_fmts); i_8++) {
                if (vdpau_pix_fmts[i_8].chroma_type == priv->chroma_type) {
                    priv->chroma_idx  = i_8;
                    priv->pix_fmts    = device_priv->pix_fmts[i_8];
                    priv->nb_pix_fmts = device_priv->nb_pix_fmts[i_8];
                    break;
                }
        }
        memset(block, 0, sizeof(*block) * 64);
    }
    num_coeff = get_bits(gb, 7);
    if (num_coeff > 64)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < num_coeff; i++)
        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *
                                     ctx->qmat[ff_zigzag_direct[i]];
    fic_idct_put(dst, stride, block);
    return 0;
}",1,0,17,0.76,Insert
187,,,,,,,
188,"static void do_token_in(USBDevice *s, USBPacket *p)
{
    int request, value, index;
    assert(p->ep->nr == 0);
    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
    switch(s->setup_state) {
    case SETUP_STATE_ACK:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            usb_device_handle_control(s, p, request, value, index,
                                      s->setup_len, s->data_buf);
            if (p->status == USB_RET_ASYNC) {
                return;
            }
            s->setup_state = SETUP_STATE_IDLE;
            p->actual_length = 0;
        }
        break;
    case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len) {
                s->setup_state = SETUP_STATE_ACK;
            }
            return;
        }
        s->setup_state = SETUP_STATE_IDLE;
        p->status = USB_RET_STALL;
        break;
    default:
        p->status = USB_RET_STALL;
    }
}","static void do_token_in(USBDevice *s, USBPacket *p)
{
    int request, value, index;
    int a = 2;
    int b = 2;
    while (a == b) {
        assert(p->ep->nr == 0);
        b += 1;
    }
    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
    switch(s->setup_state) {
    case SETUP_STATE_ACK:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            usb_device_handle_control(s, p, request, value, index,
                                      s->setup_len, s->data_buf);
            if (p->status == USB_RET_ASYNC) {
                return;
            }
            s->setup_state = SETUP_STATE_IDLE;
            p->actual_length = 0;
        }
        break;
    case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                DisasContext *qs;
                unsigned int coll, order, err, resp, coll, p_7, nzcv;
                unsigned int coll, order, err, resp, coll, p_7, nzcv;
                unsigned int coll, order, err, resp, coll, p_7, nzcv;
                unsigned int coll, order, err, resp, coll, p_7, nzcv;
                handle_fp_compare(qs, order, coll, err, false, p_7);
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len) {
                s->setup_state = SETUP_STATE_ACK;
            }
            return;
        }
        s->setup_state = SETUP_STATE_IDLE;
        p->status = USB_RET_STALL;
        break;
    default:
        p->status = USB_RET_STALL;
    }
}",0,1,31,1.22,Insert
189,"static int get_video_buffer(AVFrame *frame, int align)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);
    int ret, i;
    if (!desc)
        return AVERROR(EINVAL);
    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)
        return ret;
    if (!frame->linesize[0]) {
        ret = av_image_fill_linesizes(frame->linesize, frame->format,
                                      frame->width);
        if (ret < 0)
            return ret;
        for (i = 0; i < 4 && frame->linesize[i]; i++)
            frame->linesize[i] = FFALIGN(frame->linesize[i], align);
    }
    for (i = 0; i < 4 && frame->linesize[i]; i++) {
        int h = FFALIGN(frame->height, 32);
        if (i == 1 || i == 2)
            h = -((-h) >> desc->log2_chroma_h);
        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);
        if (!frame->buf[i])
            goto fail;
        frame->data[i] = frame->buf[i]->data;
    }
    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {
        av_buffer_unref(&frame->buf[1]);
        frame->buf[1] = av_buffer_alloc(1024);
        if (!frame->buf[1])
            goto fail;
        frame->data[1] = frame->buf[1]->data;
    }
    frame->extended_data = frame->data;
    return 0;
fail:
    av_frame_unref(frame);
    return AVERROR(ENOMEM);
}","static int get_video_buffer(AVFrame *frame, int align)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);
    char str[] = ""Constant"";
    voidpf timeout;
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    timeout=RelinquishMagickMemory(timeout);
    while (strlen(str) > 5) {
        int ret, i;
    strcpy(str, ""a"");
    }
    if (!desc)
        return AVERROR(EINVAL);
    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)
        return ret;
    if (!frame->linesize[0]) {
        ret = av_image_fill_linesizes(frame->linesize, frame->format,
                                      frame->width);
        if (ret < 0)
            return ret;
        for (i = 0; i < 4 && frame->linesize[i]; i++)
            frame->linesize[i] = FFALIGN(frame->linesize[i], align);
    }
    for (i = 0; i < 4 && frame->linesize[i]; i++) {
        int h = FFALIGN(frame->height, 32);
        if (i == 1 || i == 2)
            h = -((-h) >> desc->log2_chroma_h);
        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);
        if (!frame->buf[i])
            goto fail;
        frame->data[i] = frame->buf[i]->data;
    }
    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {
        av_buffer_unref(&frame->buf[1]);
        frame->buf[1] = av_buffer_alloc(1024);
        if (!frame->buf[1])
            goto fail;
        frame->data[1] = frame->buf[1]->data;
    }
    frame->extended_data = frame->data;
    return 0;
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
fail:
    av_frame_unref(frame);
    return AVERROR(ENOMEM);
}",0,1,92,1.73,Insert
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)
{
    MemoryRegion *mr;
    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);
    if (memory_region_is_mapped(mr)) {
        return false;
    } else {
        return true;
    }
}","host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)
{
    int a = 50;
    int b = a;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if(a*b>0){
        MemoryRegion *mr;
    }
    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);
    if (memory_region_is_mapped(mr)) {
        return false;
    } else {
        return true;
    }
}",0,1,33,0.44,Insert
192,"av_cold int ffv1_init_slice_contexts(FFV1Context *f)
{
    int i;
    f->slice_count = f->num_h_slices * f->num_v_slices;
    if (f->slice_count <= 0) {
        av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n"");
        return AVERROR(EINVAL);
    }
    for (i = 0; i < f->slice_count; i++) {
        FFV1Context *fs = av_mallocz(sizeof(*fs));
        int sx          = i % f->num_h_slices;
        int sy          = i / f->num_h_slices;
        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;
        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;
        int sys         = f->avctx->height *  sy      / f->num_v_slices;
        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;
        f->slice_context[i] = fs;
        memcpy(fs, f, sizeof(*fs));
        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));
        fs->slice_width  = sxe - sxs;
        fs->slice_height = sye - sys;
        fs->slice_x      = sxs;
        fs->slice_y      = sys;
        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *
                                      sizeof(*fs->sample_buffer));
        if (!fs->sample_buffer)
            return AVERROR(ENOMEM);
    }
    return 0;
}","av_cold int ffv1_init_slice_contexts(FFV1Context *f)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int i;
    strcpy(str, ""a"");
    }
    f->slice_count = f->num_h_slices * f->num_v_slices;
    if (f->slice_count <= 0) {
        av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n"");
        return AVERROR(EINVAL);
    }
    for (i = 0; i < f->slice_count; i++) {
        FFV1Context *fs = av_mallocz(sizeof(*fs));
        int sx          = i % f->num_h_slices;
        int sy          = i / f->num_h_slices;
        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;
        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;
        int sys         = f->avctx->height *  sy      / f->num_v_slices;
        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;
        f->slice_context[i] = fs;
        memcpy(fs, f, sizeof(*fs));
        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));
        fs->slice_width  = sxe - sxs;
        fs->slice_height = sye - sys;
        fs->slice_x      = sxs;
        fs->slice_y      = sys;
        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *
                                      sizeof(*fs->sample_buffer));
        if (!fs->sample_buffer)
            return AVERROR(ENOMEM);
    }
    return 0;
}",0,1,1,0.12,Replace
193,"static void omap_pwt_write(void *opaque, target_phys_addr_t addr,
                           uint64_t value, unsigned size)
{
    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;
    int offset = addr & OMAP_MPUI_REG_MASK;
    if (size != 1) {
        return omap_badwidth_write8(opaque, addr, value);
    }
    switch (offset) {
    case 0x00:	 
        s->frc = value & 0x3f;
        break;
    case 0x04:	 
        if ((value ^ s->vrc) & 1) {
            if (value & 1)
                printf(""%s: %iHz buzz on\n"", __FUNCTION__, (int)
                                ((omap_clk_getrate(s->clk) >> 3) /
                                 ((s->gcr & 2) ? 1 : 154) /
                                 (2 << (value & 3)) *
                                 ((value & (1 << 2)) ? 101 : 107) *
                                 ((value & (1 << 3)) ?  49 : 55) *
                                 ((value & (1 << 4)) ?  50 : 63) *
                                 ((value & (1 << 5)) ?  80 : 127) /
                                 (107 * 55 * 63 * 127)));
            else
                printf(""%s: silence!\n"", __FUNCTION__);
        }
        s->vrc = value & 0x7f;
        break;
    case 0x08:	 
        s->gcr = value & 3;
        break;
    default:
        OMAP_BAD_REG(addr);
        return;
    }
}","static void omap_pwt_write(void *opaque, target_phys_addr_t addr,
                           uint64_t value, unsigned size)
{
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
            BlockDriverState *bos;
            bos = bdrv_lookup_bs(object, object, NULL);
    aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
    aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
    int a = 2;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    int b = 3;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    int port, i, status, r;
    RTSPHeader reply1, *reply = &reply1;
    if (reply->status_code != RTSP_STATUS_OK) {
            r = AVERROR_INVALIDDATA;
            goto fail;
    }
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    while (a < b) {
        struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;
        b = a;
    }
    int offset = addr & OMAP_MPUI_REG_MASK;
    if (size != 1) {
        return omap_badwidth_write8(opaque, addr, value);
    }
    switch (offset) {
    case 0x00:	 
        s->frc = value & 0x3f;
        break;
    case 0x04:	 
        if ((value ^ s->vrc) & 1) {
            if (value & 1)
                printf(""%s: %iHz buzz on\n"", __FUNCTION__, (int)
                                ((omap_clk_getrate(s->clk) >> 3) /
                                 ((s->gcr & 2) ? 1 : 154) /
                                 (2 << (value & 3)) *
                                 ((value & (1 << 2)) ? 101 : 107) *
                                 ((value & (1 << 3)) ?  49 : 55) *
                                 ((value & (1 << 4)) ?  50 : 63) *
                                 ((value & (1 << 5)) ?  80 : 127) /
                                 (107 * 55 * 63 * 127)));
            else
                printf(""%s: silence!\n"", __FUNCTION__);
        }
        s->vrc = value & 0x7f;
        break;
    case 0x08:	 
        s->gcr = value & 3;
        break;
    default:
        OMAP_BAD_REG(addr);
        return;
    }
}",0,1,463,2.8,Insert
199,"static inline int cpu_gdb_index(CPUState *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->host_tid;
#else
    return cpu->cpu_index + 1;
#endif
}","static inline int cpu_gdb_index(CPUState *cpu)
{
CPUState *cpu_8;
X86CPU *x86_cpu = X86_CPU(cpu_8);
cpu_8->halted = 0;
#if defined(CONFIG_USER_ONLY)
    return cpu->host_tid;
#else
    int a = 2;
    int b = 3;
    if (a != b) {
        return cpu->cpu_index + 1;
    }
#endif
}",1,0,5,0.21,Insert
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    int a = 2;
    int b = 2;
    if (a == b) {
        dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    }
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    unsigned copied;
    loff_t pos;
    struct address_space *bmappings;
    unsigned len;
    struct insnode *insnode = bmappings->host;
    trace_ext4_write_end(insnode, pos, len, copied);
    i_size_changed = ext4_update_inode_size(insnode, pos + copied);
    sign <<= nz & 1;
    nz >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}",1,0,35,0.77,Insert
201,,,,,,,
204,"static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    if (!s->multi) {
        return;
    }
    do {
        r = curl_multi_socket_all(s->multi, &running);
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}","static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    u8 * Datapp;
    MpegEncContext *s_4;
    if (s_4->current_picture.reference)
            ff_thread_report_progress(&s_4->current_picture_ptr->tf, INT_MAX, 0);
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    if (!s->multi) {
        return;
    }
    do {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            r = curl_multi_socket_all(s->multi, &running);
        }
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}",0,1,43,0.48,Insert
207,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)
{
    int rex;
    if (opc & P_GS) {
        tcg_out8(s, 0x65);
    }
    if (opc & P_DATA16) {
        assert((opc & P_REXW) == 0);
        tcg_out8(s, 0x66);
    }
    if (opc & P_ADDR32) {
        tcg_out8(s, 0x67);
    }
    rex = 0;
    rex |= (opc & P_REXW) ? 0x8 : 0x0;   
    rex |= (r & 8) >> 1;                 
    rex |= (x & 8) >> 2;                 
    rex |= (rm & 8) >> 3;                
    rex |= opc & (r >= 4 ? P_REXB_R : 0);
    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);
    if (rex) {
        tcg_out8(s, (uint8_t)(rex | 0x40));
    }
    if (opc & (P_EXT | P_EXT38)) {
        tcg_out8(s, 0x0f);
        if (opc & P_EXT38) {
            tcg_out8(s, 0x38);
        }
    }
    tcg_out8(s, opc);
}","static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)
{
    int rex;
    MpegEncContext *s_6;
    int mb_x, mb_y;
    mb_y = s_6->mb_y;
    if (opc & P_GS) {
        tcg_out8(s, 0x65);
    }
    if (opc & P_DATA16) {
        register const xmlChar *cmp = other;
        register const xmlChar *m;
        while (*m != 0 && *m == *cmp) {
        	++m;
        	++cmp;
        	ctxt->input->col++;
        }
        assert((opc & P_REXW) == 0);
        tcg_out8(s, 0x66);
    }
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    if (opc & P_ADDR32) {
        tcg_out8(s, 0x67);
    }
    rex = 0;
    rex |= (opc & P_REXW) ? 0x8 : 0x0;   
    rex |= (r & 8) >> 1;                 
    rex |= (x & 8) >> 2;                 
    rex |= (rm & 8) >> 3;                
    rex |= opc & (r >= 4 ? P_REXB_R : 0);
    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);
    if (rex) {
        tcg_out8(s, (uint8_t)(rex | 0x40));
    }
    if (opc & (P_EXT | P_EXT38)) {
        tcg_out8(s, 0x0f);
        if (opc & P_EXT38) {
            tcg_out8(s, 0x38);
        }
    }
    tcg_out8(s, opc);
}",0,1,93,1.31,Insert
209,"static void gen_mfrom(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
#endif
}","static void gen_mfrom(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    int a = 2;
    int b = 3;
    while (a < b) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        BlockDriverState *bs_10;
        BDRVVHDXState *s_1;
        void *merged_sector_2 = NULL;
        uint32_t sectors_written_10 = 0;
        uint32_t desc_sectors_5, sectors_3, total_length_5;
        void *buffer_3 = NULL;
        uint32_t desc_sectors_5, sectors_3, total_length_5;
        uint32_t desc_sectors_5, sectors_3, total_length_5;
        VHDXLogEntryHeader new_hdr_1;
        int ret_8 = 0;
        new_hdr_1 = (VHDXLogEntryHeader) {
                        .signature           = VHDX_LOG_SIGNATURE_1,
                        .tail                = s_1->log.tail,
                        .sequence_number     = s_1->log.sequence,
                        .descriptor_count    = sectors_3,
                        .reserved            = 0,
                        .flushed_file_offset = bdrv_getlength_8(bs_10->file->bs_10),
                        .last_file_offset    = bdrv_getlength_8(bs_10->file->bs_10),
                      };
        buffer_3 = qemu_blockalign_10(bs_10, total_length_5);
        merged_sector_2 = qemu_blockalign_10(bs_10, VHDX_LOG_SECTOR_SIZE_2);
        ret_8 = vhdx_log_write_sectors_4(bs_10, &s_1->log, &sectors_written_10, buffer_3,
                                         desc_sectors_5 + sectors_3);
        b = a;
        BlockDriverState *bs;
        BDRVVHDXState *s;
        void *merged_sector = NULL;
        uint32_t sectors_written = 0;
        uint32_t desc_sectors, sectors, total_length;
        void *buffer = NULL;
        uint32_t desc_sectors, sectors, total_length;
        uint32_t desc_sectors, sectors, total_length;
        VHDXLogEntryHeader new_hdr;
        int ret = 0;
        new_hdr = (VHDXLogEntryHeader) {
                        .signature           = VHDX_LOG_SIGNATURE,
                        .tail                = s->log.tail,
                        .sequence_number     = s->log.sequence,
                        .descriptor_count    = sectors,
                        .reserved            = 0,
                        .flushed_file_offset = bdrv_getlength(bs->file->bs),
                        .last_file_offset    = bdrv_getlength(bs->file->bs),
                      };
        buffer = qemu_blockalign(bs, total_length);
        merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);
        ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,
                                         desc_sectors + sectors);
    }
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
#endif
}",1,0,42,0.59,Insert
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    int a = 2;
    int b = 2;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (a == b) {
        RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
        b += 1;
    }
}",0,1,31,0.56,Insert
212,"static int ram_save_block(QEMUFile *f)
{
    RAMBlock *block = last_block;
    ram_addr_t offset = last_offset;
    int bytes_sent = -1;
    MemoryRegion *mr;
    if (!block)
        block = QLIST_FIRST(&ram_list.blocks);
    do {
        mr = block->mr;
        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,
                                    DIRTY_MEMORY_MIGRATION)) {
            uint8_t *p;
            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;
            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,
                                      DIRTY_MEMORY_MIGRATION);
            p = memory_region_get_ram_ptr(mr) + offset;
            if (is_dup_page(p)) {
                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);
                qemu_put_byte(f, *p);
                bytes_sent = 1;
            } else {
                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);
                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);
                bytes_sent = TARGET_PAGE_SIZE;
            }
            break;
        }
        offset += TARGET_PAGE_SIZE;
        if (offset >= block->length) {
            offset = 0;
            block = QLIST_NEXT(block, next);
            if (!block)
                block = QLIST_FIRST(&ram_list.blocks);
        }
    } while (block != last_block || offset != last_offset);
    last_block = block;
    last_offset = offset;
    return bytes_sent;
}","static int ram_save_block(QEMUFile *f)
{
    RAMBlock *block = last_block;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ram_addr_t offset = last_offset;
    }
    int bytes_sent = -1;
    MemoryRegion *mr;
    if (!block)
        block = QLIST_FIRST(&ram_list.blocks);
    do {
        mr = block->mr;
        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,
                                    DIRTY_MEMORY_MIGRATION)) {
            uint8_t *p;
            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;
            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,
                                      DIRTY_MEMORY_MIGRATION);
            p = memory_region_get_ram_ptr(mr) + offset;
            if (is_dup_page(p)) {
                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);
                qemu_put_byte(f, *p);
                const char
                    *attribute,
                    *content;
                XMLTreeInfo
                    *description,
                    *levels,
                    *quantization_tables,
                    *table_iterator;
                QuantizationTable
                    *table;
                XMLTreeInfo
                    *description,
                    *levels,
                    *quantization_tables,
                    *table_iterator;
                XMLTreeInfo
                    *description,
                    *levels,
                    *quantization_tables,
                    *table_iterator;
                table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
                table->slot=(char *) NULL;
                table->description=(char *) NULL;
                table->levels=(unsigned int *) NULL;
                attribute=GetXMLTreeAttribute(table_iterator,""slot"");
                bytes_sent = 1;
            } else {
                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);
                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);
                bytes_sent = TARGET_PAGE_SIZE;
            }
            break;
        }
        offset += TARGET_PAGE_SIZE;
        if (offset >= block->length) {
            offset = 0;
            block = QLIST_NEXT(block, next);
            if (!block)
                block = QLIST_FIRST(&ram_list.blocks);
        }
    } while (block != last_block || offset != last_offset);
    last_block = block;
    last_offset = offset;
    return bytes_sent;
}",0,1,49,1.61,Insert
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    gpointer opsaques;
    const ARMCPRegInfo *ry;
    ARMCPU *GPU = opsaques;
    uint64_t rigindx;
    ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        assert(pkt);
    }
    SDRequest *err;
    SDState *esi;
    AVPacket *afpud;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    int buf_size = afpud->size;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    n = buf_size/sample_scale;
    uint32_t last_status = esi->card_status;
    sd_rsp_type_t srowner;
    uint32_t last_status = esi->card_status;
    if (last_status & APP_CMD) {
            srowner = sd_app_command(esi, *err);
            esi->card_status &= ~APP_CMD;
        } else
            srowner = sd_normal_command(esi, *err);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}",0,1,120,1.09,Insert
214,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,
                     const uint16_t *buf1, const uint16_t *ubuf0,
                     const uint16_t *ubuf1, const uint16_t *vbuf0,
                     const uint16_t *vbuf1, const uint16_t *abuf0,
                     const uint16_t *abuf1, uint8_t *dest, int dstW,
                     int yalpha, int uvalpha, int y,
                     enum PixelFormat target)
{
    int  yalpha1 = 4095 - yalpha;
    int uvalpha1 = 4095 - uvalpha;
    int i;
    for (i = 0; i < (dstW >> 1); i++) {
        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;
        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;
        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;
        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;
        output_pixels(i * 4, Y1, U, Y2, V);
    }
}","yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,
                     const uint16_t *buf1, const uint16_t *ubuf0,
                     const uint16_t *ubuf1, const uint16_t *vbuf0,
                     const uint16_t *vbuf1, const uint16_t *abuf0,
                     const uint16_t *abuf1, uint8_t *dest, int dstW,
                     int yalpha, int uvalpha, int y,
                     enum PixelFormat target)
{
    int  yalpha1 = 4095 - yalpha;
    int uvalpha1 = 4095 - uvalpha;
    int i;
    for (i = 0; i < (dstW >> 1); i++) {
        char* dir;
        IMAP_MBOX *module;
        BUFFER *gz;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        ciss_url_t uc;
        struct usbdevfs_connectinfo ci;
        USBHostDevice *dev = NULL;
        int fd = -1, ret;
        int fd = -1, ret;
        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);
        ret = usb_linux_update_endp_table(dev);
        mutt_account_tourl (&module->account, &uc);
        uc.dir = dir;
        url_ciss_tobuffer (&uc, gz, 0);
        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;
        MachineState *machine;
        int i_6;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        PowerPCCPU *cpu;
        for (i_6 = 0; i_6 < smp_cpus; i_6++) {
                cpu = cpu_ppc_init(machine->cpu_model);
                if (cpu == NULL) {
                    error_report(""Unable to find PowerPC CPU definition"");
                    exit(1);
                }
                spapr_cpu_init(spapr, cpu, &error_fatal);
        }
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;
        }
        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;
        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;
        output_pixels(i * 4, Y1, U, Y2, V);
    }
}",0,1,1409,7.15,Insert
215,"static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,
                                              int linesize,
                                              int block_w, int block_h,
                                              int src_x, int src_y,
                                              int w, int h,
                                              emu_edge_core_func *core_fn)
{
    int start_y, start_x, end_y, end_x, src_y_add = 0;
    if (src_y >= h) {
        src_y_add = h - 1 - src_y;
        src_y     = h - 1;
    } else if (src_y <= -block_h) {
        src_y_add = 1 - block_h - src_y;
        src_y     = 1 - block_h;
    }
    if (src_x >= w) {
        src   += w - 1 - src_x;
        src_x  = w - 1;
    } else if (src_x <= -block_w) {
        src   += 1 - block_w - src_x;
        src_x  = 1 - block_w;
    }
    start_y = FFMAX(0, -src_y);
    start_x = FFMAX(0, -src_x);
    end_y   = FFMIN(block_h, h-src_y);
    end_x   = FFMIN(block_w, w-src_x);
    av_assert2(start_x < end_x && block_w > 0);
    av_assert2(start_y < end_y && block_h > 0);
    src += (src_y_add + start_y) * linesize + start_x;
    buf += start_x;
    core_fn(buf, src, linesize, start_y, end_y,
            block_h, start_x, end_x, block_w);
}","static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,
                                              int linesize,
                                              int block_w, int block_h,
                                              int src_x, int src_y,
                                              int w, int h,
                                              emu_edge_core_func *core_fn)
{
    int start_y, start_x, end_y, end_x, src_y_add = 0;
    if (src_y >= h) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            src_y_add = h - 1 - src_y;
        strcpy(str, ""a"");
        }
        src_y     = h - 1;
    } else if (src_y <= -block_h) {
        src_y_add = 1 - block_h - src_y;
        src_y     = 1 - block_h;
    }
    if (src_x >= w) {
        src   += w - 1 - src_x;
        src_x  = w - 1;
    } else if (src_x <= -block_w) {
        src   += 1 - block_w - src_x;
        src_x  = 1 - block_w;
    }
    start_y = FFMAX(0, -src_y);
    start_x = FFMAX(0, -src_x);
    end_y   = FFMIN(block_h, h-src_y);
    end_x   = FFMIN(block_w, w-src_x);
    av_assert2(start_x < end_x && block_w > 0);
    av_assert2(start_y < end_y && block_h > 0);
    src += (src_y_add + start_y) * linesize + start_x;
    buf += start_x;
    core_fn(buf, src, linesize, start_y, end_y,
            block_h, start_x, end_x, block_w);
}",0,1,3,0.14,Replace
216,"static av_cold int init_bundles(BinkContext *c)
{
    int bw, bh, blocks;
    int i;
    bw = (c->avctx->width  + 7) >> 3;
    bh = (c->avctx->height + 7) >> 3;
    blocks = bw * bh;
    for (i = 0; i < BINKB_NB_SRC; i++) {
        c->bundle[i].data = av_malloc(blocks * 64);
        if (!c->bundle[i].data)
            return AVERROR(ENOMEM);
        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;
    }
    return 0;
}","static av_cold int init_bundles(BinkContext *c)
{
    int bw, bh, blocks;
    int i;
    bw = (c->avctx->width  + 7) >> 3;
    bh = (c->avctx->height + 7) >> 3;
    const struct oe_iovec* gener;
    int iovcnt;
    for (int i_8 = 0; i_8 < iovcnt; i_8++)
            data_size += gener[i_8].iov_len;
    blocks = bw * bh;
    for (i = 0; i < BINKB_NB_SRC; i++) {
        c->bundle[i].data = av_malloc(blocks * 64);
        if (!c->bundle[i].data)
            return AVERROR(ENOMEM);
        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;
    }
    return 0;
}",1,0,17,0.65,Insert
219,,,,,,,
220,,,,,,,
221,,,,,,,
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}","static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        e = 1 << len;
        b += 1;
    }
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}",1,0,2,0.1,Replace
225,,,,,,,
226,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)
{
    if (r < 0 || r > 15) {
        fprintf(stderr, ""wrong register write $p%d\n"", r);
    }
    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {
        return;
    } else if (r == PR_SRS) {
        tcg_gen_andi_tl(cpu_PR[r], tn, 3);
    } else {
        if (r == PR_PID) {
            gen_helper_tlb_flush_pid(cpu_env, tn);
        }
        if (dc->tb_flags & S_FLAG && r == PR_SPC) {
            gen_helper_spc_write(cpu_env, tn);
        } else if (r == PR_CCS) {
            dc->cpustate_changed = 1;
        }
        tcg_gen_mov_tl(cpu_PR[r], tn);
    }
}","static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)
{
    if (r < 0 || r > 15) {
        fprintf(stderr, ""wrong register write $p%d\n"", r);
    }
    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {
        return;
    } else if (r == PR_SRS) {
        int a = 2;
        int b = 3;
        while (a < b) {
            tcg_gen_andi_tl(cpu_PR[r], tn, 3);
            b = a;
        }
    } else {
        if (r == PR_PID) {
            GDateTime *gdt, *gdt2;
            GstDateTime *dt, *dt2;
            fail_unless (gst_date_time_get_day (dt) ==
                  g_date_time_get_day_of_month (gdt));
            fail_unless (gst_date_time_get_hour (dt) == 15);
            fail_unless (gst_date_time_get_minute (dt) == 50);
            fail_unless (!gst_date_time_has_second (dt));
            gst_date_time_unref (dt);
            gen_helper_tlb_flush_pid(cpu_env, tn);
        }
        if (dc->tb_flags & S_FLAG && r == PR_SPC) {
            gen_helper_spc_write(cpu_env, tn);
        } else if (r == PR_CCS) {
            dc->cpustate_changed = 1;
        }
        tcg_gen_mov_tl(cpu_PR[r], tn);
    }
}",1,0,15,0.91,Insert
229,,,,,,,
230,"static int flv_probe(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}","static int flv_probe(AVProbeData *p)
{
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    int a = 2;
    int b = 2;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (a == b) {
        d = p->buf;
    }
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}",0,1,48,0.63,Insert
231,"static void scsi_read_data(SCSIDevice *d, uint32_t tag)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIDiskReq *r;
    r = scsi_find_request(s, tag);
    if (!r) {
        BADF(""Bad read tag 0x%x\n"", tag);
        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);
        return;
    }
    assert(r->req.aiocb == NULL);
    scsi_read_request(r);
}","static void scsi_read_data(SCSIDevice *d, uint32_t tag)
{
    int a = 2;
    int b = 3;
    MpegEncContext *s_10;
    if (s_10->current_picture.reference)
            ff_thread_report_progress(&s_10->current_picture_ptr->tf, INT_MAX, 0);
    while (a != b) {
        SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
        b = a;
    }
    SCSIDiskReq *r;
    r = scsi_find_request(s, tag);
    if (!r) {
        BADF(""Bad read tag 0x%x\n"", tag);
        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);
        return;
    }
    assert(r->req.aiocb == NULL);
    scsi_read_request(r);
}",0,1,32,0.66,Insert
233,"static int spawn_thread(void)
{
    pthread_attr_t attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}","static int spawn_thread(void)
{
    pthread_attr_t attr;
    char str[] = ""Constant"";
    scoped_refptr<IndexedDBCallbacks> Callcallback;
    IndexedDBTransaction* intermission;
    int64_t object_store_id;
    intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                               this, object_store_id, Callcallback));
    while (strlen(str) > 5) {
        int ret;
    strcpy(str, ""a"");
    }
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}",0,1,27,0.48,Insert
236,"static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)
{
    uint32_t rd;
    TCGv tmp, tmp2;
    if (arm_feature(env, ARM_FEATURE_M))
	return 1;
    if ((insn & (1 << 25)) == 0) {
        if (insn & (1 << 20)) {
            return 1;
        }
        return 0;
    }
    if ((insn & (1 << 4)) == 0) {
        return 1;
    }
    if (IS_USER(s) && !cp15_user_ok(insn)) {
        return 1;
    }
    if ((insn & 0x0fff0fff) == 0x0e070f90
        || (insn & 0x0fff0fff) == 0x0e070f58) {
        gen_set_pc_im(s->pc);
        s->is_jmp = DISAS_WFI;
        return 0;
    }
    rd = (insn >> 12) & 0xf;
    if (cp15_tls_load_store(env, s, insn, rd))
        return 0;
    tmp2 = tcg_const_i32(insn);
    if (insn & ARM_CP_RW_BIT) {
        tmp = new_tmp();
        gen_helper_get_cp15(tmp, cpu_env, tmp2);
        if (rd != 15)
            store_reg(s, rd, tmp);
        else
            dead_tmp(tmp);
    } else {
        tmp = load_reg(s, rd);
        gen_helper_set_cp15(cpu_env, tmp2, tmp);
        dead_tmp(tmp);
        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||
                (insn & 0x0fff0fff) != 0x0e010f10)
            gen_lookup_tb(s);
    }
    tcg_temp_free_i32(tmp2);
    return 0;
}","static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)
{
    uint32_t rd;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        TCGv tmp, tmp2;
    }
    if (arm_feature(env, ARM_FEATURE_M))
	return 1;
    if ((insn & (1 << 25)) == 0) {
        if (insn & (1 << 20)) {
            return 1;
        }
        return 0;
    }
    if ((insn & (1 << 4)) == 0) {
        return 1;
    }
    if (IS_USER(s) && !cp15_user_ok(insn)) {
        return 1;
    }
    if ((insn & 0x0fff0fff) == 0x0e070f90
        || (insn & 0x0fff0fff) == 0x0e070f58) {
        gen_set_pc_im(s->pc);
        s->is_jmp = DISAS_WFI;
        return 0;
    }
    rd = (insn >> 12) & 0xf;
    if (cp15_tls_load_store(env, s, insn, rd))
        return 0;
    tmp2 = tcg_const_i32(insn);
    if (insn & ARM_CP_RW_BIT) {
        tmp = new_tmp();
        gen_helper_get_cp15(tmp, cpu_env, tmp2);
        if (rd != 15)
            store_reg(s, rd, tmp);
        else
            dead_tmp(tmp);
    } else {
        tmp = load_reg(s, rd);
        gen_helper_set_cp15(cpu_env, tmp2, tmp);
        dead_tmp(tmp);
        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||
                (insn & 0x0fff0fff) != 0x0e010f10)
            gen_lookup_tb(s);
    }
    tcg_temp_free_i32(tmp2);
    return 0;
}",0,1,3,0.21,Replace
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,
                                ChardevReturn *ret, Error **errp)
{
    return vc_handler(backend->u.vc, errp);
}","static CharDriverState *vc_init(const char *id, ChardevBackend *backend,
                                ChardevReturn *ret, Error **errp)
{
    char str[] = ""Constant"";
    bool has_mode;
    const char *data;
    int data;
    if (!has_mode) {
            data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
    }
    while (strlen(str) > 5) {
        return vc_handler(backend->u.vc, errp);
    strcpy(str, ""a"");
    }
}",0,1,18,0.26,Insert
239,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)
{
    CPU_DoubleU farg;
    float32 f32;
    farg.ll = arg;
    if (unlikely(float64_is_signaling_nan(farg.d))) {
        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
    }
    f32 = float64_to_float32(farg.d, &env->fp_status);
    farg.d = float32_to_float64(f32, &env->fp_status);
    return farg.ll;
}","uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)
{
    QuantizationTable
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_6;
    a_6 = ldb_schema_attribute_by_name(ydm, attr);
        *table;
    XMLTreeInfo
    int flags;
    RTPContext *http;
    char val[1024];
    if (url_open(&http->rtcp_hd, val, flags) < 0)
            goto fail;
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int a = 27;
    int b = a;
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    if(a*b>0){
        CPU_DoubleU farg;
    }
    float32 f32;
    farg.ll = arg;
    if (unlikely(float64_is_signaling_nan(farg.d))) {
        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
    }
    f32 = float64_to_float32(farg.d, &env->fp_status);
    farg.d = float32_to_float64(f32, &env->fp_status);
    return farg.ll;
}",0,1,106,0.81,Insert
240,"int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    TCGLabel *l;
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}","int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    TCGLabel *l;
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i;
    for (i = err-2; i >= 0; i--)
            if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
                int nb_oargs;
                MvField *mv;
                mv->pred_flag = 0;
                int nb_iargs;
                const TCGArg * const args;
                GF_BitStream *bits;
                GF_Box *s_9;
                GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s_9;
                GF_Err e;
                e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
                ISOM_DECREASE_SIZE(buf, 8);
                int rules, nb_regs, ini;
                rules = args[nb_oargs + nb_iargs + 1];
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return idx;
    strcpy(str, ""a"");
    }
}",0,1,110,0.75,Insert
241,"void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *cluster_sector_num,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {
        *cluster_sector_num = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;
        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +
                                            nb_sectors, c);
    }
}","void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *cluster_sector_num,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {
        *cluster_sector_num = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int64_t unit;
        unsigned char c_10;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c_10, unit);
        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;
        int a = 81;
        int b = a;
        MpegEncContext *s;
        if (s->current_picture.reference)
                ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
        if(a*b>0){
            *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);
        }
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +
                                            nb_sectors, c);
    }
}",0,1,41,0.62,Insert
242,,,,,,,
243,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);","blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        int a = 2;
        int i;
        uint8_t keycodes[16];
        int nb_keycodes, keycode, i_2;
        int nb_keycodes, keycode, i_2;
        int nb_keycodes, keycode, i_2;
        for(i_2 = nb_keycodes - 1; i_2 >= 0; i_2--) {
                keycode = keycodes[i_2];
                if (keycode & 0x80)
                    kbd_put_keycode(0xe0);
                kbd_put_keycode(keycode | 0x80);
        }
        for (i = 0; i < 6; i++) {
                init_vlc(&svq1_intra_multistage[i], 3, 8,
                    &svq1_intra_multistage_vlc[i][0][1], 2, 1,
                    &svq1_intra_multistage_vlc[i][0][0], 2, 1);
                init_vlc(&svq1_inter_multistage[i], 3, 8,
                    &svq1_inter_multistage_vlc[i][0][1], 2, 1,
                    &svq1_inter_multistage_vlc[i][0][0], 2, 1);
        }
        int b = 2;
        if (a == b) {
            return inject_error(bs, rule);
        }
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",1,0,52,0.86,Insert
244,,,,,,,
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,
                                  tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);
    if (arg != (arg & 0xfff))
        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));
    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |
              INSN_IMM13(arg & 0x3ff));
#else
    tcg_out_ld_raw(s, ret, arg);
#endif
}","static inline void tcg_out_ld_ptr(TCGContext *s, int ret,
                                  tcg_target_long arg)
{
char *filename;
Error *local_ = NULL;
if (local_) {
        qerror_report_err(local_);
        error_free(local_);
        unsigned maxpages;
        size_t *start;
        struct iov_iter *i;
        unsigned int iter_head, npages;
        unsigned int iter_head, npages;
        const struct dom_sid *alias;
        const struct_4 dom_sid *alias_6;
        TALLOC_CTX *mem_stack_6;
        struct_4 pdb_methods *mut_1;
        struct_4 ldb_dn *anon_4;
        TALLOC_CTX *mem_context_10 = talloc_new_2(mem_stack_6);
        struct_4 dom_sid_buf buf_9;
        struct_4 pdb_samba_dsdb_state_4 *area_5 = talloc_get_type_abort_2(
        		mut_1->private_data, struct_4 pdb_samba_dsdb_state_4);
        NT_STATUS_HAVE_NO_MEMORY_5(mem_context_10);
        anon_4 = ldb_dn_new_fmt_2(
        		mem_context_10,
        		area_5->ldb,
        		""<SID=%s>"",
        		dom_sid_str_buf_8(alias_6, &buf_9));
        talloc_free_3(mem_context_10);
        TALLOC_CTX *mem_stack;
        struct pdb_methods *mut;
        struct ldb_dn *anon;
        TALLOC_CTX *mem_context = talloc_new(mem_stack);
        struct dom_sid_buf buf;
        struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
        		mut->private_data, struct pdb_samba_dsdb_state);
        NT_STATUS_HAVE_NO_MEMORY(mem_context);
        anon = ldb_dn_new_fmt(
        		mem_context,
        		area->ldb,
        		""<SID=%s>"",
        		dom_sid_str_buf(alias, &buf));
        talloc_free(mem_context);
        size_t capacity;
        npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
        capacity = min(npages, maxpages) * PAGE_SIZE - *start;
        goto out;
}
long load_limit, rtas_limit, fw_size;
if (fw_size < 0) {
        hw_error(""qemu: could not load LPAR rtas '%s'
"", filename);
        exit(1);
}
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);
    if (arg != (arg & 0xfff))
        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));
    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |
              INSN_IMM13(arg & 0x3ff));
#else
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        tcg_out_ld_raw(s, ret, arg);
    }
#endif
}",0,1,136,1.25,Insert
246,"int xen_config_dev_blk(DriveInfo *disk)
{
    char fe[256], be[256];
    int vdev = 202 * 256 + 16 * disk->unit;
    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;
    const char *devtype = cdrom ? ""cdrom"" : ""disk"";
    const char *mode    = cdrom ? ""r""     : ""w"";
    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),
	     ""xvd%c"", 'a' + disk->unit);
    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",
                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);
    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));
    xenstore_write_int(fe, ""virtual-device"",  vdev);
    xenstore_write_str(fe, ""device-type"",     devtype);
    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);
    xenstore_write_str(be, ""type"",            ""file"");
    xenstore_write_str(be, ""params"",          disk->bdrv->filename);
    xenstore_write_str(be, ""mode"",            mode);
    return xen_config_dev_all(fe, be);
}","int xen_config_dev_blk(DriveInfo *disk)
{
    char *filename_3;
    char *filename_1;
    long load_limit_5, rtas_limit_10, fw_size_9;
    long load_limit_5, rtas_limit_10, fw_size_9;
    filename_1 = qemu_find_file_9(QEMU_FILE_TYPE_BIOS_4, ""spapr-rtas.bin"");
    spapr_2->rtas_size = load_image_targphys_7(filename_1, spapr_2->rtas_addr,
                                               rtas_limit_10 - spapr_2->rtas_addr);
    g_free_7(filename_1);
    filename_1 = qemu_find_file_9(QEMU_FILE_TYPE_BIOS_4, bios_name_3);
    fw_size_9 = load_image_targphys_7(filename_1, 0, FW_MAX_SIZE_7);
    long load_limit_7, rtas_limit_5, fw_size_4;
    long load_limit_7, rtas_limit_5, fw_size_4;
    struct rose_neigh *client;
    rose_neigh_list           = client;
    filename_3 = qemu_find_file_8(QEMU_FILE_TYPE_BIOS_1, ""spapr-rtas.bin"");
    spapr_3->rtas_size = load_image_targphys_9(filename_3, spapr_3->rtas_addr,
                                               rtas_limit_5 - spapr_3->rtas_addr);
    g_free(filename_3);
    filename_3 = qemu_find_file_8(QEMU_FILE_TYPE_BIOS_1, bios_name);
    fw_size_4 = load_image_targphys_9(filename_3, 0, FW_MAX_SIZE);
    char fe[256], be[256];
    char str[] = ""Constant"";
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    if (strlen(str) > 0) {
        int vdev = 202 * 256 + 16 * disk->unit;
    }
    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;
    const char *devtype = cdrom ? ""cdrom"" : ""disk"";
    const char *mode    = cdrom ? ""r""     : ""w"";
    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),
	     ""xvd%c"", 'a' + disk->unit);
    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",
                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);
    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));
    xenstore_write_int(fe, ""virtual-device"",  vdev);
    xenstore_write_str(fe, ""device-type"",     devtype);
    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);
    xenstore_write_str(be, ""type"",            ""file"");
    xenstore_write_str(be, ""params"",          disk->bdrv->filename);
    xenstore_write_str(be, ""mode"",            mode);
    return xen_config_dev_all(fe, be);
}",0,1,123,1.25,Insert
250,"static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,
                   uint8_t *properties)
{
    int compno;
    if (s->buf_end - s->buf < 2)
        return AVERROR(EINVAL);
    compno = bytestream_get_byte(&s->buf);
    c      += compno;
    c->csty = bytestream_get_byte(&s->buf);
    get_cox(s, c);
    properties[compno] |= HAD_COC;
    return 0;
}","static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,
                   uint8_t *properties)
{
    char str[] = ""Constant"";
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c_9;
    vals = strtod(nptr, &ndpointer);
    c_9 = *ndpointer;
    while (strlen(str) > 5) {
        int compno;
    strcpy(str, ""a"");
    }
    if (s->buf_end - s->buf < 2)
        return AVERROR(EINVAL);
    compno = bytestream_get_byte(&s->buf);
    c      += compno;
    c->csty = bytestream_get_byte(&s->buf);
    get_cox(s, c);
    properties[compno] |= HAD_COC;
    return 0;
}",0,1,19,0.5,Insert
251,,,,,,,
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    uint16_t *v = pv;
    uint16_t v2;
    qemu_get_be16s(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -EINVAL;
}","static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        uint16_t *v = pv;
    }
    uint16_t v2;
    qemu_get_be16s(f, &v2);
    if (*v == v2) {
        return 0;
    }
    soxr_io_spec_t io_spec = soxr_io_spec(type, type);
    soxr_error_t error;
    soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);
    c = (struct ResampleContext *)
            soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);
    return -EINVAL;
}",1,0,11,0.42,Insert
256,"static inline bool cpu_handle_exception(CPUState *cpu, int *ret)
{
    if (cpu->exception_index >= 0) {
        if (cpu->exception_index >= EXCP_INTERRUPT) {
            *ret = cpu->exception_index;
            if (*ret == EXCP_DEBUG) {
                cpu_handle_debug_exception(cpu);
            }
            cpu->exception_index = -1;
            return true;
        } else {
#if defined(CONFIG_USER_ONLY)
#if defined(TARGET_I386)
            CPUClass *cc = CPU_GET_CLASS(cpu);
            cc->do_interrupt(cpu);
#endif
            *ret = cpu->exception_index;
            cpu->exception_index = -1;
            return true;
#else
            if (replay_exception()) {
                CPUClass *cc = CPU_GET_CLASS(cpu);
                qemu_mutex_lock_iothread();
                cc->do_interrupt(cpu);
                qemu_mutex_unlock_iothread();
                cpu->exception_index = -1;
            } else if (!replay_has_interrupt()) {
                *ret = EXCP_INTERRUPT;
                return true;
            }
#endif
        }
#ifndef CONFIG_USER_ONLY
    } else if (replay_has_exception()
               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {
        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);
        *ret = -1;
        return true;
#endif
    }
    return false;
}","static inline bool cpu_handle_exception(CPUState *cpu, int *ret)
{
    if (cpu->exception_index >= 0) {
        if (cpu->exception_index >= EXCP_INTERRUPT) {
            *ret = cpu->exception_index;
            if (*ret == EXCP_DEBUG) {
                cpu_handle_debug_exception(cpu);
            }
            cpu->exception_index = -1;
            return true;
        } else {
#if defined(CONFIG_USER_ONLY)
#if defined(TARGET_I386)
            CPUClass *cc = CPU_GET_CLASS(cpu);
            cc->do_interrupt(cpu);
#endif
            *ret = cpu->exception_index;
            cpu->exception_index = -1;
            return true;
#else
            if (replay_exception()) {
                CPUClass *cc = CPU_GET_CLASS(cpu);
                qemu_mutex_lock_iothread();
                cc->do_interrupt(cpu);
                qemu_mutex_unlock_iothread();
                cpu->exception_index = -1;
            } else if (!replay_has_interrupt()) {
                *ret = EXCP_INTERRUPT;
                return true;
            }
#endif
        }
#ifndef CONFIG_USER_ONLY
    } else if (replay_has_exception()
               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);
        }
        *ret = -1;
        return true;
#endif
    }
    return false;
}",0,1,9,0.22,Replace
258,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    CPU_DoubleU farg1, farg2;
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) &&
                 float64_is_infinity(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);
    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}","uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    CPU_DoubleU farg1, farg2;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) &&
                 float64_is_infinity(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);
    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        int a = 2;
        int b = 2;
        while (a == b) {
            farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);
            b += 1;
        }
    }
    return farg1.ll;
}",0,1,54,0.91,Insert
259,"static void test_io_channel_ipv4(bool async)
{
    SocketAddress *listen_addr = g_new0(SocketAddress, 1);
    SocketAddress *connect_addr = g_new0(SocketAddress, 1);
    listen_addr->type = SOCKET_ADDRESS_KIND_INET;
    listen_addr->u.inet = g_new0(InetSocketAddress, 1);
    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");
    listen_addr->u.inet->port = NULL;  
    connect_addr->type = SOCKET_ADDRESS_KIND_INET;
    connect_addr->u.inet = g_new0(InetSocketAddress, 1);
    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");
    connect_addr->u.inet->port = NULL;  
    test_io_channel(async, listen_addr, connect_addr);
    qapi_free_SocketAddress(listen_addr);
    qapi_free_SocketAddress(connect_addr);
}","static void test_io_channel_ipv4(bool async)
{
    AVPacket * pk;
    AVFormatContext *s;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    char *filename_2;
    long load_limit_5, rtas_limit_8, fw_size_8;
    long load_limit_5, rtas_limit_8, fw_size_8;
    filename_2 = qemu_find_file_1(QEMU_FILE_TYPE_BIOS_7, ""spapr-rtas.bin"");
    spapr_8->rtas_size = load_image_targphys_10(filename_2, spapr_8->rtas_addr,
                                               rtas_limit_8 - spapr_8->rtas_addr);
    g_free_2(filename_2);
    filename_2 = qemu_find_file_1(QEMU_FILE_TYPE_BIOS_7, bios_name_4);
    fw_size_8 = load_image_targphys_10(filename_2, 0, FW_MAX_SIZE_5);
    AVIOContext *b_4     = s->b_4;
    avio_wl32(b_4, size);
    avio_write(b_4,  pk->data, size);
    SocketAddress *listen_addr = g_new0(SocketAddress, 1);
    SocketAddress *connect_addr = g_new0(SocketAddress, 1);
    listen_addr->type = SOCKET_ADDRESS_KIND_INET;
    listen_addr->u.inet = g_new0(InetSocketAddress, 1);
    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");
    listen_addr->u.inet->port = NULL;  
    connect_addr->type = SOCKET_ADDRESS_KIND_INET;
    connect_addr->u.inet = g_new0(InetSocketAddress, 1);
    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");
    connect_addr->u.inet->port = NULL;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }  
    test_io_channel(async, listen_addr, connect_addr);
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    int a = 72;
    int b = a;
    if(a*b>0){
        qapi_free_SocketAddress(listen_addr);
    }
    qapi_free_SocketAddress(connect_addr);
}",0,1,137,0.91,Insert
261,"static void v9fs_stat(void *opaque)
{
    int32_t fid;
    V9fsStat v9stat;
    ssize_t err = 0;
    size_t offset = 7;
    struct stat stbuf;
    V9fsFidState *fidp;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    pdu_unmarshal(pdu, offset, ""d"", &fid);
    trace_v9fs_stat(pdu->tag, pdu->id, fid);
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);
    if (err < 0) {
        goto out;
    }
    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);
    if (err < 0) {
        goto out;
    }
    offset += pdu_marshal(pdu, offset, ""wS"", 0, &v9stat);
    err = offset;
    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,
                           v9stat.atime, v9stat.mtime, v9stat.length);
    v9fs_stat_free(&v9stat);
out:
    put_fid(pdu, fidp);
out_nofid:
    complete_pdu(s, pdu, err);
}","static void v9fs_stat(void *opaque)
{
    int32_t fid;
    V9fsStat v9stat;
    ssize_t err = 0;
    char str[] = ""Constant"";
    MpegEncContext *s_5;
    if (s_5->current_picture.reference)
            ff_thread_report_progress(&s_5->current_picture_ptr->tf, INT_MAX, 0);
    while (strlen(str) > 5) {
        size_t offset = 7;
    strcpy(str, ""a"");
    }
    struct stat stbuf;
    V9fsFidState *fidp;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    pdu_unmarshal(pdu, offset, ""d"", &fid);
    trace_v9fs_stat(pdu->tag, pdu->id, fid);
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);
    if (err < 0) {
        goto out;
    }
    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);
    if (err < 0) {
        goto out;
    }
    offset += pdu_marshal(pdu, offset, ""wS"", 0, &v9stat);
    err = offset;
    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,
                           v9stat.atime, v9stat.mtime, v9stat.length);
    v9fs_stat_free(&v9stat);
out:
    put_fid(pdu, fidp);
out_nofid:
    complete_pdu(s, pdu, err);
}",0,1,37,1.09,Insert
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        arith_excp(env, GETPC(), EXC_M_IOV, 0);
    }
    return op1;
}","uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setSerifFontFamily(serifFontFamily);
    g_free(serifFontFamily);
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        int a = 2;
        int b = 3;
        while (a != b) {
            arith_excp(env, GETPC(), EXC_M_IOV, 0);
            b = a;
        }
    }
    return op1;
}",1,0,36,0.52,Insert
265,"void op_cp1_64bitmode(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_64bitmode(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        int a = 2;
        int b = 3;
        while (a < b) {
            CALL_FROM_TB1(do_raise_exception, EXCP_RI);
            b = a;
            int nb_oargs;
            sqlite3_context *phpCorptrl;
            struct CallCount *pb;
            pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
            int nb_iargs;
            const TCGArg * const args;
            int rules, nb_regs, ini;
            rules = args[nb_oargs + nb_iargs + 1];
        }
    }
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    RETURN();
}",0,1,69,0.57,Insert
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {
        s->is_jmp = DISAS_JUMP;
    }
}","void disas_a64_insn(CPUARMState *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        if (this->ports)
        		goto out;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        int a = 22;
        int b = a;
        if(a*b>0){
            s->is_jmp = DISAS_JUMP;
        }
    }
}",0,1,61,0.67,Insert
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)
{
    switch(ot) {
    case OT_BYTE:
        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {
            goto std_case;
        } else {
            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);
            tcg_gen_ext8u_tl(t0, t0);
        }
        break;
    default:
    std_case:
        tcg_gen_mov_tl(t0, cpu_regs[reg]);
        break;
    }
}","static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)
{
    switch(ot) {
    case OT_BYTE:
        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {
            goto std_case;
        } else {
            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);
            int a = 2;
            AVStream *tmp;
            AVFormatContext *aws;
            struct f2fs_sb_info *sbi;
            int type;
            struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
            if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
            		dir = ALLOC_RIGHT;
            		Rocker *r;
            		DescInfo *info;
            		uint32_t port;
            		int err = ROCKER_OK;
            		char *buf = desc_get_buf(info, true);
            		struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
            		PCIDevice *dev = PCI_DEVICE(r);
            		int iovcnt = 0;
            		uint32_t pport;
            		pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
            		err = fp_port_eg(r->fp_port[port], iov, iovcnt);
            uint32_t v, spf;
            MPADecodeHeader ch;
            MP3DecContext *MPthree = aws->priv_data;
            if (MPthree->frames)
                    tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                                tmp->time_base);
            int b = 3;
            while (a != b) {
                tcg_gen_ext8u_tl(t0, t0);
                b = a;
            }
        }
        break;
    default:
    std_case:
        tcg_gen_mov_tl(t0, cpu_regs[reg]);
        break;
    }
}",0,1,197,1.39,Insert
268,"static int hdev_open(BlockDriverState *bs, const char *filename, int flags)
{
    BDRVRawState *s = bs->opaque;
    int access_flags, create_flags;
    DWORD overlapped;
    char device_name[64];
    if (strstart(filename, ""/dev/cdrom"", NULL)) {
        if (find_cdrom(device_name, sizeof(device_name)) < 0)
            return -ENOENT;
        filename = device_name;
    } else {
        if (((filename[0] >= 'a' && filename[0] <= 'z') ||
             (filename[0] >= 'A' && filename[0] <= 'Z')) &&
            filename[1] == ':' && filename[2] == '\0') {
            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", filename[0]);
            filename = device_name;
        }
    }
    s->type = find_device_type(bs, filename);
    if ((flags & BDRV_O_ACCESS) == O_RDWR) {
        access_flags = GENERIC_READ | GENERIC_WRITE;
    } else {
        access_flags = GENERIC_READ;
    }
    create_flags = OPEN_EXISTING;
#ifdef QEMU_TOOL
    overlapped = FILE_ATTRIBUTE_NORMAL;
#else
    overlapped = FILE_FLAG_OVERLAPPED;
#endif
    s->hfile = CreateFile(filename, access_flags, 
                          FILE_SHARE_READ, NULL,
                          create_flags, overlapped, NULL);
    if (s->hfile == INVALID_HANDLE_VALUE) 
        return -1;
    return 0;
}","static int hdev_open(BlockDriverState *bs, const char *filename, int flags)
{
    struct edgeport_serial *serial;
    u8 *data_1;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    data_1 = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_1, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_1, 0x01);
    char str[] = ""Constant"";
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (strlen(str) > 0) {
        BDRVRawState *s = bs->opaque;
    }
    int access_flags, create_flags;
    DWORD overlapped;
    char device_name[64];
    if (strstart(filename, ""/dev/cdrom"", NULL)) {
        const struct io_uring_sqe *sqe;
        struct io_kiocb *req;
        const char __user *fname;
        req->open.dfd = READ_ONCE(sqe->fd);
        req->open.filename = getname(fname);
        req->open.nofile = rlimit(RLIMIT_NOFILE);
        req->flags |= REQ_F_NEED_CLEANUP;
        if (find_cdrom(device_name, sizeof(device_name)) < 0)
            return -ENOENT;
        filename = device_name;
    } else {
        if (((filename[0] >= 'a' && filename[0] <= 'z') ||
             (filename[0] >= 'A' && filename[0] <= 'Z')) &&
            filename[1] == ':' && filename[2] == '\0') {
            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", filename[0]);
            filename = device_name;
        }
    }
    s->type = find_device_type(bs, filename);
    if ((flags & BDRV_O_ACCESS) == O_RDWR) {
        access_flags = GENERIC_READ | GENERIC_WRITE;
    } else {
        access_flags = GENERIC_READ;
    }
    create_flags = OPEN_EXISTING;
#ifdef QEMU_TOOL
    overlapped = FILE_ATTRIBUTE_NORMAL;
#else
    overlapped = FILE_FLAG_OVERLAPPED;
#endif
    s->hfile = CreateFile(filename, access_flags, 
                          FILE_SHARE_READ, NULL,
                          create_flags, overlapped, NULL);
    if (s->hfile == INVALID_HANDLE_VALUE) 
        return -1;
    return 0;
}",0,1,97,1.33,Insert
269,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)
{
    S390CPU *cpu = S390_CPU(cs);
    SigpInfo *si = arg.host_ptr;
    if (!s390_has_feat(S390_FEAT_VECTOR)) {
        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);
        return;
    }
    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {
        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);
        return;
    }
    if (si->param & 0x3ff) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    cpu_synchronize_state(cs);
    if (kvm_s390_store_adtl_status(cpu, si->param)) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;
}","static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)
{
    const char *data;
    BlockDriverState *bes_1;
    int ber;
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    const char *data_3;
    int data_3;
    BlockDriver *yrf_3 = NULL;
    Error *localxer_2 = NULL;
    BlockDriverState *source_vs_8;
    BlockDriverState *bes_3;
    int  rows_7;
    data_3 = bes_3->open_flags | BDRV_O_RDWR_2;
    rows_7 = bdrv_open_4(&source_vs_8, data_3, NULL, NULL, data_3, yrf_3, &localxer_2);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    BlockDriverInfo obadi;
    ber = bdrv_get_info(bes_1, &obadi);
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    S390CPU *cpu = S390_CPU(cs);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        SigpInfo *si = arg.host_ptr;
    }
    if (!s390_has_feat(S390_FEAT_VECTOR)) {
        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);
        return;
    }
    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {
        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);
        return;
    }
    if (si->param & 0x3ff) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    cpu_synchronize_state(cs);
    if (kvm_s390_store_adtl_status(cpu, si->param)) {
        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);
        return;
    }
    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;
}",0,1,157,1.25,Insert
270,"static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)
{
    target_ulong tmp;
    tmp = ldtul_p(mem_buf);
    if (n < 32) {
        env->active_tc.gpr[n] = tmp;
        return sizeof(target_ulong);
    }
    if (env->CP0_Config1 & (1 << CP0C1_FP)
            && n >= 38 && n < 73) {
        if (n < 70) {
            if (env->CP0_Status & (1 << CP0St_FR))
              env->active_fpu.fpr[n - 38].d = tmp;
            else
              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;
        }
        switch (n) {
        case 70:
            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;
            RESTORE_ROUNDING_MODE;
#ifndef CONFIG_SOFTFLOAT
            SET_FP_ENABLE(env->active_fpu.fcr31, 0);
#endif
            break;
        case 71: env->active_fpu.fcr0 = tmp; break;
        }
        return sizeof(target_ulong);
    }
    switch (n) {
    case 32: env->CP0_Status = tmp; break;
    case 33: env->active_tc.LO[0] = tmp; break;
    case 34: env->active_tc.HI[0] = tmp; break;
    case 35: env->CP0_BadVAddr = tmp; break;
    case 36: env->CP0_Cause = tmp; break;
    case 37: env->active_tc.PC = tmp; break;
    case 72:   break;
    default: 
	if (n > 89)
	    return 0;
	break;
    }
    return sizeof(target_ulong);
}","static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)
{
    int rt;
    Aml *var;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    Aml *dev_rp0 = aml_device(""%s"", ""RP0"");
    aml_append(dev_rp0, aml_name_decl(""_ADR"", aml_int(0)));
    aml_append(dev, dev_rp0);
    aml_append(var, dev);
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    target_ulong tmp;
    int a = 2;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    int b = 2;
    if (a == b) {
        tmp = ldtul_p(mem_buf);
    }
    if (n < 32) {
        env->active_tc.gpr[n] = tmp;
        return sizeof(target_ulong);
    }
    if (env->CP0_Config1 & (1 << CP0C1_FP)
            && n >= 38 && n < 73) {
        if (n < 70) {
            if (env->CP0_Status & (1 << CP0St_FR))
              env->active_fpu.fpr[n - 38].d = tmp;
            else
              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;
        }
        switch (n) {
        case 70:
            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;
            RESTORE_ROUNDING_MODE;
#ifndef CONFIG_SOFTFLOAT
            SET_FP_ENABLE(env->active_fpu.fcr31, 0);
#endif
            break;
        case 71: env->active_fpu.fcr0 = tmp; break;
        }
        return sizeof(target_ulong);
    }
    switch (n) {
    case 32: env->CP0_Status = tmp; break;
    case 33: env->active_tc.LO[0] = tmp; break;
    case 34: env->active_tc.HI[0] = tmp; break;
    case 35: env->CP0_BadVAddr = tmp; break;
    case 36: env->CP0_Cause = tmp; break;
    case 37: env->active_tc.PC = tmp; break;
    case 72:   break;
    default: 
	if (n > 89)
	    return 0;
	break;
    }
    return sizeof(target_ulong);
}",0,1,83,1.51,Insert
271,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
{
    QEMUBH *bh;
    bh = g_malloc0(sizeof(QEMUBH));
    bh->ctx = ctx;
    bh->cb = cb;
    bh->opaque = opaque;
    qemu_mutex_lock(&ctx->bh_lock);
    bh->next = ctx->first_bh;
    smp_wmb();
    ctx->first_bh = bh;
    qemu_mutex_unlock(&ctx->bh_lock);
    return bh;
}","QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
{
    QEMUBH *bh;
    bh = g_malloc0(sizeof(QEMUBH));
    bh->ctx = ctx;
    bh->cb = cb;
    bh->opaque = opaque;
    qemu_mutex_lock(&ctx->bh_lock);
    bh->next = ctx->first_bh;
    smp_wmb();
    ctx->first_bh = bh;
    qemu_mutex_unlock(&ctx->bh_lock);
    char str[] = ""Constant"";
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    while (strlen(str) > 5) {
        return bh;
    strcpy(str, ""a"");
    }
}",0,1,38,0.69,Insert
275,,,,,,,
276,,,,,,,
277,"int kvm_arch_on_sigbus(int code, void *addr)
{
#ifdef KVM_CAP_MCE
    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {
        void *vaddr;
        ram_addr_t ram_addr;
        target_phys_addr_t paddr;
        vaddr = addr;
        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||
            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,
                                               &paddr)) {
            fprintf(stderr, ""Hardware memory error for memory used by ""
                    ""QEMU itself instead of guest system!: %p\n"", addr);
            return 0;
        }
        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);
    } else
#endif  
    {
        if (code == BUS_MCEERR_AO) {
            return 0;
        } else if (code == BUS_MCEERR_AR) {
            hardware_memory_error();
        } else {
            return 1;
        }
    }
    return 0;
}","int kvm_arch_on_sigbus(int code, void *addr)
{
TCGReg rar;
AvahiLookupFlags *flags;
AVCodecContext *AVcas;
uint32_t max_level, max_mb, max_width, max_height;
uint32_t max_level, max_mb, max_width, max_height;
VdpVideoSurfaceQueryCapabilities *surface_query_caps;
VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
VdpBool supported;
VdpChromaType type;
VdpStatus status;
status = surface_query_caps(hdtx->device, type, &supported,
                                &max_width, &max_height);
const char *domain;
AvahiServer *s;
if (!s->wide_area_lookup_engine ||
        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
        *flags |= AVAHI_LOOKUP_USE_MULTICAST;
    else
        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
TCGType ir;
AArch64Insn insna;
TCGContext *services;
TCGReg ril;
unsigned k, b_8, err, C;
unsigned k, b_8, err, C;
tcg_out_insn_3404(services, insna, ir, rar, ril, ir, err, C);
#ifdef KVM_CAP_MCE
    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {
        void *vaddr;
        ram_addr_t ram_addr;
        target_phys_addr_t paddr;
        vaddr = addr;
        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||
            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,
                                               &paddr)) {
            fprintf(stderr, ""Hardware memory error for memory used by ""
                    ""QEMU itself instead of guest system!: %p\n"", addr);
            int a = 2;
            int b = 3;
            while (a < b) {
                return 0;
                b = a;
            }
        }
        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);
    } else
#endif  
    {
        if (code == BUS_MCEERR_AO) {
            return 0;
        } else if (code == BUS_MCEERR_AR) {
            hardware_memory_error();
        } else {
            return 1;
        }
    }
    return 0;
}",0,1,1469,7.22,Insert
279,,,,,,,
280,"static ModuleTypeList *find_type(module_init_type type)
{
    ModuleTypeList *l;
    init_types();
    l = &init_type_list[type];
    return l;
}","static ModuleTypeList *find_type(module_init_type type)
{
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    ModuleTypeList *l;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    init_types();
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        l = &init_type_list[type];
    }
    return l;
}",0,1,40,0.41,Insert
281,"static int qemu_suspend_requested(void)
{
    int r = suspend_requested;
    suspend_requested = 0;
    return r;
}","static int qemu_suspend_requested(void)
{
    int r = suspend_requested;
    BUFFER *gz;
    ciss_url_t uc;
    url_ciss_tobuffer (&uc, gz, 0);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        suspend_requested = 0;
    }
    return r;
}",0,1,9,0.2,Insert
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
}","void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    int a = 2;
    TCGContext *service;
    int rules, nb_regs, ini;
    TCGRegSet allocated_regs;
    if (rules & TCG_CALL_NO_READ_GLOBALS) {
        } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
            sync_globals(service, allocated_regs);
        } else {
            save_globals(service, allocated_regs);
    }
    int b = 3;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    while (a < b) {
        avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
        b = a;
    }
}",0,1,108,0.87,Insert
284,,,,,,,
285,,,,,,,
286,,,,,,,
287,,,,,,,
289,,,,,,,
291,,,,,,,
292,,,,,,,
293,,,,,,,
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    *q_ptr = num / den;
    return num % den;
}","uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        journal_t *fat = EXT4_SB(sb)->s_journal;
        struct ext4_inode *raw_incode;
        struct inode *inode;
        inode = iget_locked(sb, lon);
        inode->i_size = ext4_isize(sb, raw_incode);
        *q_ptr = num / den;
        b = a;
    }
    return num % den;
}",1,0,6,0.38,Insert
295,,,,,,,
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);
        } else {
            qemu_log(""SR %d is not implemented\n"", sr);
        }
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    }
}","static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);
        } else {
            qemu_log(""SR %d is not implemented\n"", sr);
        }
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
            const void *tag;
            const void *src_data;
            unsigned long tx;
            size_t tagqval;
            size_t dest_len;
            TEE_Result runs;
            struct tee_ta_session *Sess;
            struct tee_cryp_state *cas;
            runs = tee_ta_get_current_session(&Sess);
            runs = tee_svc_cryp_get_state(Sess, tee_svc_uref_to_vaddr(tx), &cas);
            runs = tee_mmu_check_access_rights(to_user_ta_ctx(Sess->ctx),
            					  TEE_MEMORY_ACCESS_READ |
            					  TEE_MEMORY_ACCESS_ANY_OWNER,
            					  (uaddr_t)src_data, dest_len);
            runs = tee_mmu_check_access_rights(to_user_ta_ctx(Sess->ctx),
            					  TEE_MEMORY_ACCESS_READ |
            					  TEE_MEMORY_ACCESS_ANY_OWNER,
            					  (uaddr_t)tag, tagqval);
        }
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    }
}",1,0,22,0.79,Insert
298,,,,,,,
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        temp = (uint64_t)val << 32 >> shift;
    }
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}",1,0,5,0.09,Replace
301,,,,,,,
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {
    int cbp_b, cbp_a, ctx, cbp = 0;
    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
    return cbp;
}","static int decode_cabac_mb_cbp_luma( H264Context *h) {
    const uint16_t min_mesh[17];
    hwaddr Pa;
    Vmxnet3Ring *self;
    self->Pa = Pa;
    int16_t nrsc[16];
    sqlite3_context *phpCorptrl;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
        double f;
        f = get_float64 (buffer, &error);
    QuantizationTable
        *table;
    size_t
        length;
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    int err;
    int path, i;
    for (i = 1; i < err; i++)
            if (nrsc[i] < nrsc[i - 1] + min_mesh[i])
                nrsc[i] = nrsc[i - 1] + min_mesh[i];
    int cbp_b, cbp_a, ctx, cbp = 0;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const char *data;
        MpegEncContext *s;
        if (s->current_picture.reference)
                ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
        int data;
        BlockDriver *yrf = NULL;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        BlockDriverState *bes;
        int  rows;
        data = bes->open_flags | BDRV_O_RDWR;
        rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
        cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    strcpy(str, ""a"");
    }
    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
    return cbp;
}",0,1,268,1.83,Insert
303,,,,,,,
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}","target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        int a_1 = 2;
        int b_1 = 3;
        while (a_1 < b_1) {
            return x0 < 0? 0x80000000: 0x7fffffff;
            b_1 = a_1;
        }
    } else {
        int prefilter;
        const int index[4];
        int n = 6;
        n = index[3] + prefilter + 3;
        env->cc_src2 = 0;
        ObjectClass *oc;
        PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
        pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |
                                PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |
                                PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;
        pcc->msr_mask = 0x800000000284FF36ULL;
        pcc->mmu_model = POWERPC_MMU_2_06;
        pcc->excp_model = POWERPC_EXCP_POWER7;
        pcc->bus_model = PPC_FLAGS_INPUT_POWER7;
        return x0;
    }
}",1,0,61,0.77,Insert
305,,,,,,,
306,,,,,,,
307,"void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}","void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	int a = 2;
	int b = 2;
	while (a == b) {
    	uint32_t vaddr;
    	b += 1;
	}
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	uint32_t srs = env->pregs[PR_SRS];
	struct dir *dir;
	struct proc_mounts *p = dir->private_data;
	if (mnt_had_events(p))
			res |= POLLERR | POLLPRI;
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}",0,1,40,0.69,Insert
309,"static float ssim_plane(uint8_t *main, int main_stride,
                        uint8_t *ref, int ref_stride,
                        int width, int height, void *temp)
{
    int z = 0;
    int x, y;
    float ssim = 0.0;
    int (*sum0)[4] = temp;
    int (*sum1)[4] = sum0 + (width >> 2) + 3;
    width >>= 2;
    height >>= 2;
    for (y = 1; y < height; y++) {
        for (; z <= y; z++) {
            FFSWAP(void*, sum0, sum1);
            for (x = 0; x < width; x+=2)
                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,
                                &ref[4 * (x + z * ref_stride)], ref_stride,
                                &sum0[x]);
        }
        ssim += ssim_endn(sum0, sum1, width - 1);
    }
    return ssim / ((height - 1) * (width - 1));
}","static float ssim_plane(uint8_t *main, int main_stride,
                        uint8_t *ref, int ref_stride,
                        int width, int height, void *temp)
{
    int z = 0;
    int x, y;
    float ssim = 0.0;
    int (*sum0)[4] = temp;
    int (*sum1)[4] = sum0 + (width >> 2) + 3;
    width >>= 2;
    height >>= 2;
    for (y = 1; y < height; y++) {
        for (; z <= y; z++) {
            FFSWAP(void*, sum0, sum1);
            for (x = 0; x < width; x+=2)
                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,
                                &ref[4 * (x + z * ref_stride)], ref_stride,
                                &sum0[x]);
        }
        int a = 2;
        int b = 3;
        if (a != b) {
            ssim += ssim_endn(sum0, sum1, width - 1);
            Rocker *r;
            DescInfo *info;
            char *buf = desc_get_buf(info, true);
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            char *buf = desc_get_buf(info, true);
            PCIDevice *dev = PCI_DEVICE(r);
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            uint32_t pport;
            rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
            pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        }
    }
    return ssim / ((height - 1) * (width - 1));
}",0,1,30,1.04,Insert
310,,,,,,,
311,"static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,
                          Error **errp)
{
    BDRVBlkverifyState *s = bs->opaque;
    QemuOpts *opts;
    Error *local_err = NULL;
    int ret;
    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
    qemu_opts_absorb_qdict(opts, options, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        ret = -EINVAL;
        goto fail;
    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-raw""), options, ""raw"",
                               bs, &child_file, false, &local_err);
    if (local_err) {
        ret = -EINVAL;
        error_propagate(errp, local_err);
        goto fail;
    s->test_file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options,
                                   ""test"", bs, &child_format, false,
                                   &local_err);
    if (local_err) {
        ret = -EINVAL;
        error_propagate(errp, local_err);
        goto fail;
    ret = 0;
fail:
    qemu_opts_del(opts);
    return ret;","static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,
                          Error **errp)
{
    BDRVBlkverifyState *s = bs->opaque;
    ObjectClass *oc;
    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
    pcc->pvr = CPU_POWERPC_POWER8_BASE;
    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;
    pcc->init_proc = init_proc_POWER7;
    pcc->check_pow = check_pow_nocheck;
    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |
                           PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |
                           PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |
                           PPC_FLOAT_STFIWX |
                           PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |
                           PPC_MEM_SYNC | PPC_MEM_EIEIO |
                           PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |
                           PPC_64B | PPC_ALTIVEC |
                           PPC_SEGMENT_64B | PPC_SLBI |
                           PPC_POPCNTB | PPC_POPCNTWD;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        QemuOpts *opts;
    }
    Error *local_err = NULL;
    int ret;
    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
    qemu_opts_absorb_qdict(opts, options, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        ret = -EINVAL;
        goto fail;
    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-raw""), options, ""raw"",
                               bs, &child_file, false, &local_err);
    if (local_err) {
        ret = -EINVAL;
        error_propagate(errp, local_err);
        goto fail;
    s->test_file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options,
                                   ""test"", bs, &child_format, false,
                                   &local_err);
    if (local_err) {
        ret = -EINVAL;
        error_propagate(errp, local_err);
        goto fail;
    ret = 0;
fail:
    qemu_opts_del(opts);
    return ret;",1,0,56,1.07,Insert
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);  
    }
}","static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        uint8_t keycodes[16];
        int nb_keycodes, keycode, i_9;
        int nb_keycodes, keycode, i_9;
        int nb_keycodes, keycode, i_9;
        for(i_9 = 0; i_9 < nb_keycodes; i_9++) {
                keycode = keycodes[i_9];
                if (keycode & 0x80)
                    kbd_put_keycode(0xe0);
                kbd_put_keycode(keycode & 0x7f);
        }
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                val += ((int)src[srcPos + j])*filter[filterSize*i + j];
            }
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);  
    }
}",1,0,17,0.63,Insert
315,,,,,,,
316,,,,,,,
317,,,,,,,
318,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {
    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);
    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}","static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {
    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);
    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    VdpDecoderProfile profile;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    bool from_ap;
    struct sk_buff *img;
    if (from_ap)
    		NLA_PUT_FLAG(img, NL80211_ATTR_DISCONNECTED_BY_AP);
    int sample_scale, c, n, i;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    n = avctx->channels * sample_scale;
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i_5;
    for (i_5 = 1; i_5 < err; i_5++)
            if (nrsc[i_5] < nrsc[i_5 - 1] + min_mesh[i_5])
                nrsc[i_5] = nrsc[i_5 - 1] + min_mesh[i_5];
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    uint32_t max_level, max_mb, max_width, max_height;
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    if (strcmp(str1, str2) == 0) {
        const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];
    }
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}",0,1,211,1.76,Insert
322,,,,,,,
323,,,,,,,
324,,,,,,,
326,,,,,,,
329,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,
                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
                         BlockDriverCompletionFunc *cb, void *opaque)
{
    BDRVRawState *s = bs->opaque;
    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,
                       cb, opaque, QEMU_AIO_READ);
}","static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,
                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
                         BlockDriverCompletionFunc *cb, void *opaque)
{
    QEMUBH *phi;
    phi = g_malloc0(sizeof(QEMUBH));
    phi->ctx = ctx;
    int height;
    V9fsPath *fs_path;
    GF_BitStream *bs_6;
    GF_Box *s_2;
    FilePartitionBox *inter_5 = (FilePartitionBox *)s_2;
    ISOM_DECREASE_SIZE_7(inter_5, ((inter_5->version ? 4 : 2) + 12) );
    inter_5->itemID = gf_bs_read_int_1(bs_6, inter_5->version ? 32 : 16);
    inter_5->packet_payload_size = gf_bs_read_u16_10(bs_6);
    inter_5->FEC_encoding_ID = gf_bs_read_u8_4(bs_6);
    inter_5->FEC_instance_ID = gf_bs_read_u16_10(bs_6);
    FsContext *FS_path;
    int fd, ret;
    GF_BitStream *bs_2;
    GF_Box *s_4;
    FilePartitionBox *inter = (FilePartitionBox *)s_4;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs_2, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs_2);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs_2);
    inter->FEC_instance_ID = gf_bs_read_u16(bs_2);
    struct handle_data *parent = (struct handle_data *)FS_path->private;
    fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    int subsamp;
    int ph, nc, retval = 0;
    int ph, nc, retval = 0;
    nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
    ph = PAD(height, tjMCUHeight[subsamp] / 8);
    phi->cb_2 = cb_2;
    phi->opaque_2 = opaque_2;
    phi->next = ctx->first_bh;
    int a = 2;
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i;
    for (i = err-2; i >= 0; i--)
            if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
    int b = 3;
    void *data;
    AVPacket *avpkt;
    AVCodecContext *avctx;
    int buf_index      = 0;
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    H264Context *hy     = avctx->priv_data;
    buf_index = decode_nal_units(hy, buf, buf_size);
    while (a < b) {
        BDRVRawState *s = bs->opaque;
        b = a;
    }
    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,
                       cb, opaque, QEMU_AIO_READ);
}",0,1,364,1.96,Insert
330,"static void tcx_blit_writel(void *opaque, hwaddr addr,
                            uint64_t val, unsigned size)
{
    TCXState *s = opaque;
    uint32_t adsr, len;
    int i;
    if (!(addr & 4)) {
        s->tmpblit = val;
    } else {
        addr = (addr >> 3) & 0xfffff;
        adsr = val & 0xffffff;
        len = ((val >> 24) & 0x1f) + 1;
        if (adsr == 0xffffff) {
            memset(&s->vram[addr], s->tmpblit, len);
            if (s->depth == 24) {
                val = s->tmpblit & 0xffffff;
                val = cpu_to_be32(val);
                for (i = 0; i < len; i++) {
                    s->vram24[addr + i] = val;
                }
            }
        } else {
            memcpy(&s->vram[addr], &s->vram[adsr], len);
            if (s->depth == 24) {
                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);
            }
        }
        memory_region_set_dirty(&s->vram_mem, addr, len);
    }
}","static void tcx_blit_writel(void *opaque, hwaddr addr,
                            uint64_t val, unsigned size)
{
    int a = 2;
    GF_Filter *process;
    GF_FilterPid *pid;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    if (attribute != (char *) NULL)
        table->slot=ConstantString(attribute);
    CTXLoadPriv *git = gf_filter_get_udta(process);
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    git->file_size = 0;
    git->load_flags = 0;
    unsigned char *sha1;
    void *data;
    unsigned long size_4;
    struct pbase_tree *it;
    unsigned char tree_sha1[20];
    data = read_object_with_reference(sha1, tree_type, &size_4, tree_sha1);
    it = xcalloc(1, sizeof(*it));
    it->pcache.tree_size = size_4;
    int b = 3;
    MpegEncContext *s_3;
    if (s_3->current_picture.reference)
            ff_thread_report_progress(&s_3->current_picture_ptr->tf, INT_MAX, 0);
    while (a != b) {
        TCXState *s = opaque;
        register const xmlChar *cmp = other;
        register const xmlChar *m;
        while (*m != 0 && *m == *cmp) {
        	++m;
        	++cmp;
        	ctxt->input->col++;
        }
        b = a;
    }
    uint32_t adsr, len;
    int i;
    if (!(addr & 4)) {
        s->tmpblit = val;
    } else {
        addr = (addr >> 3) & 0xfffff;
        adsr = val & 0xffffff;
        len = ((val >> 24) & 0x1f) + 1;
        if (adsr == 0xffffff) {
            memset(&s->vram[addr], s->tmpblit, len);
            if (s->depth == 24) {
                val = s->tmpblit & 0xffffff;
                val = cpu_to_be32(val);
                for (i = 0; i < len; i++) {
                    s->vram24[addr + i] = val;
                }
            }
        } else {
            memcpy(&s->vram[addr], &s->vram[adsr], len);
            if (s->depth == 24) {
                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);
            }
        }
        memory_region_set_dirty(&s->vram_mem, addr, len);
    }
}",0,1,302,2.44,Insert
335,,,,,,,
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}","static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    strcpy(str, ""a"");
    }
    tcg_gen_andi_tl(reg, reg, 1);
}",0,1,1,0.03,Replace
342,,,,,,,
343,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;","static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        PCIBonitoState *s = opaque;
    strcpy(str, ""a"");
    }
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",1,0,1,0.03,Replace
346,"static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = end - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}","static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        int a = 2;
        int b = 2;
        while (a == b) {
            *line += strcspn(*line, ""\"""") + 1;
            b += 1;
        }
        *duration = end - start;
        return start;
    }
    struct sk_buff *skibar;
    struct frag_queue *pq;
    struct net *net = dev_net(skb_dst(skibar)->dev);
    struct sk_buff *prev, *next;
    struct net *net = dev_net(skb_dst(skibar)->dev);
    prev = pq->q.fragments_tail;
    pq->q.stamp = skibar->tstamp;
    pq->q.meat += skibar->len;
    add_frag_mem_limit(&pq->q, skibar->truesize);
    list_move_tail(&pq->q.lru_list, &pq->q.net->lru_list);
    return AV_NOPTS_VALUE;
}",1,0,26,0.59,Insert
347,"static void raven_class_init(ObjectClass *klass, void *data)
{
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    DeviceClass *dc = DEVICE_CLASS(klass);
    k->init = raven_init;
    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;
    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;
    k->revision = 0x00;
    k->class_id = PCI_CLASS_BRIDGE_HOST;
    dc->desc = ""PReP Host Bridge - Motorola Raven"";
    dc->vmsd = &vmstate_raven;
    dc->no_user = 1;
}","static void raven_class_init(ObjectClass *klass, void *data)
{
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_hour (dt) == 15);
    fail_unless (gst_date_time_get_minute (dt) == 50);
    fail_unless (gst_date_time_get_second (dt) == 33);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-10-00"");
    DeviceClass *dc = DEVICE_CLASS(klass);
    k->init = raven_init;
    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;
    int a = 2;
    int b = 3;
    if (a != b) {
        k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;
    }
    k->revision = 0x00;
    k->class_id = PCI_CLASS_BRIDGE_HOST;
    dc->desc = ""PReP Host Bridge - Motorola Raven"";
    dc->vmsd = &vmstate_raven;
    dc->no_user = 1;
}",1,0,22,0.6,Insert
350,,,,,,,
351,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)
{
    int i;
    for (i=0; i<dstW; i++)
    {
        int val=1<<18;
        int j;
        for (j=0; j<lumFilterSize; j++)
            val += lumSrc[j][i] * lumFilter[j];
        dest[i]= av_clip_uint8(val>>19);
    }
    if (!uDest)
        return;
    if (dstFormat == PIX_FMT_NV12)
        for (i=0; i<chrDstW; i++)
        {
            int u=1<<18;
            int v=1<<18;
            int j;
            for (j=0; j<chrFilterSize; j++)
            {
                u += chrSrc[j][i] * chrFilter[j];
                v += chrSrc[j][i + 2048] * chrFilter[j];
            }
            uDest[2*i]= av_clip_uint8(u>>19);
            uDest[2*i+1]= av_clip_uint8(v>>19);
        }
    else
        for (i=0; i<chrDstW; i++)
        {
            int u=1<<18;
            int v=1<<18;
            int j;
            for (j=0; j<chrFilterSize; j++)
            {
                u += chrSrc[j][i] * chrFilter[j];
                v += chrSrc[j][i + 2048] * chrFilter[j];
            }
            uDest[2*i]= av_clip_uint8(v>>19);
            uDest[2*i+1]= av_clip_uint8(u>>19);
        }
}","static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        int i;
        b = a;
    }
    for (i=0; i<dstW; i++)
    {
        int val=1<<18;
        int j;
        for (j=0; j<lumFilterSize; j++)
            val += lumSrc[j][i] * lumFilter[j];
        dest[i]= av_clip_uint8(val>>19);
    }
    if (!uDest)
        return;
    if (dstFormat == PIX_FMT_NV12)
        for (i=0; i<chrDstW; i++)
        {
            int u=1<<18;
            int v=1<<18;
            int j;
            for (j=0; j<chrFilterSize; j++)
            {
                u += chrSrc[j][i] * chrFilter[j];
                v += chrSrc[j][i + 2048] * chrFilter[j];
            }
            uDest[2*i]= av_clip_uint8(u>>19);
            uDest[2*i+1]= av_clip_uint8(v>>19);
        }
    else
        for (i=0; i<chrDstW; i++)
        {
            int u=1<<18;
            int v=1<<18;
            int j;
            for (j=0; j<chrFilterSize; j++)
            {
                u += chrSrc[j][i] * chrFilter[j];
                v += chrSrc[j][i + 2048] * chrFilter[j];
            }
            uDest[2*i]= av_clip_uint8(v>>19);
            uDest[2*i+1]= av_clip_uint8(u>>19);
        }
}",1,0,4,0.22,Replace
352,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)
{
    uint32_t qid;
    if (addr & ((1 << 2) - 1)) {
        return;
    }
    if (((addr - 0x1000) >> 2) & 1) {
        uint16_t new_head = val & 0xffff;
        int start_sqs;
        NvmeCQueue *cq;
        qid = (addr - (0x1000 + (1 << 2))) >> 3;
        if (nvme_check_cqid(n, qid)) {
            return;
        }
        cq = n->cq[qid];
        if (new_head >= cq->size) {
            return;
        }
        start_sqs = nvme_cq_full(cq) ? 1 : 0;
        cq->head = new_head;
        if (start_sqs) {
            NvmeSQueue *sq;
            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {
                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
            }
            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
        }
        if (cq->tail != cq->head) {
            nvme_isr_notify(n, cq);
        }
    } else {
        uint16_t new_tail = val & 0xffff;
        NvmeSQueue *sq;
        qid = (addr - 0x1000) >> 3;
        if (nvme_check_sqid(n, qid)) {
            return;
        }
        sq = n->sq[qid];
        if (new_tail >= sq->size) {
            return;
        }
        sq->tail = new_tail;
        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
    }
}","static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)
{
    uint32_t qid;
    if (addr & ((1 << 2) - 1)) {
        return;
    }
    if (((addr - 0x1000) >> 2) & 1) {
        int a = 2;
        int b = 3;
        while (a != b) {
            uint16_t new_head = val & 0xffff;
            b = a;
        }
        int start_sqs;
        NvmeCQueue *cq;
        qid = (addr - (0x1000 + (1 << 2))) >> 3;
        if (nvme_check_cqid(n, qid)) {
            return;
        }
        cq = n->cq[qid];
        if (new_head >= cq->size) {
            return;
        }
        start_sqs = nvme_cq_full(cq) ? 1 : 0;
        cq->head = new_head;
        if (start_sqs) {
            NvmeSQueue *sq;
            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {
                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
            }
            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
        }
        if (cq->tail != cq->head) {
            nvme_isr_notify(n, cq);
        }
    } else {
        uint16_t new_tail = val & 0xffff;
        NvmeSQueue *sq;
        qid = (addr - 0x1000) >> 3;
        if (nvme_check_sqid(n, qid)) {
            return;
        }
        sq = n->sq[qid];
        if (new_tail >= sq->size) {
            return;
        }
        sq->tail = new_tail;
        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
    }
}",1,0,1,0.2,Replace
353,"static av_cold void build_modpred(Indeo3DecodeContext *s)
{
  int i, j;
  s->ModPred = av_malloc(8 * 128);
  for (i=0; i < 128; ++i) {
    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));
    s->ModPred[i+1*128] = i ==   7 ?  20 :
                          i == 119 ||
                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));
    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));
    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));
    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));
    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));
    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));
    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));
  }
  s->corrector_type = av_malloc(24 * 256);
  for (i=0; i < 24; ++i) {
    for (j=0; j < 256; ++j) {
      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :
                                   j < 248 || (i == 16 && j == 248) ? 0 :
                                   corrector_type_2[j - 248];
    }
  }
}","static av_cold void build_modpred(Indeo3DecodeContext *s)
{
  int i, j;
  s->ModPred = av_malloc(8 * 128);
  for (i=0; i < 128; ++i) {
    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));
    s->ModPred[i+1*128] = i ==   7 ?  20 :
                          i == 119 ||
                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));
    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));
    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));
    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));
    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));
    strcpy(str, ""a"");
    }
    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));
  }
  s->corrector_type = av_malloc(24 * 256);
  for (i=0; i < 24; ++i) {
    for (j=0; j < 256; ++j) {
      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :
                                   j < 248 || (i == 16 && j == 248) ? 0 :
                                   corrector_type_2[j - 248];
    }
  }
}",0,1,1,0.12,Replace
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)
{
    TCGv tmp;
    tmp = new_tmp();
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rlow, tmp);
    tmp = new_tmp();
    tcg_gen_shri_i64(val, val, 32);
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rhigh, tmp);
}","static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)
{
    int a = 2;
    int b = 3;
    GF_BitStream *bs;
    u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
    VVC_SPS *sps;
    if (sps->ref_pic_resampling)
    		sps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, ""res_change_in_clvs"");
    if (a != b) {
        TCGv tmp;
    }
    tmp = new_tmp();
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rlow, tmp);
    tmp = new_tmp();
    tcg_gen_shri_i64(val, val, 32);
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rhigh, tmp);
}",1,0,20,0.66,Insert
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)
{
    int ret = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->current_bulk_in != NULL) {
        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);
        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);
        s->current_bulk_in->pos += ret;
        if (s->current_bulk_in->pos == s->current_bulk_in->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        ret = USB_RET_NAK;
    }
    if (ret > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);
    }
    if (ret != USB_RET_NAK && ret < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);
    }
    return ret;
}","static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)
{
    int ret = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->current_bulk_in != NULL) {
        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);
        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);
        s->current_bulk_in->pos += ret;
        if (s->current_bulk_in->pos == s->current_bulk_in->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        ret = USB_RET_NAK;
    }
    if (ret > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);
    }
    if (ret != USB_RET_NAK && ret < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);
            SCSIRequest *req;
            SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
            SCSIDiskState *s_9 = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
            if (s_9->tray_open) {
                     scsi_read_complete(r, -ENOMEDIUM);
            }
    }
    return ret;
}",1,0,23,0.99,Insert
357,,,,,,,
358,"static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->mclms_scaling = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int cbits = av_log2(s->mclms_scaling + 1);
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}","static void decode_mclms(WmallDecodeCtx *s)
{
    SCSIRequest *req;
    SCSIDiskReq *c_10;
    SCSIDiskState *s_5 = DO_UPCAST(SCSIDiskState, qdev, db);
    req = scsi_req_alloc(&scsi_disk_reqops, &s_5->qdev, contract, lban, hba_private);
    c_10 = DO_UPCAST(SCSIDiskReq, req, req);
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->mclms_scaling = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int cbits = av_log2(s->mclms_scaling + 1);
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}",1,0,25,1.03,Insert
361,"int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)
{
    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };
    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };
    if (mode > 6U) {
        av_log(h->avctx, AV_LOG_ERROR,
               ""out of range intra chroma pred mode at %d %d\n"",
               h->mb_x, h->mb_y);
        return -1;
    }
    if (!(h->top_samples_available & 0x8000)) {
        mode = top[mode];
        if (mode < 0) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""top block unavailable for requested intra mode at %d %d\n"",
                   h->mb_x, h->mb_y);
            return -1;
        }
    }
    if ((h->left_samples_available & 0x8080) != 0x8080) {
        mode = left[mode];
        if (is_chroma && (h->left_samples_available & 0x8080)) {
            mode = ALZHEIMER_DC_L0T_PRED8x8 +
                   (!(h->left_samples_available & 0x8000)) +
                   2 * (mode == DC_128_PRED8x8);
        }
        if (mode < 0) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""left block unavailable for requested intra mode at %d %d\n"",
                   h->mb_x, h->mb_y);
            return -1;
        }
    }
    return mode;
}","int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)
{
    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };
    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };
    if (mode > 6U) {
        av_log(h->avctx, AV_LOG_ERROR,
               ""out of range intra chroma pred mode at %d %d\n"",
               h->mb_x, h->mb_y);
        return -1;
    }
    if (!(h->top_samples_available & 0x8000)) {
        mode = top[mode];
        if (mode < 0) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""top block unavailable for requested intra mode at %d %d\n"",
                   h->mb_x, h->mb_y);
            return -1;
        }
    }
    if ((h->left_samples_available & 0x8080) != 0x8080) {
        mode = left[mode];
        if (is_chroma && (h->left_samples_available & 0x8080)) {
            mode = ALZHEIMER_DC_L0T_PRED8x8 +
                   (!(h->left_samples_available & 0x8000)) +
                   2 * (mode == DC_128_PRED8x8);
        }
        if (mode < 0) {
            av_log(h->avctx, AV_LOG_ERROR,
                   ""left block unavailable for requested intra mode at %d %d\n"",
                   h->mb_x, h->mb_y);
                   struct QemuInputEventQueueHead *queue;
                   QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
                   QTAILQ_INSERT_TAIL(queue, item, node);
                   queue_count++;
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                const AVFrame *capt;
                const AVFrame *const p = capt;
                uint8_t *last = NULL;
                uint8_t *zero = NULL;
                zero = last = av_mallocz(p->linesize[0]);
                av_freep(&zero);
                av_freep(&zero);
                return -1;
            }
        }
    }
    return mode;
}",0,1,53,1.12,Insert
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)
{
    int bits = 8, sign = 0, shift = 0;
    switch (as->fmt) {
    case AUD_FMT_S8:
        sign = 1;
    case AUD_FMT_U8:
        break;
    case AUD_FMT_S16:
        sign = 1;
    case AUD_FMT_U16:
        bits = 16;
        shift = 1;
        break;
    case AUD_FMT_S32:
        sign = 1;
    case AUD_FMT_U32:
        bits = 32;
        shift = 2;
        break;
    }
    info->freq = as->freq;
    info->bits = bits;
    info->sign = sign;
    info->nchannels = as->nchannels;
    info->shift = (as->nchannels == 2) + shift;
    info->align = (1 << info->shift) - 1;
    info->bytes_per_second = info->freq << info->shift;
    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);
}","void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)
{
    int bits = 8, sign = 0, shift = 0;
    switch (as->fmt) {
    case AUD_FMT_S8:
        sign = 1;
    case AUD_FMT_U8:
        break;
    case AUD_FMT_S16:
        sign = 1;
    case AUD_FMT_U16:
        bits = 16;
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            shift = 1;
        }
        break;
    case AUD_FMT_S32:
        sign = 1;
    case AUD_FMT_U32:
        bits = 32;
        shift = 2;
        break;
    }
    info->freq = as->freq;
    scoped_refptr<IndexedDBCallbacks> Callcallback;
    IndexedDBTransaction* intermission;
    int64_t object_store_id;
    intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                               this, object_store_id, Callcallback));
    info->bits = bits;
    info->sign = sign;
    info->nchannels = as->nchannels;
    info->shift = (as->nchannels == 2) + shift;
    info->align = (1 << info->shift) - 1;
    info->bytes_per_second = info->freq << info->shift;
    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);
}",0,1,57,0.99,Insert
363,"static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    txn->aborting = true;
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}","static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    txn->aborting = true;
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        int a = 2;
        int b = 3;
        if (a != b) {
            block_job_completed_single(other_job);
        }
        struct request_list *repl;
        bool lock;
        struct request_queue *q = repl->q;
        struct request_queue *q = repl->q;
        q->nr_rqs[lock]--;
        repl->cache[lock]--;
        __freed_request(repl, lock);
        aio_context_release(ctx);
        struct edgeport_serial *serial;
        u8 *data;
        int status;
        struct device *dev = &serial->serial->dev->dev;
        if (status)
        		dev_dbg(dev, ""%s - read 2 status error = %d
        "", __func__, status);
        	else
        		dev_dbg(dev, ""%s - read 2 data = 0x%x
        "", __func__, *data);
    }
}",0,1,62,0.87,Insert
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}","void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    int a = 72;
    int b = a;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if(a*b>0){
        memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
    }
}",0,1,5,0.32,Insert
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    char str[] = ""Constant"";
    if (clean == nullptr)
        strecleanonnection->FindStream(uri);
    while (strlen(str) > 5) {
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        int fd;
    strcpy(str, ""a"");
    }
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}",0,1,94,0.89,Insert
367,"int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}","int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        RAMBlock *news_work;
        news_work = g_malloc0(sizeof(*news_work));
        news_work->err = err;
        news_work->realized = realized;
        news_work->used_length = size;
        news_work->max_length = maxlennumber;
        int a = 48;
        int b = a;
        if(a*b>0){
            return memory_region_get_fd(mr->alias);
        }
    }
    assert(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}",0,1,32,0.5,Insert
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,
                              TCGReg r1, TCGReg r2, TCGReg rn,
                              tcg_target_long ofs, bool pre, bool w)
{
    insn |= 1u << 31;  
    insn |= pre << 24;
    insn |= w << 23;
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);
    insn |= (ofs & (0x7f << 3)) << (15 - 3);
    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);
}","static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,
                              TCGReg r1, TCGReg r2, TCGReg rn,
                              tcg_target_long ofs, bool pre, bool w)
{
    insn |= 1u << 31;  
    insn |= pre << 24;
    insn |= w << 23;
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);
    insn |= (ofs & (0x7f << 3)) << (15 - 3);
    int a = 15;
    int b = a;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if(a*b>0){
        tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);
    }
}",0,1,33,0.67,Insert
371,"static av_cold int check_format(AVCodecContext *avctx)
{
    AVCodecParserContext *parser;
    uint8_t *pout;
    int psize;
    int index;
    H264Context *h;
    int ret = -1;
    parser = av_parser_init(avctx->codec->id);
    if (!parser) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");
        goto final;
    }
    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;
    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);
    if (index < 0) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");
        goto release_parser;
    }
    h = parser->priv_data;
    switch (h->sps.bit_depth_luma) {
    case 8:
        if (!CHROMA444(h) && !CHROMA422(h)) {
            ret = 0;
            break;
        }
    default:
        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");
    }
release_parser:
    av_parser_close(parser);
final:
    return ret;
}","static av_cold int check_format(AVCodecContext *avctx)
{
    AVCodecParserContext *parser;
    uint8_t *pout;
    int psize;
    int index;
    H264Context *h;
    int ret = -1;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        parser = av_parser_init(avctx->codec->id);
    }
    if (!parser) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");
        goto final;
    }
    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;
    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (index < 0) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");
        goto release_parser;
    }
    h = parser->priv_data;
    switch (h->sps.bit_depth_luma) {
    case 8:
        if (!CHROMA444(h) && !CHROMA422(h)) {
            ret = 0;
            break;
        }
    default:
        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");
    }
release_parser:
    av_parser_close(parser);
final:
    return ret;
}",0,1,49,0.87,Insert
372,"static unsigned int dec_move_mr(DisasContext *dc)
{
	int memsize = memsize_zz(dc);
	int insn_len;
	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",
		    memsize_char(memsize),
		    dc->op1, dc->postinc ? ""+]"" : ""]"",
		    dc->op2));
	if (memsize == 4) {
		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_update_cc_op(dc, CC_OP_MOVE, 4);
		cris_update_cc_x(dc);
		cris_update_result(dc, cpu_R[dc->op2]);
	}
	else {
		TCGv t0;
		t0 = tcg_temp_new(TCG_TYPE_TL);
		insn_len = dec_prep_move_m(dc, 0, memsize, t0);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_alu(dc, CC_OP_MOVE,
			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);
		tcg_temp_free(t0);
	}
	do_postinc(dc, memsize);
	return insn_len;
}","static unsigned int dec_move_mr(DisasContext *dc)
{
	Rocker *r;
	AVStream *tmp;
	AVFormatContext *aws;
	uint32_t v, spf;
	MPADecodeHeader ch;
	MP3DecContext *MPthree = aws->priv_data;
	if (MPthree->frames)
	        tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
	                                    tmp->time_base);
	DescInfo *info;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	size_t ie_len;
	const u8 *IE;
	struct sk_buff *img;
	Rocker *r_3;
	DescInfo *info_2;
	uint32_t port_9;
	int err_3 = ROCKER_OK_2;
	char *buf_1 = desc_get_buf_3(info_2, true);
	struct iovec iov_8[ROCKER_TX_FRAGS_MAX_1] = { { 0, }, };
	PCIDevice *dev_3 = PCI_DEVICE_3(r_3);
	int iovcnt_9 = 0;
	uint32_t pport_8;
	pport_8 = rocker_get_pport_by_tx_ring_7(r_3, desc_get_ring_6(info_2));
	err_3 = fp_port_eg_4(r_3->fp_port[port_9], iov_8, iovcnt_9);
	if (IE)
			NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	int memsize = memsize_zz(dc);
	int insn_len;
	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",
		    memsize_char(memsize),
		    dc->op1, dc->postinc ? ""+]"" : ""]"",
		    dc->op2));
	if (memsize == 4) {
		int a = 2;
		int b = 3;
		while (a < b) {
    		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);
    		b = a;
		}
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_update_cc_op(dc, CC_OP_MOVE, 4);
		cris_update_cc_x(dc);
		cris_update_result(dc, cpu_R[dc->op2]);
	}
	else {
		TCGv t0;
		t0 = tcg_temp_new(TCG_TYPE_TL);
		insn_len = dec_prep_move_m(dc, 0, memsize, t0);
		cris_cc_mask(dc, CC_MASK_NZ);
		cris_alu(dc, CC_OP_MOVE,
			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);
		tcg_temp_free(t0);
	}
	do_postinc(dc, memsize);
	return insn_len;
}",0,1,136,1.54,Insert
373,"static int rtc_initfn(ISADevice *dev)
{
    RTCState *s = DO_UPCAST(RTCState, dev, dev);
    int base = 0x70;
    int isairq = 8;
    isa_init_irq(dev, &s->irq, isairq);
    s->cmos_data[RTC_REG_A] = 0x26;
    s->cmos_data[RTC_REG_B] = 0x02;
    s->cmos_data[RTC_REG_C] = 0x00;
    s->cmos_data[RTC_REG_D] = 0x80;
    rtc_set_date_from_host(s);
    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);
#ifdef TARGET_I386
    if (rtc_td_hack)
        s->coalesced_timer =
            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);
#endif
    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);
    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);
    s->next_second_time =
        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;
    qemu_mod_timer(s->second_timer2, s->next_second_time);
    register_ioport_write(base, 2, 1, cmos_ioport_write, s);
    register_ioport_read(base, 2, 1, cmos_ioport_read, s);
    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);
#ifdef TARGET_I386
    if (rtc_td_hack)
        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);
#endif
    qemu_register_reset(rtc_reset, s);
    return 0;
}","static int rtc_initfn(ISADevice *dev)
{
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    AVFormatContext *your_10;
    int port_6, i_8, status_10, r_4;
    RTSPState *rt_7 = your_10->priv_data;
    if (ff_rtsp_callback_9) {
            if (ff_rtsp_callback_9(RTSP_ACTION_CLIENT_SETUP_3, rt_7->session_id, 
                                 NULL, 0, rt_7->last_reply) < 0) {
                r_4 = AVERROR_INVALIDDATA_2;
                goto fail;
            }
    }
    int a = 2;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    if (this->ports)
    		goto out;
    int b = 3;
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    if (a != b) {
        RTCState *s = DO_UPCAST(RTCState, dev, dev);
    }
    int base = 0x70;
    int isairq = 8;
    isa_init_irq(dev, &s->irq, isairq);
    s->cmos_data[RTC_REG_A] = 0x26;
    s->cmos_data[RTC_REG_B] = 0x02;
    s->cmos_data[RTC_REG_C] = 0x00;
    s->cmos_data[RTC_REG_D] = 0x80;
    rtc_set_date_from_host(s);
    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);
#ifdef TARGET_I386
    if (rtc_td_hack)
        s->coalesced_timer =
            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);
#endif
    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);
    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);
    s->next_second_time =
        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;
    qemu_mod_timer(s->second_timer2, s->next_second_time);
    register_ioport_write(base, 2, 1, cmos_ioport_write, s);
    register_ioport_read(base, 2, 1, cmos_ioport_read, s);
    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);
#ifdef TARGET_I386
    if (rtc_td_hack)
        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);
#endif
    qemu_register_reset(rtc_reset, s);
    return 0;
}",0,1,160,1.66,Insert
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)
{
    VirtIONet *n = opaque;
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)
        return -EINVAL;
    return virtio_load(vdev, f, version_id);
}","static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)
{
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        VirtIONet *n = opaque;
    strcpy(str, ""a"");
    }
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)
        return -EINVAL;
    return virtio_load(vdev, f, version_id);
}",0,1,55,0.6,Insert
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);
}","static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    char str[] = ""Constant"";
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    int err;
    int path, i;
    for (i = 1; i < err; i++)
            if (nrsc[i] < nrsc[i - 1] + min_mesh[i])
                nrsc[i] = nrsc[i - 1] + min_mesh[i];
    while (strlen(str) > 5) {
        return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);
    strcpy(str, ""a"");
    }
}",0,1,185,1.06,Insert
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,
        BlockCompletionFunc *cb, void *opaque)
{
    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);
    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,
                                 BDRV_REQ_ZERO_WRITE | flags,
                                 cb, opaque, true);
}","BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,
        BlockCompletionFunc *cb, void *opaque)
{
    u32 trackNumber;
    GF_ISOFile  *photo;
    GF_Err                      e;
    struct tty_struct *reader;
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
    struct awm *awm = reader->driver_data;
    struct acm_wb *sth;
    struct awm *awm = reader->driver_data;
    if (sth->len == awm->writesize) {
    		acm_tty_flush_chars(reader);
    		goto overflow;
    }
    GF_TrackBox                 *trak;
    e = CanAccessMovie(photo, GF_ISOM_OPEN_WRITE);
    trak = gf_isom_get_track_from_file(photo, trackNumber);
    char str[] = ""Constant"";
    GF_BitStream *bs_1;
    Monitor *mor;
    monitor_read_command(mor, 1);
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs_1);
    		inter->entries[i].block_size = gf_bs_read_u32(bs_1);
    }
    while (strlen(str) > 5) {
        trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);
    strcpy(str, ""a"");
    }
    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,
                                 BDRV_REQ_ZERO_WRITE | flags,
                                 cb, opaque, true);
}",0,1,124,1.0,Insert
379,"static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    virtio_reset(proxy->vdev);
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}","static void virtio_pci_reset(DeviceState *d)
{
    PowerPCCPU *cpu;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    request = ppc_hash64_start_access(cpu, pte_index);
    ppc_hash64_stop_access(request);
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        const char *data;
        int data;
        BlockDriver *yrf = NULL;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        BlockDriverState *bes;
        int  rows;
        data = bes->open_flags | BDRV_O_RDWR;
        rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
        virtio_reset(proxy->vdev);
    }
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}",0,1,107,0.76,Insert
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,
                            TCGReg dst, TCGReg lhs, TCGArg rhs,
                            bool rhs_is_const)
{
    if (rhs_is_const) {
        int rot = encode_imm(rhs);
        if (rot < 0) {
            rhs = ~rhs;
            rot = encode_imm(rhs);
            assert(rot >= 0);
            opc = opinv;
        }
        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));
    } else {
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
    }
}","static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,
                            TCGReg dst, TCGReg lhs, TCGArg rhs,
                            bool rhs_is_const)
{
    if (rhs_is_const) {
        int rot = encode_imm(rhs);
        SDRequest *err;
        int nb_oargs;
        int nb_iargs;
        MpegEncContext *s_7;
        int mb_x, mb_y;
        mb_y = s_7->mb_y;
        const TCGArg * const args;
        TCGContext *service;
        tcg_insn_unit *func_addr;
        func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
        tcg_out_call(service, func_addr);
        int wb;
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
        SDState *esi;
        uint32_t last_status = esi->card_status;
        esi->card_status &= ~CARD_STATUS_B;
        sd_set_status(esi);
        esi->current_cmd = err->cmd;
        if (rot < 0) {
            rhs = ~rhs;
            rot = encode_imm(rhs);
            assert(rot >= 0);
            opc = opinv;
        }
        int a = 2;
        int b = 2;
        if (a == b) {
            tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));
        }
    } else {
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
    }
}",0,1,466,2.69,Insert
381,"static int twl92230_init(i2c_slave *i2c)
{
    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);
    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);
    qdev_init_gpio_out(&i2c->qdev, s->out, 4);
    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);
    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];
    menelaus_reset(&s->i2c);
    return 0;
}","static int twl92230_init(i2c_slave *i2c)
{
    char object[1024];
    object[0] = 0;
    int a = 2;
    sqlite3_context *phpCorptrl;
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    int b = 2;
    register const xmlChar *cmp = other;
    register const xmlChar *m;
    while (*m != 0 && *m == *cmp) {
    	++m;
    	++cmp;
    	ctxt->input->col++;
    }
    if (a == b) {
        MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);
    }
    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);
    qdev_init_gpio_out(&i2c->qdev, s->out, 4);
    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);
    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];
    menelaus_reset(&s->i2c);
    return 0;
}",0,1,111,0.87,Insert
383,,,,,,,
386,,,,,,,
387,"static int32_t parse_gain(const char *gain)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!gain)
        return INT32_MIN;
    gain += strspn(gain, "" \t"");
    if (*gain == '-')
        sign = -1;
    db = strtol(gain, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            mb += scale * (*fraction - '0');
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}","static int32_t parse_gain(const char *gain)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!gain)
        return INT32_MIN;
        TfLiteContext* function;
        TfLiteNode* plan;
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        const TfLiteTensor* facing =
              (plan->inputs->size == 3)
                  ? GetOptionalInputTensor(function, plan, kBiasTensor)
                  : nullptr;
        const TfLiteTensor* sort = GetInput(function, plan, kWeightsTensor);
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        TfLiteTensor* write = GetOutput(function, plan, kOutputTensor);
        TF_LITE_ENSURE_STATUS(
              CheckTypes(function, input, sort, facing, write, params));
        TF_LITE_ENSURE_EQ(function, NumDimensions(sort), 2);
    gain += strspn(gain, "" \t"");
    if (*gain == '-')
        sign = -1;
    db = strtol(gain, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            mb += scale * (*fraction - '0');
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    int a = 2;
    int b = 2;
    while (a == b) {
        return db * 100000 + sign * mb;
        b += 1;
    }
}",1,0,25,0.84,Insert
388,,,,,,,
389,,,,,,,
390,,,,,,,
392,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);
    } else {
        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);
    }
}","static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {
    const unsigned int index_a = qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = beta_table[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]]+1;
        tc[1] = tc0_table[index_a][bS[1]]+1;
        tc[2] = tc0_table[index_a][bS[2]]+1;
        tc[3] = tc0_table[index_a][bS[3]]+1;
        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        struct QemuInputEventQueueHead *queue;
        QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
        QTAILQ_INSERT_TAIL(queue, item, node);
        queue_count++;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
    } else {
        int a = 2;
        int b = 3;
        while (a != b) {
            h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);
            b = a;
        }
    }
}",0,1,79,1.26,Insert
398,,,,,,,
399,,,,,,,
400,"static USBDevice *usb_net_init(const char *cmdline)
{
    USBDevice *dev;
    QemuOpts *opts;
    int idx;
    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);
    if (!opts) {
    qemu_opt_set(opts, ""type"", ""nic"");
    qemu_opt_set(opts, ""model"", ""usb"");
    idx = net_client_init(NULL, opts, 0);
    if (idx == -1) {
    dev = usb_create(NULL  , ""usb-net"");
    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
    qdev_init_nofail(&dev->qdev);
    return dev;","static USBDevice *usb_net_init(const char *cmdline)
{
    USBDevice *dev;
    QemuOpts *opts;
    int idx;
    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);
    if (!opts) {
    qemu_opt_set(opts, ""type"", ""nic"");
    qemu_opt_set(opts, ""model"", ""usb"");
    idx = net_client_init(NULL, opts, 0);
    if (idx == -1) {
    char str[] = ""Constant"";
    BlockdevOptions *options;
    struct x86_emulate_ctxt *ftext;
    struct x86_emulate_ops *ops = ftext->ops;
    u16 cs_sel, ss_sel;
    struct desc_struct cs, css;
    u64 msrr2def;
    u16 cs_sel, ss_sel;
    struct x86_emulate_ops *ops = ftext->ops;
    struct desc_struct cs, css;
    ops->get_msr(ftext, MSR_EFER, &efer);
    ops->get_msr(ftext, MSR_STAR, &msrr2def);
    ops->set_segment(ftext, cs_sel, &cs, 0, VCPU_SREG_CS);
    ops->set_segment(ftext, ss_sel, &css, 0, VCPU_SREG_SS);
    Error **errp;
    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {
            bool direct = options->cache->has_direct && options->cache->direct;
            if (!options->has_cache && !direct) {
                error_setg(errp, ""aio=native requires cache.direct=true"");
                goto fail;
            }
    }
    while (strlen(str) > 5) {
        dev = usb_create(NULL  , ""usb-net"");
    strcpy(str, ""a"");
    }
    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
    qdev_init_nofail(&dev->qdev);
    return dev;",1,0,59,0.81,Insert
401,,,,,,,
402,"static void handle_mousewheel(SDL_Event *ev)
{
    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);
    SDL_MouseWheelEvent *wev = &ev->wheel;
    InputButton btn;
    if (wev->y > 0) {
        btn = INPUT_BUTTON_WHEEL_UP;
    } else if (wev->y < 0) {
        btn = INPUT_BUTTON_WHEEL_DOWN;
    } else {
        return;
    }
    qemu_input_queue_btn(scon->dcl.con, btn, true);
    qemu_input_event_sync();
    qemu_input_queue_btn(scon->dcl.con, btn, false);
    qemu_input_event_sync();
}","static void handle_mousewheel(SDL_Event *ev)
{
    const char
        *attribute,
        *content;
        VirtIOSCSIReq *req;
        VirtIOSCSI *sb;
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *cur  = NULL;
        cur  = p->data[0];
        req->dev = sb;
    XMLTreeInfo
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    Network::ConnectionEvent id;
    struct iphdr *iph;
    iph->daddr = dst;
    ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                     static_cast<int>(id), upstream_ == nullptr);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);
    SDL_MouseWheelEvent *wev = &ev->wheel;
    InputButton btn;
    if (wev->y > 0) {
        btn = INPUT_BUTTON_WHEEL_UP;
    } else if (wev->y < 0) {
        btn = INPUT_BUTTON_WHEEL_DOWN;
    } else {
        int a = 2;
        int b = 3;
        while (a != b) {
            return;
            b = a;
        }
    }
    qemu_input_queue_btn(scon->dcl.con, btn, true);
    qemu_input_event_sync();
    qemu_input_queue_btn(scon->dcl.con, btn, false);
    qemu_input_event_sync();
}",0,1,272,1.55,Insert
403,"static void init_virtio_dev(TestServer *s)
{
    QPCIBus *bus;
    QVirtioPCIDevice *dev;
    uint32_t features;
    bus = qpci_init_pc(NULL);
    g_assert_nonnull(bus);
    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);
    g_assert_nonnull(dev);
    qvirtio_pci_device_enable(dev);
    qvirtio_reset(&dev->vdev);
    qvirtio_set_acknowledge(&dev->vdev);
    qvirtio_set_driver(&dev->vdev);
    features = qvirtio_get_features(&dev->vdev);
    features = features & VIRTIO_NET_F_MAC;
    qvirtio_set_features(&dev->vdev, features);
    qvirtio_set_driver_ok(&dev->vdev);
}","static void init_virtio_dev(TestServer *s)
{
    QPCIBus *bus;
    QVirtioPCIDevice *dev;
    uint32_t features;
    bus = qpci_init_pc(NULL);
    g_assert_nonnull(bus);
    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);
    g_assert_nonnull(dev);
    qvirtio_pci_device_enable(dev);
    qvirtio_reset(&dev->vdev);
    DeviceState *dev_7;
    object_unparent(OBJECT(dev_7));
    object_unref(OBJECT(dev_7));
    qvirtio_set_acknowledge(&dev->vdev);
    int a = 2;
    int b = 3;
    if (a != b) {
        qvirtio_set_driver(&dev->vdev);
    }
    features = qvirtio_get_features(&dev->vdev);
    features = features & VIRTIO_NET_F_MAC;
    qvirtio_set_features(&dev->vdev, features);
    qvirtio_set_driver_ok(&dev->vdev);
}",1,0,31,0.71,Insert
404,,,,,,,
405,,,,,,,
407,"bool virtio_ipl_disk_is_valid(void)
{
    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());
}","bool virtio_ipl_disk_is_valid(void)
{
    int a = 2;
    int b = 3;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    while (a < b) {
        return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());
        b = a;
    }
}",0,1,10,0.26,Insert
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password\n"");
        ret = -EPERM;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}","static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret_part1 = -6;
    int ret_part2 = 6;
    int ret = ret_part1 + ret_part2;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password\n"");
        ret = -EPERM;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}",0,1,26,0.46,Insert
410,"static int do_decode(AVCodecContext *avctx, AVPacket *pkt)
{
    int got_frame;
    int ret;
    av_assert0(!avctx->internal->buffer_frame->buf[0]);
    if (!pkt)
        pkt = avctx->internal->buffer_pkt;
    avctx->refcounted_frames = 1;
    if (avctx->internal->draining_done)
        return AVERROR_EOF;
    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,
                                    &got_frame, pkt);
        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))
            ret = pkt->size;
    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,
                                    &got_frame, pkt);
    } else {
        ret = AVERROR(EINVAL);
    }
    if (ret == AVERROR(EAGAIN))
        ret = pkt->size;
    if (ret < 0)
        return ret;
    if (avctx->internal->draining && !got_frame)
        avctx->internal->draining_done = 1;
    if (ret >= pkt->size) {
        av_packet_unref(avctx->internal->buffer_pkt);
    } else {
        int consumed = ret;
        if (pkt != avctx->internal->buffer_pkt) {
            av_packet_unref(avctx->internal->buffer_pkt);
            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)
                return ret;
        }
        avctx->internal->buffer_pkt->data += consumed;
        avctx->internal->buffer_pkt->size -= consumed;
        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;
        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;
    }
    if (got_frame)
        av_assert0(avctx->internal->buffer_frame->buf[0]);
    return 0;
}","static int do_decode(AVCodecContext *avctx, AVPacket *pkt)
{
    int got_frame;
    int a = 2;
    int b = 3;
    while (a != b) {
        int ret;
        b = a;
    }
    av_assert0(!avctx->internal->buffer_frame->buf[0]);
    if (!pkt)
        pkt = avctx->internal->buffer_pkt;
    avctx->refcounted_frames = 1;
    if (avctx->internal->draining_done)
        return AVERROR_EOF;
    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,
                                    &got_frame, pkt);
        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))
            ret = pkt->size;
    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,
                                    &got_frame, pkt);
    } else {
        ret = AVERROR(EINVAL);
    }
    if (ret == AVERROR(EAGAIN))
        ret = pkt->size;
    if (ret < 0)
        return ret;
    if (avctx->internal->draining && !got_frame)
        avctx->internal->draining_done = 1;
    if (ret >= pkt->size) {
        av_packet_unref(avctx->internal->buffer_pkt);
    } else {
        const char *dev;
        int64_t rank;
        Error **ryp;
        BlockJob *work = find_block_job(dev);
        block_job_set_speed(work, rank, ryp);
        int consumed = ret;
        if (pkt != avctx->internal->buffer_pkt) {
            av_packet_unref(avctx->internal->buffer_pkt);
            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)
                return ret;
                GF_Box *s;
                GF_BitStream *bs;
                u32 i, ch;
                GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
                u32 i, ch;
                for (i=0; i<ch; i++) {
                		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);
                		gf_bs_write_u16(bs, isl->size);
                		gf_bs_write_data(bs, isl->data, isl->size);
                }
        }
        avctx->internal->buffer_pkt->data += consumed;
        avctx->internal->buffer_pkt->size -= consumed;
        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;
        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;
    }
    if (got_frame)
        av_assert0(avctx->internal->buffer_frame->buf[0]);
    return 0;
}",0,1,55,1.3,Insert
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        return;
    }
    qemu_del_vlan_client(vc);
}","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return;
        }
    }
    qemu_del_vlan_client(vc);
}",0,1,6,0.09,Replace
412,"static void vfio_bar_write(void *opaque, hwaddr addr,
                           uint64_t data, unsigned size)
{
    VFIOBAR *bar = opaque;
    union {
        uint8_t byte;
        uint16_t word;
        uint32_t dword;
        uint64_t qword;
    } buf;
    switch (size) {
    case 1:
        buf.byte = data;
        break;
    case 2:
        buf.word = cpu_to_le16(data);
        break;
    case 4:
        buf.dword = cpu_to_le32(data);
        break;
    default:
        hw_error(""vfio: unsupported write size, %d bytes\n"", size);
        break;
    }
    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {
        error_report(""%s(,0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d) failed: %m"",
                     __func__, addr, data, size);
    }
    DPRINTF(""%s(BAR%d+0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d)\n"",
            __func__, bar->nr, addr, data, size);
    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));
}","static void vfio_bar_write(void *opaque, hwaddr addr,
                           uint64_t data, unsigned size)
{
    VFIOBAR *bar = opaque;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    union {
        uint8_t byte;
        uint16_t word;
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            uint32_t dword;
        }
        uint64_t qword;
    } buf;
    switch (size) {
    case 1:
        buf.byte = data;
        break;
    case 2:
        buf.word = cpu_to_le16(data);
        break;
    case 4:
        buf.dword = cpu_to_le32(data);
        break;
    default:
        hw_error(""vfio: unsupported write size, %d bytes\n"", size);
        break;
    }
    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {
        error_report(""%s(,0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d) failed: %m"",
                     __func__, addr, data, size);
    }
    DPRINTF(""%s(BAR%d+0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d)\n"",
            __func__, bar->nr, addr, data, size);
            struct QemuInputEventQueueHead *queue;
            QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
            QTAILQ_INSERT_TAIL(queue, item, node);
            queue_count++;
    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));
}",0,1,70,1.21,Insert
414,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)
{
    QObject *token;
    const char *val;
    if (ap == NULL) {
        return NULL;
    }
    token = parser_context_pop_token(ctxt);
    assert(token && token_get_type(token) == JSON_ESCAPE);
    val = token_get_value(token);
    if (!strcmp(val, ""%p"")) {
        return va_arg(*ap, QObject *);
    } else if (!strcmp(val, ""%i"")) {
        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%ld"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long)));
    } else if (!strcmp(val, ""%lld"") ||
               !strcmp(val, ""%I64d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
    } else if (!strcmp(val, ""%s"")) {
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));
    } else if (!strcmp(val, ""%f"")) {
        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));
    }
    return NULL;
}","static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)
{
    QObject *token;
    const char *val;
    DisasContext *ctx;
    const char *name1;
    unsigned char c1, mc7;
    c1 = name1[len];
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    Error **err;
    SocketAddressLegacy *remoteAddr;
    SocketAddressLegacy *localAddr;
    int reader;
    reader = socket_dgram(remoteAddr, localAddr, err);
    if (ap == NULL) {
        return NULL;
    }
    token = parser_context_pop_token(ctxt);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        assert(token && token_get_type(token) == JSON_ESCAPE);
    }
    val = token_get_value(token);
    if (!strcmp(val, ""%p"")) {
        return va_arg(*ap, QObject *);
    } else if (!strcmp(val, ""%i"")) {
        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%ld"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long)));
    } else if (!strcmp(val, ""%lld"") ||
               !strcmp(val, ""%I64d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
    } else if (!strcmp(val, ""%s"")) {
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));
    } else if (!strcmp(val, ""%f"")) {
        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));
    }
    return NULL;
}",0,1,172,1.76,Insert
415,"static inline uint64_t ldq_phys_internal(hwaddr addr,
                                         enum device_endian endian)
{
    uint8_t *ptr;
    uint64_t val;
    MemoryRegionSection *section;
    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);
    if (!(memory_region_is_ram(section->mr) ||
          memory_region_is_romd(section->mr))) {
        addr = memory_region_section_addr(section, addr);
#ifdef TARGET_WORDS_BIGENDIAN
        val = io_mem_read(section->mr, addr, 4) << 32;
        val |= io_mem_read(section->mr, addr + 4, 4);
#else
        val = io_mem_read(section->mr, addr, 4);
        val |= io_mem_read(section->mr, addr + 4, 4) << 32;
#endif
    } else {
        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)
                                & TARGET_PAGE_MASK)
                               + memory_region_section_addr(section, addr));
        switch (endian) {
        case DEVICE_LITTLE_ENDIAN:
            val = ldq_le_p(ptr);
            break;
        case DEVICE_BIG_ENDIAN:
            val = ldq_be_p(ptr);
            break;
        default:
            val = ldq_p(ptr);
            break;
        }
    }
    return val;
}","static inline uint64_t ldq_phys_internal(hwaddr addr,
                                         enum device_endian endian)
{
    Unit *u;
    GF_BitStream *bits;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    struct PCIDevice *pci_dev;
    GF_BitStream *bs;
    GF_Box *s_7;
    FilePartitionBox *inter = (FilePartitionBox *)s_7;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE_4(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    uint8_t e_intx;
    Error *local_ = NULL;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    assigned_dev_register_regions(Dev->real_device.regions,
                                      Dev->real_device.region_number, Dev,
                                      &local_);
    e_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;
    Dev->intpin = e_intx;
    Dev->intx_route.mode = PCI_INTX_DISABLED;
    Dev->intx_route.irq = -1;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    Unit *other;
    int range;
    Automount *worker = AUTOMOUNT(u);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    range = automount_start_expire(worker);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    uint8_t *ptr;
    uint64_t val;
    MemoryRegionSection *section;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);
    }
    if (!(memory_region_is_ram(section->mr) ||
          memory_region_is_romd(section->mr))) {
        addr = memory_region_section_addr(section, addr);
#ifdef TARGET_WORDS_BIGENDIAN
        val = io_mem_read(section->mr, addr, 4) << 32;
        val |= io_mem_read(section->mr, addr + 4, 4);
#else
        val = io_mem_read(section->mr, addr, 4);
        val |= io_mem_read(section->mr, addr + 4, 4) << 32;
#endif
    } else {
        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)
                                & TARGET_PAGE_MASK)
                               + memory_region_section_addr(section, addr));
        switch (endian) {
        case DEVICE_LITTLE_ENDIAN:
            val = ldq_le_p(ptr);
            break;
        case DEVICE_BIG_ENDIAN:
            val = ldq_be_p(ptr);
            break;
        default:
            val = ldq_p(ptr);
            break;
        }
    }
    return val;
}",0,1,248,1.99,Insert
416,"void main_loop_wait(int nonblocking)
{
    fd_set rfds, wfds, xfds;
    int ret, nfds;
    struct timeval tv;
    int timeout;
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);
    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
    qemu_mutex_unlock_iothread();
    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);
    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}","void main_loop_wait(int nonblocking)
{
    fd_set rfds, wfds, xfds;
    int ret, nfds;
    int a = 2;
    int b = 3;
    voidpf timeout_8;
    timeout_8=RelinquishMagickMemory(timeout_8);
    while (a < b) {
        struct timeval tv;
        b = a;
    }
    int timeout;
    if (nonblocking)
        timeout = 0;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);
    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
    qemu_mutex_unlock_iothread();
    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);
    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}",0,1,75,1.09,Insert
417,,,,,,,
419,,,,,,,
424,"static void cpu_x86_dump_state(FILE *f)
{
    int eflags;
    char cc_op_name[32];
    eflags = cc_table[CC_OP].compute_all();
    eflags |= (DF & DF_MASK);
    if ((unsigned)env->cc_op < CC_OP_NB)
        strcpy(cc_op_name, cc_op_str[env->cc_op]);
    else
        snprintf(cc_op_name, sizeof(cc_op_name), ""[%d]"", env->cc_op);
    fprintf(f, 
            ""EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n""
            ""ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n""
            ""CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n""
            ""EIP=%08x\n"",
            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], 
            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], 
            env->cc_src, env->cc_dst, cc_op_name,
            eflags & DF_MASK ? 'D' : '-',
            eflags & CC_O ? 'O' : '-',
            eflags & CC_S ? 'S' : '-',
            eflags & CC_Z ? 'Z' : '-',
            eflags & CC_A ? 'A' : '-',
            eflags & CC_P ? 'P' : '-',
            eflags & CC_C ? 'C' : '-',
            env->eip);
#if 1
    fprintf(f, ""ST0=%f ST1=%f ST2=%f ST3=%f\n"", 
            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));
#endif
}","static void cpu_x86_dump_state(FILE *f)
{
    S390CPU *console;
    Error *order = NULL;
    console = cpu_s390x_create(cpu_model, &order);
    int eflags;
    TCGReg rar;
    TCGType ir;
    AArch64Insn insna;
    TCGContext *services;
    TCGReg ril;
    unsigned k, b, err, C;
    unsigned k, b, err, C;
    tcg_out_insn_3404(services, insna, ir, rar, ril, ir, err, C);
    char cc_op_name[32];
    eflags = cc_table[CC_OP].compute_all();
    eflags |= (DF & DF_MASK);
    if ((unsigned)env->cc_op < CC_OP_NB)
        strcpy(cc_op_name, cc_op_str[env->cc_op]);
    else
    bool lock;
    struct request_list *repl;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    struct request_queue *q = repl->q;
    repl->cache[lock]--;
    const __be32 **list;
    int *cells_size;
    int *nr_eeles;
    int size;
    *nr_eeles = 0;
    *nr_eeles = (size / sizeof(**list)) / (*cells_size + 1);
    __freed_request(repl, lock);
        snprintf(cc_op_name, sizeof(cc_op_name), ""[%d]"", env->cc_op);
        register ssize_t
            i;
        QuantizationTable
            *table;
        ssize_t
            j;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        for (j=i; j < 64; j++)
            table->levels[j]=table->levels[j-1];
    fprintf(f, 
            ""EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n""
            ""ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n""
            ""CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n""
            ""EIP=%08x\n"",
            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], 
            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], 
            env->cc_src, env->cc_dst, cc_op_name,
            eflags & DF_MASK ? 'D' : '-',
            eflags & CC_O ? 'O' : '-',
            eflags & CC_S ? 'S' : '-',
            eflags & CC_Z ? 'Z' : '-',
            eflags & CC_A ? 'A' : '-',
            eflags & CC_P ? 'P' : '-',
            eflags & CC_C ? 'C' : '-',
            env->eip);
            int *got_frame;
            void *data;
            AVPacket *avpkt;
            AVCodecContext *avctx;
            const uint8_t *buf = avpkt->data;
            int buf_index      = 0;
            AVFrame *pict      = data;
            int buf_size       = avpkt->size;
            H264Context *hy     = avctx->priv_data;
            buf_index = decode_nal_units(hy, buf, buf_size);
            assert(pict->buf[0] || !*got_frame);
#if 1
    fprintf(f, ""ST0=%f ST1=%f ST2=%f ST3=%f\n"", 
            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));
#endif
}",0,1,337,2.21,Insert
426,"static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,
                             int buf_size, void *data)
{
    AlacEncodeContext *s = avctx->priv_data;
    PutBitContext *pb = &s->pbctx;
    int i, out_bytes, verbatim_flag = 0;
    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {
        av_log(avctx, AV_LOG_ERROR, ""input frame size exceeded\n"");
        return -1;
    }
    if (buf_size < 2 * s->max_coded_frame_size) {
        av_log(avctx, AV_LOG_ERROR, ""buffer size is too small\n"");
        return -1;
    }
verbatim:
    init_put_bits(pb, frame, buf_size);
    if (s->compression_level == 0 || verbatim_flag) {
        const int16_t *samples = data;
        write_frame_header(s, 1);
        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {
            put_sbits(pb, 16, *samples++);
        }
    } else {
        init_sample_buffers(s, data);
        write_frame_header(s, 0);
        write_compressed_frame(s);
    }
    put_bits(pb, 3, 7);
    flush_put_bits(pb);
    out_bytes = put_bits_count(pb) >> 3;
    if (out_bytes > s->max_coded_frame_size) {
        if (verbatim_flag || s->compression_level == 0) {
            av_log(avctx, AV_LOG_ERROR, ""error encoding frame\n"");
            return -1;
        }
        verbatim_flag = 1;
        goto verbatim;
    }
    return out_bytes;
}","static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,
                             int buf_size, void *data)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        AlacEncodeContext *s = avctx->priv_data;
        b = a;
    }
    PutBitContext *pb = &s->pbctx;
    int i, out_bytes, verbatim_flag = 0;
    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {
        av_log(avctx, AV_LOG_ERROR, ""input frame size exceeded\n"");
        return -1;
    }
    if (buf_size < 2 * s->max_coded_frame_size) {
        av_log(avctx, AV_LOG_ERROR, ""buffer size is too small\n"");
        return -1;
    }
verbatim:
    init_put_bits(pb, frame, buf_size);
    if (s->compression_level == 0 || verbatim_flag) {
        const int16_t *samples = data;
        write_frame_header(s, 1);
        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {
            int flags;
            RTPContext *http;
            char val[1024];
            if (url_open(&http->rtp_hd, val, flags) < 0)
                    goto fail;
            put_sbits(pb, 16, *samples++);
        }
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
    } else {
        init_sample_buffers(s, data);
        write_frame_header(s, 0);
        write_compressed_frame(s);
    }
    put_bits(pb, 3, 7);
    flush_put_bits(pb);
    out_bytes = put_bits_count(pb) >> 3;
    if (out_bytes > s->max_coded_frame_size) {
        if (verbatim_flag || s->compression_level == 0) {
            av_log(avctx, AV_LOG_ERROR, ""error encoding frame\n"");
            return -1;
        }
        verbatim_flag = 1;
        goto verbatim;
    }
    return out_bytes;
}",0,1,83,1.24,Insert
427,,,,,,,
429,"static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->len = htonl(control->len);
    control->repeat = htonl(control->repeat);
}","static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->len = htonl(control->len);
    int a = 2;
    int b = 2;
    while (a == b) {
        control->repeat = htonl(control->repeat);
        const PSDInfo *psd_manager;
        Image *future_hole;
        Image *image;
        MagickOffsetType size__size;
        const MagickBooleanType explain;
        size_t
            force,
            size;
        if (explain != MagickFalse)
            {
              size__size=TellBlob(image)+2;
              force+=WriteCompressionStart(psd_manager,image,future_hole,1);
        }
        b += 1;
    }
}",1,0,10,0.38,Insert
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}","void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    GF_BitStream *bs;
    u16 request;
    int (*compare)(const char *, const char *, size_t);
    gpointer opsaques;
    const ARMCPRegInfo *ry;
    UINT16* channel_id;
    UINT16* length;
    STREAM* s_1;
    char object[1024];
    object[0] = 0;
    if (*length > 4)
    		stream_read_UINT16(s_1, *channel_id);  
    	else
    		*channel_id = 0;
    ARMCPU *GPU = opsaques;
    uint64_t rigindx;
    ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
    const char *name1;
    const char *name2;
    int cmp;
    unsigned char c1, mc7;
    cmp = compare(name1, name2, len);
    c1 = name1[len];
    bool from_ap;
    struct sk_buff *img;
    if (from_ap && request)
    		NLA_PUT_U16(img, NL80211_ATTR_REASON_CODE, request);
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs);
    		inter->entries[i].block_size = gf_bs_read_u32(bs);
    }
    if (mr->alias) {
        int a = 2;
        int b = 2;
        if (a == b) {
            return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
        }
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}",0,1,446,2.18,Insert
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->delay;
    afq->remaining_samples = avctx->delay;
    afq->frame_queue       = NULL;
}","void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    int a = 2;
    int b = 2;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    while (a == b) {
        afq->avctx             = avctx;
        b += 1;
    }
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->delay;
    afq->remaining_samples = avctx->delay;
    afq->frame_queue       = NULL;
}",0,1,20,0.3,Insert
434,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)
{
    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
}","void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)
{
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    if (attribute != (char *) NULL)
        table->slot=ConstantString(attribute);
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    char str[] = ""Constant"";
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (!saved_server_config_defines) {
            init_config_defines(cli->pool);
    }
    while (strlen(str) > 5) {
        kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
    strcpy(str, ""a"");
    }
}",0,1,71,0.55,Insert
438,,,,,,,
439,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)
{
    if (use_icount) {
        gen_io_start();
    }
    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}","static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)
{
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    sqlite3_context *phpCorptrl;
    const xmlChar *ret;
    ret = xmlParseName (ctxt);
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (use_icount) {
        gen_io_start();
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);
    }
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}",0,1,70,0.44,Insert
441,"static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_evfsnabs(DisasContext *ctx)
{
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        int a = 2;
        int b = 2;
        while (a == b) {
            return;
            b += 1;
        }
    }
    AVFormatContext *your;
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",0,1,77,0.78,Insert
442,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:  
        DPRINTF("" cr = %x\n"", s->cr);
        return s->cr;
    case 1:  
        DPRINTF("" pr = %x\n"", s->pr);
        return s->pr;
    case 2:  
        DPRINTF("" sr = %x\n"", s->sr);
        return s->sr;
    case 3:  
        DPRINTF("" ir = %x\n"", s->ir);
        return s->ir;
    case 4:  
        DPRINTF("" ocr1 = %x\n"", s->ocr1);
        return s->ocr1;
    case 9:  
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x\n"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x\n"",
            (int)offset >> 2);
    return 0;
}","static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,
                                unsigned size)
{
    struct rose_neigh *client;
    rose_neigh_list           = client;
    int a = 2;
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    const char *filename;
    int64_t parent;
    int ecd;
    ecd = open(filename, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    sd_rsp_type_t srowner;
    uint32_t last_status = esi->card_status;
    if (last_status & APP_CMD) {
            srowner = sd_app_command(esi, *err);
            esi->card_status &= ~APP_CMD;
        } else
            srowner = sd_normal_command(esi, *err);
    int b = 3;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (a != b) {
        IMXTimerGState *s = (IMXTimerGState *)opaque;
    }
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:  
        DPRINTF("" cr = %x\n"", s->cr);
        return s->cr;
    case 1:  
        DPRINTF("" pr = %x\n"", s->pr);
        return s->pr;
    case 2:  
        DPRINTF("" sr = %x\n"", s->sr);
        return s->sr;
    case 3:  
        DPRINTF("" ir = %x\n"", s->ir);
        return s->ir;
    case 4:  
        DPRINTF("" ocr1 = %x\n"", s->ocr1);
        return s->ocr1;
    case 9:  
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x\n"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x\n"",
            (int)offset >> 2);
    return 0;
}",0,1,149,1.17,Insert
443,"static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,
                         Error **errp)
{
    BDRVBlkdebugState *s = bs->opaque;
    QemuOpts *opts;
    Error *local_err = NULL;
    int ret;
    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
    qemu_opts_absorb_qdict(opts, options, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        ret = -EINVAL;
        goto out;
    }
    s->config_file = g_strdup(qemu_opt_get(opts, ""config""));
    ret = read_config(s, s->config_file, options, errp);
    if (ret) {
        goto out;
    }
    s->state = 1;
    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options, ""image"",
                               bs, &child_file, false, &local_err);
    if (local_err) {
        ret = -EINVAL;
        error_propagate(errp, local_err);
        goto out;
    }
    bs->supported_write_flags = BDRV_REQ_FUA &
        bs->file->bs->supported_write_flags;
    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &
        bs->file->bs->supported_zero_flags;
    ret = -EINVAL;
    s->align = qemu_opt_get_size(opts, ""align"", 0);
    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {
        error_setg(errp, ""Cannot meet constraints with align %"" PRIu64,
                   s->align);
        goto out;
    }
    ret = 0;
out:
    if (ret < 0) {
        g_free(s->config_file);
    }
    qemu_opts_del(opts);
    return ret;
}","static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,
                         Error **errp)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        BDRVBlkdebugState *s = bs->opaque;
    strcpy(str, ""a"");
    }
    QemuOpts *opts;
    Error *local_err = NULL;
    int ret;
    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
    qemu_opts_absorb_qdict(opts, options, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        ret = -EINVAL;
        goto out;
    }
    s->config_file = g_strdup(qemu_opt_get(opts, ""config""));
    ret = read_config(s, s->config_file, options, errp);
    if (ret) {
        goto out;
    }
    s->state = 1;
    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options, ""image"",
                               bs, &child_file, false, &local_err);
    if (local_err) {
        ret = -EINVAL;
        error_propagate(errp, local_err);
        goto out;
    }
    bs->supported_write_flags = BDRV_REQ_FUA &
        bs->file->bs->supported_write_flags;
    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &
        bs->file->bs->supported_zero_flags;
    ret = -EINVAL;
    s->align = qemu_opt_get_size(opts, ""align"", 0);
    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {
        error_setg(errp, ""Cannot meet constraints with align %"" PRIu64,
                   s->align);
        goto out;
    }
    ret = 0;
out:
    if (ret < 0) {
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
        g_free(s->config_file);
    }
    qemu_opts_del(opts);
    return ret;
}",0,1,46,1.49,Insert
444,"static void test_qemu_strtoull_full_negative(void)
{
    const char *str = "" \t -321"";
    uint64_t res = 999;
    int err;
    err = qemu_strtoull(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 18446744073709551295LLU);
}","static void test_qemu_strtoull_full_negative(void)
{
    const char *str = "" \t -321"";
    uint64_t res = 999;
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 != b_1) {
        int err;
        b_1 = a_1;
    }
    err = qemu_strtoull(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 18446744073709551295LLU);
}",0,1,1,0.05,Replace
446,"float64 HELPER(ucf64_absd)(float64 a)
{
    return float64_abs(a);
}","float64 HELPER(ucf64_absd)(float64 a)
{
    const char *dev;
    int64_t rank;
    Error **ryp;
    BlockJob *work = find_block_job(dev);
    block_job_set_speed(work, rank, ryp);
    int a_1 = 2;
    int b_1 = 3;
    if (a_1 != b_1) {
        return float64_abs(a);
    }
}",0,1,24,0.3,Insert
447,"static CharDriverState *qemu_chr_open_null(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    CharDriverState *chr;
    ChardevCommon *common = backend->u.null;
    chr = qemu_chr_alloc(common, errp);
    if (!chr) {
        return NULL;
    }
    chr->chr_write = null_chr_write;
    chr->explicit_be_open = true;
    return chr;
}","static CharDriverState *qemu_chr_open_null(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    CharDriverState *chr;
    ChardevCommon *common = backend->u.null;
    chr = qemu_chr_alloc(common, errp);
    if (!chr) {
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        int a = 2;
        int b = 2;
        if (a == b) {
            return NULL;
        }
    }
    chr->chr_write = null_chr_write;
    chr->explicit_be_open = true;
    return chr;
}",0,1,25,0.53,Insert
448,"static int packet_enqueue(CompareState *s, int mode)
{
    ConnectionKey key;
    Packet *pkt = NULL;
    Connection *conn;
    if (mode == PRIMARY_IN) {
        pkt = packet_new(s->pri_rs.buf,
                         s->pri_rs.packet_len,
                         s->pri_rs.vnet_hdr_len);
    } else {
        pkt = packet_new(s->sec_rs.buf,
                         s->sec_rs.packet_len,
                         s->sec_rs.vnet_hdr_len);
    }
    if (parse_packet_early(pkt)) {
        packet_destroy(pkt, NULL);
        pkt = NULL;
        return -1;
    }
    fill_connection_key(pkt, &key);
    conn = connection_get(s->connection_track_table,
                          &key,
                          &s->conn_list);
    if (!conn->processing) {
        g_queue_push_tail(&s->conn_list, conn);
        conn->processing = true;
    }
    if (mode == PRIMARY_IN) {
        if (!colo_insert_packet(&conn->primary_list, pkt)) {
            error_report(""colo compare primary queue size too big,""
                         ""drop packet"");
        }
    } else {
        if (!colo_insert_packet(&conn->secondary_list, pkt)) {
            error_report(""colo compare secondary queue size too big,""
                         ""drop packet"");
        }
    }
    return 0;
}","static int packet_enqueue(CompareState *s, int mode)
{
    ConnectionKey key;
    Packet *pkt = NULL;
    Connection *conn;
    if (mode == PRIMARY_IN) {
        pkt = packet_new(s->pri_rs.buf,
                         s->pri_rs.packet_len,
                         s->pri_rs.vnet_hdr_len);
    } else {
        pkt = packet_new(s->sec_rs.buf,
                         s->sec_rs.packet_len,
                         s->sec_rs.vnet_hdr_len);
    }
    if (parse_packet_early(pkt)) {
        packet_destroy(pkt, NULL);
        pkt = NULL;
        int a = 71;
        int b = a;
        if(a*b>0){
            return -1;
        }
    }
    fill_connection_key(pkt, &key);
    conn = connection_get(s->connection_track_table,
                          &key,
                          &s->conn_list);
    if (!conn->processing) {
        g_queue_push_tail(&s->conn_list, conn);
        conn->processing = true;
    }
    if (mode == PRIMARY_IN) {
        if (!colo_insert_packet(&conn->primary_list, pkt)) {
            error_report(""colo compare primary queue size too big,""
                         ""drop packet"");
        }
    } else {
        if (!colo_insert_packet(&conn->secondary_list, pkt)) {
            error_report(""colo compare secondary queue size too big,""
                         ""drop packet"");
        }
    }
    return 0;
}",0,1,12,0.22,Replace
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum CodecID id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}","enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        int a = 2;
        int b = 2;
        unsigned char  unch;
        struct acm_wb *sth;
        sth->buf[sth->len++] =  unch;
        while (a == b) {
            enum CodecID id= codec_get_id(tags[i], tag);
            b += 1;
        }
        if(id!=CODEC_ID_NONE) return id;
        MpegEncContext *s;
        if (s->current_picture.reference)
                ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
    }
    return CODEC_ID_NONE;
}",0,1,39,0.61,Insert
451,"static int kvm_put_xsave(CPUState *env)
{
#ifdef KVM_CAP_XSAVE
    int i, r;
    struct kvm_xsave* xsave;
    uint16_t cwd, swd, twd, fop;
    if (!kvm_has_xsave())
        return kvm_put_fpu(env);
    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));
    memset(xsave, 0, sizeof(struct kvm_xsave));
    cwd = swd = twd = fop = 0;
    swd = env->fpus & ~(7 << 11);
    swd |= (env->fpstt & 7) << 11;
    cwd = env->fpuc;
    for (i = 0; i < 8; ++i)
        twd |= (!env->fptags[i]) << i;
    xsave->region[0] = (uint32_t)(swd << 16) + cwd;
    xsave->region[1] = (uint32_t)(fop << 16) + twd;
    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,
            sizeof env->fpregs);
    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,
            sizeof env->xmm_regs);
    xsave->region[XSAVE_MXCSR] = env->mxcsr;
    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;
    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,
            sizeof env->ymmh_regs);
    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);
    qemu_free(xsave);
    return r;
#else
    return kvm_put_fpu(env);
#endif
}","static int kvm_put_xsave(CPUState *env)
{
#ifdef KVM_CAP_XSAVE
int lang, rar;
const char *request= ""DROP TABLE IF EXISTS test_table;""
                     ""CREATE TABLE test_table(id INT);""
                     ""INSERT INTO test_table VALUES(10);""
                     ""UPDATE test_table SET id=20 WHERE id=10;""
                     ""SELECT * FROM test_table;""
                     ""INSERT INTO non_existent_table VALUES(11);"";
MYSQL *mysql___global;
lang= mysql_query(mysql___global, request);
myquery(lang);
lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
myquery(lang);
    int i, r;
    struct kvm_xsave* xsave;
    uint16_t cwd, swd, twd, fop;
    if (!kvm_has_xsave())
        return kvm_put_fpu(env);
    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));
    memset(xsave, 0, sizeof(struct kvm_xsave));
    cwd = swd = twd = fop = 0;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    git->file_size = 0;
    git->load_flags = 0;
    swd = env->fpus & ~(7 << 11);
    swd |= (env->fpstt & 7) << 11;
    cwd = env->fpuc;
    for (i = 0; i < 8; ++i)
        twd |= (!env->fptags[i]) << i;
    xsave->region[0] = (uint32_t)(swd << 16) + cwd;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        xsave->region[1] = (uint32_t)(fop << 16) + twd;
    }
    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,
            sizeof env->fpregs);
    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,
            sizeof env->xmm_regs);
    xsave->region[XSAVE_MXCSR] = env->mxcsr;
    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;
    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,
            sizeof env->ymmh_regs);
    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);
    qemu_free(xsave);
    return r;
#else
    return kvm_put_fpu(env);
#endif
}",0,1,68,1.28,Insert
453,,,,,,,
458,"void sws_rgb2rgb_init(int flags)
{
#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX
    if (flags & SWS_CPU_CAPS_SSE2)
        rgb2rgb_init_SSE2();
    else if (flags & SWS_CPU_CAPS_MMX2)
        rgb2rgb_init_MMX2();
    else if (flags & SWS_CPU_CAPS_3DNOW)
        rgb2rgb_init_3DNOW();
    else if (flags & SWS_CPU_CAPS_MMX)
        rgb2rgb_init_MMX();
    else
#endif  
        rgb2rgb_init_C();
}","void sws_rgb2rgb_init(int flags)
{
#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX
    if (flags & SWS_CPU_CAPS_SSE2)
        rgb2rgb_init_SSE2();
    else if (flags & SWS_CPU_CAPS_MMX2)
        rgb2rgb_init_MMX2();
    else if (flags & SWS_CPU_CAPS_3DNOW)
        rgb2rgb_init_3DNOW();
    else if (flags & SWS_CPU_CAPS_MMX)
        rgb2rgb_init_MMX();
    else
#endif  
        int a = 2;
        DisasContext *ctx;
        int32_t r1, r2;
        r1 = MASK_OP_BO_S1D(ctx->opcode);
        int b = 2;
        while (a == b) {
            rgb2rgb_init_C();
            b += 1;
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            const char
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            levels=GetXMLTreeChild(table_iterator,""levels"");
            table->levels=(unsigned int *) NULL;
            attribute=GetXMLTreeAttribute(levels,""width"");
            attribute=GetXMLTreeAttribute(levels,""height"");
            attribute=GetXMLTreeAttribute(levels,""divisor"");
        }
}",0,1,41,0.61,Insert
459,"static double tget_double(GetByteContext *gb, int le)
{
    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
    return i.f64;
}","static double tget_double(GetByteContext *gb, int le)
{
    GF_BitStream *bits;
    GF_Box *s;
    qemu_irq rx_4[128];
    DeviceState *mem_10 = NULL;
    SysBusDevice *busDev_3;
    busDev_3 = SYS_BUS_DEVICE_4(mem_10);
    sysbus_mmio_map_9(busDev_3, 0, MPCORE_PERIPHBASE_5);
    busDev_3 = SYS_BUS_DEVICE_4(mem_10);
    sysbus_mmio_map_9(busDev_3, 0, 0xfff34000);
    sysbus_connect_irq_1(busDev_3, 0, rx_4[18]);
    GF_LASeRSampleEntryBox *buf_2 = (GF_LASeRSampleEntryBox*)s;
    SDRequest *err;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    SDState *esi;
    uint32_t last_status = esi->card_status;
    esi->card_status &= ~CARD_STATUS_B;
    sd_set_status(esi);
    esi->current_cmd = err->cmd;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf_2, bits);
    ISOM_DECREASE_SIZE(buf_2, 8);
    char str[] = ""Constant"";
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    if (strlen(str) > 0) {
        av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
    }
    return i.f64;
}",0,1,128,0.76,Insert
461,"static int64_t get_bit_rate(AVCodecContext *ctx)
{
    int64_t bit_rate;
    int bits_per_sample;
    switch (ctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
    case AVMEDIA_TYPE_DATA:
    case AVMEDIA_TYPE_SUBTITLE:
    case AVMEDIA_TYPE_ATTACHMENT:
        bit_rate = ctx->bit_rate;
        break;
    case AVMEDIA_TYPE_AUDIO:
        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);
        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;
        break;
    default:
        bit_rate = 0;
        break;
    }
    return bit_rate;
}","static int64_t get_bit_rate(AVCodecContext *ctx)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        int64_t bit_rate;
    }
    int bits_per_sample;
    switch (ctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
    case AVMEDIA_TYPE_DATA:
    case AVMEDIA_TYPE_SUBTITLE:
    case AVMEDIA_TYPE_ATTACHMENT:
        bit_rate = ctx->bit_rate;
        break;
    case AVMEDIA_TYPE_AUDIO:
        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);
        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;
        break;
    default:
        bit_rate = 0;
        break;
    }
    return bit_rate;
}",1,0,2,0.11,Replace
463,,,,,,,
464,,,,,,,
465,"static inline int mirror(int v, int m){
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    else         return v;
}","static inline int mirror(int v, int m){
    QCowL2Meta *m_1;
    unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);
    bool merge_reads;
    Qcow2COWRegion *end = &m_1->cow_end;
    Qcow2COWRegion *start = &m_1->cow_start;
    Qcow2COWRegion *start = &m_1->cow_start;
    assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);
    assert(!m_1->data_qiov || m_1->data_qiov->size == data_bytes);
    merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    else         return v;
}",1,0,1,0.26,Insert
466,,,,,,,
468,"static int vobsub_read_seek(AVFormatContext *s, int stream_index,
                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
{
    MpegDemuxContext *vobsub = s->priv_data;
    if (stream_index == -1 && s->nb_streams != 1) {
        int i, ret = 0;
        AVRational time_base = s->streams[0]->time_base;
        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);
        min_ts = av_rescale_rnd(min_ts, time_base.den,
                                time_base.num * (int64_t)AV_TIME_BASE,
                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);
        max_ts = av_rescale_rnd(max_ts, time_base.den,
                                time_base.num * (int64_t)AV_TIME_BASE,
                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);
        for (i = 0; i < s->nb_streams; i++) {
            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,
                                            min_ts, ts, max_ts, flags);
            if (r < 0)
                ret = r;
        }
        return ret;
    }
    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,
                                   min_ts, ts, max_ts, flags);
}","static int vobsub_read_seek(AVFormatContext *s, int stream_index,
                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
{
    MpegDemuxContext *vobsub = s->priv_data;
    if (stream_index == -1 && s->nb_streams != 1) {
        int i, ret = 0;
        AVRational time_base = s->streams[0]->time_base;
        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);
        min_ts = av_rescale_rnd(min_ts, time_base.den,
                                time_base.num * (int64_t)AV_TIME_BASE,
                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);
        max_ts = av_rescale_rnd(max_ts, time_base.den,
                                time_base.num * (int64_t)AV_TIME_BASE,
                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);
        for (i = 0; i < s->nb_streams; i++) {
            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,
                                            min_ts, ts, max_ts, flags);
                                            SCSIRequest *req;
                                            SCSIDiskReq *r_10 = DO_UPCAST(SCSIDiskReq, req, req);
                                            SCSIDiskState *s_7 = DO_UPCAST(SCSIDiskState, qdev, r_10->req.dev);
                                            SCSIDiskReq *r_10 = DO_UPCAST(SCSIDiskReq, req, req);
                                            uint32_t node;
                                            assert(r_10->req.aiocb == NULL);
                                            r_10->req.aiocb = bdrv_aio_readv(s_7->bs, r_10->sector, &r_10->qiov, node,
                                                                           scsi_read_complete, r_10);
            if (r < 0)
                ret = r;
        }
        return ret;
    }
    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,
                                   min_ts, ts, max_ts, flags);
}",1,0,13,1.06,Insert
473,,,,,,,
474,"static QmpInputVisitor *to_qiv(Visitor *v)
{
    return container_of(v, QmpInputVisitor, visitor);
}","static QmpInputVisitor *to_qiv(Visitor *v)
{
    char str[] = ""Constant"";
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *cur  = NULL;
    cur  = p->data[0];
    if (strlen(str) > 0) {
        return container_of(v, QmpInputVisitor, visitor);
    }
}",0,1,6,0.2,Insert
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        return res;
    }
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    if (frame && s->interlaced) {
        frame->interlaced_frame = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}","static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
int (*compare)(const char *, const char *, size_t);
const char *name1;
const char *name2;
int cmp;
unsigned char c1, mc7;
cmp = compare(name1, name2, len_10);
c1 = name1[len_10];
#if FF_API_CODED_FRAME

QuantizationTable
    *table;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
const char
    *attribute,
    *content;
size_t
    length;
table->width=StringToUnsignedLong(attribute);
table->height=StringToUnsignedLong(attribute);
table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
length=(size_t) table->width*table->height;
int len;
int copied, err;
struct sk_buff *skb, *skb2;
copied = skb->len;
table->levels=(unsigned int *) AcquireQuantumMemory(length,
    sizeof(*table->levels));FF_DISABLE_DEPRECATION_WARNINGS
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
VirtIOSCSIReq *req;
VirtIOSCSI *sb;
req->dev = sb;
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        int a = 2;
        int b = 2;
        while (a == b) {
            return res;
            b += 1;
        }
    }
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    if (frame && s->interlaced) {
        frame->interlaced_frame = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}",0,1,106,1.14,Insert
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
    k->init = bonito_pcihost_initfn;
    dc->no_user = 1;
}","static void bonito_pcihost_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
    struct sk_buff *skb;
    struct sock *sk = skb->sk;
    struct flowi6 fl6;
    struct sock *sk = skb->sk;
    IP6_ECN_flow_xmit(sk, fl6.flowlabel);
    pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6
    "", __func__, skb,
    		 skb->len, &fl6.saddr, &fl6.daddr);
    k->init = bonito_pcihost_initfn;
    int a = 2;
    int b = 2;
    while (a == b) {
        dc->no_user = 1;
        b += 1;
    }
}",1,0,12,0.43,Insert
477,"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)
{
    uint32_t v, spf;
    MPADecodeHeader c;
    int vbrtag_size = 0;
    MP3DecContext *mp3 = s->priv_data;
    ffio_init_checksum(s->pb, ff_crcA001_update, 0);
    v = avio_rb32(s->pb);
    if(ff_mpa_check_header(v) < 0)
      return -1;
    if (avpriv_mpegaudio_decode_header(&c, v) == 0)
        vbrtag_size = c.frame_size;
    if(c.layer != 3)
        return -1;
    spf = c.lsf ? 576 : 1152;  
    mp3->frames = 0;
    mp3->size   = 0;
    mp3_parse_info_tag(s, st, &c, spf);
    mp3_parse_vbri_tag(s, st, base);
    if (!mp3->frames && !mp3->size)
        return -1;
    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);
    if (mp3->frames)
        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},
                                    st->time_base);
    if (mp3->size && mp3->frames && !mp3->is_cbr)
        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);
    return 0;
}","static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)
{
    struct f2fs_sb_info *sbi;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
    		dir = ALLOC_RIGHT;
    uint32_t v, spf;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    int c_9, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (strcmp(str1, str2) == 0) {
        MPADecodeHeader c;
    }
    int vbrtag_size = 0;
    MP3DecContext *mp3 = s->priv_data;
    ffio_init_checksum(s->pb, ff_crcA001_update, 0);
    v = avio_rb32(s->pb);
    if(ff_mpa_check_header(v) < 0)
      return -1;
    if (avpriv_mpegaudio_decode_header(&c, v) == 0)
        vbrtag_size = c.frame_size;
    if(c.layer != 3)
        return -1;
    spf = c.lsf ? 576 : 1152;  
    mp3->frames = 0;
    mp3->size   = 0;
    mp3_parse_info_tag(s, st, &c, spf);
    mp3_parse_vbri_tag(s, st, base);
    if (!mp3->frames && !mp3->size)
        return -1;
    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);
    if (mp3->frames)
        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},
                                    st->time_base);
    if (mp3->size && mp3->frames && !mp3->is_cbr)
        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);
    return 0;
}",0,1,107,1.45,Insert
478,"void memory_region_iommu_replay_all(MemoryRegion *mr)
{
    IOMMUNotifier *notifier;
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
        memory_region_iommu_replay(mr, notifier, false);
    }
}","void memory_region_iommu_replay_all(MemoryRegion *mr)
{
    IOMMUNotifier *notifier;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
            V9fsPath *fs_path;
            FsContext *FS_path;
            int fd, ret;
            struct handle_data *parent_7 = (struct handle_data *)FS_path->private;
            fd = open_by_handle(parent_7->mountfd, fs_path->parent_7, O_PATH);
    }
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
        int a = 24;
        int b = a;
        const char *data;
        int data;
        BlockDriver *yrf = NULL;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        BlockDriverState *bes;
        int  rows;
        data = bes->open_flags | BDRV_O_RDWR;
        rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
        if(a*b>0){
            memory_region_iommu_replay(mr, notifier, false);
        }
    }
}",0,1,65,0.56,Insert
479,"static int usb_uhci_piix3_initfn(PCIDevice *dev)
{
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);
    return usb_uhci_common_initfn(s);
}","static int usb_uhci_piix3_initfn(PCIDevice *dev)
{
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                     aml_name(""CDW1"")));
    aml_append(ifconfig, ifconfig0);
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                     aml_name(""CDW1"")));
    int a = 2;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    int b = 3;
    int lang, rar;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (a != b) {
        UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
        b = a;
    }
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);
    return usb_uhci_common_initfn(s);
}",0,1,123,0.86,Insert
481,"static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	int a = 2;
	int b = 3;
	while (a != b) {
    	cris_cc_mask(dc, 0);
    	b = a;
	}
	Vring *pray;
	bool var;
	uint16_t old, new;
	GOutputStream *os;
	GInputStream *isa;
	test_common_bounds_server(isa, os);
	uint16_t old, new;
	old = pray->signalled_used;
	var = pray->signalled_used_valid;
	new = pray->signalled_used = pray->last_used_idx;
	pray->signalled_used_valid = true;
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}",0,1,63,0.87,Insert
483,"static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,
                                 unsigned size)
{
    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;
    uint32_t ret;
    int bank;
    if (offset >= 0x200)
        return 0;
    bank = pxa2xx_gpio_regs[offset].bank;
    switch (pxa2xx_gpio_regs[offset].reg) {
    case GPDR:		 
        return s->dir[bank];
    case GPSR:		 
        qemu_log_mask(LOG_GUEST_ERROR,
                      ""pxa2xx GPIO: read from write only register GPSR\n"");
        return 0;
    case GPCR:		 
        qemu_log_mask(LOG_GUEST_ERROR,
                      ""pxa2xx GPIO: read from write only register GPCR\n"");
        return 0;
    case GRER:		 
        return s->rising[bank];
    case GFER:		 
        return s->falling[bank];
    case GAFR_L:	 
        return s->gafr[bank * 2];
    case GAFR_U:	 
        return s->gafr[bank * 2 + 1];
    case GPLR:		 
        ret = (s->olevel[bank] & s->dir[bank]) |
                (s->ilevel[bank] & ~s->dir[bank]);
        qemu_irq_raise(s->read_notify);
        return ret;
    case GEDR:		 
        return s->status[bank];
    default:
        hw_error(""%s: Bad offset "" REG_FMT ""\n"", __FUNCTION__, offset);
    }
    return 0;
}","static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,
                                 unsigned size)
{
    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;
    uint32_t ret;
    int bank;
    if (offset >= 0x200)
        return 0;
    bank = pxa2xx_gpio_regs[offset].bank;
    switch (pxa2xx_gpio_regs[offset].reg) {
    case GPDR:		 
        return s->dir[bank];
    case GPSR:		 
        qemu_log_mask(LOG_GUEST_ERROR,
                      ""pxa2xx GPIO: read from write only register GPSR\n"");
        int a = 2;
        int b = 3;
        if (a != b) {
            return 0;
        }
    case GPCR:		 
        qemu_log_mask(LOG_GUEST_ERROR,
                      ""pxa2xx GPIO: read from write only register GPCR\n"");
                      bool use_pubs;
                      const char
                          *attribute,
                          *content;
                          AVCodecContext *ajcas;
                          DCAContext *s_6 = ajcas->priv_data;
                          int num_core_channels = 0;
                          int channels, full_channels;
                          int channels, full_channels;
                          num_core_channels = s_6->prim_channels;
                          full_channels = channels = s_6->prim_channels + !!s_6->lfe;
                      XMLTreeInfo
                          *description,
                          *levels,
                          *quantization_tables,
                          *table_iterator;
                      QuantizationTable
                          *table;
                      XMLTreeInfo
                          *description,
                          *levels,
                          *quantization_tables,
                          *table_iterator;
                      XMLTreeInfo
                          *description,
                          *levels,
                          *quantization_tables,
                          *table_iterator;
                      table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
                      table->slot=(char *) NULL;
                      table->description=(char *) NULL;
                      table->levels=(unsigned int *) NULL;
                      attribute=GetXMLTreeAttribute(table_iterator,""slot"");
                      const struct smb_filename *smb_fhandle;
                      uint32_t access_mask;
                      struct connection_struct *connected;
                      uint32_t rejected_share_error;
                      uint32_t rejected_mask = access_mask;
                      struct security_descriptor *sd = NULL;
                      NTSTATUS success;
                      rejected_share_error = access_mask & ~(connected->share_access);
                      success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
                      			(SECINFO_OWNER |
                      			SECINFO_GROUP |
                      			 SECINFO_DACL), talloc_tos(), &sd);
                      success = se_file_access_check(sd,
                      				get_current_nttok(connected),
                      				use_pubs,
                      				(access_mask & ~do_not_check_mask),
                      				&rejected_mask);
        return 0;
    case GRER:		 
        return s->rising[bank];
    case GFER:		 
        return s->falling[bank];
    case GAFR_L:	 
        return s->gafr[bank * 2];
    case GAFR_U:	 
        return s->gafr[bank * 2 + 1];
    case GPLR:		 
        ret = (s->olevel[bank] & s->dir[bank]) |
                (s->ilevel[bank] & ~s->dir[bank]);
        qemu_irq_raise(s->read_notify);
        return ret;
    case GEDR:		 
        return s->status[bank];
    default:
        hw_error(""%s: Bad offset "" REG_FMT ""\n"", __FUNCTION__, offset);
    }
    return 0;
}",0,1,88,1.44,Insert
484,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    return 0;","static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int y;
        b += 1;
    }
    unsigned char P[2];
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    return 0;",1,0,1,0.06,Replace
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->file)) {
        goto out;
    }
    s->xfer_limit = new_rate;
out:
    return s->xfer_limit;
}","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MpegEncContext *s_8;
    if (s_8->current_picture.reference)
            ff_thread_report_progress(&s_8->current_picture_ptr->tf, INT_MAX, 0);
    MigrationState *s = opaque;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (qemu_file_get_error(s->file)) {
        int a = 2;
        int b = 3;
        if (a != b) {
            goto out;
        }
    }
    s->xfer_limit = new_rate;
out:
    return s->xfer_limit;
}",0,1,39,0.47,Insert
487,"static void scsi_disk_reset(DeviceState *dev)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);
    uint64_t nb_sectors;
    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->tray_open = 0;
}","static void scsi_disk_reset(DeviceState *dev)
{
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    char str[] = ""Constant"";
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                const char
                    *attribute,
                    *content;
                char
                    *p,
                    *xml;
                double
                    value;
                value=InterpretLocaleValue(content,&p);
                (void) value;
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if (strlen(str) > 0) {
        SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);
    }
    uint64_t nb_sectors;
    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->tray_open = 0;
}",0,1,129,0.92,Insert
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    dc0= 0x01010101*((dc0 + 4)>>3);
    for(i=0; i<8; i++){
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}","static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    int a = 2;
    int b = 2;
    while (a == b) {
        dc0= 0x01010101*((dc0 + 4)>>3);
        b += 1;
    }
    const char *dirname;
    mapping_t* mapping;
    unsigned int i_2;
    mapping->first_mapping_index = -1;
    mapping->path = g_strdup(dirname);
    i_2 = strlen(mapping->path);
    mapping->mode = MODE_DIRECTORY;
    mapping->read_only = 0;
    for(i=0; i<8; i++){
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}",1,0,9,0.65,Insert
490,"static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,
                              uint16_t index, uint16_t num)
{
    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);
    if (index >= VIRTIO_PCI_QUEUE_MAX) {
        return -EINVAL;
    }
    if (addr && (align != 4096)) {
        return -EINVAL;
    }
    if (!vdev) {
        return -EINVAL;
    }
    virtio_queue_set_addr(vdev, index, addr);
    if (!addr) {
        virtio_queue_set_vector(vdev, index, 0);
    } else {
        if (virtio_queue_get_num(vdev, index) > num) {
            return -EINVAL;
        }
        virtio_queue_set_vector(vdev, index, index);
    }
    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;
    return 0;
}","static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,
                              uint16_t index, uint16_t num)
{
    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);
    PutBitContext pb, pb2;
    int comps;
    put_bits(&pb, 16, 8 + comps * 3);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 16, 6 + comps * 2);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 8, (comps > 1) ? 1 : 0);
    if (index >= VIRTIO_PCI_QUEUE_MAX) {
        return -EINVAL;
    }
    int diff;
    diff = -1;
    if (addr && (align != 4096)) {
        RCore *model;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
        eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
        "");
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, end, NULL, &prev, false);
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, prev, NULL, NULL, false);
        return -EINVAL;
        QuantizationTable
            *table;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table->slot=(char *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    }
    if (!vdev) {
        return -EINVAL;
    }
    virtio_queue_set_addr(vdev, index, addr);
    if (!addr) {
        virtio_queue_set_vector(vdev, index, 0);
        int port, i, status, r;
        RTSPHeader reply1, *reply = &reply1;
        if (reply->status_code != RTSP_STATUS_OK) {
                r = AVERROR_INVALIDDATA;
                goto fail;
        }
        DictionaryValue* strings;
        strings->SetString(""proceed"",
              l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));
    } else {
        if (virtio_queue_get_num(vdev, index) > num) {
            return -EINVAL;
        }
        virtio_queue_set_vector(vdev, index, index);
    }
    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",0,1,171,1.35,Insert
491,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)
{
    rtl8139_do_receive(opaque, buf, size, 1);
}","static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)
{
    int a = 2;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_9;
    a_9 = ldb_schema_attribute_by_name(ydm, attr);
    int b = 3;
    if (a != b) {
        rtl8139_do_receive(opaque, buf, size, 1);
    }
}",0,1,4,0.25,Insert
492,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)
{
    char buffer[PATH_MAX];
    char *path = fs_path->data;
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||
        (fs_ctx->export_flags & V9FS_SM_NONE)) {
        return lchown(rpath(fs_ctx, path, buffer),
                      credp->fc_uid, credp->fc_gid);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {
        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {
        return local_set_mapped_file_attr(fs_ctx, path, credp);
    }
    return -1;
}","static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        char buffer[PATH_MAX];
        b += 1;
    }
    char *path = fs_path->data;
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||
        (fs_ctx->export_flags & V9FS_SM_NONE)) {
        return lchown(rpath(fs_ctx, path, buffer),
                      credp->fc_uid, credp->fc_gid);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        if (this->ports)
        		goto out;
        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);
        RAMBlock *news_work;
        news_work = g_malloc0(sizeof(*news_work));
        news_work->err = err;
        news_work->realized = realized;
        news_work->used_length = size;
        news_work->max_length = maxlennumber;
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {
        return local_set_mapped_file_attr(fs_ctx, path, credp);
    }
    return -1;
}",0,1,44,0.7,Insert
494,,,,,,,
495,,,,,,,
498,,,,,,,
500,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)
{
    if (env->softint != value) {
        env->softint = value;
#if !defined(CONFIG_USER_ONLY)
        if (cpu_interrupts_enabled(env)) {
            cpu_check_irqs(env);
        }
#endif
        return true;
    }
    return false;
}","static bool do_modify_softint(CPUSPARCState *env, uint32_t value)
{
    if (env->softint != value) {
        struct sk_buff *skb;
        int type;
        struct net_device *dev;
        u32 seq;
        u32 pid;
        unsigned int flags;
        struct nlmsghdr  *nlh;
        struct ifinfomsg *r;
        unsigned char	 *b_9 = skb->tail;
        unsigned char	 *b_9 = skb->tail;
        nlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);
        RTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);
        nlh->nlmsg_len = skb->tail - b_9;
        env->softint = value;
#if !defined(CONFIG_USER_ONLY)
        if (cpu_interrupts_enabled(env)) {
            int a = 2;
            int b = 2;
            while (a == b) {
                cpu_check_irqs(env);
                b += 1;
            }
        }
#endif
        return true;
    }
    return false;
}",1,0,9,0.44,Insert
502,,,,,,,
503,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)
{
    double d;
    char *ptr;
    FdMigrationState *s;
    const char *value = qdict_get_str(qdict, ""value"");
    d = strtod(value, &ptr);
    switch (*ptr) {
    case 'G': case 'g':
        d *= 1024;
    case 'M': case 'm':
        d *= 1024;
    case 'K': case 'k':
        d *= 1024;
    default:
        break;
    }
    max_throttle = (uint32_t)d;
    s = migrate_to_fms(current_migration);
    if (s) {
        qemu_file_set_rate_limit(s->file, max_throttle);
    }
}","void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)
{
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    double d;
    char *ptr;
    FdMigrationState *s;
    const char *value = qdict_get_str(qdict, ""value"");
    d = strtod(value, &ptr);
    switch (*ptr) {
    case 'G': case 'g':
        int a = 12;
        int b = a;
        if(a*b>0){
            d *= 1024;
        }
    case 'M': case 'm':
        d *= 1024;
    case 'K': case 'k':
        d *= 1024;
    default:
        break;
    }
    max_throttle = (uint32_t)d;
    s = migrate_to_fms(current_migration);
    if (s) {
        qemu_file_set_rate_limit(s->file, max_throttle);
    }
}",0,1,29,0.66,Insert
504,"static inline void gen_efdneg(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_efdneg(DisasContext *ctx)
{
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_3     = s->b_3;
    if (size & 1)
            avio_w8(b_3, 0);
    if (unlikely(!ctx->spe_enabled)) {
        int a = 2;
        int b = 2;
        if (a == b) {
            gen_exception(ctx, POWERPC_EXCP_APU);
        }
        return;
    }
    const char *data;
    void *opaque;
    struct f2fs_sb_info *sbi;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
    		dir = ALLOC_RIGHT;
    int32_t fid;
    V9fsPDU *dru = opaque;
    V9fsStat f9stats;
    ssize_t err = 0;
    size_t offset = 7;
    pdu_unmarshal(dru, offset, ""d"", &fid);
    offset += pdu_marshal(dru, offset, ""wS"", 0, &f9stats);
    err = offset;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",0,1,101,0.81,Insert
505,"static void gen_srlq(DisasContext *ctx)
{
    int l1 = gen_new_label();
    int l2 = gen_new_label();
    TCGv t0 = tcg_temp_local_new();
    TCGv t1 = tcg_temp_local_new();
    TCGv t2 = tcg_temp_local_new();
    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);
    tcg_gen_movi_tl(t1, 0xFFFFFFFF);
    tcg_gen_shr_tl(t2, t1, t2);
    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);
    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
    gen_load_spr(t0, SPR_MQ);
    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);
    tcg_gen_and_tl(t0, t0, t2);
    gen_load_spr(t1, SPR_MQ);
    tcg_gen_andc_tl(t1, t1, t2);
    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);
    gen_set_label(l2);
    tcg_temp_free(t0);
    tcg_temp_free(t1);
    tcg_temp_free(t2);
    if (unlikely(Rc(ctx->opcode) != 0))
        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);
}","static void gen_srlq(DisasContext *ctx)
{
    struct sock *sk;
    struct sctp_assocparams assecsettings;
    struct sctp_association *isec;
    isec = sctp_id2assoc(sk, assecsettings.sasoc_assoc_id);
    int l1 = gen_new_label();
    int l2 = gen_new_label();
    TCGv t0 = tcg_temp_local_new();
    TCGv t1 = tcg_temp_local_new();
    TCGv t2 = tcg_temp_local_new();
    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);
    tcg_gen_movi_tl(t1, 0xFFFFFFFF);
    tcg_gen_shr_tl(t2, t1, t2);
    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);
    char str[] = ""Constant"";
    int w;
    AVPacket * pk;
    AVFormatContext *s;
    const int stream_index =  pk->stream_index;
    apr_pool_t *pid;
    apr_pool_cleanup_register(pid, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
    int size               =  pk->size;
    AVIOContext *b     = s->b;
    avio_wl32(b, size);
    avio_write(b,  pk->data, size);
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            struct tty_struct *reader;
            int rt;
            const char *name1;
            unsigned char c1, mc7;
            c1 = name1[len];
            TCGv T00, ttyapp;
            gen_load_gpr(ttyapp, rt);
            struct awm *awm = reader->driver_data;
            struct acm_wb *sth;
            struct awm *awm = reader->driver_data;
            if (sth->len == awm->writesize) {
            		acm_tty_flush_chars(reader);
            		goto overflow;
            }
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    if (strlen(str) > 0) {
        tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
        unsigned maxpages;
        size_t *start;
        struct iov_iter *i;
        unsigned int iter_head, npages;
        unsigned int iter_head, npages;
        size_t capacity;
        npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
        capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    }
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    gen_load_spr(t0, SPR_MQ);
    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);
    tcg_gen_and_tl(t0, t0, t2);
    gen_load_spr(t1, SPR_MQ);
    tcg_gen_andc_tl(t1, t1, t2);
    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);
    gen_set_label(l2);
    tcg_temp_free(t0);
    tcg_temp_free(t1);
    tcg_temp_free(t2);
    if (unlikely(Rc(ctx->opcode) != 0))
        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);
}",0,1,677,3.94,Insert
506,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)
{
    VirtQueueElement elem;
    VirtQueue *vq;
    vq = vser->c_ivq;
    if (!virtio_queue_ready(vq)) {
        return 0;
    }
    if (!virtqueue_pop(vq, &elem)) {
        return 0;
    }
    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);
    virtqueue_push(vq, &elem, len);
    virtio_notify(VIRTIO_DEVICE(vser), vq);
    return len;
}","static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)
{
    QuantizationTable
    int c, cnt;
    QuantizationTable
        *table_3;
    XMLTreeInfo
        *description_9,
        *levels_8,
        *quantization_tables_4,
        *table_iterator_2;
    const char
        *attribute_9,
        *content_1;
    attribute_9=GetXMLTreeAttribute_10(levels_8,""divisor"");
    table_3->divisor=InterpretLocaleValue_2(attribute_9,(char **) NULL);
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    VirtQueueElement elem;
    VirtQueue *vq;
    vq = vser->c_ivq;
    if (!virtio_queue_ready(vq)) {
        return 0;
    }
    if (!virtqueue_pop(vq, &elem)) {
        int a = 2;
        int b = a;
        if(a*b>0){
            return 0;
        }
    }
    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);
    virtqueue_push(vq, &elem, len);
    virtio_notify(VIRTIO_DEVICE(vser), vq);
    return len;
}",0,1,90,0.92,Insert
508,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    cpu_physical_memory_read(addr, (void *) &ret, 1);
    return ret;
}","uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    cpu_physical_memory_read(addr, (void *) &ret, 1);
    const char *dev_3;
    Image *image;
    const LayerInfo* layer_info;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    int64_t rank;
    Error **ryp;
    BlockJob *work = find_block_job(dev_3);
    block_job_set_speed(work, rank, ryp);
    int a = 2;
    int b = 3;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    char *filename;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    while (a != b) {
        return ret;
        b = a;
    }
}",0,1,162,1.01,Insert
509,,,,,,,
511,,,,,,,
514,"static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,
                               TCGMemOp s_bits, int which)
{
    const TCGReg r0 = TCG_REG_O0;
    const TCGReg r1 = TCG_REG_O1;
    const TCGReg r2 = TCG_REG_O2;
    int tlb_ofs;
    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);
    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,
                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));
    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);
    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);
    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);
    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);
    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);
    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {
        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);
        tlb_ofs &= 0x3ff;
    }
    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);
    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));
    tcg_out_cmp(s, r0, r2, 0);
    if (SPARC64 && TARGET_LONG_BITS == 32) {
        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);
        return r0;
    }
    return addr;
}","static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,
                               TCGMemOp s_bits, int which)
{
    const TCGReg r0 = TCG_REG_O0;
    const TCGReg r1 = TCG_REG_O1;
    const TCGReg r2 = TCG_REG_O2;
    int tlb_ofs;
    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);
    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,
                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));
    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);
    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);
    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);
    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);
    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);
    PutBitContext pb, pb2;
    int comps;
    put_bits(&pb, 16, 8 + comps * 3);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 16, 6 + comps * 2);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 8, (comps > 1) ? 1 : 0);
    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);
        tlb_ofs &= 0x3ff;
    }
    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);
    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));
    tcg_out_cmp(s, r0, r2, 0);
    if (SPARC64 && TARGET_LONG_BITS == 32) {
        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);
        return r0;
    }
    return addr;
}",0,1,70,1.5,Insert
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}","static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            int a = 2;
            int b = 2;
            if (a == b) {
                qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
                const char *data;
                int data;
                BlockDriver *yrf = NULL;
                Error *localxer = NULL;
                BlockDriverState *source_vs;
                BlockDriverState *bes;
                int  rows;
                data = bes->open_flags | BDRV_O_RDWR;
                rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
            }
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}",0,1,38,0.67,Insert
517,,,,,,,
518,,,,,,,
519,"void ff_er_frame_start(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}","void ff_er_frame_start(ERContext *s)
{
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    int a = 2;
    int b = 3;
    while (a != b) {
        s->error_occurred = 0;
        b = a;
    }
}",0,1,23,0.44,Insert
524,"void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,
                         const uint32_t *intbit_to_level,
                         qemu_irq **irq, qemu_irq **cpu_irq,
                         unsigned int cputimer)
{
    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;
    SLAVIO_INTCTLState *s;
    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));
    if (!s)
        return NULL;
    s->intbit_to_level = intbit_to_level;
    for (i = 0; i < MAX_CPUS; i++) {
	slavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);
	cpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,
                                     slavio_intctl_io_memory);
    }
    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);
    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);
    register_savevm(""slavio_intctl"", addr, 1, slavio_intctl_save, slavio_intctl_load, s);
    qemu_register_reset(slavio_intctl_reset, s);
    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);
    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);
    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];
    slavio_intctl_reset(s);
    return s;
}","void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,
                         const uint32_t *intbit_to_level,
                         qemu_irq **irq, qemu_irq **cpu_irq,
                         unsigned int cputimer)
{
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;
    SLAVIO_INTCTLState *s;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (!s)
        return NULL;
    s->intbit_to_level = intbit_to_level;
    for (i = 0; i < MAX_CPUS; i++) {
	slavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);
	cpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,
                                     slavio_intctl_io_memory);
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);
        b += 1;
    }
    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);
    register_savevm(""slavio_intctl"", addr, 1, slavio_intctl_save, slavio_intctl_load, s);
    qemu_register_reset(slavio_intctl_reset, s);
    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);
    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);
    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];
    slavio_intctl_reset(s);
    return s;
}",0,1,111,1.29,Insert
525,"void helper_frndint(void)
{
    ST0 = rint(ST0);
}","void helper_frndint(void)
{
    int level;
    SSL *s;
    if ((level == 2) && (s->session != NULL))
            SSL_CTX_remove_session(s->session_ctx, s->session);
    ST0 = rint(ST0);
}",1,0,3,0.14,Insert
526,"static void start_children(FFStream *feed)
{
    if (no_launch)
        return;
    for (; feed; feed = feed->next) {
        if (feed->child_argv && !feed->pid) {
            feed->pid_start = time(0);
            feed->pid = fork();
            if (feed->pid < 0) {
                http_log(""Unable to create children\n"");
                exit(1);
            }
            if (!feed->pid) {
                char pathname[1024];
                char *slash;
                int i;
                av_strlcpy(pathname, my_program_name, sizeof(pathname));
                slash = strrchr(pathname, '/');
                if (!slash)
                    slash = pathname;
                else
                    slash++;
                strcpy(slash, ""ffmpeg"");
                http_log(""Launch command line: "");
                http_log(""%s "", pathname);
                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)
                    http_log(""%s "", feed->child_argv[i]);
                http_log(""\n"");
                for (i = 3; i < 256; i++)
                    close(i);
                if (!ffserver_debug) {
                    i = open(""/dev/null"", O_RDWR);
                    if (i != -1) {
                        dup2(i, 0);
                        dup2(i, 1);
                        dup2(i, 2);
                        close(i);
                    }
                }
                chdir(my_program_dir);
                signal(SIGPIPE, SIG_DFL);
                execvp(pathname, feed->child_argv);
                _exit(1);
            }
        }
    }
}","static void start_children(FFStream *feed)
{
    if (no_launch)
        return;
    for (; feed; feed = feed->next) {
        if (feed->child_argv && !feed->pid) {
            feed->pid_start = time(0);
            feed->pid = fork();
            if (feed->pid < 0) {
                http_log(""Unable to create children\n"");
                char str[] = ""Constant"";
                while (strlen(str) > 5) {
                    exit(1);
                strcpy(str, ""a"");
                }
            }
            if (!feed->pid) {
                char pathname[1024];
                char *slash;
                int i;
                av_strlcpy(pathname, my_program_name, sizeof(pathname));
                slash = strrchr(pathname, '/');
                if (!slash)
                    slash = pathname;
                else
                    slash++;
                strcpy(slash, ""ffmpeg"");
                http_log(""Launch command line: "");
                http_log(""%s "", pathname);
                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)
                    http_log(""%s "", feed->child_argv[i]);
                http_log(""\n"");
                for (i = 3; i < 256; i++)
                    close(i);
                if (!ffserver_debug) {
                    i = open(""/dev/null"", O_RDWR);
                    if (i != -1) {
                        dup2(i, 0);
                        dup2(i, 1);
                        dup2(i, 2);
                        close(i);
                    }
                }
                chdir(my_program_dir);
                signal(SIGPIPE, SIG_DFL);
                execvp(pathname, feed->child_argv);
                _exit(1);
            }
        }
    }
}",0,1,6,0.23,Replace
527,,,,,,,
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            track->edit_rate.den = get_be32(pb);
        }
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        SCSIRequest *req;
        SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
        SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
        assert(r->req.aiocb == NULL);
        scsi_req_ref(&r->req);
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}",1,0,23,0.49,Insert
531,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)
{
    int t = rc->range * (uint64_t)cumFreq / total_freq;
    rc->code1 += t + 1;
    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);
    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {
        unsigned byte = bytestream2_get_byte(gb);
        rc->code = (rc->code << 8) | byte;
        rc->code1 <<= 8;
        rc->range <<= 8;
    }
}","static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)
{
    const char *data;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    int t = rc->range * (uint64_t)cumFreq / total_freq;
    rc->code1 += t + 1;
    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);
    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {
        int a = 2;
        int b = 3;
        while (a < b) {
            unsigned byte = bytestream2_get_byte(gb);
            b = a;
        }
        rc->code = (rc->code << 8) | byte;
        rc->code1 <<= 8;
        rc->range <<= 8;
    }
}",0,1,48,0.86,Insert
533,"bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)
{
    assert(pkt);
    return pkt->vlan_stripped;
}","bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        assert(pkt);
        b += 1;
    }
    int p2;
    int16_t *cfpt;
    int r, b_5;
    b_5 = cfpt[p2];
    return pkt->vlan_stripped;
}",1,0,5,0.23,Insert
534,,,,,,,
535,,,,,,,
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}","void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        bs->detect_zeroes = blk->root_state.detect_zeroes;
        const uint16_t min_mesh[17];
        int16_t nrsc[16];
        int err;
        int path, i;
        for (i = 1; i < err; i++)
                if (nrsc[i] < nrsc[i - 1] + min_mesh[i])
                    nrsc[i] = nrsc[i - 1] + min_mesh[i];
    }
}",0,1,10,0.22,Insert
541,"static uint64_t megasas_fw_time(void)
{
    struct tm curtime;
    uint64_t bcd_time;
    qemu_get_timedate(&curtime, 0);
    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |
        ((uint64_t)curtime.tm_min & 0xff)  << 40 |
        ((uint64_t)curtime.tm_hour & 0xff) << 32 |
        ((uint64_t)curtime.tm_mday & 0xff) << 24 |
        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |
        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);
    return bcd_time;
}","static uint64_t megasas_fw_time(void)
{
    struct tm curtime;
    uint64_t bcd_time;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_1;
    a_1 = ldb_schema_attribute_by_name(ydm, attr);
    int a = 50;
    int b = a;
    if(a*b>0){
        qemu_get_timedate(&curtime, 0);
    }
    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |
        ((uint64_t)curtime.tm_min & 0xff)  << 40 |
        ((uint64_t)curtime.tm_hour & 0xff) << 32 |
        ((uint64_t)curtime.tm_mday & 0xff) << 24 |
        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |
        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);
    return bcd_time;
}",0,1,9,0.3,Insert
542,,,,,,,
545,,,,,,,
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
    s->freq = PXA25X_FREQ;
    s->tm4 = NULL;
}","void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
    struct CallCount *pb_4;
    if( pb_4 ) pb_4->nStep = 1;
    int a = 2;
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    ram_addr_t gram_size, prom_reset, tcx64off;
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
                  serial_hds[0], ESCC_CLOCK, 1);
    int b = 3;
    qemu_irq rx[128];
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    DeviceState *mem = NULL;
    int c, cnt;
    sqlite3_context *phpCorptrl;
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    if (a != b) {
        s->freq = PXA25X_FREQ;
    }
    s->tm4 = NULL;
}",0,1,160,0.93,Insert
551,,,,,,,
554,,,,,,,
555,,,,,,,
556,"static av_cold int roq_encode_init(AVCodecContext *avctx)
{
    RoqContext *enc = avctx->priv_data;
    av_lfg_init(&enc->randctx, 1);
    enc->framesSinceKeyframe = 0;
    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions must be divisible by 16\n"");
        return AVERROR(EINVAL);
    if (avctx->width > 65535 || avctx->height > 65535) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions are max %d\n"", enc->quake3_compat ? 32768 : 65535);
        return AVERROR(EINVAL);
    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))
        av_log(avctx, AV_LOG_ERROR, ""Warning: dimensions not power of two, this is not supported by quake\n"");
    enc->width = avctx->width;
    enc->height = avctx->height;
    enc->framesSinceKeyframe = 0;
    enc->first_frame = 1;
    enc->last_frame    = av_frame_alloc();
    enc->current_frame = av_frame_alloc();
    if (!enc->last_frame || !enc->current_frame) {
    enc->tmpData      = av_malloc(sizeof(RoqTempdata));
    enc->this_motion4 =
        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));
    enc->last_motion4 =
        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));
    enc->this_motion8 =
        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));
    enc->last_motion8 =
        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));
    return 0;","static av_cold int roq_encode_init(AVCodecContext *avctx)
{
    RoqContext *enc = avctx->priv_data;
    av_lfg_init(&enc->randctx, 1);
    enc->framesSinceKeyframe = 0;
    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions must be divisible by 16\n"");
        return AVERROR(EINVAL);
    if (avctx->width > 65535 || avctx->height > 65535) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions are max %d\n"", enc->quake3_compat ? 32768 : 65535);
        return AVERROR(EINVAL);
    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))
        av_log(avctx, AV_LOG_ERROR, ""Warning: dimensions not power of two, this is not supported by quake\n"");
    enc->width = avctx->width;
    int a = 35;
    int b = a;
    if(a*b>0){
        enc->height = avctx->height;
    }
    enc->framesSinceKeyframe = 0;
    enc->first_frame = 1;
    enc->last_frame    = av_frame_alloc();
    enc->current_frame = av_frame_alloc();
    if (!enc->last_frame || !enc->current_frame) {
    enc->tmpData      = av_malloc(sizeof(RoqTempdata));
    enc->this_motion4 =
        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));
    enc->last_motion4 =
        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));
    enc->this_motion8 =
        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));
    enc->last_motion8 =
        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));
    return 0;",1,0,13,0.2,Replace
557,,,,,,,
558,"static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)
{
    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);
    void *dst;
    if (o_out)
        *o_out= o;
    if (!o || o->offset<=0)
        return AVERROR_OPTION_NOT_FOUND;
    if (o->max*den < num*intnum || o->min*den > num*intnum) {
        av_log(obj, AV_LOG_ERROR, ""Value %lf for parameter '%s' out of range\n"", num, name);
        return AVERROR(ERANGE);
    }
    dst= ((uint8_t*)obj) + o->offset;
    switch (o->type) {
    case FF_OPT_TYPE_FLAGS:
    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;
    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;
    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;
    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;
    case FF_OPT_TYPE_RATIONAL:
        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};
        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);
        break;
    default:
        return AVERROR(EINVAL);
    }
    return 0;
}","static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)
{
    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);
    void *dst;
    if (o_out)
        *o_out= o;
    if (!o || o->offset<=0)
        return AVERROR_OPTION_NOT_FOUND;
    if (o->max*den < num*intnum || o->min*den > num*intnum) {
        av_log(obj, AV_LOG_ERROR, ""Value %lf for parameter '%s' out of range\n"", num, name);
        return AVERROR(ERANGE);
    }
    dst= ((uint8_t*)obj) + o->offset;
    switch (o->type) {
    case FF_OPT_TYPE_FLAGS:
    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;
    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;
    int a = 37;
    int b = a;
    if(a*b>0){
        case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;
    }
    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;
    case FF_OPT_TYPE_RATIONAL:
        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};
        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);
        break;
    default:
        return AVERROR(EINVAL);
    }
    return 0;
}",0,1,1,0.13,Replace
560,,,,,,,
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
    case 2:  
        int a = 2;
        int b = 3;
        while (a < b) {
            return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
            b = a;
        }
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}",1,0,2,0.08,Replace
562,,,,,,,
563,"static void gen_exception_insn(DisasContext *s, int offset, int excp)
{
    gen_a64_set_pc_im(s->pc - offset);
    gen_exception(excp);
    s->is_jmp = DISAS_JUMP;
}","static void gen_exception_insn(DisasContext *s, int offset, int excp)
{
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    if (strcmp(str1, str2) == 0) {
        gen_a64_set_pc_im(s->pc - offset);
    }
    gen_exception(excp);
    s->is_jmp = DISAS_JUMP;
}",0,1,56,0.49,Insert
564,"static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)
{
    const QDictEntry *ent;
    const char *arg_name;
    const QObject *arg_obj;
    bool has_exec_key = false;
    QDict *dict = NULL;
    if (qobject_type(request) != QTYPE_QDICT) {
        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,
                   ""request is not a dictionary"");
        return NULL;
    }
    dict = qobject_to_qdict(request);
    for (ent = qdict_first(dict); ent;
         ent = qdict_next(dict, ent)) {
        arg_name = qdict_entry_key(ent);
        arg_obj = qdict_entry_value(ent);
        if (!strcmp(arg_name, ""execute"")) {
            if (qobject_type(arg_obj) != QTYPE_QSTRING) {
                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",
                           ""string"");
                return NULL;
            }
            has_exec_key = true;
        } else if (strcmp(arg_name, ""arguments"")) {
            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);
            return NULL;
        }
    }
    if (!has_exec_key) {
        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, ""execute"");
        return NULL;
    }
    return dict;
}","static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)
{
    const QDictEntry *ent;
    const char *arg_name;
    const QObject *arg_obj;
    bool has_exec_key = false;
    QDict *dict = NULL;
    if (qobject_type(request) != QTYPE_QDICT) {
        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,
                   ""request is not a dictionary"");
        return NULL;
    }
    dict = qobject_to_qdict(request);
    for (ent = qdict_first(dict); ent;
         ent = qdict_next(dict, ent)) {
        arg_name = qdict_entry_key(ent);
        arg_obj = qdict_entry_value(ent);
        if (!strcmp(arg_name, ""execute"")) {
            if (qobject_type(arg_obj) != QTYPE_QSTRING) {
                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",
                           ""string"");
                return NULL;
            }
            has_exec_key = true;
        } else if (strcmp(arg_name, ""arguments"")) {
            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);
            return NULL;
        }
    }
    if (!has_exec_key) {
        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, ""execute"");
        return NULL;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return dict;
    strcpy(str, ""a"");
    }
}",0,1,2,0.15,Replace
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)
{
    int64_t *v = pv;
    qemu_get_sbe64s(f, v);
    return 0;
}","static int get_int64(QEMUFile *f, void *pv, size_t size)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        int64_t *v = pv;
        b = a;
        char *header;
        long start;
        start = ftell(fp);
        fseek(fp, 0, SEEK_SET);
        SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.
        "");
        fseek(fp, start, SEEK_SET);
    }
    qemu_get_sbe64s(f, v);
    return 0;
}",1,0,7,0.33,Insert
567,,,,,,,
568,,,,,,,
569,,,,,,,
570,"PPC_OP(slw)
{
    if (T1 & 0x20) {
        T0 = 0;
    } else {
        T0 = T0 << T1;
    }
    RETURN();
}","PPC_OP(slw)
{
    if (T1 & 0x20) {
        T0 = 0;
    } else {
        T0 = T0 << T1;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        AVFormatContext *s;
        int ret = 0, i;
        HLSContext *c = s->priv_data;
        if (c->n_variants == 0) {
                av_log(NULL, AV_LOG_WARNING, ""Empty playlist
        "");
                ret = AVERROR_EOF;
                goto fail;
        }
        RETURN();
    strcpy(str, ""a"");
    }
}",1,0,8,0.33,Insert
571,,,,,,,
573,"static int piix4_initfn(PCIDevice *dev)
{
    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
    uint8_t *pci_conf;
    isa_bus_new(&d->dev.qdev);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0);  
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}","static int piix4_initfn(PCIDevice *dev)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    if (strcmp(str1, str2) == 0) {
        PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
    }
    uint8_t *pci_conf;
    isa_bus_new(&d->dev.qdev);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0);  
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    return 0;
}",0,1,80,0.7,Insert
574,,,,,,,
575,,,,,,,
576,,,,,,,
577,,,,,,,
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)
{
    TCGv_i64 tmp;
    TCGv tmp2;
    tmp = tcg_temp_new_i64();
    tmp2 = load_reg(s, rlow);
    tcg_gen_extu_i32_i64(tmp, tmp2);
    dead_tmp(tmp2);
    tcg_gen_add_i64(val, val, tmp);
    tcg_temp_free_i64(tmp);
}","static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)
{
    TCGv_i64 tmp;
    TCGv tmp2;
    tmp = tcg_temp_new_i64();
    tmp2 = load_reg(s, rlow);
    tcg_gen_extu_i32_i64(tmp, tmp2);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        dead_tmp(tmp2);
    }
    tcg_gen_add_i64(val, val, tmp);
    int log2_cb_size;
    int nPbH;
    int y0;
    int nPbW;
    int part_idx;
    int x0;
    int merge_idx;
    HEVCContext *s_10;
    HEVCLocalContext *lc = &s_10->HEVClc;
    int singleMCLFlag = 0;
    int nPbW2 = nPbW;
    int nPbH2 = nPbH;
    int nCS = 1 << log2_cb_size;
    derive_spatial_merge_candidates(s_10, x0, y0, nPbW, nPbH, log2_cb_size,
                                        singleMCLFlag, part_idx,
                                        merge_idx, mergecand_list);
    tcg_temp_free_i64(tmp);
}",1,0,19,0.49,Insert
581,,,,,,,
582,"static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)
{
    VirtIOBlockReq *req = virtio_blk_alloc_request(s);
    if (!virtqueue_pop(s->vq, &req->elem)) {
        virtio_blk_free_request(req);
        return NULL;
    }
    return req;
}","static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)
{
    VirtIOBlockReq *req = virtio_blk_alloc_request(s);
    if (!virtqueue_pop(s->vq, &req->elem)) {
        virtio_blk_free_request(req);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return NULL;
        strcpy(str, ""a"");
        }
    }
    return req;
}",0,1,3,0.06,Replace
584,,,,,,,
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)
{
    uint64_t size;
    uint64_t sect;
    if (bdrv) {
        bdrv_get_geometry(bdrv, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->bdrv = bdrv;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}","static void sd_reset(SDState *sd, BlockDriverState *bdrv)
{
    RAMBlock *news_work;
    size_1 = HOST_PAGE_ALIGN(size_1);
    news_work = g_malloc0_8(sizeof(*news_work));
    news_work->used_length = size_1;
    assert(maxlennumber >= size_1);
    uint64_t size;
    uint64_t sect;
    if (bdrv) {
        char str[] = ""Constant"";
        const char
            *attribute,
            *content;
        XMLTreeInfo
        const char *data;
        int data;
        BlockDriver *yrf = NULL;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        BlockDriverState *bes;
        int  rows;
        data = bes->open_flags | BDRV_O_RDWR;
        rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        while (strlen(str) > 5) {
            bdrv_get_geometry(bdrv, &sect);
        strcpy(str, ""a"");
        }
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->bdrv = bdrv;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}",0,1,109,1.44,Insert
590,"static CharDriverState *qemu_chr_open_spice_port(const char *id,
                                                 ChardevBackend *backend,
                                                 ChardevReturn *ret,
                                                 Error **errp)
{
    const char *name = backend->spiceport->fqdn;
    CharDriverState *chr;
    SpiceCharDriver *s;
    if (name == NULL) {
        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");
        return NULL;
    }
    chr = chr_open(""port"", spice_port_set_fe_open);
    s = chr->opaque;
    s->sin.portname = g_strdup(name);
    return chr;
}","static CharDriverState *qemu_chr_open_spice_port(const char *id,
                                                 ChardevBackend *backend,
                                                 ChardevReturn *ret,
                                                 Error **errp)
{
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    int a = 2;
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    int b = 2;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    if (a == b) {
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        levels=GetXMLTreeChild(table_iterator,""levels"");
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(levels,""width"");
        attribute=GetXMLTreeAttribute(levels,""height"");
        attribute=GetXMLTreeAttribute(levels,""divisor"");
        const char *name = backend->spiceport->fqdn;
    }
    CharDriverState *chr;
    SpiceCharDriver *s;
    if (name == NULL) {
        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");
        return NULL;
    }
    chr = chr_open(""port"", spice_port_set_fe_open);
    s = chr->opaque;
    s->sin.portname = g_strdup(name);
    return chr;
}",0,1,143,1.08,Insert
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    g_free(breakpoint);
#endif
}","void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
        if (!saved_server_config_defines) {
                init_config_defines(cli->pool);
        }
        breakpoint_invalidate(cpu, breakpoint->pc);
    strcpy(str, ""a"");
    }
    g_free(breakpoint);
#endif
}",0,1,26,0.43,Insert
592,,,,,,,
593,,,,,,,
596,"void ff_mpv_frame_end(MpegEncContext *s)
{
#if FF_API_XVMC
FF_DISABLE_DEPRECATION_WARNINGS
    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {
        ff_xvmc_field_end(s);
    } else
FF_ENABLE_DEPRECATION_WARNINGS
#endif  
    emms_c();
    if (s->current_picture.reference)
        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
}","void ff_mpv_frame_end(MpegEncContext *s)
{
TCGContext *service;
int rules, nb_regs, ini;
TCGRegSet allocated_regs;
QuantizationTable
    *table;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
const char
    *attribute,
    *content;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
levels=GetXMLTreeChild(table_iterator,""levels"");
table->levels=(unsigned int *) NULL;
attribute=GetXMLTreeAttribute(levels,""width"");
attribute=GetXMLTreeAttribute(levels,""height"");
attribute=GetXMLTreeAttribute(levels,""divisor"");
if (rules & TCG_CALL_NO_READ_GLOBALS) {
    } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
        sync_globals(service, allocated_regs);
    } else {
        save_globals(service, allocated_regs);
}
#if FF_API_XVMC

VirtioCcwDevice *dev;
Error *err = NULL;
VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
DeviceState *parent = DEVICE(dev);
if (k->realize) {
        k->realize(dev, &err);
}FF_DISABLE_DEPRECATION_WARNINGS
    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {
        ff_xvmc_field_end(s);
    } else
FF_ENABLE_DEPRECATION_WARNINGS
#endif  
    emms_c();
    if (s->current_picture.reference)
        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
}",0,1,88,0.68,Insert
597,,,,,,,
598,"static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->priv;
    zimg_filter_graph_free(s->graph);
    av_freep(&s->tmp);
    s->tmp_size = 0;
}","static void uninit(AVFilterContext *ctx)
{
    int a = 2;
    int b = 2;
    AVCodecContext *avctx;
    Vp3DecodeContext *s_2 = avctx->priv_data;
    Vp3DecodeContext *s_2 = avctx->priv_data;
    if (s_2->last_frame.data[0] && s_2->last_frame.type != FF_BUFFER_TYPE_COPY)
            ff_thread_release_buffer(avctx, &s_2->last_frame);
    while (a == b) {
        ZScaleContext *s = ctx->priv;
        b += 1;
    }
    zimg_filter_graph_free(s->graph);
    av_freep(&s->tmp);
    s->tmp_size = 0;
}",1,0,10,0.27,Insert
600,"static int kvm_mips_get_fpu_registers(CPUState *cs)
{
    MIPSCPU *cpu = MIPS_CPU(cs);
    CPUMIPSState *env = &cpu->env;
    int err, ret = 0;
    unsigned int i;
    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,
                                    &env->active_fpu.fcr0);
        if (err < 0) {
            DPRINTF(""%s: Failed to get FCR_IR (%d)\n"", __func__, err);
            ret = err;
        }
        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,
                                    &env->active_fpu.fcr31);
        if (err < 0) {
            DPRINTF(""%s: Failed to get FCR_CSR (%d)\n"", __func__, err);
            ret = err;
        } else {
            restore_fp_status(env);
        }
        for (i = 0; i < 32; ++i) {
            if (env->CP0_Status & (1 << CP0St_FR)) {
                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),
                                              &env->active_fpu.fpr[i].d);
            } else {
                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),
                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);
            }
            if (err < 0) {
                DPRINTF(""%s: Failed to get FPR%u (%d)\n"", __func__, i, err);
                ret = err;
            }
        }
    }
    return ret;
}","static int kvm_mips_get_fpu_registers(CPUState *cs)
{
    MIPSCPU *cpu = MIPS_CPU(cs);
    CPUMIPSState *env = &cpu->env;
    int a = 2;
    int b = 2;
    while (a == b) {
        int err, ret = 0;
        GF_Filter *process;
        GF_FilterPid *pid;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        const GF_PropertyValue *proc;
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
        gf_filter_pid_set_udta(pid, git->out_pid);
        proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
        b += 1;
    }
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    CPUState *viron;
    qemu_irq *irq;
    QEMUBH *rb;
    rb = qemu_bh_new(tick_irq, viron);
    rb = qemu_bh_new(stick_irq, viron);
    rb = qemu_bh_new(hstick_irq, viron);
    irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
    int  rows_7;
    data = bes->open_flags | BDRV_O_RDWR;
    rows_7 = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    unsigned int i;
    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,
                                    &env->active_fpu.fcr0);
                                    const char *name1;
                                    unsigned char c1, mc7;
                                    c1 = name1[len];
        if (err < 0) {
            files_struct *lsp;
            const struct dom_sid *group_sid = NULL;
            TALLOC_CTX *frame = talloc_stackframe();
            struct security_descriptor *psd = NULL;
            const struct dom_sid *owner_sid = NULL;
            struct security_descriptor *parent_desc = NULL;
            struct security_token *token = lsp->conn->session_info->security_token;
            status = se_create_child_secdesc(frame,
            			&psd,
            			&size,
            			parent_desc,
            			owner_sid,
            			group_sid,
            			lsp->is_directory);
            status = SMB_VFS_FSET_NT_ACL(lsp,
            			security_info_sent,
            			psd);
            DPRINTF(""%s: Failed to get FCR_IR (%d)\n"", __func__, err);
            ret = err;
        }
        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,
                                    &env->active_fpu.fcr31);
        if (err < 0) {
            DPRINTF(""%s: Failed to get FCR_CSR (%d)\n"", __func__, err);
            ret = err;
        } else {
            restore_fp_status(env);
        }
        for (i = 0; i < 32; ++i) {
            if (env->CP0_Status & (1 << CP0St_FR)) {
                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),
                                              &env->active_fpu.fpr[i].d);
            } else {
                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),
                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);
            }
            if (err < 0) {
                DPRINTF(""%s: Failed to get FPR%u (%d)\n"", __func__, i, err);
                ret = err;
            }
        }
        SDRequest *err_2;
        SDState *esi;
        uint32_t last_status = esi->card_status;
        esi->current_cmd = err_2->cmd;
    }
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    return ret;
}",0,1,348,2.77,Insert
602,"static void vfio_pci_load_rom(VFIOPCIDevice *vdev)
{
    struct vfio_region_info reg_info = {
        .argsz = sizeof(reg_info),
        .index = VFIO_PCI_ROM_REGION_INDEX
    };
    uint64_t size;
    off_t off = 0;
    size_t bytes;
    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {
        error_report(""vfio: Error getting ROM info: %m"");
        return;
    }
    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,
                            (unsigned long)reg_info.offset,
                            (unsigned long)reg_info.flags);
    vdev->rom_size = size = reg_info.size;
    vdev->rom_offset = reg_info.offset;
    if (!vdev->rom_size) {
        vdev->rom_read_failed = true;
        error_report(""vfio-pci: Cannot read device rom at ""
                    ""%s"", vdev->vbasedev.name);
        error_printf(""Device option ROM contents are probably invalid ""
                    ""(check dmesg).\nSkip option ROM probe with rombar=0, ""
                    ""or load from file with romfile=\n"");
        return;
    }
    vdev->rom = g_malloc(size);
    memset(vdev->rom, 0xff, size);
    while (size) {
        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,
                      size, vdev->rom_offset + off);
        if (bytes == 0) {
            break;
        } else if (bytes > 0) {
            off += bytes;
            size -= bytes;
        } else {
            if (errno == EINTR || errno == EAGAIN) {
                continue;
            }
            error_report(""vfio: Error reading device ROM: %m"");
            break;
        }
    }
}","static void vfio_pci_load_rom(VFIOPCIDevice *vdev)
{
    struct vfio_region_info reg_info = {
        .argsz = sizeof(reg_info),
        .index = VFIO_PCI_ROM_REGION_INDEX
    };
    uint64_t size;
    off_t off = 0;
    size_t bytes;
    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {
        int a = 2;
        int b = 3;
        while (a < b) {
            error_report(""vfio: Error getting ROM info: %m"");
            b = a;
        }
        return;
    }
    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,
                            (unsigned long)reg_info.offset,
                            (unsigned long)reg_info.flags);
    vdev->rom_size = size = reg_info.size;
    vdev->rom_offset = reg_info.offset;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    if (!vdev->rom_size) {
        vdev->rom_read_failed = true;
        error_report(""vfio-pci: Cannot read device rom at ""
        struct ldb_context *ydm_4;
        const char *attr_10;
        const struct ldb_schema_attribute *a_2;
        a_2 = ldb_schema_attribute_by_name_10(ydm_4, attr_10);
                    ""%s"", vdev->vbasedev.name);
        error_printf(""Device option ROM contents are probably invalid ""
                    ""(check dmesg).\nSkip option ROM probe with rombar=0, ""
                    ""or load from file with romfile=\n"");
        return;
        struct ldb_context *ydm;
        const char *attr;
        const struct ldb_schema_attribute *a_1;
        a_1 = ldb_schema_attribute_by_name(ydm, attr);
    }
    vdev->rom = g_malloc(size);
    memset(vdev->rom, 0xff, size);
    while (size) {
        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,
                      size, vdev->rom_offset + off);
        if (bytes == 0) {
            break;
        } else if (bytes > 0) {
            off += bytes;
            size -= bytes;
        } else {
            if (errno == EINTR || errno == EAGAIN) {
                continue;
            }
            error_report(""vfio: Error reading device ROM: %m"");
            break;
        }
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    }
}",0,1,114,1.5,Insert
603,,,,,,,
604,,,,,,,
605,"static void test_qemu_strtoul_full_negative(void)
{
    const char *str = "" \t -321"";
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, -321ul);
}","static void test_qemu_strtoul_full_negative(void)
{
    const char *str = "" \t -321"";
    int a_1 = 2;
    int b_1 = 3;
    if (a_1 != b_1) {
        unsigned long res = 999;
    }
    int err;
    err = qemu_strtoul(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, -321ul);
}",0,1,1,0.05,Replace
607,,,,,,,
608,,,,,,,
611,"static int calculate_bitrate(AVFormatContext *s)
{
    AVIContext *avi = s->priv_data;
    int i, j;
    int64_t lensum = 0;
    int64_t maxpos = 0;
    for (i = 0; i<s->nb_streams; i++) {
        int64_t len = 0;
        AVStream *st = s->streams[i];
        if (!st->nb_index_entries)
            continue;
        for (j = 0; j < st->nb_index_entries; j++)
            len += st->index_entries[j].size;
        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);
        lensum += len;
    }
    if (maxpos < avi->io_fsize*9/10)  
        return 0;
    if (lensum*9/10 > maxpos || lensum < maxpos*9/10)  
        return 0;
    for (i = 0; i<s->nb_streams; i++) {
        int64_t len = 0;
        AVStream *st = s->streams[i];
        int64_t duration;
        for (j = 0; j < st->nb_index_entries; j++)
            len += st->index_entries[j].size;
        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)
            continue;
        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;
        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);
    }
    return 1;
}","static int calculate_bitrate(AVFormatContext *s)
{
    AVIContext *avi = s->priv_data;
    int i, j;
    int64_t lensum = 0;
    int64_t maxpos = 0;
    for (i = 0; i<s->nb_streams; i++) {
        uint64_t offset;
        int ret;
        void *opaque;
        size_t len_6;
        BlockDriverState *bs = ocf->common.bs;
        BDRVQEDState *s_10 = acb_to_s(ocf);
        QEDAIOCB *ocf = opaque;
        offset += qed_offset_into_cluster(s_10, ocf->cur_pos);
        trace_qed_aio_read_data(s_10, ocf, ret, offset, len_6);
        qemu_iovec_concat(&ocf->cur_qiov, ocf->qiov, ocf->qiov_offset, len_6);
        bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,
                           &ocf->cur_qiov, ocf->cur_qiov.size / BDRV_SECTOR_SIZE,
                           qed_aio_next_io, ocf);
        int64_t len = 0;
        AVStream *st = s->streams[i];
        if (!st->nb_index_entries)
            continue;
        for (j = 0; j < st->nb_index_entries; j++)
            len += st->index_entries[j].size;
        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);
        lensum += len;
    }
    if (maxpos < avi->io_fsize*9/10)  
        return 0;
    if (lensum*9/10 > maxpos || lensum < maxpos*9/10)  
        return 0;
    for (i = 0; i<s->nb_streams; i++) {
        int64_t len = 0;
        AVStream *st = s->streams[i];
        int64_t duration;
        for (j = 0; j < st->nb_index_entries; j++)
            len += st->index_entries[j].size;
        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)
            continue;
        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;
        int a = 2;
        int b = 3;
        while (a != b) {
            st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);
            b = a;
        }
    }
    return 1;
}",1,0,31,1.34,Insert
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)
{
    tcg_gen_qemu_st16(val, addr, index);
    dead_tmp(val);
}","static inline void gen_st16(TCGv val, TCGv addr, int index)
{
    tcg_gen_qemu_st16(val, addr, index);
    unsigned high_bit_depth;
    PixblockDSPContext *c;
    int cpu_flags = av_get_cpu_flags();
    if (EXTERNAL_SSE2(cpu_flags)) {
            if (!high_bit_depth)
                c->get_pixels = ff_get_pixels_sse2;
            c->diff_pixels = ff_diff_pixels_sse2;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        dead_tmp(val);
        b += 1;
    }
}",1,0,6,0.32,Insert
613,"static void q35_host_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);
    hc->root_bus_path = q35_host_root_bus_path;
    dc->realize = q35_host_realize;
    dc->props = mch_props;
    dc->user_creatable = false;
    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
    dc->fw_name = ""pci"";
}","static void q35_host_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);
    hc->root_bus_path = q35_host_root_bus_path;
    dc->realize = q35_host_realize;
    dc->props = mch_props;
    int a = 2;
    int b = 3;
    while (a < b) {
        dc->user_creatable = false;
        b = a;
    }
    BlockDriverState *bs;
    BDRVVHDXState *s;
    void *merged_sector = NULL;
    uint32_t sectors_written = 0;
    uint32_t desc_sectors, sectors, total_length;
    void *buffer = NULL;
    uint32_t desc_sectors, sectors, total_length;
    uint32_t desc_sectors, sectors, total_length;
    VHDXLogEntryHeader new_hdr;
    int ret = 0;
    new_hdr = (VHDXLogEntryHeader) {
                    .signature           = VHDX_LOG_SIGNATURE,
                    .tail                = s->log.tail,
                    .sequence_number     = s->log.sequence,
                    .descriptor_count    = sectors,
                    .reserved            = 0,
                    .flushed_file_offset = bdrv_getlength(bs->file->bs),
                    .last_file_offset    = bdrv_getlength(bs->file->bs),
                  };
    buffer = qemu_blockalign(bs, total_length);
    merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);
    ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,
                                     desc_sectors + sectors);
    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
    dc->fw_name = ""pci"";
}",1,0,22,0.52,Insert
614,,,,,,,
616,"void HELPER(stpq)(CPUS390XState *env, uint64_t addr,
                  uint64_t low, uint64_t high)
{
    uintptr_t ra = GETPC();
    if (parallel_cpus) {
#ifndef CONFIG_ATOMIC128
        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);
#else
        int mem_idx = cpu_mmu_index(env, false);
        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);
        Int128 v = int128_make128(low, high);
        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);
#endif
    } else {
        check_alignment(env, addr, 16, ra);
        cpu_stq_data_ra(env, addr + 0, high, ra);
        cpu_stq_data_ra(env, addr + 8, low, ra);
    }
}","void HELPER(stpq)(CPUS390XState *env, uint64_t addr,
                  uint64_t low, uint64_t high)
{
    int a = 2;
    int b = 3;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args_9;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args_9[ini]]);
                IntegrationStreamDecoderPtr http;
                http->waitForEndStream();
            }
    }
    while (a < b) {
        uintptr_t ra = GETPC();
        b = a;
    }
    if (parallel_cpus) {
#ifndef CONFIG_ATOMIC128
int lang, rar;
const char *request= ""DROP TABLE IF EXISTS test_table;""
                     ""CREATE TABLE test_table(id INT);""
                     QEMUMachineInitArgs *args;
                     char *filename;
                     ram_addr_t ram_size = args->ram_size;
                     long load_limit, rtas_limit, fw_size;
                     spapr->next_irq = XICS_IRQ_BASE;
                     spapr->ram_limit = ram_size;
                     filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
                     spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                                rtas_limit - spapr->rtas_addr);
                     spapr_events_init(spapr);
                     ""INSERT INTO test_table VALUES(10);""
                     ""UPDATE test_table SET id=20 WHERE id=10;""
                     ""SELECT * FROM test_table;""
                     ""INSERT INTO non_existent_table VALUES(11);"";
MYSQL *mysql___global;
lang= mysql_query(mysql___global, request);
myquery(lang);
lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
myquery(lang);
        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);
#else
        int mem_idx = cpu_mmu_index(env, false);
        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);
        Int128 v = int128_make128(low, high);
        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);
#endif
    } else {
        check_alignment(env, addr, 16, ra);
        cpu_stq_data_ra(env, addr + 0, high, ra);
        cpu_stq_data_ra(env, addr + 8, low, ra);
    }
}",0,1,110,1.33,Insert
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}","static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        u8 * Datapp;
        struct ath6kl_vif *vif;
        struct wmi_disconnect_event *dev;
        dev = (struct wmi_disconnect_event *)  Datapp;
        ath6kl_dbg(ATH6KL_DBG_WMI,
        		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
        "",
        		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
        		   dev->disconn_reason, dev->assoc_resp_len);
        ath6kl_disconnect_event(vif, dev->disconn_reason,
        				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
        				le16_to_cpu(dev->proto_reason_status));
        int i,j,xy,yz;
    strcpy(str, ""a"");
    }
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}",0,1,39,0.86,Insert
619,,,,,,,
620,,,,,,,
622,,,,,,,
623,"static void ppc4xx_pob_reset (void *opaque)
{
    ppc4xx_pob_t *pob;
    pob = opaque;
    pob->bear = 0x00000000;
    pob->besr[0] = 0x0000000;
    pob->besr[1] = 0x0000000;
}","static void ppc4xx_pob_reset (void *opaque)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        ppc4xx_pob_t *pob;
        b = a;
    }
    pob = opaque;
    pob->bear = 0x00000000;
    pob->besr[0] = 0x0000000;
    pob->besr[1] = 0x0000000;
}",1,0,1,0.04,Replace
625,,,,,,,
629,,,,,,,
631,,,,,,,
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
    if (!buffer->cmd) {
        AVBufferRef *buf = buffer->user_data;
        av_buffer_unref(&buf);
    }
    mmal_buffer_header_release(buffer);
}","static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
    if (!buffer->cmd) {
        AVBufferRef *buf = buffer->user_data;
        av_buffer_unref(&buf);
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        mmal_buffer_header_release(buffer);
    }
}",1,0,1,0.04,Replace
634,,,,,,,
636,"static int net_socket_can_send(void *opaque)
{
    NetSocketState *s = opaque;
    return qemu_can_send_packet(&s->nc);
}","static int net_socket_can_send(void *opaque)
{
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PCMDecode *s_6 = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    if (this->ports)
    		goto out;
    int a = 2;
    AVPacket * pk;
    AVFormatContext *s_9;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b_5     = s_9->b_5;
    avio_write(b_5,  pk->data, size);
    int b = 2;
    while (a == b) {
        NetSocketState *s = opaque;
        b += 1;
    }
    return qemu_can_send_packet(&s->nc);
}",0,1,76,0.54,Insert
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    return env->CP0_EBase & 0x3ff;
}","target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    const gdImagePtr src;
    gdRectPtr src_area;
    gdRect area_full;
    if (src_area == NULL) {
    		area_full.x = 0;
    		area_full.y = 0;
    		area_full.width  = gdImageSX(src);
    		area_full.height = gdImageSY(src);
    		src_area = &area_full;
    }
    return env->CP0_EBase & 0x3ff;
}",1,0,5,0.13,Insert
640,,,,,,,
641,,,,,,,
643,,,,,,,
644,"static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
    return width - av_log2(num);
}","static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
        H264Context *h;
        int i, j;
        int i, j;
        if (h->cur_pic_ptr) {
                h->cur_pic_ptr->reference = 0;
                for (j=i=0; h->delayed_pic[i]; i++)
                    if (h->delayed_pic[i] != h->cur_pic_ptr)
                        h->delayed_pic[j++] = h->delayed_pic[i];
                h->delayed_pic[j] = NULL;
        }
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return width - av_log2(num);
    }
}",1,0,9,0.45,Insert
645,,,,,,,
646,"static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    ohci_eof_timer(ohci);
    return 1;
}","static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ohci_eof_timer(ohci);
    strcpy(str, ""a"");
    GstDateTime *dt, *dt2;
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-10-30 15:50:33"");
    fail_unless (gst_date_time_get_year (dt) == 2010);
    fail_unless (gst_date_time_get_month (dt) == 10);
    fail_unless (gst_date_time_get_day (dt) == 30);
    }
    return 1;
}",1,0,34,0.46,Insert
647,,,,,,,
648,"static int srt_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_sub_ptr, AVPacket *avpkt)
{
    AVSubtitle *sub = data;
    AVBPrint buffer;
    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;
    int size, ret;
    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);
    FFASSDecoderContext *s = avctx->priv_data;
    if (p && size == 16) {
        x1 = AV_RL32(p     );
        y1 = AV_RL32(p +  4);
        x2 = AV_RL32(p +  8);
        y2 = AV_RL32(p + 12);
    }
    if (avpkt->size <= 0)
        return avpkt->size;
    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);
    av_bprint_finalize(&buffer, NULL);
    if (ret < 0)
        return ret;
    *got_sub_ptr = sub->num_rects > 0;
    return avpkt->size;
}","static int srt_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_sub_ptr, AVPacket *avpkt)
{
    AVSubtitle *sub = data;
    AVBPrint buffer;
    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;
    int size, ret;
    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);
    int a = 2;
    int b = 2;
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    while (a == b) {
        FFASSDecoderContext *s = avctx->priv_data;
        b += 1;
    }
    if (p && size == 16) {
        x1 = AV_RL32(p     );
        y1 = AV_RL32(p +  4);
        x2 = AV_RL32(p +  8);
        y2 = AV_RL32(p + 12);
        int wb;
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    }
    if (avpkt->size <= 0)
        return avpkt->size;
    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);
    av_bprint_finalize(&buffer, NULL);
    if (ret < 0)
        return ret;
    *got_sub_ptr = sub->num_rects > 0;
    register const xmlChar *cmp = other;
    register const xmlChar *m;
    while (*m != 0 && *m == *cmp) {
    	++m;
    	++cmp;
    	ctxt->input->col++;
    }
    return avpkt->size;
}",0,1,99,1.45,Insert
650,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,
                              int mmu_idx)
{
    if (ppc64_radix_guest(cpu)) {  
        error_report(""Guest Radix Support Unimplemented"");
        exit(1);
    } else {  
        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
    }
}","int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,
                              int mmu_idx)
{
    BlockdevOnError on_source_bug;
    PowerPCCPU *cpu_4;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu_4->viron;
    request = ppc_hash64_start_access(cpu_4, pte_index);
    ppc_hash64_stop_access(request);
    BlockdevOnError on_source_complete;
    BlockdevOnError on_source_bug_4;
    BlockdevOnError on_source_complete_9;
    const char *dev_6;
    enum MirrorSyncMode stage_2;
    int64_t peed_2;
    const char *data_3;
    int data_3;
    Error *localxer_8 = NULL;
    BlockDriverState *source_vs_8;
    int64_t store_7;
    BlockDriverState *bes_6;
    bes_6 = bdrv_find_1(dev_6);
    data_3 = bes_6->open_flags | BDRV_O_RDWR_2;
    store_7 = bdrv_getlength_7(bes_6);
    backup_start_10(bes_6, source_vs_8, peed_2, stage_2, on_source_bug_4, on_source_complete_9,
                     block_job_cb_4, bes_6, &localxer_8);
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (ppc64_radix_guest(cpu)) {  
        error_report(""Guest Radix Support Unimplemented"");
        exit(1);
    } else {  
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
        }
    }
}",0,1,71,0.5,Insert
652,,,,,,,
655,,,,,,,
658,"INLINE int16 extractFloat64Exp( float64 a )
{
    return ( a>>52 ) & 0x7FF;
}","INLINE int16 extractFloat64Exp( float64 a )
{
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_7;
    a_7 = ldb_schema_attribute_by_name(ydm, attr);
    return ( a / (2**52) ) & 0x7FF;
}",0,1,4,0.12,Insert
659,"uint32_t helper_fcmp_un(uint32_t a, uint32_t b)
{
    CPU_FloatU fa, fb;
    uint32_t r = 0;
    fa.l = a;
    fb.l = b;
    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {
        update_fpu_flags(float_flag_invalid);
        r = 1;
    }
    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {
        r = 1;
    }
    return r;
}","uint32_t helper_fcmp_un(uint32_t a, uint32_t b)
{
    int a_1 = 2;
    int wb;
    uint32_t lvcall;
    int C, len, vv;
    len = 0;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    int b_1 = 3;
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    esi->card_status &= ~CARD_STATUS_B;
    sd_set_status(esi);
    esi->current_cmd = err->cmd;
    while (a_1 < b_1) {
        CPU_FloatU fa, fb;
        b_1 = a_1;
    }
    uint32_t r = 0;
    fa.l = a;
    fb.l = b;
    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {
        const char *fil;
        AVIOContext *pb;
        unsigned int base;
        unsigned char *result = NULL;
        int ret = 0, probe_size;
        AVProbeData pd = { fil ? fil : """", NULL, -base };
        ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
        update_fpu_flags(float_flag_invalid);
        r = 1;
    }
    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {
        r = 1;
    }
    return r;
}",0,1,249,1.49,Insert
660,"static int vhost_user_start(VhostUserState *s)
{
    VhostNetOptions options;
    if (vhost_user_running(s)) {
        return 0;
    }
    options.backend_type = VHOST_BACKEND_TYPE_USER;
    options.net_backend = &s->nc;
    options.opaque = s->chr;
    s->vhost_net = vhost_net_init(&options);
    return vhost_user_running(s) ? 0 : -1;
}","static int vhost_user_start(VhostUserState *s)
{
    VhostNetOptions options;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    if (vhost_user_running(s)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return 0;
        strcpy(str, ""a"");
        }
    }
    options.backend_type = VHOST_BACKEND_TYPE_USER;
    options.net_backend = &s->nc;
    options.opaque = s->chr;
    s->vhost_net = vhost_net_init(&options);
    return vhost_user_running(s) ? 0 : -1;
}",0,1,22,0.49,Insert
661,"static int alac_set_info(ALACContext *alac)
{
    GetByteContext gb;
    bytestream2_init(&gb, alac->avctx->extradata,
                     alac->avctx->extradata_size);
    bytestream2_skipu(&gb, 12);  
    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);
    if (alac->max_samples_per_frame >= UINT_MAX/4){
        av_log(alac->avctx, AV_LOG_ERROR,
               ""max_samples_per_frame too large\n"");
        return AVERROR_INVALIDDATA;
    }
    bytestream2_skipu(&gb, 1);   
    alac->sample_size          = bytestream2_get_byteu(&gb);
    alac->rice_history_mult    = bytestream2_get_byteu(&gb);
    alac->rice_initial_history = bytestream2_get_byteu(&gb);
    alac->rice_limit           = bytestream2_get_byteu(&gb);
    alac->channels             = bytestream2_get_byteu(&gb);
    bytestream2_get_be16u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    return 0;
}","static int alac_set_info(ALACContext *alac)
{
    static int  init;
    if (! init) {
             init = 1;
            optimize_flags_init();
    }
    char str[] = ""Constant"";
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    if (strlen(str) > 0) {
        GetByteContext gb;
    }
    bytestream2_init(&gb, alac->avctx->extradata,
                     alac->avctx->extradata_size);
    bytestream2_skipu(&gb, 12);  
    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);
    if (alac->max_samples_per_frame >= UINT_MAX/4){
        av_log(alac->avctx, AV_LOG_ERROR,
               ""max_samples_per_frame too large\n"");
        return AVERROR_INVALIDDATA;
    }
    bytestream2_skipu(&gb, 1);   
    alac->sample_size          = bytestream2_get_byteu(&gb);
    alac->rice_history_mult    = bytestream2_get_byteu(&gb);
    alac->rice_initial_history = bytestream2_get_byteu(&gb);
    alac->rice_limit           = bytestream2_get_byteu(&gb);
    alac->channels             = bytestream2_get_byteu(&gb);
    bytestream2_get_be16u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    return 0;
}",0,1,65,0.89,Insert
663,"static void test_dealloc_types(void)
{
    UserDefOne *ud1test, *ud1a, *ud1b;
    UserDefOneList *ud1list;
    ud1test = g_malloc0(sizeof(UserDefOne));
    ud1test->base = g_new0(UserDefZero, 1);
    ud1test->base->integer = 42;
    ud1test->string = g_strdup(""hi there 42"");
    qapi_free_UserDefOne(ud1test);
    ud1a = g_malloc0(sizeof(UserDefOne));
    ud1a->base = g_new0(UserDefZero, 1);
    ud1a->base->integer = 43;
    ud1a->string = g_strdup(""hi there 43"");
    ud1b = g_malloc0(sizeof(UserDefOne));
    ud1b->base = g_new0(UserDefZero, 1);
    ud1b->base->integer = 44;
    ud1b->string = g_strdup(""hi there 44"");
    ud1list = g_malloc0(sizeof(UserDefOneList));
    ud1list->value = ud1a;
    ud1list->next = g_malloc0(sizeof(UserDefOneList));
    ud1list->next->value = ud1b;
    qapi_free_UserDefOneList(ud1list);
}","static void test_dealloc_types(void)
{
    UserDefOne *ud1test, *ud1a, *ud1b;
    UserDefOneList *ud1list;
    ud1test = g_malloc0(sizeof(UserDefOne));
    ud1test->base = g_new0(UserDefZero, 1);
    int a = 2;
    int b = 2;
    while (a == b) {
        ud1test->base->integer = 42;
        b += 1;
    }
    ud1test->string = g_strdup(""hi there 42"");
    qapi_free_UserDefOne(ud1test);
    ud1a = g_malloc0(sizeof(UserDefOne));
    ud1a->base = g_new0(UserDefZero, 1);
    ud1a->base->integer = 43;
    ud1a->string = g_strdup(""hi there 43"");
    ud1b = g_malloc0(sizeof(UserDefOne));
    ud1b->base = g_new0(UserDefZero, 1);
    ud1b->base->integer = 44;
    ud1b->string = g_strdup(""hi there 44"");
    ud1list = g_malloc0(sizeof(UserDefOneList));
    ud1list->value = ud1a;
    ud1list->next = g_malloc0(sizeof(UserDefOneList));
    ud1list->next->value = ud1b;
    double f;
    f = get_float64 (buffer, &error);
    qapi_free_UserDefOneList(ud1list);
}",0,1,42,0.68,Insert
664,"void net_checksum_calculate(uint8_t *data, int length)
{
    int hlen, plen, proto, csum_offset;
    uint16_t csum;
    if ((data[14] & 0xf0) != 0x40)
	return;  
    hlen  = (data[14] & 0x0f) * 4;
    plen  = (data[16] << 8 | data[17]) - hlen;
    proto = data[23];
    switch (proto) {
    case PROTO_TCP:
	csum_offset = 16;
	break;
    case PROTO_UDP:
	csum_offset = 6;
	break;
    default:
	return;
    }
    if (plen < csum_offset+2)
	return;
    data[14+hlen+csum_offset]   = 0;
    data[14+hlen+csum_offset+1] = 0;
    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);
    data[14+hlen+csum_offset]   = csum >> 8;
    data[14+hlen+csum_offset+1] = csum & 0xff;
}","void net_checksum_calculate(uint8_t *data, int length)
{
    int hlen, plen, proto, csum_offset;
    uint16_t csum;
    if ((data[14] & 0xf0) != 0x40)
	return;  
    hlen  = (data[14] & 0x0f) * 4;
    plen  = (data[16] << 8 | data[17]) - hlen;
    proto = data[23];
    switch (proto) {
    case PROTO_TCP:
	csum_offset = 16;
	int a = 2;
	int b = 2;
	while (a == b) {
    	break;
    	b += 1;
	}
	QuantizationTable
	int lang, rar;
	const char *request= ""DROP TABLE IF EXISTS test_table;""
	                     ""CREATE TABLE test_table(id INT);""
	                     ""INSERT INTO test_table VALUES(10);""
	                     ""UPDATE test_table SET id=20 WHERE id=10;""
	                     ""SELECT * FROM test_table;""
	                     ""INSERT INTO non_existent_table VALUES(11);"";
	MYSQL *mysql___global;
	lang= mysql_query(mysql___global, request);
	myquery(lang);
	lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
	myquery(lang);
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length_7;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length_7=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length_7,
	    sizeof(*table->levels));
    case PROTO_UDP:
	csum_offset = 6;
	break;
    default:
	return;
    }
    if (plen < csum_offset+2)
	return;
    data[14+hlen+csum_offset]   = 0;
    data[14+hlen+csum_offset+1] = 0;
    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);
    data[14+hlen+csum_offset]   = csum >> 8;
    data[14+hlen+csum_offset+1] = csum & 0xff;
}",0,1,78,1.07,Insert
666,,,,,,,
667,,,,,,,
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t ret = gnutls_read(*session, data, datalen);
    if (ret < 0) {
        if (ret == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            errno = EIO;
        }
        ret = -1;
    }
    return ret;
}","static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,
                                   size_t datalen)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        ssize_t ret = gnutls_read(*session, data, datalen);
        b = a;
    }
    if (ret < 0) {
        if (ret == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            AVCodecContext *avctx;
            const AVCodec *codec;
            int ret_1;
            TDSCContext *ctx = avctx->priv_data;
            TDSCContext *ctx = avctx->priv_data;
            ret_1 = avcodec_open2(ctx->jpeg_avctx, codec, NULL);
            ctx->refframe->format = avctx->pix_fmt;
            errno = EIO;
        }
        ret = -1;
    }
    return ret;
}",1,0,11,0.58,Insert
669,,,,,,,
671,"static void stream_close(VideoState *is)
{
    VideoPicture *vp;
    int i;
    is->abort_request = 1;
    SDL_WaitThread(is->read_tid, NULL);
    SDL_WaitThread(is->refresh_tid, NULL);
    packet_queue_destroy(&is->videoq);
    packet_queue_destroy(&is->audioq);
    packet_queue_destroy(&is->subtitleq);
    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {
        vp = &is->pictq[i];
#if CONFIG_AVFILTER
        avfilter_unref_bufferp(&vp->picref);
#endif
        if (vp->bmp) {
            SDL_FreeYUVOverlay(vp->bmp);
            vp->bmp = NULL;
        }
    }
    SDL_DestroyMutex(is->pictq_mutex);
    SDL_DestroyCond(is->pictq_cond);
    SDL_DestroyMutex(is->subpq_mutex);
    SDL_DestroyCond(is->subpq_cond);
    SDL_DestroyCond(is->continue_read_thread);
#if !CONFIG_AVFILTER
    sws_freeContext(is->img_convert_ctx);
#endif
    av_free(is);
}","static void stream_close(VideoState *is)
{
    VideoPicture *vp;
    int i;
    RAMBlock *news_work;
    SysBusDevice *b;
    if (i_4) {
            sysbus_mmio_map(b, 0, i_4);
    }
    news_work->realized = realized;
    is->abort_request = 1;
    SDL_WaitThread(is->read_tid, NULL);
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table->slot=(char *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        SDL_WaitThread(is->refresh_tid, NULL);
    }
    packet_queue_destroy(&is->videoq);
    packet_queue_destroy(&is->audioq);
    packet_queue_destroy(&is->subtitleq);
    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {
        vp = &is->pictq[i];
#if CONFIG_AVFILTER
        avfilter_unref_bufferp(&vp->picref);
#endif
        if (vp->bmp) {
            SDL_FreeYUVOverlay(vp->bmp);
            vp->bmp = NULL;
        }
    }
    SDL_DestroyMutex(is->pictq_mutex);
    SDL_DestroyCond(is->pictq_cond);
    SDL_DestroyMutex(is->subpq_mutex);
    SDL_DestroyCond(is->subpq_cond);
    SDL_DestroyCond(is->continue_read_thread);
#if !CONFIG_AVFILTER
    sws_freeContext(is->img_convert_ctx);
#endif
    av_free(is);
}",0,1,110,1.1,Insert
672,,,,,,,
673,,,,,,,
674,"static int scsi_device_init(SCSIDevice *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}","static int scsi_device_init(SCSIDevice *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return sc->init(s);
        strcpy(str, ""a"");
        }
    }
    return 0;
}",0,1,1,0.05,Replace
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int64_t start, end;
    unsigned long val, idx, bit;
    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;
    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    int64_t start, end;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        unsigned long val, idx, bit;
    }
    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;
    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}",0,1,25,0.71,Insert
676,"static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,
    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)
{
    size_t fetched = 0;
    struct iovec *src = pkt->vec;
    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;
    while (fetched < pkt->virt_hdr.gso_size) {
        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {
            break;
        }
        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {
            break;
        }
        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;
        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,
            pkt->virt_hdr.gso_size - fetched);
        *src_offset += dst[*dst_idx].iov_len;
        fetched += dst[*dst_idx].iov_len;
        if (*src_offset == src[*src_idx].iov_len) {
            *src_offset = 0;
            (*src_idx)++;
        }
        (*dst_idx)++;
    }
    return fetched;
}","static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,
    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)
{
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (key) {
            if (!server_config_defined_vars) {
                struct QemuInputEventQueueHead *queue;
                QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
                QTAILQ_INSERT_TAIL(queue, item, node);
                queue_count++;
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    size_t fetched = 0;
    struct iovec *src = pkt->vec;
    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;
    while (fetched < pkt->virt_hdr.gso_size) {
        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                break;
            }
        }
        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {
            break;
        }
        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;
        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,
            pkt->virt_hdr.gso_size - fetched);
        *src_offset += dst[*dst_idx].iov_len;
        fetched += dst[*dst_idx].iov_len;
        if (*src_offset == src[*src_idx].iov_len) {
            *src_offset = 0;
            (*src_idx)++;
        }
        (*dst_idx)++;
    }
    return fetched;
}",0,1,72,0.92,Insert
677,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}","static void lsi_ram_write(void *opaque, target_phys_addr_t addr,
                          uint64_t val, unsigned size)
{
    int a = 2;
    int b = 3;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         VirtioCcwDevice *dev;
                         Error *err = NULL;
                         VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
                         DeviceState *parent = DEVICE(dev);
                         if (k->realize) {
                                 k->realize(dev, &err);
                         }
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (a != b) {
        LSIState *s = opaque;
        b = a;
    }
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}",0,1,80,0.9,Insert
678,,,,,,,
684,"static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)
{
    char *argstr_flat;
    wchar_t **argv_w;
    int i, buffsize = 0, offset = 0;
    if (win32_argv_utf8) {
        *argc_ptr = win32_argc;
        *argv_ptr = win32_argv_utf8;
        return;
    }
    win32_argc = 0;
    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);
    if (win32_argc <= 0 || !argv_w)
        return;
    for (i = 0; i < win32_argc; i++)
        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
                                        NULL, 0, NULL, NULL);
    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);
    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);
    if (win32_argv_utf8 == NULL) {
        LocalFree(argv_w);
        return;
    }
    for (i = 0; i < win32_argc; i++) {
        win32_argv_utf8[i] = &argstr_flat[offset];
        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
                                      &argstr_flat[offset],
                                      buffsize - offset, NULL, NULL);
    }
    win32_argv_utf8[i] = NULL;
    LocalFree(argv_w);
    *argc_ptr = win32_argc;
    *argv_ptr = win32_argv_utf8;
}","static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)
{
    char *argstr_flat;
    wchar_t **argv_w;
    int i, buffsize = 0, offset = 0;
    if (win32_argv_utf8) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            *argc_ptr = win32_argc;
        strcpy(str, ""a"");
        }
        *argv_ptr = win32_argv_utf8;
        return;
    }
    win32_argc = 0;
    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);
    if (win32_argc <= 0 || !argv_w)
        return;
    for (i = 0; i < win32_argc; i++)
        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
                                        NULL, 0, NULL, NULL);
    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);
    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);
    if (win32_argv_utf8 == NULL) {
        LocalFree(argv_w);
        return;
    }
    for (i = 0; i < win32_argc; i++) {
        win32_argv_utf8[i] = &argstr_flat[offset];
        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
                                      &argstr_flat[offset],
                                      buffsize - offset, NULL, NULL);
    }
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    win32_argv_utf8[i] = NULL;
    LocalFree(argv_w);
    *argc_ptr = win32_argc;
    *argv_ptr = win32_argv_utf8;
}",0,1,37,1.09,Insert
685,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)
{
    switch (size) {
    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;
    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;
    default: abort();
    }
}","static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)
{
    RAMBlock *news_work;
    news_work = g_malloc0(sizeof(*news_work));
    news_work->err = err;
    news_work->realized = realized;
    news_work->used_length = size_3;
    news_work->max_length = maxlennumber;
    switch (size) {
    int a = 2;
    int b = 2;
    while (a == b) {
        case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;
        b += 1;
    }
    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;
    default: abort();
    }
}",0,1,11,0.38,Insert
686,"int MP3lame_encode_frame(AVCodecContext *avctx,
                     unsigned char *frame, int buf_size, void *data)
{
	Mp3AudioContext *s = avctx->priv_data;
	int num, i;
	if (s->stereo) {
		num = lame_encode_buffer_interleaved(s->gfp, data,
			MPA_FRAME_SIZE, frame, buf_size);
	} else {
		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,
			frame, buf_size);
	}
	return num;
}","int MP3lame_encode_frame(AVCodecContext *avctx,
                     unsigned char *frame, int buf_size, void *data)
{
	Mp3AudioContext *s = avctx->priv_data;
	int c, cnt;
	int val;
	struct timeval t1, t2;
	int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
	int64_t alpha;
	int total = 0;
	print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
	int num, i;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	if (s->stereo) {
		num = lame_encode_buffer_interleaved(s->gfp, data,
			MPA_FRAME_SIZE, frame, buf_size);
	} else {
		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,
			frame, buf_size);
	}
	return num;
}",0,1,40,0.66,Insert
687,,,,,,,
689,,,,,,,
693,,,,,,,
694,,,,,,,
695,"static void virtio_crypto_instance_init(Object *obj)
{
    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);
    vcrypto->config_size = sizeof(struct virtio_crypto_config);
    object_property_add_link(obj, ""cryptodev"",
                             TYPE_CRYPTODEV_BACKEND,
                             (Object **)&vcrypto->conf.cryptodev,
                             virtio_crypto_check_cryptodev_is_used,
                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);
}","static void virtio_crypto_instance_init(Object *obj)
{
    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);
    char str[] = ""Constant"";
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    if (strlen(str) > 0) {
        vcrypto->config_size = sizeof(struct virtio_crypto_config);
    }
    object_property_add_link(obj, ""cryptodev"",
                             TYPE_CRYPTODEV_BACKEND,
                             (Object **)&vcrypto->conf.cryptodev,
                             virtio_crypto_check_cryptodev_is_used,
                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);
}",0,1,30,0.37,Insert
696,"int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,
			     int mmu_idx, int is_softmmu)
{
    target_ulong physical;
    int prot, ret, access_type;
    access_type = ACCESS_INT;
    ret =
	get_physical_address(env, &physical, &prot, address, rw,
			     access_type);
    if (ret != MMU_OK) {
	env->tea = address;
	switch (ret) {
	case MMU_ITLB_MISS:
	case MMU_DTLB_MISS_READ:
	    env->exception_index = 0x040;
	    break;
	case MMU_DTLB_MULTIPLE:
	case MMU_ITLB_MULTIPLE:
	    env->exception_index = 0x140;
	    break;
	case MMU_ITLB_VIOLATION:
	    env->exception_index = 0x0a0;
	    break;
	case MMU_DTLB_MISS_WRITE:
	    env->exception_index = 0x060;
	    break;
	case MMU_DTLB_INITIAL_WRITE:
	    env->exception_index = 0x080;
	    break;
	case MMU_DTLB_VIOLATION_READ:
	    env->exception_index = 0x0a0;
	    break;
	case MMU_DTLB_VIOLATION_WRITE:
	    env->exception_index = 0x0c0;
	    break;
	case MMU_IADDR_ERROR:
	case MMU_DADDR_ERROR_READ:
	    env->exception_index = 0x0c0;
	    break;
	case MMU_DADDR_ERROR_WRITE:
	    env->exception_index = 0x100;
	    break;
	default:
	    assert(0);
	}
	return 1;
    }
    address &= TARGET_PAGE_MASK;
    physical &= TARGET_PAGE_MASK;
    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);
}","int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,
			     int mmu_idx, int is_softmmu)
{
    target_ulong physical;
    int prot, ret, access_type;
    access_type = ACCESS_INT;
    MachineState *machine;
    char *filename;
    char *filename_5;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename_5 = qemu_find_file_10(QEMU_FILE_TYPE_BIOS_5, ""spapr-rtas.bin"");
    spapr_1->rtas_size = load_image_targphys(filename_5, spapr_1->rtas_addr,
                                               rtas_limit - spapr_1->rtas_addr);
    g_free(filename_5);
    filename_5 = qemu_find_file_10(QEMU_FILE_TYPE_BIOS_5, bios_name);
    fw_size = load_image_targphys(filename_5, 0, FW_MAX_SIZE);
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    ret =
	get_physical_address(env, &physical, &prot, address, rw,
			     access_type);
    if (ret != MMU_OK) {
	env->tea = address;
	switch (ret) {
	case MMU_ITLB_MISS:
	case MMU_DTLB_MISS_READ:
	    env->exception_index = 0x040;
	int a = 2;
	int b = 3;
	while (a != b) {
    	    break;
    	b = a;
	}
	case MMU_DTLB_MULTIPLE:
	case MMU_ITLB_MULTIPLE:
	    env->exception_index = 0x140;
	    break;
	case MMU_ITLB_VIOLATION:
	    env->exception_index = 0x0a0;
	    break;
	case MMU_DTLB_MISS_WRITE:
	    env->exception_index = 0x060;
	    break;
	case MMU_DTLB_INITIAL_WRITE:
	    env->exception_index = 0x080;
	    break;
	case MMU_DTLB_VIOLATION_READ:
	    env->exception_index = 0x0a0;
	    break;
	case MMU_DTLB_VIOLATION_WRITE:
	    env->exception_index = 0x0c0;
	    break;
	case MMU_IADDR_ERROR:
	case MMU_DADDR_ERROR_READ:
	    env->exception_index = 0x0c0;
	    break;
	case MMU_DADDR_ERROR_WRITE:
	    env->exception_index = 0x100;
	    break;
	default:
	    assert(0);
	}
	return 1;
    }
    address &= TARGET_PAGE_MASK;
    physical &= TARGET_PAGE_MASK;
    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);
}",0,1,62,1.29,Insert
697,,,,,,,
698,,,,,,,
699,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;","target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    int a = 2;
    int b = 3;
    int intno;
    CPUX86State *env;
    SegmentCache *dt;
    if (intno * 16 + 15 > dt->limit) {
            raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);
    }
    while (a != b) {
        hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
        b = a;
    }
    rtas_st(rets, 0, -3);
    return H_PARAMETER;",1,0,9,0.58,Insert
701,"void ip6_input(struct mbuf *m)
{
    struct ip6 *ip6;
    DEBUG_CALL(""ip6_input"");
    DEBUG_ARG(""m = %lx"", (long)m);
    DEBUG_ARG(""m_len = %d"", m->m_len);
    if (m->m_len < sizeof(struct ip6)) {
        goto bad;
    }
    ip6 = mtod(m, struct ip6 *);
    if (ip6->ip_v != IP6VERSION) {
        goto bad;
    }
    if (ip6->ip_hl == 0) {
        goto bad;
    }
    switch (ip6->ip_nh) {
    case IPPROTO_TCP:
        break;
    case IPPROTO_UDP:
        break;
    case IPPROTO_ICMPV6:
        icmp6_input(m);
        break;
    default:
        m_free(m);
    }
    return;
bad:
    m_free(m);
}","void ip6_input(struct mbuf *m)
{
    struct ip6 *ip6;
    DEBUG_CALL(""ip6_input"");
    DEBUG_ARG(""m = %lx"", (long)m);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        DEBUG_ARG(""m_len = %d"", m->m_len);
    strcpy(str, ""a"");
    }
    if (m->m_len < sizeof(struct ip6)) {
        goto bad;
    }
    ip6 = mtod(m, struct ip6 *);
    GfxState *dir;
    SplashPath *mode, * pathtwo;
    SplashPath *mode, * pathtwo;
    path = convertPath(dir, dir->getPath()modepath = convertPath(dir, dir->getPath());
    pathtwo = splash->makeStrokePath(mode);
    if (ip6->ip_v != IP6VERSION) {
        goto bad;
    }
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (ip6->ip_hl == 0) {
        goto bad;
    }
    switch (ip6->ip_nh) {
    case IPPROTO_TCP:
        break;
    case IPPROTO_UDP:
        break;
    case IPPROTO_ICMPV6:
        icmp6_input(m);
        break;
    default:
        m_free(m);
    }
    return;
bad:
    m_free(m);
}",0,1,85,0.82,Insert
702,"void fork_start(void)
{
    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);
    pthread_mutex_lock(&exclusive_lock);
    mmap_fork_start();
}","void fork_start(void)
{
    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);
    pthread_mutex_lock(&exclusive_lock);
    int a = 2;
    int b = 2;
    if (a == b) {
        mmap_fork_start();
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    }
}",0,1,12,0.21,Insert
705,"static void verdex_init(MachineState *machine)
{
    const char *cpu_model = machine->cpu_model;
    PXA2xxState *cpu;
    DriveInfo *dinfo;
    int be;
    MemoryRegion *address_space_mem = get_system_memory();
    uint32_t verdex_rom = 0x02000000;
    uint32_t verdex_ram = 0x10000000;
    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: ""pxa270-c0"");
    dinfo = drive_get(IF_PFLASH, 0, 0);
    if (!dinfo && !qtest_enabled()) {
        fprintf(stderr, ""A flash image must be given with the ""
                ""'pflash' parameter\n"");
        exit(1);
    }
#ifdef TARGET_WORDS_BIGENDIAN
    be = 1;
#else
    be = 0;
#endif
    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,
                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                               sector_len, verdex_rom / sector_len,
                               2, 0, 0, 0, 0, be)) {
        fprintf(stderr, ""qemu: Error registering flash memory.\n"");
        exit(1);
    }
    smc91c111_init(&nd_table[0], 0x04000300,
                    qdev_get_gpio_in(cpu->gpio, 99));
}","static void verdex_init(MachineState *machine)
{
    void *userdata;
    Link *link = userdata;
    assert(link);
    const char *cpu_model = machine->cpu_model;
    size_t ie_len;
    int chels, types, SEClocks, translation;
    int chels, types, SEClocks, translation;
    int chels, types, SEClocks, translation;
    chels = types = SEClocks = 0;
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    PXA2xxState *cpu;
    DriveInfo *dinfo;
    int be;
    MemoryRegion *address_space_mem = get_system_memory();
    uint32_t verdex_rom = 0x02000000;
    uint32_t verdex_ram = 0x10000000;
    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: ""pxa270-c0"");
    dinfo = drive_get(IF_PFLASH, 0, 0);
    if (!dinfo && !qtest_enabled()) {
        fprintf(stderr, ""A flash image must be given with the ""
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
                ""'pflash' parameter\n"");
        exit(1);
    }
    GetBitContext *db;
    int profile_lengtho, level_idc, constraint_set_flags = 0;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    SPS * spr;
    profile_lengtho           = get_bits(db, 8);
    spr->profile_lengtho          = profile_lengtho;
#ifdef TARGET_WORDS_BIGENDIAN
    be = 1;
#else
void *extra;
struct cm_apr_msg *apar_orig;
u8 info_length;
if (extra && info_length) {
		apar_orig->info_length = info_length;
		memcpy(apar_orig->extra, extra, info_length);
}
    be = 0;
#endif
    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,
                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                               sector_len, verdex_rom / sector_len,
                               2, 0, 0, 0, 0, be)) {
        fprintf(stderr, ""qemu: Error registering flash memory.\n"");
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            exit(1);
        }
    }
    smc91c111_init(&nd_table[0], 0x04000300,
                    qdev_get_gpio_in(cpu->gpio, 99));
}",0,1,216,1.57,Insert
707,,,,,,,
709,"static void gen_mtfsfi(DisasContext *ctx)
{
    int bf, sh;
    TCGv_i64 t0;
    TCGv_i32 t1;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_FPU);
        return;
    }
    bf = crbD(ctx->opcode) >> 2;
    sh = 7 - bf;
    gen_update_nip(ctx, ctx->nip - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    t1 = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(cpu_env, t0, t1);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(t1);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);
    }
    gen_helper_float_check_status(cpu_env);
}","static void gen_mtfsfi(DisasContext *ctx)
{
    SDRequest *err;
    int c, cnt;
    MpegEncContext *s;
    if (s->current_picture.reference)
            ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
    int val;
    struct timeval t1_10, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    SDState *esi;
    uint32_t last_status = esi->card_status;
    esi->current_cmd = err->cmd;
    int bf, sh;
    TCGv_i64 t0;
    TCGv_i32 t1;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_FPU);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    bf = crbD(ctx->opcode) >> 2;
    sh = 7 - bf;
    gen_update_nip(ctx, ctx->nip - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    t1 = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(cpu_env, t0, t1);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(t1);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);
    }
    gen_helper_float_check_status(cpu_env);
}",0,1,120,1.28,Insert
710,,,,,,,
712,,,,,,,
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,
                                 QEMUIOVector *qiov, int nb_sectors,
                                 BlockDriverCompletionFunc *cb, void *opaque)
{
    BlockDriver *drv = bs->drv;
    BlockDriverAIOCB *ret;
    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);
    if (!drv)
        return NULL;
    if (bdrv_check_request(bs, sector_num, nb_sectors))
        return NULL;
    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,
                              cb, opaque);
    if (ret) {
	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
	bs->rd_ops ++;
    }
    return ret;
}","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,
                                 QEMUIOVector *qiov, int nb_sectors,
                                 BlockDriverCompletionFunc *cb, void *opaque)
{
    BlockDriver *drv = bs->drv;
    int a = 17;
    int b = a;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if(a*b>0){
        BlockDriverAIOCB *ret;
    }
    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);
    if (!drv)
        return NULL;
    if (bdrv_check_request(bs, sector_num, nb_sectors))
        return NULL;
    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,
                              cb, opaque);
    if (ret) {
	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
	bs->rd_ops ++;
    }
    return ret;
}",0,1,38,0.77,Insert
717,,,,,,,
719,"static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,
                                         void *logctx, int size)
{
    uint8_t *user_data;
    int e, build, i;
    if (size < 16 || size >= INT_MAX - 16)
        return AVERROR_INVALIDDATA;
    user_data = av_malloc(16 + size + 1);
    if (!user_data)
        return AVERROR(ENOMEM);
    for (i = 0; i < size + 16; i++)
        user_data[i] = get_bits(gb, 8);
    user_data[i] = 0;
    e = sscanf(user_data + 16, ""x264 - core %d"", &build);
    if (e == 1 && build > 0)
        h->x264_build = build;
    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))
        h->x264_build = 67;
    if (strlen(user_data + 16) > 0)
        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);
    av_free(user_data);
    return 0;
}","static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,
                                         void *logctx, int size)
{
    uint8_t *user_data;
    int e, build, i;
    if (size < 16 || size >= INT_MAX - 16)
        return AVERROR_INVALIDDATA;
    user_data = av_malloc(16 + size + 1);
    if (!user_data)
        return AVERROR(ENOMEM);
    for (i = 0; i < size + 16; i++)
        user_data[i] = get_bits(gb, 8);
    int a = 2;
    int b = 3;
    while (a != b) {
        user_data[i] = 0;
        b = a;
    }
    e = sscanf(user_data + 16, ""x264 - core %d"", &build);
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    if (e == 1 && build > 0)
        h->x264_build = build;
    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))
        h->x264_build = 67;
    if (strlen(user_data + 16) > 0)
        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);
    av_free(user_data);
    return 0;
}",0,1,41,1.09,Insert
720,"void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
{
    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);
    AVFilterPad *dst = link->dstpad;
    int i;
    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);
    if (!(filter_samples = dst->filter_samples))
        filter_samples = avfilter_default_filter_samples;
    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||
        dst->rej_perms & samplesref->perms) {
        av_log(link->dst, AV_LOG_DEBUG,
               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"",
               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);
        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,
                                                          samplesref->audio->nb_samples);
        link->cur_buf->pts                = samplesref->pts;
        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;
        for (i = 0; samplesref->data[i]; i++)
            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);
        avfilter_unref_buffer(samplesref);
    } else
        link->cur_buf = samplesref;
    filter_samples(link, link->cur_buf);
}","void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
{
    int a = 2;
    int b = 3;
    int nb_oargs;
    int nb_iargs;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    while (a != b) {
        void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);
        b = a;
    }
    AVFilterPad *dst = link->dstpad;
    int i;
    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);
    if (!(filter_samples = dst->filter_samples))
        filter_samples = avfilter_default_filter_samples;
    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||
        dst->rej_perms & samplesref->perms) {
        av_log(link->dst, AV_LOG_DEBUG,
               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"",
               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);
        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,
                                                          samplesref->audio->nb_samples);
        link->cur_buf->pts                = samplesref->pts;
        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;
        for (i = 0; samplesref->data[i]; i++)
            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);
        avfilter_unref_buffer(samplesref);
    } else
        link->cur_buf = samplesref;
    filter_samples(link, link->cur_buf);
}",0,1,75,1.15,Insert
721,,,,,,,
722,,,,,,,
724,,,,,,,
727,"static void sd_response_r1_make(SDState *sd,
                                uint8_t *response, uint32_t last_status)
{
    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;
    uint32_t status;
    status = (sd->card_status & ~mask) | (last_status & mask);
    sd->card_status &= ~CARD_STATUS_C | APP_CMD;
    response[0] = (status >> 24) & 0xff;
    response[1] = (status >> 16) & 0xff;
    response[2] = (status >> 8) & 0xff;
    response[3] = (status >> 0) & 0xff;
}","static void sd_response_r1_make(SDState *sd,
                                uint8_t *response, uint32_t last_status)
{
    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;
    int a = 91;
    int b = a;
    if(a*b>0){
        uint32_t status;
    }
    status = (sd->card_status & ~mask) | (last_status & mask);
    sd->card_status &= ~CARD_STATUS_C | APP_CMD;
    response[0] = (status >> 24) & 0xff;
    response[1] = (status >> 16) & 0xff;
    response[2] = (status >> 8) & 0xff;
    response[3] = (status >> 0) & 0xff;
}",0,1,3,0.07,Replace
729,"DeviceState *qdev_try_create(BusState *bus, const char *name)
{
    DeviceState *dev;
    if (object_class_by_name(name) == NULL) {
        return NULL;
    }
    dev = DEVICE(object_new(name));
    if (!dev) {
        return NULL;
    }
    if (!bus) {
        bus = sysbus_get_default();
    }
    qdev_set_parent_bus(dev, bus);
    qdev_prop_set_globals(dev);
    return dev;
}","DeviceState *qdev_try_create(BusState *bus, const char *name)
{
    char str[] = ""Constant"";
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev_4;
    dev_4 = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev_4->proto_reason_status), dev_4->bssid,
    		   dev_4->disconn_reason, dev_4->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev_4->disconn_reason,
    				dev_4->bssid, dev_4->assoc_resp_len, dev_4->assoc_info,
    				le16_to_cpu(dev_4->proto_reason_status));
    while (strlen(str) > 5) {
        DeviceState *dev;
    strcpy(str, ""a"");
    }
    if (object_class_by_name(name) == NULL) {
        return NULL;
    }
    dev = DEVICE(object_new(name));
    if (!dev) {
        return NULL;
    }
    if (!bus) {
        bus = sysbus_get_default();
    }
    qdev_set_parent_bus(dev, bus);
    qdev_prop_set_globals(dev);
    return dev;
}",0,1,21,0.52,Insert
730,,,,,,,
731,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)
{
    int iomemtype;
    pl080_state *s;
    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));
    iomemtype = cpu_register_io_memory(0, pl080_readfn,
                                       pl080_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->nchannels = nchannels;
    return s;
}","void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)
{
    int iomemtype;
    int a = 2;
    int b = 3;
    while (a != b) {
        pl080_state *s;
        b = a;
    }
    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));
    iomemtype = cpu_register_io_memory(0, pl080_readfn,
                                       pl080_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->nchannels = nchannels;
    return s;
}",1,0,1,0.06,Replace
732,,,,,,,
735,"static void end_last_frame(AVFilterContext *ctx)
{
    TileContext *tile    = ctx->priv;
    AVFilterLink *outlink = ctx->outputs[0];
    AVFilterBufferRef *out_buf = outlink->out_buf;
    outlink->out_buf = NULL;
    ff_start_frame(outlink, out_buf);
    while (tile->current < tile->nb_frames)
        draw_blank_frame(ctx, out_buf);
    ff_draw_slice(outlink, 0, out_buf->video->h, 1);
    ff_end_frame(outlink);
    tile->current = 0;
}","static void end_last_frame(AVFilterContext *ctx)
{
    TileContext *tile    = ctx->priv;
    AVFilterLink *outlink = ctx->outputs[0];
    AVFilterBufferRef *out_buf = outlink->out_buf;
    outlink->out_buf = NULL;
    int a = 49;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    struct net_bridge *bridge = this->bridge;
    if (!netif_running(bridge->dev) || timer_pending(&this->timer))
    		goto out;
    int b = a;
    DisasContext *ctx_5;
    int32_t r1, r2;
    r1 = MASK_OP_BO_S1D(ctx_5->opcode);
    if(a*b>0){
        ff_start_frame(outlink, out_buf);
    }
    while (tile->current < tile->nb_frames)
        draw_blank_frame(ctx, out_buf);
    ff_draw_slice(outlink, 0, out_buf->video->h, 1);
    ff_end_frame(outlink);
    tile->current = 0;
}",0,1,47,0.56,Insert
736,"void av_register_output_format(AVOutputFormat *format)
{
    AVOutputFormat **p = &first_oformat;
    while (*p != NULL)
        p = &(*p)->next;
    *p = format;
    format->next = NULL;
}","void av_register_output_format(AVOutputFormat *format)
{
    struct dir *dir;
    struct proc_mounts *p_10 = dir->private_data;
    if (mnt_had_events(p_10))
    		res |= POLLERR | POLLPRI;
    AVOutputFormat **p = &first_oformat;
    while (*p != NULL)
        p = &(*p)->next;
    int a = 2;
    int b = 2;
    if (a == b) {
        *p = format;
    }
    format->next = NULL;
}",0,1,7,0.29,Insert
738,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,
                                                            int perms)
{
    AVFilterBufferRef *picref =
        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,
                                                  frame->width, frame->height,
                                                  frame->format);
    if (!picref)
        return NULL;
    avfilter_copy_frame_props(picref, frame);
    return picref;
}","AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,
                                                            int perms)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    AVFilterBufferRef *picref =
        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,
                                                  frame->width, frame->height,
                                                  frame->format);
    if (!picref)
        return NULL;
    avfilter_copy_frame_props(picref, frame);
    int a = 22;
    int b = a;
    if(a*b>0){
        return picref;
    }
}",0,1,6,0.44,Insert
739,"void *g_realloc(void *ptr, size_t size)
{
    size_t old_size, copy;
    void *new_ptr;
    if (!ptr)
        return g_malloc(size);
    old_size = *(size_t *)((char *)ptr - 16);
    copy = old_size < size ? old_size : size;
    new_ptr = g_malloc(size);
    memcpy(new_ptr, ptr, copy);
    g_free(ptr);
    return new_ptr;
}","void *g_realloc(void *ptr, size_t size)
{
    size_t old_size, copy;
    void *new_ptr;
    if (!ptr)
        return g_malloc(size);
    int a = 2;
    int b = 3;
    while (a < b) {
        old_size = *(size_t *)((char *)ptr - 16);
        b = a;
    }
    AVCodecContext *avctx;
    AVPacket *avpkt;
    void *data;
    const uint8_t *buf = avpkt->data;
    int nb_samples, coded_samples, ret;
    int nb_samples, coded_samples, ret;
    int buf_size = avpkt->size;
    const uint8_t *buf = avpkt->data;
    ADPCMDecodeContext *c = avctx->priv_data;
    short *samples;
    ADPCMDecodeContext *c = avctx->priv_data;
    nb_samples = get_nb_samples(avctx, buf, buf_size, &coded_samples);
    c->frame.nb_samples = nb_samples;
    samples = (short *)c->frame.data[0];
    copy = old_size < size ? old_size : size;
    new_ptr = g_malloc(size);
    memcpy(new_ptr, ptr, copy);
    g_free(ptr);
    return new_ptr;
}",1,0,17,0.63,Insert
740,,,,,,,
744,"int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->prot->url_shutdown)
        return AVERROR(EINVAL);
    return h->prot->url_shutdown(h, flags);
}","int ffurl_shutdown(URLContext *h, int flags)
{
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_7     = s->b_7;
    if (size & 1)
            avio_w8(b_7, 0);
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (!h->prot->url_shutdown)
        return AVERROR(EINVAL);
    int a = 2;
    int b = 3;
    while (a < b) {
        return h->prot->url_shutdown(h, flags);
        b = a;
    }
}",0,1,64,0.52,Insert
745,,,,,,,
747,"QString *qstring_from_substr(const char *str, int start, int end)
{
    QString *qstring;
    qstring = g_malloc(sizeof(*qstring));
    qstring->length = end - start + 1;
    qstring->capacity = qstring->length;
    qstring->string = g_malloc(qstring->capacity + 1);
    memcpy(qstring->string, str + start, qstring->length);
    qstring->string[qstring->length] = 0;
    QOBJECT_INIT(qstring, &qstring_type);
    return qstring;
}","QString *qstring_from_substr(const char *str, int start, int end)
{
    int diff;
    diff = -1;
    QString *qstring;
    struct usb_serial_port *timeout;
    struct whiteheat_simple close_command;
    void *opaque;
    int32_t fid;
    V9fsPDU *dru = opaque;
    V9fsStat f9stats;
    ssize_t err = 0;
    size_t offset = 7;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                     aml_name(""CDW1"")));
    aml_append(ifconfig, ifconfig0);
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                     aml_name(""CDW1"")));
    pdu_unmarshal(dru, offset, ""d"", &fid);
    offset += pdu_marshal(dru, offset, ""wS"", 0, &f9stats);
    err = offset;
    close_command.timeout = timeout->port_number + 1;
    char str_1[] = ""Constant"";
    char *filename;
    long load_limit, rtas_limit, fw_size;
    if (fw_size < 0) {
            hw_error(""qemu: could not load LPAR rtas '%s'
    "", filename);
    blink::WebURLRequest& quest;
    ResourceType resource_type = WebURLRequestToResourceType(quest);
    RenderThreadImpl* render_thread = RenderThreadImpl::current();
    if (render_thread && render_thread->url_loader_throttle_provider()) {
        extra_data->set_url_loader_throttles(
            render_thread->url_loader_throttle_provider()->CreateThrottles(
                routing_id_, quest, resource_type));
    }
            exit(1);
    }
    if (strlen(str_1) > 0) {
        qstring = g_malloc(sizeof(*qstring));
    }
    qstring->length = end - start + 1;
    qstring->capacity = qstring->length;
    qstring->string = g_malloc(qstring->capacity + 1);
    memcpy(qstring->string, str + start, qstring->length);
    qstring->string[qstring->length] = 0;
    QOBJECT_INIT(qstring, &qstring_type);
    return qstring;
}",0,1,170,1.07,Insert
748,,,,,,,
749,"static int coroutine_fn is_allocated_base(BlockDriverState *top,
                                          BlockDriverState *base,
                                          int64_t sector_num,
                                          int nb_sectors, int *pnum)
{
    BlockDriverState *intermediate;
    int ret, n;
    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);
    if (ret) {
        *pnum = n;
        return ret;
    }
    intermediate = top->backing_hd;
    while (intermediate != base) {
        int pnum_inter;
        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,
                                   &pnum_inter);
        if (ret < 0) {
            return ret;
        } else if (ret) {
            *pnum = pnum_inter;
            return 0;
        }
        if (n > pnum_inter) {
            n = pnum_inter;
        }
        intermediate = intermediate->backing_hd;
    }
    *pnum = n;
    return 1;
}","static int coroutine_fn is_allocated_base(BlockDriverState *top,
                                          BlockDriverState *base,
                                          int64_t sector_num,
                                          int nb_sectors, int *pnum)
{
    BlockDriverState *intermediate;
    int ret, n;
    uint64_t glms;
    unsigned k, b_3, err, C;
    unsigned k, b_3, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_3 = ctz64(glms);
    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);
    if (ret) {
        *pnum = n;
        return ret;
    }
    intermediate = top->backing_hd;
    while (intermediate != base) {
        int pnum_inter;
        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,
                                   &pnum_inter);
        if (ret < 0) {
            int a = 99;
            int b = a;
            if(a*b>0){
                return ret;
            }
        } else if (ret) {
            *pnum = pnum_inter;
            return 0;
        }
        if (n > pnum_inter) {
            n = pnum_inter;
        }
        intermediate = intermediate->backing_hd;
        DisasContext *ctx;
        int32_t r1, r2;
        r2  = MASK_OP_BO_S2(ctx->opcode);
    }
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    *pnum = n;
    return 1;
}",0,1,87,1.19,Insert
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->packet_start + nut->written_packet_size){
        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}","static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->packet_start + nut->written_packet_size){
        int a = 2;
        struct ldb_context *ydm;
        const char *attr;
        const struct ldb_schema_attribute *a_5;
        a_5 = ldb_schema_attribute_by_name(ydm, attr);
        int b = 3;
        if (a != b) {
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            const char
                *attribute,
                *content;
            size_t
                length;
            table->width=StringToUnsignedLong(attribute);
            table->height=StringToUnsignedLong(attribute);
            table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
            length=(size_t) table->width*table->height;
            table->levels=(unsigned int *) AcquireQuantumMemory(length,
                sizeof(*table->levels));
            av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        }
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}",0,1,61,0.96,Insert
752,"static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)
{
    PCIDevice *p = PCI_DEVICE(s);
    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);
    cmd->frame = NULL;
    cmd->pa = 0;
    clear_bit(cmd->index, s->frame_map);
}","static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)
{
    int r;
    if (r < 0) {
            goto out;
    }
    PCIDevice *p = PCI_DEVICE(s);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);
    strcpy(str, ""a"");
    }
    cmd->frame = NULL;
    cmd->pa = 0;
    clear_bit(cmd->index, s->frame_map);
}",0,1,14,0.42,Insert
754,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)
{
    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    static const uint8_t vlan[] = {0x81, 0x00};
    uint8_t *ptr = (uint8_t *)buf;
    int i;
    if (n->promisc)
        return 1;
    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {
        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;
        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
            return 0;
    }
    if ((ptr[0] & 1) && n->allmulti)
        return 1;
    if (!memcmp(ptr, bcast, sizeof(bcast)))
        return 1;
    if (!memcmp(ptr, n->mac, ETH_ALEN))
        return 1;
    for (i = 0; i < n->mac_table.in_use; i++) {
        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))
            return 1;
    }
    return 0;
}","static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)
{
    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    static const uint8_t vlan[] = {0x81, 0x00};
    uint8_t *ptr = (uint8_t *)buf;
    int i;
    if (n->promisc)
        return 1;
    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;
        strcpy(str, ""a"");
        }
        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
            return 0;
    }
    if ((ptr[0] & 1) && n->allmulti)
        return 1;
    if (!memcmp(ptr, bcast, sizeof(bcast)))
        return 1;
    if (!memcmp(ptr, n->mac, ETH_ALEN))
        return 1;
        MpegEncContext *s;
        int mb_x, mb_y;
        double f;
        f = get_float64 (buffer, &error);
        mb_y = s->mb_y;
    for (i = 0; i < n->mac_table.in_use; i++) {
        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))
            return 1;
    }
    return 0;
}",0,1,49,1.01,Insert
756,,,,,,,
757,"GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    return aio_get_g_source(iohandler_ctx);
}","GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    char str[] = ""Constant"";
    MpegEncContext *s;
    if (s->current_picture.reference)
            ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
    if (strlen(str) > 0) {
        return aio_get_g_source(iohandler_ctx);
    }
}",0,1,28,0.25,Insert
763,"static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)
{
    GtkWidget *machine_menu;
    GtkWidget *separator;
    machine_menu = gtk_menu_new();
    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);
    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(""_Pause""));
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);
    separator = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);
    s->reset_item = gtk_menu_item_new_with_mnemonic(_(""_Reset""));
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);
    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(""Power _Down""));
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);
    separator = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);
    s->quit_item = gtk_menu_item_new_with_mnemonic(_(""_Quit""));
    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),
                                 ""<QEMU>/Machine/Quit"");
    gtk_accel_map_add_entry(""<QEMU>/Machine/Quit"",
                            GDK_KEY_q, GDK_CONTROL_MASK);
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);
    return machine_menu;
}","static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)
{
    int a = 2;
    int diff;
    diff = -1;
    int b = 2;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    QuantizationTable
    CharDriverState *chr;
    SpiceCharDriver *sb;
    chr = chr_open(""port"", spice_port_set_fe_open);
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    sb = chr->opaque;
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    while (a == b) {
        GtkWidget *machine_menu;
        b += 1;
    }
    GtkWidget *separator;
    machine_menu = gtk_menu_new();
    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);
    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(""_Pause""));
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);
    separator = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);
    s->reset_item = gtk_menu_item_new_with_mnemonic(_(""_Reset""));
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);
    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(""Power _Down""));
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);
    separator = gtk_separator_menu_item_new();
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);
    s->quit_item = gtk_menu_item_new_with_mnemonic(_(""_Quit""));
    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),
                                 ""<QEMU>/Machine/Quit"");
    gtk_accel_map_add_entry(""<QEMU>/Machine/Quit"",
                            GDK_KEY_q, GDK_CONTROL_MASK);
    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);
    return machine_menu;
}",0,1,191,1.81,Insert
764,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        break;
    }
}","static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        char str[] = ""Constant"";
        struct QemuInputEventQueueHead *queue;
        QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
        QTAILQ_INSERT_TAIL(queue, item, node);
        queue_count++;
        if (strlen(str) > 0) {
            s->cfgr0 = value;
        }
        SysBusDevice *b;
        if (i) {
                sysbus_mmio_map(b, 0, i);
        }
        break;
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
    }
}",0,1,92,0.77,Insert
765,"static int qemu_rdma_get_fd(void *opaque)
{
    QEMUFileRDMA *rfile = opaque;
    RDMAContext *rdma = rfile->rdma;
    return rdma->comp_channel->fd;
}","static int qemu_rdma_get_fd(void *opaque)
{
    int a = 2;
    int b = 3;
    MOVContext *c;
    AVIOContext *pb;
    uint32_t minor_ver;
    char minor_ver_str[11];
    minor_ver = avio_rb32(pb);
    snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
    av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);
    while (a != b) {
        QEMUFileRDMA *rfile = opaque;
        b = a;
    }
    RDMAContext *rdma = rfile->rdma;
    return rdma->comp_channel->fd;
}",1,0,9,0.31,Insert
768,"static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}","static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    int a = 2;
    int b = 3;
    while (a < b) {
        s->size_scaler = 64;
        b = a;
    }
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}",1,0,2,0.06,Replace
769,,,,,,,
774,"int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,
                              int access_type, int mmu_idx, int is_softmmu)
{
    uint32_t phys_addr;
    target_ulong page_size;
    int prot;
    int ret, is_user;
    is_user = mmu_idx == MMU_USER_IDX;
    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,
                        &page_size);
    if (ret == 0) {
        phys_addr &= ~(uint32_t)0x3ff;
        address &= ~(uint32_t)0x3ff;
        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,
                      page_size);
        return 0;
    }
    if (access_type == 2) {
        env->cp15.c5_insn = ret;
        env->cp15.c6_insn = address;
        env->exception_index = EXCP_PREFETCH_ABORT;
    } else {
        env->cp15.c5_data = ret;
        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))
            env->cp15.c5_data |= (1 << 11);
        env->cp15.c6_data = address;
        env->exception_index = EXCP_DATA_ABORT;
    }
    return 1;
}","int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,
                              int access_type, int mmu_idx, int is_softmmu)
{
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    uint32_t phys_addr;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    int a = 1;
    QDict *rss, *lst, *resource, *vne, *acl, *diffen;
    QObject *row, *reader;
    reader = qdict_crumple(rss, &error_abort);
    QDECREF(rss);
    int b = a;
    if(a*b>0){
        target_ulong page_size;
        struct edgeport_serial *serial_1;
        u8 *data_3;
        struct device *dev_5 = &serial_1->serial_1->dev_5->dev_5;
        struct device *dev_5 = &serial_1->serial_1->dev_5->dev_5;
        int status_7;
        status_7 = ti_vread_sync(serial_1->serial_1->dev_5, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_3, 0x01);
        status_7 = ti_vread_sync(serial_1->serial_1->dev_5, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_3, 0x01);
        dev_dbg_6(dev_5, ""%s - Unknown
        "", __func___10);
    }
    int prot;
    int ret, is_user;
    is_user = mmu_idx == MMU_USER_IDX;
    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,
                        &page_size);
    if (ret == 0) {
        phys_addr &= ~(uint32_t)0x3ff;
        address &= ~(uint32_t)0x3ff;
        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,
                      page_size);
        return 0;
    }
    if (access_type == 2) {
        env->cp15.c5_insn = ret;
        env->cp15.c6_insn = address;
        env->exception_index = EXCP_PREFETCH_ABORT;
    } else {
        env->cp15.c5_data = ret;
        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))
            env->cp15.c5_data |= (1 << 11);
        env->cp15.c6_data = address;
        env->exception_index = EXCP_DATA_ABORT;
    }
    return 1;
}",0,1,123,1.38,Insert
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    return h->pps.chroma_qp_table[t][qscale];
}","static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    DisasContext *ctx;
    int32_t r1, r2;
    AVPacket * pk;
    AVFormatContext *s_3;
    int size               =  pk->size;
    AVIOContext *b_2     = s_3->b_2;
    if (size & 1)
            avio_w8(b_2, 0);
    r2  = MASK_OP_BO_S2(ctx->opcode);
    int a = 2;
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    int b = 2;
    while (a == b) {
        return h->pps.chroma_qp_table[t][qscale];
        b += 1;
    }
}",0,1,63,0.42,Insert
777,,,,,,,
779,"struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)
{
    struct omap_l4_s *bus = g_malloc0(
                    sizeof(*bus) + ta_num * sizeof(*bus->ta));
    bus->ta_num = ta_num;
    bus->base = base;
#ifdef L4_MUX_HACK
    omap_l4_io_entries = 1;
    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));
    omap_cpu_io_entry =
            cpu_register_io_memory(omap_l4_io_readfn,
                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);
# define L4_PAGES	(0xb4000 / TARGET_PAGE_SIZE)
    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);
#endif
    return bus;
}","struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)
{
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    struct omap_l4_s *bus = g_malloc0(
                    sizeof(*bus) + ta_num * sizeof(*bus->ta));
    bus->ta_num = ta_num;
    bus->base = base;
#ifdef L4_MUX_HACK
    omap_l4_io_entries = 1;
    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));
    omap_cpu_io_entry =
            cpu_register_io_memory(omap_l4_io_readfn,
                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);
# define L4_PAGES	(0xb4000 / TARGET_PAGE_SIZE)
    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);
    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);
#endif
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return bus;
    strcpy(str, ""a"");
    }
}",0,1,53,0.76,Insert
782,"static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)
{
    const char *p;
    char *q, buf1[20], c;
    int nd, len, addchar_count;
    int found_count = 0;
    q = buf;
    p = filename;
    for (;;) {
        c = *p;
        if (c == '\0')
            break;
        if (c == '%' && *(p+1) == '%')   
            addchar_count = 2;
        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {
            nd = 0;
            addchar_count = 1;
            while (av_isdigit(*(p + addchar_count))) {
                nd = nd * 10 + *(p + addchar_count) - '0';
                addchar_count++;
            }
            if (*(p + addchar_count) == placeholder) {
                len = snprintf(buf1, sizeof(buf1), ""%0*""PRId64, (number < 0) ? nd : nd++, number);
                if (len < 1)   
                    goto fail;
                if ((q - buf + len) > buf_size - 1)
                    goto fail;
                memcpy(q, buf1, len);
                q += len;
                p += (addchar_count + 1);
                addchar_count = 0;
                found_count++;
            }
        } else
            addchar_count = 1;
        while (addchar_count--)
            if ((q - buf) < buf_size - 1)
                *q++ = *p++;
            else
                goto fail;
    }
    *q = '\0';
    return found_count;
fail:
    *q = '\0';
    return -1;
}","static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)
{
    const char *p;
    char *q, buf1[20], c;
    int nd, len, addchar_count;
    int found_count = 0;
    q = buf;
    p = filename;
    for (;;) {
        c = *p;
        if (c == '\0')
            break;
        if (c == '%' && *(p+1) == '%')   
            addchar_count = 2;
        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {
            nd = 0;
            addchar_count = 1;
            while (av_isdigit(*(p + addchar_count))) {
                nd = nd * 10 + *(p + addchar_count) - '0';
                addchar_count++;
            }
            if (*(p + addchar_count) == placeholder) {
                len = snprintf(buf1, sizeof(buf1), ""%0*""PRId64, (number < 0) ? nd : nd++, number);
                if (len < 1)   
                    goto fail;
                if ((q - buf + len) > buf_size - 1)
                    goto fail;
                memcpy(q, buf1, len);
                q += len;
                p += (addchar_count + 1);
                addchar_count = 0;
                int a = 2;
                int b = 2;
                if (a == b) {
                    found_count++;
                }
                VirtioCcwDevice *dev;
                Error *err = NULL;
                VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
                DeviceState *parent = DEVICE(dev);
                if (k->realize) {
                        k->realize(dev, &err);
                }
            }
        } else
            addchar_count = 1;
        while (addchar_count--)
            if ((q - buf) < buf_size - 1)
                *q++ = *p++;
            else
                goto fail;
    }
    *q = '\0';
    return found_count;
fail:
    *q = '\0';
    return -1;
}",0,1,34,1.49,Insert
783,"static void cubieboard_init(QEMUMachineInitArgs *args)
{
    CubieBoardState *s = g_new(CubieBoardState, 1);
    Error *err = NULL;
    s->a10 = AW_A10(object_new(TYPE_AW_A10));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s\n"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}","static void cubieboard_init(QEMUMachineInitArgs *args)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        CubieBoardState *s = g_new(CubieBoardState, 1);
        b = a;
    }
    Error *err = NULL;
    s->a10 = AW_A10(object_new(TYPE_AW_A10));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s\n"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args_2;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args_2[ini]]);
            }
    }
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}",0,1,43,0.81,Insert
784,"void esp_init(target_phys_addr_t espaddr, int it_shift,
              ESPDMAMemoryReadWriteFunc dma_memory_read,
              ESPDMAMemoryReadWriteFunc dma_memory_write,
              void *dma_opaque, qemu_irq irq, qemu_irq *reset,
              qemu_irq *dma_enable)
{
    DeviceState *dev;
    SysBusDevice *s;
    SysBusESPState *sysbus;
    ESPState *esp;
    dev = qdev_create(NULL, ""esp"");
    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);
    esp = &sysbus->esp;
    esp->dma_memory_read = dma_memory_read;
    esp->dma_memory_write = dma_memory_write;
    esp->dma_opaque = dma_opaque;
    sysbus->it_shift = it_shift;
    esp->dma_enabled = 1;
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, espaddr);
    *reset = qdev_get_gpio_in(dev, 0);
    *dma_enable = qdev_get_gpio_in(dev, 1);
}","void esp_init(target_phys_addr_t espaddr, int it_shift,
              ESPDMAMemoryReadWriteFunc dma_memory_read,
              ESPDMAMemoryReadWriteFunc dma_memory_write,
              void *dma_opaque, qemu_irq irq, qemu_irq *reset,
              qemu_irq *dma_enable)
{
    DeviceState *dev;
    SysBusDevice *s;
    SysBusESPState *sysbus;
    ESPState *esp;
    dev = qdev_create(NULL, ""esp"");
    ESPDMAMemoryReadWriteFunc dma_memory_read_6;
    ESPState *esp_5;
    esp_5->dma_memory_read_6 = dma_memory_read_6;
    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);
    esp = &sysbus->esp;
    esp->dma_memory_read = dma_memory_read;
    esp->dma_memory_write = dma_memory_write;
    esp->dma_opaque = dma_opaque;
    sysbus->it_shift = it_shift;
    esp->dma_enabled = 1;
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, espaddr);
    int (*compare)(const char *, const char *, size_t);
    const char *name1;
    const char *name2;
    int cmp;
    unsigned char c1, mc7;
    cmp = compare(name1, name2, len);
    c1 = name1[len];
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map_8(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map_8(busDev, 0, 0xfff34000);
    sysbus_connect_irq_7(busDev, 0, rx[18]);
    int a = 2;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    int b = 2;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    if (a == b) {
        *reset = qdev_get_gpio_in(dev, 0);
    }
    *dma_enable = qdev_get_gpio_in(dev, 1);
}",0,1,195,1.47,Insert
785,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)
{
    WMACodecContext *s = avctx->priv_data;
    float **audio      = (float **) frame->extended_data;
    int len            = frame->nb_samples;
    int window_index   = s->frame_len_bits - s->block_len_bits;
    FFTContext *mdct   = &s->mdct_ctx[window_index];
    int ch;
    const float *win   = s->windows[window_index];
    int window_len     = 1 << s->block_len_bits;
    float n            = 2.0 * 32768.0 / window_len;
    for (ch = 0; ch < avctx->channels; ch++) {
        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));
        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);
        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],
                                    win, len);
        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);
        mdct->mdct_calc(mdct, s->coefs[ch], s->output);
    }
}","static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)
{
    WMACodecContext *s = avctx->priv_data;
    float **audio      = (float **) frame->extended_data;
    int len            = frame->nb_samples;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    int window_index   = s->frame_len_bits - s->block_len_bits;
    FFTContext *mdct   = &s->mdct_ctx[window_index];
    int ch;
    const float *win   = s->windows[window_index];
    int window_len     = 1 << s->block_len_bits;
    float n            = 2.0 * 32768.0 / window_len;
    for (ch = 0; ch < avctx->channels; ch++) {
        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));
        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);
        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],
                                    win, len);
        int a = 2;
        int b = 3;
        while (a < b) {
            s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);
            b = a;
        }
        mdct->mdct_calc(mdct, s->coefs[ch], s->output);
    }
}",0,1,41,1.12,Insert
787,,,,,,,
788,"bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}","bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return false;
        b += 1;
    }
}",1,0,5,0.06,Replace
789,"static void hds_free(AVFormatContext *s)
{
    HDSContext *c = s->priv_data;
    int i, j;
    if (!c->streams)
        return;
    for (i = 0; i < s->nb_streams; i++) {
        OutputStream *os = &c->streams[i];
        if (os->out)
            avio_close(os->out);
        os->out = NULL;
        if (os->ctx && os->ctx_inited)
            av_write_trailer(os->ctx);
        if (os->ctx && os->ctx->pb)
            av_free(os->ctx->pb);
        if (os->ctx)
            avformat_free_context(os->ctx);
        av_free(os->metadata);
        for (j = 0; j < os->nb_extra_packets; j++)
            av_free(os->extra_packets[j]);
        for (j = 0; j < os->nb_fragments; j++)
            av_free(os->fragments[j]);
        av_free(os->fragments);
    }
    av_freep(&c->streams);
}","static void hds_free(AVFormatContext *s)
{
    HDSContext *c = s->priv_data;
    int i, j;
    if (!c->streams)
        return;
    for (i = 0; i < s->nb_streams; i++) {
        OutputStream *os = &c->streams[i];
        if (os->out)
            avio_close(os->out);
        os->out = NULL;
        if (os->ctx && os->ctx_inited)
            av_write_trailer(os->ctx);
        if (os->ctx && os->ctx->pb)
            av_free(os->ctx->pb);
        if (os->ctx)
            avformat_free_context(os->ctx);
        av_free(os->metadata);
        for (j = 0; j < os->nb_extra_packets; j++)
            av_free(os->extra_packets[j]);
        for (j = 0; j < os->nb_fragments; j++)
            av_free(os->fragments[j]);
        av_free(os->fragments);
        u8 * Datapp;
        struct ath6kl_vif *vif;
        struct wmi_disconnect_event *dev;
        dev = (struct wmi_disconnect_event *)  Datapp;
        ath6kl_dbg(ATH6KL_DBG_WMI,
        		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
        "",
        		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
        		   dev->disconn_reason, dev->assoc_resp_len);
        ath6kl_disconnect_event(vif, dev->disconn_reason,
        				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
        				le16_to_cpu(dev->proto_reason_status));
    }
    av_freep(&c->streams);
}",0,1,41,1.05,Insert
790,,,,,,,
791,,,,,,,
792,"QBool *qbool_from_bool(bool value)
{
    QBool *qb;
    qb = g_malloc(sizeof(*qb));
    qb->value = value;
    QOBJECT_INIT(qb, &qbool_type);
    return qb;
}","QBool *qbool_from_bool(bool value)
{
    QBool *qb;
    qb = g_malloc(sizeof(*qb));
    int a = 2;
    struct edgeport_serial *serial;
    const EC_POINT *parent;
    const EC_POINT *points[1];
    points[0] = parent;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    int b = 2;
    if (a == b) {
        qb->value = value;
    }
    QOBJECT_INIT(qb, &qbool_type);
    return qb;
}",0,1,43,0.44,Insert
793,"static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 
                           target_siginfo_t *info,
			   target_sigset_t *set, CPUState *env)
{
	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));
	int err = 0;
#if 0
	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
            return 1;
#endif
	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);
	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);
	err |= copy_siginfo_to_user(&frame->info, info);
	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));
	err |= setup_sigcontext(&frame->uc.uc_mcontext,  
				env, set->sig[0]);
	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
	if (err == 0)
		err = setup_return(env, ka, &frame->retcode, frame, usig);
	if (err == 0) {
            env->regs[1] = (target_ulong)frame->pinfo;
            env->regs[2] = (target_ulong)frame->puc;
	}
}","static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 
                           target_siginfo_t *info,
			   target_sigset_t *set, CPUState *env)
{
	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));
	int err = 0;
#if 0
	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
            return 1;
#endif
	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);
	int a = 44;
	int b = a;
	if(a*b>0){
    	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);
	}
	err |= copy_siginfo_to_user(&frame->info, info);
	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));
	err |= setup_sigcontext(&frame->uc.uc_mcontext,  
				env, set->sig[0]);
	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
	if (err == 0)
		err = setup_return(env, ka, &frame->retcode, frame, usig);
	if (err == 0) {
            env->regs[1] = (target_ulong)frame->pinfo;
            env->regs[2] = (target_ulong)frame->puc;
	}
}",0,1,3,0.11,Replace
796,,,,,,,
797,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));","void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        int nhoff;
        struct frag_queue *pq;
        int offset, end;
        if (offset == 0) {
        		pq->nhoffset = nhoff;
        		pq->q.last_in |= INET_FRAG_FIRST_IN;
        }
        int a = 2;
        int b = 2;
        while (a == b) {
            offload &= ~TUN_F_UFO;
            b += 1;
        }
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",1,0,9,0.83,Insert
799,,,,,,,
800,"static void count_frame_bits_fixed(AC3EncodeContext *s)
{
    static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };
    int blk;
    int frame_bits;
    frame_bits = 16;  
    if (s->eac3) {
        frame_bits += 35;
        frame_bits += 1 + 1 + 1;
        frame_bits += 2;
        frame_bits += 10;
        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)
            frame_bits += 2 * s->fbw_channels + s->lfe_on;
        frame_bits += s->fbw_channels * 5;
        frame_bits += 10;
        frame_bits++;
    } else {
        frame_bits += 49;
        frame_bits += frame_bits_inc[s->channel_mode];
    }
    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {
        if (!s->eac3) {
            frame_bits += s->fbw_channels;
            frame_bits += s->fbw_channels;
        }
        frame_bits++;
        if (s->eac3)
            frame_bits++;
        if (!s->eac3) {
            frame_bits += 2 * s->fbw_channels;
            if (s->lfe_on)
                frame_bits++;
            frame_bits++;
            if (!blk)
                frame_bits += 2 + 2 + 2 + 2 + 3;
        }
        if (s->eac3)
            frame_bits++;
        if (!s->eac3) {
            frame_bits++;
            frame_bits++;
        }
    }
    frame_bits++;
    frame_bits += 1 + 16;
    s->frame_bits_fixed = frame_bits;
}","static void count_frame_bits_fixed(AC3EncodeContext *s)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };
    strcpy(str, ""a"");
    }
    int blk;
    RAMBlock *news_work;
    news_work = g_malloc0(sizeof(*news_work));
    news_work->err = err;
    news_work->realized = realized;
    news_work->used_length = size;
    news_work->max_length = maxlennumber;
    int frame_bits;
    frame_bits = 16;  
    if (s->eac3) {
        frame_bits += 35;
        frame_bits += 1 + 1 + 1;
        frame_bits += 2;
        frame_bits += 10;
        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)
            frame_bits += 2 * s->fbw_channels + s->lfe_on;
        frame_bits += s->fbw_channels * 5;
        frame_bits += 10;
        frame_bits++;
    } else {
        frame_bits += 49;
        frame_bits += frame_bits_inc[s->channel_mode];
    }
    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {
        if (!s->eac3) {
            frame_bits += s->fbw_channels;
            frame_bits += s->fbw_channels;
        }
        frame_bits++;
        if (s->eac3)
            frame_bits++;
        if (!s->eac3) {
            frame_bits += 2 * s->fbw_channels;
            if (s->lfe_on)
                frame_bits++;
            frame_bits++;
            if (!blk)
                frame_bits += 2 + 2 + 2 + 2 + 3;
        }
        if (s->eac3)
            frame_bits++;
        if (!s->eac3) {
            frame_bits++;
            frame_bits++;
        }
    }
    frame_bits++;
    frame_bits += 1 + 16;
    s->frame_bits_fixed = frame_bits;
}",0,1,63,1.29,Insert
801,"static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);
    } else {
        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);
    }
}","static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {
    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
    const int alpha = alpha_table[index_a];
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
    if (alpha ==0 || beta == 0) return;
    if( bS[0] < 4 ) {
        int8_t tc[4];
        tc[0] = tc0_table[index_a][bS[0]];
        tc[1] = tc0_table[index_a][bS[1]];
        tc[2] = tc0_table[index_a][bS[2]];
        tc[3] = tc0_table[index_a][bS[3]];
        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
        struct usbdevfs_connectinfo ci;
        MpegEncContext *ses_1;
        MotionEstContext * const k_9= &ses_1->me;
        MotionEstContext * const k_9= &ses_1->me;
        k_9->avctx= ses_1->avctx;
        ff_set_cmp_7(&ses_1->dsp, ses_1->dsp.me_pre_cmp, k_9->avctx->me_pre_cmp);
        ff_set_cmp_7(&ses_1->dsp, ses_1->dsp.me_cmp, k_9->avctx->me_cmp);
        ff_set_cmp_7(&ses_1->dsp, ses_1->dsp.me_sub_cmp, k_9->avctx->me_sub_cmp);
        ff_set_cmp_7(&ses_1->dsp, ses_1->dsp.mb_cmp, k_9->avctx->mb_cmp);
        USBHostDevice *dev = NULL;
        int fd = -1, ret;
        int fd = -1, ret;
        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);
        ret = usb_linux_update_endp_table(dev);
    } else {
        int a = 2;
        int b = 3;
        while (a != b) {
            h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);
            b = a;
            MpegEncContext *ses;
            MotionEstContext * const k= &ses->me;
            MotionEstContext * const k= &ses->me;
            k->avctx= ses->avctx;
            ff_set_cmp(&ses->dsp, ses->dsp.me_pre_cmp, k->avctx->me_pre_cmp);
            ff_set_cmp(&ses->dsp, ses->dsp.me_cmp, k->avctx->me_cmp);
            ff_set_cmp(&ses->dsp, ses->dsp.me_sub_cmp, k->avctx->me_sub_cmp);
            ff_set_cmp(&ses->dsp, ses->dsp.mb_cmp, k->avctx->mb_cmp);
        }
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
    }
}",0,1,219,1.89,Insert
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        ret= 0;
    return ret;
}","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    *frame_size_ptr= 0;
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        int a = 19;
        int b = a;
        if(a*b>0){
            ret= 0;
        }
    return ret;
}",0,1,46,0.68,Insert
804,,,,,,,
805,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)
{
    int count, x;
    uint8_t *out;
    out = outbuf;
        for(x = 0; x < w; x += count) {
            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {
                if(out + bpp + 1 > outbuf + out_size) return -1;
                *out++ = (count ^ xor) + add;
                memcpy(out, ptr, bpp);
                out += bpp;
            } else {
                count = count_pixels(ptr, w-x, bpp, 0);
                *out++ = count - 1;
                if(out + bpp*count > outbuf + out_size) return -1;
                memcpy(out, ptr, bpp * count);
                out += bpp * count;
        }
        ptr += count * bpp;
    }
    return out - outbuf;
}","int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)
{
    int count, x;
    uint8_t *out;
    out = outbuf;
        for(x = 0; x < w; x += count) {
            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {
                if(out + bpp + 1 > outbuf + out_size) return -1;
                *out++ = (count ^ xor) + add;
                memcpy(out, ptr, bpp);
                out += bpp;
            } else {
                int a = 36;
                int b = a;
                if(a*b>0){
                    count = count_pixels(ptr, w-x, bpp, 0);
                }
                *out++ = count - 1;
                if(out + bpp*count > outbuf + out_size) return -1;
                memcpy(out, ptr, bpp * count);
                out += bpp * count;
        }
        ptr += count * bpp;
    }
    return out - outbuf;
}",0,1,1,0.09,Replace
806,,,,,,,
807,,,,,,,
809,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])
{
    S390CPU *cpu = s390_env_get_cpu(env);
    const unsigned long *features = cpu->model->features;
    unsigned max_bit = 0;
    S390Feat feat;
    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);
    if (test_bit(S390_FEAT_ZARCH, features)) {
        words[0] = 1ull << (63 - 2);
    }
    for (feat = find_first_bit(features, S390_FEAT_MAX);
         feat < S390_FEAT_MAX;
         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {
        const S390FeatDef *def = s390_feat_def(feat);
        if (def->type == S390_FEAT_TYPE_STFL) {
            unsigned bit = def->bit;
            if (bit > max_bit) {
                max_bit = bit;
            }
            assert(bit / 64 < MAX_STFL_WORDS);
            words[bit / 64] |= 1ULL << (63 - bit % 64);
        }
    }
    return max_bit / 64;
}","static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])
{
    S390CPU *cpu = s390_env_get_cpu(env);
    const unsigned long *features = cpu->model->features;
    unsigned max_bit = 0;
    S390Feat feat;
    int a = 2;
    int b = 2;
    hwaddr array;
    PowerPCCPU *cpu_3;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu_3->viron;
    CPUPPCState *viron = &cpu_3->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu_3, pte_index);
    while (a == b) {
        memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);
        b += 1;
    }
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (test_bit(S390_FEAT_ZARCH, features)) {
        words[0] = 1ull << (63 - 2);
    }
    for (feat = find_first_bit(features, S390_FEAT_MAX);
         feat < S390_FEAT_MAX;
         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {
        const S390FeatDef *def = s390_feat_def(feat);
        if (def->type == S390_FEAT_TYPE_STFL) {
            unsigned bit = def->bit;
            if (bit > max_bit) {
                max_bit = bit;
            }
            assert(bit / 64 < MAX_STFL_WORDS);
            words[bit / 64] |= 1ULL << (63 - bit % 64);
        }
    }
    return max_bit / 64;
}",0,1,57,1.07,Insert
810,"static int nbd_establish_connection(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    int sock;
    int ret;
    off_t size;
    size_t blocksize;
    if (s->host_spec[0] == '/') {
        sock = unix_socket_outgoing(s->host_spec);
    } else {
        sock = tcp_socket_outgoing_spec(s->host_spec);
    }
    if (sock < 0) {
        logout(""Failed to establish connection to NBD server\n"");
        return -errno;
    }
    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,
                                &blocksize);
    if (ret < 0) {
        logout(""Failed to negotiate with the NBD server\n"");
        closesocket(sock);
        return -errno;
    }
    socket_set_nonblock(sock);
    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,
                            nbd_have_request, NULL, s);
    s->sock = sock;
    s->size = size;
    s->blocksize = blocksize;
    logout(""Established connection with NBD server\n"");
    return 0;
}","static int nbd_establish_connection(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    int sock;
    int ret;
    off_t size;
    size_t blocksize;
    if (s->host_spec[0] == '/') {
        sock = unix_socket_outgoing(s->host_spec);
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        err = extract32(ksns, 16, 5);
        handle_fp_compare(qs, order, coll, err, false, p);
    } else {
        sock = tcp_socket_outgoing_spec(s->host_spec);
    }
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    if (sock < 0) {
        int a = 2;
        int b = 3;
        if (a != b) {
            logout(""Failed to establish connection to NBD server\n"");
        }
        return -errno;
    }
    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,
                                &blocksize);
    if (ret < 0) {
        logout(""Failed to negotiate with the NBD server\n"");
        closesocket(sock);
        return -errno;
    }
    socket_set_nonblock(sock);
    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,
                            nbd_have_request, NULL, s);
    s->sock = sock;
    s->size = size;
    s->blocksize = blocksize;
    logout(""Established connection with NBD server\n"");
    return 0;
}",0,1,69,1.05,Insert
812,"void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)
{
    int y;
    uint8_t * fcode_tab= s->fcode_tab;
    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);
    for(y=0; y<s->mb_height; y++){
        int x;
        int xy= (y+1)* (s->mb_width+2)+1;
        int i= y*s->mb_width;
        for(x=0; x<s->mb_width; x++)
            {
            if (s->mb_type[i] & type)     
                {
                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)
                    {
                    if(mv_table[xy][0]>0) 
                        mv_table[xy][0]=  range-1;
                    else
                        mv_table[xy][0]= -range;
                    }
                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)
                    {
                    if(mv_table[xy][1]>0) 
                        mv_table[xy][1]=  range-1;
                    else                  
                        mv_table[xy][1]= -range;
            }
            }
            xy++;
            i++;
        }
    }
}","void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)
{
    double f;
    f = get_float64 (buffer, &error);
    int y;
    uint8_t * fcode_tab= s->fcode_tab;
    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);
    for(y=0; y<s->mb_height; y++){
        int x;
        int xy= (y+1)* (s->mb_width+2)+1;
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            int i= y*s->mb_width;
        strcpy(str, ""a"");
        }
        for(x=0; x<s->mb_width; x++)
            {
            if (s->mb_type[i] & type)     
                {
                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)
                    {
                    if(mv_table[xy][0]>0) 
                        mv_table[xy][0]=  range-1;
                    else
                        mv_table[xy][0]= -range;
                    }
                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)
                    {
                    if(mv_table[xy][1]>0) 
                        mv_table[xy][1]=  range-1;
                    else                  
                        mv_table[xy][1]= -range;
            }
            }
            xy++;
            i++;
        }
    }
}",0,1,25,1.22,Insert
813,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)
{
    S390CPU *cpu;
    Error *err = NULL;
    cpu = cpu_s390x_create(cpu_model, &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);
out:
    if (err) {
        error_propagate(errp, err);
        object_unref(OBJECT(cpu));
        cpu = NULL;
    }
    return cpu;
}","S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)
{
    unsigned maxpages;
    size_t *start;
    const char
        *attribute_9,
        *content_10;
    QuantizationTable
        *table_1;
    XMLTreeInfo
    int *out_size;
    int size;
    *out_size = size;
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content_10 != (char *) NULL)
        table_1->description=ConstantString_10(content_10);
    unsigned int iter_head, npages;
    unsigned maxpages_7;
    size_t *start_6;
    unsigned int iter_head_6, npages_4;
    size_t capacity_8;
    capacity_8 = min_7(npages_4, maxpages_7) * PAGE_SIZE_7 - *start_6;
    size_t capacity;
    capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    char str[] = ""Constant"";
    struct udscs_message_header *header;
    const gchar *port = ""invalid message"";
    if (header->port < G_N_ELEMENTS(vdagentd_messages))
            port = vdagentd_messages[header->port];
            Image *image;
            MagickOffsetType
                offset;
            offset=TellBlob(image);
    while (strlen(str) > 5) {
        S390CPU *cpu;
    strcpy(str, ""a"");
    }
    Error *err = NULL;
    cpu = cpu_s390x_create(cpu_model, &err);
    const char *dev;
    BlockDriverState *bes_7;
    bes_7 = bdrv_find(dev);
    if (err != NULL) {
        goto out;
    }
    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);
    const char *data;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    if (attribute != (char *) NULL)
        table->slot=ConstantString(attribute);
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (err != NULL) {
        goto out;
    }
    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);
out:
    if (err) {
        error_propagate(errp, err);
        object_unref(OBJECT(cpu));
        cpu = NULL;
    }
    return cpu;
}",0,1,412,2.18,Insert
814,"aio_compute_timeout(AioContext *ctx)
{
    int64_t deadline;
    int timeout = -1;
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&ctx->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&ctx->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}","aio_compute_timeout(AioContext *ctx)
{
    int64_t deadline;
    int timeout = -1;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_10;
    a_10 = ldb_schema_attribute_by_name(ydm, attr);
    QEMUBH *bh;
    struct hfi1_user_sdma_comp_q *cq;
    u16 idx;
    struct hfi1_user_sdma_pkt_q *pq;
    GF_BitStream *bs_5;
    GF_Box *s_4;
    FilePartitionBox *inter_5 = (FilePartitionBox *)s_4;
    inter_5->nb_entries = gf_bs_read_int_6(bs_5, inter_5->version ? 32 : 16);
    ISOM_DECREASE_SIZE_7(inter_5, inter_5->nb_entries * 6 );
    GF_SAFE_ALLOC_N_1(inter_5->entries, inter_5->nb_entries, FilePartitionEntry_10);
    int ret;
    enum hfi1_sdma_comp_state state;
    cq->comps[idx].status = state;
    trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
    					idx, state, ret);
    for (bh = atomic_rcu_read(&ctx->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            AVStream *tmp;
            AVFormatContext *aws;
            uint32_t v, spf;
            GF_BitStream *bs;
            GF_Box *s;
            FilePartitionBox *inter = (FilePartitionBox *)s;
            inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
            ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
            GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
            MPADecodeHeader ch;
            MP3DecContext *MPthree = aws->priv_data;
            if (MPthree->frames)
                    tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                                tmp->time_base);
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&ctx->tlg);
    if (deadline == 0) {
        int a = 2;
        int b = 3;
        while (a != b) {
            return 0;
            b = a;
        }
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}",0,1,144,1.06,Insert
815,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)
{
    int n=0, x, y, i;
    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));
    for (y=0; y<enc->height; y+=16)
        for (x=0; x<enc->width; x+=16)
            for(i=0; i<4; i++) {
                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;
                tempData->cel_evals[n++].sourceY = y + (i&2)*4;
            }
}","static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)
{
    struct request_list *repl;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    if (attribute != (char *) NULL)
        table->slot=ConstantString(attribute);
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    uint64_t glms;
    unsigned k, b, err, C;
    unsigned k, b, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b = ctz64(glms);
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int n=0, x, y, i;
    }
    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));
    for (y=0; y<enc->height; y+=16)
        for (x=0; x<enc->width; x+=16)
            for(i=0; i<4; i++) {
                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;
                tempData->cel_evals[n++].sourceY = y + (i&2)*4;
            }
}",0,1,74,0.91,Insert
817,,,,,,,
818,"static int video_open(VideoState *is){
    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;
    int w,h;
    if(is_full_screen) flags |= SDL_FULLSCREEN;
    else               flags |= SDL_RESIZABLE;
    if (is_full_screen && fs_screen_width) {
        w = fs_screen_width;
        h = fs_screen_height;
    } else if(!is_full_screen && screen_width){
        w = screen_width;
        h = screen_height;
    }else if (is->video_st && is->video_st->codec->width){
        w = is->video_st->codec->width;
        h = is->video_st->codec->height;
    } else {
        w = 640;
        h = 480;
    }
#ifndef SYS_DARWIN
    screen = SDL_SetVideoMode(w, h, 0, flags);
#else
    screen = SDL_SetVideoMode(w, h, 24, flags);
#endif
    if (!screen) {
        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");
        return -1;
    }
    SDL_WM_SetCaption(""FFplay"", ""FFplay"");
    is->width = screen->w;
    is->height = screen->h;
    return 0;
}","static int video_open(VideoState *is){
    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;
    int w,h;
    if(is_full_screen) flags |= SDL_FULLSCREEN;
    else               flags |= SDL_RESIZABLE;
    HEVCContext *settings;
    int y0;
    int nPbH;
    int nPcH;
    int y1;
    HEVCLocalContext *cpu = settings->HEVClc;
    ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    if (is_full_screen && fs_screen_width) {
        VirtioCcwDevice *dev;
        AVPacket * pk;
        AVFormatContext *s;
        const int stream_index =  pk->stream_index;
        int size               =  pk->size;
        AVIOContext *b_8     = s->b_8;
        avio_wl32(b_8, size);
        avio_write(b_8,  pk->data, size);
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        int a = 30;
        int b = a;
        if(a*b>0){
            w = fs_screen_width;
        }
        h = fs_screen_height;
    } else if(!is_full_screen && screen_width){
        w = screen_width;
        h = screen_height;
    }else if (is->video_st && is->video_st->codec->width){
        w = is->video_st->codec->width;
        h = is->video_st->codec->height;
    } else {
        w = 640;
        h = 480;
    }
#ifndef SYS_DARWIN
    screen = SDL_SetVideoMode(w, h, 0, flags);
#else
    screen = SDL_SetVideoMode(w, h, 24, flags);
#endif
    if (!screen) {
        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");
        return -1;
    }
    SDL_WM_SetCaption(""FFplay"", ""FFplay"");
    is->width = screen->w;
    is->height = screen->h;
    return 0;
}",0,1,128,1.41,Insert
819,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    s->rdy = rdy;
    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));
    return r;
}","static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
    const char
        *attribute,
        *content;
    QuantizationTable
    uint8_t *fig;
    VirtIODevice *vrdevice;
    struct virtio_blk_config blkcfg;
    VirtIOBlock *s_2 = VIRTIO_BLK(vrdevice);
    blkcfg.alignment_offset = 0;
    blkcfg.wce = bdrv_enable_write_cache(s_2->bs);
    memcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));
        *table;
        int diff;
        diff = -1;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    int a = 2;
    int b = 3;
    while (a < b) {
        s->rdy = rdy;
        b = a;
    }
    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));
    return r;
}",0,1,107,0.92,Insert
820,"void qmp_migrate_set_speed(int64_t value, Error **errp)
{
    MigrationState *s;
    if (value < 0) {
        value = 0;
    }
    s = migrate_get_current();
    s->bandwidth_limit = value;
    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);
}","void qmp_migrate_set_speed(int64_t value, Error **errp)
{
    char str[] = ""Constant"";
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_5 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_5->linade, linade, datalen);
    if (strlen(str) > 0) {
        MigrationState *s;
    }
    if (value < 0) {
        value = 0;
    }
    s = migrate_get_current();
    s->bandwidth_limit = value;
    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);
}",0,1,41,0.47,Insert
821,,,,,,,
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    uint8_t *v = pv;
    qemu_put_8s(f, v);
}","static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        const uint8_t *quant;
        int16_t *blks;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        s1 = (int) blks[1 * 8] * quant[1 * 8];
        t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;
        t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
        uint8_t *v = pv;
        b = a;
    }
    qemu_put_8s(f, v);
}",1,0,6,0.33,Insert
824,,,,,,,
826,"static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}","static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        int a = 2;
        int b = 3;
        while (a != b) {
            qemu_cond_init(cpu->halt_cond);
            b = a;
        }
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}",1,0,1,0.12,Replace
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (vs->tls.session) {
        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
    } else {
#endif  
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif  
    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);
    return vnc_client_io_error(vs, ret, socket_error());
}","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (vs->tls.session) {
        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
    } else {
#endif  
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif  
    int a = 2;
    int b = 2;
    while (a == b) {
        VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);
        b += 1;
    }
    return vnc_client_io_error(vs, ret, socket_error());
}",1,0,4,0.08,Replace
829,"static int libgsm_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
                               AVPacket *avpkt) {
    uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);
    if (*data_size < out_size) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        return AVERROR(EINVAL);
    }
    if (buf_size < avctx->block_align) {
        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
        return AVERROR_INVALIDDATA;
    }
    switch(avctx->codec_id) {
    case CODEC_ID_GSM:
        if(gsm_decode(avctx->priv_data,buf,data)) return -1;
        break;
    case CODEC_ID_GSM_MS:
        if(gsm_decode(avctx->priv_data,buf,data) ||
           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;
    }
    *data_size = out_size;
    return avctx->block_align;
}","static int libgsm_decode_frame(AVCodecContext *avctx,
                               void *data, int *data_size,
                               AVPacket *avpkt) {
    uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);
    QEMUMachineInitArgs *args;
    char *filename;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    if (*data_size < out_size) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        int a = 19;
        int b = a;
        if(a*b>0){
            return AVERROR(EINVAL);
        }
    }
    if (buf_size < avctx->block_align) {
        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");
        return AVERROR_INVALIDDATA;
    }
    switch(avctx->codec_id) {
    case CODEC_ID_GSM:
        if(gsm_decode(avctx->priv_data,buf,data)) return -1;
        break;
    case CODEC_ID_GSM_MS:
        if(gsm_decode(avctx->priv_data,buf,data) ||
           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;
    }
    *data_size = out_size;
    return avctx->block_align;
}",0,1,61,0.88,Insert
830,,,,,,,
832,,,,,,,
834,,,,,,,
837,,,,,,,
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = MAX(r1.start, r2.start);
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, end - start + 1);
}","static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = MAX(r1.start, r2.start);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    }
    struct sk_buff *skibar;
    struct frag_queue *pq;
    struct net_device *dev;
    struct net *net = dev_net(skb_dst(skibar)->dev);
    if (dev) {
    		pq->iif = dev->ifindex;
    		skibar->dev = NULL;
    }
    return addrrange_make(start, end - start + 1);
}",1,0,9,0.38,Insert
840,"static int64_t do_strtosz(const char *nptr, char **end,
                          const char default_suffix, int64_t unit)
{
    int64_t retval;
    char *endptr;
    unsigned char c;
    int mul_required = 0;
    double val, mul, integral, fraction;
    errno = 0;
    val = strtod(nptr, &endptr);
    if (isnan(val) || endptr == nptr || errno != 0) {
        retval = -EINVAL;
        goto out;
    }
    fraction = modf(val, &integral);
    if (fraction != 0) {
        mul_required = 1;
    }
    c = *endptr;
    mul = suffix_mul(c, unit);
    if (mul >= 0) {
        endptr++;
    } else {
        mul = suffix_mul(default_suffix, unit);
        assert(mul >= 0);
    }
    if (mul == 1 && mul_required) {
        retval = -EINVAL;
        goto out;
    }
    if ((val * mul >= INT64_MAX) || val < 0) {
        retval = -ERANGE;
        goto out;
    }
    retval = val * mul;
out:
    if (end) {
        *end = endptr;
    } else if (*endptr) {
        retval = -EINVAL;
    }
    return retval;
}","static int64_t do_strtosz(const char *nptr, char **end,
                          const char default_suffix, int64_t unit)
{
    int64_t retval;
    char *endptr;
    unsigned char c;
    int mul_required = 0;
    double val, mul, integral, fraction;
    errno = 0;
    val = strtod(nptr, &endptr);
    if (isnan(val) || endptr == nptr || errno != 0) {
        retval = -EINVAL;
        goto out;
    }
    fraction = modf(val, &integral);
    if (fraction != 0) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            mul_required = 1;
        }
    }
    c = *endptr;
    mul = suffix_mul(c, unit);
    if (mul >= 0) {
        endptr++;
    } else {
        mul = suffix_mul(default_suffix, unit);
        assert(mul >= 0);
    }
    if (mul == 1 && mul_required) {
        retval = -EINVAL;
        goto out;
    }
    if ((val * mul >= INT64_MAX) || val < 0) {
        retval = -ERANGE;
        goto out;
    }
    retval = val * mul;
out:
    if (end) {
        *end = endptr;
    } else if (*endptr) {
        retval = -EINVAL;
    }
    return retval;
}",0,1,1,0.2,Replace
842,,,,,,,
843,"static inline int onenand_erase(OneNANDState *s, int sec, int num)
{
    uint8_t *blankbuf, *tmpbuf;
    blankbuf = g_malloc(512);
    if (!blankbuf) {
        return 1;
    }
    tmpbuf = g_malloc(512);
    if (!tmpbuf) {
        g_free(blankbuf);
        return 1;
    }
    memset(blankbuf, 0xff, 512);
    for (; num > 0; num--, sec++) {
        if (s->bdrv_cur) {
            int erasesec = s->secs_cur + (sec >> 5);
            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {
                goto fail;
            }
            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {
                goto fail;
            }
            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);
            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {
                goto fail;
            }
        } else {
            if (sec + 1 > s->secs_cur) {
                goto fail;
            }
            memcpy(s->current + (sec << 9), blankbuf, 512);
            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),
                   blankbuf, 1 << 4);
        }
    }
    g_free(tmpbuf);
    g_free(blankbuf);
    return 0;
fail:
    g_free(tmpbuf);
    g_free(blankbuf);
    return 1;
}","static inline int onenand_erase(OneNANDState *s, int sec, int num)
{
    uint8_t *blankbuf, *tmpbuf;
    blankbuf = g_malloc(512);
    if (!blankbuf) {
        return 1;
    }
    tmpbuf = g_malloc(512);
    if (!tmpbuf) {
        g_free(blankbuf);
        return 1;
    }
    memset(blankbuf, 0xff, 512);
    for (; num > 0; num--, sec++) {
        if (s->bdrv_cur) {
            int erasesec = s->secs_cur + (sec >> 5);
            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {
                goto fail;
            }
            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {
                goto fail;
            }
            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);
            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {
                goto fail;
            }
        } else {
            if (sec + 1 > s->secs_cur) {
                goto fail;
            }
            memcpy(s->current + (sec << 9), blankbuf, 512);
            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),
                   blankbuf, 1 << 4);
        }
    }
    g_free(tmpbuf);
    g_free(blankbuf);
    char str[] = ""Constant"";
    DisasContext *ctx;
    int32_t r1, r2;
    r1 = MASK_OP_BO_S1D(ctx->opcode);
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
fail:
    g_free(tmpbuf);
    g_free(blankbuf);
    return 1;
}",0,1,35,1.11,Insert
845,"static int default_lockmgr_cb(void **arg, enum AVLockOp op)
{
    void * volatile * mutex = arg;
    int err;
    switch (op) {
    case AV_LOCK_CREATE:
        return 0;
    case AV_LOCK_OBTAIN:
        if (!*mutex) {
            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));
            if (!tmp)
                return AVERROR(ENOMEM);
            if ((err = pthread_mutex_init(tmp, NULL))) {
                av_free(tmp);
                return AVERROR(err);
            }
            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {
                pthread_mutex_destroy(tmp);
                av_free(tmp);
            }
        }
        if ((err = pthread_mutex_lock(*mutex)))
            return AVERROR(err);
        return 0;
    case AV_LOCK_RELEASE:
        if ((err = pthread_mutex_unlock(*mutex)))
            return AVERROR(err);
        return 0;
    case AV_LOCK_DESTROY:
        if (*mutex)
            pthread_mutex_destroy(*mutex);
        av_free(*mutex);
        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);
        return 0;
    }
    return 1;
}","static int default_lockmgr_cb(void **arg, enum AVLockOp op)
{
    void * volatile * mutex = arg;
    int err;
    switch (op) {
    case AV_LOCK_CREATE:
        return 0;
    case AV_LOCK_OBTAIN:
        if (!*mutex) {
            int a = 2;
            int b = 2;
            if (a == b) {
                pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));
            }
            if (!tmp)
                return AVERROR(ENOMEM);
            if ((err = pthread_mutex_init(tmp, NULL))) {
                av_free(tmp);
                return AVERROR(err);
            }
            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {
                pthread_mutex_destroy(tmp);
                av_free(tmp);
            }
        }
        H264Context *h;
        int i, j;
        for (i = 0; i < h->nb_slice_ctx; i++)
                h->slice_ctx[i].list_count = 0;
        if ((err = pthread_mutex_lock(*mutex)))
            return AVERROR(err);
        return 0;
    case AV_LOCK_RELEASE:
        if ((err = pthread_mutex_unlock(*mutex)))
            return AVERROR(err);
        return 0;
    case AV_LOCK_DESTROY:
        if (*mutex)
            pthread_mutex_destroy(*mutex);
        av_free(*mutex);
        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);
        return 0;
    }
    return 1;
}",1,0,38,1.04,Insert
848,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)
{
    VAAPIEncodeContext *ctx = avctx->priv_data;
    VAAPIEncodePicture *pic, *next;
    for (pic = ctx->pic_start; pic; pic = next) {
        next = pic->next;
        vaapi_encode_free(avctx, pic);
    }
    if (ctx->va_context != VA_INVALID_ID) {
        vaDestroyContext(ctx->hwctx->display, ctx->va_context);
        ctx->va_context = VA_INVALID_ID;
    }
    if (ctx->va_config != VA_INVALID_ID) {
        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
        ctx->va_config = VA_INVALID_ID;
    }
    if (ctx->codec->close)
        ctx->codec->close(avctx);
    av_buffer_pool_uninit(&ctx->output_buffer_pool);
    av_freep(&ctx->codec_sequence_params);
    av_freep(&ctx->codec_picture_params);
    av_buffer_unref(&ctx->recon_frames_ref);
    av_buffer_unref(&ctx->input_frames_ref);
    av_buffer_unref(&ctx->device_ref);
    av_freep(&ctx->priv_data);
    return 0;
}","av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)
{
    VAAPIEncodeContext *ctx = avctx->priv_data;
    VAAPIEncodePicture *pic, *next;
    for (pic = ctx->pic_start; pic; pic = next) {
        int a = 2;
        int b = 2;
        while (a == b) {
            next = pic->next;
            b += 1;
        }
        vaapi_encode_free(avctx, pic);
    }
    if (ctx->va_context != VA_INVALID_ID) {
        char *filename;
        g_free(filename);
        vaDestroyContext(ctx->hwctx->display, ctx->va_context);
        ctx->va_context = VA_INVALID_ID;
        int flags;
        RTPContext *http;
        char val[1024];
        if (url_open(&http->rtp_hd, val, flags) < 0)
                goto fail;
    }
    if (ctx->va_config != VA_INVALID_ID) {
        char *filename_1;
        long load_limit, fw_size;
        if (fw_size <= 0) {
                error_report(""Could not load LPAR firmware '%s'"", filename_1);
                exit(1);
        }
        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
        ctx->va_config = VA_INVALID_ID;
    }
    if (ctx->codec->close)
        ctx->codec->close(avctx);
    av_buffer_pool_uninit(&ctx->output_buffer_pool);
    av_freep(&ctx->codec_sequence_params);
    av_freep(&ctx->codec_picture_params);
    av_buffer_unref(&ctx->recon_frames_ref);
    av_buffer_unref(&ctx->input_frames_ref);
    av_buffer_unref(&ctx->device_ref);
    av_freep(&ctx->priv_data);
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i;
    for (i = 1; i < err; i++)
            if (nrsc[i] < nrsc[i - 1] + min_mesh[i])
                nrsc[i] = nrsc[i - 1] + min_mesh[i];
    return 0;
}",0,1,150,1.31,Insert
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            return -EIO;
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}","static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            int a = 2;
            int b = 3;
            if (a != b) {
                return -EIO;
            }
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}",0,1,22,0.6,Insert
850,"AioContext *blk_get_aio_context(BlockBackend *blk)
{
    return bdrv_get_aio_context(blk->bs);
}","AioContext *blk_get_aio_context(BlockBackend *blk)
{
    int a = 2;
    int b = 3;
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    while (a < b) {
        return bdrv_get_aio_context(blk->bs);
        b = a;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    }
}",0,1,37,0.4,Insert
851,"static int vfio_load_rom(VFIODevice *vdev)
{
    uint64_t size = vdev->rom_size;
    char name[32];
    off_t off = 0, voff = vdev->rom_offset;
    ssize_t bytes;
    void *ptr;
    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {
        return 0;
    }
    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,
            vdev->host.bus, vdev->host.slot, vdev->host.function);
    snprintf(name, sizeof(name), ""vfio[%04x:%02x:%02x.%x].rom"",
             vdev->host.domain, vdev->host.bus, vdev->host.slot,
             vdev->host.function);
    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);
    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);
    memset(ptr, 0xff, size);
    while (size) {
        bytes = pread(vdev->fd, ptr + off, size, voff + off);
        if (bytes == 0) {
            break;  
        } else if (bytes > 0) {
            off += bytes;
            size -= bytes;
        } else {
            if (errno == EINTR || errno == EAGAIN) {
                continue;
            }
            error_report(""vfio: Error reading device ROM: %m"");
            memory_region_destroy(&vdev->pdev.rom);
            return -errno;
        }
    }
    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);
    vdev->pdev.has_rom = true;
    return 0;
}","static int vfio_load_rom(VFIODevice *vdev)
{
    uint64_t size = vdev->rom_size;
    char name[32];
    off_t off = 0, voff = vdev->rom_offset;
    int a = 39;
    int b = a;
    if(a*b>0){
        ssize_t bytes;
    }
    void *ptr;
    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {
        return 0;
    }
    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,
            vdev->host.bus, vdev->host.slot, vdev->host.function);
    snprintf(name, sizeof(name), ""vfio[%04x:%02x:%02x.%x].rom"",
             vdev->host.domain, vdev->host.bus, vdev->host.slot,
             vdev->host.function);
    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);
    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);
    memset(ptr, 0xff, size);
    while (size) {
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        description=GetXMLTreeChild(table_iterator,""description"");
        levels=GetXMLTreeChild(table_iterator,""levels"");
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        bytes = pread(vdev->fd, ptr + off, size, voff + off);
        if (bytes == 0) {
            break;  
        } else if (bytes > 0) {
            off += bytes;
            size -= bytes;
            Unit *u;
            Unit *other;
            int range;
            Automount *worker = AUTOMOUNT(u);
            if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                            (void) automount_send_ready(worker, worker->tokens, 0);
                            range = automount_start_expire(worker);
                            if (range < 0)
                                    log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                            automount_set_state(worker, AUTOMOUNT_RUNNING);
            }
        } else {
            if (errno == EINTR || errno == EAGAIN) {
                continue;
            }
            error_report(""vfio: Error reading device ROM: %m"");
            memory_region_destroy(&vdev->pdev.rom);
            return -errno;
        }
    }
    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);
    vdev->pdev.has_rom = true;
    return 0;
}",0,1,69,1.37,Insert
852,"UuidInfo *qmp_query_uuid(Error **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],
                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],
                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],
                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
                   qemu_uuid[14], qemu_uuid[15]);
    info->UUID = g_strdup(uuid);
    return info;
}","UuidInfo *qmp_query_uuid(Error **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    int a = 2;
    int b = 3;
    const char
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_5;
    a_5 = ldb_schema_attribute_by_name(ydm, attr);
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    while (a != b) {
        char uuid[64];
        b = a;
    }
    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],
                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],
                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],
                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
                   qemu_uuid[14], qemu_uuid[15]);
    info->UUID = g_strdup(uuid);
    return info;
}",0,1,39,0.68,Insert
854,,,,,,,
856,,,,,,,
857,"static void apic_update_irq(APICState *s)
{
    int irrv, ppr;
    if (!(s->spurious_vec & APIC_SV_ENABLE))
        return;
    irrv = get_highest_priority_int(s->irr);
    if (irrv < 0)
        return;
    ppr = apic_get_ppr(s);
    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))
        return;
    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
}","static void apic_update_irq(APICState *s)
{
    int diff;
    diff = -1;
    char str[] = ""Constant"";
    int r;
    if (r < 0) {
            AVPacket *mctx;
            Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
            PutBitContext pb_6, pb2_4;
            JLSState *state;
            int i_6, size_2, ure_1;
            PutBitContext pb_6, pb2_4;
            ls_store_lse(state, &pb_6);
            put_bits(&pb2_4, 7, 0);
            size_2 = put_bits_count_10(&pb2_4);
            flush_put_bits(&pb2_4);
            avpriv_align_put_bits(&pb_6);
            Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
            Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
            aml_append(coll,
                    aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
            aml_append(ifconfig,
                    aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
            aml_append(ifconfig,
                    aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
            aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                            aml_name(""CTRL"")));
            ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
            uint8_t *uf8 = NULL;
            GetBitContext gb;
            PutBitContext pb, pb2;
            PutBitContext pb, pb2;
            int i, size, ure;
            size = put_bits_count(&pb2);
            init_get_bits(&gb, uf8, size);
            size -= 7;
            mctx->size   = put_bits_count(&pb) >> 3;
            goto out;
    }
    char **names;
    MpegEncContext *s_1;
    int mb_x, mb_y;
    mb_y = s_1->mb_y;
    char *p;
    char *ea_namelist = smallbuf;
    size_t num_names;
    for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen_2(p)+1) {
    		names[num_names++] = p;
    }
    while (strlen(str) > 5) {
        int irrv, ppr;
    strcpy(str, ""a"");
    }
    if (!(s->spurious_vec & APIC_SV_ENABLE))
        return;
    irrv = get_highest_priority_int(s->irr);
    if (irrv < 0)
        return;
    ppr = apic_get_ppr(s);
    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))
        return;
    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
}",0,1,646,3.04,Insert
859,"static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)
{
    BDRVQEDState *s = acb_to_s(acb);
    qemu_iovec_destroy(&acb->cur_qiov);
    qed_unref_l2_cache_entry(acb->request.l2_table);
    if (acb->flags & QED_AIOCB_ZERO) {
        qemu_vfree(acb->qiov->iov[0].iov_base);
        acb->qiov->iov[0].iov_base = NULL;
    }
    if (acb == s->allocating_acb) {
        s->allocating_acb = NULL;
        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {
            qemu_co_enter_next(&s->allocating_write_reqs);
        } else if (s->header.features & QED_F_NEED_CHECK) {
            qed_start_need_check_timer(s);
        }
    }
}","static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)
{
    BDRVQEDState *s = acb_to_s(acb);
    qemu_iovec_destroy(&acb->cur_qiov);
    qed_unref_l2_cache_entry(acb->request.l2_table);
    if (acb->flags & QED_AIOCB_ZERO) {
        qemu_vfree(acb->qiov->iov[0].iov_base);
        acb->qiov->iov[0].iov_base = NULL;
    }
    if (acb == s->allocating_acb) {
        s->allocating_acb = NULL;
        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {
            qemu_co_enter_next(&s->allocating_write_reqs);
            QuantizationTable
            struct sock *sk;
            struct sctp_assocparams assecsettings;
            struct sctp_association *isec;
            isec = sctp_id2assoc(sk, assecsettings.sasoc_assoc_id);
                *table;
                struct edgeport_serial *serial;
                u8 *data;
                struct device *dev = &serial->serial->dev->dev;
                struct device *dev = &serial->serial->dev->dev;
                int status;
                status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
                				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
                status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
                				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
                dev_dbg(dev, ""%s - Unknown
                "", __func__);
                const uint16_t min_mesh[17];
                int16_t nrsc[16];
                int err;
                int path, i;
                for (i = err-2; i >= 0; i--)
                        if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                            nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
            const char
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            table->slot=(char *) NULL;
            attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        } else if (s->header.features & QED_F_NEED_CHECK) {
            int a = 2;
            int b = 2;
            while (a == b) {
                qed_start_need_check_timer(s);
                b += 1;
            }
        }
    }
}",0,1,132,1.0,Insert
866,"static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)
{
    AMFDataType type;
    AVStream *stream, *astream, *vstream;
    AVIOContext *ioc;
    int i;
    char buffer[11];
    astream = NULL;
    vstream = NULL;
    ioc     = s->pb;
    type = avio_r8(ioc);
    if (type != AMF_DATA_TYPE_STRING ||
        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)
        return -1;
    if (!strcmp(buffer, ""onTextData""))
        return 1;
    if (strcmp(buffer, ""onMetaData""))
        return -1;
    for (i = 0; i < s->nb_streams; i++) {
        stream = s->streams[i];
        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)
            astream = stream;
        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)
            vstream = stream;
    }
    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)
        return -1;
    return 0;
}","static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)
{
    AMFDataType type;
    AVStream *stream, *astream, *vstream;
    AVIOContext *ioc;
    int i;
    char buffer[11];
    astream = NULL;
    vstream = NULL;
    ioc     = s->pb;
    type = avio_r8(ioc);
    if (type != AMF_DATA_TYPE_STRING ||
        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)
        return -1;
    if (!strcmp(buffer, ""onTextData""))
        return 1;
    if (strcmp(buffer, ""onMetaData""))
        return -1;
    for (i = 0; i < s->nb_streams; i++) {
        stream = s->streams[i];
        RAMBlock *news_work;
        news_work = g_malloc0(sizeof(*news_work));
        news_work->err = err;
        news_work->realized = realized;
        news_work->used_length = size;
        news_work->max_length = maxlennumber;
        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)
            astream = stream;
        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)
            vstream = stream;
    }
    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)
        return -1;
    return 0;
}",0,1,41,0.92,Insert
868,"static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)
{
    int i;
    GICState *s = KVM_ARM_GIC(dev);
    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);
    kgc->parent_realize(dev, errp);
    if (error_is_set(errp)) {
        return;
    }
    i = s->num_irq - GIC_INTERNAL;
    i += (GIC_INTERNAL * s->num_cpu);
    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);
    for (i = 0; i < s->num_cpu; i++) {
        sysbus_init_irq(sbd, &s->parent_irq[i]);
    }
    memory_region_init_reservation(&s->iomem, OBJECT(s),
                                   ""kvm-gic_dist"", 0x1000);
    sysbus_init_mmio(sbd, &s->iomem);
    kvm_arm_register_device(&s->iomem,
                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)
                            | KVM_VGIC_V2_ADDR_TYPE_DIST);
    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),
                                   ""kvm-gic_cpu"", 0x1000);
    sysbus_init_mmio(sbd, &s->cpuiomem[0]);
    kvm_arm_register_device(&s->cpuiomem[0],
                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)
                            | KVM_VGIC_V2_ADDR_TYPE_CPU);
}","static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)
{
    int i;
    GICState *s = KVM_ARM_GIC(dev);
    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);
    int a = 83;
    int b = a;
    if(a*b>0){
        kgc->parent_realize(dev, errp);
    }
    if (error_is_set(errp)) {
        return;
    }
    i = s->num_irq - GIC_INTERNAL;
    i += (GIC_INTERNAL * s->num_cpu);
    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);
    for (i = 0; i < s->num_cpu; i++) {
        sysbus_init_irq(sbd, &s->parent_irq[i]);
    }
    memory_region_init_reservation(&s->iomem, OBJECT(s),
                                   ""kvm-gic_dist"", 0x1000);
    sysbus_init_mmio(sbd, &s->iomem);
    kvm_arm_register_device(&s->iomem,
                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)
                            | KVM_VGIC_V2_ADDR_TYPE_DIST);
    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),
                                   ""kvm-gic_cpu"", 0x1000);
    sysbus_init_mmio(sbd, &s->cpuiomem[0]);
    kvm_arm_register_device(&s->cpuiomem[0],
                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)
                            | KVM_VGIC_V2_ADDR_TYPE_CPU);
}",0,1,1,0.14,Replace
869,,,,,,,
870,,,,,,,
872,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,
                                 unsigned size)
{
    PICCommonState *s = opaque;
    return s->elcr;
}","static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,
                                 unsigned size)
{
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    int a = 2;
    int b = 3;
    SysBusDevice *b_1;
    if (i) {
            sysbus_mmio_map(b_1, 0, i);
    }
    while (a != b) {
        PICCommonState *s = opaque;
        b = a;
        struct tty_struct *tty;
        ssize_t n;
        down_write(&tty->termios_rwsem);
        n = chars_in_buffer(tty);
        up_write(&tty->termios_rwsem);
    }
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    return s->elcr;
}",0,1,95,0.66,Insert
873,,,,,,,
874,,,,,,,
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, ret);
}","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        tcg_r1 = load_gpr(ctx, r1);
    }
    BlockDriverState *bs;
    struct rtable *rt_4 = NULL;
    struct geneve_dev *geneve = netdev_priv(dev);
    rt_4 = ip_route_output_key(geneve->net, fl4);
    uint64_t offset;
    BDRVVHDXState *s;
    uint64_t file_offset;
    uint32_t desc_sectors, sectors, total_length;
    VHDXLogEntryHeader new_hdr;
    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;
    new_hdr = (VHDXLogEntryHeader) {
                    .signature           = VHDX_LOG_SIGNATURE,
                    .tail                = s->log.tail,
                    .sequence_number     = s->log.sequence,
                    .descriptor_count    = sectors,
                    .reserved            = 0,
                    .flushed_file_offset = bdrv_getlength(bs->file->bs),
                    .last_file_offset    = bdrv_getlength(bs->file->bs),
                  };
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, ret);
}",1,0,54,0.91,Insert
877,,,,,,,
878,,,,,,,
881,,,,,,,
882,"enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target)
{
    if (codec && codec->pix_fmts) {
        const enum AVPixelFormat *p = codec->pix_fmts;
        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;
        enum AVPixelFormat best= AV_PIX_FMT_NONE;
        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {
            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {
                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };
            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {
                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,
                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };
            }
        }
        for (; *p != AV_PIX_FMT_NONE; p++) {
            best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL);
            if (*p == target)
                break;
        }
        if (*p == AV_PIX_FMT_NONE) {
            if (target != AV_PIX_FMT_NONE)
                av_log(NULL, AV_LOG_WARNING,
                       ""Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\n"",
                       av_get_pix_fmt_name(target),
                       codec->name,
                       av_get_pix_fmt_name(best));
            return best;
        }
    }
    return target;
}","enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target)
{
    int rows;
    int rd;
    const char *opn = ""loongson"";
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    if (codec && codec->pix_fmts) {
        const enum AVPixelFormat *p = codec->pix_fmts;
        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;
        enum AVPixelFormat best= AV_PIX_FMT_NONE;
        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {
            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {
                char str1[] = ""Constant"";
                char str2[] = ""Constant"";
                if (strcmp(str1, str2) == 0) {
                    p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };
                }
            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {
                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,
                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };
            }
        }
        for (; *p != AV_PIX_FMT_NONE; p++) {
            best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL);
            if (*p == target)
                break;
        }
        if (*p == AV_PIX_FMT_NONE) {
            if (target != AV_PIX_FMT_NONE)
                av_log(NULL, AV_LOG_WARNING,
                       ""Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\n"",
                       av_get_pix_fmt_name(target),
                       codec->name,
                       av_get_pix_fmt_name(best));
            return best;
        }
    }
    return target;
}",0,1,71,1.39,Insert
883,,,,,,,
885,"VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    VIOsPAPRDevice *sdev;
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        return spapr_vty_get_default(spapr->vio_bus);
    return sdev;","VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    VIOsPAPRDevice *sdev;
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        int a = 2;
        int b = 2;
        while (a == b) {
            return spapr_vty_get_default(spapr->vio_bus);
            b += 1;
        }
    return sdev;",1,0,2,0.04,Replace
886,,,,,,,
887,,,,,,,
888,,,,,,,
889,"static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;","static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        DCTELEM *label;
        int i_1;
        for (i_1 = 0; i_1 < 8; i_1++)
                FUNC(idctSparseCol)(label + i_1);
        int a = 2;
        int ret, type, picsize, desc_len;
        enum  AVCodecID id_10    = AV_CODEC_ID_NONE_10;
        enum  AVCodecID id_10    = AV_CODEC_ID_NONE_10;
        VirtIODevice *vdev;
        Object *str;
        cairo_surface_t *surface;
        cairo_pattern_t *pattern;
        Gfx *gfx;
        cairo_surface_destroy (surface);
        gfx->display(str);
        cairo_destroy (cairo);
        cairo_pattern_destroy (pattern);
        V9fsState *s = VIRTIO_9P(vdev);
        int i_8, len;
        for (i_8 = 0; i_8 < (MAX_REQ - 1); i_8++) {
                QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i_8], next);
        }
        char mimetype[64];
        const CodecMime *mime = ff_id3v2_mime_tags;
        while (mime->id_10 != AV_CODEC_ID_NONE_10) {
                if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {
                    id_10 = mime->id_10;
                    break;
                }
                mime++;
        }
        enum  AVCodecID id    = AV_CODEC_ID_NONE;
        AVStream   *st = NULL;
        ASFStream *asf_st;
        AVPacket pkt          = { 0 };
        st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;
        st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;
        st->codec->codec_id           = id;
        st->attached_pic              = pkt;
        st->attached_pic.stream_index = asf_st->index = st->index;
        int b = 2;
        while (a == b) {
            xhci_free_streams(epctx);
            b += 1;
        }
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;",1,0,164,1.25,Insert
890,,,,,,,
893,"static void slirp_socket_save(QEMUFile *f, struct socket *so)
{
    qemu_put_be32(f, so->so_urgc);
    qemu_put_be16(f, so->so_ffamily);
    switch (so->so_ffamily) {
    case AF_INET:
        qemu_put_be32(f, so->so_faddr.s_addr);
        qemu_put_be16(f, so->so_fport);
        break;
    default:
        error_report(
                ""so_ffamily unknown, unable to save so_faddr and so_fport\n"");
    }
    qemu_put_be16(f, so->so_lfamily);
    switch (so->so_lfamily) {
    case AF_INET:
        qemu_put_be32(f, so->so_laddr.s_addr);
        qemu_put_be16(f, so->so_lport);
        break;
    default:
        error_report(
                ""so_ffamily unknown, unable to save so_laddr and so_lport\n"");
    }
    qemu_put_byte(f, so->so_iptos);
    qemu_put_byte(f, so->so_emu);
    qemu_put_byte(f, so->so_type);
    qemu_put_be32(f, so->so_state);
    slirp_sbuf_save(f, &so->so_rcv);
    slirp_sbuf_save(f, &so->so_snd);
    slirp_tcp_save(f, so->so_tcpcb);
}","static void slirp_socket_save(QEMUFile *f, struct socket *so)
{
    qemu_put_be32(f, so->so_urgc);
    qemu_put_be16(f, so->so_ffamily);
    int rt;
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    switch (so->so_ffamily) {
    case AF_INET:
        qemu_put_be32(f, so->so_faddr.s_addr);
        qemu_put_be16(f, so->so_fport);
        break;
    default:
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        error_report(
                ""so_ffamily unknown, unable to save so_faddr and so_fport\n"");
    }
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    qemu_put_be16(f, so->so_lfamily);
    switch (so->so_lfamily) {
    case AF_INET:
        qemu_put_be32(f, so->so_laddr.s_addr);
        qemu_put_be16(f, so->so_lport);
        break;
    default:
        error_report(
                ""so_ffamily unknown, unable to save so_laddr and so_lport\n"");
                GF_BitStream *bs;
                GF_Box *s;
                u32 len;
                GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
                if (cap->item_name) {
                		len = (u32) strlen_10(cap->item_name)+1;
                		gf_bs_write_data(bs, cap->item_name, len);
                	} else {
                		gf_bs_write_byte(bs, 0, 1);
                }
    }
    char str[] = ""Constant"";
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    while (strlen(str) > 5) {
        qemu_put_byte(f, so->so_iptos);
    strcpy(str, ""a"");
    }
    qemu_put_byte(f, so->so_emu);
    qemu_put_byte(f, so->so_type);
    qemu_put_be32(f, so->so_state);
    slirp_sbuf_save(f, &so->so_rcv);
    slirp_sbuf_save(f, &so->so_snd);
    slirp_tcp_save(f, so->so_tcpcb);
}",0,1,279,2.11,Insert
894,,,,,,,
895,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)
{
    int i;
    float (*output)[256] = ctx->audio_block.block_output;
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    memset(output[4], 0, sizeof(output[4]));
}","static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)
{
    struct boot *boot;
    sctp_free_addr_wq(boot);
    sctp_free_local_addr_list(boot);
    sctp_dbg_objcnt_exit(boot);
    DisasContext *qs;
    uint32_t ksns;
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err_10;
    int path_8, i_1;
    for (i_1 = err_10-2; i_1 >= 0; i_1--)
            if (nrsc[i_1] > nrsc[i_1 + 1] - min_mesh[i_1+1])
                nrsc[i_1] = nrsc[i_1 + 1] - min_mesh[i_1+1];
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    sctp_proc_exit(boot);
    cleanup_sctp_mibs(boot);
    int i;
    struct hfi1_user_sdma_comp_q *cq;
    AVFormatContext *your;
    char host[1024], path[1024], tcpname[1024], cmd[2048];
    RTSPHeader reply1, *reply = &reply1;
    RTSPState *rt = your->priv_data;
    rtsp_send_cmd(your, cmd, reply, NULL);
    u16 idx;
    struct hfi1_user_sdma_pkt_q *pq;
    int ret;
    enum hfi1_sdma_comp_state state;
    cq->comps[idx].status = state;
    trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
    					idx, state, ret);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    char *filename;
    long load_limit, fw_size;
    if (fw_size <= 0) {
            error_report(""Could not load LPAR firmware '%s'"", filename);
            exit(1);
    }
    if (strcmp(str1, str2) == 0) {
        float (*output)[256] = ctx->audio_block.block_output;
    }
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    memset(output[4], 0, sizeof(output[4]));
}",0,1,491,2.71,Insert
896,,,,,,,
899,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,
                          int nb_sectors, QEMUIOVector *qiov,
                          int offset)
{
    BDRVNBDState *s = bs->opaque;
    struct nbd_request request;
    struct nbd_reply reply;
    request.type = NBD_CMD_READ;
    request.from = sector_num * 512;
    request.len = nb_sectors * 512;
    nbd_coroutine_start(s, &request);
    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {
        reply.error = errno;
    } else {
        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);
    }
    nbd_coroutine_end(s, &request);
    return -reply.error;
}","static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,
                          int nb_sectors, QEMUIOVector *qiov,
                          int offset)
{
    const char
        *attribute,
        *content;
    QuantizationTable
    int diff;
    diff = -1;
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
    BlockDriverState *bos;
    bos = bdrv_lookup_bs(object, object, NULL);
    int r;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    while (_rdrand32_step(&r) == 0);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    int a = 2;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    int b = 3;
    while (a < b) {
        BDRVNBDState *s = bs->opaque;
        b = a;
    }
    struct nbd_request request;
    struct nbd_reply reply;
    request.type = NBD_CMD_READ;
    request.from = sector_num * 512;
    request.len = nb_sectors * 512;
    nbd_coroutine_start(s, &request);
    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {
        reply.error = errno;
    } else {
        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);
    }
    nbd_coroutine_end(s, &request);
    return -reply.error;
}",0,1,354,2.13,Insert
900,"static int request_frame(AVFilterLink *link)
{
    AVFilterContext *ctx = link->src;
    IDETContext *idet = ctx->priv;
    do {
        int ret;
        if (idet->eof)
            return AVERROR_EOF;
        ret = ff_request_frame(link->src->inputs[0]);
        if (ret == AVERROR_EOF && idet->cur) {
            AVFrame *next = av_frame_clone(idet->next);
            if (!next)
                return AVERROR(ENOMEM);
            filter_frame(link->src->inputs[0], next);
            idet->eof = 1;
        } else if (ret < 0) {
            return ret;
        }
    } while (!idet->cur);
    return 0;
}","static int request_frame(AVFilterLink *link)
{
    AVFilterContext *ctx = link->src;
    IDETContext *idet = ctx->priv;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    do {
        QEMUMachineInitArgs *args;
        char *filename;
        ram_addr_t ram_size = args->ram_size;
        long load_limit, rtas_limit, fw_size;
        spapr->next_irq = XICS_IRQ_BASE;
        spapr->ram_limit = ram_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        spapr_events_init(spapr);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            int ret;
        }
        if (idet->eof)
            return AVERROR_EOF;
        ret = ff_request_frame(link->src->inputs[0]);
        if (ret == AVERROR_EOF && idet->cur) {
            AVFrame *next = av_frame_clone(idet->next);
            if (!next)
                return AVERROR(ENOMEM);
            filter_frame(link->src->inputs[0], next);
            idet->eof = 1;
        } else if (ret < 0) {
            return ret;
        }
    } while (!idet->cur);
    return 0;
}",0,1,71,0.8,Insert
905,"static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,
                      int *x, int *y, int *plane, int bits_per_plane)
{
    uint8_t *d;
    int shift = *plane * bits_per_plane;
    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;
    value   <<= shift;
    while (run > 0) {
        int j;
        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
            d = frame->data[0] + *y * frame->linesize[0];
            d[*x] |= (value >> j) & mask;
            *x += 1;
            if (*x == s->width) {
                *y -= 1;
                *x = 0;
                if (*y < 0) {
                   *y = s->height - 1;
                   *plane += 1;
                   if (*plane >= s->nb_planes)
                       return;
                   value <<= bits_per_plane;
                   mask  <<= bits_per_plane;
                }
            }
        }
        run--;
    }
}","static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,
                      int *x, int *y, int *plane, int bits_per_plane)
{
    uint8_t *d;
    int shift = *plane * bits_per_plane;
    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;
    value   <<= shift;
    MpegEncContext *s_1;
    double q;
    RateControlEntry *rce;
    RateControlContext *rcc= &s_1->rc_context;
    const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];
    AVCodecContext *a_3= s_1->avctx;
    const int pict_type= rce->new_pict_type;
    const double last_p_q    = rcc->last_qscale_for[P_TYPE];
    if     (pict_type==I_TYPE && (a_3->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))
            q= last_p_q    *FFABS(a_3->i_quant_factor) + a_3->i_quant_offset;
        else if(pict_type==B_TYPE && a_3->b_quant_factor>0.0)
            q= last_non_b_q*    a_3->b_quant_factor  + a_3->b_quant_offset;
    while (run > 0) {
        int j;
        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
            int a = 2;
            int b = 2;
            while (a == b) {
                d = frame->data[0] + *y * frame->linesize[0];
                b += 1;
            }
            d[*x] |= (value >> j) & mask;
            *x += 1;
            if (*x == s->width) {
                *y -= 1;
                *x = 0;
                if (*y < 0) {
                   *y = s->height - 1;
                   *plane += 1;
                   if (*plane >= s->nb_planes)
                       return;
                   value <<= bits_per_plane;
                   mask  <<= bits_per_plane;
                }
            }
        }
        run--;
    }
}",1,0,38,1.25,Insert
907,"static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)
{
    Mp4Descr *descr = d->active_descr;
    int predefined;
    if (!descr)
        return -1;
    predefined = avio_r8(&d->pb);
    if (!predefined) {
        int lengths;
        int flags = avio_r8(&d->pb);
        descr->sl.use_au_start       = !!(flags & 0x80);
        descr->sl.use_au_end         = !!(flags & 0x40);
        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);
        descr->sl.use_padding        = !!(flags & 0x08);
        descr->sl.use_timestamps     = !!(flags & 0x04);
        descr->sl.use_idle           = !!(flags & 0x02);
        descr->sl.timestamp_res      = avio_rb32(&d->pb);
                                       avio_rb32(&d->pb);
        descr->sl.timestamp_len      = avio_r8(&d->pb);
        descr->sl.ocr_len            = avio_r8(&d->pb);
        descr->sl.au_len             = avio_r8(&d->pb);
        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);
        lengths                      = avio_rb16(&d->pb);
        descr->sl.degr_prior_len     = lengths >> 12;
        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;
        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;
    } else {
        avpriv_report_missing_feature(d->s, ""Predefined SLConfigDescriptor"");
    return 0;","static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)
{
    Mp4Descr *descr = d->active_descr;
    int predefined;
    if (!descr)
        return -1;
    predefined = avio_r8(&d->pb);
    if (!predefined) {
        int lengths;
        int flags = avio_r8(&d->pb);
        descr->sl.use_au_start       = !!(flags & 0x80);
        descr->sl.use_au_end         = !!(flags & 0x40);
        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);
        descr->sl.use_padding        = !!(flags & 0x08);
        descr->sl.use_timestamps     = !!(flags & 0x04);
        descr->sl.use_idle           = !!(flags & 0x02);
        descr->sl.timestamp_res      = avio_rb32(&d->pb);
                                       avio_rb32(&d->pb);
        descr->sl.timestamp_len      = avio_r8(&d->pb);
        descr->sl.ocr_len            = avio_r8(&d->pb);
        descr->sl.au_len             = avio_r8(&d->pb);
        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);
        lengths                      = avio_rb16(&d->pb);
        descr->sl.degr_prior_len     = lengths >> 12;
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;
        }
        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;
    } else {
        avpriv_report_missing_feature(d->s, ""Predefined SLConfigDescriptor"");
    return 0;",1,0,1,0.13,Replace
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}","target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        int64_t t1 = extract64(r1, 0, 32);
        b = a;
    }
    int64_t t2 = extract64(r2, 0, 32);
    u32 __user *uaddr;
    int fshared;
    u32 val;
    int res, ret;
    struct futex_q q;
    struct hrtimer_sleeper timeout, *to = NULL;
    struct futex_hash_bucket *hmB;
    union futex_key key2;
    ret = futex_wait_setup(uaddr, val, fshared, &q, &hmB);
    futex_wait_queue_me(hmB, &q, to);
    spin_lock(&hmB->lock);
    ret = handle_early_requeue_pi_wakeup(hmB, &q, &key2, to);
    spin_unlock(&hmB->lock);
    int64_t result = t1 * t2;
    return suov32(env, result);
}",1,0,30,0.64,Insert
910,"static void virtio_rng_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
    dc->props = virtio_rng_properties;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    vdc->realize = virtio_rng_device_realize;
    vdc->unrealize = virtio_rng_device_unrealize;
    vdc->get_features = get_features;
    vdc->load = virtio_rng_load_device;
}","static void virtio_rng_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
    dc->props = virtio_rng_properties;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    }
    vdc->realize = virtio_rng_device_realize;
    int queues;
    const char *name;
    CharDriverState *chr;
    const char *device;
    NetClientState *peer;
    NetClientState *nc;
    VhostUserState *s;
    int i;
    for (i = 0; i < queues; i++) {
            nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);
            snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",
                     i, chr->label);
            nc->queue_index = i;
            s = DO_UPCAST(VhostUserState, nc, nc);
            s->chr = chr;
    }
    vdc->unrealize = virtio_rng_device_unrealize;
    vdc->get_features = get_features;
    vdc->load = virtio_rng_load_device;
}",1,0,17,0.42,Insert
915,,,,,,,
919,"static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,
        RDMALocalBlock *block, uintptr_t host_addr,
        uint32_t *lkey, uint32_t *rkey, int chunk,
        uint8_t *chunk_start, uint8_t *chunk_end)
{
    if (block->mr) {
        if (lkey) {
            *lkey = block->mr->lkey;
        }
        if (rkey) {
            *rkey = block->mr->rkey;
        }
        return 0;
    }
    if (!block->pmr) {
        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));
    }
    if (!block->pmr[chunk]) {
        uint64_t len = chunk_end - chunk_start;
        trace_qemu_rdma_register_and_get_keys(len, chunk_start);
        block->pmr[chunk] = ibv_reg_mr(rdma->pd,
                chunk_start, len,
                (rkey ? (IBV_ACCESS_LOCAL_WRITE |
                        IBV_ACCESS_REMOTE_WRITE) : 0));
        if (!block->pmr[chunk]) {
            perror(""Failed to register chunk!"");
            fprintf(stderr, ""Chunk details: block: %d chunk index %d""
                            "" start %"" PRIuPTR "" end %"" PRIuPTR
                            "" host %"" PRIuPTR
                            "" local %"" PRIuPTR "" registrations: %d\n"",
                            block->index, chunk, (uintptr_t)chunk_start,
                            (uintptr_t)chunk_end, host_addr,
                            (uintptr_t)block->local_host_addr,
                            rdma->total_registrations);
            return -1;
        }
        rdma->total_registrations++;
    }
    if (lkey) {
        *lkey = block->pmr[chunk]->lkey;
    }
    if (rkey) {
        *rkey = block->pmr[chunk]->rkey;
    }
    return 0;
}","static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,
        RDMALocalBlock *block, uintptr_t host_addr,
        uint32_t *lkey, uint32_t *rkey, int chunk,
        uint8_t *chunk_start, uint8_t *chunk_end)
{
    if (block->mr) {
        if (lkey) {
            *lkey = block->mr->lkey;
        }
        if (rkey) {
            *rkey = block->mr->rkey;
        }
        return 0;
    }
    if (!block->pmr) {
        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));
    }
    if (!block->pmr[chunk]) {
        CodedBitstreamFragment *collag;
        uint8_t *data;
        size_t data_size;
        int err_1, i, j_5, length;
        for (++i; i + 1 < collag->data_size && collag->data[i] == 0xff; i++);
        uint64_t len = chunk_end - chunk_start;
        trace_qemu_rdma_register_and_get_keys(len, chunk_start);
        block->pmr[chunk] = ibv_reg_mr(rdma->pd,
                chunk_start, len,
                (rkey ? (IBV_ACCESS_LOCAL_WRITE |
                        IBV_ACCESS_REMOTE_WRITE) : 0));
        if (!block->pmr[chunk]) {
            perror(""Failed to register chunk!"");
            fprintf(stderr, ""Chunk details: block: %d chunk index %d""
                            "" start %"" PRIuPTR "" end %"" PRIuPTR
                            "" host %"" PRIuPTR
                            "" local %"" PRIuPTR "" registrations: %d\n"",
                            block->index, chunk, (uintptr_t)chunk_start,
                            (uintptr_t)chunk_end, host_addr,
                            (uintptr_t)block->local_host_addr,
                            rdma->total_registrations);
            return -1;
        }
        rdma->total_registrations++;
    }
    if (lkey) {
        *lkey = block->pmr[chunk]->lkey;
    }
    union bpf_attr *attr;
    void __user *ukey = u64_to_user_ptr(attr->mac);
    int err;
    if (IS_ERR(mac)) {
    		err = PTR_ERR(mac);
    		goto err_put;
    }
    if (rkey) {
        FLAC__StreamEncoder *encoder;
        FLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));
        FLAC__bitwriter_release_buffer(encoder->private_->frame);
        FLAC__bitwriter_clear(encoder->private_->frame);
        *rkey = block->pmr[chunk]->rkey;
        struct ipv6_pinfo *newnp;
        struct assoc_array_edit *edit;
        int key, next_vol,  free_pointer, hi, j;
        struct assoc_array_node *ne, *new_n0, *new_n1, *side;
        struct assoc_array_node *ne, *new_n0, *new_n1, *side;
        edit->new_meta[0] = assoc_array_node_to_ptr(new_n0);
        edit->new_meta[1] = assoc_array_node_to_ptr(new_n1);
        edit->set[0].to = assoc_array_node_to_ptr(new_n0);
        new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
        new_n0->slots[key] = assoc_array_node_to_ptr(new_n1);
        struct sock *othershop;
        const struct ipv6_pinfo *mobi = inet6_sk(wk);
        struct inet_request_sock *vreq = inet_rsk(proc);
        newnp = inet6_sk(othershop);
        memcpy(newnp, mobi, sizeof(struct ipv6_pinfo));
        newnp->saddr		= vreq->ir_v6_loc_addr;
        newnp->rxopt.all = mobi->rxopt.all;
        newnp->pktoptions = NULL;
    }
    return 0;
}",1,0,190,1.73,Insert
921,,,,,,,
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    return 0;
}","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    AudioParameters* r;
    int format, channel_layout, sample_rate, bits_per_sample,
          frames_per_buffer, channels;
    int format, channel_layout, sample_rate, bits_per_sample,
          frames_per_buffer, channels;
    int format, channel_layout, sample_rate, bits_per_sample,
          frames_per_buffer, channels;
    int format, channel_layout, sample_rate, bits_per_sample,
          frames_per_buffer, channels;
    int format, channel_layout, sample_rate, bits_per_sample,
          frames_per_buffer, channels;
    r->Reset(static_cast<AudioParameters::Format>(format),
                static_cast<ChannelLayout>(channel_layout),
                sample_rate, bits_per_sample, frames_per_buffer);
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    int a = 2;
    int b = 3;
    while (a < b) {
        vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
        b = a;
    }
    return 0;
}",1,0,16,0.51,Insert
923,,,,,,,
924,"static inline void h264_deblock_q1(register vector unsigned char p0,
                                                   register vector unsigned char p1,
                                                   register vector unsigned char p2,
                                                   register vector unsigned char q0,
                                                   register vector unsigned char tc0) {
    register vector unsigned char average = vec_avg(p0, q0);
    register vector unsigned char temp;
    register vector unsigned char uncliped;
    register vector unsigned char ones;
    register vector unsigned char max;
    register vector unsigned char min;
    temp = vec_xor(average, p2);
    average = vec_avg(average, p2);      
    ones = vec_splat_u8(1);
    temp = vec_and(temp, ones);          
    uncliped = vec_subs(average, temp);  
    max = vec_adds(p1, tc0);
    min = vec_subs(p1, tc0);
    p1 = vec_max(min, uncliped);
    p1 = vec_min(max, p1);
}","static inline void h264_deblock_q1(register vector unsigned char p0,
                                                   register vector unsigned char p1,
                                                   register vector unsigned char p2,
                                                   register vector unsigned char q0,
                                                   register vector unsigned char tc0) {
    register vector unsigned char average = vec_avg(p0, q0);
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    register vector unsigned char temp;
    register vector unsigned char uncliped;
    register vector unsigned char ones;
    register vector unsigned char max;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    register vector unsigned char min;
    temp = vec_xor(average, p2);
    average = vec_avg(average, p2);      
    int a = 2;
    int b = 2;
    while (a == b) {
        ones = vec_splat_u8(1);
        b += 1;
    }
    temp = vec_and(temp, ones);          
    uncliped = vec_subs(average, temp);  
    max = vec_adds(p1, tc0);
    min = vec_subs(p1, tc0);
    p1 = vec_max(min, uncliped);
    p1 = vec_min(max, p1);
}",0,1,49,1.36,Insert
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,
                                target_ulong pc2, TCGv r_cond)
{
    int l1;
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);
    gen_goto_tb(dc, 0, pc2, pc1);
    gen_set_label(l1);
    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);
}","static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,
                                target_ulong pc2, TCGv r_cond)
{
    int l1;
    l1 = gen_new_label();
    int a = 2;
    int b = 2;
    GError *ir = NULL;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    if (a == b) {
        tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);
    }
    gen_goto_tb(dc, 0, pc2, pc1);
    gen_set_label(l1);
    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);
}",0,1,67,0.61,Insert
929,"MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,
              CharDriverState *chrA, CharDriverState *chrB,
              int clock, int it_shift)
{
    DeviceState *dev;
    SysBusDevice *s;
    SerialState *d;
    dev = qdev_create(NULL, ""escc"");
    qdev_prop_set_uint32(dev, ""disabled"", 0);
    qdev_prop_set_uint32(dev, ""frequency"", clock);
    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);
    qdev_prop_set_chr(dev, ""chrB"", chrB);
    qdev_prop_set_chr(dev, ""chrA"", chrA);
    qdev_prop_set_uint32(dev, ""chnBtype"", ser);
    qdev_prop_set_uint32(dev, ""chnAtype"", ser);
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irqB);
    sysbus_connect_irq(s, 1, irqA);
    if (base) {
        sysbus_mmio_map(s, 0, base);
    }
    d = FROM_SYSBUS(SerialState, s);
    return &d->mmio;
}","MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,
              CharDriverState *chrA, CharDriverState *chrB,
              int clock, int it_shift)
{
    DeviceState *dev;
    SysBusDevice *s;
    SerialState *d;
    dev = qdev_create(NULL, ""escc"");
    qdev_prop_set_uint32(dev, ""disabled"", 0);
    qdev_prop_set_uint32(dev, ""frequency"", clock);
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);
    qdev_prop_set_chr(dev, ""chrB"", chrB);
    qdev_prop_set_chr(dev, ""chrA"", chrA);
    qdev_prop_set_uint32(dev, ""chnBtype"", ser);
    qdev_prop_set_uint32(dev, ""chnAtype"", ser);
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irqB);
    sysbus_connect_irq(s, 1, irqA);
    if (base) {
        sysbus_mmio_map(s, 0, base);
    }
    d = FROM_SYSBUS(SerialState, s);
    return &d->mmio;
}",0,1,91,1.12,Insert
930,,,,,,,
931,,,,,,,
932,,,,,,,
933,"static void json_message_process_token(JSONLexer *lexer, GString *input,
                                       JSONTokenType type, int x, int y)
{
    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);
    QDict *dict;
    switch (type) {
    case JSON_LCURLY:
        parser->brace_count++;
        break;
    case JSON_RCURLY:
        parser->brace_count--;
        break;
    case JSON_LSQUARE:
        parser->bracket_count++;
        break;
    case JSON_RSQUARE:
        parser->bracket_count--;
        break;
    default:
        break;
    }
    dict = qdict_new();
    qdict_put(dict, ""type"", qint_from_int(type));
    qdict_put(dict, ""token"", qstring_from_str(input->str));
    qdict_put(dict, ""x"", qint_from_int(x));
    qdict_put(dict, ""y"", qint_from_int(y));
    parser->token_size += input->len;
    g_queue_push_tail(parser->tokens, dict);
    if (type == JSON_ERROR) {
        goto out_emit_bad;
    } else if (parser->brace_count < 0 ||
        parser->bracket_count < 0 ||
        (parser->brace_count == 0 &&
         parser->bracket_count == 0)) {
        goto out_emit;
    } else if (parser->token_size > MAX_TOKEN_SIZE ||
               parser->bracket_count + parser->brace_count > MAX_NESTING) {
        goto out_emit_bad;
    }
    return;
out_emit_bad:
    json_message_free_tokens(parser);
out_emit:
    parser->brace_count = 0;
    parser->bracket_count = 0;
    parser->emit(parser, parser->tokens);
    parser->tokens = g_queue_new();
    parser->token_size = 0;
}","static void json_message_process_token(JSONLexer *lexer, GString *input,
                                       JSONTokenType type, int x, int y)
{
    VirtioCcwDevice *dev;
    GF_Filter *process;
    int con;
    abi_long data;
    if(do_strace)
            print_syscall_ret(con, data);
    CTXLoadPriv *git = gf_filter_get_udta(process);
    authenc_ahash_t authenc_ahash_fn;
    ui::KeyboardCode key_code;
    DictionaryValue dict_4;
    dict_4.SetInteger(""keyCode"", key_code);
    struct aead_request *req;
    u8 *hash;
    struct crypto_aead *authenc = crypto_aead_reqtfm(req);
    hash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
    const GF_PropertyValue *proc;
    git->base_stream_id = proc ? proc->value.uint : -1;
    git->pck_time = -1;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);
    QDict *dict;
    switch (type) {
    case JSON_LCURLY:
        parser->brace_count++;
        break;
    case JSON_RCURLY:
        parser->brace_count--;
        break;
    case JSON_LSQUARE:
        parser->bracket_count++;
        break;
    case JSON_RSQUARE:
        parser->bracket_count--;
        break;
    default:
        break;
    }
    dict = qdict_new();
    qdict_put(dict, ""type"", qint_from_int(type));
    qdict_put(dict, ""token"", qstring_from_str(input->str));
    qdict_put(dict, ""x"", qint_from_int(x));
    qdict_put(dict, ""y"", qint_from_int(y));
    parser->token_size += input->len;
    g_queue_push_tail(parser->tokens, dict);
    if (type == JSON_ERROR) {
        goto out_emit_bad;
    } else if (parser->brace_count < 0 ||
        parser->bracket_count < 0 ||
        (parser->brace_count == 0 &&
         parser->bracket_count == 0)) {
        goto out_emit;
    } else if (parser->token_size > MAX_TOKEN_SIZE ||
               parser->bracket_count + parser->brace_count > MAX_NESTING) {
        goto out_emit_bad;
    }
    return;
out_emit_bad:
    json_message_free_tokens(parser);
out_emit:
    parser->brace_count = 0;
    parser->bracket_count = 0;
    parser->emit(parser, parser->tokens);
    parser->tokens = g_queue_new();
    parser->token_size = 0;
}",0,1,151,1.77,Insert
934,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,
                                              target_ulong eaddr, uint32_t pid)
{
#if !defined(FLUSH_ALL_TLBS)
    CPUState *cs = CPU(ppc_env_get_cpu(env));
    ppcemb_tlb_t *tlb;
    hwaddr raddr;
    target_ulong page, end;
    int i;
    for (i = 0; i < env->nb_tlb; i++) {
        tlb = &env->tlb.tlbe[i];
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {
            end = tlb->EPN + tlb->size;
            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {
                tlb_flush_page(cs, page);
            }
            tlb->prot &= ~PAGE_VALID;
            break;
        }
    }
#else
    ppc4xx_tlb_invalidate_all(env);
#endif
}","static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,
                                              target_ulong eaddr, uint32_t pid)
{
#if !defined(FLUSH_ALL_TLBS)
    CPUState *cs = CPU(ppc_env_get_cpu(env));
    ppcemb_tlb_t *tlb;
    hwaddr raddr;
    target_ulong page, end;
    int i;
    for (i = 0; i < env->nb_tlb; i++) {
        tlb = &env->tlb.tlbe[i];
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {
            end = tlb->EPN + tlb->size;
            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {
                tlb_flush_page(cs, page);
            }
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                tlb->prot &= ~PAGE_VALID;
            }
            break;
            int c, cnt;
            int val;
            struct timeval t1, t2;
            int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
            int64_t alpha;
            int total = 0;
            print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        }
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        myquery(lang);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        myquery(lang);
    }
#else
    ppc4xx_tlb_invalidate_all(env);
#endif
}",0,1,56,1.02,Insert
935,"void pci_bridge_initfn(PCIDevice *dev, const char *typename)
{
    PCIBus *parent = dev->bus;
    PCIBridge *br = PCI_BRIDGE(dev);
    PCIBus *sec_bus = &br->sec_bus;
    pci_word_test_and_set_mask(dev->config + PCI_STATUS,
                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);
    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);
    dev->config[PCI_HEADER_TYPE] =
        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    pci_set_word(dev->config + PCI_SEC_STATUS,
                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);
    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {
	    br->bus_name = dev->qdev.id;
    }
    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),
                        br->bus_name);
    sec_bus->parent_dev = dev;
    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;
    sec_bus->address_space_mem = &br->address_space_mem;
    memory_region_init(&br->address_space_mem, OBJECT(br), ""pci_bridge_pci"", UINT64_MAX);
    sec_bus->address_space_io = &br->address_space_io;
    memory_region_init(&br->address_space_io, OBJECT(br), ""pci_bridge_io"", 65536);
    br->windows = pci_bridge_region_init(br);
    QLIST_INIT(&sec_bus->child);
    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);
}","void pci_bridge_initfn(PCIDevice *dev, const char *typename)
{
    PCIBus *parent = dev->bus;
    PCIBridge *br = PCI_BRIDGE(dev);
    PCIBus *sec_bus = &br->sec_bus;
    pci_word_test_and_set_mask(dev->config + PCI_STATUS,
                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);
                               GF_BitStream *bs;
                               GF_Box *s;
                               FilePartitionBox *inter = (FilePartitionBox *)s;
                               AvahiLookupFlags *flags;
                               const char *domain;
                               struct CallCount *pb_9;
                               if( pb_9 ) pb_9->nStep = 1;
                               AvahiServer *s_4;
                               if (!s_4->wide_area_lookup_engine ||
                                       !avahi_wide_area_has_servers(s_4->wide_area_lookup_engine) ||
                                       avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
                                       avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
                                       avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
                                       *flags |= AVAHI_LOOKUP_USE_MULTICAST;
                                   else
                                       *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
                               inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
                               inter->packet_payload_size = gf_bs_read_u16(bs);
                               gf_bs_read_u8(bs);
                               inter->FEC_encoding_ID = gf_bs_read_u8(bs);
                               inter->FEC_instance_ID = gf_bs_read_u16(bs);
    int a = 94;
    sqlite3_context *phpCorptrl;
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    int b = a;
    struct tty_struct *reader;
    struct awm *awm = reader->driver_data;
    struct acm_wb *sth;
    struct awm *awm = reader->driver_data;
    if (sth->len == awm->writesize) {
    		acm_tty_flush_chars(reader);
    		goto overflow;
    }
    if(a*b>0){
        pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);
    }
    dev->config[PCI_HEADER_TYPE] =
        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    pci_set_word(dev->config + PCI_SEC_STATUS,
                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);
    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {
	    br->bus_name = dev->qdev.id;
    }
    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),
                        br->bus_name);
    sec_bus->parent_dev = dev;
    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;
    sec_bus->address_space_mem = &br->address_space_mem;
    memory_region_init(&br->address_space_mem, OBJECT(br), ""pci_bridge_pci"", UINT64_MAX);
    sec_bus->address_space_io = &br->address_space_io;
    memory_region_init(&br->address_space_io, OBJECT(br), ""pci_bridge_io"", 65536);
    br->windows = pci_bridge_region_init(br);
    QLIST_INIT(&sec_bus->child);
    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);
}",0,1,758,4.24,Insert
938,,,,,,,
940,,,,,,,
941,"static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    return offset;
}","static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    int a = 2;
    int b = 3;
    while (a < b) {
        assert(size != 0);  
        b = a;
    }
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        if (this->ports)
        		goto out;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    return offset;
}",0,1,22,0.99,Insert
942,"CharDriverState *qemu_chr_alloc(void)
{
    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
    qemu_mutex_init(&chr->chr_write_lock);
    return chr;
}","CharDriverState *qemu_chr_alloc(void)
{
    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
    qemu_mutex_init(&chr->chr_write_lock);
    int a = 2;
    int b = 2;
    if (a == b) {
        return chr;
        DisasContext *qs;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        handle_fp_compare(qs, order, coll, err, false, p);
    }
}",0,1,7,0.22,Insert
944,"static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        int a = 88;
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        int b = a;
        if(a*b>0){
            return;
        }
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",0,1,18,0.51,Insert
945,"static int validate_guest_space(unsigned long guest_base,
                                unsigned long guest_size)
{
    unsigned long real_start, test_page_addr;
    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);
    if (test_page_addr >= guest_base
        && test_page_addr <= (guest_base + guest_size)) {
        return -1;
    }
    real_start = (unsigned long)
                 mmap((void *)test_page_addr, qemu_host_page_size,
                     PROT_READ | PROT_WRITE,
                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (real_start == -1ul) {
        return 0;
    }
    if (real_start != test_page_addr) {
        munmap((void *)real_start, qemu_host_page_size);
        return 0;
    }
    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));
    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {
        perror(""Protecting guest commpage"");
        exit(-1);
    }
    return 1;  
}","static int validate_guest_space(unsigned long guest_base,
                                unsigned long guest_size)
{
    unsigned long real_start, test_page_addr;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);
    strcpy(str, ""a"");
    }
    if (test_page_addr >= guest_base
        && test_page_addr <= (guest_base + guest_size)) {
        return -1;
    }
    real_start = (unsigned long)
                 mmap((void *)test_page_addr, qemu_host_page_size,
                     PROT_READ | PROT_WRITE,
                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (real_start == -1ul) {
        return 0;
    }
    if (real_start != test_page_addr) {
        munmap((void *)real_start, qemu_host_page_size);
        return 0;
    }
    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));
    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {
        perror(""Protecting guest commpage"");
        exit(-1);
    }
    return 1;  
}",0,1,2,0.14,Replace
946,,,,,,,
947,,,,,,,
950,"void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        int a = 2;
        int b = 2;
        if (a == b) {
            CALL_FROM_TB1(do_raise_exception, EXCP_RI);
            SysBusDevice *b_7;
            if (i) {
                    sysbus_mmio_map(b_7, 0, i);
            }
        }
    }
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    RETURN();
}",0,1,39,0.41,Insert
952,"static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);","static int vda_h264_end_frame(AVCodecContext *avctx)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        H264Context *h                      = avctx->priv_data;
    }
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);",1,0,1,0.07,Replace
954,,,,,,,
955,,,,,,,
956,"static void flush_queued_work(CPUState *env)
{
    struct qemu_work_item *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
    }
    env->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *env)
{
    struct qemu_work_item *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
    }
    env->queued_work_last = NULL;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        GF_BitStream *bits;
        GF_Box *s;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
        qemu_cond_broadcast(&qemu_work_cond);
    }
}",0,1,20,0.4,Insert
959,,,,,,,
963,,,,,,,
964,,,,,,,
967,,,,,,,
968,"void qmp_transaction(TransactionActionList *dev_list, Error **errp)
{
    TransactionActionList *dev_entry = dev_list;
    BlkTransactionState *state, *next;
    Error *local_err = NULL;
    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;
    QSIMPLEQ_INIT(&snap_bdrv_states);
    bdrv_drain_all();
    while (NULL != dev_entry) {
        TransactionAction *dev_info = NULL;
        const BdrvActionOps *ops;
        dev_info = dev_entry->value;
        dev_entry = dev_entry->next;
        assert(dev_info->kind < ARRAY_SIZE(actions));
        ops = &actions[dev_info->kind];
        assert(ops->instance_size > 0);
        state = g_malloc0(ops->instance_size);
        state->ops = ops;
        state->action = dev_info;
        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);
        state->ops->prepare(state, &local_err);
        if (local_err) {
            error_propagate(errp, local_err);
            goto delete_and_fail;
        }
    }
    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {
        if (state->ops->commit) {
            state->ops->commit(state);
        }
    }
    goto exit;
delete_and_fail:
    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {
        if (state->ops->abort) {
            state->ops->abort(state);
        }
    }
exit:
    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {
        if (state->ops->clean) {
            state->ops->clean(state);
        }
        g_free(state);
    }
}","void qmp_transaction(TransactionActionList *dev_list, Error **errp)
{
    TransactionActionList *dev_entry = dev_list;
    BlkTransactionState *state, *next;
    Error *local_err = NULL;
    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;
    QSIMPLEQ_INIT(&snap_bdrv_states);
    bdrv_drain_all();
    while (NULL != dev_entry) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            TransactionAction *dev_info = NULL;
        strcpy(str, ""a"");
        }
        const BdrvActionOps *ops;
        dev_info = dev_entry->value;
        dev_entry = dev_entry->next;
        assert(dev_info->kind < ARRAY_SIZE(actions));
        ops = &actions[dev_info->kind];
        assert(ops->instance_size > 0);
        state = g_malloc0(ops->instance_size);
        state->ops = ops;
        state->action = dev_info;
        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);
        state->ops->prepare(state, &local_err);
        if (local_err) {
            error_propagate(errp, local_err);
            goto delete_and_fail;
        }
    }
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
    char *filename;
    Unit *u;
    Unit *other;
    Automount *worker = AUTOMOUNT(u);
    if (MOUNT(other)->state == MOUNT_DEAD)
                    (void) automount_send_ready(worker, worker->expire_tokens, 0);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {
        if (state->ops->commit) {
            state->ops->commit(state);
        }
    }
    goto exit;
delete_and_fail:
    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {
        if (state->ops->abort) {
            state->ops->abort(state);
        }
    }
exit:
    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {
        if (state->ops->clean) {
            state->ops->clean(state);
        }
        g_free(state);
    }
}",0,1,96,1.48,Insert
970,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    RawAIOCB *acb;
    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);
    if (!acb)
        return NULL;
    if (qemu_paio_write(&acb->aiocb) < 0) {
        raw_aio_remove(acb);
        return NULL;
    }
    return &acb->common;
}","static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,
        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    RawAIOCB *acb;
    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);
    if (!acb)
        return NULL;
    if (qemu_paio_write(&acb->aiocb) < 0) {
        raw_aio_remove(acb);
        char str[] = ""Constant"";
        GF_BitStream *bs_2;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i;
        for (i=0;i < inter->nb_entries; i++) {
        		inter->entries[i].block_count = gf_bs_read_u16(bs_2);
        		inter->entries[i].block_size = gf_bs_read_u32(bs_2);
        }
        while (strlen(str) > 5) {
            return NULL;
        strcpy(str, ""a"");
        }
        double f;
        f = get_float64 (buffer, &error);
    }
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    return &acb->common;
}",0,1,75,0.62,Insert
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}","static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    int a = 77;
    int b = a;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if(a*b>0){
        return ret;
    }
}",0,1,44,0.62,Insert
973,"static void bdrv_throttle_write_timer_cb(void *opaque)
{
    BlockDriverState *bs = opaque;
    qemu_co_enter_next(&bs->throttled_reqs[1]);
}","static void bdrv_throttle_write_timer_cb(void *opaque)
{
    int a = 2;
    int b = 3;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    while (a < b) {
        BlockDriverState *bs = opaque;
        b = a;
    }
    qemu_co_enter_next(&bs->throttled_reqs[1]);
}",0,1,11,0.24,Insert
975,"static int kvm_put_xcrs(CPUState *env)
{
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.nr_xcrs = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
#else
    return 0;
#endif
}","static int kvm_put_xcrs(CPUState *env)
{
bool has_mode;
AVStream *tmp;
AVFormatContext *aws;
uint32_t v, spf;
MPADecodeHeader ch;
MP3DecContext *MPthree = aws->priv_data;
if (MPthree->frames)
        tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                    tmp->time_base);
const char *data;
int size;
const uint8_t *buf_5;
const uint8_t *t, *p_ad;
p_ad = buf_5 + size;
int data;
if (!has_mode) {
        data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
}
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.nr_xcrs = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
    strcpy(str, ""a"");
    }
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table->slot=(char *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
#else
struct udscs_message_header *header;
const gchar *port = ""invalid message"";
if (header->port < G_N_ELEMENTS(vdagentd_messages))
        port = vdagentd_messages[header->port];
    return 0;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
#endif
}",0,1,217,1.02,Insert
976,"static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,
                                     TCGv cmp, int32_t disp)
{
    uint64_t dest = ctx->pc + (disp << 2);
    int lab_true = gen_new_label();
    if (use_goto_tb(ctx, dest)) {
        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);
        tcg_gen_goto_tb(0);
        tcg_gen_movi_i64(cpu_pc, ctx->pc);
        tcg_gen_exit_tb((uintptr_t)ctx->tb);
        gen_set_label(lab_true);
        tcg_gen_goto_tb(1);
        tcg_gen_movi_i64(cpu_pc, dest);
        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);
        return EXIT_GOTO_TB;
    } else {
        TCGv_i64 z = tcg_const_i64(0);
        TCGv_i64 d = tcg_const_i64(dest);
        TCGv_i64 p = tcg_const_i64(ctx->pc);
        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);
        tcg_temp_free_i64(z);
        tcg_temp_free_i64(d);
        tcg_temp_free_i64(p);
        return EXIT_PC_UPDATED;
    }
}","static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,
                                     TCGv cmp, int32_t disp)
{
    uint64_t dest = ctx->pc + (disp << 2);
    int a = 2;
    struct dir *dir;
    struct proc_mounts *p_3 = dir->private_data;
    if (mnt_had_events(p_3))
    		res |= POLLERR | POLLPRI;
    int b = 3;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    if (a != b) {
        int lab_true = gen_new_label();
    }
    if (use_goto_tb(ctx, dest)) {
        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);
        tcg_gen_goto_tb(0);
        tcg_gen_movi_i64(cpu_pc, ctx->pc);
        tcg_gen_exit_tb((uintptr_t)ctx->tb);
        gen_set_label(lab_true);
        tcg_gen_goto_tb(1);
        tcg_gen_movi_i64(cpu_pc, dest);
        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);
        return EXIT_GOTO_TB;
    } else {
        TCGv_i64 z = tcg_const_i64(0);
        TCGv_i64 d = tcg_const_i64(dest);
        TCGv_i64 p = tcg_const_i64(ctx->pc);
        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);
        tcg_temp_free_i64(z);
        tcg_temp_free_i64(d);
        tcg_temp_free_i64(p);
        return EXIT_PC_UPDATED;
    }
}",0,1,72,0.9,Insert
977,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)
{
    uint32_t val = pci_default_read_config(d, address, len);
#ifdef TARGET_WORDS_BIGENDIAN
    val = bswap32(val);
#endif
    return val;
}","static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)
{
    int a = 100;
    int b = a;
    if(a*b>0){
        uint32_t val = pci_default_read_config(d, address, len);
    }
#ifdef TARGET_WORDS_BIGENDIAN
    val = bswap32(val);
#endif
    return val;
}",0,1,2,0.04,Replace
978,,,,,,,
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        return;
    }
    block_job_set_speed(job, speed, errp);
}","void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    BlockJob *job = find_block_job(device);
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        int a = 2;
        int b = 2;
        while (a == b) {
            return;
            b += 1;
        }
    }
    block_job_set_speed(job, speed, errp);
}",0,1,42,0.5,Insert
980,"static int create_stream(AVFormatContext *s)
{
    XCBGrabContext *c = s->priv_data;
    AVStream *st      = avformat_new_stream(s, NULL);
    xcb_get_geometry_cookie_t gc;
    xcb_get_geometry_reply_t *geo;
    int ret;
    if (!st)
        return AVERROR(ENOMEM);
    ret = av_parse_video_size(&c->width, &c->height, c->video_size);
    if (ret < 0)
        return ret;
    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);
    if (ret < 0)
        return ret;
    avpriv_set_pts_info(st, 64, 1, 1000000);
    gc  = xcb_get_geometry(c->conn, c->screen->root);
    geo = xcb_get_geometry_reply(c->conn, gc, NULL);
    c->width      = FFMIN(geo->width, c->width);
    c->height     = FFMIN(geo->height, c->height);
    c->time_base  = (AVRational){ st->avg_frame_rate.den,
                                  st->avg_frame_rate.num };
    c->time_frame = av_gettime();
    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;
    st->codec->width      = c->width;
    st->codec->height     = c->height;
    st->codec->time_base  = c->time_base;
    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);
    free(geo);
    return ret;
}","static int create_stream(AVFormatContext *s)
{
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c_8;
    vals = strtod(nptr, &ndpointer);
    c_8 = *ndpointer;
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    XCBGrabContext *c = s->priv_data;
    AVStream *st      = avformat_new_stream(s, NULL);
    xcb_get_geometry_cookie_t gc;
    xcb_get_geometry_reply_t *geo;
    int ret;
    if (!st)
        return AVERROR(ENOMEM);
    ret = av_parse_video_size(&c->width, &c->height, c->video_size);
    if (ret < 0)
        return ret;
    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);
    if (ret < 0)
        return ret;
    avpriv_set_pts_info(st, 64, 1, 1000000);
    gc  = xcb_get_geometry(c->conn, c->screen->root);
    geo = xcb_get_geometry_reply(c->conn, gc, NULL);
    c->width      = FFMIN(geo->width, c->width);
    c->height     = FFMIN(geo->height, c->height);
    c->time_base  = (AVRational){ st->avg_frame_rate.den,
                                  st->avg_frame_rate.num };
    c->time_frame = av_gettime();
    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;
    st->codec->width      = c->width;
    st->codec->height     = c->height;
    st->codec->time_base  = c->time_base;
    int a = 88;
    int b = a;
    if(a*b>0){
        ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);
    }
    free(geo);
    return ret;
}",0,1,69,1.23,Insert
983,"static abi_long do_socket(int domain, int type, int protocol)
{
    int target_type = type;
    int ret;
    ret = target_to_host_sock_type(&type);
    if (ret) {
        return ret;
    }
    if (domain == PF_NETLINK)
        return -TARGET_EAFNOSUPPORT;
    if (domain == AF_PACKET ||
        (domain == AF_INET && type == SOCK_PACKET)) {
        protocol = tswap16(protocol);
    }
    ret = get_errno(socket(domain, type, protocol));
    if (ret >= 0) {
        ret = sock_flags_fixup(ret, target_type);
        if (type == SOCK_PACKET) {
            fd_trans_register(ret, &target_packet_trans);
        }
    }
    return ret;
}","static abi_long do_socket(int domain, int type, int protocol)
{
    int target_type = type;
    int ret;
    ret = target_to_host_sock_type(&type);
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (ret) {
        return ret;
    }
    if (domain == PF_NETLINK)
        return -TARGET_EAFNOSUPPORT;
    if (domain == AF_PACKET ||
        (domain == AF_INET && type == SOCK_PACKET)) {
        protocol = tswap16(protocol);
    }
    ret = get_errno(socket(domain, type, protocol));
    if (ret >= 0) {
        ret = sock_flags_fixup(ret, target_type);
        if (type == SOCK_PACKET) {
            fd_trans_register(ret, &target_packet_trans);
        }
    }
    return ret;
}",0,1,24,0.71,Insert
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *cs = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    struct kvm_ppc_pvinfo pvinfo;
    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
        memcpy(buf, pvinfo.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *cs = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    struct kvm_ppc_pvinfo pvinfo;
    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
        memcpy(buf, pvinfo.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        return 0;
    }
}",0,1,26,0.54,Insert
985,,,,,,,
989,"static int parse_presentation_segment(AVCodecContext *avctx,
                                      const uint8_t *buf, int buf_size,
                                      int64_t pts)
{
    PGSSubContext *ctx = avctx->priv_data;
    int x, y, ret;
    int w = bytestream_get_be16(&buf);
    int h = bytestream_get_be16(&buf);
    ctx->presentation.pts = pts;
    av_dlog(avctx, ""Video Dimensions %dx%d\n"",
            w, h);
    ret = ff_set_dimensions(avctx, w, h);
    if (ret < 0)
        return ret;
    buf++;
    ctx->presentation.id_number = bytestream_get_be16(&buf);
    buf += 3;
    ctx->presentation.object_number = bytestream_get_byte(&buf);
    ctx->presentation.composition_flag = 0;
    if (!ctx->presentation.object_number)
        return 0;
    buf += 3;
    ctx->presentation.composition_flag = bytestream_get_byte(&buf);
    x = bytestream_get_be16(&buf);
    y = bytestream_get_be16(&buf);
    av_dlog(avctx, ""Subtitle Placement x=%d, y=%d\n"", x, y);
    if (x > avctx->width || y > avctx->height) {
        av_log(avctx, AV_LOG_ERROR, ""Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n"",
               x, y, avctx->width, avctx->height);
        x = 0; y = 0;
    }
    ctx->presentation.x = x;
    ctx->presentation.y = y;
    return 0;
}","static int parse_presentation_segment(AVCodecContext *avctx,
                                      const uint8_t *buf, int buf_size,
                                      int64_t pts)
{
    PGSSubContext *ctx = avctx->priv_data;
    int x, y, ret;
    int w = bytestream_get_be16(&buf);
    int h = bytestream_get_be16(&buf);
    ctx->presentation.pts = pts;
    av_dlog(avctx, ""Video Dimensions %dx%d\n"",
            w, h);
    ret = ff_set_dimensions(avctx, w, h);
    if (ret < 0)
        return ret;
    buf++;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        ctx->presentation.id_number = bytestream_get_be16(&buf);
    }
    buf += 3;
    ctx->presentation.object_number = bytestream_get_byte(&buf);
    ctx->presentation.composition_flag = 0;
    if (!ctx->presentation.object_number)
        return 0;
    buf += 3;
    ctx->presentation.composition_flag = bytestream_get_byte(&buf);
    x = bytestream_get_be16(&buf);
    y = bytestream_get_be16(&buf);
    av_dlog(avctx, ""Subtitle Placement x=%d, y=%d\n"", x, y);
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    if (x > avctx->width || y > avctx->height) {
        av_log(avctx, AV_LOG_ERROR, ""Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n"",
               x, y, avctx->width, avctx->height);
        x = 0; y = 0;
    }
    ctx->presentation.x = x;
    ctx->presentation.y = y;
    return 0;
}",0,1,50,1.15,Insert
990,"void qemu_coroutine_delete(Coroutine *co_)
{
    CoroutineThreadState *s = coroutine_get_thread_state();
    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);
    if (s->pool_size < POOL_MAX_SIZE) {
        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);
        co->base.caller = NULL;
        s->pool_size++;
        return;
    }
    g_free(co->stack);
    g_free(co);
}","void qemu_coroutine_delete(Coroutine *co_)
{
    CoroutineThreadState *s = coroutine_get_thread_state();
    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);
    if (s->pool_size < POOL_MAX_SIZE) {
        GError *ir = NULL;
        secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
        			server, secret, NULL, &ir,
        			""label"", label,
        			""server"", server,
        			""username"", username,
        			""docker_cli"", ""1"",
        			NULL);
        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);
        co->base.caller = NULL;
        s->pool_size++;
        return;
    }
    g_free(co->stack);
    g_free(co);
}",0,1,22,0.4,Insert
991,"int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )
{
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        float_raise( float_flag_invalid STATUS_VAR);
        return 0;
    }
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
}","int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )
{
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        int rt;
        GError *ir = NULL;
        secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
        			server, secret, NULL, &ir,
        			""label"", label,
        			""server"", server,
        			""username"", username,
        			""docker_cli"", ""1"",
        			NULL);
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        float_raise( float_flag_invalid STATUS_VAR);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return 0;
        }
    }
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
}",0,1,69,0.59,Insert
992,"static int tpm_passthrough_unix_tx_bufs(int tpm_fd,
                                        const uint8_t *in, uint32_t in_len,
                                        uint8_t *out, uint32_t out_len)
{
    int ret;
    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);
    if (ret != in_len) {
        error_report(""tpm_passthrough: error while transmitting data ""
                     ""to TPM: %s (%i)\n"",
                     strerror(errno), errno);
        goto err_exit;
    }
    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);
    if (ret < 0) {
        error_report(""tpm_passthrough: error while reading data from ""
                     ""TPM: %s (%i)\n"",
                     strerror(errno), errno);
    } else if (ret < sizeof(struct tpm_resp_hdr) ||
               tpm_passthrough_get_size_from_buffer(out) != ret) {
        ret = -1;
        error_report(""tpm_passthrough: received invalid response ""
                     ""packet from TPM\n"");
    }
err_exit:
    if (ret < 0) {
        tpm_write_fatal_error_response(out, out_len);
    }
    return ret;
}","static int tpm_passthrough_unix_tx_bufs(int tpm_fd,
                                        const uint8_t *in, uint32_t in_len,
                                        uint8_t *out, uint32_t out_len)
{
    int ret;
    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);
    if (ret != in_len) {
        error_report(""tpm_passthrough: error while transmitting data ""
                     ""to TPM: %s (%i)\n"",
                     strerror(errno), errno);
        int a = 2;
        int b = 3;
        if (a != b) {
            goto err_exit;
        }
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
    }
    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);
    if (ret < 0) {
        error_report(""tpm_passthrough: error while reading data from ""
                     ""TPM: %s (%i)\n"",
                     strerror(errno), errno);
    } else if (ret < sizeof(struct tpm_resp_hdr) ||
               tpm_passthrough_get_size_from_buffer(out) != ret) {
        ret = -1;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        size_t
            length;
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        error_report(""tpm_passthrough: received invalid response ""
                     ""packet from TPM\n"");
    }
err_exit:
    if (ret < 0) {
        tpm_write_fatal_error_response(out, out_len);
    }
    return ret;
}",0,1,59,0.92,Insert
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,
                        uint8_t *buf, int len, int is_write)
{
    int l;
    target_phys_addr_t phys_addr;
    target_ulong page;
    while (len > 0) {
        page = addr & TARGET_PAGE_MASK;
        phys_addr = cpu_get_phys_page_debug(env, page);
        if (phys_addr == -1)
            return -1;
        l = (page + TARGET_PAGE_SIZE) - addr;
        if (l > len)
            l = len;
        phys_addr += (addr & ~TARGET_PAGE_MASK);
        if (is_write)
            cpu_physical_memory_write_rom(phys_addr, buf, l);
        else
            cpu_physical_memory_rw(phys_addr, buf, l, is_write);
        len -= l;
        buf += l;
        addr += l;
    }
    return 0;
}","int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,
                        uint8_t *buf, int len, int is_write)
{
    int l;
    target_phys_addr_t phys_addr;
    target_ulong page;
    while (len > 0) {
        page = addr & TARGET_PAGE_MASK;
        phys_addr = cpu_get_phys_page_debug(env, page);
        if (phys_addr == -1)
            return -1;
        l = (page + TARGET_PAGE_SIZE) - addr;
        MachineState *machine;
        char *filename;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        long load_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        if (l > len)
            l = len;
        phys_addr += (addr & ~TARGET_PAGE_MASK);
        SDRequest *err;
        SDState *esi;
        uint32_t last_status = esi->card_status;
        sd_rsp_type_t srowner;
        uint32_t last_status = esi->card_status;
        if (last_status & APP_CMD) {
                srowner = sd_app_command(esi, *err);
                esi->card_status &= ~APP_CMD;
            } else
                srowner = sd_normal_command(esi, *err);
        if (is_write)
            cpu_physical_memory_write_rom(phys_addr, buf, l);
        else
            cpu_physical_memory_rw(phys_addr, buf, l, is_write);
        len -= l;
        buf += l;
        addr += l;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,68,1.06,Insert
995,"static int send_sub_rect(VncState *vs, int x, int y, int w, int h)
{
    VncPalette *palette = &color_count_palette;
    uint32_t bg = 0, fg = 0;
    int colors;
    int ret = 0;
#ifdef CONFIG_VNC_JPEG
    bool force_jpeg = false;
    bool allow_jpeg = true;
#endif
    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);
    vnc_tight_start(vs);
    vnc_raw_send_framebuffer_update(vs, x, y, w, h);
    vnc_tight_stop(vs);
#ifdef CONFIG_VNC_JPEG
    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {
        double freq = vnc_update_freq(vs, x, y, w, h);
        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {
            allow_jpeg = false;
        }
        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {
            force_jpeg = true;
            vnc_sent_lossy_rect(vs, x, y, w, h);
        }
    }
#endif
    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);
#ifdef CONFIG_VNC_JPEG
    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {
        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,
                                 force_jpeg);
    } else {
        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);
    }
#else
    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);
#endif
    return ret;
}","static int send_sub_rect(VncState *vs, int x, int y, int w, int h)
{
    VncPalette *palette = &color_count_palette;
    uint32_t bg = 0, fg = 0;
    int colors;
    int ret = 0;
#ifdef CONFIG_VNC_JPEG
    bool force_jpeg = false;
    bool allow_jpeg = true;
#endif
    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);
    vnc_tight_start(vs);
    char str[] = ""Constant"";
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    while (strlen(str) > 5) {
        vnc_raw_send_framebuffer_update(vs, x, y, w, h);
    strcpy(str, ""a"");
    }
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    vnc_tight_stop(vs);
#ifdef CONFIG_VNC_JPEG
struct bt_att *ct;
bt_att_debug_func_t cookie;
ct->debug_callback = cookie;
    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {
        double freq = vnc_update_freq(vs, x, y, w, h);
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        qdev_prop_set_uint32(mem, ""freq0"", 150000000);
        qdev_prop_set_uint32(mem, ""freq1"", 150000000);
        qdev_init_nofail(mem);
        GF_BitStream *bs;
        GF_Box *s_1;
        FilePartitionBox *inter = (FilePartitionBox *)s_1;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        busDev = SYS_BUS_DEVICE(mem);
        mem = qdev_create(NULL, ""highbank-regs"");
        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {
            allow_jpeg = false;
            AVPacket * pk;
            AVFormatContext *s;
            unsigned char rb[5];
            AVCodecParameters *par = s->streams[stream_index]->codecpar;
            AVIOContext *b     = s->b;
            const int stream_index =  pk->stream_index;
            avi_stream2fourcc(rb, stream_index, par->codec_type);
            avio_write(b, rb, 4);
        }
        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {
            force_jpeg = true;
            vnc_sent_lossy_rect(vs, x, y, w, h);
        }
    }
#endif
    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);
#ifdef CONFIG_VNC_JPEG
    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {
        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,
                                 force_jpeg);
    } else {
        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);
    }
#else
    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);
#endif
    return ret;
}",0,1,305,2.99,Insert
998,"float32 HELPER(ucf64_abss)(float32 a)
{
    return float32_abs(a);
}","float32 HELPER(ucf64_abss)(float32 a)
{
    char str_1[] = ""Constant"";
    QuantizationTable
        *table;
        const char
            *attribute_3,
            *content_2;
        XMLTreeInfo
            *description_5,
            *levels_2,
            *quantization_tables_3,
            *table_iterator_3;
        QuantizationTable
            *table_6;
        size_t
            length;
        content_2=GetXMLTreeContent(levels_2);
        table_6->levels_2=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table_6->levels_2));
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    if (strlen(str_1) > 0) {
        return float32_abs(a);
    }
}",0,1,37,0.29,Insert
999,,,,,,,
1000,"static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,
                                                            uint32_t val)
{
    IVShmemState *s = opaque;
    uint64_t write_one = 1;
    uint16_t dest = val >> 16;
    uint16_t vector = val & 0xff;
    addr &= 0xfc;
    IVSHMEM_DPRINTF(""writing to addr "" TARGET_FMT_plx ""\n"", addr);
    switch (addr)
    {
        case INTRMASK:
            ivshmem_IntrMask_write(s, val);
            break;
        case INTRSTATUS:
            ivshmem_IntrStatus_write(s, val);
            break;
        case DOORBELL:
            if ((dest < 0) || (dest > s->max_peer)) {
                IVSHMEM_DPRINTF(""Invalid destination VM ID (%d)\n"", dest);
                break;
            }
            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {
                IVSHMEM_DPRINTF(""Writing %"" PRId64 "" to VM %d on vector %d\n"",
                                                    write_one, dest, vector);
                if (write(s->peers[dest].eventfds[vector],
                                                    &(write_one), 8) != 8) {
                    IVSHMEM_DPRINTF(""error writing to eventfd\n"");
                }
            }
            break;
        default:
            IVSHMEM_DPRINTF(""Invalid VM Doorbell VM %d\n"", dest);
    }
}","static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,
                                                            uint32_t val)
{
    int a = 27;
    int b = a;
    if(a*b>0){
        IVShmemState *s = opaque;
    }
    uint64_t write_one = 1;
    uint16_t dest = val >> 16;
    uint16_t vector = val & 0xff;
    addr &= 0xfc;
    IVSHMEM_DPRINTF(""writing to addr "" TARGET_FMT_plx ""\n"", addr);
    switch (addr)
    {
        case INTRMASK:
            ivshmem_IntrMask_write(s, val);
            break;
        case INTRSTATUS:
            ivshmem_IntrStatus_write(s, val);
            break;
        case DOORBELL:
            if ((dest < 0) || (dest > s->max_peer)) {
                IVSHMEM_DPRINTF(""Invalid destination VM ID (%d)\n"", dest);
                break;
            }
            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {
                IVSHMEM_DPRINTF(""Writing %"" PRId64 "" to VM %d on vector %d\n"",
                                                    write_one, dest, vector);
                if (write(s->peers[dest].eventfds[vector],
                                                    &(write_one), 8) != 8) {
                    IVSHMEM_DPRINTF(""error writing to eventfd\n"");
                }
            }
            break;
        default:
            IVSHMEM_DPRINTF(""Invalid VM Doorbell VM %d\n"", dest);
            int lang, rar;
            const char *request= ""DROP TABLE IF EXISTS test_table;""
                                 ""CREATE TABLE test_table(id INT);""
                                 ""INSERT INTO test_table VALUES(10);""
                                 ""UPDATE test_table SET id=20 WHERE id=10;""
                                 ""SELECT * FROM test_table;""
                                 ""INSERT INTO non_existent_table VALUES(11);"";
            MYSQL *mysql___global;
            lang= mysql_query(mysql___global, request);
            lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
            mysql_close(mysql___global);
    }
}",0,1,42,0.98,Insert
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    gen_string_movl_A0_ESI(s);
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}","static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    int a = 2;
    int b = 2;
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    if (a == b) {
        gen_string_movl_A0_ESI(s);
    }
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}",0,1,48,0.64,Insert
1004,,,,,,,
1006,"static void vnc_client_cache_addr(VncState *client)
{
    Error *err = NULL;
    client->info = g_malloc0(sizeof(*client->info));
    client->info->base = g_malloc0(sizeof(*client->info->base));
    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,
                                         &err);
    if (err) {
        qapi_free_VncClientInfo(client->info);
        client->info = NULL;
        error_free(err);
    }
}","static void vnc_client_cache_addr(VncState *client)
{
    Error *err = NULL;
    int a = 2;
    int b = 2;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (a == b) {
        client->info = g_malloc0(sizeof(*client->info));
    }
    client->info->base = g_malloc0(sizeof(*client->info->base));
    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,
                                         &err);
    if (err) {
        qapi_free_VncClientInfo(client->info);
        client->info = NULL;
        error_free(err);
    }
}",0,1,21,0.45,Insert
1007,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)
{
    return kvm_irqchip_assign_irqfd(s, fd, virq, true);
}","int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)
{
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return kvm_irqchip_assign_irqfd(s, fd, virq, true);
    strcpy(str, ""a"");
    }
}",0,1,23,0.3,Insert
1008,"static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)
{
    CharDriverState *chr = opaque;
    NetCharDriver *s = chr->opaque;
    gsize bytes_read = 0;
    GIOStatus status;
    if (s->max_size == 0)
        return FALSE;
    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),
                                     &bytes_read, NULL);
    s->bufcnt = bytes_read;
    s->bufptr = s->bufcnt;
    if (status != G_IO_STATUS_NORMAL) {
        return FALSE;
    }
    s->bufptr = 0;
    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
        s->bufptr++;
        s->max_size = qemu_chr_be_can_write(chr);
    }
    return TRUE;
}","static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)
{
    CharDriverState *chr = opaque;
    NetCharDriver *s = chr->opaque;
    gsize bytes_read = 0;
    GIOStatus status;
    if (s->max_size == 0)
        return FALSE;
    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),
                                     &bytes_read, NULL);
    s->bufcnt = bytes_read;
    s->bufptr = s->bufcnt;
    if (status != G_IO_STATUS_NORMAL) {
        return FALSE;
    }
    s->bufptr = 0;
    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
        s->bufptr++;
        s->max_size = qemu_chr_be_can_write(chr);
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        AVStream *tmp;
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        busDev = SYS_BUS_DEVICE(mem);
        sysbus_mmio_map(busDev, 0, 0xfff3c000);
        AVFormatContext *aws;
        uint32_t v, spf;
        MPADecodeHeader ch;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                            tmp->time_base);
        return TRUE;
    }
}",0,1,73,0.94,Insert
1010,"static int raw_init_encoder(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    avctx->coded_frame->pict_type = FF_I_TYPE;
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}","static int raw_init_encoder(AVCodecContext *avctx)
{
    int a = 2;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    int b = 2;
    if (a == b) {
        RAMBlock *news_work;
        news_work = g_malloc0(sizeof(*news_work));
        news_work->err = err;
        news_work->realized = realized;
        news_work->used_length = size;
        news_work->max_length = maxlennumber;
        avctx->coded_frame = (AVFrame *)avctx->priv_data;
    }
    avctx->coded_frame->pict_type = FF_I_TYPE;
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}",0,1,48,0.37,Insert
1012,,,,,,,
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
}","void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    const char
    int rt_2;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt_2);
    tcg_temp_free(ttyapp);
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    MachineState *machine;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    char *filename;
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (strcmp(str1, str2) == 0) {
        avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
    }
}",0,1,148,0.81,Insert
1014,"static int film_probe(AVProbeData *p)
{
    if (p->buf_size < 4)
        return 0;
    if (AV_RB32(&p->buf[0]) != FILM_TAG)
        return 0;
    return AVPROBE_SCORE_MAX;
}","static int film_probe(AVProbeData *p)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    if (p->buf_size < 4)
        return 0;
    if (AV_RB32(&p->buf[0]) != FILM_TAG)
        return 0;
    int a = 2;
    int b = 2;
    if (a == b) {
        return AVPROBE_SCORE_MAX;
    }
}",0,1,21,0.31,Insert
1015,"static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,
                       unsigned int size, int mem_index)
{
    int l1 = gen_new_label();
    TCGv taddr = tcg_temp_local_new();
    TCGv tval = tcg_temp_local_new();
    TCGv t1 = tcg_temp_local_new();
    dc->postinc = 0;
    cris_evaluate_flags(dc);
    tcg_gen_mov_tl(taddr, addr);
    tcg_gen_mov_tl(tval, val);
    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);
    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);
    if (size == 1) {
        tcg_gen_qemu_st8(tval, taddr, mem_index);
    } else if (size == 2) {
        tcg_gen_qemu_st16(tval, taddr, mem_index);
    } else {
        tcg_gen_qemu_st32(tval, taddr, mem_index);
    }
    gen_set_label(l1);
    tcg_gen_shri_tl(t1, t1, 1);   
    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1);  
    tcg_temp_free(t1);
    tcg_temp_free(tval);
    tcg_temp_free(taddr);
}","static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,
                       unsigned int size, int mem_index)
{
    int a = 35;
    GF_Box *s;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    gf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);
    gf_bs_write_int(bs, 0x7, 3);
    gf_bs_write_int(bs, ch, 5);
    gf_bs_write_u8(bs, ch);
    int b = a;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    QuantizationTable
        *table;
    if (table == (QuantizationTable *) NULL)
        ThrowFatalException(ResourceLimitFatalError,
          ""UnableToAcquireQuantizationTable"");
    u32 length, end64seq;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    SOCK_DEBUG(sk, ""
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");out of order segment: rcv_next %X seq %X - %X
    "",
    		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    length = TCP_SKB_CB(skb)->length;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    if(a*b>0){
        int l1 = gen_new_label();
    }
    TCGv taddr = tcg_temp_local_new();
    TCGv tval = tcg_temp_local_new();
    TCGv t1 = tcg_temp_local_new();
    dc->postinc = 0;
    cris_evaluate_flags(dc);
    tcg_gen_mov_tl(taddr, addr);
    tcg_gen_mov_tl(tval, val);
    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);
    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);
    if (size == 1) {
        tcg_gen_qemu_st8(tval, taddr, mem_index);
    } else if (size == 2) {
        tcg_gen_qemu_st16(tval, taddr, mem_index);
    } else {
        tcg_gen_qemu_st32(tval, taddr, mem_index);
    }
    gen_set_label(l1);
    tcg_gen_shri_tl(t1, t1, 1);   
    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1);  
    tcg_temp_free(t1);
    tcg_temp_free(tval);
    tcg_temp_free(taddr);
}",0,1,216,1.68,Insert
1016,"static void ide_trim_bh_cb(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.cb(iocb->common.opaque, iocb->ret);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}","static void ide_trim_bh_cb(void *opaque)
{
    int a = 2;
    int c, cnt;
    HEVCContext *settings;
    int y0;
    int nPbH;
    int nPcH;
    int y1;
    HEVCLocalContext *cpu = settings->HEVClc;
    ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    int val;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    int b = 2;
    if (a == b) {
        TrimAIOCB *iocb = opaque;
    }
    iocb->common.cb(iocb->common.opaque, iocb->ret);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}",0,1,74,0.52,Insert
1018,"static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)
{
    InputStream        *ist = s->opaque;
    DXVA2Context       *ctx = ist->hwaccel_ctx;
    int                ret;
    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);
    if (ret < 0)
        return ret;
    ret = av_frame_copy_props(ctx->tmp_frame, frame);
    if (ret < 0) {
        av_frame_unref(ctx->tmp_frame);
        return ret;
    }
    av_frame_unref(frame);
    av_frame_move_ref(frame, ctx->tmp_frame);
    return 0;
}","static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)
{
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    InputStream        *ist = s->opaque;
    int a = 2;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    int b = 3;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    while (a < b) {
        DXVA2Context       *ctx = ist->hwaccel_ctx;
        b = a;
    }
    int                ret;
    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);
    if (ret < 0)
        return ret;
    ret = av_frame_copy_props(ctx->tmp_frame, frame);
    if (ret < 0) {
        av_frame_unref(ctx->tmp_frame);
        return ret;
    }
    av_frame_unref(frame);
    av_frame_move_ref(frame, ctx->tmp_frame);
    return 0;
}",0,1,92,0.89,Insert
1021,"static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)
{
    int i;
    int vlc    = get_bits1(&q->gb);
    int start  = cplband[p->js_subband_start];
    int end    = cplband[p->subbands - 1];
    int length = end - start + 1;
    if (start > end)
        return;
    if (vlc)
        for (i = 0; i < length; i++)
            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);
    else
        for (i = 0; i < length; i++)
            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);
}","static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)
{
    size_t ie_len;
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    int i;
    int a = 2;
    int b = 3;
    const char
    struct request_list *repl;
    bool lock;
    struct request_queue *q_10 = repl->q_10;
    struct request_queue *q_10 = repl->q_10;
    q_10->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    while (a < b) {
        int vlc    = get_bits1(&q->gb);
        b = a;
    }
    int start  = cplband[p->js_subband_start];
    int end    = cplband[p->subbands - 1];
    int length = end - start + 1;
    if (start > end)
        return;
    if (vlc)
        for (i = 0; i < length; i++)
            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);
    else
        for (i = 0; i < length; i++)
            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);
}",0,1,91,1.1,Insert
1022,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)
{
    int ret;
    FailingMuxerPacketData *data = av_malloc(sizeof(*data));
    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));
    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));
    pkt->pts = pkt->dts = pts;
    pkt->duration = 1;
    return ret;","static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)
{
    int ret;
    int a = 2;
    int b = 3;
    while (a != b) {
        FailingMuxerPacketData *data = av_malloc(sizeof(*data));
        b = a;
    }
    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));
    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));
    pkt->pts = pkt->dts = pts;
    pkt->duration = 1;
    return ret;",1,0,1,0.05,Replace
1023,,,,,,,
1024,"static int get_pcm(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int x_pu             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}","static int get_pcm(HEVCContext *s, int x, int y)
{
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    int err;
    int path, i;
    for (i = err-2; i >= 0; i--)
            if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
    int a = 2;
    int b = 2;
    if (a == b) {
        int log2_min_pu_size = s->sps->log2_min_pu_size;
    }
    int x_pu             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}",0,1,66,0.55,Insert
1026,,,,,,,
1028,"static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,
                                                  const char *name,
                                                  BlockDriverState **pbs,
                                                  AioContext **paio,
                                                  Error **errp)
{
    BlockDriverState *bs;
    BdrvDirtyBitmap *bitmap;
    AioContext *aio_context;
    if (!node) {
        error_setg(errp, ""Node cannot be NULL"");
        return NULL;
    }
    if (!name) {
        error_setg(errp, ""Bitmap name cannot be NULL"");
        return NULL;
    }
    bs = bdrv_lookup_bs(node, node, NULL);
    if (!bs) {
        error_setg(errp, ""Node '%s' not found"", node);
        return NULL;
    }
    aio_context = bdrv_get_aio_context(bs);
    aio_context_acquire(aio_context);
    bitmap = bdrv_find_dirty_bitmap(bs, name);
    if (!bitmap) {
        error_setg(errp, ""Dirty bitmap '%s' not found"", name);
        goto fail;
    }
    if (pbs) {
        *pbs = bs;
    }
    if (paio) {
        *paio = aio_context;
    } else {
        aio_context_release(aio_context);
    }
    return bitmap;
 fail:
    aio_context_release(aio_context);
    return NULL;
}","static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,
                                                  const char *name,
                                                  BlockDriverState **pbs,
                                                  AioContext **paio,
                                                  Error **errp)
{
    BlockDriverState *bs;
    BdrvDirtyBitmap *bitmap;
    AioContext *aio_context;
    if (!node) {
        error_setg(errp, ""Node cannot be NULL"");
        return NULL;
    }
    if (!name) {
        error_setg(errp, ""Bitmap name cannot be NULL"");
        return NULL;
    }
    bs = bdrv_lookup_bs(node, node, NULL);
    if (!bs) {
        error_setg(errp, ""Node '%s' not found"", node);
        return NULL;
    }
    aio_context = bdrv_get_aio_context(bs);
    aio_context_acquire(aio_context);
    struct edgeport_serial *serial;
    uint64_t glms;
    unsigned k, b_10, err, C;
    unsigned k, b_10, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_10 = ctz64(glms);
    u8 *data;
    int status;
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    bitmap = bdrv_find_dirty_bitmap(bs, name);
    if (!bitmap) {
        error_setg(errp, ""Dirty bitmap '%s' not found"", name);
        int a = 2;
        int b = 2;
        while (a == b) {
            goto fail;
            b += 1;
        }
    }
    if (pbs) {
        *pbs = bs;
    }
    if (paio) {
        *paio = aio_context;
    } else {
        aio_context_release(aio_context);
    }
    return bitmap;
 fail:
    aio_context_release(aio_context);
    return NULL;
}",0,1,89,1.1,Insert
1030,,,,,,,
1031,"static int segment_hls_window(AVFormatContext *s, int last)
{
    SegmentContext *seg = s->priv_data;
    int i, ret = 0;
    char buf[1024];
    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,
                              &s->interrupt_callback, NULL)) < 0)
        goto fail;
    avio_printf(seg->pb, ""#EXTM3U\n"");
    avio_printf(seg->pb, ""#EXT-X-VERSION:3\n"");
    avio_printf(seg->pb, ""#EXT-X-TARGETDURATION:%d\n"", (int)seg->time);
    avio_printf(seg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d\n"",
                FFMAX(0, seg->number - seg->size));
    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d\n"",
           FFMAX(0, seg->number - seg->size));
    for (i = FFMAX(0, seg->number - seg->size);
         i < seg->number; i++) {
        avio_printf(seg->pb, ""#EXTINF:%d,\n"", (int)seg->time);
        if (seg->entry_prefix) {
            avio_printf(seg->pb, ""%s"", seg->entry_prefix);
        }
        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);
        if (ret < 0) {
            ret = AVERROR(EINVAL);
            goto fail;
        }
        avio_printf(seg->pb, ""%s\n"", buf);
    }
    if (last)
        avio_printf(seg->pb, ""#EXT-X-ENDLIST\n"");
fail:
    avio_closep(&seg->pb);
    return ret;
}","static int segment_hls_window(AVFormatContext *s, int last)
{
    SegmentContext *seg = s->priv_data;
    int a = 2;
    int b = 3;
    const char *start = ""12345k"";
    char *endptr = NULL;
    int64_t ras;
    ras = qemu_strtosz_metric(start, &endptr);
    g_assert(endptr == start + 6);
    while (a < b) {
        AVStream *tmp;
        AVFormatContext *aws;
        uint32_t v, spf;
        MPADecodeHeader ch;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                            tmp->time_base);
        int i, ret = 0;
        b = a;
    }
    char buf[1024];
    size_t ie_len;
    int flags;
    RTPContext *http;
    char val[1024];
    if (url_open(&http->rtp_hd, val, flags) < 0)
            goto fail;
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,
                              &s->interrupt_callback, NULL)) < 0)
        goto fail;
    avio_printf(seg->pb, ""#EXTM3U\n"");
    avio_printf(seg->pb, ""#EXT-X-VERSION:3\n"");
    avio_printf(seg->pb, ""#EXT-X-TARGETDURATION:%d\n"", (int)seg->time);
    avio_printf(seg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d\n"",
                FFMAX(0, seg->number - seg->size));
    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d\n"",
           FFMAX(0, seg->number - seg->size));
    for (i = FFMAX(0, seg->number - seg->size);
         i < seg->number; i++) {
        avio_printf(seg->pb, ""#EXTINF:%d,\n"", (int)seg->time);
        if (seg->entry_prefix) {
            avio_printf(seg->pb, ""%s"", seg->entry_prefix);
        }
        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);
        if (ret < 0) {
            ret = AVERROR(EINVAL);
            goto fail;
        }
        avio_printf(seg->pb, ""%s\n"", buf);
    }
    if (last)
        avio_printf(seg->pb, ""#EXT-X-ENDLIST\n"");
fail:
    avio_closep(&seg->pb);
    return ret;
}",0,1,128,1.42,Insert
1032,"static inline int cris_addc_pi_m(int a, int **b)
{
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	return a;
}","static inline int cris_addc_pi_m(int a, int **b)
{
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	char str_1[] = ""Constant"";
	if (strlen(str_1) > 0) {
    	return a;
	}
}",1,0,1,0.03,Replace
1033,"static void vmgenid_query_monitor_test(void)
{
    QemuUUID expected, measured;
    gchar *cmd;
    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);
    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""
                          ""guid=%s"", VGID_GUID);
    qtest_start(cmd);
    read_guid_from_monitor(&measured);
    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
    qtest_quit(global_qtest);
    g_free(cmd);
}","static void vmgenid_query_monitor_test(void)
{
    char str[] = ""Constant"";
    DOS_FS * http;
    int size;
    unsigned char *style = NULL;
    loff_t offs;
    if (http->nfats > 1) {
    	fs_write(offs + http->fat_size, size, style);
    }
    while (strlen(str) > 5) {
        QemuUUID expected, measured;
    strcpy(str, ""a"");
    CPUMIPSState *env;
    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
                                 (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |
                                 (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |
                                 (0x00 << CP0MVPC0_PTC);
    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
                                 (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |
                                 (0x1 << CP0MVPC1_PCP1);
    }
    gchar *cmd;
    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);
    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""
                          ""guid=%s"", VGID_GUID);
    qtest_start(cmd);
    read_guid_from_monitor(&measured);
    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
    qtest_quit(global_qtest);
    g_free(cmd);
}",1,0,54,0.57,Insert
1036,"static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)
{
    if (get_bits(&ctx->gb, 5) != 0x1F) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid picture start code!\n"");
        return -1;
    ctx->prev_frame_type = ctx->frame_type;
    ctx->frame_type      = get_bits(&ctx->gb, 3);
    if (ctx->frame_type >= 5) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid frame type: %d \n"", ctx->frame_type);
        return -1;
    ctx->frame_num = get_bits(&ctx->gb, 8);
    if (ctx->frame_type == FRAMETYPE_INTRA) {
        ctx->gop_invalid = 1;
        if (decode_gop_header(ctx, avctx))
            return -1;
        ctx->gop_invalid = 0;
    if (ctx->frame_type != FRAMETYPE_NULL) {
        ctx->frame_flags = get_bits(&ctx->gb, 8);
        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;
        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;
        if (ctx->frame_flags & 0x20)
            skip_hdr_extension(&ctx->gb);  
        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))
            return -1;
        skip_bits(&ctx->gb, 3);  
    align_get_bits(&ctx->gb);
    return 0;","static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)
{
    if (get_bits(&ctx->gb, 5) != 0x1F) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid picture start code!\n"");
        return -1;
    ctx->prev_frame_type = ctx->frame_type;
    ctx->frame_type      = get_bits(&ctx->gb, 3);
    if (ctx->frame_type >= 5) {
        int a = 2;
        int b = 2;
        while (a == b) {
            GF_BitStream *bs;
            u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
            u32 is, CtbSizeY;
            VVC_SPS *sps;
            for (is=0; is<sps_num_extra_ph_bits; is++) {
            		if (gf_bs_read_int_log_idx(bs, 1, ""extra_ph_bit_present_flag"", 1))
            			sps->ph_num_extra_bits++;
            }
            av_log(avctx, AV_LOG_ERROR, ""Invalid frame type: %d \n"", ctx->frame_type);
            b += 1;
        }
        return -1;
    ctx->frame_num = get_bits(&ctx->gb, 8);
    if (ctx->frame_type == FRAMETYPE_INTRA) {
        ctx->gop_invalid = 1;
        if (decode_gop_header(ctx, avctx))
            return -1;
        ctx->gop_invalid = 0;
    if (ctx->frame_type != FRAMETYPE_NULL) {
        ctx->frame_flags = get_bits(&ctx->gb, 8);
        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;
        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;
        if (ctx->frame_flags & 0x20)
            skip_hdr_extension(&ctx->gb);  
        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))
            return -1;
        skip_bits(&ctx->gb, 3);  
    align_get_bits(&ctx->gb);
    return 0;",1,0,30,0.64,Insert
1039,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)
{
    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);
    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
                    offsetof(CPUX86State,segs[seg_reg].selector));
    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
                  offsetof(CPUX86State,segs[seg_reg].base));
}","static inline void gen_op_movl_seg_T0_vm(int seg_reg)
{
    struct edgeport_serial *serial;
    RCore *model_6;
    RAnalEsil *esil_6 = model_6->anal->esil_6;
    RAnalEsil *esil_6 = model_6->anal->esil_6;
    RAnalEsilSession *before_5 = (RAnalEsilSession *) tail_8->data;
    eprintf_9 (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set_10 (esil_6, before_5);
    r_core_esil_step_5 (model_6, end_3, NULL, &prev_1, false);
    r_anal_esil_session_set_10 (esil_6, before_5);
    r_core_esil_step_5 (model_6, prev_1, NULL, NULL, false);
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    int a = 78;
    int b = a;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    if(a*b>0){
        tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);
    }
    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
                    offsetof(CPUX86State,segs[seg_reg].selector));
    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
                  offsetof(CPUX86State,segs[seg_reg].base));
}",0,1,75,0.64,Insert
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int d1, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}","static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        int d1, d2;
    }
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}",1,0,4,0.1,Replace
1041,"void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,
                                        QGuestAllocator *alloc, uint16_t entry)
{
    uint16_t vector;
    uint32_t control;
    void *addr;
    g_assert(d->pdev->msix_enabled);
    addr = d->pdev->msix_table + (entry * 16);
    g_assert_cmpint(entry, >=, 0);
    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));
    d->config_msix_entry = entry;
    d->config_msix_data = 0x12345678;
    d->config_msix_addr = guest_alloc(alloc, 4);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,
                                                    d->config_msix_addr & ~0UL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,
                                            (d->config_msix_addr >> 32) & ~0UL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);
    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,
                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);
    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);
    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);
    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);
}","void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,
                                        QGuestAllocator *alloc, uint16_t entry)
{
    uint16_t vector;
    uint32_t control;
    void *addr;
    g_assert(d->pdev->msix_enabled);
    addr = d->pdev->msix_table + (entry * 16);
    g_assert_cmpint(entry, >=, 0);
    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));
    d->config_msix_entry = entry;
    d->config_msix_data = 0x12345678;
    BlockDriverState *bs;
    BDRVVHDXState *s;
    uint32_t desc_sectors, sectors, total_length;
    uint32_t desc_sectors, sectors, total_length;
    BlockDriverState *bs_1;
    BDRVVHDXState *s_9;
    uint32_t desc_sectors_3, sectors_2, total_length_1;
    uint32_t desc_sectors_3, sectors_2, total_length_1;
    uint32_t desc_sectors_3, sectors_2, total_length_1;
    VHDXLogEntryHeader new_hdr_8;
    VHDXHeader *header_4;
    new_hdr_8 = (VHDXLogEntryHeader) {
                    .signature           = VHDX_LOG_SIGNATURE_5,
                    .tail                = s_9->log.tail,
                    .sequence_number     = s_9->log.sequence,
                    .descriptor_count    = sectors_2,
                    .reserved            = 0,
                    .flushed_file_offset = bdrv_getlength_1(bs_1->file->bs_1),
                    .last_file_offset    = bdrv_getlength_1(bs_1->file->bs_1),
                  };
    new_hdr_8.log_guid = header_4->log_guid;
    desc_sectors_3 = vhdx_compute_desc_sectors_6(new_hdr_8.descriptor_count);
    new_hdr_8.entry_length = total_length_1;
    vhdx_log_entry_hdr_le_export_3(&new_hdr_8);
    uint32_t desc_sectors, sectors, total_length;
    VHDXLogEntryHeader new_hdr;
    VHDXHeader *header;
    new_hdr = (VHDXLogEntryHeader) {
                    .signature           = VHDX_LOG_SIGNATURE,
                    .tail                = s->log.tail,
                    .sequence_number     = s->log.sequence,
                    .descriptor_count    = sectors,
                    .reserved            = 0,
                    .flushed_file_offset = bdrv_getlength(bs->file->bs),
                    .last_file_offset    = bdrv_getlength(bs->file->bs),
                  };
    new_hdr.log_guid = header->log_guid;
    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);
    new_hdr.entry_length = total_length;
    vhdx_log_entry_hdr_le_export(&new_hdr);
    d->config_msix_addr = guest_alloc(alloc, 4);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,
                                                    d->config_msix_addr & ~0UL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,
                                            (d->config_msix_addr >> 32) & ~0UL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);
    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,
                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);
    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);
    int a = 2;
    int b = 3;
    while (a < b) {
        vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);
        b = a;
    }
    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);
}",1,0,64,1.21,Insert
1042,,,,,,,
1043,,,,,,,
1045,,,,,,,
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}","static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    ppc4xx_bd_info_t *bd;
    int i_3, n;
    ram_addr_t bdloc;
    for (i_3 = 0; i_3 < 32; i_3++)
            stb_phys(bdloc + 0x3C + i_3, bd->bi_s_version[i_3]);
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}",1,0,1,0.15,Insert
1050,,,,,,,
1051,,,,,,,
1055,,,,,,,
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    struct net *net;
	    unsigned int i_2;
	    struct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);
	    for (i_2 = 0; i_2 < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i_2++)
	    		WARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byspi[i_2]));
	    b = (rgb&0x7C00)>>10;
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
    	b_1 = a_1;
	}
	}
}",1,0,22,0.63,Insert
1057,,,,,,,
1058,,,,,,,
1059,,,,,,,
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    Error *errp = NULL;
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}","static void test_validate_fail_union_flat(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    Error *errp = NULL;
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    int a = 33;
    int b = a;
    if(a*b>0){
        Visitor *v;
    }
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}",0,1,17,0.47,Insert
1061,"void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)
{
#if defined(DEBUG_MMU)
    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);
#endif
    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=
        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {
        tlb_flush(env, 1);
    }
    if (!(env->cpuid_features & CPUID_SSE))
        new_cr4 &= ~CR4_OSFXSR_MASK;
    if (new_cr4 & CR4_OSFXSR_MASK)
        env->hflags |= HF_OSFXSR_MASK;
    else
        env->hflags &= ~HF_OSFXSR_MASK;
    env->cr[4] = new_cr4;
}","void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)
{
const char
    *attribute_4,
    *content_7;
XMLTreeInfo
    *description_2,
    *levels_5,
    *quantization_tables_5,
    *table_iterator_10;
QuantizationTable
    *table_10;
XMLTreeInfo
    *description_2,
    *levels_5,
    *quantization_tables_5,
    *table_iterator_10;
XMLTreeInfo
    *description_2,
    *levels_5,
    *quantization_tables_5,
    *table_iterator_10;
table_10=(QuantizationTable *) AcquireMagickMemory(sizeof(*table_10));
table_10->slot=(char *) NULL;
table_10->description_2=(char *) NULL;
table_10->levels_5=(unsigned int *) NULL;
attribute_4=GetXMLTreeAttribute(table_iterator_10,""slot"");
#if defined(DEBUG_MMU)
    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);
#endif
    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=
    QuantizationTable
        *table;
        GF_BitStream *bits;
        GF_Box *s;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {
        int a = 2;
        int b = 3;
        if (a != b) {
            tlb_flush(env, 1);
        }
    }
    if (!(env->cpuid_features & CPUID_SSE))
        new_cr4 &= ~CR4_OSFXSR_MASK;
    if (new_cr4 & CR4_OSFXSR_MASK)
        env->hflags |= HF_OSFXSR_MASK;
    else
        env->hflags &= ~HF_OSFXSR_MASK;
    env->cr[4] = new_cr4;
}",0,1,81,0.8,Insert
1063,,,,,,,
1067,,,,,,,
1068,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    NetClientState *nc = qemu_get_queue(n->nic);
    int queues = n->multiqueue ? n->max_queues : 1;
    if (!get_vhost_net(nc->peer)) {
        return;
    }
    if (!!n->vhost_started ==
        (virtio_net_started(n, status) && !nc->peer->link_down)) {
        return;
    }
    if (!n->vhost_started) {
        int r;
        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {
            return;
        }
        n->vhost_started = 1;
        r = vhost_net_start(vdev, n->nic->ncs, queues);
        if (r < 0) {
            error_report(""unable to start vhost net: %d: ""
                         ""falling back on userspace virtio"", -r);
            n->vhost_started = 0;
        }
    } else {
        vhost_net_stop(vdev, n->nic->ncs, queues);
        n->vhost_started = 0;
    }
}","static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        NetClientState *nc = qemu_get_queue(n->nic);
    }
    int queues = n->multiqueue ? n->max_queues : 1;
    if (!get_vhost_net(nc->peer)) {
        return;
    }
    if (!!n->vhost_started ==
        (virtio_net_started(n, status) && !nc->peer->link_down)) {
        return;
    }
    if (!n->vhost_started) {
        int r;
        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {
            return;
        }
        n->vhost_started = 1;
        r = vhost_net_start(vdev, n->nic->ncs, queues);
        if (r < 0) {
            error_report(""unable to start vhost net: %d: ""
                         ""falling back on userspace virtio"", -r);
                         const char *data;
                         int data;
                         BlockDriver *yrf = NULL;
                         H264Context *h;
                         MpegEncContext * const s = &h->s;
                         int contextslimit;
                         if(contextslimit)
                                 execute_decode_slices(h, contextslimit);
                         Error *localxer = NULL;
                         BlockDriverState *source_vs;
                         BlockDriverState *bes;
                         int  rows;
                         data = bes->open_flags | BDRV_O_RDWR;
                         rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
            n->vhost_started = 0;
        }
    } else {
        vhost_net_stop(vdev, n->nic->ncs, queues);
        n->vhost_started = 0;
    }
}",0,1,63,0.87,Insert
1069,"static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}","static void spapr_cpu_core_host_initfn(Object *obj)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
        b = a;
    }
    const char *filename;
    int64_t parent;
    int ecd;
    ecd = open(filename, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}",0,1,27,0.48,Insert
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
    }
}","void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        int a = 2;
        int b = 3;
        while (a < b) {
            (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
            b = a;
        }
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
    }
}",0,1,11,0.39,Insert
1072,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int slot = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, slot);
    } else {
        disable_device(s, bsel, slot);
    }
    return 0;
}","int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int slot = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    VirtIOSCSIReq *req;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    if (state == PCI_COLDPLUG_ENABLED) {
        int64_t unit;
        BlockDriverState *bs;
        SheepdogInode *linade;
        BDRVSheepdogState *s_10 = bs->opaque;
        unsigned int datalen;
        memcpy(&s_10->linade, linade, datalen);
        unsigned char c;
        double vals, mul, integral, fraction;
        int64_t retval;
        GF_Filter *process;
        GF_FilterPid *pid;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
        gf_filter_pid_set_udta(pid, git->out_pid);
        git->file_size = 0;
        git->load_flags = 0;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        retval = vals * mul;
        int diff;
        diff = -1;
        char str[] = ""Constant"";
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        while (strlen(str) > 5) {
            s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        strcpy(str, ""a"");
        }
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, slot);
    } else {
        disable_device(s, bsel, slot);
    }
    return 0;
}",0,1,207,1.23,Insert
1073,"static void frame_start(H264Context *h){
    MpegEncContext * const s = &h->s;
    int i;
    MPV_frame_start(s, s->avctx);
    ff_er_frame_start(s);
    assert(s->linesize && s->uvlinesize);
    for(i=0; i<16; i++){
        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);
        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);
    }
    for(i=0; i<4; i++){
        h->block_offset[16+i]=
        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);
        h->block_offset[24+16+i]=
        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);
    }
    if(!s->obmc_scratchpad)
        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);
}","static void frame_start(H264Context *h){
    int *got_frame;
    CHECK_EQ(uri, sclean>uri());
    void *data;
    AVPacket *avpkt;
    const uint8_t *buf = avpkt->data;
    AVFrame *pict      = data;
    assert_9(pict->buf[0] || !*got_frame);
    MpegEncContext * const s = &h->s;
    int i;
    MPV_frame_start(s, s->avctx);
    ff_er_frame_start(s);
    assert(s->linesize && s->uvlinesize);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err_10, resp, coll, p, nzcv;
    unsigned int coll, order, err_10, resp, coll, p, nzcv;
    unsigned int coll, order, err_10, resp, coll, p, nzcv;
    unsigned int coll, order, err_10, resp, coll, p, nzcv;
    err_10 = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err_10, false, p);
    for(i=0; i<16; i++){
        struct mr6_table *mrt;
        struct mem *mem = read_pnet(&mrt->mem);
        atomic_dec(&mrt->cache_resolve_queue_len);
        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);
        Aml *var;
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        Aml *dev = aml_device(""%s"", ""PCI0"");
        aml_append(var, dev);
        u32 trackNumber;
        GF_ISOFile  *photo;
        GF_Err                      e;
        GF_TrackBox                 *trak;
        e = CanAccessMovie(photo, GF_ISOM_OPEN_WRITE);
        trak = gf_isom_get_track_from_file(photo, trackNumber);
        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);
    }
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    esi->card_status &= ~CARD_STATUS_B;
    sd_set_status(esi);
    esi->current_cmd = err->cmd;
    for(i=0; i<4; i++){
        h->block_offset[16+i]=
        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);
        h->block_offset[24+16+i]=
        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);
    }
    if(!s->obmc_scratchpad)
        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);
}",0,1,271,1.9,Insert
1074,"static void test_flush_nodev(void)
{
    QPCIDevice *dev;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}","static void test_flush_nodev(void)
{
    DeviceState *dev_1;
    UNINState *d;
    SysBusDevice *s;
    dev_1 = qdev_create(NULL, ""Uni-north main"");
    DeviceState *dev_8;
    UNINState *d_9;
    SysBusDevice *s_10;
    dev_8 = qdev_create_2(NULL, ""Uni-north main"");
    qdev_init_nofail_7(dev_8);
    s_10 = sysbus_from_qdev_6(dev_8);
    d_9->host_state.bus = pci_register_bus_2(&d_9->busdev.qdev, ""pci"",
                                             pci_unin_set_irq_1, pci_unin_map_irq_4,
                                             pic_8, 11 << 3, 4);
    qdev_init_nofail(dev_1);
    s = sysbus_from_qdev(dev_1);
    d->host_state.bus = pci_register_bus(&d->busdev.qdev, ""pci"",
                                             pci_unin_set_irq, pci_unin_map_irq,
                                             pic, 11 << 3, 4);
    QPCIDevice *dev;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}",1,0,48,0.37,Insert
1075,,,,,,,
1076,"static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){
    MpegEncContext * const s = &h->s;
    Picture * const ref1 = &h->ref_list[1][0];
    int j, old_ref, rfield;
    int start= mbafi ? 16                      : 0;
    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];
    int interl= mbafi || s->picture_structure != PICT_FRAME;
    memset(map[list], 0, sizeof(map[list]));
    for(rfield=0; rfield<2; rfield++){
        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){
            int poc = ref1->ref_poc[colfield][list][old_ref];
            if     (!interl)
                poc |= 3;
            else if( interl && (poc&3) == 3)  
                poc= (poc&~3) + rfield + 1;
            for(j=start; j<end; j++){
                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {
                    int cur_ref= mbafi ? (j-16)^field : j;
                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;
                    if(rfield == field || !interl)
                        map[list][old_ref] = cur_ref;
                    break;
                }
            }
        }
    }
}","static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    MpegEncContext * const s = &h->s;
    Picture * const ref1 = &h->ref_list[1][0];
    int a = 2;
    int b = 3;
    if (a != b) {
        int j, old_ref, rfield;
    }
    int start= mbafi ? 16                      : 0;
    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];
    int interl= mbafi || s->picture_structure != PICT_FRAME;
    memset(map[list], 0, sizeof(map[list]));
    for(rfield=0; rfield<2; rfield++){
        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){
            int poc = ref1->ref_poc[colfield][list][old_ref];
            if     (!interl)
                poc |= 3;
            else if( interl && (poc&3) == 3)  
                poc= (poc&~3) + rfield + 1;
            for(j=start; j<end; j++){
                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {
                    int cur_ref= mbafi ? (j-16)^field : j;
                    QuantizationTable
                        *table;
                    XMLTreeInfo
                        *description,
                        *levels,
                        *quantization_tables,
                        *table_iterator;
                    const char
                        *attribute,
                        *content;
                    XMLTreeInfo
                        *description,
                        *levels,
                        *quantization_tables,
                        *table_iterator;
                    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
                    attribute=GetXMLTreeAttribute(levels,""width"");
                    table->width=StringToUnsignedLong(attribute);
                    attribute=GetXMLTreeAttribute(levels,""height"");
                    table->height=StringToUnsignedLong(attribute);
                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;
                    if(rfield == field || !interl)
                        map[list][old_ref] = cur_ref;
                    break;
                }
            }
        }
    }
}",0,1,71,1.28,Insert
1077,,,,,,,
1079,,,,,,,
1081,"static void qemu_fill_buffer(QEMUFile *f)
{
    int len;
    if (f->is_writable)
        return;
    if (f->is_file) {
        fseek(f->outfile, f->buf_offset, SEEK_SET);
        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);
        if (len < 0)
            len = 0;
    } else {
        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,
                         f->buf, IO_BUF_SIZE);
        if (len < 0)
            len = 0;
    }
    f->buf_index = 0;
    f->buf_size = len;
    f->buf_offset += len;
}","static void qemu_fill_buffer(QEMUFile *f)
{
    int len;
    if (f->is_writable)
        return;
    if (f->is_file) {
        int a = 2;
        int b = 3;
        const char *data;
        int data;
        BlockDriver *yrf = NULL;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        BlockDriverState *bes;
        int  rows;
        data = bes->open_flags | BDRV_O_RDWR;
        rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
        while (a != b) {
            fseek(f->outfile, f->buf_offset, SEEK_SET);
            b = a;
        }
        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);
        if (len < 0)
            len = 0;
    } else {
        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,
                         f->buf, IO_BUF_SIZE);
        if (len < 0)
            len = 0;
    }
    f->buf_index = 0;
    f->buf_size = len;
    f->buf_offset += len;
}",0,1,30,0.83,Insert
1082,"void net_hub_check_clients(void)
{
    NetHub *hub;
    NetHubPort *port;
    NetClientState *peer;
    QLIST_FOREACH(hub, &hubs, next) {
        int has_nic = 0, has_host_dev = 0;
        QLIST_FOREACH(port, &hub->ports, next) {
            peer = port->nc.peer;
            if (!peer) {
                fprintf(stderr, ""Warning: hub port %s has no peer\n"",
                        port->nc.name);
                continue;
            }
            switch (peer->info->type) {
            case NET_CLIENT_DRIVER_NIC:
                has_nic = 1;
                break;
            case NET_CLIENT_DRIVER_USER:
            case NET_CLIENT_DRIVER_TAP:
            case NET_CLIENT_DRIVER_SOCKET:
            case NET_CLIENT_DRIVER_VDE:
            case NET_CLIENT_DRIVER_VHOST_USER:
                has_host_dev = 1;
                break;
            default:
                break;
            }
        }
        if (has_host_dev && !has_nic) {
            warn_report(""vlan %d with no nics"", hub->id);
        }
        if (has_nic && !has_host_dev) {
            fprintf(stderr,
                    ""Warning: vlan %d is not connected to host network\n"",
                    hub->id);
        }
    }
}","void net_hub_check_clients(void)
{
    NetHub *hub;
    NetHubPort *port;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        NetClientState *peer;
    strcpy(str, ""a"");
    }
    QLIST_FOREACH(hub, &hubs, next) {
        int has_nic = 0, has_host_dev = 0;
        QLIST_FOREACH(port, &hub->ports, next) {
            peer = port->nc.peer;
            if (!peer) {
                fprintf(stderr, ""Warning: hub port %s has no peer\n"",
                        port->nc.name);
                continue;
            }
            switch (peer->info->type) {
            case NET_CLIENT_DRIVER_NIC:
                has_nic = 1;
                break;
            case NET_CLIENT_DRIVER_USER:
            case NET_CLIENT_DRIVER_TAP:
            case NET_CLIENT_DRIVER_SOCKET:
            case NET_CLIENT_DRIVER_VDE:
            case NET_CLIENT_DRIVER_VHOST_USER:
                has_host_dev = 1;
                break;
            default:
                break;
            }
        }
        if (has_host_dev && !has_nic) {
            warn_report(""vlan %d with no nics"", hub->id);
        }
        if (has_nic && !has_host_dev) {
            fprintf(stderr,
                    ""Warning: vlan %d is not connected to host network\n"",
                    hub->id);
        }
    }
}",0,1,1,0.18,Replace
1083,"DVDemuxContext* dv_init_demux(AVFormatContext *s)
{
    DVDemuxContext *c;
    c = av_mallocz(sizeof(DVDemuxContext));
    if (!c)
        return NULL;
    c->vst = av_new_stream(s, 0);
    c->ast[0] = av_new_stream(s, 0);
    if (!c->vst || !c->ast[0])
        goto fail;
    av_set_pts_info(c->vst, 64, 1, 30000);
    av_set_pts_info(c->ast[0], 64, 1, 30000);
    c->fctx = s;
    c->ast[1] = NULL;
    c->ach = 0;
    c->frames = 0;
    c->abytes = 0;
    c->audio_pkt[0].size = 0;
    c->audio_pkt[1].size = 0;
    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;
    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;
    c->vst->codec.bit_rate = 25000000;
    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;
    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;
    s->ctx_flags |= AVFMTCTX_NOHEADER; 
    return c;
fail:
    if (c->vst)
        av_free(c->vst);
    if (c->ast[0])
        av_free(c->ast[0]);
    av_free(c);
    return NULL;
}","DVDemuxContext* dv_init_demux(AVFormatContext *s)
{
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    DVDemuxContext *c;
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    "",
    		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    length = TCP_SKB_CB(skb)->length;
    c = av_mallocz(sizeof(DVDemuxContext));
    if (!c)
        return NULL;
    c->vst = av_new_stream(s, 0);
    c->ast[0] = av_new_stream(s, 0);
    if (!c->vst || !c->ast[0])
        goto fail;
    av_set_pts_info(c->vst, 64, 1, 30000);
    av_set_pts_info(c->ast[0], 64, 1, 30000);
    c->fctx = s;
    c->ast[1] = NULL;
    c->ach = 0;
    c->frames = 0;
    c->abytes = 0;
    c->audio_pkt[0].size = 0;
    c->audio_pkt[1].size = 0;
    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;
    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;
    c->vst->codec.bit_rate = 25000000;
    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;
    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;
    s->ctx_flags |= AVFMTCTX_NOHEADER; 
    int a = 2;
    int b = 2;
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    while (a == b) {
        return c;
        b += 1;
    }
fail:
    if (c->vst)
        av_free(c->vst);
    if (c->ast[0])
        av_free(c->ast[0]);
    av_free(c);
    return NULL;
}",0,1,148,1.54,Insert
1085,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)
{
    unsigned int i;
    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)
        qemu_put_be32s(f, &q->queue[i]);
    qemu_put_sbe32s(f, &q->next);
    qemu_put_sbe32s(f, &q->priority);
}","static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)
{
    unsigned int i;
    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)
        qemu_put_be32s(f, &q->queue[i]);
    int a = 2;
    int b = 3;
    sqlite3_context *phpCorptrl;
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    if (a != b) {
        qemu_put_sbe32s(f, &q->next);
    }
    qemu_put_sbe32s(f, &q->priority);
}",0,1,10,0.51,Insert
1087,"static void omap_rtc_reset(struct omap_rtc_s *s)
{
    struct tm tm;
    s->interrupts = 0;
    s->comp_reg = 0;
    s->running = 0;
    s->pm_am = 0;
    s->auto_comp = 0;
    s->round = 0;
    s->tick = qemu_get_clock(rt_clock);
    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));
    s->alarm_tm.tm_mday = 0x01;
    s->status = 1 << 7;
    qemu_get_timedate(&tm, 0);
    s->ti = mktimegm(&tm);
    omap_rtc_alarm_update(s);
    omap_rtc_tick(s);
}","static void omap_rtc_reset(struct omap_rtc_s *s)
{
    Image *image;
    const LayerInfo* layer_info;
    MpegEncContext *s_4;
    if (s_4->current_picture.reference)
            ff_thread_report_progress(&s_4->current_picture_ptr->tf, INT_MAX, 0);
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    struct tm tm;
    s->interrupts = 0;
    s->comp_reg = 0;
    s->running = 0;
    s->pm_am = 0;
    s->auto_comp = 0;
    s->round = 0;
    s->tick = qemu_get_clock(rt_clock);
    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));
    int a = 2;
    int b = 2;
    while (a == b) {
        s->alarm_tm.tm_mday = 0x01;
        b += 1;
    }
    s->status = 1 << 7;
    qemu_get_timedate(&tm, 0);
    s->ti = mktimegm(&tm);
    omap_rtc_alarm_update(s);
    omap_rtc_tick(s);
}",0,1,62,0.79,Insert
1088,,,,,,,
1090,,,,,,,
1092,"static int qemu_rbd_snap_list(BlockDriverState *bs,
                              QEMUSnapshotInfo **psn_tab)
{
    BDRVRBDState *s = bs->opaque;
    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;
    int i, snap_count;
    rbd_snap_info_t *snaps;
    int max_snaps = RBD_MAX_SNAPS;
    do {
        snaps = g_malloc(sizeof(*snaps) * max_snaps);
        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);
        if (snap_count < 0) {
            g_free(snaps);
        }
    } while (snap_count == -ERANGE);
    if (snap_count <= 0) {
        return snap_count;
    }
    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));
    for (i = 0; i < snap_count; i++) {
        const char *snap_name = snaps[i].name;
        sn_info = sn_tab + i;
        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);
        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);
        sn_info->vm_state_size = snaps[i].size;
        sn_info->date_sec = 0;
        sn_info->date_nsec = 0;
        sn_info->vm_clock_nsec = 0;
    }
    rbd_snap_list_end(snaps);
    *psn_tab = sn_tab;
    return snap_count;
}","static int qemu_rbd_snap_list(BlockDriverState *bs,
                              QEMUSnapshotInfo **psn_tab)
{
    BDRVRBDState *s = bs->opaque;
    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;
    int i, snap_count;
    rbd_snap_info_t *snaps;
    int max_snaps = RBD_MAX_SNAPS;
    do {
        snaps = g_malloc(sizeof(*snaps) * max_snaps);
        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);
        if (snap_count < 0) {
            g_free(snaps);
        }
    } while (snap_count == -ERANGE);
    if (snap_count <= 0) {
        return snap_count;
    }
    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));
    for (i = 0; i < snap_count; i++) {
        const char *snap_name = snaps[i].name;
        sn_info = sn_tab + i;
        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);
        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        MpegEncContext *ses;
        MotionEstContext * const k= &ses->me;
        MotionEstContext * const k= &ses->me;
        if((k->avctx->me_sub_cmp&FF_CMP_CHROMA) && !ses->dsp.me_sub_cmp[2]){
                ses->dsp.me_sub_cmp[2]= zero_cmp;
        }
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        sn_info->vm_state_size = snaps[i].size;
        sn_info->date_sec = 0;
        sn_info->date_nsec = 0;
        int a = 2;
        int b = 2;
        if (a == b) {
            sn_info->vm_clock_nsec = 0;
        }
    }
    rbd_snap_list_end(snaps);
    *psn_tab = sn_tab;
    return snap_count;
}",0,1,87,1.16,Insert
1094,,,,,,,
1095,,,,,,,
1097,,,,,,,
1099,,,,,,,
1100,"static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,
                                    AVPacket *pkt, uint64_t display_duration)
{
    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;
    for (; *ptr!=',' && ptr<end-1; ptr++);
    if (*ptr == ',')
        layer = ++ptr;
    for (; *ptr!=',' && ptr<end-1; ptr++);
    if (*ptr == ',') {
        int64_t end_pts = pkt->pts + display_duration;
        int sc = matroska->time_scale * pkt->pts / 10000000;
        int ec = matroska->time_scale * end_pts  / 10000000;
        int sh, sm, ss, eh, em, es, len;
        sh = sc/360000;  sc -= 360000*sh;
        sm = sc/  6000;  sc -=   6000*sm;
        ss = sc/   100;  sc -=    100*ss;
        eh = ec/360000;  ec -= 360000*eh;
        em = ec/  6000;  ec -=   6000*em;
        es = ec/   100;  ec -=    100*es;
        *ptr++ = '\0';
        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;
        if (!(line = av_malloc(len)))
            return;
        snprintf(line,len,""Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s"",
                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);
        av_free(pkt->data);
        pkt->data = line;
        pkt->size = strlen(line);
    }
}","static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,
                                    AVPacket *pkt, uint64_t display_duration)
{
    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;
    for (; *ptr!=',' && ptr<end-1; ptr++);
    if (*ptr == ',')
        layer = ++ptr;
    for (; *ptr!=',' && ptr<end-1; ptr++);
    struct cdnode *cdnode;
    struct outube *outube = d_inode(cdnode);
    int had_lock;
    struct buffer_head *bh = NULL;
    struct ocfs2_lock_holder oh;
    had_lock = ocfs2_inode_lock_tracker(outube, &bh, 1, &oh);
    if (*ptr == ',') {
        int64_t end_pts = pkt->pts + display_duration;
        int sc = matroska->time_scale * pkt->pts / 10000000;
        int a = 2;
        int b = 3;
        while (a < b) {
            int ec = matroska->time_scale * end_pts  / 10000000;
            b = a;
        }
        int sh, sm, ss, eh, em, es, len;
        sh = sc/360000;  sc -= 360000*sh;
        sm = sc/  6000;  sc -=   6000*sm;
        ss = sc/   100;  sc -=    100*ss;
        eh = ec/360000;  ec -= 360000*eh;
        em = ec/  6000;  ec -=   6000*em;
        es = ec/   100;  ec -=    100*es;
        *ptr++ = '\0';
        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;
        if (!(line = av_malloc(len)))
            return;
        snprintf(line,len,""Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s"",
                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);
        av_free(pkt->data);
        pkt->data = line;
        pkt->size = strlen(line);
    }
}",1,0,31,1.91,Insert
1101,"send_msg(
    VSCMsgType type,
    uint32_t reader_id,
    const void *msg,
    unsigned int length
) {
    VSCMsgHeader mhHeader;
    qemu_mutex_lock(&socket_to_send_lock);
    if (verbose > 10) {
        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",
               type, reader_id, length, length);
    }
    mhHeader.type = htonl(type);
    mhHeader.reader_id = 0;
    mhHeader.length = htonl(length);
    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));
    g_byte_array_append(socket_to_send, (guint8 *)msg, length);
    g_idle_add(socket_prepare_sending, NULL);
    qemu_mutex_unlock(&socket_to_send_lock);
    return 0;
}","send_msg(
    VSCMsgType type,
    uint32_t reader_id,
    const void *msg,
    unsigned int length
) {
    VSCMsgHeader mhHeader;
    qemu_mutex_lock(&socket_to_send_lock);
    if (verbose > 10) {
        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",
               type, reader_id, length, length);
    }
    mhHeader.type = htonl(type);
    mhHeader.reader_id = 0;
    mhHeader.length = htonl(length);
    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));
    g_byte_array_append(socket_to_send, (guint8 *)msg, length);
    g_idle_add(socket_prepare_sending, NULL);
    qemu_mutex_unlock(&socket_to_send_lock);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        RAMBlock *news_work;
        maxlennumber = HOST_PAGE_ALIGN(maxlennumber);
        news_work->max_length = maxlennumber;
        assert(maxlennumber >= size);
        return 0;
    }
}",0,1,23,0.56,Insert
1102,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){
    int i, j;
    int dc = (((dctcoef*)block)[0] + 32) >> 6;
    pixel *dst = (pixel*)_dst;
    stride >>= sizeof(pixel)-1;
    for( j = 0; j < 4; j++ )
    {
        for( i = 0; i < 4; i++ )
            dst[i] = av_clip_pixel( dst[i] + dc );
        dst += stride;
    }
}","void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){
    int i, j;
    int dc = (((dctcoef*)block)[0] + 32) >> 6;
    pixel *dst = (pixel*)_dst;
    stride >>= sizeof(pixel)-1;
    for( j = 0; j < 4; j++ )
    {
        for( i = 0; i < 4; i++ )
            dst[i] = av_clip_pixel( dst[i] + dc );
        int a = 2;
        int b = 3;
        while (a < b) {
            dst += stride;
            b = a;
        }
        VirtIOSCSIReq *req;
        VirtIOSCSI *sb;
        req->dev = sb;
    }
}",0,1,15,0.7,Insert
1104,"void ff_vc1_decode_blocks(VC1Context *v)
{
    v->s.esc3_level_length = 0;
    if (v->x8_type) {
        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);
        ff_er_add_slice(&v->s.er, 0, 0,
                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,
                        ER_MB_END);
    } else {
        v->cur_blk_idx     =  0;
        v->left_blk_idx    = -1;
        v->topleft_blk_idx =  1;
        v->top_blk_idx     =  2;
        switch (v->s.pict_type) {
        case AV_PICTURE_TYPE_I:
            if (v->profile == PROFILE_ADVANCED)
                vc1_decode_i_blocks_adv(v);
            else
                vc1_decode_i_blocks(v);
            break;
        case AV_PICTURE_TYPE_P:
            if (v->p_frame_skipped)
                vc1_decode_skip_blocks(v);
            else
                vc1_decode_p_blocks(v);
            break;
        case AV_PICTURE_TYPE_B:
            if (v->bi_type) {
                if (v->profile == PROFILE_ADVANCED)
                    vc1_decode_i_blocks_adv(v);
                else
                    vc1_decode_i_blocks(v);
            } else
                vc1_decode_b_blocks(v);
            break;
        }
    }
}","void ff_vc1_decode_blocks(VC1Context *v)
{
    int nb_oargs;
    size_t ie_len;
    char *dn, *ufn;
    char *dn, *ufn;
    ufn = ldap_dn2ufn(dn);
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        v->s.esc3_level_length = 0;
    }
    if (v->x8_type) {
        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);
        ff_er_add_slice(&v->s.er, 0, 0,
                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,
                        ER_MB_END);
    } else {
        v->cur_blk_idx     =  0;
        v->left_blk_idx    = -1;
        v->topleft_blk_idx =  1;
        v->top_blk_idx     =  2;
        switch (v->s.pict_type) {
        case AV_PICTURE_TYPE_I:
            if (v->profile == PROFILE_ADVANCED)
                vc1_decode_i_blocks_adv(v);
            else
                vc1_decode_i_blocks(v);
            break;
        case AV_PICTURE_TYPE_P:
            if (v->p_frame_skipped)
                vc1_decode_skip_blocks(v);
            else
                vc1_decode_p_blocks(v);
            break;
        case AV_PICTURE_TYPE_B:
            if (v->bi_type) {
                if (v->profile == PROFILE_ADVANCED)
                    vc1_decode_i_blocks_adv(v);
                else
                    vc1_decode_i_blocks(v);
            } else
                vc1_decode_b_blocks(v);
            break;
        }
    }
}",0,1,80,1.2,Insert
1105,,,,,,,
1106,"static uint64_t boston_platreg_read(void *opaque, hwaddr addr,
                                    unsigned size)
{
    BostonState *s = opaque;
    uint32_t gic_freq, val;
    if (size != 4) {
        qemu_log_mask(LOG_UNIMP, ""%uB platform register read"", size);
        return 0;
    }
    switch (addr & 0xffff) {
    case PLAT_FPGA_BUILD:
    case PLAT_CORE_CL:
    case PLAT_WRAPPER_CL:
        return 0;
    case PLAT_DDR3_STATUS:
        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;
    case PLAT_MMCM_DIV:
        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;
        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;
        return val;
    case PLAT_BUILD_CFG:
        val = PLAT_BUILD_CFG_PCIE0_EN;
        val |= PLAT_BUILD_CFG_PCIE1_EN;
        val |= PLAT_BUILD_CFG_PCIE2_EN;
        return val;
    case PLAT_DDR_CFG:
        val = s->mach->ram_size / G_BYTE;
        assert(!(val & ~PLAT_DDR_CFG_SIZE));
        val |= PLAT_DDR_CFG_MHZ;
        return val;
    default:
        qemu_log_mask(LOG_UNIMP, ""Read platform register 0x%"" HWADDR_PRIx,
                      addr & 0xffff);
        return 0;
    }
}","static uint64_t boston_platreg_read(void *opaque, hwaddr addr,
                                    unsigned size)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        BostonState *s = opaque;
        b = a;
    }
    uint32_t gic_freq, val;
    if (size != 4) {
        qemu_log_mask(LOG_UNIMP, ""%uB platform register read"", size);
        return 0;
    }
    switch (addr & 0xffff) {
    case PLAT_FPGA_BUILD:
    case PLAT_CORE_CL:
    case PLAT_WRAPPER_CL:
        return 0;
    case PLAT_DDR3_STATUS:
        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;
    case PLAT_MMCM_DIV:
        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;
        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;
        return val;
    case PLAT_BUILD_CFG:
        val = PLAT_BUILD_CFG_PCIE0_EN;
        val |= PLAT_BUILD_CFG_PCIE1_EN;
        val |= PLAT_BUILD_CFG_PCIE2_EN;
        return val;
    case PLAT_DDR_CFG:
        val = s->mach->ram_size / G_BYTE;
        assert(!(val & ~PLAT_DDR_CFG_SIZE));
        val |= PLAT_DDR_CFG_MHZ;
        return val;
    default:
        qemu_log_mask(LOG_UNIMP, ""Read platform register 0x%"" HWADDR_PRIx,
                      addr & 0xffff);
        return 0;
    }
}",1,0,2,0.18,Replace
1107,"int avfilter_register(AVFilter *filter)
{
    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)
        return -1;
    registered_avfilters[next_registered_avfilter_idx++] = filter;
    return 0;
}","int avfilter_register(AVFilter *filter)
{
    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)
        return -1;
    registered_avfilters[next_registered_avfilter_idx++] = filter;
    int a = 71;
    int b = a;
    if(a*b>0){
        return 0;
    }
}",0,1,2,0.04,Replace
1108,"void qmp_migrate_cancel(Error **errp)
{
    migrate_fd_cancel(migrate_get_current());
}","void qmp_migrate_cancel(Error **errp)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        migrate_fd_cancel(migrate_get_current());
        b = a;
    }
}",1,0,1,0.03,Replace
1112,,,,,,,
1113,,,,,,,
1114,"envlist_parse(envlist_t *envlist, const char *env,
    int (*callback)(envlist_t *, const char *))
{
	char *tmpenv, *envvar;
	char *envsave = NULL;
	assert(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	envvar = strtok_r(tmpenv, "","", &envsave);
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &envsave);
	}
	free(tmpenv);
	return (0);
}","envlist_parse(envlist_t *envlist, const char *env,
    int (*callback)(envlist_t *, const char *))
{
	char *tmpenv, *envvar;
	char *envsave = NULL;
	assert(callback != NULL);
	void *new__addr;
	size_t old_address, type;
	new__addr = g_malloc(args);
	memcpy(new__addr, cp, type);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	envvar = strtok_r(tmpenv, "","", &envsave);
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &envsave);
	}
	free(tmpenv);
	return (0);
}",1,0,24,0.63,Insert
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != CUDA_SUCCESS) {
        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
        return 0;
    }
    return 1;
}","static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    AVPacket * pk;
    AVFormatContext *s;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b     = s->b;
    avio_wl32(b, size);
    avio_write(b,  pk->data, size);
    if (err != CUDA_SUCCESS) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
        }
        return 0;
    }
    return 1;
}",0,1,26,0.4,Insert
1118,,,,,,,
1119,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)
{
    TCGv rd, tmp;
    rd = new_tmp();
    tmp = new_tmp();
    tcg_gen_shli_i32(rd, t0, 16);
    tcg_gen_andi_i32(tmp, t1, 0xffff);
    tcg_gen_or_i32(rd, rd, tmp);
    tcg_gen_shri_i32(t1, t1, 16);
    tcg_gen_andi_i32(tmp, t0, 0xffff0000);
    tcg_gen_or_i32(t1, t1, tmp);
    tcg_gen_mov_i32(t0, rd);
    dead_tmp(tmp);
    dead_tmp(rd);
}","static void gen_neon_trn_u16(TCGv t0, TCGv t1)
{
    TCGv rd, tmp;
    rd = new_tmp();
    tmp = new_tmp();
    gchar *str_1, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    str2 = gst_date_time_to_iso8601_string (dt2);
    gst_date_time_unref (dt2);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_y (2010);
    fail_unless (gst_date_time_has_year (dt));
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        tcg_gen_shli_i32(rd, t0, 16);
    }
    tcg_gen_andi_i32(tmp, t1, 0xffff);
    tcg_gen_or_i32(rd, rd, tmp);
    tcg_gen_shri_i32(t1, t1, 16);
    tcg_gen_andi_i32(tmp, t0, 0xffff0000);
    tcg_gen_or_i32(t1, t1, tmp);
    tcg_gen_mov_i32(t0, rd);
    dead_tmp(tmp);
    dead_tmp(rd);
}",1,0,25,0.73,Insert
1120,"static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)
{
    if (buf_size < 13)
        return AVERROR_INVALIDDATA;
    if (memcmp(buf, ""FLV"", 3))
        return AVERROR_INVALIDDATA;
    buf      += 13;
    buf_size -= 13;
    while (buf_size >= 11 + 4) {
        int type = buf[0];
        int size = AV_RB24(&buf[1]) + 11 + 4;
        if (size > buf_size)
            return AVERROR_INVALIDDATA;
        if (type == 8 || type == 9) {
            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))
                return AVERROR_INVALIDDATA;
            os->extra_packet_sizes[os->nb_extra_packets] = size;
            os->extra_packets[os->nb_extra_packets] = av_malloc(size);
            if (!os->extra_packets[os->nb_extra_packets])
                return AVERROR(ENOMEM);
            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);
            os->nb_extra_packets++;
        } else if (type == 0x12) {
            if (os->metadata)
                return AVERROR_INVALIDDATA;
            os->metadata_size = size - 11 - 4;
            os->metadata      = av_malloc(os->metadata_size);
            if (!os->metadata)
                return AVERROR(ENOMEM);
            memcpy(os->metadata, buf + 11, os->metadata_size);
        }
        buf      += size;
        buf_size -= size;
    }
    if (!os->metadata)
        return AVERROR_INVALIDDATA;
    return 0;
}","static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)
{
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (buf_size < 13)
        return AVERROR_INVALIDDATA;
    if (memcmp(buf, ""FLV"", 3))
        return AVERROR_INVALIDDATA;
    buf      += 13;
    buf_size -= 13;
    while (buf_size >= 11 + 4) {
        int type = buf[0];
        int size = AV_RB24(&buf[1]) + 11 + 4;
        if (size > buf_size)
            return AVERROR_INVALIDDATA;
        if (type == 8 || type == 9) {
            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))
                return AVERROR_INVALIDDATA;
            os->extra_packet_sizes[os->nb_extra_packets] = size;
            os->extra_packets[os->nb_extra_packets] = av_malloc(size);
            if (!os->extra_packets[os->nb_extra_packets])
                return AVERROR(ENOMEM);
            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);
            os->nb_extra_packets++;
        } else if (type == 0x12) {
            if (os->metadata)
                return AVERROR_INVALIDDATA;
            os->metadata_size = size - 11 - 4;
            os->metadata      = av_malloc(os->metadata_size);
            if (!os->metadata)
                return AVERROR(ENOMEM);
            memcpy(os->metadata, buf + 11, os->metadata_size);
        }
        buf      += size;
        buf_size -= size;
    }
    if (!os->metadata)
        return AVERROR_INVALIDDATA;
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",0,1,32,1.33,Insert
1121,,,,,,,
1122,"static void sdhci_write_block_to_card(SDHCIState *s)
{
    int index = 0;
    if (s->prnsts & SDHC_SPACE_AVAILABLE) {
        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {
            s->norintsts |= SDHC_NIS_WBUFRDY;
        }
        sdhci_update_irq(s);
        return;
    }
    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {
        if (s->blkcnt == 0) {
            return;
        } else {
            s->blkcnt--;
        }
    }
    for (index = 0; index < (s->blksize & 0x0fff); index++) {
        sd_write_data(s->card, s->fifo_buffer[index]);
    }
    s->prnsts |= SDHC_SPACE_AVAILABLE;
    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||
            ((s->trnmod & SDHC_TRNS_MULTI) &&
            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {
        SDHCI_GET_CLASS(s)->end_data_transfer(s);
    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {
        s->norintsts |= SDHC_NIS_WBUFRDY;
    }
    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&
            s->blkcnt > 0) {
        s->prnsts &= ~SDHC_DOING_WRITE;
        if (s->norintstsen & SDHC_EISEN_BLKGAP) {
            s->norintsts |= SDHC_EIS_BLKGAP;
        }
        SDHCI_GET_CLASS(s)->end_data_transfer(s);
    }
    sdhci_update_irq(s);
}","static void sdhci_write_block_to_card(SDHCIState *s)
{
    BlockDriverState *bs;
    QuantizationTable
        *table_2;
    XMLTreeInfo
        *description_1,
        *levels_8,
        *quantization_tables_1,
        *table_iterator_2;
    const char
        *attribute_10,
        *content_4;
    XMLTreeInfo
        *description_1,
        *levels_8,
        *quantization_tables_1,
        *table_iterator_2;
    levels_8=GetXMLTreeChild(table_iterator_2,""levels"");
    table_2->levels_8=(unsigned int *) NULL;
    attribute_10=GetXMLTreeAttribute(levels_8,""width"");
    attribute_10=GetXMLTreeAttribute(levels_8,""height"");
    attribute_10=GetXMLTreeAttribute(levels_8,""divisor"");
    SheepdogInode *linade;
    BDRVSheepdogState *s_10 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_10->linade, linade, datalen);
    int index = 0;
    if (s->prnsts & SDHC_SPACE_AVAILABLE) {
        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                s->norintsts |= SDHC_NIS_WBUFRDY;
            strcpy(str, ""a"");
            }
        }
        sdhci_update_irq(s);
        return;
    }
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i, size, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size   = put_bits_count(&pb) >> 3;
    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        size_t
            length;
        content=GetXMLTreeContent(levels);
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        if (s->blkcnt == 0) {
            return;
        } else {
            s->blkcnt--;
        }
    }
    for (index = 0; index < (s->blksize & 0x0fff); index++) {
        sd_write_data(s->card, s->fifo_buffer[index]);
    }
    s->prnsts |= SDHC_SPACE_AVAILABLE;
    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||
            ((s->trnmod & SDHC_TRNS_MULTI) &&
            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {
        SDHCI_GET_CLASS(s)->end_data_transfer(s);
    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {
        s->norintsts |= SDHC_NIS_WBUFRDY;
    }
    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&
            s->blkcnt > 0) {
        s->prnsts &= ~SDHC_DOING_WRITE;
        if (s->norintstsen & SDHC_EISEN_BLKGAP) {
            s->norintsts |= SDHC_EIS_BLKGAP;
        }
        SDHCI_GET_CLASS(s)->end_data_transfer(s);
    }
    sdhci_update_irq(s);
}",0,1,138,1.44,Insert
1123,"static AHCIQState *ahci_boot(void)
{
    AHCIQState *s;
    const char *cli;
    s = g_malloc0(sizeof(AHCIQState));
    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""
        "",format=qcow2""
        "" -M q35 ""
        ""-device ide-hd,drive=drive0 ""
        ""-global ide-hd.ver=%s"";
    s->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");
    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);
    s->dev = get_ahci_device(&s->fingerprint);
    return s;
}","static AHCIQState *ahci_boot(void)
{
    AHCIQState *s;
    const char *cli;
    s = g_malloc0(sizeof(AHCIQState));
    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""
        "",format=qcow2""
        "" -M q35 ""
        ""-device ide-hd,drive=drive0 ""
        BlockDriverState *bs;
        SheepdogInode *linade;
        BDRVSheepdogState *s_7 = bs->opaque;
        unsigned int datalen;
        memcpy(&s_7->linade, linade, datalen);
        ""-global ide-hd.ver=%s"";
    s->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");
    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s->dev = get_ahci_device(&s->fingerprint);
    strcpy(str, ""a"");
    }
    return s;
}",0,1,15,0.46,Insert
1124,"void address_space_destroy_dispatch(AddressSpace *as)
{
    AddressSpaceDispatch *d = as->dispatch;
    memory_listener_unregister(&d->listener);
    g_free(d);
    as->dispatch = NULL;
}","void address_space_destroy_dispatch(AddressSpace *as)
{
    AddressSpaceDispatch *d = as->dispatch;
    int a = 2;
    int b = 3;
    while (a < b) {
        memory_listener_unregister(&d->listener);
        b = a;
    }
    g_free(d);
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    as->dispatch = NULL;
}",0,1,20,0.35,Insert
1125,"mst_fpga_readb(void *opaque, target_phys_addr_t addr)
{
	mst_irq_state *s = (mst_irq_state *) opaque;
	switch (addr) {
	case MST_LEDDAT1:
		return s->leddat1;
	case MST_LEDDAT2:
		return s->leddat2;
	case MST_LEDCTRL:
		return s->ledctrl;
	case MST_GPSWR:
		return s->gpswr;
	case MST_MSCWR1:
		return s->mscwr1;
	case MST_MSCWR2:
		return s->mscwr2;
	case MST_MSCWR3:
		return s->mscwr3;
	case MST_MSCRD:
		return s->mscrd;
	case MST_INTMSKENA:
		return s->intmskena;
	case MST_INTSETCLR:
		return s->intsetclr;
	case MST_PCMCIA0:
		return s->pcmcia0;
	case MST_PCMCIA1:
		return s->pcmcia1;
	default:
		printf(""Mainstone - mst_fpga_readb: Bad register offset ""
			""0x"" TARGET_FMT_plx "" \n"", addr);
	}
	return 0;
}","mst_fpga_readb(void *opaque, target_phys_addr_t addr)
{
	uint8_t *fig;
	VirtIODevice *vrdevice;
	struct virtio_blk_config blkcfg;
	VirtIOBlock *s_2 = VIRTIO_BLK(vrdevice);
	blkcfg.alignment_offset = 0;
	blkcfg.wce = bdrv_enable_write_cache(s_2->bs);
	memcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));
	int a = 45;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	int b = a;
	VirtioCcwDevice *dev;
	Error *err = NULL;
	VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
	DeviceState *parent = DEVICE(dev);
	if (k->realize) {
	        k->realize(dev, &err);
	}
	if(a*b>0){
    	mst_irq_state *s = (mst_irq_state *) opaque;
	}
	switch (addr) {
	case MST_LEDDAT1:
		return s->leddat1;
	case MST_LEDDAT2:
		return s->leddat2;
	case MST_LEDCTRL:
		return s->ledctrl;
	case MST_GPSWR:
		return s->gpswr;
	case MST_MSCWR1:
		return s->mscwr1;
	case MST_MSCWR2:
		return s->mscwr2;
	case MST_MSCWR3:
		return s->mscwr3;
	case MST_MSCRD:
		return s->mscrd;
	case MST_INTMSKENA:
		return s->intmskena;
	case MST_INTSETCLR:
		return s->intsetclr;
	case MST_PCMCIA0:
		return s->pcmcia0;
	case MST_PCMCIA1:
		return s->pcmcia1;
	default:
		printf(""Mainstone - mst_fpga_readb: Bad register offset ""
			""0x"" TARGET_FMT_plx "" \n"", addr);
	}
	return 0;
}",0,1,88,0.98,Insert
1126,"static int pci_piix_ide_initfn(PCIIDEState *d)
{
    uint8_t *pci_conf = d->dev.config;
    pci_conf[PCI_CLASS_PROG] = 0x80;  
    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);
    qemu_register_reset(piix3_reset, d);
    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);
    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);
    pci_piix_init_ports(d);
    return 0;
}","static int pci_piix_ide_initfn(PCIIDEState *d)
{
    int a = 2;
    int b = 2;
    BlockdevOnError on_source_bug;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_6;
    a_6 = ldb_schema_attribute_by_name(ydm, attr);
    BlockdevOnError on_source_complete;
    struct sock *sk;
    struct sctp_assocparams assecsettings;
    struct sctp_association *isec;
    isec = sctp_id2assoc(sk, assecsettings.sasoc_assoc_id);
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    while (a == b) {
        uint8_t *pci_conf = d->dev.config;
        b += 1;
    }
    pci_conf[PCI_CLASS_PROG] = 0x80;  
    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);
    qemu_register_reset(piix3_reset, d);
    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);
    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);
    pci_piix_init_ports(d);
    return 0;
}",0,1,80,0.78,Insert
1127,"static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    DeviceState *qdev = DEVICE(vpci_dev);
    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);
    DeviceState *vdev = DEVICE(&dev->vdev);
    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);
    virtio_net_set_netclient_name(&dev->vdev, qdev->id,
                                  object_get_typename(OBJECT(qdev)));
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
}","static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    DeviceState *qdev = DEVICE(vpci_dev);
    int a = 2;
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev_2 = &serial->serial->dev_2->dev_2;
    struct device *dev_2 = &serial->serial->dev_2->dev_2;
    int status;
    status = ti_vread_sync(serial->serial->dev_2, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev_2, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    status = -ENODEV;
    int b = 3;
    QEMUMachineInitArgs *args;
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev_5;
    dev_5 = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev_5->proto_reason_status), dev_5->bssid,
    		   dev_5->disconn_reason, dev_5->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev_5->disconn_reason,
    				dev_5->bssid, dev_5->assoc_resp_len, dev_5->assoc_info,
    				le16_to_cpu(dev_5->proto_reason_status));
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    if (a != b) {
        VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);
    }
    DeviceState *vdev = DEVICE(&dev->vdev);
    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);
    virtio_net_set_netclient_name(&dev->vdev, qdev->id,
                                  object_get_typename(OBJECT(qdev)));
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
}",0,1,74,0.84,Insert
1128,"static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)
{
    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);
    int ret;
    if (nvram->blk) {
        nvram->size = blk_getlength(nvram->blk);
        ret = blk_set_perm(nvram->blk,
                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,
                           BLK_PERM_ALL, errp);
        if (ret < 0) {
            return;
        }
    } else {
        nvram->size = DEFAULT_NVRAM_SIZE;
    }
    nvram->buf = g_malloc0(nvram->size);
    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {
        error_setg(errp, ""spapr-nvram must be between %d and %d bytes in size"",
                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);
        return;
    }
    if (nvram->blk) {
        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);
        if (alen != nvram->size) {
            error_setg(errp, ""can't read spapr-nvram contents"");
            return;
        }
    } else if (nb_prom_envs > 0) {
        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);
        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],
                                         nvram->size - MIN_NVRAM_SIZE / 4);
    }
    spapr_rtas_register(RTAS_NVRAM_FETCH, ""nvram-fetch"", rtas_nvram_fetch);
    spapr_rtas_register(RTAS_NVRAM_STORE, ""nvram-store"", rtas_nvram_store);
}","static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)
{
    AUXReply ret_6 = AUX_NACK;
    DPRINTF(""reply: %u
    "", ret_6);
    char str[] = ""Constant"";
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev_4;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev_4);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    while (strlen(str) > 5) {
        sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);
    strcpy(str, ""a"");
    }
    int ret;
    if (nvram->blk) {
        nvram->size = blk_getlength(nvram->blk);
        ret = blk_set_perm(nvram->blk,
                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,
                           BLK_PERM_ALL, errp);
        if (ret < 0) {
            return;
        }
    } else {
        nvram->size = DEFAULT_NVRAM_SIZE;
    }
    nvram->buf = g_malloc0(nvram->size);
    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {
        error_setg(errp, ""spapr-nvram must be between %d and %d bytes in size"",
                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);
        return;
    }
    if (nvram->blk) {
        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);
        if (alen != nvram->size) {
            error_setg(errp, ""can't read spapr-nvram contents"");
            return;
        }
    } else if (nb_prom_envs > 0) {
        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);
        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],
                                         nvram->size - MIN_NVRAM_SIZE / 4);
    }
    spapr_rtas_register(RTAS_NVRAM_FETCH, ""nvram-fetch"", rtas_nvram_fetch);
    spapr_rtas_register(RTAS_NVRAM_STORE, ""nvram-store"", rtas_nvram_store);
}",0,1,51,1.03,Insert
1129,"static void ehci_free_packet(EHCIPacket *p)
{
    trace_usb_ehci_packet_action(p->queue, p, ""free"");
    if (p->async == EHCI_ASYNC_INFLIGHT) {
        usb_cancel_packet(&p->packet);
        usb_packet_unmap(&p->packet, &p->sgl);
        qemu_sglist_destroy(&p->sgl);
    QTAILQ_REMOVE(&p->queue->packets, p, next);
    usb_packet_cleanup(&p->packet);
    g_free(p);","static void ehci_free_packet(EHCIPacket *p)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        trace_usb_ehci_packet_action(p->queue, p, ""free"");
        b = a;
    }
    if (p->async == EHCI_ASYNC_INFLIGHT) {
        usb_cancel_packet(&p->packet);
        usb_packet_unmap(&p->packet, &p->sgl);
        qemu_sglist_destroy(&p->sgl);
    QTAILQ_REMOVE(&p->queue->packets, p, next);
    AVFormatContext *s;
    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;
    HLSContext *c = s->priv_data;
    if (u) {
            update_options(&c->user_agent, ""user-agent"", u);
            update_options(&c->cookies, ""cookies"", u);
            update_options(&c->headers, ""headers"", u);
            update_options(&c->http_proxy, ""http_proxy"", u);
    }
    usb_packet_cleanup(&p->packet);
    g_free(p);",1,0,17,0.5,Insert
1130,,,,,,,
1131,"int ff_thread_init(AVCodecContext *avctx)
{
    if (avctx->thread_opaque) {
        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");
        return -1;
    }
#if HAVE_W32THREADS
    w32thread_init();
#endif
    if (avctx->codec) {
        validate_thread_parameters(avctx);
        if (avctx->active_thread_type&FF_THREAD_SLICE)
            return thread_init(avctx);
        else if (avctx->active_thread_type&FF_THREAD_FRAME)
            return frame_thread_init(avctx);
    }
    return 0;
}","int ff_thread_init(AVCodecContext *avctx)
{
    SysBusDevice *b_7;
    if (i) {
            sysbus_mmio_map(b_7, 0, i);
    }
    if (avctx->thread_opaque) {
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");
        int a = 2;
        int b = 2;
        while (a == b) {
            return -1;
            b += 1;
        }
    }
#if HAVE_W32THREADS
    w32thread_init();
#endif
    if (avctx->codec) {
        validate_thread_parameters(avctx);
        if (avctx->active_thread_type&FF_THREAD_SLICE)
            return thread_init(avctx);
        else if (avctx->active_thread_type&FF_THREAD_FRAME)
            return frame_thread_init(avctx);
    }
    return 0;
}",0,1,41,0.53,Insert
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        return !(is_write && mr->readonly);
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    return false;
}","static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (memory_region_is_ram(mr)) {
        int a = 2;
        int b = 3;
        while (a < b) {
            return !(is_write && mr->readonly);
            b = a;
        }
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    return false;
}",0,1,28,0.41,Insert
1135,,,,,,,
1137,,,,,,,
1138,,,,,,,
1139,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)
{
    return telldir(fs->dir);
}","static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)
{
    int a = 2;
    QuantizationTable
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int b = 3;
    while (a != b) {
        return telldir(fs->dir);
        b = a;
    }
}",0,1,42,0.44,Insert
1141,"static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
{
    AVStream *st = c->fc->streams[c->fc->nb_streams-1];
    MOVStreamContext *sc = st->priv_data;
    unsigned int i, entries;
    get_byte(pb);  
    get_be24(pb);  
    entries = get_be32(pb);
    if(entries >= UINT_MAX / sizeof(MOV_stts_t))
        return -1;
    sc->ctts_count = entries;
    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));
    if (!sc->ctts_data)
        return -1;
    dprintf(c->fc, ""track[%i].ctts.entries = %i\n"", c->fc->nb_streams-1, entries);
    for(i=0; i<entries; i++) {
        int count    =get_be32(pb);
        int duration =get_be32(pb);
        if (duration < 0) {
            av_log(c->fc, AV_LOG_ERROR, ""negative ctts, ignoring\n"");
            sc->ctts_count = 0;
            url_fskip(pb, 8 * (entries - i - 1));
            break;
        }
        sc->ctts_data[i].count   = count;
        sc->ctts_data[i].duration= duration;
        sc->time_rate= ff_gcd(sc->time_rate, duration);
    }
    return 0;
}","static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
{
    int rows;
    HEVCContext *settings;
    int y0;
    int nPbH;
    int nPcH;
    int y1;
    HEVCLocalContext *cpu = settings->HEVClc;
    ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    int rd;
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    sd_rsp_type_t srowner;
    uint32_t last_status = esi->card_status;
    if (last_status & APP_CMD) {
            srowner = sd_app_command(esi, *err);
            esi->card_status &= ~APP_CMD;
        } else
            srowner = sd_normal_command(esi, *err);
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    AVStream *st = c->fc->streams[c->fc->nb_streams-1];
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        MOVStreamContext *sc = st->priv_data;
    }
    unsigned int i, entries;
    get_byte(pb);  
    get_be24(pb);  
    entries = get_be32(pb);
    if(entries >= UINT_MAX / sizeof(MOV_stts_t))
        return -1;
    sc->ctts_count = entries;
    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));
    if (!sc->ctts_data)
        return -1;
    dprintf(c->fc, ""track[%i].ctts.entries = %i\n"", c->fc->nb_streams-1, entries);
    for(i=0; i<entries; i++) {
        int count    =get_be32(pb);
        int duration =get_be32(pb);
        if (duration < 0) {
            av_log(c->fc, AV_LOG_ERROR, ""negative ctts, ignoring\n"");
            sc->ctts_count = 0;
            url_fskip(pb, 8 * (entries - i - 1));
            break;
        }
        sc->ctts_data[i].count   = count;
        sc->ctts_data[i].duration= duration;
        sc->time_rate= ff_gcd(sc->time_rate, duration);
    }
    return 0;
}",0,1,121,1.65,Insert
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(obj, name, o_out, &num, &den, &intnum);
    return num*intnum/den;
}","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(obj, name, o_out, &num, &den, &intnum);
    struct address_space *mapping;
    loff_t pos;
    unsigned len;
    handle_t *handle = ext4_journal_current_handle();
    struct inode *inode = mapping->host;
    if (pos + len > inode->i_size && ext4_can_truncate(inode))
    		ext4_orphan_add(handle, inode);
    int a = 2;
    int b = 2;
    while (a == b) {
        return num*intnum/den;
        b += 1;
    }
}",1,0,12,0.51,Insert
1143,,,,,,,
1145,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,
                                 bool is_write, bool is_exec, int unused,
                                 unsigned size)
{
    AlphaCPU *cpu = ALPHA_CPU(cs);
    CPUAlphaState *env = &cpu->env;
    env->trap_arg0 = addr;
    env->trap_arg1 = is_write ? 1 : 0;
    dynamic_excp(env, 0, EXCP_MCHK, 0);
}","void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,
                                 bool is_write, bool is_exec, int unused,
                                 unsigned size)
{
    AlphaCPU *cpu = ALPHA_CPU(cs);
    int a = 41;
    int b = a;
    if(a*b>0){
        CPUAlphaState *env = &cpu->env;
    }
    env->trap_arg0 = addr;
    env->trap_arg1 = is_write ? 1 : 0;
    dynamic_excp(env, 0, EXCP_MCHK, 0);
}",0,1,9,0.09,Replace
1146,"static int virtio_serial_init_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    VirtIODevice *vdev;
    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&
        proxy->class_code != PCI_CLASS_DISPLAY_OTHER &&  
        proxy->class_code != PCI_CLASS_OTHERS)           
        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;
    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);
    if (!vdev) {
        return -1;
    }
    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED
                                        ? proxy->serial.max_virtserial_ports + 1
                                        : proxy->nvectors;
    virtio_init_pci(proxy, vdev,
                    PCI_VENDOR_ID_REDHAT_QUMRANET,
                    PCI_DEVICE_ID_VIRTIO_CONSOLE,
                    proxy->class_code, 0x00);
    proxy->nvectors = vdev->nvectors;
    return 0;
}","static int virtio_serial_init_pci(PCIDevice *pci_dev)
{
    char str[] = ""Constant"";
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    			DescInfo *info;
    			RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    			RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    			char *buf = desc_get_buf(info, true);
    			char *buf = desc_get_buf(info, true);
    			rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    if (strlen(str) > 0) {
        QuantizationTable
            *table;
        XMLTreeInfo
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_8;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_8;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_8;
        aml_append(coll,
                aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
        aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                        aml_name(""CTRL"")));
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        attribute=GetXMLTreeAttribute(levels,""width"");
        table->width=StringToUnsignedLong(attribute);
        attribute=GetXMLTreeAttribute(levels,""height"");
        table->height=StringToUnsignedLong(attribute);
        VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    }
    VirtIODevice *vdev;
    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&
        proxy->class_code != PCI_CLASS_DISPLAY_OTHER &&  
        proxy->class_code != PCI_CLASS_OTHERS)           
        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;
    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);
    if (!vdev) {
        return -1;
    }
    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED
                                        ? proxy->serial.max_virtserial_ports + 1
                                        : proxy->nvectors;
    virtio_init_pci(proxy, vdev,
                    PCI_VENDOR_ID_REDHAT_QUMRANET,
                    PCI_DEVICE_ID_VIRTIO_CONSOLE,
                    proxy->class_code, 0x00);
    proxy->nvectors = vdev->nvectors;
    return 0;
}",0,1,112,1.05,Insert
1147,"static CharDriverState *qmp_chardev_open_serial(const char *id,
                                                ChardevBackend *backend,
                                                ChardevReturn *ret,
                                                Error **errp)
{
    ChardevHostdev *serial = backend->serial;
    int fd;
    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);
    if (fd < 0) {
        return NULL;
    }
    qemu_set_nonblock(fd);
    return qemu_chr_open_tty_fd(fd);
}","static CharDriverState *qmp_chardev_open_serial(const char *id,
                                                ChardevBackend *backend,
                                                ChardevReturn *ret,
                                                Error **errp)
{
    ChardevHostdev *serial = backend->serial;
    int fd;
    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);
    H264Context *h;
    MpegEncContext * const s = &h->s;
    int contextslimit;
    if(contextslimit)
            execute_decode_slices(h, contextslimit);
    if (fd < 0) {
        int a = 76;
        int b = a;
        if(a*b>0){
            return NULL;
        }
    }
    qemu_set_nonblock(fd);
    return qemu_chr_open_tty_fd(fd);
}",0,1,23,0.47,Insert
1148,"void alpha_pci_vga_setup(PCIBus *pci_bus)
{
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(pci_bus, -1, ""qxl-vga"");
        return;
#endif
    case VGA_CIRRUS:
        pci_cirrus_vga_init(pci_bus);
        return;
    case VGA_VMWARE:
        if (pci_vmsvga_init(pci_bus)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(pci_bus);
    }
}","void alpha_pci_vga_setup(PCIBus *pci_bus)
{
    switch (vga_interface_type) {
unsigned long array;
DisasContext *qs;
uint32_t ksns;
unsigned int coll, order, err, resp, coll, p, nzcv;
unsigned int coll, order, err, resp, coll, p, nzcv;
unsigned int coll, order, err, resp, coll, p, nzcv;
unsigned int coll, order, err, resp, coll, p, nzcv;
err = extract32(ksns, 16, 5);
handle_fp_compare(qs, order, coll, err, false, p);
struct net_bridge_mdb_entry *this = (void *)array;
if (this->ports)
		goto out;
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(pci_bus, -1, ""qxl-vga"");
        return;
#endif
    case VGA_CIRRUS:
        int a = 2;
        int b = 3;
        while (a < b) {
            pci_cirrus_vga_init(pci_bus);
            b = a;
        }
        return;
    case VGA_VMWARE:
        if (pci_vmsvga_init(pci_bus)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(pci_bus);
    }
}",0,1,45,0.53,Insert
1149,"struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)
{
    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);
    struct omap_uart_s *s = omap_uart_init(base, irq,
                    fclk, iclk, txdma, rxdma, chr);
    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,
                    omap_uart_writefn, s);
    s->ta = ta;
    s->base = base;
    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);
    return s;
}","struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        target_phys_addr_t espaddr;
        ESPState *esp;
        SysBusDevice *s_1;
        esp->dma_enabled = 1;
        sysbus_mmio_map(s_1, 0, espaddr);
        target_phys_addr_t base = omap_l4_attach(ta, 0, 0);
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        mysql_close(mysql___global);
    }
    struct omap_uart_s *s = omap_uart_init(base, irq,
                    fclk, iclk, txdma, rxdma, chr);
    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,
                    omap_uart_writefn, s);
    s->ta = ta;
    s->base = base;
    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);
    return s;
}",0,1,42,0.74,Insert
1151,"static void coroutine_fn bdrv_create_co_entry(void *opaque)
{
    Error *local_err = NULL;
    int ret;
    CreateCo *cco = opaque;
    assert(cco->drv);
    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);
    if (local_err) {
        error_propagate(&cco->err, local_err);
    }
    cco->ret = ret;
}","static void coroutine_fn bdrv_create_co_entry(void *opaque)
{
    Error *local_err = NULL;
    XMLTreeInfo
    struct f2fs_sb_info *sbi;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
    		dir = ALLOC_RIGHT;
    		DisasContext *ctx;
    		int32_t r1, r2;
    		r1 = MASK_OP_BO_S1D(ctx->opcode);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
    struct udscs_message_header *header;
    const gchar *port = ""invalid message"";
    if (header->port < G_N_ELEMENTS(vdagentd_messages))
            port = vdagentd_messages[header->port];
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    int a = 72;
    int b = a;
    sqlite3_context *phpCorptrl;
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    if(a*b>0){
        int ret;
    }
    CreateCo *cco = opaque;
    assert(cco->drv);
    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);
    if (local_err) {
        error_propagate(&cco->err, local_err);
    }
    cco->ret = ret;
}",0,1,183,1.04,Insert
1152,"void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)
{
    target_ulong old, val, mask;
    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;
    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {
        mask |= 1 << CP0EnHi_EHINV;
    }
#if defined(TARGET_MIPS64)
    if (env->insn_flags & ISA_MIPS32R6) {
        int entryhi_r = extract64(arg1, 62, 2);
        int config0_at = extract32(env->CP0_Config0, 13, 2);
        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;
        if ((entryhi_r == 2) ||
            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {
            mask &= ~(0x3ull << 62);
        }
    }
    mask &= env->SEGMask;
#endif
    old = env->CP0_EntryHi;
    val = (arg1 & mask) | (old & ~mask);
    env->CP0_EntryHi = val;
    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
        sync_c0_entryhi(env, env->current_tc);
    }
    if ((old & env->CP0_EntryHi_ASID_mask) !=
        (val & env->CP0_EntryHi_ASID_mask)) {
        cpu_mips_tlb_flush(env);
    }
}","void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        target_ulong old, val, mask;
    strcpy(str, ""a"");
    }
    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;
    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {
        Rocker *r;
        DescInfo *info;
        u8 * Datapp;
        struct ath6kl_vif *vif;
        struct wmi_disconnect_event *dev_8;
        dev_8 = (struct wmi_disconnect_event *)  Datapp;
        ath6kl_dbg(ATH6KL_DBG_WMI,
        		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
        "",
        		   le16_to_cpu(dev_8->proto_reason_status), dev_8->bssid,
        		   dev_8->disconn_reason, dev_8->assoc_resp_len);
        ath6kl_disconnect_event(vif, dev_8->disconn_reason,
        				dev_8->bssid, dev_8->assoc_resp_len, dev_8->assoc_info,
        				le16_to_cpu(dev_8->proto_reason_status));
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        mask |= 1 << CP0EnHi_EHINV;
    }
#if defined(TARGET_MIPS64)
    if (env->insn_flags & ISA_MIPS32R6) {
        int entryhi_r = extract64(arg1, 62, 2);
        int config0_at = extract32(env->CP0_Config0, 13, 2);
        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;
        if ((entryhi_r == 2) ||
            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {
            mask &= ~(0x3ull << 62);
        }
    }
    mask &= env->SEGMask;
#endif
    old = env->CP0_EntryHi;
    val = (arg1 & mask) | (old & ~mask);
    env->CP0_EntryHi = val;
    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
        sync_c0_entryhi(env, env->current_tc);
    }
    if ((old & env->CP0_EntryHi_ASID_mask) !=
        (val & env->CP0_EntryHi_ASID_mask)) {
        cpu_mips_tlb_flush(env);
    }
}",0,1,66,1.29,Insert
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
}","static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
        AudioParameters* r;
        int format, channel_layout, sample_rate, bits_per_sample,
              frames_per_buffer, channels;
        int format, channel_layout, sample_rate, bits_per_sample,
              frames_per_buffer, channels;
        int format, channel_layout, sample_rate, bits_per_sample,
              frames_per_buffer, channels;
        int format, channel_layout, sample_rate, bits_per_sample,
              frames_per_buffer, channels;
        int format, channel_layout, sample_rate, bits_per_sample,
              frames_per_buffer, channels;
        r->Reset(static_cast<AudioParameters::Format>(format),
                    static_cast<ChannelLayout>(channel_layout),
                    sample_rate, bits_per_sample, frames_per_buffer);
        b += 1;
    }
}",1,0,4,0.28,Insert
1154,,,,,,,
1157,"static inline int test_bit(uint32_t *field, int bit)
{
    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;
}","static inline int test_bit(uint32_t *field, int bit)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;
    }
}",0,1,2,0.03,Replace
1158,"static void test_qemu_strtoul_decimal(void)
{
    const char *str = ""0123"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, &endptr, 10, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
    str = ""123"";
    res = 999;
    endptr = &f;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
}","static void test_qemu_strtoul_decimal(void)
{
    const char *str = ""0123"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        err = qemu_strtoul(str, &endptr, 10, &res);
        b_1 = a_1;
    }
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
    str = ""123"";
    res = 999;
    endptr = &f;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
}",0,1,33,0.82,Insert
1159,,,,,,,
1160,,,,,,,
1162,,,,,,,
1163,"static MemoryRegionSection address_space_do_translate(AddressSpace *as,
                                                      hwaddr addr,
                                                      hwaddr *xlat,
                                                      hwaddr *plen,
                                                      bool is_write,
                                                      bool is_mmio)
{
    IOMMUTLBEntry iotlb;
    MemoryRegionSection *section;
    MemoryRegion *mr;
    for (;;) {
        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);
        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);
        mr = section->mr;
        if (!mr->iommu_ops) {
            break;
        }
        iotlb = mr->iommu_ops->translate(mr, addr, is_write);
        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)
                | (addr & iotlb.addr_mask));
        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);
        if (!(iotlb.perm & (1 << is_write))) {
            goto translate_fail;
        }
        as = iotlb.target_as;
    }
    *xlat = addr;
    return *section;
translate_fail:
    return (MemoryRegionSection) { .mr = &io_mem_unassigned };
}","static MemoryRegionSection address_space_do_translate(AddressSpace *as,
                                                      hwaddr addr,
                                                      hwaddr *xlat,
                                                      hwaddr *plen,
                                                      bool is_write,
                                                      bool is_mmio)
{
    int a = 2;
    Unit *u;
    struct rose_neigh *client;
    rose_neigh_list           = client;
    Unit *other;
    int range;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status_2;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status_2 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status_2 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status_2 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status_2 = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    Automount *worker = AUTOMOUNT(u);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    MagickStatusType
                        status;
                        const char *fil;
                        AVIOContext *pb;
                        unsigned int base;
                        unsigned char *result = NULL;
                        int ret = 0, probe_size;
                        AVProbeData pd = { fil ? fil : """", NULL, -base };
                        ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
                    status=MagickTrue;
                    range = automount_start_expire(worker);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    int b = 2;
    while (a == b) {
        IOMMUTLBEntry iotlb;
        b += 1;
    }
    MemoryRegionSection *section;
    MemoryRegion *mr;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    for (;;) {
        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);
        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);
        mr = section->mr;
        QEMUMachineInitArgs *args;
        char *filename;
        ram_addr_t ram_size = args->ram_size;
        long load_limit, rtas_limit, fw_size;
        spapr->next_irq = XICS_IRQ_BASE;
        spapr->ram_limit = ram_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        spapr_events_init(spapr);
        if (!mr->iommu_ops) {
            break;
        }
        iotlb = mr->iommu_ops->translate(mr, addr, is_write);
        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)
                | (addr & iotlb.addr_mask));
        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);
        if (!(iotlb.perm & (1 << is_write))) {
            goto translate_fail;
        }
        as = iotlb.target_as;
    }
    *xlat = addr;
    return *section;
translate_fail:
    return (MemoryRegionSection) { .mr = &io_mem_unassigned };
}",0,1,238,1.94,Insert
1164,"static void read_guest_mem(void)
{
    uint32_t *guest_mem;
    gint64 end_time;
    int i, j;
    size_t size;
    g_mutex_lock(data_mutex);
    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;
    while (!fds_num) {
        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {
            g_assert(fds_num);
            break;
        }
    }
    g_assert_cmpint(fds_num, >, 0);
    g_assert_cmpint(fds_num, ==, memory.nregions);
    for (i = 0; i < fds_num; i++) {
        if (memory.regions[i].guest_phys_addr != 0x0) {
            continue;
        }
        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);
        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;
        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,
                         MAP_SHARED, fds[i], 0);
        g_assert(guest_mem != MAP_FAILED);
        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));
        for (j = 0; j < 256; j++) {
            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);
            uint32_t b = guest_mem[j];
            g_assert_cmpint(a, ==, b);
        }
        munmap(guest_mem, memory.regions[i].memory_size);
    }
    g_assert_cmpint(1, ==, 1);
    g_mutex_unlock(data_mutex);
}","static void read_guest_mem(void)
{
    uint32_t *guest_mem;
    gint64 end_time;
    int i, j;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        size_t size;
    strcpy(str, ""a"");
    }
    g_mutex_lock(data_mutex);
    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;
    while (!fds_num) {
        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {
            g_assert(fds_num);
            break;
        }
    }
    g_assert_cmpint(fds_num, >, 0);
    g_assert_cmpint(fds_num, ==, memory.nregions);
    for (i = 0; i < fds_num; i++) {
        if (memory.regions[i].guest_phys_addr != 0x0) {
            DeviceState *mem = NULL;
            SysBusDevice *busDev;
            qdev_prop_set_uint32(mem, ""num-cpu"", smp_cpus);
            qdev_prop_set_uint32(mem, ""num-irq"", NIRQ_GIC);
            qdev_init_nofail(mem);
            busDev = SYS_BUS_DEVICE(mem);
            mem = qdev_create(NULL, ""sp804"");
            continue;
        }
        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);
        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;
        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,
                         MAP_SHARED, fds[i], 0);
        g_assert(guest_mem != MAP_FAILED);
        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));
        for (j = 0; j < 256; j++) {
            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);
            uint32_t b = guest_mem[j];
            g_assert_cmpint(a, ==, b);
        }
        munmap(guest_mem, memory.regions[i].memory_size);
    }
    g_assert_cmpint(1, ==, 1);
    g_mutex_unlock(data_mutex);
}",0,1,34,1.3,Insert
1166,,,,,,,
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    outw(0xcfc, value);
}","static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    strcpy(str, ""a"");
    }
    BlkActionState *common;
    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);
    DriveBackup *backup;
    Error *local_err = NULL;
    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);
    backup = common->action->u.drive_backup.data;
    do_drive_backup(backup, common->block_job_txn, &local_err);
    outw(0xcfc, value);
}",1,0,16,0.33,Insert
1170,,,,,,,
1171,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)
{
    TCGv_i32 tmp;
    store_reg(s, 15, pc);
    tmp = load_cpu_field(spsr);
    gen_set_cpsr(tmp, CPSR_ERET_MASK);
    tcg_temp_free_i32(tmp);
    s->is_jmp = DISAS_UPDATE;
}","static void gen_exception_return(DisasContext *s, TCGv_i32 pc)
{
    TCGv_i32 tmp;
    store_reg(s, 15, pc);
    tmp = load_cpu_field(spsr);
    gen_set_cpsr(tmp, CPSR_ERET_MASK);
    tcg_temp_free_i32(tmp);
    int a = 2;
    int b = 2;
    while (a == b) {
        s->is_jmp = DISAS_UPDATE;
        b += 1;
    }
}",1,0,12,0.1,Replace
1172,"static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,
                                            uint16_t code, const char *reason)
{
    struct iovec iov;
    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));
    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =
        cpu_to_be16(code);
    ioc->rawoutput.offset += 2;
    if (reason) {
        buffer_append(&ioc->rawoutput, reason, strlen(reason));
    }
    iov.iov_base = ioc->rawoutput.buffer;
    iov.iov_len = ioc->rawoutput.offset;
    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,
                               &iov, 1, iov.iov_len);
    buffer_reset(&ioc->rawoutput);
    qio_channel_websock_write_wire(ioc, NULL);
    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
}","static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,
                                            uint16_t code, const char *reason)
{
    int a = 2;
    int b = 3;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    if (a != b) {
        struct iovec iov;
    }
    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));
    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =
        cpu_to_be16(code);
    ioc->rawoutput.offset += 2;
    if (reason) {
        buffer_append(&ioc->rawoutput, reason, strlen(reason));
    }
    iov.iov_base = ioc->rawoutput.buffer;
    iov.iov_len = ioc->rawoutput.offset;
    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,
                               &iov, 1, iov.iov_len);
    buffer_reset(&ioc->rawoutput);
    qio_channel_websock_write_wire(ioc, NULL);
    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);
}",0,1,48,0.71,Insert
1173,"static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)
{
    fadt->model = 1;
    fadt->reserved1 = 0;
    fadt->sci_int = cpu_to_le16(pm->sci_int);
    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);
    fadt->acpi_enable = pm->acpi_enable_cmd;
    fadt->acpi_disable = pm->acpi_disable_cmd;
    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);
    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);
    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);
    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);
    fadt->pm1_evt_len = 4;
    fadt->pm1_cnt_len = 2;
    fadt->pm_tmr_len = 4;
    fadt->gpe0_blk_len = pm->gpe0_blk_len;
    fadt->plvl2_lat = cpu_to_le16(0xfff);  
    fadt->plvl3_lat = cpu_to_le16(0xfff);  
    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |
                              (1 << ACPI_FADT_F_PROC_C1) |
                              (1 << ACPI_FADT_F_SLP_BUTTON) |
                              (1 << ACPI_FADT_F_RTC_S4));
    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);
    if (max_cpus > 8) {
        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);
    }
    fadt->century = RTC_CENTURY;
}","static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)
{
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""
    		   int nb_oargs;
    		   int nb_iargs;
    		   const TCGArg * const args;
    		   int rules, nb_regs, ini;
    		   tcg_insn_unit *func_addr;
    		   func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
    		   rules = args[nb_oargs + nb_iargs + 1];wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    		   char *filename;
    		   long load_limit, fw_size;
    		   fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    fadt->model = 1;
    fadt->reserved1 = 0;
    fadt->sci_int = cpu_to_le16(pm->sci_int);
    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);
    fadt->acpi_enable = pm->acpi_enable_cmd;
    fadt->acpi_disable = pm->acpi_disable_cmd;
    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);
    }
    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);
    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);
    fadt->pm1_evt_len = 4;
    fadt->pm1_cnt_len = 2;
    fadt->pm_tmr_len = 4;
    fadt->gpe0_blk_len = pm->gpe0_blk_len;
    fadt->plvl2_lat = cpu_to_le16(0xfff);  
    fadt->plvl3_lat = cpu_to_le16(0xfff);  
    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |
                              (1 << ACPI_FADT_F_PROC_C1) |
                              (1 << ACPI_FADT_F_SLP_BUTTON) |
                              (1 << ACPI_FADT_F_RTC_S4));
    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);
    if (max_cpus > 8) {
        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);
    }
    fadt->century = RTC_CENTURY;
}",0,1,109,1.0,Insert
1174,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)
{
    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);
    if (val & ACPI_BITMASK_SLEEP_ENABLE) {
        uint16_t sus_typ = (val >> 10) & 7;
        switch(sus_typ) {
        case 0:  
            qemu_system_shutdown_request();
            break;
        case 1:
            ar->pm1.evt.sts |=
                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);
            qemu_system_reset_request();
            qemu_irq_raise(ar->pm1.cnt.cmos_s3);
        default:
            break;
        }
    }
}","void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)
{
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);
    if (val & ACPI_BITMASK_SLEEP_ENABLE) {
        uint16_t sus_typ = (val >> 10) & 7;
        switch(sus_typ) {
        case 0:  
            qemu_system_shutdown_request();
            int a = 2;
            int b = 3;
            while (a < b) {
                break;
                b = a;
            }
        case 1:
            ar->pm1.evt.sts |=
                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);
            qemu_system_reset_request();
            qemu_irq_raise(ar->pm1.cnt.cmos_s3);
        default:
            break;
        }
    }
}",0,1,23,0.45,Insert
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    struct qemu_alarm_win32 *data = t->priv;
    uint64_t nearest_delta_us;
    if (!active_timers[QEMU_TIMER_REALTIME] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->period,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",
                GetLastError());
        timeEndPeriod(data->period);
        exit(1);
    }
}","static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    quantization_tables=NewXMLTree(xml,exception);
    quantization_tables=DestroyXMLTree(quantization_tables);
    struct qemu_alarm_win32 *data = t->priv;
    uint64_t nearest_delta_us;
    if (!active_timers[QEMU_TIMER_REALTIME] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        int a = 2;
        int b = 2;
        if (a == b) {
            return;
        }
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->period,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",
                GetLastError());
        timeEndPeriod(data->period);
        exit(1);
    }
}",0,1,30,0.63,Insert
1176,,,,,,,
1177,,,,,,,
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    int8_t *ptr = qdev_get_prop_ptr(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != DEV_STATE_CREATED) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    visit_type_int(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}","static void set_int8(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        Property *prop = opaque;
    }
    int8_t *ptr = qdev_get_prop_ptr(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != DEV_STATE_CREATED) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    visit_type_int(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}",1,0,1,0.12,Replace
1179,"static void enter_migration_coroutine(void *opaque)
{
    Coroutine *co = opaque;
    qemu_coroutine_enter(co, NULL);
}","static void enter_migration_coroutine(void *opaque)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        Coroutine *co = opaque;
        MpegEncContext *s;
        double q;
        RateControlEntry *rce;
        RateControlContext *rcc= &s->rc_context;
        const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];
        AVCodecContext *a_10= s->avctx;
        const int pict_type= rce->new_pict_type;
        const double last_p_q    = rcc->last_qscale_for[P_TYPE];
        if     (pict_type==I_TYPE && (a_10->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))
                q= last_p_q    *FFABS(a_10->i_quant_factor) + a_10->i_quant_offset;
            else if(pict_type==B_TYPE && a_10->b_quant_factor>0.0)
                q= last_non_b_q*    a_10->b_quant_factor  + a_10->b_quant_offset;
    }
    qemu_coroutine_enter(co, NULL);
}",1,0,5,0.27,Insert
1181,"static int cinaudio_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
                                 AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    CinAudioContext *cin = avctx->priv_data;
    const uint8_t *src = buf;
    int16_t *samples = data;
    int delta;
    buf_size = FFMIN(buf_size, *data_size/2);
    delta = cin->delta;
    if (cin->initial_decode_frame) {
        cin->initial_decode_frame = 0;
        delta = (int16_t)AV_RL16(src); src += 2;
        *samples++ = delta;
        buf_size -= 2;
    }
    while (buf_size > 0) {
        delta += cinaudio_delta16_table[*src++];
        delta = av_clip_int16(delta);
        *samples++ = delta;
        --buf_size;
    }
    cin->delta = delta;
    *data_size = (uint8_t *)samples - (uint8_t *)data;
    return src - buf;
}","static int cinaudio_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
                                 AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    CinAudioContext *cin = avctx->priv_data;
    const uint8_t *src = buf;
    int16_t *samples = data;
    int delta;
    buf_size = FFMIN(buf_size, *data_size/2);
    delta = cin->delta;
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (key) {
            if (!server_config_defined_vars) {
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    if (cin->initial_decode_frame) {
        cin->initial_decode_frame = 0;
        delta = (int16_t)AV_RL16(src); src += 2;
        *samples++ = delta;
        buf_size -= 2;
    }
    while (buf_size > 0) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            delta += cinaudio_delta16_table[*src++];
        strcpy(str, ""a"");
        }
        delta = av_clip_int16(delta);
        *samples++ = delta;
        --buf_size;
    }
    cin->delta = delta;
    *data_size = (uint8_t *)samples - (uint8_t *)data;
    return src - buf;
}",0,1,59,0.9,Insert
1183,"int qemu_paio_init(struct qemu_paioinit *aioinit)
{
    int ret;
    ret = pthread_attr_init(&attr);
    if (ret) die2(ret, ""pthread_attr_init"");
    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    if (ret) die2(ret, ""pthread_attr_setdetachstate"");
    TAILQ_INIT(&request_list);
    return 0;
}","int qemu_paio_init(struct qemu_paioinit *aioinit)
{
    int ret;
    ret = pthread_attr_init(&attr);
    if (ret) die2(ret, ""pthread_attr_init"");
    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    QuantizationTable
    AUXReply ret_8 = AUX_NACK;
    DPRINTF(""
    QuantizationTable
        *table_7;
    XMLTreeInfo
        *description_7,
        *levels_8,
        *quantization_tables_9,
        *table_iterator_5;
    const char
        *attribute_3,
        *content_5;
    XMLTreeInfo
        *description_7,
        *levels_8,
        *quantization_tables_9,
        *table_iterator_5;
    levels_8=GetXMLTreeChild_2(table_iterator_5,""levels"");
    table_7->levels_8=(unsigned int *) NULL;
    attribute_3=GetXMLTreeAttribute_10(levels_8,""width"");
    attribute_3=GetXMLTreeAttribute_10(levels_8,""height"");
    attribute_3=GetXMLTreeAttribute_10(levels_8,""divisor"");reply: %u
    "", ret_8);
    TCGContext *service;
    register ssize_t
        i;
    QuantizationTable
        *table_8;
    ssize_t
        j;
    XMLTreeInfo
        *description_1,
        *levels_10,
        *quantization_tables_6,
        *table_iterator_10;
    for (j=i; j < 64; j++)
        table_8->levels_10[j]=table_8->levels_10[j-1];
    int rules, nb_regs, ini;
    TCGRegSet allocated_regs;
    if (rules & TCG_CALL_NO_READ_GLOBALS) {
        } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
            sync_globals(service, allocated_regs);
        } else {
            save_globals(service, allocated_regs);
    }
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    if (ret) die2(ret, ""pthread_attr_setdetachstate"");
    TAILQ_INIT(&request_list);
    int a = 2;
    int b = 2;
    while (a == b) {
        return 0;
        b += 1;
        Rocker *r;
        DescInfo *info;
        uint32_t port;
        int err = ROCKER_OK;
        char *buf = desc_get_buf(info, true);
        struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
        PCIDevice *dev = PCI_DEVICE(r);
        int iovcnt = 0;
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    }
}",0,1,505,2.46,Insert
1184,"dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}","dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        int a = 2;
        int b = 3;
        while (a != b) {
            va_start(args, fmt);
            b = a;
        }
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}",0,1,3,0.06,Replace
1185,"static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,
                                  DeviceState *dev, Error **errp)
{
    PCIDevice *pci_dev = PCI_DEVICE(dev);
    S390PCIBusDevice *pbdev;
    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)
                                           ->qbus.parent);
    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];
    pbdev->fid = s390_pci_get_pfid(pci_dev);
    pbdev->pdev = pci_dev;
    pbdev->configured = true;
    pbdev->fh = s390_pci_get_pfh(pci_dev);
    s390_pcihost_setup_msix(pbdev);
    if (dev->hotplugged) {
        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,
                                     pbdev->fh, pbdev->fid);
        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,
                                     pbdev->fh, pbdev->fid);
    }
}","static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,
                                  DeviceState *dev, Error **errp)
{
    PCIDevice *pci_dev = PCI_DEVICE(dev);
    authenc_ahash_t authenc_ahash_fn;
    struct aead_request *req;
    struct file *filp;
    struct PCIDevice *pci_dev_10;
    int (*compare)(const char *, const char *, size_t);
    const char *name1;
    const char *name2;
    int cmp;
    unsigned char c1, mc7;
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev_6 = &serial->serial->dev_6->dev_6;
    if (status)
    		dev_dbg(dev_6, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev_6, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    cmp = compare(name1, name2, len);
    c1 = name1[len];
    uint8_t e_intx;
    Error *local_ = NULL;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev_10);
    assigned_dev_register_regions(Dev->real_device.regions,
                                      Dev->real_device.region_number, Dev,
                                      &local_);
    e_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;
    Dev->intpin = e_intx;
    struct PCIDevice *pci_dev_6;
    int r;
    AssignedDevice_2 *Dev_5 = DO_UPCAST_1(AssignedDevice_2, Dev_5, pci_dev_6);
    AssignedDevice_2 *Dev_5 = DO_UPCAST_1(AssignedDevice_2, Dev_5, pci_dev_6);
    r = assign_device(Dev_5);
    r = assign_intx(Dev_5);
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    assigned_dev_load_option_rom(Dev_5);
    add_boot_device_path(Dev_5->bootindex, &pci_dev_6->qdev, NULL);
    Dev->intx_route.mode = PCI_INTX_DISABLED;
    Dev->intx_route.irq = -1;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    fput(filp);
    u8 *hash;
    struct crypto_aead *authenc = crypto_aead_reqtfm(req);
    hash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
    int a = 2;
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    int b = 3;
    if (a != b) {
        S390PCIBusDevice *pbdev;
    }
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)
                                           ->qbus.parent);
    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];
    pbdev->fid = s390_pci_get_pfid(pci_dev);
    pbdev->pdev = pci_dev;
    pbdev->configured = true;
    pbdev->fh = s390_pci_get_pfh(pci_dev);
    s390_pcihost_setup_msix(pbdev);
    if (dev->hotplugged) {
        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,
                                     pbdev->fh, pbdev->fid);
        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,
                                     pbdev->fh, pbdev->fid);
    }
}",0,1,799,3.96,Insert
1186,"static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,
                               unsigned size)
{
    PXA2xxState *s = (PXA2xxState *) opaque;
    switch (addr) {
    case MDCNFG ... SA1110:
        if ((addr & 3) == 0)
            return s->mm_regs[addr >> 2];
    default:
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
    return 0;
}","static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,
                               unsigned size)
{
    unsigned long array;
    AVCodecContext *ajcas;
    DCAContext *s_2 = ajcas->priv_data;
    int num_core_channels = 0;
    int channels, full_channels;
    int channels, full_channels;
    num_core_channels = s_2->prim_channels;
    full_channels = channels = s_2->prim_channels + !!s_2->lfe;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    int a = 2;
    int b = 3;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    D(printf_5 (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    while (a < b) {
        PXA2xxState *s = (PXA2xxState *) opaque;
        b = a;
    }
    switch (addr) {
    case MDCNFG ... SA1110:
        if ((addr & 3) == 0)
            return s->mm_regs[addr >> 2];
    default:
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
    return 0;
}",0,1,519,2.76,Insert
1187,"static int vhost_verify_ring_mappings(struct vhost_dev *dev,
                                      uint64_t start_addr,
                                      uint64_t size)
{
    int i, j;
    int r = 0;
    const char *part_name[] = {
        ""descriptor table"",
        ""available ring"",
        ""used ring""
    };
    for (i = 0; i < dev->nvqs; ++i) {
        struct vhost_virtqueue *vq = dev->vqs + i;
        j = 0;
        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,
                                           vq->desc_size, start_addr, size);
        if (!r) {
            break;
        }
        j++;
        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,
                                           vq->avail_size, start_addr, size);
        if (!r) {
            break;
        }
        j++;
        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,
                                           vq->used_size, start_addr, size);
        if (!r) {
            break;
        }
    }
    if (r == -ENOMEM) {
        error_report(""Unable to map %s for ring %d"", part_name[j], i);
    } else if (r == -EBUSY) {
        error_report(""%s relocated for ring %d"", part_name[j], i);
    }
    return r;
}","static int vhost_verify_ring_mappings(struct vhost_dev *dev,
                                      uint64_t start_addr,
                                      uint64_t size)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        int i, j;
        b = a;
    }
    int r = 0;
    const char *part_name[] = {
        ""descriptor table"",
        ""available ring"",
        ""used ring""
    };
    int len;
    int copied, err;
    struct sk_buff *skb, *skb2;
    copied = skb->len;
    for (i = 0; i < dev->nvqs; ++i) {
        struct vhost_virtqueue *vq = dev->vqs + i;
        j = 0;
        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,
                                           vq->desc_size, start_addr, size);
        if (!r) {
            break;
        }
        j++;
        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,
                                           vq->avail_size, start_addr, size);
        if (!r) {
            break;
        }
        DisasContext *ctx;
        int32_t r1, r2;
        r1 = MASK_OP_BO_S1D(ctx->opcode);
        j++;
        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,
                                           vq->used_size, start_addr, size);
        if (!r) {
            break;
        }
    }
    if (r == -ENOMEM) {
        error_report(""Unable to map %s for ring %d"", part_name[j], i);
    } else if (r == -EBUSY) {
        error_report(""%s relocated for ring %d"", part_name[j], i);
    }
    return r;
}",0,1,50,1.33,Insert
1189,,,,,,,
1192,,,,,,,
1193,"static void stop_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val |= TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}","static void stop_tco(const TestData *d)
{
    uint32_t val;
    int a = 2;
    int b = 2;
    while (a == b) {
        val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
        b += 1;
    }
    H264Context *h;
    int log2_cb_size;
    int nPbH;
    int y0;
    int nPbW;
    int part_idx;
    int x0;
    int merge_idx;
    HEVCContext *s_6;
    HEVCLocalContext *lc = &s_6->HEVClc;
    int singleMCLFlag = 0;
    int nPbW2 = nPbW;
    int nPbH2 = nPbH;
    int nCS = 1 << log2_cb_size;
    derive_spatial_merge_candidates(s_6, x0, y0, nPbW, nPbH, log2_cb_size,
                                        singleMCLFlag, part_idx,
                                        merge_idx, mergecand_list);
    MpegEncContext * const s = &h->s;
    const int big_mb_num= s->mb_stride * (s->mb_height+1);
    MpegEncContext * const s = &h->s;
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)
    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);
    val |= TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}",1,0,45,0.49,Insert
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    qemu_put_byte(f, v >> 24);
    qemu_put_byte(f, v >> 16);
    qemu_put_byte(f, v >> 8);
    qemu_put_byte(f, v);
}","void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        qemu_put_byte(f, v >> 24);
    }
    qemu_put_byte(f, v >> 16);
    qemu_put_byte(f, v >> 8);
    qemu_put_byte(f, v);
}",1,0,10,0.07,Replace
1195,,,,,,,
1196,,,,,,,
1199,,,,,,,
1200,"static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)
{
    const uint8_t *buf_end = buf + buf_size;
    while(buf + 48 <= buf_end) {
        int dir_length, name_size, first_sector, depth;
        uint64_t file_length;
        const uint8_t *name;
        if (ff_guidcmp(buf, dir_entry_guid)) {
            av_log(s, AV_LOG_ERROR, ""unknown guid ""FF_PRI_GUID"", expected dir_entry_guid; ""
                   ""remaining directory entries ignored\n"", FF_ARG_GUID(buf));
            break;
        }
        dir_length  = AV_RL16(buf + 16);
        file_length = AV_RL64(buf + 24);
        name_size   = 2 * AV_RL32(buf + 32);
        if (buf + 48 + name_size > buf_end) {
            av_log(s, AV_LOG_ERROR, ""filename exceeds buffer size; remaining directory entries ignored\n"");
            break;
        }
        first_sector = AV_RL32(buf + 40 + name_size);
        depth        = AV_RL32(buf + 44 + name_size);
        name = buf + 40;
        if (name_size >= filename_size &&
            !memcmp(name, filename, filename_size) &&
            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))
            return wtvfile_open_sector(first_sector, file_length, depth, s);
        buf += dir_length;
    }
    return 0;
}","static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)
{
    const uint8_t *buf_end = buf + buf_size;
    while(buf + 48 <= buf_end) {
        int dir_length, name_size, first_sector, depth;
        uint64_t file_length;
        const uint8_t *name;
        if (ff_guidcmp(buf, dir_entry_guid)) {
            av_log(s, AV_LOG_ERROR, ""unknown guid ""FF_PRI_GUID"", expected dir_entry_guid; ""
                   ""remaining directory entries ignored\n"", FF_ARG_GUID(buf));
            break;
        }
        dir_length  = AV_RL16(buf + 16);
        file_length = AV_RL64(buf + 24);
        name_size   = 2 * AV_RL32(buf + 32);
        if (buf + 48 + name_size > buf_end) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                av_log(s, AV_LOG_ERROR, ""filename exceeds buffer size; remaining directory entries ignored\n"");
            }
            break;
        }
        first_sector = AV_RL32(buf + 40 + name_size);
        depth        = AV_RL32(buf + 44 + name_size);
        name = buf + 40;
        if (name_size >= filename_size &&
            !memcmp(name, filename, filename_size) &&
            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))
            return wtvfile_open_sector(first_sector, file_length, depth, s);
        buf += dir_length;
    }
    return 0;
}",1,0,12,0.18,Replace
1203,"static int idcin_decode_init(AVCodecContext *avctx)
{
    IdcinContext *s = avctx->priv_data;
    int i, j, histogram_index = 0;
    unsigned char *histograms;
    s->avctx = avctx;
    avctx->pix_fmt = PIX_FMT_PAL8;
    dsputil_init(&s->dsp, avctx);
    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);
        return -1;
    }
    histograms = (unsigned char *)s->avctx->extradata;
    for (i = 0; i < 256; i++) {
        for(j = 0; j < HUF_TOKENS; j++)
            s->huff_nodes[i][j].count = histograms[histogram_index++];
        huff_build_tree(s, i);
    }
    s->frame.data[0] = NULL;
    return 0;
}","static int idcin_decode_init(AVCodecContext *avctx)
{
    IdcinContext *s = avctx->priv_data;
    int i, j, histogram_index = 0;
    unsigned char *histograms;
    s->avctx = avctx;
    avctx->pix_fmt = PIX_FMT_PAL8;
    int a = 62;
    int b = a;
    if(a*b>0){
        dsputil_init(&s->dsp, avctx);
    }
    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);
        return -1;
    }
    histograms = (unsigned char *)s->avctx->extradata;
    for (i = 0; i < 256; i++) {
        for(j = 0; j < HUF_TOKENS; j++)
            s->huff_nodes[i][j].count = histograms[histogram_index++];
        huff_build_tree(s, i);
    }
    s->frame.data[0] = NULL;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    return 0;
}",0,1,32,0.8,Insert
1204,"static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,
                                 uint32_t color, int *w_ptr, int *h_ptr)
{
    int dx, dy, dw, dh;
    int w_prev;
    int w_best = 0, h_best = 0;
    w_prev = w;
    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {
        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);
        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);
        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {
            break;
        }
        for (dx = x + dw; dx < x + w_prev;) {
            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);
            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {
                break;
            }
            dx += dw;
        }
        w_prev = dx - x;
        if (w_prev * (dy + dh - y) > w_best * h_best) {
            w_best = w_prev;
            h_best = dy + dh - y;
        }
    }
    *w_ptr = w_best;
    *h_ptr = h_best;
}","static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,
                                 uint32_t color, int *w_ptr, int *h_ptr)
{
    int dx, dy, dw, dh;
    int w_prev;
    int w_best = 0, h_best = 0;
    w_prev = w;
    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {
        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);
        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {
            const char *data;
            int data;
            BlockDriver *yrf = NULL;
            Error *localxer = NULL;
            BlockDriverState *source_vs;
            BlockDriverState *bes;
            int  rows;
            data = bes->open_flags | BDRV_O_RDWR;
            rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
            int a = 8;
            int b = a;
            if(a*b>0){
                break;
            }
        }
        for (dx = x + dw; dx < x + w_prev;) {
            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);
            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {
                break;
            }
            dx += dw;
        }
        w_prev = dx - x;
        if (w_prev * (dy + dh - y) > w_best * h_best) {
            w_best = w_prev;
            h_best = dy + dh - y;
        }
    }
    *w_ptr = w_best;
    *h_ptr = h_best;
}",0,1,78,1.75,Insert
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    abort();
found:
    ram_list.mru_block = block;
    return block;
}","static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    char str[] = ""Constant"";
    RAMBlock *news_work;
    struct udscs_message_header *header;
    const gchar *port = ""invalid message"";
    if (header->port < G_N_ELEMENTS(vdagentd_messages))
            port = vdagentd_messages[header->port];
    news_work = g_malloc0(sizeof(*news_work));
    news_work->err = err;
    news_work->realized = realized;
    news_work->used_length = size;
    news_work->max_length = maxlennumber;
    if (strlen(str) > 0) {
        abort();
    }
found:
    ram_list.mru_block = block;
    return block;
}",0,1,50,0.73,Insert
1206,,,,,,,
1209,"void AUD_vlog (const char *cap, const char *fmt, va_list ap)
{
    if (conf.log_to_monitor) {
        if (cap) {
            monitor_printf(default_mon, ""%s: "", cap);
        }
        monitor_vprintf(default_mon, fmt, ap);
    }
    else {
        if (cap) {
            fprintf (stderr, ""%s: "", cap);
        }
        vfprintf (stderr, fmt, ap);
    }
}","void AUD_vlog (const char *cap, const char *fmt, va_list ap)
{
    if (conf.log_to_monitor) {
        if (cap) {
            const JavaParamRef<jstring>& java_short_name;
            JNIEnv* env;
            const JavaParamRef<jstring>& java_start_url;
            ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));
            info.short_name = ConvertJavaStringToUTF16(env, java_short_name);
            monitor_printf(default_mon, ""%s: "", cap);
        }
        monitor_vprintf(default_mon, fmt, ap);
    }
    else {
        if (cap) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                fprintf (stderr, ""%s: "", cap);
            }
        }
        vfprintf (stderr, fmt, ap);
    }
}",1,0,14,0.54,Insert
1210,"static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,
                                  OGGStreamContext *oggstream, int bitexact)
{
    const char *vendor = bitexact ? ""ffmpeg"" : LIBAVFORMAT_IDENT;
    uint8_t *p;
    if (extradata_size != 34)
        return -1;
    oggstream->header_len[0] = 51;
    oggstream->header[0] = av_mallocz(51);  
    p = oggstream->header[0];
    bytestream_put_byte(&p, 0x7F);
    bytestream_put_buffer(&p, ""FLAC"", 4);
    bytestream_put_byte(&p, 1);  
    bytestream_put_byte(&p, 0);  
    bytestream_put_be16(&p, 1);  
    bytestream_put_buffer(&p, ""fLaC"", 4);
    bytestream_put_byte(&p, 0x00);  
    bytestream_put_be24(&p, 34);
    bytestream_put_buffer(&p, extradata, 34);
    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;
    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);
    p = oggstream->header[1];
    bytestream_put_byte(&p, 0x84);  
    bytestream_put_be24(&p, oggstream->header_len[1] - 4);
    bytestream_put_le32(&p, strlen(vendor));
    bytestream_put_buffer(&p, vendor, strlen(vendor));
    bytestream_put_le32(&p, 0);  
    return 0;
}","static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,
                                  OGGStreamContext *oggstream, int bitexact)
{
    const char *vendor = bitexact ? ""ffmpeg"" : LIBAVFORMAT_IDENT;
    uint8_t *p;
    if (extradata_size != 34)
        return -1;
        register const xmlChar *cmp = other;
        register const xmlChar *m;
        while (*m != 0 && *m == *cmp) {
        	++m;
        	++cmp;
        	ctxt->input->col++;
        }
    oggstream->header_len[0] = 51;
    size_t ie_len;
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    int a = 40;
    int b = a;
    int i, qa;
    qa = libusb_init(&ctx);
    if(a*b>0){
        oggstream->header[0] = av_mallocz(51);  
    }
    p = oggstream->header[0];
    bytestream_put_byte(&p, 0x7F);
    bytestream_put_buffer(&p, ""FLAC"", 4);
    bytestream_put_byte(&p, 1);  
    bytestream_put_byte(&p, 0);  
    bytestream_put_be16(&p, 1);  
    bytestream_put_buffer(&p, ""fLaC"", 4);
    bytestream_put_byte(&p, 0x00);  
    bytestream_put_be24(&p, 34);
    bytestream_put_buffer(&p, extradata, 34);
    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;
    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);
    p = oggstream->header[1];
    bytestream_put_byte(&p, 0x84);  
    bytestream_put_be24(&p, oggstream->header_len[1] - 4);
    bytestream_put_le32(&p, strlen(vendor));
    bytestream_put_buffer(&p, vendor, strlen(vendor));
    bytestream_put_le32(&p, 0);  
    return 0;
}",0,1,133,1.44,Insert
1211,"static void put_subframe(DCAEncContext *c, int subframe)
{
    int i, band, ss, ch;
    put_bits(&c->pb, 2, SUBSUBFRAMES -1);
    put_bits(&c->pb, 3, 0);
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 1, 0);
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 5, c->abits[band][ch]);
    if (SUBSUBFRAMES > 1) {
        for (ch = 0; ch < c->fullband_channels; ch++)
            for (band = 0; band < DCAENC_SUBBANDS; band++)
                put_bits(&c->pb, 1, 0);  
    }
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 7, c->scale_factor[band][ch]);
    if (c->lfe_channel) {
        for (i = 0; i < DCA_LFE_SAMPLES; i++)
            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);
        put_bits(&c->pb, 8, c->lfe_scale_factor);
    }
    for (ss = 0; ss < SUBSUBFRAMES ; ss++)
        for (ch = 0; ch < c->fullband_channels; ch++)
            for (band = 0; band < DCAENC_SUBBANDS; band++)
                    put_subframe_samples(c, ss, band, ch);
    put_bits(&c->pb, 16, 0xffff);
}","static void put_subframe(DCAEncContext *c, int subframe)
{
    PutBitContext pb, pb2;
    int comps;
    put_bits_1(&pb, 16, 8 + comps * 3);
    put_bits_1(&pb, 8, comps);
    put_bits_1(&pb, 16, 6 + comps * 2);
    put_bits_1(&pb, 8, comps);
    put_bits_1(&pb, 8, (comps > 1) ? 1 : 0);
    int i, band, ss, ch;
    put_bits(&c->pb, 2, SUBSUBFRAMES -1);
    put_bits(&c->pb, 3, 0);
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 1, 0);
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 5, c->abits[band][ch]);
    if (SUBSUBFRAMES > 1) {
        for (ch = 0; ch < c->fullband_channels; ch++)
            for (band = 0; band < DCAENC_SUBBANDS; band++)
                put_bits(&c->pb, 1, 0);  
    }
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 7, c->scale_factor[band][ch]);
    if (c->lfe_channel) {
        for (i = 0; i < DCA_LFE_SAMPLES; i++)
            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);
            AVFormatContext *your;
            int port, i_1, status, r;
            RTSPState *rt = your->priv_data;
            if (ff_rtsp_callback) {
                    if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                         NULL, 0, rt->last_reply) < 0) {
                        r = AVERROR_INVALIDDATA;
                        goto fail;
                    }
            }
        put_bits(&c->pb, 8, c->lfe_scale_factor);
        GF_BitStream *bits;
        GF_Box *s;
        GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
        GF_Err e;
        e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
        ISOM_DECREASE_SIZE(buf, 8);
    }
    for (ss = 0; ss < SUBSUBFRAMES ; ss++)
        for (ch = 0; ch < c->fullband_channels; ch++)
            for (band = 0; band < DCAENC_SUBBANDS; band++)
                    put_subframe_samples(c, ss, band, ch);
    put_bits(&c->pb, 16, 0xffff);
}",0,1,82,2.01,Insert
1212,"static void decode_gray_bitstream(HYuvContext *s, int count)
{
    int i;
    count/=2;
    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {
        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    } else {
        for(i=0; i<count; i++){
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    }
}","static void decode_gray_bitstream(HYuvContext *s, int count)
{
    int i;
    count/=2;
    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {
        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {
            int a = 2;
            int b = 2;
            register const xmlChar *cmp = other;
            register const xmlChar *m;
            while (*m != 0 && *m == *cmp) {
            	++m;
            	++cmp;
            	ctxt->input->col++;
            }
            while (a == b) {
                READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
                b += 1;
            }
        }
    } else {
        for(i=0; i<count; i++){
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    }
}",0,1,27,0.67,Insert
1213,"static int start_auth_vencrypt_subauth(VncState *vs)
{
    switch (vs->vd->subauth) {
    case VNC_AUTH_VENCRYPT_TLSNONE:
    case VNC_AUTH_VENCRYPT_X509NONE:
       VNC_DEBUG(""Accept TLS auth none\n"");
       vnc_write_u32(vs, 0);  
       vnc_read_when(vs, protocol_client_init, 1);
       break;
    case VNC_AUTH_VENCRYPT_TLSVNC:
    case VNC_AUTH_VENCRYPT_X509VNC:
       VNC_DEBUG(""Start TLS auth VNC\n"");
       return start_auth_vnc(vs);
    default:  
       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);
       vnc_write_u8(vs, 1);
       if (vs->minor >= 8) {
           static const char err[] = ""Unsupported authentication type"";
           vnc_write_u32(vs, sizeof(err));
           vnc_write(vs, err, sizeof(err));
       }
       vnc_client_error(vs);
    }
    return 0;
}","static int start_auth_vencrypt_subauth(VncState *vs)
{
    switch (vs->vd->subauth) {
    case VNC_AUTH_VENCRYPT_TLSNONE:
    case VNC_AUTH_VENCRYPT_X509NONE:
       DisasContext *ctx;
       int32_t r1, r2;
       r1 = MASK_OP_BO_S1D(ctx->opcode);
       VNC_DEBUG(""Accept TLS auth none\n"");
       vnc_write_u32(vs, 0);  
       vnc_read_when(vs, protocol_client_init, 1);
       break;
    case VNC_AUTH_VENCRYPT_TLSVNC:
    case VNC_AUTH_VENCRYPT_X509VNC:
       VNC_DEBUG(""Start TLS auth VNC\n"");
       return start_auth_vnc(vs);
    default:  
       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);
       vnc_write_u8(vs, 1);
       if (vs->minor >= 8) {
           int a = 2;
           int b = 3;
           if (a != b) {
               static const char err[] = ""Unsupported authentication type"";
           }
           vnc_write_u32(vs, sizeof(err));
           vnc_write(vs, err, sizeof(err));
       }
       vnc_client_error(vs);
    }
    return 0;
}",0,1,33,0.63,Insert
1214,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,
                     void *command_data, void *opaque)
{
    IscsiAIOCB *acb = opaque;
    if (acb->canceled != 0) {
        return;
    }
    acb->status = 0;
    if (status < 0) {
        error_report(""Failed to unmap data on iSCSI lun. %s"",
                     iscsi_get_error(iscsi));
        acb->status = -EIO;
    }
    iscsi_schedule_bh(acb);
}","iscsi_unmap_cb(struct iscsi_context *iscsi, int status,
                     void *command_data, void *opaque)
{
    IscsiAIOCB *acb = opaque;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    if (acb->canceled != 0) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return;
        }
    }
    acb->status = 0;
    if (status < 0) {
        error_report(""Failed to unmap data on iSCSI lun. %s"",
                     iscsi_get_error(iscsi));
        acb->status = -EIO;
    }
    iscsi_schedule_bh(acb);
}",0,1,11,0.32,Insert
1215,"static void virtio_notify(struct subchannel_id schid)
{
    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
}","static void virtio_notify(struct subchannel_id schid)
{
    int a = 2;
    int b = 3;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    while (a < b) {
        kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
        b = a;
    }
}",0,1,6,0.26,Insert
1216,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .addr = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
    kvm_mce_broadcast_rest(env);
}","static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    struct edgeport_serial *serial;
    u8 *data_8;
    struct device *dev_10 = &serial->serial->dev_10->dev_10;
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    struct device *dev_10 = &serial->serial->dev_10->dev_10;
    int status_2;
    status_2 = ti_vread_sync(serial->serial->dev_10, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_8, 0x01);
    status_2 = ti_vread_sync(serial->serial->dev_10, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_8, 0x01);
    dev_dbg(dev_10, ""%s - Unknown
    "", __func__);
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    CPUState *cpu;
    KVMState *b_4 = kvm_state;
    KVMState *b_4 = kvm_state;
    cpu->kvm_state = b_4;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    int port, i, status_4, r_3;
    RTSPHeader reply1, *reply = &reply1;
    if (reply->status_code != RTSP_STATUS_OK) {
            r_3 = AVERROR_INVALIDDATA;
            VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
            uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
            internal_buf->chunk_header.port = VDP_SERVER_PORT;
            internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
            internal_buf->header.protocol = VD_AGENT_PROTOCOL;
            internal_buf->header.type = type;
            internal_buf->header.opaque = 0;
            goto fail;
    }
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    struct perf_event *bug;
    struct perf_sample_data *data;
    u64 sample_type = bug->attr.sample_type;
    if (sample_type & PERF_SAMPLE_STREAM_ID)
    		data->stream_id = bug->id;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .addr = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    int a = 2;
    int b = 3;
    while (a < b) {
        kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
        b = a;
    }
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    kvm_mce_broadcast_rest(env);
}",0,1,678,3.39,Insert
1219,"static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)
{
    QObject *token, *ret;
    QList *working = qlist_copy(*tokens);
    token = qlist_pop(working);
    if (token == NULL) {
        goto out;
    }
    if (token_get_type(token) != JSON_KEYWORD) {
        goto out;
    }
    if (token_is_keyword(token, ""true"")) {
        ret = QOBJECT(qbool_from_int(true));
    } else if (token_is_keyword(token, ""false"")) {
        ret = QOBJECT(qbool_from_int(false));
    } else {
        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));
        goto out;
    }
    qobject_decref(token);
    QDECREF(*tokens);
    *tokens = working;
    return ret;
out: 
    qobject_decref(token);
    QDECREF(working);
    return NULL;
}","static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)
{
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    struct edgeport_serial *serial;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    u8 *data;
    struct device *dev_9 = &serial->serial->dev_9->dev_9;
    struct device *dev_9 = &serial->serial->dev_9->dev_9;
    int status;
    status = ti_vread_sync(serial->serial->dev_9, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev_9, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    status = -ENODEV;
    if (k->realize) {
            k->realize(dev, &err);
    }
    QObject *token, *ret;
    QList *working = qlist_copy(*tokens);
    token = qlist_pop(working);
    if (token == NULL) {
        QEMUMachineInitArgs *args;
        char *filename;
        ram_addr_t ram_size = args->ram_size;
        long load_limit, rtas_limit, fw_size;
        spapr->next_irq = XICS_IRQ_BASE;
        spapr->ram_limit = ram_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        spapr_events_init(spapr);
        int a = 2;
        int b = 3;
        while (a != b) {
            goto out;
            b = a;
        }
    }
    if (token_get_type(token) != JSON_KEYWORD) {
        goto out;
    }
    if (token_is_keyword(token, ""true"")) {
        ret = QOBJECT(qbool_from_int(true));
    } else if (token_is_keyword(token, ""false"")) {
        ret = QOBJECT(qbool_from_int(false));
    } else {
        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));
        goto out;
    }
    qobject_decref(token);
    QDECREF(*tokens);
    *tokens = working;
    return ret;
out: 
    qobject_decref(token);
    QDECREF(working);
    return NULL;
}",0,1,125,1.29,Insert
1223,"static void qdm2_init(QDM2Context *q) {
    static int inited = 0;
    if (inited != 0)
        return;
    inited = 1;
    qdm2_init_vlc();
    ff_mpa_synth_init(mpa_window);
    softclip_table_init();
    rnd_table_init();
    init_noise_samples();
    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");
}","static void qdm2_init(QDM2Context *q) {
    static int inited = 0;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    if (inited != 0)
        return;
    inited = 1;
    qdm2_init_vlc();
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ff_mpa_synth_init(mpa_window);
    strcpy(str, ""a"");
    }
    softclip_table_init();
    rnd_table_init();
    init_noise_samples();
    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");
}",0,1,23,0.33,Insert
1224,,,,,,,
1228,"static bool migrate_caps_check(bool *cap_list,
                               MigrationCapabilityStatusList *params,
                               Error **errp)
{
    MigrationCapabilityStatusList *cap;
    bool old_postcopy_cap;
    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];
    for (cap = params; cap; cap = cap->next) {
        cap_list[cap->value->capability] = cap->value->state;
    }
#ifndef CONFIG_LIVE_BLOCK_MIGRATION
    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {
        error_setg(errp, ""QEMU compiled without old-style (blk/-b, inc/-i) ""
                   ""block migration"");
        error_append_hint(errp, ""Use drive_mirror+NBD instead.\n"");
        return false;
    }
#endif
    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {
        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {
            error_setg(errp, ""Postcopy is not currently compatible ""
                       ""with compression"");
            return false;
        }
        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&
            !postcopy_ram_supported_by_host()) {
            error_setg(errp, ""Postcopy is not supported"");
            return false;
        }
    }
    return true;
}","static bool migrate_caps_check(bool *cap_list,
                               MigrationCapabilityStatusList *params,
                               Error **errp)
{
    Rocker *r;
    int *out_size;
    int size;
    *out_size = size;
    DescInfo *info;
    uint32_t port;
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    MigrationCapabilityStatusList *cap;
    char str[] = ""Constant"";
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    while (strlen(str) > 5) {
        bool old_postcopy_cap;
    strcpy(str, ""a"");
    }
    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];
    for (cap = params; cap; cap = cap->next) {
        cap_list[cap->value->capability] = cap->value->state;
    }
#ifndef CONFIG_LIVE_BLOCK_MIGRATION
    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {
        error_setg(errp, ""QEMU compiled without old-style (blk/-b, inc/-i) ""
                   ""block migration"");
        error_append_hint(errp, ""Use drive_mirror+NBD instead.\n"");
        return false;
    }
#endif
    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {
        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {
            error_setg(errp, ""Postcopy is not currently compatible ""
                       ""with compression"");
            return false;
        }
        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&
            !postcopy_ram_supported_by_host()) {
            error_setg(errp, ""Postcopy is not supported"");
            return false;
        }
    }
    return true;
}",0,1,111,1.09,Insert
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}","static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    int a = 2;
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    int b = 2;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    if (a == b) {
        BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    }
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}",0,1,53,0.91,Insert
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
                omap_clk fclk, omap_clk iclk)
{
    struct omap_mmc_s *s = (struct omap_mmc_s *)
            g_malloc0(sizeof(struct omap_mmc_s));
    s->irq = irq;
    s->dma = dma;
    s->clk = fclk;
    s->lines = 4;
    s->rev = 2;
    omap_mmc_reset(s);
    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",
                          omap_l4_region_size(ta, 0));
    omap_l4_attach(ta, 0, &s->iomem);
    s->card = sd_init(bd, false);
    if (s->card == NULL) {
        exit(1);
    }
    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
    sd_set_cb(s->card, NULL, s->cdet);
    return s;
}","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
                omap_clk fclk, omap_clk iclk)
{
    struct omap_mmc_s *s = (struct omap_mmc_s *)
            g_malloc0(sizeof(struct omap_mmc_s));
    s->irq = irq;
    int a = 2;
    int b = 3;
    while (a < b) {
        s->dma = dma;
        b = a;
    }
    s->clk = fclk;
    s->lines = 4;
    s->rev = 2;
    omap_mmc_reset(s);
    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",
                          omap_l4_region_size(ta, 0));
    omap_l4_attach(ta, 0, &s->iomem);
    s->card = sd_init(bd, false);
    if (s->card == NULL) {
        exit(1);
    }
    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
    sd_set_cb(s->card, NULL, s->cdet);
    return s;
}",1,0,2,0.12,Replace
1234,"static void vmxnet3_update_mcast_filters(VMXNET3State *s)
{
    uint16_t list_bytes =
        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,
                                  devRead.rxFilterConf.mfTableLen);
    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);
    s->mcast_list = g_realloc(s->mcast_list, list_bytes);
    if (!s->mcast_list) {
        if (s->mcast_list_len == 0) {
            VMW_CFPRN(""Current multicast list is empty"");
        } else {
            VMW_ERPRN(""Failed to allocate multicast list of %d elements"",
                      s->mcast_list_len);
        }
        s->mcast_list_len = 0;
    } else {
        int i;
        hwaddr mcast_list_pa =
            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,
                                      devRead.rxFilterConf.mfTablePA);
        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);
        VMW_CFPRN(""Current multicast list len is %d:"", s->mcast_list_len);
        for (i = 0; i < s->mcast_list_len; i++) {
            VMW_CFPRN(""\t"" MAC_FMT, MAC_ARG(s->mcast_list[i].a));
        }
    }
}","static void vmxnet3_update_mcast_filters(VMXNET3State *s)
{
    uint16_t list_bytes =
        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,
                                  devRead.rxFilterConf.mfTableLen);
    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);
    s->mcast_list = g_realloc(s->mcast_list, list_bytes);
    if (!s->mcast_list) {
        if (s->mcast_list_len == 0) {
            VMW_CFPRN(""Current multicast list is empty"");
        } else {
            VMW_ERPRN(""Failed to allocate multicast list of %d elements"",
                      s->mcast_list_len);
        }
        s->mcast_list_len = 0;
    } else {
        int i;
        hwaddr mcast_list_pa =
            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,
                                      devRead.rxFilterConf.mfTablePA);
        int a = 2;
        int b = 3;
        while (a != b) {
            pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);
            b = a;
            UINT32 header;
            MPADecodeContext *s_2;
            int sample_rate_index, bitrate_index;
            int sample_rate, frame_size, mpeg25, padding;
            int sample_rate, frame_size, mpeg25, padding;
            sample_rate_index = (header >> 10) & 3;
            sample_rate = mpa_freq_tab[sample_rate_index] >> (s_2->lsf + mpeg25);
            sample_rate_index += 3 * (s_2->lsf + mpeg25);
            s_2->sample_rate_index = sample_rate_index;
        }
        VMW_CFPRN(""Current multicast list len is %d:"", s->mcast_list_len);
        for (i = 0; i < s->mcast_list_len; i++) {
            VMW_CFPRN(""\t"" MAC_FMT, MAC_ARG(s->mcast_list[i].a));
        }
    }
}",1,0,19,0.85,Insert
1237,,,,,,,
1238,,,,,,,
1241,"static void do_info_commands(Monitor *mon, QObject **ret_data)
{
    QList *cmd_list;
    const mon_cmd_t *cmd;
    cmd_list = qlist_new();
    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&
            !compare_cmd(cmd->name, ""info"")) {
            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));
        }
    }
    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {
            char buf[128];
            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);
            qlist_append_obj(cmd_list, get_cmd_dict(buf));
        }
    }
    *ret_data = QOBJECT(cmd_list);
}","static void do_info_commands(Monitor *mon, QObject **ret_data)
{
    QList *cmd_list;
    const mon_cmd_t *cmd;
    cmd_list = qlist_new();
    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&
            !compare_cmd(cmd->name, ""info"")) {
            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));
        }
    }
    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {
            char buf[128];
            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);
            qlist_append_obj(cmd_list, get_cmd_dict(buf));
        }
    }
    int a = 39;
    int b = a;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    if(a*b>0){
        char *filename;
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        *ret_data = QOBJECT(cmd_list);
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        myquery(lang);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        myquery(lang);
    }
}",0,1,82,0.93,Insert
1242,"static void spapr_msi_write(void *opaque, hwaddr addr,
                            uint64_t data, unsigned size)
{
    sPAPRPHBState *phb = opaque;
    int ndev = addr >> 16;
    int vec = ((addr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(addr, data, irq);
    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
}","static void spapr_msi_write(void *opaque, hwaddr addr,
                            uint64_t data, unsigned size)
{
    char str[] = ""Constant"";
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (strlen(str) > 5) {
        sPAPRPHBState *phb = opaque;
    strcpy(str, ""a"");
    }
    int ndev = addr >> 16;
    int vec = ((addr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(addr, data, irq);
    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
}",0,1,46,0.61,Insert
1243,"static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;
    if (addr > s->pm_base + PCMD31) {
        pxa2xx_i2c_write(s->i2c[1], addr, value);
        return;
    }
    addr -= s->pm_base;
    switch (addr) {
    case PMCR:
        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);
        s->pm_regs[addr >> 2] |= value & 0x15;
        break;
    case PSSR:	 
    case RCSR:
    case PKSR:
        s->pm_regs[addr >> 2] &= ~value;
        break;
    default:	 
        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {
            s->pm_regs[addr >> 2] = value;
            break;
        }
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
}","static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;
    if (addr > s->pm_base + PCMD31) {
        pxa2xx_i2c_write(s->i2c[1], addr, value);
        int a = 2;
        int b = 2;
        while (a == b) {
            return;
            b += 1;
        }
        RAMBlock *news_work;
        news_work = g_malloc0(sizeof(*news_work));
        news_work->err = err;
        news_work->realized = realized;
        news_work->used_length = size;
        news_work->max_length = maxlennumber;
    }
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    Unit *u;
    Unit *other;
    int range;
    struct f2fs_sb_info *sbi;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
    		dir = ALLOC_RIGHT;
    Automount *worker = AUTOMOUNT(u);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    range = automount_start_expire(worker);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    item->type = QEMU_INPUT_QUEUE_SYNC;
    QTAILQ_INSERT_TAIL(queue, item, node);
    addr -= s->pm_base;
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    switch (addr) {
    case PMCR:
        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);
        s->pm_regs[addr >> 2] |= value & 0x15;
        break;
    case PSSR:	 
    case RCSR:
    case PKSR:
        s->pm_regs[addr >> 2] &= ~value;
        break;
    default:	 
        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {
            s->pm_regs[addr >> 2] = value;
            break;
        }
        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);
        break;
    }
}",0,1,163,1.39,Insert
1245,"void readline_show_prompt(ReadLineState *rs)
{
    monitor_printf(rs->mon, ""%s"", rs->prompt);
    monitor_flush(rs->mon);
    rs->last_cmd_buf_index = 0;
    rs->last_cmd_buf_size = 0;
    rs->esc_state = IS_NORM;
}","void readline_show_prompt(ReadLineState *rs)
{
    monitor_printf(rs->mon, ""%s"", rs->prompt);
    int a = 38;
    int b = a;
    struct rose_neigh *client;
    rose_neigh_list           = client;
    if(a*b>0){
        monitor_flush(rs->mon);
    }
    rs->last_cmd_buf_index = 0;
    rs->last_cmd_buf_size = 0;
    rs->esc_state = IS_NORM;
}",0,1,28,0.45,Insert
1246,"static int parallel_parse(const char *devname)
{
    static int index = 0;
    char label[32];
    if (strcmp(devname, ""none"") == 0)
        return 0;
    if (index == MAX_PARALLEL_PORTS) {
        fprintf(stderr, ""qemu: too many parallel ports\n"");
        exit(1);
    }
    snprintf(label, sizeof(label), ""parallel%d"", index);
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);
    if (!parallel_hds[index]) {
        fprintf(stderr, ""qemu: could not connect parallel device""
                "" to character backend '%s'\n"", devname);
        return -1;
    }
    index++;
    return 0;
}","static int parallel_parse(const char *devname)
{
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
            QuantizationTable
                *table_4;
            XMLTreeInfo
                *description_2,
                *levels_3,
                *quantization_tables_10,
                *table_iterator_8;
            const char
                *attribute_9,
                *content_4;
            XMLTreeInfo
                *description_2,
                *levels_3,
                *quantization_tables_10,
                *table_iterator_8;
            attribute_9=GetXMLTreeAttribute_7(table_iterator_8,""slot"");
            attribute_9=GetXMLTreeAttribute_7(levels_3,""width"");
            table_4->width=StringToUnsignedLong_10(attribute_9);
            attribute_9=GetXMLTreeAttribute_7(levels_3,""height"");
            table_4->height=StringToUnsignedLong_10(attribute_9);
    }
    static int index = 0;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    char label[32];
    if (strcmp(devname, ""none"") == 0)
        return 0;
    if (index == MAX_PARALLEL_PORTS) {
        int a = 2;
        int b = 3;
        while (a < b) {
            fprintf(stderr, ""qemu: too many parallel ports\n"");
            b = a;
        }
        exit(1);
    }
    snprintf(label, sizeof(label), ""parallel%d"", index);
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);
    if (!parallel_hds[index]) {
        fprintf(stderr, ""qemu: could not connect parallel device""
                "" to character backend '%s'\n"", devname);
        return -1;
    }
    index++;
    return 0;
}",0,1,143,1.18,Insert
1247,"START_TEST(qfloat_destroy_test)
{
    QFloat *qf = qfloat_from_double(0.0);
    QDECREF(qf);
}","START_TEST(qfloat_destroy_test)
{
    char *filename;
    if (!filename) {
            error_report(""Could not find LPAR firmware '%s'"", bios_name);
            exit(1);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        QFloat *qf = qfloat_from_double(0.0);
    strcpy(str, ""a"");
    }
    QDECREF(qf);
}",0,1,23,0.29,Insert
1248,"static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)
{
    int err;
    char buffer[PATH_MAX];
    char *path = fs_path->data;
    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);
    if (err) {
        return err;
    }
    if (fs_ctx->fs_sm == SM_MAPPED) {
        uid_t tmp_uid;
        gid_t tmp_gid;
        mode_t tmp_mode;
        dev_t tmp_dev;
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.uid"", &tmp_uid,
                    sizeof(uid_t)) > 0) {
            stbuf->st_uid = tmp_uid;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.gid"", &tmp_gid,
                    sizeof(gid_t)) > 0) {
            stbuf->st_gid = tmp_gid;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.mode"",
                    &tmp_mode, sizeof(mode_t)) > 0) {
            stbuf->st_mode = tmp_mode;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.rdev"", &tmp_dev,
                        sizeof(dev_t)) > 0) {
                stbuf->st_rdev = tmp_dev;
        }
    }
    return err;
}","static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)
{
    int err;
    char str[] = ""Constant"";
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    while (strlen(str) > 5) {
        char buffer[PATH_MAX];
    strcpy(str, ""a"");
    }
    char *path = fs_path->data;
    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);
    if (err) {
        return err;
    }
    if (fs_ctx->fs_sm == SM_MAPPED) {
        uid_t tmp_uid;
        gid_t tmp_gid;
        mode_t tmp_mode;
        dev_t tmp_dev;
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.uid"", &tmp_uid,
                    sizeof(uid_t)) > 0) {
            stbuf->st_uid = tmp_uid;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.gid"", &tmp_gid,
                    sizeof(gid_t)) > 0) {
            stbuf->st_gid = tmp_gid;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.mode"",
                    &tmp_mode, sizeof(mode_t)) > 0) {
            stbuf->st_mode = tmp_mode;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.rdev"", &tmp_dev,
                        sizeof(dev_t)) > 0) {
                stbuf->st_rdev = tmp_dev;
        }
    }
    USBDevice *dev;
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;
    trace_usb_port_detach(bus->busnr, port->path);
    return err;
}",0,1,64,1.17,Insert
1249,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int t;
    cs->exception_index = EXCP_PGM;
    env->int_pgm_code = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.addr);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.addr += t;
    cpu_loop_exit(cs);
}","void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    int lang, rar;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev_8 = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int t;
    int a = 2;
    int b = 3;
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    while (a != b) {
        cs->exception_index = EXCP_PGM;
        b = a;
    }
    env->int_pgm_code = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.addr);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.addr += t;
    cpu_loop_exit(cs);
}",0,1,80,0.97,Insert
1250,"static int usb_host_init(void)
{
    const struct libusb_pollfd **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}","static int usb_host_init(void)
{
    const struct libusb_pollfd **poll;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int i, rc;
    }
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}",0,1,4,0.13,Replace
1252,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)
{
    VirtIOSCSI *s = req->dev;
    VirtQueue *vq = req->vq;
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);
    if (req->sreq) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
    }
    virtio_scsi_free_req(req);
    virtio_notify(vdev, vq);
}","static void virtio_scsi_complete_req(VirtIOSCSIReq *req)
{
    VirtIOSCSI *s = req->dev;
    int a = 2;
    MpegEncContext *s_4;
    if (s_4->current_picture.reference)
            ff_thread_report_progress(&s_4->current_picture_ptr->tf, INT_MAX, 0);
    int b = 3;
    while (a < b) {
        VirtQueue *vq = req->vq;
        struct sk_buff *skb;
        struct sock *sk;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
        "",
        		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
        length = TCP_SKB_CB(skb)->length;
        b = a;
    }
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);
    char *filename;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    if (req->sreq) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
    }
    virtio_scsi_free_req(req);
    virtio_notify(vdev, vq);
}",0,1,89,0.88,Insert
1253,"bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        if (t == ts) {
            return true;
        }
    }
    return false;
}","bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        if (t == ts) {
            return true;
        }
    }
    int a = 73;
    int b = a;
    if(a*b>0){
        return false;
        VirtIOSCSIReq *req;
        VirtIOSCSI *sb;
        req->dev = sb;
    }
}",0,1,19,0.44,Insert
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
}","static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    int a = 73;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    int b = a;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    if(a*b>0){
        char buf[3];
    }
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
}",0,1,90,0.77,Insert
1257,"static void blk_delete(BlockBackend *blk)
{
    assert(!blk->refcnt);
    assert(!blk->name);
    assert(!blk->dev);
    if (blk->root) {
        blk_remove_bs(blk);
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, blk, link);
    drive_info_del(blk->legacy_dinfo);
    block_acct_cleanup(&blk->stats);
    g_free(blk);","static void blk_delete(BlockBackend *blk)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        assert(!blk->refcnt);
        b += 1;
    }
    assert(!blk->name);
    assert(!blk->dev);
    if (blk->root) {
        blk_remove_bs(blk);
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, blk, link);
    drive_info_del(blk->legacy_dinfo);
    block_acct_cleanup(&blk->stats);
    g_free(blk);",1,0,1,0.06,Replace
1258,,,,,,,
1259,,,,,,,
1260,,,,,,,
1261,,,,,,,
1263,"static int local_open2(FsContext *fs_ctx, const char *path, int flags,
        FsCred *credp)
{
    int fd = -1;
    int err = -1;
    int serrno = 0;
    if (fs_ctx->fs_sm == SM_MAPPED) {
        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);
        if (fd == -1) {
            return fd;
        }
        credp->fc_mode = credp->fc_mode|S_IFREG;
        err = local_set_xattr(rpath(fs_ctx, path), credp);
        if (err == -1) {
            serrno = errno;
            goto err_end;
        }
    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {
        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);
        if (fd == -1) {
            return fd;
        }
        err = local_post_create_passthrough(fs_ctx, path, credp);
        if (err == -1) {
            serrno = errno;
            goto err_end;
        }
    }
    return fd;
err_end:
    close(fd);
    remove(rpath(fs_ctx, path));
    errno = serrno;
    return err;
}","static int local_open2(FsContext *fs_ctx, const char *path, int flags,
        FsCred *credp)
{
    int fd = -1;
    int err = -1;
    int serrno = 0;
    if (fs_ctx->fs_sm == SM_MAPPED) {
        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);
        struct usb_line6 *line6;
        const struct usb_device_id *id;
        struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
        struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
        int err_2;
        toneport->type = id->driver_info;
        INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
        line6->disconnect = line6_toneport_disconnect;
        err_2 = line6_init_pcm(line6, &toneport_pcm_properties);
        err_2 = snd_ctl_add(line6->card,
        			  snd_ctl_new1(&toneport_control_monitor,
        				       line6->line6pcm));
        if (fd == -1) {
            return fd;
        }
        credp->fc_mode = credp->fc_mode|S_IFREG;
        err = local_set_xattr(rpath(fs_ctx, path), credp);
        if (err == -1) {
            serrno = errno;
            goto err_end;
        }
    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {
        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);
        if (fd == -1) {
            return fd;
        }
        err = local_post_create_passthrough(fs_ctx, path, credp);
        if (err == -1) {
            serrno = errno;
            goto err_end;
        }
    }
    return fd;
err_end:
    close(fd);
    remove(rpath(fs_ctx, path));
    errno = serrno;
    return err;
}",1,0,36,0.85,Insert
1264,,,,,,,
1266,,,,,,,
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, ret;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, ret;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                int a = 2;
                int b = 3;
                while (a < b) {
                    return ret;
                    b = a;
                }
                BlockdevOnError on_source_bug;
                BlockdevOnError on_source_complete;
                const char *dev_10;
                enum MirrorSyncMode stage;
                int64_t peed;
                const char *data;
                int data;
                Error *localxer = NULL;
                BlockDriverState *source_vs;
                int64_t store;
                BlockDriverState *bes;
                bes = bdrv_find(dev_10);
                data = bes->open_flags | BDRV_O_RDWR;
                store = bdrv_getlength(bes);
                backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                                 block_job_cb, bes, &localxer);
            }
        }
    }
    return USB_RET_NODEV;
}",0,1,34,0.81,Insert
1272,,,,,,,
1273,"av_cold void ff_dct_init_x86(DCTContext *s)
{
    int cpu_flags = av_get_cpu_flags();
    if (EXTERNAL_SSE(cpu_flags))
        s->dct32 = ff_dct32_float_sse;
    if (EXTERNAL_SSE2(cpu_flags))
        s->dct32 = ff_dct32_float_sse2;
    if (EXTERNAL_AVX(cpu_flags))
        s->dct32 = ff_dct32_float_avx;
}","av_cold void ff_dct_init_x86(DCTContext *s)
{
    Image *image;
    AVPacket * pk;
    AVFormatContext *s_8;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b_4     = s_8->b_4;
    avio_write(b_4,  pk->data, size);
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    int a = 2;
    int b = 3;
    int c, cnt;
    int val;
    int rt;
    TCGv T00, ttyapp;
    QEMUBH *phi;
    phi->cb = cb;
    gen_load_gpr(ttyapp, rt);
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    while (a < b) {
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        int cpu_flags = av_get_cpu_flags();
        b = a;
    }
    if (EXTERNAL_SSE(cpu_flags))
        s->dct32 = ff_dct32_float_sse;
    if (EXTERNAL_SSE2(cpu_flags))
        s->dct32 = ff_dct32_float_sse2;
    if (EXTERNAL_AVX(cpu_flags))
        s->dct32 = ff_dct32_float_avx;
}",0,1,249,1.5,Insert
1275,,,,,,,
1276,"static void test_properties(const char *path, bool recurse)
{
    char *child_path;
    QDict *response, *tuple;
    QList *list;
    QListEntry *entry;
    g_test_message(""Obtaining properties of %s"", path);
    response = qmp(""{ 'execute': 'qom-list',""
                   ""  'arguments': { 'path': %s } }"", path);
    g_assert(response);
    if (!recurse) {
        return;
    }
    g_assert(qdict_haskey(response, ""return""));
    list = qobject_to_qlist(qdict_get(response, ""return""));
    QLIST_FOREACH_ENTRY(list, entry) {
        tuple = qobject_to_qdict(qlist_entry_obj(entry));
        bool is_child = strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL);
        bool is_link = strstart(qdict_get_str(tuple, ""type""), ""link<"", NULL);
        if (is_child || is_link) {
            child_path = g_strdup_printf(""%s/%s"",
                                         path, qdict_get_str(tuple, ""name""));
            test_properties(child_path, is_child);
            g_free(child_path);
        } else {
            const char *prop = qdict_get_str(tuple, ""name"");
            g_test_message(""Testing property %s.%s"", path, prop);
            response = qmp(""{ 'execute': 'qom-get',""
                           ""  'arguments': { 'path': %s,""
                           ""                 'property': %s } }"",
                           path, prop);
            g_assert(response);
        }
    }
}","static void test_properties(const char *path, bool recurse)
{
    char *child_path;
    QDict *response, *tuple;
    int a = 2;
    int b = 3;
    while (a != b) {
        QList *list;
        b = a;
    }
    QListEntry *entry;
    g_test_message(""Obtaining properties of %s"", path);
    response = qmp(""{ 'execute': 'qom-list',""
                   ""  'arguments': { 'path': %s } }"", path);
    g_assert(response);
    if (!recurse) {
        return;
    }
    g_assert(qdict_haskey(response, ""return""));
    list = qobject_to_qlist(qdict_get(response, ""return""));
    QLIST_FOREACH_ENTRY(list, entry) {
        tuple = qobject_to_qdict(qlist_entry_obj(entry));
        bool is_child = strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL);
        bool is_link = strstart(qdict_get_str(tuple, ""type""), ""link<"", NULL);
        AVFilterLink *inlink;
        AVFrame *frame;
        AVFilterContext *ctx = inlink->dst;
        AVFilterContext *ctx = inlink->dst;
        uint32_t plane_checksum[4] = {0}, checksum = 0;
        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
        av_log(ctx, AV_LOG_INFO,
                   ""n:%""PRId64"" pts:%s pts_time:%s pos:%""PRId64"" ""
                   ""fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c ""
                   ""checksum:%08X plane_checksum:[%08X"",
                   inlink->frame_count,
                   av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),
                   desc->name,
                   frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,
                   frame->width, frame->height,
                   !frame->interlaced_frame ? 'P' :          
                   frame->top_field_first   ? 'T' : 'B',     
                   frame->key_frame,
                   av_get_picture_type_char(frame->pict_type),
                   checksum, plane_checksum[0]);
        if (is_child || is_link) {
            child_path = g_strdup_printf(""%s/%s"",
                                         path, qdict_get_str(tuple, ""name""));
            test_properties(child_path, is_child);
            g_free(child_path);
        } else {
            const char *prop = qdict_get_str(tuple, ""name"");
            g_test_message(""Testing property %s.%s"", path, prop);
            response = qmp(""{ 'execute': 'qom-get',""
                           ""  'arguments': { 'path': %s,""
                           ""                 'property': %s } }"",
                           path, prop);
            g_assert(response);
        }
    }
}",1,0,42,1.28,Insert
1280,"static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);
    DeviceState *vdev = DEVICE(&vinput->vdev);
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;
    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;
    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
}","static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    qemu_irq rx[128];
    DisasContext *services;
    gen_compute_eflags(services);
    int *got_frame;
    int c, cnt;
    scoped_refptr<IndexedDBCallbacks> Callcallback;
    IndexedDBTransaction* intermission;
    int64_t object_store_id;
    intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                               this, object_store_id, Callcallback));
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    void *data;
    AVPacket *avpkt;
    const uint8_t *buf = avpkt->data;
    AVFrame *pict      = data;
    assert(pict->buf[0] || !*got_frame);
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    int a = 2;
    int b = 3;
    Unit *u;
    Unit *other;
    int range;
    Automount *worker = AUTOMOUNT(u);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    range = automount_start_expire(worker);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    if (a != b) {
        VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);
    }
    DeviceState *vdev = DEVICE(&vinput->vdev);
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;
    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;
    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
}",0,1,170,1.06,Insert
1281,"static void test_visitor_out_string(TestOutputVisitorData *data,
                                    const void *unused)
{
    char *string = (char *) ""Q E M U"";
    Error *err = NULL;
    QObject *obj;
    visit_type_str(data->ov, &string, NULL, &err);
    g_assert(!err);
    obj = qmp_output_get_qobject(data->qov);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QSTRING);
    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);
    qobject_decref(obj);
}","static void test_visitor_out_string(TestOutputVisitorData *data,
                                    const void *unused)
{
    char *string = (char *) ""Q E M U"";
    Error *err = NULL;
    QObject *obj;
    visit_type_str(data->ov, &string, NULL, &err);
    g_assert(!err);
    int a = 2;
    int b = 3;
    GF_Filter *process;
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    while (a != b) {
        obj = qmp_output_get_qobject(data->qov);
        b = a;
    }
    struct edgeport_serial *serial;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    u8 *data_7;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data_7);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QSTRING);
    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);
    qobject_decref(obj);
}",0,1,117,1.09,Insert
1282,"static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    pcms->vmport = value;
}","static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)
{
    const char
    struct irda_sock *data;
    discinfo_t *discovery;
    int	code;
    discovery = irlmp_get_discoveries(&code, data->mask.word,
    					    data->nslots);
    kfree(discovery);
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    bool lock;
    struct request_list *repl;
    struct request_queue *q = repl->q;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    if (strcmp(str1, str2) == 0) {
        PCMachineState *pcms = PC_MACHINE(obj);
    }
    pcms->vmport = value;
}",0,1,69,0.45,Insert
1284,,,,,,,
1285,,,,,,,
1290,,,,,,,
1291,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,
                                uint8_t *data, unsigned int *data_size, int is32)
{
    SubStream *s = &m->substream[substr];
    unsigned int i, out_ch = 0;
    int32_t *data_32 = (int32_t*) data;
    int16_t *data_16 = (int16_t*) data;
    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))
        return -1;
    for (i = 0; i < s->blockpos; i++) {
        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {
            int mat_ch = s->ch_assign[out_ch];
            int32_t sample = m->sample_buffer[i][mat_ch]
                          << s->output_shift[mat_ch];
            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;
            if (is32) *data_32++ = sample << 8;
            else      *data_16++ = sample >> 8;
        }
    }
    *data_size = i * out_ch * (is32 ? 4 : 2);
    return 0;
}","static int output_data_internal(MLPDecodeContext *m, unsigned int substr,
                                uint8_t *data, unsigned int *data_size, int is32)
{
    SubStream *s = &m->substream[substr];
    unsigned int i, out_ch = 0;
    int32_t *data_32 = (int32_t*) data;
    int16_t *data_16 = (int16_t*) data;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))
        return -1;
    for (i = 0; i < s->blockpos; i++) {
        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {
            int mat_ch = s->ch_assign[out_ch];
            int32_t sample = m->sample_buffer[i][mat_ch]
                          << s->output_shift[mat_ch];
            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;
            if (is32) *data_32++ = sample << 8;
            else      *data_16++ = sample >> 8;
        }
    }
    *data_size = i * out_ch * (is32 ? 4 : 2);
    int a = 38;
    int b = a;
    if(a*b>0){
        return 0;
    }
}",0,1,19,0.76,Insert
1293,,,,,,,
1294,"void pl011_init(uint32_t base, qemu_irq irq,
                CharDriverState *chr)
{
    int iomemtype;
    pl011_state *s;
    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
    iomemtype = cpu_register_io_memory(0, pl011_readfn,
                                       pl011_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->chr = chr;
    s->read_trigger = 1;
    s->ifl = 0x12;
    s->cr = 0x300;
    s->flags = 0x90;
    if (chr){ 
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
                              pl011_event, s);
    }
}","void pl011_init(uint32_t base, qemu_irq irq,
                CharDriverState *chr)
{
    int iomemtype;
    pl011_state *s;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
    }
    iomemtype = cpu_register_io_memory(0, pl011_readfn,
                                       pl011_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->chr = chr;
    s->read_trigger = 1;
    s->ifl = 0x12;
    s->cr = 0x300;
    s->flags = 0x90;
    if (chr){ 
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
                              pl011_event, s);
    }
}",1,0,1,0.09,Replace
1295,,,,,,,
1297,,,,,,,
1299,,,,,,,
1301,,,,,,,
1303,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        return true;
    }
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}","bool vring_should_notify(VirtIODevice *vdev, Vring *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        return true;
    }
    smbus_alarm_callback bc;
    struct acpi_smb_hc *Hdc;
    void *length;
    mutex_lock(&Hdc->lock);
    Hdc->bc = bc;
    Hdc->length = length;
    mutex_unlock(&Hdc->lock);
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
                             int c, cnt;
                             struct net_device *dev;
                             struct l2tp_eth *priv = netdev_priv(dev);
                             if (likely(ret == NET_XMIT_SUCCESS)) {
                             		atomic_long_add(len, &priv->tx_bytes);
                             		atomic_long_inc(&priv->tx_packets);
                             	} else {
                             		atomic_long_inc(&priv->tx_dropped);
                             }
                             int val;
                             struct timeval t1, t2;
                             int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
                             int64_t alpha;
                             int total = 0;
                             print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        mysql_close(mysql___global);
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return true;
        strcpy(str, ""a"");
        }
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}",0,1,124,1.08,Insert
1305,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,
                          int is_asi, int size)
{
    CPUState *saved_env;
    saved_env = env;
    env = cpu_single_env;
    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",
             addr, is_write, is_exec);
    if (!(env->sregs[SR_MSR] & MSR_EE)) {
        return;
    }
    if (is_exec) {
        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    } else {
        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    }
}","void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,
                          int is_asi, int size)
{
    int nb_oargs;
    bool has_mode;
    const char *data;
    int data;
    if (!has_mode) {
            data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
    }
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        CPUState *saved_env;
    strcpy(str, ""a"");
    }
    saved_env = env;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    quantization_tables=NewXMLTree(xml,exception);
    quantization_tables=DestroyXMLTree(quantization_tables);
    env = cpu_single_env;
    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",
             addr, is_write, is_exec);
    if (!(env->sregs[SR_MSR] & MSR_EE)) {
        return;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
    }
    if (is_exec) {
        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    } else {
        VirtIOSCSIReq *req;
        VirtIOSCSI *sb;
        req->dev = sb;
        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;
            helper_raise_exception(EXCP_HW_EXCP);
        }
    }
}",0,1,140,1.19,Insert
1307,,,,,,,
1308,,,,,,,
1309,,,,,,,
1313,,,,,,,
1314,,,,,,,
1315,,,,,,,
1316,"static void v9fs_readdir(void *opaque)
{
    int32_t fid;
    V9fsFidState *fidp;
    ssize_t retval = 0;
    size_t offset = 7;
    uint64_t initial_offset;
    int32_t count;
    uint32_t max_count;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    pdu_unmarshal(pdu, offset, ""dqd"", &fid, &initial_offset, &max_count);
    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        retval = -EINVAL;
        goto out_nofid;
    }
    if (!fidp->fs.dir) {
        retval = -EINVAL;
        goto out;
    }
    if (initial_offset == 0) {
        v9fs_co_rewinddir(pdu, fidp);
    } else {
        v9fs_co_seekdir(pdu, fidp, initial_offset);
    }
    count = v9fs_do_readdir(pdu, fidp, max_count);
    if (count < 0) {
        retval = count;
        goto out;
    }
    retval = offset;
    retval += pdu_marshal(pdu, offset, ""d"", count);
    retval += count;
    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);
out:
    put_fid(pdu, fidp);
out_nofid:
    complete_pdu(s, pdu, retval);
}","static void v9fs_readdir(void *opaque)
{
    int32_t fid;
    V9fsFidState *fidp;
    DictionaryValue* strings;
    strings->SetString(""proceed"",
          l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));
    ssize_t retval = 0;
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset_10;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset_10+layer_info->channel_info[url].size-2,SEEK_SET);
    size_t offset = 7;
    uint64_t initial_offset;
    int32_t count;
    uint32_t max_count;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    pdu_unmarshal(pdu, offset, ""dqd"", &fid, &initial_offset, &max_count);
    int a = 75;
    int b = a;
    if(a*b>0){
        trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);
    }
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        retval = -EINVAL;
        goto out_nofid;
    }
    if (!fidp->fs.dir) {
        retval = -EINVAL;
        goto out;
    }
    if (initial_offset == 0) {
        v9fs_co_rewinddir(pdu, fidp);
    } else {
        v9fs_co_seekdir(pdu, fidp, initial_offset);
    }
    count = v9fs_do_readdir(pdu, fidp, max_count);
    if (count < 0) {
        retval = count;
        goto out;
    }
    retval = offset;
    retval += pdu_marshal(pdu, offset, ""d"", count);
    retval += count;
    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);
out:
    put_fid(pdu, fidp);
out_nofid:
    complete_pdu(s, pdu, retval);
}",0,1,65,1.08,Insert
1317,"uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    uint32_t cc = 0;
    int old_exc = cs->exception_index;
    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
    uint64_t ret;
    int flags;
    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {
        program_interrupt(env, PGM_SPECIAL_OP, 2);
    }
    cs->exception_index = old_exc;
    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {
        cc = 3;
    }
    if (cs->exception_index == EXCP_PGM) {
        ret = env->int_pgm_code | 0x80000000;
    } else {
        ret |= addr & ~TARGET_PAGE_MASK;
    }
    cs->exception_index = old_exc;
    env->cc_op = cc;
    return ret;
}","uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    uint32_t cc = 0;
    int old_exc = cs->exception_index;
    int a = 36;
    int b = a;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    MachineState *machine;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if(a*b>0){
        uint64_t asc = env->psw.mask & PSW_MASK_ASC;
    }
    uint64_t ret;
    int flags;
    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {
        program_interrupt(env, PGM_SPECIAL_OP, 2);
    }
    cs->exception_index = old_exc;
    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {
        cc = 3;
    }
    if (cs->exception_index == EXCP_PGM) {
        ret = env->int_pgm_code | 0x80000000;
    } else {
        ret |= addr & ~TARGET_PAGE_MASK;
    }
    cs->exception_index = old_exc;
    env->cc_op = cc;
    return ret;
}",0,1,182,1.5,Insert
1318,"static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,
                                  uint64_t new_shared_perm,
                                  BdrvChild *ignore_child, Error **errp)
{
    BdrvChild *c;
    uint64_t cumulative_perms = new_used_perm;
    uint64_t cumulative_shared_perms = new_shared_perm;
    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);
    QLIST_FOREACH(c, &bs->parents, next_parent) {
        if (c == ignore_child) {
            continue;
        }
        if ((new_used_perm & c->shared_perm) != new_used_perm) {
            char *user = bdrv_child_user_desc(c);
            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);
            error_setg(errp, ""Conflicts with use by %s as '%s', which does not ""
                             ""allow '%s' on %s"",
                       user, c->name, perm_names, bdrv_get_node_name(c->bs));
            g_free(user);
            g_free(perm_names);
            return -EPERM;
        }
        if ((c->perm & new_shared_perm) != c->perm) {
            char *user = bdrv_child_user_desc(c);
            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);
            error_setg(errp, ""Conflicts with use by %s as '%s', which uses ""
                             ""'%s' on %s"",
                       user, c->name, perm_names, bdrv_get_node_name(c->bs));
            g_free(user);
            g_free(perm_names);
            return -EPERM;
        }
        cumulative_perms |= c->perm;
        cumulative_shared_perms &= c->shared_perm;
    }
    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);
}","static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,
                                  uint64_t new_shared_perm,
                                  BdrvChild *ignore_child, Error **errp)
{
    BdrvChild *c;
    uint64_t cumulative_perms = new_used_perm;
    uint64_t cumulative_shared_perms = new_shared_perm;
    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);
    QLIST_FOREACH(c, &bs->parents, next_parent) {
        if (c == ignore_child) {
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                continue;
            strcpy(str, ""a"");
            }
        }
        if ((new_used_perm & c->shared_perm) != new_used_perm) {
            char *user = bdrv_child_user_desc(c);
            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);
            error_setg(errp, ""Conflicts with use by %s as '%s', which does not ""
                             ""allow '%s' on %s"",
                       user, c->name, perm_names, bdrv_get_node_name(c->bs));
            g_free(user);
            g_free(perm_names);
            DisasContext *qs;
            uint32_t ksns;
            const char
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            char
                *p_9,
                *xml;
            double
                value;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            content=GetXMLTreeContent(description);
            content=GetXMLTreeContent(levels);
            value=InterpretLocaleValue(content,&p_9);
            unsigned int coll, order, err, resp, coll, p, nzcv;
            const AVFrame *capt;
            const AVFrame *const p_2 = capt;
            uint8_t *cur  = NULL;
            cur  = p_2->data[0];
            unsigned int coll, order, err, resp, coll, p, nzcv;
            unsigned int coll, order, err, resp, coll, p, nzcv;
            unsigned int coll, order, err, resp, coll, p, nzcv;
            err = extract32(ksns, 16, 5);
            handle_fp_compare(qs, order, coll, err, false, p);
            return -EPERM;
        }
        if ((c->perm & new_shared_perm) != c->perm) {
            char *user = bdrv_child_user_desc(c);
            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);
            error_setg(errp, ""Conflicts with use by %s as '%s', which uses ""
                             ""'%s' on %s"",
                       user, c->name, perm_names, bdrv_get_node_name(c->bs));
            g_free(user);
            g_free(perm_names);
            return -EPERM;
        }
        cumulative_perms |= c->perm;
        cumulative_shared_perms &= c->shared_perm;
    }
    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);
}",0,1,107,1.43,Insert
1319,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)
{
    QDict *qmp;
    qmp = qdict_new();
    if (!monitor_has_error(mon)) {
        if (data) {
            assert(qobject_type(data) == QTYPE_QDICT);
            qobject_incref(data);
            qdict_put_obj(qmp, ""return"", data);
        } else {
            qdict_put(qmp, ""return"", qdict_new());
        }
    } else {
        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));
        qdict_put(qmp, ""error"", mon->error->error);
        QINCREF(mon->error->error);
        QDECREF(mon->error);
        mon->error = NULL;
    }
    if (mon->mc->id) {
        qdict_put_obj(qmp, ""id"", mon->mc->id);
        mon->mc->id = NULL;
    }
    monitor_json_emitter(mon, QOBJECT(qmp));
    QDECREF(qmp);
}","static void monitor_protocol_emitter(Monitor *mon, QObject *data)
{
    QDict *qmp;
    qmp = qdict_new();
    if (!monitor_has_error(mon)) {
        DisasContext *ctx;
        int32_t r1, r2;
        r2  = MASK_OP_BO_S2(ctx->opcode);
        if (data) {
            assert(qobject_type(data) == QTYPE_QDICT);
            qobject_incref(data);
            qdict_put_obj(qmp, ""return"", data);
            MachineState *machine;
            char *filename;
            sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
            long load_limit, fw_size;
            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
            spapr->rtas_size = get_image_size(filename);
            g_free(filename);
            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
            fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        } else {
            qdict_put(qmp, ""return"", qdict_new());
        }
    } else {
        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));
        qdict_put(qmp, ""error"", mon->error->error);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            QINCREF(mon->error->error);
        strcpy(str, ""a"");
        }
        QDECREF(mon->error);
        mon->error = NULL;
    }
    if (mon->mc->id) {
        qdict_put_obj(qmp, ""id"", mon->mc->id);
        mon->mc->id = NULL;
    }
    monitor_json_emitter(mon, QOBJECT(qmp));
    QDECREF(qmp);
}",0,1,71,0.93,Insert
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,
                          const uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    int ret;
    if (!drv) {
        return -ENOMEDIUM;
    }
    if (!drv->bdrv_write_compressed) {
        return -ENOTSUP;
    }
    ret = bdrv_check_request(bs, sector_num, nb_sectors);
    if (ret < 0) {
        return ret;
    }
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);
}","int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,
                          const uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    int c, cnt;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    int ret;
    if (!drv) {
        return -ENOMEDIUM;
    }
    if (!drv->bdrv_write_compressed) {
        return -ENOTSUP;
    }
    ret = bdrv_check_request(bs, sector_num, nb_sectors);
    if (ret < 0) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return ret;
        strcpy(str, ""a"");
        }
    }
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);
}",0,1,63,0.7,Insert
1324,,,,,,,
1326,,,,,,,
1327,"int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,
                              int64_t wanted_timestamp, int flags)
{
    int a, b, m;
    int64_t timestamp;
    a = -1;
    b = nb_entries;
    if (b && entries[b - 1].timestamp < wanted_timestamp)
        a = b - 1;
    while (b - a > 1) {
        m         = (a + b) >> 1;
        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {
            m++;
            if (m == b && entries[m].timestamp >= wanted_timestamp) {
                m = b - 1;
                break;
            }
        }
        timestamp = entries[m].timestamp;
        if (timestamp >= wanted_timestamp)
            b = m;
        if (timestamp <= wanted_timestamp)
            a = m;
    }
    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
    if (!(flags & AVSEEK_FLAG_ANY))
        while (m >= 0 && m < nb_entries &&
               !(entries[m].flags & AVINDEX_KEYFRAME))
            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;
    if (m == nb_entries)
        return -1;
    return m;
}","int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,
                              int64_t wanted_timestamp, int flags)
{
    int a, b, m;
    int64_t timestamp;
    a = -1;
    b = nb_entries;
    if (b && entries[b - 1].timestamp < wanted_timestamp)
        a = b - 1;
    while (b - a > 1) {
        m         = (a + b) >> 1;
        AVPacket * pk;
        AVFormatContext *s;
        const int stream_index =  pk->stream_index;
        int size               =  pk->size;
        AVIOContext *b_2     = s->b_2;
        avio_write(b_2,  pk->data, size);
        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {
            char str_1[] = ""Constant"";
            if (strlen(str_1) > 0) {
                m++;
            }
            if (m == b && entries[m].timestamp >= wanted_timestamp) {
                m = b - 1;
                break;
            }
        }
        timestamp = entries[m].timestamp;
        if (timestamp >= wanted_timestamp)
            b = m;
        if (timestamp <= wanted_timestamp)
            a = m;
    }
    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
    if (!(flags & AVSEEK_FLAG_ANY))
        while (m >= 0 && m < nb_entries &&
               !(entries[m].flags & AVINDEX_KEYFRAME))
            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;
    if (m == nb_entries)
        return -1;
    return m;
}",0,1,23,1.28,Insert
1328,,,,,,,
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}","void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    int a = 2;
    S390CPU *console;
    Error *order = NULL;
    console = cpu_s390x_create(cpu_model, &order);
    int b = 3;
    struct client_session *c;
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    int http_status;
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    data = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    struct session_request *sr;
    struct mk_list *host_list = &config->hosts;
    struct mk_list *sr_list = &c->request_list;
    if (http_status > 0) {
            if (!sr->host_conf) {
                sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
            }
            mk_request_error(http_status, c, sr);
            mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                NULL, c, sr);
    }
    if (a != b) {
        TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
    }
}",0,1,100,0.68,Insert
1333,"void stl_phys_notdirty(hwaddr addr, uint32_t val)
{
    uint8_t *ptr;
    MemoryRegionSection *section;
    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);
    if (!memory_region_is_ram(section->mr) || section->readonly) {
        addr = memory_region_section_addr(section, addr);
        if (memory_region_is_ram(section->mr)) {
            section = &phys_sections[phys_section_rom];
        }
        io_mem_write(section->mr, addr, val, 4);
    } else {
        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)
                               & TARGET_PAGE_MASK)
            + memory_region_section_addr(section, addr);
        ptr = qemu_get_ram_ptr(addr1);
        stl_p(ptr, val);
        if (unlikely(in_migration)) {
            if (!cpu_physical_memory_is_dirty(addr1)) {
                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);
                cpu_physical_memory_set_dirty_flags(
                    addr1, (0xff & ~CODE_DIRTY_FLAG));
            }
        }
    }
}","void stl_phys_notdirty(hwaddr addr, uint32_t val)
{
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    Unit *other;
    assert_6(other);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    uint8_t *ptr;
    MemoryRegionSection *section;
    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);
    if (!memory_region_is_ram(section->mr) || section->readonly) {
        char str[] = ""Constant"";
        void *userdata;
        Link *link = userdata;
        assert(link);
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VdpDecoderProfile profile_3;
        AVCodecContext *AVcas_8;
        uint32_t input;
        VdpDecoderCreate *create;
        VDPAUHWContext *hwctx = AVcas_8->hwaccel_context;
        VDPAUContext *hdtx_7 = AVcas_8->internal->hwaccel_priv_data;
        VdpStatus status_10;
        status_10 = create(hdtx_7->device, profile_3, width, input, AVcas_8->refs,
                            &hdtx_7->decoder);
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        while (strlen(str) > 5) {
            addr = memory_region_section_addr(section, addr);
        strcpy(str, ""a"");
        }
        if (memory_region_is_ram(section->mr)) {
            char *filename;
            g_free(filename);
            section = &phys_sections[phys_section_rom];
        }
        io_mem_write(section->mr, addr, val, 4);
    } else {
        Rocker *r;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        DescInfo *info;
        uint32_t port;
        int err = ROCKER_OK;
        char *buf = desc_get_buf(info, true);
        struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
        PCIDevice *dev = PCI_DEVICE(r);
        int iovcnt = 0;
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        err = fp_port_eg(r->fp_port[port], iov, iovcnt);
        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)
                               & TARGET_PAGE_MASK)
            + memory_region_section_addr(section, addr);
        ptr = qemu_get_ram_ptr(addr1);
        stl_p(ptr, val);
        if (unlikely(in_migration)) {
            if (!cpu_physical_memory_is_dirty(addr1)) {
                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);
                cpu_physical_memory_set_dirty_flags(
                    addr1, (0xff & ~CODE_DIRTY_FLAG));
            }
        }
    }
}",0,1,1343,6.69,Insert
1334,"static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}","static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    float *ptr;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table->slot=(char *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        int a = 2;
        int b = 3;
        while (a < b) {
            float *csa = &csa_table_float[0][0];
            b = a;
        }
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}",0,1,47,0.92,Insert
1335,,,,,,,
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    return inline_cvttq(env, a, float_round_to_zero, 0);
}","uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    CPUPPCState *env_8;
    spr_register(env_8, SPR_750FX_HID2, ""HID2"",
                     SPR_NOACCESS, SPR_NOACCESS,
                     &spr_read_generic, &spr_write_generic,
                     0x00000000);
    spr_register(env_8, SPR_970_HID5, ""HID5"",
                     SPR_NOACCESS, SPR_NOACCESS,
                     &spr_read_generic, &spr_write_generic,
                     POWERPC970_HID5_INIT);
    spr_register(env_8, SPR_L2CR, ""L2CR"",
                     SPR_NOACCESS, SPR_NOACCESS,
                     &spr_read_generic, NULL,
                     0x00000000);
    gen_low_BATs(env_8);
    spr_register(env_8, SPR_MMUCFG, ""MMUCFG"",
                     SPR_NOACCESS, SPR_NOACCESS,
                     &spr_read_generic, SPR_NOACCESS,
                     0x00000000);
    return inline_cvttq(env, a, float_round_to_zero, 0);
}",1,0,3,0.19,Insert
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)
{
    int ret;
    s->ext_audio_mask = 0;
    s->xch_pos = s->xxch_pos = s->x96_pos = 0;
    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)
        return ret;
    s->gb_in = s->gb;
    if ((ret = parse_frame_header(s)) < 0)
        return ret;
    if ((ret = alloc_sample_buffer(s)) < 0)
        return ret;
    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)
        return ret;
    if ((ret = parse_optional_info(s)) < 0)
        return ret;
    if (s->frame_size > size && s->frame_size < size + 4)
        s->frame_size = size;
    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {
        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");
        if (s->avctx->err_recognition & AV_EF_EXPLODE)
            return AVERROR_INVALIDDATA;
    }
    return 0;
}","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int ret;
        b += 1;
    }
    s->ext_audio_mask = 0;
    s->xch_pos = s->xxch_pos = s->x96_pos = 0;
    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)
        return ret;
    s->gb_in = s->gb;
    if ((ret = parse_frame_header(s)) < 0)
        return ret;
    if ((ret = alloc_sample_buffer(s)) < 0)
        return ret;
    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)
        return ret;
    if ((ret = parse_optional_info(s)) < 0)
        return ret;
    if (s->frame_size > size && s->frame_size < size + 4)
        s->frame_size = size;
    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {
        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        order = extract32(ksns, 22, 2);
        handle_fp_compare(qs, order, coll, err, false, p);
        if (s->avctx->err_recognition & AV_EF_EXPLODE)
            return AVERROR_INVALIDDATA;
    }
    return 0;
}",0,1,16,1.12,Insert
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc, sr_cy);
    tcg_temp_free(sr_cy);
}","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    ResourceRecord rr;
    rr.type = DNS_QUERY_NONE;
    rr.rdlength = 0;
    rr.ttl = 1;
    rr.rr_class = 0;
    this->ttl = rr.ttl;
    if (strcmp(str1, str2) == 0) {
        gen_ove_cy(dc, sr_cy);
    }
    tcg_temp_free(sr_cy);
}",1,0,16,0.4,Insert
1339,"static int decode_init_mp3on4(AVCodecContext * avctx)
{
    MP3On4DecodeContext *s = avctx->priv_data;
    int i;
    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {
        av_log(avctx, AV_LOG_ERROR, ""Codec extradata missing or too short.\n"");
        return -1;
    }
    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;
    s->frames = mp3Frames[s->chan_cfg];
    if(!s->frames) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid channel config number.\n"");
        return -1;
    }
    avctx->channels = mp3Channels[s->chan_cfg];
    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));
    avctx->priv_data = s->mp3decctx[0];
    decode_init(avctx);
    avctx->priv_data = s;
    s->mp3decctx[0]->adu_mode = 1;  
    for (i = 1; i < s->frames; i++) {
        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));
        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;
        s->mp3decctx[i]->adu_mode = 1;
        s->mp3decctx[i]->avctx = avctx;
    }
    return 0;
}","static int decode_init_mp3on4(AVCodecContext * avctx)
{
    MP3On4DecodeContext *s = avctx->priv_data;
    int i;
    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {
        av_log(avctx, AV_LOG_ERROR, ""Codec extradata missing or too short.\n"");
        return -1;
    }
    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;
    s->frames = mp3Frames[s->chan_cfg];
    if(!s->frames) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid channel config number.\n"");
        return -1;
    }
    avctx->channels = mp3Channels[s->chan_cfg];
    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    char **names;
    char *p;
    char *ea_namelist = smallbuf;
    size_t num_names;
    for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
    		names[num_names++] = p;
    }
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    avctx->priv_data = s->mp3decctx[0];
    decode_init(avctx);
    avctx->priv_data = s;
    s->mp3decctx[0]->adu_mode = 1;  
    for (i = 1; i < s->frames; i++) {
        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));
        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;
        s->mp3decctx[i]->adu_mode = 1;
        s->mp3decctx[i]->avctx = avctx;
    }
    return 0;
}",0,1,81,0.96,Insert
1341,,,,,,,
1344,,,,,,,
1346,,,,,,,
1347,"static void init_dequant8_coeff_table(H264Context *h){
    int i,q,x;
    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c);  
    h->dequant8_coeff[0] = h->dequant8_buffer[0];
    h->dequant8_coeff[1] = h->dequant8_buffer[1];
    for(i=0; i<2; i++ ){
        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){
            h->dequant8_coeff[1] = h->dequant8_buffer[0];
            break;
        }
        for(q=0; q<52; q++){
            int shift = div6[q];
            int idx = rem6[q];
            for(x=0; x<64; x++)
                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =
                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *
                    h->pps.scaling_matrix8[i][x]) << shift;
        }
    }
}","static void init_dequant8_coeff_table(H264Context *h){
    int i,q,x;
    hwaddr val;
    CPUAlphaState *viron = &cpu->viron;
    viron->trap_arg0 = val;
    int a = 6;
    int b = a;
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    if(a*b>0){
        const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c);  
    }
    h->dequant8_coeff[0] = h->dequant8_buffer[0];
    h->dequant8_coeff[1] = h->dequant8_buffer[1];
    for(i=0; i<2; i++ ){
        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){
            h->dequant8_coeff[1] = h->dequant8_buffer[0];
            break;
        }
        for(q=0; q<52; q++){
            int shift = div6[q];
            int idx = rem6[q];
            for(x=0; x<64; x++)
                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =
                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *
                    h->pps.scaling_matrix8[i][x]) << shift;
        }
    }
}",0,1,72,1.35,Insert
1348,,,,,,,
1349,"PPC_OP(set_T0)
{
    T0 = PARAM(1);
    RETURN();
}","PPC_OP(set_T0)
{
    T0 = PARAM(1);
    int a = 2;
    int b = 3;
    while (a != b) {
        RETURN();
        size_t old_address, type;
        void *new__addr;
        size_t old_address, type;
        old_address = *(size_t *)((char *)cp - 16);
        memcpy(new__addr, cp, type);
        g_free(cp);
        b = a;
    }
}",1,0,5,0.23,Insert
1350,,,,,,,
1351,,,,,,,
1352,"static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,
                                  size_t *count)
{
    GIOStatus status;
    OVERLAPPED ov = {0};
    BOOL ret;
    DWORD written;
    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ret = WriteFile(c->handle, buf, size, &written, &ov);
    if (!ret) {
        if (GetLastError() == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);
            if (!ret) {
                if (!GetLastError()) {
                    status = G_IO_STATUS_AGAIN;
                } else {
                    status = G_IO_STATUS_ERROR;
            } else {
                status = G_IO_STATUS_NORMAL;
                *count = written;
        } else {
            status = G_IO_STATUS_ERROR;
    } else {
        status = G_IO_STATUS_NORMAL;
        *count = written;
    return status;","static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,
                                  size_t *count)
{
    GIOStatus status;
    OVERLAPPED ov = {0};
    BOOL ret;
    DWORD written;
    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ret = WriteFile(c->handle, buf, size, &written, &ov);
    if (!ret) {
        if (GetLastError() == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);
            if (!ret) {
                if (!GetLastError()) {
                    char str[] = ""Constant"";
                    struct socket *pocket;
                    int status_9, status_9;
                    struct pocket *work = pocket->work;
                    struct netlink_sock *nlks = nlk_sk(work);
                    if (nlks->cb_running &&
                    	    atomic_read(&work->sk_rmem_alloc) <= work->sk_rcvbuf / 2) {
                    		status_9 = netlink_dump(work);
                    		if (status_9) {
                    			work->sk_err = status_9;
                    			work->sk_error_report(work);
                    		}
                    }
                    if (strlen(str) > 0) {
                        status = G_IO_STATUS_AGAIN;
                        AioContext *ctx;
                        AioHandler *node;
                        if (!aio_epoll_enabled(ctx)) {
                                QLIST_FOREACH(node, &ctx->aio_handlers, node) {
                                    if (!node->deleted && node->pfd.events
                                        && aio_node_check(ctx, node->is_external)) {
                                        add_pollfd(node);
                                    }
                                }
                        }
                    }
                } else {
                    status = G_IO_STATUS_ERROR;
            } else {
                status = G_IO_STATUS_NORMAL;
                *count = written;
        } else {
            status = G_IO_STATUS_ERROR;
    } else {
        status = G_IO_STATUS_NORMAL;
        *count = written;
    return status;",1,0,55,1.06,Insert
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            tlb_flush(CPU(cpu));
        }
    }
}","void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                ppc_store_sdr1(env, val);
            strcpy(str, ""a"");
            }
            tlb_flush(CPU(cpu));
        }
    }
}",0,1,5,0.07,Replace
1356,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,
                                  unsigned size, bool is_write)
{
    return (size == 1) || (is_write && size == 2);
}","static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,
                                  unsigned size, bool is_write)
{
    int a = 2;
    const char *filename;
    int64_t parent;
    int ecd;
    ecd = open(filename, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    int b = 2;
    struct tty_struct *reader;
    struct awm *awm = reader->driver_data;
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    struct acm_wb *sth;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_4;
    a_4 = ldb_schema_attribute_by_name(ydm, attr);
    struct awm *awm = reader->driver_data;
    if (sth->len == awm->writesize) {
    		acm_tty_flush_chars(reader);
    		goto overflow;
    }
    while (a == b) {
        return (size == 1) || (is_write && size == 2);
        b += 1;
    }
}",0,1,112,0.74,Insert
1357,"sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,
                                   uint64_t bus_offset,
                                   uint32_t page_shift,
                                   uint32_t nb_table,
                                   bool vfio_accel)
{
    sPAPRTCETable *tcet;
    char tmp[64];
    if (spapr_tce_find_by_liobn(liobn)) {
        fprintf(stderr, ""Attempted to create TCE table with duplicate""
                "" LIOBN 0x%x\n"", liobn);
        return NULL;
    }
    if (!nb_table) {
        return NULL;
    }
    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));
    tcet->liobn = liobn;
    tcet->bus_offset = bus_offset;
    tcet->page_shift = page_shift;
    tcet->nb_table = nb_table;
    tcet->vfio_accel = vfio_accel;
    snprintf(tmp, sizeof(tmp), ""tce-table-%x"", liobn);
    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);
    object_property_set_bool(OBJECT(tcet), true, ""realized"", NULL);
    return tcet;
}","sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,
                                   uint64_t bus_offset,
                                   uint32_t page_shift,
                                   uint32_t nb_table,
                                   bool vfio_accel)
{
    sPAPRTCETable *tcet;
    char tmp[64];
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    aml_append_8(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                     aml_name(""CDW1"")));
    aml_append_8(ifconfig, ifconfig0);
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    aml_append_8(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                     aml_name(""CDW1"")));
    if (spapr_tce_find_by_liobn(liobn)) {
        fprintf(stderr, ""Attempted to create TCE table with duplicate""
                "" LIOBN 0x%x\n"", liobn);
        int a = 2;
        Aml *var;
        Aml *dev = aml_device(""%s"", ""PCI0"");
        aml_append(var, dev);
        int b = 3;
        while (a < b) {
            return NULL;
            b = a;
            struct dir *dir;
            GF_Filter *process;
            GF_FilterPid *pid;
            CTXLoadPriv *git = gf_filter_get_udta(process);
            const GF_PropertyValue *proc;
            gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
            gf_filter_pid_set_udta(pid, git->out_pid);
            proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
            struct proc_mounts *p = dir->private_data;
            if (mnt_had_events(p))
            		res |= POLLERR | POLLPRI;
        }
    }
    int nb_oargs;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if (!nb_table) {
        return NULL;
    }
    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));
    tcet->liobn = liobn;
    tcet->bus_offset = bus_offset;
    tcet->page_shift = page_shift;
    tcet->nb_table = nb_table;
    tcet->vfio_accel = vfio_accel;
    snprintf(tmp, sizeof(tmp), ""tce-table-%x"", liobn);
    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);
    object_property_set_bool(OBJECT(tcet), true, ""realized"", NULL);
    return tcet;
}",0,1,236,1.51,Insert
1358,,,,,,,
1362,,,,,,,
1364,,,,,,,
1366,,,,,,,
1369,"int avpriv_lock_avformat(void)
{
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))
            return -1;
    }
    return 0;
}","int avpriv_lock_avformat(void)
{
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))
            return -1;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
    }
}",1,0,1,0.04,Replace
1371,"static int cinepak_decode_frame(AVCodecContext *avctx,
                                void *data, int *got_frame,
                                AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int ret = 0, buf_size = avpkt->size;
    CinepakContext *s = avctx->priv_data;
    s->data = buf;
    s->size = buf_size;
    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)
        return ret;
    if (s->palette_video) {
        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);
        if (pal) {
            s->frame->palette_has_changed = 1;
            memcpy(s->pal, pal, AVPALETTE_SIZE);
        }
    }
    if ((ret = cinepak_decode(s)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""cinepak_decode failed\n"");
    }
    if (s->palette_video)
        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);
    if ((ret = av_frame_ref(data, s->frame)) < 0)
        return ret;
    *got_frame = 1;
    return buf_size;
}","static int cinepak_decode_frame(AVCodecContext *avctx,
                                void *data, int *got_frame,
                                AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int ret = 0, buf_size = avpkt->size;
    CinepakContext *s = avctx->priv_data;
    s->data = buf;
    s->size = buf_size;
    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)
        return ret;
        AVPacket *afpud;
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        tcg_insn_unit *func_addr;
        func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
        tcg_out_call(service, func_addr);
        AVCodecContext *avctx_7;
        size_t ie_len;
        const u8 *IE;
        struct sk_buff *img;
        if (IE)
        		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
        int sample_scale, c, n, i;
        int sample_scale, c, n, i;
        int buf_size_3 = afpud->size;
        PCMDecode *s_8 = avctx_7->priv_data;
        sample_scale = av_get_bits_per_sample(avctx_7->codec_id)/8;
        n = avctx_7->channels * sample_scale;
        n = buf_size_3/sample_scale;
    if (s->palette_video) {
        int a = 2;
        int b = 2;
        if (a == b) {
            const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);
        }
        if (pal) {
            s->frame->palette_has_changed = 1;
            memcpy(s->pal, pal, AVPALETTE_SIZE);
        }
    }
    if ((ret = cinepak_decode(s)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""cinepak_decode failed\n"");
    }
    if (s->palette_video)
        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);
    if ((ret = av_frame_ref(data, s->frame)) < 0)
        return ret;
    *got_frame = 1;
    return buf_size;
}",0,1,94,1.28,Insert
1373,,,,,,,
1374,,,,,,,
1375,"static int update_dimensions(VP8Context *s, int width, int height)
{
    if (width  != s->avctx->width ||
        height != s->avctx->height) {
        if (av_image_check_size(width, height, 0, s->avctx))
            return AVERROR_INVALIDDATA;
        vp8_decode_flush_impl(s->avctx, 1, 0, 1);
        avcodec_set_dimensions(s->avctx, width, height);
    }
    s->mb_width  = (s->avctx->coded_width +15) / 16;
    s->mb_height = (s->avctx->coded_height+15) / 16;
    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));
    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));
    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);
    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));
    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));
    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||
        !s->top_nnz || !s->top_border)
        return AVERROR(ENOMEM);
    s->macroblocks        = s->macroblocks_base + 1;
    return 0;
}","static int update_dimensions(VP8Context *s, int width, int height)
{
    if (width  != s->avctx->width ||
        height != s->avctx->height) {
        target_phys_addr_t aux1_base;
        SysBusDevice *s_10;
        if (aux1_base) {
                sysbus_mmio_map(s_10, 5, aux1_base);
        }
        if (av_image_check_size(width, height, 0, s->avctx))
            return AVERROR_INVALIDDATA;
        vp8_decode_flush_impl(s->avctx, 1, 0, 1);
        avcodec_set_dimensions(s->avctx, width, height);
    }
    s->mb_width  = (s->avctx->coded_width +15) / 16;
    s->mb_height = (s->avctx->coded_height+15) / 16;
    int a = 2;
    int b = 3;
    while (a != b) {
        s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));
        b = a;
    }
    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));
    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);
    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));
    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));
    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||
        !s->top_nnz || !s->top_border)
        return AVERROR(ENOMEM);
    s->macroblocks        = s->macroblocks_base + 1;
    return 0;
}",1,0,26,1.24,Insert
1376,,,,,,,
1378,,,,,,,
1379,,,,,,,
1380,"static int net_slirp_init(VLANState *vlan)
{
    if (!slirp_inited) {
        slirp_inited = 1;
        slirp_init();
    }
    slirp_vc = qemu_new_vlan_client(vlan, 
                                    slirp_receive, NULL);
    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");
    return 0;
}","static int net_slirp_init(VLANState *vlan)
{
    if (!slirp_inited) {
        slirp_inited = 1;
        slirp_init();
    }
    slirp_vc = qemu_new_vlan_client(vlan, 
                                    slirp_receive, NULL);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");
    strcpy(str, ""a"");
    int yPos, xpid;
    Vop *ip;
    PIXEL *cu_comm, *cu_next;
    PIXEL *sc_comp, *cvsprev;
    int32 range;
    cu_comm = ip->uChan + (range >> 2) + (xpid >> 2);
    sc_comp = ip->vChan + (range >> 2) + (xpid >> 2);
    }
    return 0;
}",1,0,9,0.34,Insert
1383,"static void v9fs_link(void *opaque)
{
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t dfid, oldfid;
    V9fsFidState *dfidp, *oldfidp;
    V9fsString name;
    size_t offset = 7;
    int err = 0;
    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);
    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);
    dfidp = get_fid(pdu, dfid);
    if (dfidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    oldfidp = get_fid(pdu, oldfid);
    if (oldfidp == NULL) {
        err = -ENOENT;
        goto out;
    }
    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);
    if (!err) {
        err = offset;
    }
out:
    put_fid(pdu, dfidp);
out_nofid:
    v9fs_string_free(&name);
    complete_pdu(s, pdu, err);
}","static void v9fs_link(void *opaque)
{
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t dfid, oldfid;
    int a = 2;
    int b = 3;
    while (a != b) {
        V9fsFidState *dfidp, *oldfidp;
        b = a;
    }
    V9fsString name;
    size_t offset = 7;
    int err = 0;
    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);
    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);
    dfidp = get_fid(pdu, dfid);
    if (dfidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    oldfidp = get_fid(pdu, oldfid);
    if (oldfidp == NULL) {
        err = -ENOENT;
        goto out;
    }
    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (!err) {
        err = offset;
    }
out:
    put_fid(pdu, dfidp);
out_nofid:
    v9fs_string_free(&name);
    complete_pdu(s, pdu, err);
}",0,1,61,1.0,Insert
1384,"int dxva2_init(AVCodecContext *s)
{
    InputStream *ist = s->opaque;
    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;
    DXVA2Context *ctx;
    int ret;
    if (!ist->hwaccel_ctx) {
        ret = dxva2_alloc(s);
        if (ret < 0)
            return ret;
    }
    ctx = ist->hwaccel_ctx;
    if (s->codec_id == AV_CODEC_ID_H264 &&
        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {
        av_log(NULL, loglevel, ""Unsupported H.264 profile for DXVA2 HWAccel: %d\n"", s->profile);
        return AVERROR(EINVAL);
    }
    if (s->codec_id == AV_CODEC_ID_HEVC &&
        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {
        av_log(NULL, loglevel, ""Unsupported HEVC profile for DXVA2 HWAccel: %d\n"", s->profile);
        return AVERROR(EINVAL);
    }
    av_buffer_unref(&ctx->hw_frames_ctx);
    ret = dxva2_create_decoder(s);
    if (ret < 0) {
        av_log(NULL, loglevel, ""Error creating the DXVA2 decoder\n"");
        return ret;
    }
    return 0;
}","int dxva2_init(AVCodecContext *s)
{
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
    aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
    const char *fil;
    AVIOContext *pb;
    unsigned int base;
    unsigned char *result = NULL;
    int ret_6 = 0, probe_size;
    AVProbeData pd = { fil ? fil : """", NULL, -base };
    ret_6 = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
    TCGContext *service;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    InputStream *ist = s->opaque;
    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;
    DXVA2Context *ctx;
    int ret;
    if (!ist->hwaccel_ctx) {
        int a = 2;
        int b = 3;
        while (a < b) {
            ret = dxva2_alloc(s);
            b = a;
        }
        if (ret < 0)
            return ret;
    }
    ctx = ist->hwaccel_ctx;
    if (s->codec_id == AV_CODEC_ID_H264 &&
        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {
        av_log(NULL, loglevel, ""Unsupported H.264 profile for DXVA2 HWAccel: %d\n"", s->profile);
        return AVERROR(EINVAL);
    }
    if (s->codec_id == AV_CODEC_ID_HEVC &&
        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {
        av_log(NULL, loglevel, ""Unsupported HEVC profile for DXVA2 HWAccel: %d\n"", s->profile);
        return AVERROR(EINVAL);
    }
    av_buffer_unref(&ctx->hw_frames_ctx);
    ret = dxva2_create_decoder(s);
    if (ret < 0) {
        av_log(NULL, loglevel, ""Error creating the DXVA2 decoder\n"");
        return ret;
    }
    return 0;
}",0,1,121,1.37,Insert
1385,"static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,
                                         XenPTRegInfo *reg)
{
    PCIDevice *d = &s->dev;
    XenPTRegion *region = NULL;
    PCIIORegion *r;
    int index = 0;
    index = xen_pt_bar_offset_to_index(reg->offset);
    if ((0 < index) && (index < PCI_ROM_SLOT)) {
        int type = s->real_device.io_regions[index - 1].type;
        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)
            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {
            region = &s->bases[index - 1];
            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {
                return XEN_PT_BAR_FLAG_UPPER;
            }
        }
    }
    r = &d->io_regions[index];
    if (!xen_pt_get_bar_size(r)) {
        return XEN_PT_BAR_FLAG_UNUSED;
    }
    if (index == PCI_ROM_SLOT) {
        return XEN_PT_BAR_FLAG_MEM;
    }
    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {
        return XEN_PT_BAR_FLAG_IO;
    } else {
        return XEN_PT_BAR_FLAG_MEM;
    }
}","static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,
                                         XenPTRegInfo *reg)
{
    int nb_oargs;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         struct dir *dir;
                         struct proc_mounts *p = dir->private_data;
                         int lang_2, rar_6;
                         const char *request_1= ""DROP TABLE IF EXISTS test_table;""
                                              ""CREATE TABLE test_table(id INT);""
                                              ""INSERT INTO test_table VALUES(10);""
                                              ""UPDATE test_table SET id=20 WHERE id=10;""
                                              ""SELECT * FROM test_table;""
                                              ""INSERT INTO non_existent_table VALUES(11);"";
                         MYSQL *mysql___global_4;
                         lang_2= mysql_query_10(mysql___global_4, request_1);
                         lang_2= mysql_query_10(mysql___global_4, ""DROP TABLE IF EXISTS test_table"");
                         mysql_close_5(mysql___global_4);
                         if (mnt_had_events(p))
                         		res |= POLLERR | POLLPRI;
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
                         GF_BitStream *bs;
                         GF_Box *s_5;
                         GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_5;
                         GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_5;
                         GF_Err e;
                         e = gf_isom_full_box_write(s_5, bs);
                         gf_bs_write_u16(bs, cap->item_protection_index);
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    PCIDevice *d = &s->dev;
    XenPTRegion *region = NULL;
    PCIIORegion *r;
    int index = 0;
    index = xen_pt_bar_offset_to_index(reg->offset);
    if ((0 < index) && (index < PCI_ROM_SLOT)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            int type = s->real_device.io_regions[index - 1].type;
        strcpy(str, ""a"");
        }
        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)
            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {
            region = &s->bases[index - 1];
            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {
                return XEN_PT_BAR_FLAG_UPPER;
            }
        }
    }
    r = &d->io_regions[index];
    if (!xen_pt_get_bar_size(r)) {
        return XEN_PT_BAR_FLAG_UNUSED;
    }
    if (index == PCI_ROM_SLOT) {
        return XEN_PT_BAR_FLAG_MEM;
    }
    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {
        return XEN_PT_BAR_FLAG_IO;
    } else {
        return XEN_PT_BAR_FLAG_MEM;
    }
}",0,1,174,1.57,Insert
1386,,,,,,,
1387,,,,,,,
1388,,,,,,,
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,
                                 const char *base_filename,
                                 const char *base_fmt)
{
    if (base_filename) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {
            error_report(""Backing file not supported for file format '%s'"",
                         fmt);
            return -1;
        }
    }
    if (base_fmt) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {
            error_report(""Backing file format not supported for file ""
                         ""format '%s'"", fmt);
            return -1;
        }
    }
    return 0;
}","static int add_old_style_options(const char *fmt, QemuOpts *opts,
                                 const char *base_filename,
                                 const char *base_fmt)
{
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    if (base_filename) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {
            error_report(""Backing file not supported for file format '%s'"",
                         fmt);
            return -1;
        }
    }
    if (base_fmt) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {
            error_report(""Backing file format not supported for file ""
                         ""format '%s'"", fmt);
            return -1;
        }
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return 0;
    }
}",0,1,7,0.44,Insert
1399,,,,,,,
1400,,,,,,,
1401,,,,,,,
1402,,,,,,,
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)
{
    buf[0] = 0;
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);
    AV_WB16(&buf[4], s->w);
    AV_WB16(&buf[6], s->h);
    AV_WB16(&buf[8], num_strips);
    return CVID_HEADER_SIZE;
}","static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)
{
    buf[0] = 0;
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);
    int a = 2;
    int b = 2;
    if (a == b) {
        AV_WB16(&buf[4], s->w);
    }
    AV_WB16(&buf[6], s->h);
    SCSIRequest *req;
    SCSIDiskState *s_3 = DO_UPCAST(SCSIDiskState, qdev, db);
    req = scsi_req_alloc(&scsi_disk_reqops, &s_3->qdev, contract, lban, hba_private);
    AV_WB16(&buf[8], num_strips);
    return CVID_HEADER_SIZE;
}",1,0,15,0.49,Insert
1404,,,,,,,
1405,,,,,,,
1407,"static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)
{
    switch (shiftop) {
    case 0:  
        if (shift != 0) {
            if (flags)
                shifter_out_im(var, 32 - shift);
            tcg_gen_shli_i32(var, var, shift);
        }
        break;
    case 1:  
        if (shift == 0) {
            if (flags) {
                tcg_gen_shri_i32(var, var, 31);
                gen_set_CF(var);
            }
            tcg_gen_movi_i32(var, 0);
        } else {
            if (flags)
                shifter_out_im(var, shift - 1);
            tcg_gen_shri_i32(var, var, shift);
        }
        break;
    case 2:  
        if (shift == 0)
            shift = 32;
        if (flags)
            shifter_out_im(var, shift - 1);
        if (shift == 32)
          shift = 31;
        tcg_gen_sari_i32(var, var, shift);
        break;
    case 3:  
        if (shift != 0) {
            if (flags)
                shifter_out_im(var, shift - 1);
            tcg_gen_rotri_i32(var, var, shift); break;
        } else {
            TCGv tmp = load_cpu_field(CF);
            if (flags)
                shifter_out_im(var, 0);
            tcg_gen_shri_i32(var, var, 1);
            tcg_gen_shli_i32(tmp, tmp, 31);
            tcg_gen_or_i32(var, var, tmp);
            dead_tmp(tmp);
        }
    }
};","static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)
{
    switch (shiftop) {
    case 0:  
        if (shift != 0) {
            if (flags)
                shifter_out_im(var, 32 - shift);
            tcg_gen_shli_i32(var, var, shift);
        }
        break;
    case 1:  
        if (shift == 0) {
            if (flags) {
                tcg_gen_shri_i32(var, var, 31);
                gen_set_CF(var);
            }
            tcg_gen_movi_i32(var, 0);
        } else {
            if (flags)
                shifter_out_im(var, shift - 1);
            tcg_gen_shri_i32(var, var, shift);
        }
        break;
    case 2:  
        if (shift == 0)
            shift = 32;
        if (flags)
            shifter_out_im(var, shift - 1);
        if (shift == 32)
          shift = 31;
        tcg_gen_sari_i32(var, var, shift);
        break;
    case 3:  
        if (shift != 0) {
            if (flags)
                shifter_out_im(var, shift - 1);
            tcg_gen_rotri_i32(var, var, shift); break;
        } else {
            int a = 2;
            int b = 3;
            while (a != b) {
                TCGv tmp = load_cpu_field(CF);
                b = a;
            }
            uint8_t **ref_picture;
            int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
            int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
            int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
            int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
            uint8_t *ptr;
            ptr = ref_picture[0] + (src_y * linesize) + src_x;
            ptr = ref_picture[1] + offset;
            ptr = ref_picture[2] + offset;
            if (flags)
                shifter_out_im(var, 0);
            tcg_gen_shri_i32(var, var, 1);
            tcg_gen_shli_i32(tmp, tmp, 31);
            tcg_gen_or_i32(var, var, tmp);
            dead_tmp(tmp);
        }
    }
};",1,0,15,1.59,Insert
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    int i;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.rxFilterConf.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
    }
    VMW_CFPRN(""Configured VLANs:"");
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}","static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    int i;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.rxFilterConf.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        VGACommonState *s_4;
        int full_update;
        DisplaySurface *surface = qemu_console_surface(s_4->con);
        full_update |= update_basic_params(s_4);
        full_update |= update_palette16(s_4);
        VMW_CFPRN(""Configured VLANs:"");
        b = a;
        WMAVoiceContext *s_6;
        int block_idx;
        int pulse_off = s_6->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s_6->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s_6->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s_6->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s_6->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        pulse_start = s_6->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;
    }
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}",1,0,46,0.9,Insert
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    uint32_t limit;
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    ptimer_set_limit(s->timer, limit, reload);
}","static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        uint32_t limit;
    }
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    ptimer_set_limit(s->timer, limit, reload);
}",0,1,41,0.56,Insert
1412,"static void do_log(int argc, const char **argv)
{
    int mask;
    if (argc != 2)
        goto help;
    if (!strcmp(argv[1], ""none"")) {
        mask = 0;
    } else {
        mask = cpu_str_to_log_mask(argv[1]);
        if (!mask) {
        help:
            help_cmd(argv[0]);
            return;
        }
    }
    cpu_set_log(mask);
}","static void do_log(int argc, const char **argv)
{
    int mask;
    if (argc != 2)
        goto help;
    if (!strcmp(argv[1], ""none"")) {
        mask = 0;
    } else {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            mask = cpu_str_to_log_mask(argv[1]);
        }
        if (!mask) {
        help:
            help_cmd(argv[0]);
            return;
        }
    }
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    cpu_set_log(mask);
}",0,1,13,0.4,Insert
1415,,,,,,,
1416,"static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,
				    int enable)
{
	return kvm_set_migration_log(enable);
}","static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,
				    int enable)
{
	int a = 95;
	int b = a;
	if(a*b>0){
    	return kvm_set_migration_log(enable);
	}
}",0,1,2,0.03,Replace
1417,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,
                              int64_t timestamp, int flags)
{
    RTMP *r = s->priv_data;
    if (flags & AVSEEK_FLAG_BYTE)
        return AVERROR(ENOSYS);
    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);
    if (!RTMP_SendSeek(r, timestamp))
        return -1;
    return timestamp;
}","static int64_t rtmp_read_seek(URLContext *s, int stream_index,
                              int64_t timestamp, int flags)
{
    RTMP *r = s->priv_data;
    if (flags & AVSEEK_FLAG_BYTE)
        return AVERROR(ENOSYS);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);
    }
    if (!RTMP_SendSeek(r, timestamp))
        return -1;
    return timestamp;
}",0,1,1,0.05,Replace
1418,"static av_cold int mace_decode_init(AVCodecContext * avctx)
{
    MACEContext *ctx = avctx->priv_data;
    if (avctx->channels > 2)
        return -1;
    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
    avcodec_get_frame_defaults(&ctx->frame);
    avctx->coded_frame = &ctx->frame;
    return 0;
}","static av_cold int mace_decode_init(AVCodecContext * avctx)
{
    MACEContext *ctx = avctx->priv_data;
    if (avctx->channels > 2)
        return -1;
    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
    avcodec_get_frame_defaults(&ctx->frame);
    int a = 2;
    int b = 2;
    while (a == b) {
        avctx->coded_frame = &ctx->frame;
        b += 1;
        struct dir *dir;
        struct proc_mounts *p = dir->private_data;
        if (mnt_had_events(p))
        		res |= POLLERR | POLLPRI;
    }
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    return 0;
}",0,1,50,0.47,Insert
1421,"static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)
{
    CharDriverState *chr;
    FDCharDriver *s;
    chr = g_malloc0(sizeof(CharDriverState));
    s = g_malloc0(sizeof(FDCharDriver));
    s->fd_in = io_channel_from_fd(fd_in);
    s->fd_out = io_channel_from_fd(fd_out);
    fcntl(fd_out, F_SETFL, O_NONBLOCK);
    s->chr = chr;
    chr->opaque = s;
    chr->chr_add_watch = fd_chr_add_watch;
    chr->chr_write = fd_chr_write;
    chr->chr_update_read_handler = fd_chr_update_read_handler;
    chr->chr_close = fd_chr_close;
    qemu_chr_be_generic_open(chr);
    return chr;
}","static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
        TCGContext *service;
        int rules, nb_regs, ini;
        TCGRegSet allocated_regs;
        if (rules & TCG_CALL_NO_READ_GLOBALS) {
            } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
                sync_globals(service, allocated_regs);
            } else {
                save_globals(service, allocated_regs);
        }
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    CharDriverState *chr;
    FDCharDriver *s;
    chr = g_malloc0(sizeof(CharDriverState));
    s = g_malloc0(sizeof(FDCharDriver));
    s->fd_in = io_channel_from_fd(fd_in);
    s->fd_out = io_channel_from_fd(fd_out);
    fcntl(fd_out, F_SETFL, O_NONBLOCK);
    s->chr = chr;
    chr->opaque = s;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        chr->chr_add_watch = fd_chr_add_watch;
    }
    chr->chr_write = fd_chr_write;
    chr->chr_update_read_handler = fd_chr_update_read_handler;
    chr->chr_close = fd_chr_close;
    qemu_chr_be_generic_open(chr);
    return chr;
}",0,1,63,0.78,Insert
1422,"static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
                             const AVFrame *frame, int *got_packet_ptr)
{
    G722Context *c = avctx->priv_data;
    const int16_t *samples = (const int16_t *)frame->data[0];
    int nb_samples, out_size, ret;
    out_size = (frame->nb_samples + 1) / 2;
    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))
        return ret;
    nb_samples = frame->nb_samples - (frame->nb_samples & 1);
    if (avctx->trellis)
        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);
    else
        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);
    if (nb_samples < frame->nb_samples) {
        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };
        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);
    }
    if (frame->pts != AV_NOPTS_VALUE)
        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
    *got_packet_ptr = 1;
    return 0;
}","static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
                             const AVFrame *frame, int *got_packet_ptr)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        G722Context *c = avctx->priv_data;
    }
    const int16_t *samples = (const int16_t *)frame->data[0];
    int nb_samples, out_size, ret;
    out_size = (frame->nb_samples + 1) / 2;
    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))
        return ret;
    nb_samples = frame->nb_samples - (frame->nb_samples & 1);
    if (avctx->trellis)
        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);
    else
        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);
        const char
        struct client_session *c_3;
        int http_status;
        struct session_request *sr;
        struct mk_list *host_list = &config->hosts;
        struct mk_list *sr_list = &c_3->request_list;
        if (http_status > 0) {
                if (!sr->host_conf) {
                    sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
                }
                mk_request_error(http_status, c_3, sr);
                mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c_3->socket,
                                    NULL, c_3, sr);
        }
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (nb_samples < frame->nb_samples) {
        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };
        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);
    }
    if (frame->pts != AV_NOPTS_VALUE)
        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
    *got_packet_ptr = 1;
    return 0;
}",0,1,50,1.04,Insert
1424,"static int openfile(char *name, int flags)
{
	if (bs) {
		fprintf(stderr, ""file open already, try 'help close'\n"");
		return 1;
	}
	bs = bdrv_new(""hda"");
	if (!bs)
		return 1;
	if (bdrv_open(bs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);
		bs = NULL;
		return 1;
	}
	return 0;
}","static int openfile(char *name, int flags)
{
	if (bs) {
		fprintf(stderr, ""file open already, try 'help close'\n"");
		const uint16_t min_mesh[17];
		int16_t nrsc[16];
		int err;
		int path, i;
		for (i = 1; i < err; i++)
		        if (nrsc[i] < nrsc[i - 1] + min_mesh[i])
		            nrsc[i] = nrsc[i - 1] + min_mesh[i];
		return 1;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	bs = bdrv_new(""hda"");
	strcpy(str, ""a"");
	}
	if (!bs)
		return 1;
	if (bdrv_open(bs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);
		bs = NULL;
		return 1;
	}
	return 0;
}",0,1,21,0.44,Insert
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)
{
    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),
                                  ""/e500-ccsr""));
    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
    d->config[PCI_HEADER_TYPE] =
        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,
                             0, int128_get64(ccsr->ccsr_space.size));
    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);
}","static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)
{
    struct request_list *repl;
    bool lock;
    int port, is_output, ttl, remote_host;
    const struct sun4d_hwdef *hawdecl;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    unsigned int i;
    for (i = 0; i < MAX_IOBITS; i++)
            if (hawdecl->iounit_bases[i] != (target_phys_addr_t)-1)
                ioulits[i] = iommu_init(hawdecl->iounit_bases[i],
                                        hawdecl->iounit_version,
                                        sbi_arqu[hawdecl->me_irq]);
    char val[1024];
    int port, is_output, ttl, remote_host;
    int port, is_output, ttl, remote_host;
    char hostname[256];
    build_udp_url(val, sizeof(val),
                      hostname, port, remote_host, ttl);
    build_udp_url(val, sizeof(val),
                      hostname, port + 1, remote_host + 1, ttl);
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    char str_1[] = ""Constant"";
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    if (strlen(str_1) > 0) {
        PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
    }
    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),
                                  ""/e500-ccsr""));
    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
    d->config[PCI_HEADER_TYPE] =
        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,
                             0, int128_get64(ccsr->ccsr_space.size));
    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);
}",0,1,116,0.85,Insert
1426,,,,,,,
1428,,,,,,,
1430,"static av_cold int rl2_decode_init(AVCodecContext *avctx)
{
    Rl2Context *s = avctx->priv_data;
    int back_size;
    int i;
    s->avctx = avctx;
    avctx->pix_fmt = AV_PIX_FMT_PAL8;
    avcodec_get_frame_defaults(&s->frame);
    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){
        av_log(avctx, AV_LOG_ERROR, ""invalid extradata size\n"");
        return -1;
    }
    s->video_base = AV_RL16(&avctx->extradata[0]);
    s->clr_count = AV_RL32(&avctx->extradata[2]);
    if(s->video_base >= avctx->width * avctx->height){
        av_log(avctx, AV_LOG_ERROR, ""invalid video_base\n"");
        return -1;
    }
    for(i=0;i<AVPALETTE_COUNT;i++)
        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);
    back_size = avctx->extradata_size - EXTRADATA1_SIZE;
    if(back_size > 0){
        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);
        if(!back_frame)
            return -1;
        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,
                           back_frame,avctx->width,0);
        s->back_frame = back_frame;
    }
    return 0;
}","static av_cold int rl2_decode_init(AVCodecContext *avctx)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        Rl2Context *s = avctx->priv_data;
    }
    int back_size;
    int i;
    s->avctx = avctx;
    avctx->pix_fmt = AV_PIX_FMT_PAL8;
    avcodec_get_frame_defaults(&s->frame);
    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){
        av_log(avctx, AV_LOG_ERROR, ""invalid extradata size\n"");
        return -1;
    }
    s->video_base = AV_RL16(&avctx->extradata[0]);
    s->clr_count = AV_RL32(&avctx->extradata[2]);
    if(s->video_base >= avctx->width * avctx->height){
        av_log(avctx, AV_LOG_ERROR, ""invalid video_base\n"");
        return -1;
    }
    for(i=0;i<AVPALETTE_COUNT;i++)
        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);
    back_size = avctx->extradata_size - EXTRADATA1_SIZE;
    if(back_size > 0){
        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);
        if(!back_frame)
            return -1;
        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,
                           back_frame,avctx->width,0);
        s->back_frame = back_frame;
    }
    return 0;
}",1,0,32,0.27,Replace
1431,"static void picmemset(PicContext *s, AVFrame *frame, int value, int run,
                      int *x, int *y, int *plane, int bits_per_plane)
{
    uint8_t *d;
    int shift = *plane * bits_per_plane;
    int mask  = ((1 << bits_per_plane) - 1) << shift;
    value   <<= shift;
    while (run > 0) {
        int j;
        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
            d = frame->data[0] + *y * frame->linesize[0];
            d[*x] |= (value >> j) & mask;
            *x += 1;
            if (*x == s->width) {
                *y -= 1;
                *x = 0;
                if (*y < 0) {
                   *y = s->height - 1;
                   *plane += 1;
                   if (*plane >= s->nb_planes)
                       return;
                   value <<= bits_per_plane;
                   mask  <<= bits_per_plane;
                }
            }
        }
        run--;
    }
}","static void picmemset(PicContext *s, AVFrame *frame, int value, int run,
                      int *x, int *y, int *plane, int bits_per_plane)
{
    uint8_t *d;
    int shift = *plane * bits_per_plane;
    int mask  = ((1 << bits_per_plane) - 1) << shift;
    u32 ctrlmodule;
    struct gs_device_mode *dm;
    if (ctrlmodule & CAN_CTRLMODE_3_SAMPLES)
    		dm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;
    value   <<= shift;
    while (run > 0) {
        int j;
        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
            int a = 16;
            int b = a;
            if(a*b>0){
                d = frame->data[0] + *y * frame->linesize[0];
            }
            d[*x] |= (value >> j) & mask;
            *x += 1;
            if (*x == s->width) {
                *y -= 1;
                *x = 0;
                if (*y < 0) {
                   *y = s->height - 1;
                   *plane += 1;
                   if (*plane >= s->nb_planes)
                       return;
                   value <<= bits_per_plane;
                   mask  <<= bits_per_plane;
                }
            }
        }
        run--;
    }
}",1,0,39,0.96,Insert
1433,,,,,,,
1434,"vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)
{
    struct vhost_vring_addr *vra = &vmsg->payload.addr;
    unsigned int index = vra->index;
    VubrVirtq *vq = &dev->vq[index];
    DPRINT(""vhost_vring_addr:\n"");
    DPRINT(""    index:  %d\n"", vra->index);
    DPRINT(""    flags:  %d\n"", vra->flags);
    DPRINT(""    desc_user_addr:   0x%016llx\n"", vra->desc_user_addr);
    DPRINT(""    used_user_addr:   0x%016llx\n"", vra->used_user_addr);
    DPRINT(""    avail_user_addr:  0x%016llx\n"", vra->avail_user_addr);
    DPRINT(""    log_guest_addr:   0x%016llx\n"", vra->log_guest_addr);
    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);
    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);
    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);
    vq->log_guest_addr = vra->log_guest_addr;
    DPRINT(""Setting virtq addresses:\n"");
    DPRINT(""    vring_desc  at %p\n"", vq->desc);
    DPRINT(""    vring_used  at %p\n"", vq->used);
    DPRINT(""    vring_avail at %p\n"", vq->avail);
    vq->last_used_index = vq->used->idx;
    return 0;","vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)
{
    struct vhost_vring_addr *vra = &vmsg->payload.addr;
    unsigned int index = vra->index;
    VubrVirtq *vq = &dev->vq[index];
    DPRINT(""vhost_vring_addr:\n"");
    DPRINT(""    index:  %d\n"", vra->index);
    DPRINT(""    flags:  %d\n"", vra->flags);
    DPRINT(""    desc_user_addr:   0x%016llx\n"", vra->desc_user_addr);
    DPRINT(""    used_user_addr:   0x%016llx\n"", vra->used_user_addr);
    DPRINT(""    avail_user_addr:  0x%016llx\n"", vra->avail_user_addr);
    DPRINT(""    log_guest_addr:   0x%016llx\n"", vra->log_guest_addr);
    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);
    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);
    }
    vq->log_guest_addr = vra->log_guest_addr;
    DPRINT(""Setting virtq addresses:\n"");
    DPRINT(""    vring_desc  at %p\n"", vq->desc);
    DPRINT(""    vring_used  at %p\n"", vq->used);
    DPRINT(""    vring_avail at %p\n"", vq->avail);
    vq->last_used_index = vq->used->idx;
    return 0;",1,0,1,0.1,Replace
1436,"static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)
{
    PCIDevice *pd = PCI_DEVICE(br);
    PCIBus *parent = pd->bus;
    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);
    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);
    pci_bridge_init_alias(br, &w->alias_pref_mem,
                          PCI_BASE_ADDRESS_MEM_PREFETCH,
                          ""pci_bridge_pref_mem"",
                          &br->address_space_mem,
                          parent->address_space_mem,
                          cmd & PCI_COMMAND_MEMORY);
    pci_bridge_init_alias(br, &w->alias_mem,
                          PCI_BASE_ADDRESS_SPACE_MEMORY,
                          ""pci_bridge_mem"",
                          &br->address_space_mem,
                          parent->address_space_mem,
                          cmd & PCI_COMMAND_MEMORY);
    pci_bridge_init_alias(br, &w->alias_io,
                          PCI_BASE_ADDRESS_SPACE_IO,
                          ""pci_bridge_io"",
                          &br->address_space_io,
                          parent->address_space_io,
                          cmd & PCI_COMMAND_IO);
    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);
    return w;
}","static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)
{
    const uint16_t min_mesh[17];
    char *filename;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    long load_limit, rtas_limit, fw_size;
    if (fw_size < 0) {
            hw_error(""
            int wb_6;
            uint32_t lvcall_3;
            CPUState *env_8;
            unsigned int valpages_2;
            uint32_t r_cause_10;
            int tlb_pid_6, tlb_g_10, tlb_v_2, tlb_k_4, tlb_w_2, tlb_x_5;
            uint32_t tlb_vpn_8, tlb_pfn_8 = 0;
            uint32_t tlb_vpn_8, tlb_pfn_8 = 0;
            uint32_t pid_8, lo_2, hi_8;
            int set_5, match_2 = 0;
            r_cause_10 = env_8->sregs[SFR_R_MM_CAUSE_2];
            D_3(printf_2 (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
            		  "" %x cause=%x sel=%x sp=%x %x %x
            "",
            		  __func___1, wb_6, match_2, env_8->pc,
            		  lvcall_3, valpages_2,
            		  tlb_vpn_8, tlb_pfn_8, tlb_pid_6, 
            		  pid_8,
            		  r_cause_10,
            		  env_8->sregs[SFR_RW_MM_TLB_SEL_6],
            		  env_8->regs[R_SP_3], env_8->pregs[PR_USP_6], env_8->ksp));qemu: could not load LPAR rtas '%s'
    "", filename);
            exit(1);
    }
    int16_t nrsc[16];
    int err;
    int path, i;
    for (i = err-2; i >= 0; i--)
            if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
    PCIDevice *pd = PCI_DEVICE(br);
    PCIBus *parent = pd->bus;
    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);
    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);
    pci_bridge_init_alias(br, &w->alias_pref_mem,
                          PCI_BASE_ADDRESS_MEM_PREFETCH,
                          ""pci_bridge_pref_mem"",
                          &br->address_space_mem,
                          parent->address_space_mem,
                          cmd & PCI_COMMAND_MEMORY);
    pci_bridge_init_alias(br, &w->alias_mem,
                          PCI_BASE_ADDRESS_SPACE_MEMORY,
                          ""pci_bridge_mem"",
                          &br->address_space_mem,
                          parent->address_space_mem,
                          cmd & PCI_COMMAND_MEMORY);
    pci_bridge_init_alias(br, &w->alias_io,
                          PCI_BASE_ADDRESS_SPACE_IO,
                          ""pci_bridge_io"",
                          &br->address_space_io,
                          parent->address_space_io,
                          cmd & PCI_COMMAND_IO);
    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return w;
    strcpy(str, ""a"");
    }
}",0,1,107,1.25,Insert
1440,,,,,,,
1441,"static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int err;
    err = qemu_strtol(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int err;
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        err = qemu_strtol(str, &endptr, 0, &res);
        b_1 = a_1;
        aubio_onset_t * o = AUBIO_NEW(aubio_onset_t);
        o->pv = new_aubio_pvoc(byte64min, o->hop_code);
        o->od = new_aubio_specdesc(onsset_format,byte64min);
        o->fftgrain = new_cvec(byte64min);
        o->spectral_whitening = new_aubio_spectral_whitening(byte64min, hop_code, samplerate);
    }
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}",1,0,28,0.51,Insert
1442,,,,,,,
1443,,,,,,,
1445,"static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
    return var;
}","static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    int a = 2;
    int b = 3;
    while (a != b) {
        tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
        AVFormatContext *s;
        int fd;
        int64_t Timetime;
        int64_t offset    = dv_frame_offset(s, c, Timetime, fd);
        RawDVContext *r   = s->priv_data;
        DVDemuxContext *c = r->dv_demux;
        dv_offset_reset(c, offset / c->sys->frame_size);
        offset = avio_seek(s->pb, offset, SEEK_SET);
        b = a;
    }
    return var;
}",1,0,7,0.35,Insert
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
{
    const ARMCPRegInfo *ri = rip;
    ri->writefn(env, ri, value);
}","void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
{
    CPUCRISState *env_4;
    struct target_signal_frame *frame;
    abi_ulong frame_addr;
    frame_addr = env_4->regs[R_SP];
    unlock_user_struct(frame, frame_addr, 0);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        const ARMCPRegInfo *ri = rip;
    }
    ri->writefn(env, ri, value);
}",1,0,7,0.25,Insert
1447,,,,,,,
1448,"static void start_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val &= ~TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}","static void start_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val &= ~TCO_TMR_HLT;
    int a = 2;
    int b = 3;
    struct tg3 *tp;
    u32 vpdlen;
    unsigned int block_end, rosize, len;
    int j, i = 0;
    u8 *vpd_data;
    unsigned int block_end, rosize, len;
    vpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);
    i = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);
    rosize = pci_vpd_lrdt_size(&vpd_data[i]);
    j = pci_vpd_find_info_keyword(vpd_data, i, rosize,
    				      PCI_VPD_RO_KEYWORD_MFR_ID);
    len = pci_vpd_info_field_size(&vpd_data[i]);
    while (a != b) {
        qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
        GstDateTime *dt, *dt2;
        fail_unless (gst_date_time_get_hour (dt) == 15);
        fail_unless (gst_date_time_get_minute (dt) == 50);
        fail_unless (gst_date_time_get_second (dt) == 33);
        gst_date_time_unref (dt);
        dt = gst_date_time_new_from_iso8601_string (""2010-10-00"");
        b = a;
    }
}",1,0,41,0.56,Insert
1449,"void memory_global_dirty_log_stop(void)
{
    global_dirty_log = false;
    memory_region_transaction_begin();
    memory_region_update_pending = true;
    memory_region_transaction_commit();
    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);
}","void memory_global_dirty_log_stop(void)
{
    int a = 22;
    int b = a;
    if(a*b>0){
        global_dirty_log = false;
    }
    memory_region_transaction_begin();
    memory_region_update_pending = true;
    memory_region_transaction_commit();
    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);
}",0,1,5,0.06,Replace
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ENOSYS;
    return -1;
}","static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ENOSYS;
    int a = 35;
    int b = a;
    if(a*b>0){
        return -1;
    }
}",0,1,2,0.03,Replace
1455,,,,,,,
1456,"void qemu_coroutine_adjust_pool_size(int n)
{
    qemu_mutex_lock(&pool_lock);
    pool_max_size += n;
    assert(pool_max_size >= POOL_DEFAULT_SIZE);
    while (pool_size > pool_max_size) {
        Coroutine *co = QSLIST_FIRST(&pool);
        QSLIST_REMOVE_HEAD(&pool, pool_next);
        pool_size--;
        qemu_coroutine_delete(co);
    }
    qemu_mutex_unlock(&pool_lock);
}","void qemu_coroutine_adjust_pool_size(int n)
{
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    qemu_mutex_lock(&pool_lock);
    pool_max_size += n;
    assert(pool_max_size >= POOL_DEFAULT_SIZE);
    while (pool_size > pool_max_size) {
        Coroutine *co = QSLIST_FIRST(&pool);
        QSLIST_REMOVE_HEAD(&pool, pool_next);
        pool_size--;
        qemu_coroutine_delete(co);
    }
    qemu_mutex_unlock(&pool_lock);
}",0,1,41,0.41,Insert
1457,"static void rndis_clear_responsequeue(USBNetState *s)
{
    struct rndis_response *r;
    while ((r = s->rndis_resp.tqh_first)) {
        TAILQ_REMOVE(&s->rndis_resp, r, entries);
        qemu_free(r);
    }
}","static void rndis_clear_responsequeue(USBNetState *s)
{
    struct socket *sock;
    int protocol;
    struct object *object;
    struct sock *ock;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    struct sock *ock;
    ock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);
    struct rndis_response *r;
    const char
        *attribute,
        *content;
    XMLTreeInfo
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    while ((r = s->rndis_resp.tqh_first)) {
        TAILQ_REMOVE(&s->rndis_resp, r, entries);
        int a = 62;
        int b = a;
        if(a*b>0){
            qemu_free(r);
        }
    }
}",0,1,127,0.85,Insert
1458,"av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)
{
#if HAVE_YASM
    int mm_flags = av_get_cpu_flags();
    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {
#if ARCH_X86_32
        if (mm_flags & AV_CPU_FLAG_MMX) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;
        }
#endif
        if (mm_flags & AV_CPU_FLAG_SSE2) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;
        }
    }
#endif
}","av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)
{
const AVFrame *capt;
TCGContext *service;
int rules, nb_regs, ini;
TCGRegSet allocated_regs;
if (rules & TCG_CALL_NO_READ_GLOBALS) {
    } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
        sync_globals(service, allocated_regs);
    } else {
        save_globals(service, allocated_regs);
}
const AVFrame *const p = capt;
uint8_t *last = NULL;
uint8_t *zero = NULL;
zero = last = av_mallocz(p->linesize[0]);
av_freep(&zero);
UINT16* channel_id;
UINT16* length;
STREAM* s;
if (*length > 4)
		stream_read_UINT16(s, *channel_id);  
	else
		*channel_id = 0;
av_freep(&zero);
#if HAVE_YASM
    int mm_flags = av_get_cpu_flags();
    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {
#if ARCH_X86_32
        if (mm_flags & AV_CPU_FLAG_MMX) {
            int a = 2;
            int b = 3;
            while (a != b) {
                c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;
                b = a;
            }
        }
#endif
        if (mm_flags & AV_CPU_FLAG_SSE2) {
            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;
        }
    }
#endif
}",0,1,89,0.81,Insert
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int y;
    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;
        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int y;
    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
    const uint8_t *quant;
    int16_t *blks;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    s3 = (int) blks[3 * 8] * quant[3 * 8];
    t0  =  (s3 * 19266 + s5 * 12873) >> 15;
    t1  =  (s5 * 19266 - s3 * 12873) >> 15;
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        int a = 93;
        int b = a;
        if(a*b>0){
            DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;
        }
        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}",1,0,15,1.2,Insert
1461,"static int sd_truncate(BlockDriverState *bs, int64_t offset)
{
    BDRVSheepdogState *s = bs->opaque;
    int ret, fd;
    unsigned int datalen;
    if (offset < s->inode.vdi_size) {
        error_report(""shrinking is not supported"");
        return -EINVAL;
    } else if (offset > SD_MAX_VDI_SIZE) {
        error_report(""too big image size"");
        return -EINVAL;
    }
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        return fd;
    }
    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);
    s->inode.vdi_size = offset;
    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),
                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);
    close(fd);
    if (ret < 0) {
        error_report(""failed to update an inode."");
    }
    return ret;
}","static int sd_truncate(BlockDriverState *bs, int64_t offset)
{
    BDRVSheepdogState *s = bs->opaque;
    int a = 31;
    int b = a;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if(a*b>0){
        int ret, fd;
    }
    unsigned int datalen;
    if (offset < s->inode.vdi_size) {
        error_report(""shrinking is not supported"");
        return -EINVAL;
    } else if (offset > SD_MAX_VDI_SIZE) {
        error_report(""too big image size"");
        return -EINVAL;
    }
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        return fd;
    }
    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);
    s->inode.vdi_size = offset;
    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),
                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);
    close(fd);
    if (ret < 0) {
        error_report(""failed to update an inode."");
    }
    return ret;
}",0,1,44,0.96,Insert
1462,"static int rndis_parse(USBNetState *s, uint8_t *data, int length)
{
    uint32_t msg_type;
    le32 *tmp = (le32 *) data;
    msg_type = le32_to_cpup(tmp);
    switch (msg_type) {
    case RNDIS_INITIALIZE_MSG:
        s->rndis_state = RNDIS_INITIALIZED;
        return rndis_init_response(s, (rndis_init_msg_type *) data);
    case RNDIS_HALT_MSG:
        s->rndis_state = RNDIS_UNINITIALIZED;
        return 0;
    case RNDIS_QUERY_MSG:
        return rndis_query_response(s, (rndis_query_msg_type *) data, length);
    case RNDIS_SET_MSG:
        return rndis_set_response(s, (rndis_set_msg_type *) data, length);
    case RNDIS_RESET_MSG:
        rndis_clear_responsequeue(s);
        s->out_ptr = s->in_ptr = s->in_len = 0;
        return rndis_reset_response(s, (rndis_reset_msg_type *) data);
    case RNDIS_KEEPALIVE_MSG:
        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);
    }
    return USB_RET_STALL;
}","static int rndis_parse(USBNetState *s, uint8_t *data, int length)
{
    u16 request;
    bool from_ap;
    struct sk_buff *img;
    int data_1, r;
    data_1 = -1;
    if (from_ap && request)
    		NLA_PUT_U16(img, NL80211_ATTR_REASON_CODE, request);
    uint32_t msg_type;
    le32 *tmp = (le32 *) data;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        msg_type = le32_to_cpup(tmp);
    }
    switch (msg_type) {
    case RNDIS_INITIALIZE_MSG:
        s->rndis_state = RNDIS_INITIALIZED;
        return rndis_init_response(s, (rndis_init_msg_type *) data);
    case RNDIS_HALT_MSG:
        s->rndis_state = RNDIS_UNINITIALIZED;
        return 0;
    case RNDIS_QUERY_MSG:
        return rndis_query_response(s, (rndis_query_msg_type *) data, length);
    case RNDIS_SET_MSG:
        return rndis_set_response(s, (rndis_set_msg_type *) data, length);
    case RNDIS_RESET_MSG:
        rndis_clear_responsequeue(s);
        s->out_ptr = s->in_ptr = s->in_len = 0;
        return rndis_reset_response(s, (rndis_reset_msg_type *) data);
    case RNDIS_KEEPALIVE_MSG:
        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);
    }
    return USB_RET_STALL;
}",0,1,61,0.86,Insert
1465,"static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
{
    VirtIOBlock *s = VIRTIO_BLK(vdev);
    VirtIOBlockReq *req;
    MultiReqBuffer mrb = {};
    if (s->dataplane) {
        virtio_blk_data_plane_start(s->dataplane);
        return;
    }
    blk_io_plug(s->blk);
    while ((req = virtio_blk_get_request(s))) {
        virtio_blk_handle_request(req, &mrb);
    }
    if (mrb.num_reqs) {
        virtio_blk_submit_multireq(s->blk, &mrb);
    }
    blk_io_unplug(s->blk);
}","static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
{
    VirtioCcwDevice *dev;
    DisasContext *ctx;
    int32_t r1, r2;
    r1 = MASK_OP_BO_S1D(ctx->opcode);
    Error *err = NULL;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    int a = 37;
    int b = a;
    if(a*b>0){
        VirtIOBlock *s = VIRTIO_BLK(vdev);
    }
    VirtIOBlockReq *req;
    MultiReqBuffer mrb = {};
    if (s->dataplane) {
        virtio_blk_data_plane_start(s->dataplane);
        return;
    }
    blk_io_plug(s->blk);
    while ((req = virtio_blk_get_request(s))) {
        virtio_blk_handle_request(req, &mrb);
    }
    if (mrb.num_reqs) {
        virtio_blk_submit_multireq(s->blk, &mrb);
    }
    blk_io_unplug(s->blk);
}",0,1,88,0.83,Insert
1467,,,,,,,
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    r_asi = gen_get_asi(dc, insn);
    r_size = tcg_const_i32(size);
    r_sign = tcg_const_i32(sign);
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}","static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    if (strcmp(str1, str2) == 0) {
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        r_asi = gen_get_asi(dc, insn);
    }
    r_size = tcg_const_i32(size);
    r_sign = tcg_const_i32(sign);
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}",0,1,85,1.0,Insert
1469,"static inline float64 ucf64_itod(uint64_t i)
{
    union {
        uint64_t i;
        float64 d;
    } v;
    v.i = i;
    return v.d;
}","static inline float64 ucf64_itod(uint64_t i)
{
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    union {
        uint64_t i;
        float64 d;
    } v;
    v.i = i;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return v.d;
    strcpy(str, ""a"");
    }
}",0,1,23,0.32,Insert
1472,"static void qmp_input_pop(Visitor *v, void **obj)
{
    QmpInputVisitor *qiv = to_qiv(v);
    StackObject *tos = QSLIST_FIRST(&qiv->stack);
    assert(tos && tos->qapi == obj);
    QSLIST_REMOVE_HEAD(&qiv->stack, node);
    qmp_input_stack_object_free(tos);
}","static void qmp_input_pop(Visitor *v, void **obj)
{
    QmpInputVisitor *qiv = to_qiv(v);
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    StackObject *tos = QSLIST_FIRST(&qiv->stack);
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    AVStream *tmp;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    AVFormatContext *aws;
    uint32_t v_2, spf;
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
    if (strcmp(str1, str2) == 0) {
        assert(tos && tos->qapi == obj);
    }
    QSLIST_REMOVE_HEAD(&qiv->stack, node);
    qmp_input_stack_object_free(tos);
}",0,1,104,0.91,Insert
1475,"av_cold void ff_h264_free_context(H264Context *h)
{
    int i;
    ff_h264_free_tables(h);
    if (h->DPB) {
        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
            ff_h264_unref_picture(h, &h->DPB[i]);
        av_freep(&h->DPB);
    }
    h->cur_pic_ptr = NULL;
    for (i = 0; i < h->nb_slice_ctx; i++)
        av_freep(&h->slice_ctx[i].rbsp_buffer);
    av_freep(&h->slice_ctx);
    h->nb_slice_ctx = 0;
    for (i = 0; i < MAX_SPS_COUNT; i++)
        av_freep(h->sps_buffers + i);
    for (i = 0; i < MAX_PPS_COUNT; i++)
        av_freep(h->pps_buffers + i);
}","av_cold void ff_h264_free_context(H264Context *h)
{
    int i;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ff_h264_free_tables(h);
    strcpy(str, ""a"");
    }
    int *got_frame;
    void *data;
    AVPacket *avpkt;
    AVCodecContext *avctx;
    const uint8_t *buf = avpkt->data;
    int buf_index      = 0;
    AVFrame *pict      = data;
    int buf_size       = avpkt->size;
    H264Context *hy     = avctx->priv_data;
    buf_index = decode_nal_units(hy, buf, buf_size);
    assert(pict->buf[0] || !*got_frame);
    if (h->DPB) {
        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
            ff_h264_unref_picture(h, &h->DPB[i]);
        av_freep(&h->DPB);
    }
    h->cur_pic_ptr = NULL;
    for (i = 0; i < h->nb_slice_ctx; i++)
        av_freep(&h->slice_ctx[i].rbsp_buffer);
    av_freep(&h->slice_ctx);
    h->nb_slice_ctx = 0;
    for (i = 0; i < MAX_SPS_COUNT; i++)
        av_freep(h->sps_buffers + i);
    for (i = 0; i < MAX_PPS_COUNT; i++)
        av_freep(h->pps_buffers + i);
}",0,1,34,1.1,Insert
1477,,,,,,,
1479,"static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    qemu_io_free(ctx->buf);
    g_free(ctx);
}","static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    int a = 2;
    int b = 3;
    while (a != b) {
        struct timeval t2;
        b = a;
    }
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    qemu_io_free(ctx->buf);
    g_free(ctx);
}",1,0,12,0.22,Replace
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int i, hs, ms, ss, he, me, se;
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        buf += strcspn(buf, ""\n"") + 1;
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int i, hs, ms, ss, he, me, se;
        b += 1;
    }
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        buf += strcspn(buf, ""\n"") + 1;
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            u_short type, class, tlon;
            long n, i_2;
            u_short type, class, tlon;
            char name[MAXHOSTNAMELEN];
            u_long ttl;
            n = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);
            cp += n;
            GETSHORT(type, cp);
            GETSHORT(class, cp);
            GETLONG(ttl, cp);
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}",1,0,16,1.26,Insert
1482,,,,,,,
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    CompareState *s = container_of(sec_rs, CompareState, sec_rs);
    if (packet_enqueue(s, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
    }
}","static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    int a = 2;
    int b = 2;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    while (a == b) {
        CompareState *s = container_of(sec_rs, CompareState, sec_rs);
        b += 1;
    }
    if (packet_enqueue(s, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
    }
}",0,1,45,0.54,Insert
1484,,,,,,,
1486,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();","void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    target_phys_addr_t attr;
    SysBusDevice *sh;
    RamDevice *fd;
    DeviceState *dev;
    sh = sysbus_from_qdev(dev);
    fd = FROM_SYSBUS(RamDevice, sh);
    sysbus_mmio_map(sh, 0, attr);
    int a = 2;
    int b = 2;
    if (a == b) {
        const ARMCPRegInfo *ri = rip;
    }
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();",1,0,10,0.48,Insert
1487,,,,,,,
1488,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)
{
    int x, y;
    double f0, f1, f2;
    if (in[n] == 0)
        return 0;
    if ((f0 = *in) <= 0)
        return 0;
    in--;  
    for (x=1; x <= n; x++) {
        f1 = in[x+1];
        for (y=0; y < x - 1; y++)
            f1 += in[x-y]*tgt[y];
        tgt[x-1] = f2 = -f1/f0;
        for (y=0; y < x >> 1; y++) {
            float temp = tgt[y] + tgt[x-y-2]*f2;
            tgt[x-y-2] += tgt[y]*f2;
            tgt[y] = temp;
        }
        if ((f0 += f1*f2) < 0)
            return 0;
    }
    return 1;
}","static int eval_lpc_coeffs(const float *in, float *tgt, int n)
{
    int x, y;
    double f0, f1, f2;
    if (in[n] == 0)
        return 0;
    if ((f0 = *in) <= 0)
        return 0;
    in--;  
    for (x=1; x <= n; x++) {
        f1 = in[x+1];
        for (y=0; y < x - 1; y++)
            f1 += in[x-y]*tgt[y];
        tgt[x-1] = f2 = -f1/f0;
        PutBitContext pb, pb2;
        int comps;
        put_bits(&pb, 16, 8 + comps * 3);
        put_bits(&pb, 8, comps);
        put_bits(&pb, 16, 6 + comps * 2);
        put_bits(&pb, 8, comps);
        put_bits(&pb, 8, (comps > 1) ? 1 : 0);
        for (y=0; y < x >> 1; y++) {
            float temp = tgt[y] + tgt[x-y-2]*f2;
            tgt[x-y-2] += tgt[y]*f2;
            tgt[y] = temp;
        }
        if ((f0 += f1*f2) < 0)
            return 0;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 1;
    strcpy(str, ""a"");
    }
}",0,1,19,1.2,Insert
1490,"void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);","void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    int a = 2;
    int b = 3;
    FWCfgState *s;
    int i, index, count;
    int i, index, count;
    int i, index, count;
    for (i = count + 1; i > index; i--) {
            s->files->f[i] = s->files->f[i - 1];
            s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);
            s->entries[0][FW_CFG_FILE_FIRST + i] =
                s->entries[0][FW_CFG_FILE_FIRST + i - 1];
            s->entry_order[i] = s->entry_order[i - 1];
    }
    while (a != b) {
        DeviceState *icc_bridge;
        b = a;
    }
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",1,0,5,0.65,Insert
1491,,,,,,,
1492,,,,,,,
1494,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,
                             int width, int height)
{
    int src_wrap, x, y;
    int r, g, b;
    uint8_t *lum, *cb, *cr;
    const uint8_t *p;
    lum = dst->data[0];
    cb = dst->data[1];
    cr = dst->data[2];
    src_wrap = src->linesize[0] - width * BPP;
    p = src->data[0];
    for(y=0;y<height;y++) {
        for(x=0;x<width;x++) {
            RGB_IN(r, g, b, p);
            lum[0] = RGB_TO_Y_CCIR(r, g, b);
            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);
            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);
            cb++;
            cr++;
            lum++;
        }
        p += src_wrap;
        lum += dst->linesize[0] - width;
        cb += dst->linesize[1] - width;
        cr += dst->linesize[2] - width;
    }
}","static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,
                             int width, int height)
{
    int src_wrap, x, y;
    int r, g, b;
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        uint8_t *lum, *cb, *cr;
    strcpy(str_1, ""a"");
    }
    const uint8_t *p;
    lum = dst->data[0];
    cb = dst->data[1];
    cr = dst->data[2];
    src_wrap = src->linesize[0] - width * BPP;
    p = src->data[0];
    for(y=0;y<height;y++) {
        for(x=0;x<width;x++) {
            RGB_IN(r, g, b, p);
            lum[0] = RGB_TO_Y_CCIR(r, g, b);
            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);
            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);
            cb++;
            cr++;
            lum++;
        }
        p += src_wrap;
        lum += dst->linesize[0] - width;
        cb += dst->linesize[1] - width;
        cr += dst->linesize[2] - width;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
    }
}",0,1,66,1.65,Insert
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)
{
    PCIDevice *d = (PCIDevice *)dev;
    char path[50], name[33];
    int off;
    off = snprintf(path, sizeof(path), ""%s@%x"",
                   pci_dev_fw_name(dev, name, sizeof name),
                   PCI_SLOT(d->devfn));
    if (PCI_FUNC(d->devfn))
        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));
    return strdup(path);
}","static char *pcibus_get_fw_dev_path(DeviceState *dev)
{
    PCIDevice *d = (PCIDevice *)dev;
    char path[50], name[33];
    char str[] = ""Constant"";
    struct edgeport_serial *serial;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev_1 = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    u8 *data;
    int status;
    struct device *dev_4 = &serial->serial->dev_4->dev_4;
    if (status)
    		dev_dbg(dev_4, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev_4, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    while (strlen(str) > 5) {
        int off;
    strcpy(str, ""a"");
    }
    off = snprintf(path, sizeof(path), ""%s@%x"",
                   pci_dev_fw_name(dev, name, sizeof name),
                   PCI_SLOT(d->devfn));
    if (PCI_FUNC(d->devfn))
        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));
    return strdup(path);
}",0,1,48,0.88,Insert
1496,,,,,,,
1497,,,,,,,
1500,"static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    const char *command = ""PWD\r\n"";
    const int pwd_codes[] = {257, 0};
    if (!ftp_send_command(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                continue;
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}","static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    const char *command = ""PWD\r\n"";
    const int pwd_codes[] = {257, 0};
    if (!ftp_send_command(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                int a = 2;
                int b = 3;
                while (a < b) {
                    continue;
                    b = a;
                }
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        AVStream *tmp;
        AVFormatContext *aws;
        uint32_t v, spf;
        MPADecodeHeader ch;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                            tmp->time_base);
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}",0,1,52,1.18,Insert
1501,"int qemu_opts_print(QemuOpts *opts, void *dummy)
{
    QemuOpt *opt;
    fprintf(stderr, ""%s: %s:"", opts->list->name,
            opts->id ? opts->id : ""<noid>"");
    TAILQ_FOREACH(opt, &opts->head, next) {
        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);
    }
    fprintf(stderr, ""\n"");
    return 0;
}","int qemu_opts_print(QemuOpts *opts, void *dummy)
{
    const char
        *attribute,
        *content;
        int lang, rar;
        struct btd_adapter *acorer;
        const char *owners;
        GSList *match = g_slist_find_custom(acorer->discovery_list, owners,
        								compare_sender);
        GSList *match = g_slist_find_custom(acorer->discovery_list, owners,
        								compare_sender);
        								int lang_7, rar_7;
        								const char *request_5= ""DROP TABLE IF EXISTS test_table;""
        								                     ""CREATE TABLE test_table(id INT);""
        								                     ""INSERT INTO test_table VALUES(10);""
        								                     ""UPDATE test_table SET id=20 WHERE id=10;""
        								                     ""SELECT * FROM test_table;""
        								                     ""INSERT INTO non_existent_table VALUES(11);"";
        								MYSQL *mysql___global_10;
        								lang_7= mysql_query_5(mysql___global_10, request_5);
        								lang_7= mysql_query_5(mysql___global_10, ""DROP TABLE IF EXISTS test_table"");
        								mysql_close_8(mysql___global_10);
        GSList *match = g_slist_find_custom(acorer->discovery_list, owners,
        								compare_sender);
        match = g_slist_find_custom(acorer->set_filter_list, owners,
        								compare_sender);
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        mysql_close(mysql___global);
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    QemuOpt *opt;
    fprintf(stderr, ""%s: %s:"", opts->list->name,
            opts->id ? opts->id : ""<noid>"");
    TAILQ_FOREACH(opt, &opts->head, next) {
        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);
    }
    fprintf(stderr, ""\n"");
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",0,1,104,1.01,Insert
1503,"void qemu_run_all_timers(void)
{
    alarm_timer->pending = 0;
    if (alarm_timer->expired) {
        alarm_timer->expired = 0;
        qemu_rearm_alarm_timer(alarm_timer);
    }
    qemu_run_timers(vm_clock);
    qemu_run_timers(rt_clock);
    qemu_run_timers(host_clock);
}","void qemu_run_all_timers(void)
{
    alarm_timer->pending = 0;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (alarm_timer->expired) {
        alarm_timer->expired = 0;
        qemu_rearm_alarm_timer(alarm_timer);
    }
    qemu_run_timers(vm_clock);
    qemu_run_timers(rt_clock);
    int a = 100;
    int b = a;
    if(a*b>0){
        qemu_run_timers(host_clock);
    }
}",0,1,18,0.37,Insert
1508,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)
{
    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);
}","static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)
{
    int a = 87;
    int b = a;
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    if(a*b>0){
        return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);
    }
}",0,1,5,0.34,Insert
1509,"void ide_atapi_cmd(IDEState *s)
{
    uint8_t *buf;
    buf = s->io_buffer;
#ifdef DEBUG_IDE_ATAPI
    {
        int i;
        printf(""ATAPI limit=0x%x packet:"", s->lcyl | (s->hcyl << 8));
        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {
            printf("" %02x"", buf[i]);
        }
        printf(""\n"");
    }
#endif
    if (s->sense_key == UNIT_ATTENTION &&
        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {
        ide_atapi_cmd_check_status(s);
        return;
    }
    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&
        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {
        if (s->cdrom_changed == 1) {
            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);
            s->cdrom_changed = 2;
        } else {
            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);
            s->cdrom_changed = 0;
        }
        return;
    }
    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&
        (!media_present(s) || !bdrv_is_inserted(s->bs)))
    {
        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);
        return;
    }
    if (atapi_cmd_table[s->io_buffer[0]].handler) {
        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);
        return;
    }
    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);
}","void ide_atapi_cmd(IDEState *s)
{
    uint8_t *buf;
    buf = s->io_buffer;
#ifdef DEBUG_IDE_ATAPI
    {
        int i;
        printf(""ATAPI limit=0x%x packet:"", s->lcyl | (s->hcyl << 8));
        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {
            printf("" %02x"", buf[i]);
        }
        printf(""\n"");
    }
#endif
    if (s->sense_key == UNIT_ATTENTION &&
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    SDRequest *err;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    SDState *esi;
    uint32_t last_status = esi->card_status;
    esi->card_status &= ~CARD_STATUS_B;
    sd_set_status(esi);
    esi->current_cmd = err->cmd;
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {
        ide_atapi_cmd_check_status(s);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&
        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {
        if (s->cdrom_changed == 1) {
            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);
            s->cdrom_changed = 2;
        } else {
            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);
            s->cdrom_changed = 0;
        }
        return;
    }
    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&
        (!media_present(s) || !bdrv_is_inserted(s->bs)))
    {
        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);
        return;
    }
    if (atapi_cmd_table[s->io_buffer[0]].handler) {
        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);
        return;
    }
    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);
}",0,1,87,1.64,Insert
1510,,,,,,,
1511,,,,,,,
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & HPTE64_R_R)) {
        *pte1p |= HPTE64_R_R;
        store = 1;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & HPTE64_R_R)) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            *pte1p |= HPTE64_R_R;
            const struct sun4d_hwdef *hawdecl;
            int ret_6;
            ram_addr_t gram_size, prom_reset, tcx64off;
            void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            qemu_irq *esp__set, *les_init;
            void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
            qemu_irq *esp__set, *les_init;
            char data[1024];
            cpu_register_physical_memory(hawdecl->slavio_base,
                                             (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                             TARGET_PAGE_MASK,
                                             prom_reset | IO_MEM_ROM);
            ret_6 = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
            sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
            espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                          ioulits[0], &espdma_iraque, &esp__set);
            ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                                         ioulits[0], &ledma_arquest, &les_init);
        }
        store = 1;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}",0,1,25,0.47,Insert
1516,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)
{
    int64_t ret;
    BDRVArchipelagoState *s = bs->opaque;
    ret = archipelago_volume_info(s);
    return ret;
}","static int64_t qemu_archipelago_getlength(BlockDriverState *bs)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        int64_t ret;
        b += 1;
    }
    BDRVArchipelagoState *s = bs->opaque;
    ret = archipelago_volume_info(s);
    return ret;
}",0,1,5,0.06,Replace
1517,"static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,
                                    sPAPRMachineState *spapr,
                                    uint32_t token, uint32_t nargs,
                                    target_ulong args, uint32_t nret,
                                    target_ulong rets)
{
    sPAPRPHBState *sphb;
    sPAPRPHBClass *spc;
    PCIDevice *pdev;
    uint32_t addr, option;
    uint64_t buid;
    int ret;
    if ((nargs != 4) || (nret != 1)) {
        goto param_error_exit;
    }
    buid = rtas_ldq(args, 1);
    addr = rtas_ld(args, 0);
    option = rtas_ld(args, 3);
    sphb = spapr_pci_find_phb(spapr, buid);
    if (!sphb) {
        goto param_error_exit;
    }
    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,
                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);
    if (!pdev || !object_dynamic_cast(OBJECT(pdev), ""vfio-pci"")) {
        goto param_error_exit;
    }
    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);
    if (!spc->eeh_set_option) {
        goto param_error_exit;
    }
    ret = spc->eeh_set_option(sphb, addr, option);
    rtas_st(rets, 0, ret);
    return;
param_error_exit:
    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);
}","static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,
                                    sPAPRMachineState *spapr,
                                    uint32_t token, uint32_t nargs,
                                    target_ulong args, uint32_t nret,
                                    target_ulong rets)
{
    sPAPRPHBState *sphb;
    sPAPRPHBClass *spc;
    PCIDevice *pdev;
    uint32_t addr, option;
    uint64_t buid;
    int ret;
    if ((nargs != 4) || (nret != 1)) {
        goto param_error_exit;
    }
    buid = rtas_ldq(args, 1);
    addr = rtas_ld(args, 0);
    option = rtas_ld(args, 3);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    if (strcmp(str1, str2) == 0) {
        struct QemuInputEventQueueHead *queue;
        QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
        QTAILQ_INSERT_TAIL(queue, item, node);
        queue_count++;
        sphb = spapr_pci_find_phb(spapr, buid);
        int wb_6;
        uint32_t lvcall_4;
        CPUState *env_5;
        unsigned int valpages_1;
        uint32_t r_cause_3;
        int tlb_pid_6, tlb_g_2, tlb_v_5, tlb_k_7, tlb_w_4, tlb_x_4;
        uint32_t tlb_vpn_1, tlb_pfn_5 = 0;
        uint32_t tlb_vpn_1, tlb_pfn_5 = 0;
        uint32_t pid_7, lo_9, hi_6;
        int set_3, match_5 = 0;
        r_cause_3 = env_5->sregs[SFR_R_MM_CAUSE_8];
        D_7(printf_1 (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func___7, wb_6, match_5, env_5->pc,
        		  lvcall_4, valpages_1,
        		  tlb_vpn_1, tlb_pfn_5, tlb_pid_6, 
        		  pid_7,
        		  r_cause_3,
        		  env_5->sregs[SFR_RW_MM_TLB_SEL_8],
        		  env_5->regs[R_SP_7], env_5->pregs[PR_USP_10], env_5->ksp));
    }
    size_t ie_len;
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    if (!sphb) {
        goto param_error_exit;
    }
    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,
                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);
                           int wb;
                           uint32_t lvcall;
                           CPUState *env;
                           unsigned int valpages;
                           uint32_t r_cause;
                           int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
                           uint32_t tlb_vpn, tlb_pfn = 0;
                           uint32_t tlb_vpn, tlb_pfn = 0;
                           uint32_t pid, lo, hi;
                           int set, match = 0;
                           r_cause = env->sregs[SFR_R_MM_CAUSE];
                           D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
                           		  "" %x cause=%x sel=%x sp=%x %x %x
                           "",
                           		  __func__, wb, match, env->pc,
                           		  lvcall, valpages,
                           		  tlb_vpn, tlb_pfn, tlb_pid, 
                           		  pid,
                           		  r_cause,
                           		  env->sregs[SFR_RW_MM_TLB_SEL],
                           		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    if (!pdev || !object_dynamic_cast(OBJECT(pdev), ""vfio-pci"")) {
        goto param_error_exit;
    }
    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);
    if (!spc->eeh_set_option) {
        goto param_error_exit;
    }
    ret = spc->eeh_set_option(sphb, addr, option);
    rtas_st(rets, 0, ret);
    return;
param_error_exit:
    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);
}",0,1,155,1.44,Insert
1518,"int qemu_acl_remove(qemu_acl *acl,
                    const char *match)
{
    qemu_acl_entry *entry;
    int i = 0;
    TAILQ_FOREACH(entry, &acl->entries, next) {
        i++;
        if (strcmp(entry->match, match) == 0) {
            TAILQ_REMOVE(&acl->entries, entry, next);
            return i;
        }
    }
    return -1;
}","int qemu_acl_remove(qemu_acl *acl,
                    const char *match)
{
    qemu_acl_entry *entry;
    int i = 0;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_1;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_1;
    Rocker *r_4;
    DescInfo *info_9;
    char *buf_3 = desc_get_buf_3(info_9, true);
    RockerTlv *tlvs_7[ROCKER_TLV_TX_MAX_7 + 1];
    char *buf_3 = desc_get_buf_3(info_9, true);
    PCIDevice *dev_9 = PCI_DEVICE_3(r_4);
    RockerTlv *tlvs_7[ROCKER_TLV_TX_MAX_7 + 1];
    uint32_t pport_3;
    rocker_tlv_parse_7(tlvs_7, ROCKER_TLV_TX_MAX_7, buf_3, desc_tlv_size_9(info_9));
    pport_3 = rocker_get_pport_by_tx_ring_1(r_4, desc_get_ring_4(info_9));
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
    aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
    TAILQ_FOREACH(entry, &acl->entries, next) {
        i++;
        if (strcmp(entry->match, match) == 0) {
            int a = 2;
            int b = 3;
            Rocker *r;
            DescInfo *info;
            char *buf = desc_get_buf(info, true);
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            char *buf = desc_get_buf(info, true);
            const char
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
            table->slot=(char *) NULL;
            table->description=(char *) NULL;
            table->levels=(unsigned int *) NULL;
            attribute=GetXMLTreeAttribute(table_iterator,""slot"");
            PCIDevice *dev = PCI_DEVICE(r);
            RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
            uint32_t pport;
            rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
            pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
            while (a < b) {
                TAILQ_REMOVE(&acl->entries, entry, next);
                b = a;
            }
            return i;
        }
    }
    return -1;
}",0,1,143,1.18,Insert
1520,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size)
{
    CookParseContext *s = s1->priv_data;
    if (s->duration)
        s1->duration = s->duration;
    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)
        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;
    *poutbuf      = buf;
    *poutbuf_size = buf_size;
    return buf_size;
}","static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size)
{
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    AVPacket * pk;
    AVFormatContext *s_8;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b     = s_8->b;
    avio_write(b,  pk->data, size);
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    char str[] = ""Constant"";
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    while (strlen(str) > 5) {
        CookParseContext *s = s1->priv_data;
    strcpy(str, ""a"");
    }
    if (s->duration)
        s1->duration = s->duration;
    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)
        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;
    *poutbuf      = buf;
    *poutbuf_size = buf_size;
    return buf_size;
}",0,1,87,0.91,Insert
1522,,,,,,,
1523,"void compute_images_mse_16bit(PSNRContext *s,
                        const uint8_t *main_data[4], const int main_linesizes[4],
                        const uint8_t *ref_data[4], const int ref_linesizes[4],
                        int w, int h, double mse[4])
{
    int i, c, j;
    for (c = 0; c < s->nb_components; c++) {
        const int outw = s->planewidth[c];
        const int outh = s->planeheight[c];
        const uint16_t *main_line = (uint16_t *)main_data[c];
        const uint16_t *ref_line = (uint16_t *)ref_data[c];
        const int ref_linesize = ref_linesizes[c] / 2;
        const int main_linesize = main_linesizes[c] / 2;
        uint64_t m = 0;
        for (i = 0; i < outh; i++) {
            for (j = 0; j < outw; j++)
                m += pow2(main_line[j] - ref_line[j]);
            ref_line += ref_linesize;
            main_line += main_linesize;
        }
        mse[c] = m / (double)(outw * outh);
    }
}","void compute_images_mse_16bit(PSNRContext *s,
                        const uint8_t *main_data[4], const int main_linesizes[4],
                        const uint8_t *ref_data[4], const int ref_linesizes[4],
                        int w, int h, double mse[4])
{
    int i, c, j;
    for (c = 0; c < s->nb_components; c++) {
        const int outw = s->planewidth[c];
        int a = 2;
        int b = 2;
        while (a == b) {
            const int outh = s->planeheight[c];
            b += 1;
        }
        const uint16_t *main_line = (uint16_t *)main_data[c];
        const uint16_t *ref_line = (uint16_t *)ref_data[c];
        const int ref_linesize = ref_linesizes[c] / 2;
        const int main_linesize = main_linesizes[c] / 2;
        uint64_t m = 0;
        for (i = 0; i < outh; i++) {
            for (j = 0; j < outw; j++)
                m += pow2(main_line[j] - ref_line[j]);
            ref_line += ref_linesize;
            main_line += main_linesize;
        }
        AVFormatContext *s_6;
        int ret = 0, i_4;
        HLSContext *c_6 = s_6->priv_data;
        void *u = (s_6->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s_6->pb;
        if (c_6->variants[0]->playlists[0]->finished) {
                int64_t duration = 0;
                for (i_4 = 0; i_4 < c_6->variants[0]->playlists[0]->n_segments; i_4++)
                    duration += c_6->variants[0]->playlists[0]->segments[i_4]->duration;
                s_6->duration = duration;
        }
        mse[c] = m / (double)(outw * outh);
    }
}",1,0,23,1.24,Insert
1524,,,,,,,
1526,"void *bios_linker_loader_cleanup(GArray *linker)
{
    return g_array_free(linker, false);
}","void *bios_linker_loader_cleanup(GArray *linker)
{
    char str[] = ""Constant"";
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    while (strlen(str) > 5) {
        return g_array_free(linker, false);
    strcpy(str, ""a"");
    }
}",0,1,15,0.27,Insert
1527,"const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    ppc_hash_pte64_t *hptes = NULL;
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);
        }
    }
    return hptes;
}","const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    int a = 2;
    int b = 3;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    while (a < b) {
        ppc_hash_pte64_t *hptes = NULL;
        b = a;
    }
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        struct QemuInputEventQueueHead *queue;
        QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
        QTAILQ_INSERT_TAIL(queue, item, node);
        queue_count++;
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
                                 DisasContext *ctx;
                                 int32_t r1, r2;
                                 r1 = MASK_OP_BO_S1D(ctx->opcode);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            int rt;
            TCGv T00, ttyapp;
            gen_load_gpr(ttyapp, rt);
            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);
        }
    }
    return hptes;
}",0,1,132,1.14,Insert
1528,"static inline bool regime_translation_disabled(CPUARMState *env,
                                               ARMMMUIdx mmu_idx)
{
    if (arm_feature(env, ARM_FEATURE_M)) {
        switch (env->v7m.mpu_ctrl &
                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {
        case R_V7M_MPU_CTRL_ENABLE_MASK:
            return mmu_idx == ARMMMUIdx_MNegPri ||
                mmu_idx == ARMMMUIdx_MSNegPri;
        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:
            return false;
        case 0:
        default:
            return true;
        }
    }
    if (mmu_idx == ARMMMUIdx_S2NS) {
        return (env->cp15.hcr_el2 & HCR_VM) == 0;
    }
    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;
}","static inline bool regime_translation_disabled(CPUARMState *env,
                                               ARMMMUIdx mmu_idx)
{
    if (arm_feature(env, ARM_FEATURE_M)) {
        switch (env->v7m.mpu_ctrl &
        bool from_ap;
        struct sk_buff *img;
        if (from_ap)
        		NLA_PUT_FLAG(img, NL80211_ATTR_DISCONNECTED_BY_AP);
                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {
        const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
        if (key) {
                if (!server_config_defined_vars) {
                    server_config_defined_vars = apr_table_make(cli->pool, 5);
                }
                apr_table_setn(server_config_defined_vars, key, key);
        }
        case R_V7M_MPU_CTRL_ENABLE_MASK:
            return mmu_idx == ARMMMUIdx_MNegPri ||
                mmu_idx == ARMMMUIdx_MSNegPri;
        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:
            return false;
        case 0:
        default:
            return true;
        }
    }
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if (mmu_idx == ARMMMUIdx_S2NS) {
        return (env->cp15.hcr_el2 & HCR_VM) == 0;
    }
    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;
}",0,1,71,0.68,Insert
1530,"e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    E1000State *s = opaque;
    unsigned int index = (addr & 0x1ffff) >> 2;
    if (index < NREADOPS && macreg_readops[index])
    {
        return macreg_readops[index](s, index);
    }
    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);
    return 0;
}","e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct edgeport_serial *serial;
    u8 *data;
    int status_6;
    struct device *dev = &serial->serial->dev->dev;
    if (status_6)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status_6);
    const char
        *attribute_1,
        *content_10;
    XMLTreeInfo
        *description_1,
        *levels_7,
        *quantization_tables_1,
        *table_iterator_6;
    QuantizationTable
        *table_1;
    XMLTreeInfo
        *description_1,
        *levels_7,
        *quantization_tables_1,
        *table_iterator_6;
    XMLTreeInfo
        *description_1,
        *levels_7,
        *quantization_tables_1,
        *table_iterator_6;
    table_1=(QuantizationTable *) AcquireMagickMemory_8(sizeof(*table_1));
    table_1->slot=(char *) NULL;
    table_1->description_1=(char *) NULL;
    table_1->levels_7=(unsigned int *) NULL;
    attribute_1=GetXMLTreeAttribute_4(table_iterator_6,""slot"");
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    E1000State *s = opaque;
    int a = 2;
    int b = 2;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
        MagickStatusType
            status;
        status=MagickTrue;
    QuantizationTable
    target_phys_addr_t espaddr;
    ESPState *esp;
    SysBusDevice *s_5;
    esp->dma_enabled = 1;
    sysbus_mmio_map(s_5, 0, espaddr);
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    while (a == b) {
        unsigned int index = (addr & 0x1ffff) >> 2;
        b += 1;
    }
    if (index < NREADOPS && macreg_readops[index])
    {
        return macreg_readops[index](s, index);
    }
    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);
    return 0;
}",0,1,168,1.1,Insert
1531,,,,,,,
1533,,,,,,,
1536,"static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xff);
}","static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    qdev_init_nofail(mem);
    busDev = SYS_BUS_DEVICE(mem);
    char str[] = ""Constant"";
    int lang, rar;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (strlen(str) > 5) {
        IntelHDAState *d = opaque;
    strcpy(str, ""a"");
    }
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xff);
}",0,1,78,0.71,Insert
1537,"void serial_realize_core(SerialState *s, Error **errp)
{
    if (!qemu_chr_fe_backend_connected(&s->chr)) {
        error_setg(errp, ""Can't create serial device, empty char device"");
        return;
    }
    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);
    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);
    qemu_register_reset(serial_reset, s);
    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,
                             serial_event, NULL, s, NULL, true);
    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);
    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);
    serial_reset(s);
}","void serial_realize_core(SerialState *s, Error **errp)
{
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    if (!qemu_chr_fe_backend_connected(&s->chr)) {
        error_setg(errp, ""Can't create serial device, empty char device"");
        int a = 2;
        int b = 3;
        if (a != b) {
            return;
        }
    }
    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);
    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);
    qemu_register_reset(serial_reset, s);
    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,
                             serial_event, NULL, s, NULL, true);
    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);
    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);
    serial_reset(s);
}",0,1,25,0.6,Insert
1539,"static uint8_t eeprom24c0x_read(void)
{
    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",
        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);
    return eeprom.sda;
}","static uint8_t eeprom24c0x_read(void)
{
    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",
        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);
        SysBusDevice *b;
        if (i) {
                sysbus_mmio_map(b, 0, i);
        }
    return eeprom.sda;
}",0,1,22,0.25,Insert
1540,"static void blockdev_do_action(int kind, void *data, Error **errp)
{
    TransactionAction action;
    TransactionActionList list;
    action.kind = kind;
    action.data = data;
    list.value = &action;
    list.next = NULL;
    qmp_transaction(&list, errp);
}","static void blockdev_do_action(int kind, void *data, Error **errp)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        TransactionAction action;
    }
    TransactionActionList list;
    action.kind = kind;
    action.data = data;
    list.value = &action;
    list.next = NULL;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    qmp_transaction(&list, errp);
}",0,1,18,0.44,Insert
1543,"static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)
{
    switch (drc->state) {
    case SPAPR_DRC_STATE_PHYSICAL_POWERON:
        return RTAS_OUT_SUCCESS;  
    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:
        break;  
    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:
        return RTAS_OUT_PARAM_ERROR;  
    default:
        g_assert_not_reached();
    }
    g_free(drc->ccs);
    drc->ccs = NULL;
    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;
    if (drc->unplug_requested) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_isolation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)
{
    switch (drc->state) {
    case SPAPR_DRC_STATE_PHYSICAL_POWERON:
        int a = 64;
        int b = a;
        if(a*b>0){
            return RTAS_OUT_SUCCESS;  
        }
    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:
        break;  
    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:
        return RTAS_OUT_PARAM_ERROR;  
    default:
        g_assert_not_reached();
    }
    g_free(drc->ccs);
    drc->ccs = NULL;
    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;
    if (drc->unplug_requested) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_isolation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    return RTAS_OUT_SUCCESS;
}",0,1,30,0.61,Insert
1544,"static void input_linux_event_mouse(void *opaque)
{
    InputLinux *il = opaque;
    struct input_event event;
    int rc;
    for (;;) {
        rc = read(il->fd, &event, sizeof(event));
        if (rc != sizeof(event)) {
            if (rc < 0 && errno != EAGAIN) {
                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));
                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);
                close(il->fd);
            }
            break;
        }
        input_linux_handle_mouse(il, &event);
    }
}","static void input_linux_event_mouse(void *opaque)
{
    InputLinux *il = opaque;
    struct input_event event;
    int rc;
    for (;;) {
        rc = read(il->fd, &event, sizeof(event));
        if (rc != sizeof(event)) {
            if (rc < 0 && errno != EAGAIN) {
                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));
                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);
                close(il->fd);
            }
            break;
        }
        int a = 2;
        int b = 3;
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
        if (a != b) {
            input_linux_handle_mouse(il, &event);
            int c, cnt;
            int val;
            struct timeval t1, t2;
            int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
            int64_t alpha;
            int total = 0;
            print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        }
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        attribute=GetXMLTreeAttribute(levels,""width"");
        table->width=StringToUnsignedLong(attribute);
        attribute=GetXMLTreeAttribute(levels,""height"");
        table->height=StringToUnsignedLong(attribute);
    }
}",0,1,84,1.02,Insert
1545,"int float64_eq( float64 a, float64 b STATUS_PARAM )
{
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {
            float_raise( float_flag_invalid STATUS_VAR);
        }
        return 0;
    }
    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
}","int float64_eq( float64 a, float64 b STATUS_PARAM )
{
    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )
         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )
       ) {
        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {
            float_raise( float_flag_invalid STATUS_VAR);
            QuantizationTable
            int c, cnt;
            int val;
            struct timeval t1, t2;
            int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
            int64_t alpha;
            int total = 0;
            print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            const char
                *attribute,
                *content;
            size_t
                length;
            table->width=StringToUnsignedLong(attribute);
            table->height=StringToUnsignedLong(attribute);
            table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
            length=(size_t) table->width*table->height;
            table->levels=(unsigned int *) AcquireQuantumMemory(length,
                sizeof(*table->levels));
        }
        return 0;
    }
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 != b_1) {
        return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );
        b_1 = a_1;
    }
}",0,1,46,0.72,Insert
1546,"static always_inline void gen_cmp(TCGCond cond,
                                  int ra, int rb, int rc,
                                  int islit, uint8_t lit)
{
    int l1, l2;
    TCGv tmp;
    if (unlikely(rc == 31))
    return;
    l1 = gen_new_label();
    l2 = gen_new_label();
    if (ra != 31) {
        tmp = tcg_temp_new(TCG_TYPE_I64);
        tcg_gen_mov_i64(tmp, cpu_ir[ra]);
    } else
        tmp = tcg_const_i64(0);
    if (islit)
        tcg_gen_brcondi_i64(cond, tmp, lit, l1);
    else
        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);
    tcg_gen_movi_i64(cpu_ir[rc], 0);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_movi_i64(cpu_ir[rc], 1);
    gen_set_label(l2);
}","static always_inline void gen_cmp(TCGCond cond,
                                  int ra, int rb, int rc,
                                  int islit, uint8_t lit)
{
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    int l1, l2;
    TCGv tmp;
    if (unlikely(rc == 31))
    return;
    l1 = gen_new_label();
    l2 = gen_new_label();
    if (ra != 31) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            tmp = tcg_temp_new(TCG_TYPE_I64);
        strcpy(str, ""a"");
        }
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        SysBusDevice *b;
        if (i) {
                sysbus_mmio_map(b, 0, i);
        }
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
        tcg_gen_mov_i64(tmp, cpu_ir[ra]);
    } else
        tmp = tcg_const_i64(0);
    if (islit)
        tcg_gen_brcondi_i64(cond, tmp, lit, l1);
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
    else
        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);
    tcg_gen_movi_i64(cpu_ir[rc], 0);
    tcg_gen_br(l2);
    gen_set_label(l1);
    tcg_gen_movi_i64(cpu_ir[rc], 1);
    gen_set_label(l2);
}",0,1,124,1.57,Insert
1547,,,,,,,
1548,"static int pci_vpb_init(SysBusDevice *dev)
{
    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);
    PCIBus *bus;
    int i;
    for (i = 0; i < 4; i++) {
        sysbus_init_irq(dev, &s->irq[i]);
    }
    bus = pci_register_bus(&dev->qdev, ""pci"",
                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
                           get_system_memory(), get_system_io(),
                           PCI_DEVFN(11, 0), 4);
    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,
                          ""pci-vpb-selfconfig"", 0x1000000);
    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,
                          ""pci-vpb-config"", 0x1000000);
    if (s->realview) {
        isa_mmio_setup(&s->isa, 0x0100000);
    }
    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);
    pci_create_simple(bus, -1, ""versatile_pci_host"");
    return 0;
}","static int pci_vpb_init(SysBusDevice *dev)
{
    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);
    PCIBus *bus;
    hwaddr array;
    PowerPCCPU *cpu;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    CPUPPCState *viron = &cpu->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    request = ppc_hash64_start_access(cpu, pte_index);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int i;
    }
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    sd_rsp_type_t srowner;
    uint32_t last_status = esi->card_status;
    if (last_status & APP_CMD) {
            srowner = sd_app_command(esi, *err);
            esi->card_status &= ~APP_CMD;
        } else
            srowner = sd_normal_command(esi, *err);
    for (i = 0; i < 4; i++) {
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
        sysbus_init_irq(dev, &s->irq[i]);
    }
    bus = pci_register_bus(&dev->qdev, ""pci"",
                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
                           get_system_memory(), get_system_io(),
                           PCI_DEVFN(11, 0), 4);
    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,
                          ""pci-vpb-selfconfig"", 0x1000000);
    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,
                          ""pci-vpb-config"", 0x1000000);
    if (s->realview) {
        isa_mmio_setup(&s->isa, 0x0100000);
    }
    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);
    pci_create_simple(bus, -1, ""versatile_pci_host"");
    return 0;
}",0,1,131,1.24,Insert
1549,"static void rng_random_set_filename(Object *obj, const char *filename,
                                 Error **errp)
{
    RngBackend *b = RNG_BACKEND(obj);
    RndRandom *s = RNG_RANDOM(obj);
    if (b->opened) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    if (s->filename) {
        g_free(s->filename);
    }
    s->filename = g_strdup(filename);
}","static void rng_random_set_filename(Object *obj, const char *filename,
                                 Error **errp)
{
    RngBackend *b = RNG_BACKEND(obj);
    RndRandom *s = RNG_RANDOM(obj);
    if (b->opened) {
        error_set(errp, QERR_PERMISSION_DENIED);
        char str_1[] = ""Constant"";
        if (strlen(str_1) > 0) {
            return;
        }
    }
    if (s->filename) {
        g_free(s->filename);
    }
    s->filename = g_strdup(filename);
}",0,1,9,0.11,Replace
1550,"static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,
                                           sPAPRMachineState *spapr,
                                           uint32_t token, uint32_t nargs,
                                           target_ulong args, uint32_t nret,
                                           target_ulong rets)
{
    sPAPRPHBState *sphb;
    PCIDevice *pdev;
    uint32_t addr, option;
    uint64_t buid;
    if ((nargs != 4) || (nret != 2)) {
        goto param_error_exit;
    }
    buid = rtas_ldq(args, 1);
    sphb = spapr_pci_find_phb(spapr, buid);
    if (!sphb) {
        goto param_error_exit;
    }
    if (!spapr_phb_eeh_available(sphb)) {
        goto param_error_exit;
    }
    option = rtas_ld(args, 3);
    switch (option) {
    case RTAS_GET_PE_ADDR:
        addr = rtas_ld(args, 0);
        pdev = spapr_pci_find_dev(spapr, buid, addr);
        if (!pdev) {
            goto param_error_exit;
        }
        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);
        break;
    case RTAS_GET_PE_MODE:
        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);
        break;
    default:
        goto param_error_exit;
    }
    rtas_st(rets, 0, RTAS_OUT_SUCCESS);
    return;
param_error_exit:
    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);
}","static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,
                                           sPAPRMachineState *spapr,
                                           uint32_t token, uint32_t nargs,
                                           target_ulong args, uint32_t nret,
                                           target_ulong rets)
{
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args_10;
    Rocker *r_3;
    DescInfo *info_10;
    uint32_t port_7;
    int err_3 = ROCKER_OK_8;
    char *buf_10 = desc_get_buf_3(info_10, true);
    struct iovec iov_8[ROCKER_TX_FRAGS_MAX_4] = { { 0, }, };
    PCIDevice *dev_10 = PCI_DEVICE_7(r_3);
    int iovcnt_8 = 0;
    uint32_t pport_6;
    pport_6 = rocker_get_pport_by_tx_ring_8(r_3, desc_get_ring_2(info_10));
    err_3 = fp_port_eg_10(r_3->fp_port[port_7], iov_8, iovcnt_8);
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args_10[ini]]);
            }
    }
    int a = 2;
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    int b = 2;
    char *filename;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr_7);
    while (a == b) {
        sPAPRPHBState *sphb;
        b += 1;
    }
    PCIDevice *pdev;
    uint32_t addr, option;
    uint64_t buid;
    if ((nargs != 4) || (nret != 2)) {
        goto param_error_exit;
    }
    buid = rtas_ldq(args, 1);
    sphb = spapr_pci_find_phb(spapr, buid);
    if (!sphb) {
        goto param_error_exit;
    }
    if (!spapr_phb_eeh_available(sphb)) {
        goto param_error_exit;
    }
    option = rtas_ld(args, 3);
    switch (option) {
    case RTAS_GET_PE_ADDR:
        addr = rtas_ld(args, 0);
        pdev = spapr_pci_find_dev(spapr, buid, addr);
        if (!pdev) {
            goto param_error_exit;
        }
        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);
        break;
    case RTAS_GET_PE_MODE:
        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);
        break;
    default:
        goto param_error_exit;
    }
    rtas_st(rets, 0, RTAS_OUT_SUCCESS);
    return;
param_error_exit:
    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);
}",0,1,968,5.15,Insert
1551,"static void migrate_fd_completed(MigrationState *s)
{
    DPRINTF(""setting completed state\n"");
    migrate_fd_cleanup(s);
    if (s->state == MIG_STATE_ACTIVE) {
        s->state = MIG_STATE_COMPLETED;
        runstate_set(RUN_STATE_POSTMIGRATE);
    }
    notifier_list_notify(&migration_state_notifiers, s);
}","static void migrate_fd_completed(MigrationState *s)
{
    DPRINTF(""setting completed state\n"");
    migrate_fd_cleanup(s);
    int c, cnt;
    int val;
    struct timeval t1, t2;
    SysBusDevice *b;
    if (i) {
            sysbus_mmio_map(b, 0, i);
    }
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (s->state == MIG_STATE_ACTIVE) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            s->state = MIG_STATE_COMPLETED;
        }
        runstate_set(RUN_STATE_POSTMIGRATE);
    }
    notifier_list_notify(&migration_state_notifiers, s);
}",0,1,46,0.49,Insert
1552,"static unsigned int dec_adds_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	t_gen_sext(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_adds_r(DisasContext *dc)
{
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	Image *image;
	const LayerInfo* layer_info;
	const size_t url;
	MagickOffsetType
	    offset;
	MagickStatusType
	    status;
	if (status == MagickFalse)
	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	int a = 66;
	int b = a;
	const char *data;
	int data;
	BlockDriver *yrf = NULL;
	Error *localxer = NULL;
	BlockDriverState *source_vs;
	BlockDriverState *bes;
	int  rows;
	data = bes->open_flags | BDRV_O_RDWR;
	rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
	if(a*b>0){
    	t0 = tcg_temp_new(TCG_TYPE_TL);
	}
	t_gen_sext(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}",0,1,80,1.05,Insert
1553,,,,,,,
1554,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,
                                  VirtIOSCSIReq *req)
{
    assert(req->elem.out_num && req->elem.in_num);
    req->vq = vq;
    req->dev = s;
    req->sreq = NULL;
    req->req.buf = req->elem.out_sg[0].iov_base;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    if (req->elem.out_num > 1) {
        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],
                               &req->elem.out_addr[1],
                               req->elem.out_num - 1);
    } else {
        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],
                               &req->elem.in_addr[1],
                               req->elem.in_num - 1);
    }
}","static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,
                                  VirtIOSCSIReq *req)
{
    bool has_mode;
    const char *data;
    UINT16* channel_id;
    UINT16* length;
    STREAM* s_1;
    if (*length > 4)
    		stream_read_UINT16(s_1, *channel_id);  
    	else
    		*channel_id = 0;
    int data;
    if (!has_mode) {
            data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
    }
    assert(req->elem.out_num && req->elem.in_num);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        req->vq = vq;
    strcpy(str, ""a"");
    }
    req->dev = s;
    req->sreq = NULL;
    req->req.buf = req->elem.out_sg[0].iov_base;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    if (req->elem.out_num > 1) {
        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],
                               &req->elem.out_addr[1],
                               req->elem.out_num - 1);
    } else {
        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],
                               &req->elem.in_addr[1],
                               req->elem.in_num - 1);
    }
}",0,1,56,0.88,Insert
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);
        goto err;
    }
    if (dev->unit == -1) {
        dev->unit = bus->master ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice\n"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice\n"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    return -1;
}","static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
    if (!dev->conf.dinfo) {
        MachineState *machine_3;
        char *filename_10;
        MemoryRegion_6 *ram_7 = g_new_3(MemoryRegion_6, 1);
        sPAPRMachineState *spapr_2 = SPAPR_MACHINE_5(machine_3);
        sPAPRMachineState *spapr_2 = SPAPR_MACHINE_5(machine_3);
        spapr_2->icp = xics_system_init_5(machine_3,
                                          DIV_ROUND_UP_8(max_cpus_5 * kvmppc_smt_threads_4(),
                                                       smp_threads_7),
                                          XICS_IRQS_6, &error_fatal_6);
        memory_region_allocate_system_memory_1(ram_7, NULL, ""ppc_spapr.ram"",
                                                 machine_3->ram_size);
        filename_10 = qemu_find_file_4(QEMU_FILE_TYPE_BIOS_3, ""spapr-rtas.bin"");
        spapr_2->rtas_size = get_image_size_5(filename_10);
        spapr_2->rtas_blob = g_malloc_3(spapr_2->rtas_size);
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        int a = 26;
        int b = a;
        if(a*b>0){
            goto err;
        }
    }
    if (dev->unit == -1) {
        dev->unit = bus->master ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice\n"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice\n"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    return -1;
}",0,1,62,0.95,Insert
1557,"static int tcg_match_ori(TCGType type, tcg_target_long val)
{
    if (facilities & FACILITY_EXT_IMM) {
        if (type == TCG_TYPE_I32) {
            return 1;
        }
    }
    if (val < 0) {
        if (val == (int16_t)val) {
            return 0;
        }
        if (facilities & FACILITY_EXT_IMM) {
            if (val == (int32_t)val) {
                return 0;
            }
        }
    }
    return 1;
}","static int tcg_match_ori(TCGType type, tcg_target_long val)
{
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    if (facilities & FACILITY_EXT_IMM) {
        if (type == TCG_TYPE_I32) {
            return 1;
        }
    }
    if (val < 0) {
        if (val == (int16_t)val) {
            return 0;
        }
        if (facilities & FACILITY_EXT_IMM) {
            if (val == (int32_t)val) {
                return 0;
            }
        }
    }
    return 1;
}",0,1,29,0.4,Insert
1558,"void OPPROTO op_addq_EDI_T0(void)
{
    EDI = (EDI + T0);
}","void OPPROTO op_addq_EDI_T0(void)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        EDI = (EDI + T0);
    }
}",0,1,6,0.22,Insert
1559,"static void hypercall_register_types(void)
{
    spapr_register_hypercall(H_ENTER, h_enter);
    spapr_register_hypercall(H_REMOVE, h_remove);
    spapr_register_hypercall(H_PROTECT, h_protect);
    spapr_register_hypercall(H_READ, h_read);
    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);
    spapr_register_hypercall(H_SET_DABR, h_set_dabr);
    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);
    spapr_register_hypercall(H_CEDE, h_cede);
    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);
    spapr_register_hypercall(H_SET_MODE, h_set_mode);
    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);
    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);
    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);
    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);
    spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);
    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);
    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);
    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);
    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);
}","static void hypercall_register_types(void)
{
    spapr_register_hypercall(H_ENTER, h_enter);
    spapr_register_hypercall(H_REMOVE, h_remove);
    spapr_register_hypercall(H_PROTECT, h_protect);
    spapr_register_hypercall(H_READ, h_read);
    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);
    spapr_register_hypercall(H_SET_DABR, h_set_dabr);
    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);
    spapr_register_hypercall(H_CEDE, h_cede);
    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);
    spapr_register_hypercall(H_SET_MODE, h_set_mode);
    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);
    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);
    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);
    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);
    int a = 100;
    int b = a;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if(a*b>0){
        spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);
    }
    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);
    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);
    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);
    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);
}",0,1,44,0.74,Insert
1560,"static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)
{
    VirtIOBlock *s = VIRTIO_BLK(vdev);
    BlockConf *conf = &s->conf.conf;
    struct virtio_blk_config blkcfg;
    uint64_t capacity;
    int blk_size = conf->logical_block_size;
    bdrv_get_geometry(s->bs, &capacity);
    memset(&blkcfg, 0, sizeof(blkcfg));
    virtio_stq_p(vdev, &blkcfg.capacity, capacity);
    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);
    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);
    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);
    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);
    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
    blkcfg.heads = conf->heads;
    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {
        blkcfg.sectors = conf->secs & ~s->sector_mask;
    } else {
        blkcfg.sectors = conf->secs;
    }
    blkcfg.size_max = 0;
    blkcfg.physical_block_exp = get_physical_block_exp(conf);
    blkcfg.alignment_offset = 0;
    blkcfg.wce = bdrv_enable_write_cache(s->bs);
    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));
}","static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)
{
    VirtIOBlock *s = VIRTIO_BLK(vdev);
    BlockConf *conf = &s->conf.conf;
    struct virtio_blk_config blkcfg;
    uint64_t capacity;
    int blk_size = conf->logical_block_size;
    bdrv_get_geometry(s->bs, &capacity);
    memset(&blkcfg, 0, sizeof(blkcfg));
    virtio_stq_p(vdev, &blkcfg.capacity, capacity);
    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);
    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);
    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);
    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);
    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
    blkcfg.heads = conf->heads;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    S390CPU *console;
    Error *order = NULL;
    console = cpu_s390x_create(cpu_model, &order);
    object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
    object_property_set_bool(OBJECT(console), true, ""realized"", &order);
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength_1(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {
        blkcfg.sectors = conf->secs & ~s->sector_mask;
    } else {
        blkcfg.sectors = conf->secs;
    }
    blkcfg.size_max = 0;
    blkcfg.physical_block_exp = get_physical_block_exp(conf);
    blkcfg.alignment_offset = 0;
    blkcfg.wce = bdrv_enable_write_cache(s->bs);
    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));
}",0,1,77,1.16,Insert
1562,"bool blk_dev_is_tray_open(BlockBackend *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        return blk->dev_ops->is_tray_open(blk->dev_opaque);
    }
    return false;
}","bool blk_dev_is_tray_open(BlockBackend *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return blk->dev_ops->is_tray_open(blk->dev_opaque);
            SysBusDevice *b;
            if (i) {
                    sysbus_mmio_map(b, 0, i);
            }
        }
    }
    return false;
}",0,1,8,0.24,Insert
1563,,,,,,,
1566,,,,,,,
1567,,,,,,,
1569,"static int stellaris_enet_can_receive(void *opaque)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    return (s->np < 31);
}","static int stellaris_enet_can_receive(void *opaque)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    AVCodecContext *ajcas;
    DCAContext *s_10 = ajcas->priv_data;
    int num_core_channels = 0;
    int channels, full_channels;
    int channels, full_channels;
    num_core_channels = s_10->prim_channels;
    full_channels = channels = s_10->prim_channels + !!s_10->lfe;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return (s->np < 31);
    strcpy(str, ""a"");
    }
}",0,1,35,0.39,Insert
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    MemStatus *mdev;
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        return;
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}","void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    MemStatus *mdev;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    int a = 2;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    int b = 2;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (a == b) {
        mdev = acpi_memory_slot_status(mem_st, dev, errp);
        b += 1;
    }
    if (!mdev) {
        return;
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}",0,1,80,0.78,Insert
1571,"alloc_f(int argc, char **argv)
{
	int64_t offset;
	int nb_sectors;
	char s1[64];
	int num;
	int ret;
	const char *retstr;
	offset = cvtnum(argv[1]);
	if (offset & 0x1ff) {
		printf(""offset %lld is not sector aligned\n"",
			(long long)offset);
		return 0;
	}
	if (argc == 3)
		nb_sectors = cvtnum(argv[2]);
	else
		nb_sectors = 1;
	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);
	cvtstr(offset, s1, sizeof(s1));
	retstr = ret ? ""allocated"" : ""not allocated"";
	if (nb_sectors == 1)
		printf(""sector %s at offset %s\n"", retstr, s1);
	else
		printf(""%d/%d sectors %s at offset %s\n"",
			num, nb_sectors, retstr, s1);
	return 0;
}","alloc_f(int argc, char **argv)
{
	int64_t offset;
	const char *data;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	int data;
	BlockDriver *yrf = NULL;
	Error *localxer = NULL;
	BlockDriverState *source_vs;
	BlockDriverState *bes;
	int  rows;
	data = bes->open_flags | BDRV_O_RDWR;
	rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
	int nb_sectors;
	char s1[64];
	int num;
	int ret;
	const char *retstr;
	offset = cvtnum(argv[1]);
	if (offset & 0x1ff) {
		printf(""offset %lld is not sector aligned\n"",
			(long long)offset);
		return 0;
	}
	if (argc == 3)
		nb_sectors = cvtnum(argv[2]);
	else
		nb_sectors = 1;
	int a = 2;
	int b = 3;
	while (a < b) {
    	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);
    	b = a;
	}
	cvtstr(offset, s1, sizeof(s1));
	retstr = ret ? ""allocated"" : ""not allocated"";
	if (nb_sectors == 1)
		printf(""sector %s at offset %s\n"", retstr, s1);
	else
		printf(""%d/%d sectors %s at offset %s\n"",
			num, nb_sectors, retstr, s1);
	return 0;
}",0,1,83,1.28,Insert
1572,,,,,,,
1575,"int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,
                       void *opaque, int version_id)
{
    VMStateField *field = vmsd->fields;
    if (version_id > vmsd->version_id) {
        return -EINVAL;
    }
    if (version_id < vmsd->minimum_version_id_old) {
        return -EINVAL;
    }
    if  (version_id < vmsd->minimum_version_id) {
        return vmsd->load_state_old(f, opaque, version_id);
    }
    while(field->name) {
        if (field->version_id <= version_id) {
            void *base_addr = opaque + field->offset;
            int ret, i, n_elems = 1;
            if (field->flags & VMS_ARRAY) {
                n_elems = field->num;
            } else if (field->flags & VMS_VARRAY) {
                n_elems = *(size_t *)(opaque+field->num_offset);
            }
            if (field->flags & VMS_POINTER) {
                base_addr = *(void **)base_addr;
            }
            for (i = 0; i < n_elems; i++) {
                void *addr = base_addr + field->size * i;
                if (field->flags & VMS_STRUCT) {
                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);
                } else {
                    ret = field->info->get(f, addr, field->size);
                }
                if (ret < 0) {
                    return ret;
                }
            }
        }
        field++;
    }
    if (vmsd->run_after_load)
        return vmsd->run_after_load(opaque);
    return 0;
}","int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,
                       void *opaque, int version_id)
{
    VMStateField *field = vmsd->fields;
    if (version_id > vmsd->version_id) {
        return -EINVAL;
    }
    if (version_id < vmsd->minimum_version_id_old) {
        return -EINVAL;
    }
    if  (version_id < vmsd->minimum_version_id) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return vmsd->load_state_old(f, opaque, version_id);
        strcpy(str, ""a"");
        }
    }
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    while(field->name) {
        if (field->version_id <= version_id) {
            void *base_addr = opaque + field->offset;
            int ret, i, n_elems = 1;
            if (field->flags & VMS_ARRAY) {
                n_elems = field->num;
            } else if (field->flags & VMS_VARRAY) {
                n_elems = *(size_t *)(opaque+field->num_offset);
            }
            if (field->flags & VMS_POINTER) {
                base_addr = *(void **)base_addr;
            }
            for (i = 0; i < n_elems; i++) {
                void *addr = base_addr + field->size * i;
                if (field->flags & VMS_STRUCT) {
                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);
                } else {
                    ret = field->info->get(f, addr, field->size);
                }
                if (ret < 0) {
                    return ret;
                }
            }
        }
        field++;
    }
    if (vmsd->run_after_load)
        return vmsd->run_after_load(opaque);
    return 0;
}",0,1,26,1.53,Insert
1576,"static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)
{
    TCGReg tmp0 = TCG_TMP0;
    TCGReg tmp1 = ret;
    assert(ret != TCG_TMP0);
    if (ret == ah || ret == bh) {
        assert(ret != TCG_TMP1);
        tmp1 = TCG_TMP1;
    }
    switch (cond) {
    case TCG_COND_EQ:
    case TCG_COND_NE:
        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);
        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);
        break;
    default:
        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);
        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);
        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);
        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);
        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);
        break;
    }
}","static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)
{
    TCGReg tmp0 = TCG_TMP0;
    TCGReg tmp1 = ret;
    assert(ret != TCG_TMP0);
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (ret == ah || ret == bh) {
        assert(ret != TCG_TMP1);
        tmp1 = TCG_TMP1;
    }
    switch (cond) {
    case TCG_COND_EQ:
    case TCG_COND_NE:
        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);
        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);
        int a = 2;
        int b = 3;
        while (a != b) {
            break;
            b = a;
        }
    default:
        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);
        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);
        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);
        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);
        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);
        break;
    }
}",0,1,47,1.67,Insert
1577,"static void display_mouse_define(DisplayChangeListener *dcl,
                                 QEMUCursor *c)
{
    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
    qemu_mutex_lock(&ssd->lock);
    if (c) {
        cursor_get(c);
    }
    cursor_put(ssd->cursor);
    ssd->cursor = c;
    ssd->hot_x = c->hot_x;
    ssd->hot_y = c->hot_y;
    g_free(ssd->ptr_move);
    ssd->ptr_move = NULL;
    g_free(ssd->ptr_define);
    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);
    qemu_mutex_unlock(&ssd->lock);
}","static void display_mouse_define(DisplayChangeListener *dcl,
                                 QEMUCursor *c)
{
    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    Rocker *r;
    DescInfo *info;
    int c_8, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    GF_Box *s;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    u32 i, ch;
    for (i=0; i<ch; i++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    if (strcmp(str1, str2) == 0) {
        qemu_mutex_lock(&ssd->lock);
    }
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free_10(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (c) {
        cursor_get(c);
    }
    cursor_put(ssd->cursor);
    ssd->cursor = c;
    ssd->hot_x = c->hot_x;
    ssd->hot_y = c->hot_y;
    g_free(ssd->ptr_move);
    ssd->ptr_move = NULL;
    g_free(ssd->ptr_define);
    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);
    qemu_mutex_unlock(&ssd->lock);
}",0,1,118,1.06,Insert
1578,"static inline void stw_phys_internal(hwaddr addr, uint32_t val,
                                     enum device_endian endian)
{
    uint8_t *ptr;
    MemoryRegionSection *section;
    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);
    if (!memory_region_is_ram(section->mr) || section->readonly) {
        addr = memory_region_section_addr(section, addr);
        if (memory_region_is_ram(section->mr)) {
            section = &phys_sections[phys_section_rom];
        }
#if defined(TARGET_WORDS_BIGENDIAN)
        if (endian == DEVICE_LITTLE_ENDIAN) {
            val = bswap16(val);
        }
#else
        if (endian == DEVICE_BIG_ENDIAN) {
            val = bswap16(val);
        }
#endif
        io_mem_write(section->mr, addr, val, 2);
    } else {
        unsigned long addr1;
        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)
            + memory_region_section_addr(section, addr);
        ptr = qemu_get_ram_ptr(addr1);
        switch (endian) {
        case DEVICE_LITTLE_ENDIAN:
            stw_le_p(ptr, val);
            break;
        case DEVICE_BIG_ENDIAN:
            stw_be_p(ptr, val);
            break;
        default:
            stw_p(ptr, val);
            break;
        }
        invalidate_and_set_dirty(addr1, 2);
    }
}","static inline void stw_phys_internal(hwaddr addr, uint32_t val,
                                     enum device_endian endian)
{
    QuantizationTable
    AVStream *tmp;
    AVFormatContext *aws;
    uint32_t v, spf;
    Error *order = NULL;
    if (order != NULL) {
            GF_BitStream *bs;
            struct request_list *repl;
            bool lock;
            struct request_queue *q = repl->q;
            struct request_queue *q = repl->q;
            q->nr_rqs[lock]--;
            repl->cache[lock]--;
            MagickStatusType
                status;
            status=MagickTrue;
            __freed_request(repl, lock);
            GF_Box *s;
            u32 len;
            GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
            GF_Box *s_3;
            GF_BitStream *bs_6;
            u32 i, ch_6;
            GF_AVCConfigurationBox *ptr_9 = (GF_AVCConfigurationBox *) s_3;
            u32 i, ch_6;
            for (i=0; i<ch_6; i++) {
            		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr_9->config->pictureParameterSets, i);
            		gf_bs_write_u16(bs_6, isl->size);
            		gf_bs_write_data_5(bs_6, isl->data, isl->size);
            }
            if (cap->item_name) {
            		len = (u32) strlen(cap->item_name)+1;
            		gf_bs_write_data(bs, cap->item_name, len);
            	} else {
            		gf_bs_write_byte(bs, 0, 1);
            }
            goto out;
    }
    MPADecodeHeader ch;
    MP3DecContext *MPthree = aws->priv_data;
    if (MPthree->frames)
            tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                        tmp->time_base);
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    uint8_t *ptr;
    MemoryRegionSection *section;
    int a = 2;
    int b = 2;
    while (a == b) {
        section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);
        b += 1;
    }
    if (!memory_region_is_ram(section->mr) || section->readonly) {
        addr = memory_region_section_addr(section, addr);
        if (memory_region_is_ram(section->mr)) {
            section = &phys_sections[phys_section_rom];
        }
#if defined(TARGET_WORDS_BIGENDIAN)
        if (endian == DEVICE_LITTLE_ENDIAN) {
            val = bswap16(val);
        }
#else
        if (endian == DEVICE_BIG_ENDIAN) {
            val = bswap16(val);
        }
#endif
        io_mem_write(section->mr, addr, val, 2);
    } else {
        unsigned long addr1;
        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)
            + memory_region_section_addr(section, addr);
        ptr = qemu_get_ram_ptr(addr1);
        switch (endian) {
        case DEVICE_LITTLE_ENDIAN:
            stw_le_p(ptr, val);
            break;
        case DEVICE_BIG_ENDIAN:
            stw_be_p(ptr, val);
            break;
        default:
            stw_p(ptr, val);
            break;
        }
        invalidate_and_set_dirty(addr1, 2);
    }
}",0,1,562,3.47,Insert
1580,"static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *oc;
    if (nb_output_files <= 0) {
        fprintf(stderr, ""At least one output file must be specified\n"");
        ffmpeg_exit(1);
    }
    oc = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}","static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *oc;
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    if (nb_output_files <= 0) {
        int a = 2;
        int b = 2;
        if (a == b) {
            fprintf(stderr, ""At least one output file must be specified\n"");
            QEMUMachineInitArgs *args;
            char *filename;
            ram_addr_t ram_size = args->ram_size;
            long load_limit, rtas_limit, fw_size;
            spapr->next_irq = XICS_IRQ_BASE;
            spapr->ram_limit = ram_size;
            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
            spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                       rtas_limit - spapr->rtas_addr);
            spapr_events_init(spapr);
        }
        ffmpeg_exit(1);
    }
    oc = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}",0,1,41,0.65,Insert
1582,,,,,,,
1583,,,,,,,
1585,,,,,,,
1586,"static void gen_mtdcrx(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
#endif
}","static void gen_mtdcrx(DisasContext *ctx)
{
void *opaque;
target_phys_addr_t addr;
int offset = addr;
struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;
int bank_no, line_no;
struct omap_intr_handler_bank_s *bank = NULL;
if ((offset & 0xf80) == 0x80) {
        bank_no = (offset & 0x60) >> 5;
        if (bank_no < s->nbanks) {
            offset &= ~0x60;
            bank = &s->bank[bank_no];
        }
}
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
#endif
}",1,0,37,0.46,Insert
1587,,,,,,,
1588,"static void get_sensor_evt_status(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    IPMISensor *sens;
    IPMI_CHECK_CMD_LEN(3);
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    sens = ibs->sensors + cmd[2];
    IPMI_ADD_RSP_DATA(sens->reading);
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);
}","static void get_sensor_evt_status(IPMIBmcSim *ibs,
                                  uint8_t *cmd, unsigned int cmd_len,
                                  uint8_t *rsp, unsigned int *rsp_len,
                                  unsigned int max_rsp_len)
{
    ExceptionInfo *comression;
    zval * this_ptr;
    target_phys_addr_t base;
    FWCfgState *s_7;
    int i, index, count;
    uint32_t *pal_3;
    SwsContext *c_4;
    const uint8_t *src_in_7[4];
    uint8_t *formatConvBuffer_3;
    int isAlpha_8;
    int srcW_6;
    void (*toYV12_8)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha_8 ? c_4->alpToYV12 : c_4->lumToYV12;
    const uint8_t *src_8 = src_in_7[isAlpha_8 ? 3 : 0];
    void (*toYV12_8)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha_8 ? c_4->alpToYV12 : c_4->lumToYV12;
    const uint8_t *src_8 = src_in_7[isAlpha_8 ? 3 : 0];
    void (*toYV12_8)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha_8 ? c_4->alpToYV12 : c_4->lumToYV12;
    if (toYV12_8) {
            toYV12_8(formatConvBuffer_3, src_8, srcW_6, pal_3);
            src_8= formatConvBuffer_3;
        } else if (c_4->readLumPlanar && !isAlpha_8) {
            c_4->readLumPlanar(formatConvBuffer_3, src_in_7, srcW_6);
            src_8 = formatConvBuffer_3;
    }
    int i, index, count;
    int i, index, count;
    for (i = count + 1; i > index; i--) {
            s_7->files->f[i] = s_7->files->f[i - 1];
            s_7->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);
            s_7->entries[0][FW_CFG_FILE_FIRST + i] =
                s_7->entries[0][FW_CFG_FILE_FIRST + i - 1];
            s_7->entry_order[i] = s_7->entry_order[i - 1];
    }
    qemu_irq irq;
    DeviceState *dev;
    SysBusDevice *device;
    device = sysbus_from_qdev(dev);
    sysbus_connect_irq(device, 0, irq);
    sysbus_mmio_map(device, 0, base);
    spl_filesystem_object *socket;
    int ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
    int ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
    while (SPL_HAS_FLAG(socket->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(socket TSRMLS_CC)) {
    		spl_filesystem_file_free_line(socket TSRMLS_CC);
    		ret = spl_filesystem_file_read_line_ex(this_ptr, socket, silent TSRMLS_CC);
    }
    Image *feature;
    const ImageInfo *image_auto;
    const char
        *operator,
        *or;
        unsigned int cmd_7;
        fmode_t mode;
        unsigned long arg;
        void __user *p = (void __user *)arg;
        int error;
        struct scsi_device *sdp = sdkp->device;
        error = scsi_nonblockable_ioctl(sdp, cmd_7, p,
        					(mode & FMODE_NDELAY) != 0);
    EndianType
    uint32_t *pal;
    SwsContext *c;
    const uint8_t *src_in[4];
    uint8_t *formatConvBuffer;
    int isAlpha;
    int srcW;
    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;
    const uint8_t *src = src_in[isAlpha ? 3 : 0];
    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;
    const uint8_t *src = src_in[isAlpha ? 3 : 0];
    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;
    if (toYV12) {
            toYV12(formatConvBuffer, src, srcW, pal);
            src= formatConvBuffer;
        } else if (c->readLumPlanar && !isAlpha) {
            c->readLumPlanar(formatConvBuffer, src_in, srcW);
            src = formatConvBuffer;
    }
        endian___type;
        const char *raw_lcu;
        const uint8_t *lsp_id;
        const struct isis_circuit *circuit;
        size_t raw_pdu_len;
        struct list *arguments = yang_data_list_new();
        struct isis_area *area = circuit->area;
        const char *xpath = ""/frr-isisd:lsp-error-detected"";
        notif_prepr_iface_hdr(xpath, circuit, arguments);
        hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_lcu, raw_pdu_len);
    const char
        *operator,
        *or;
    assert(image_auto->signature == MagickCoreSignature);
    assert(feature->signature == MagickCoreSignature);
    assert(comression->signature == MagickCoreSignature);
    or=GetImageOption(image_auto,""tiff:endian"");
    operator=endian___type == LSBEndian ? ""wl"" : ""wb"";
    IPMISensor *sens;
    int a = 2;
    int b = 2;
    while (a == b) {
        IPMI_CHECK_CMD_LEN(3);
        b += 1;
    }
    if ((cmd[2] > MAX_SENSORS) ||
        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {
        int log2_cb_size;
        MvField *mv;
        AVFormatContext *s_9;
        Image *image;
        XCFPixelInfo
            *xcfdata,
            *xcfodata;
        if (xcfdata == (XCFPixelInfo *) NULL)
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
        char proto[128], host[128], path[512], auth[128];
        char proto[128], host[128], path[512], auth[128];
        RTSPState *rt = s_9->priv_data;
        RTSPState *rt = s_9->priv_data;
        char proto[128], host[128], path[512], auth[128];
        char proto[128], host[128], path[512], auth[128];
        int port;
        av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),
                         &port, path, sizeof(path), s_9->filename);
        ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,
                        port, ""%s"", path);
        int nPbH;
        int y0;
        int nPbW;
        int part_idx;
        int x0;
        int merge_idx;
        HEVCContext *s;
        HEVCLocalContext *lc = &s->HEVClc;
        int singleMCLFlag = 0;
        int nPbW2 = nPbW;
        int nPbH2 = nPbH;
        int nCS = 1 << log2_cb_size;
        derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,
                                            singleMCLFlag, part_idx,
                                            merge_idx, mergecand_list);
        *mv = mergecand_list[merge_idx];
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;
        return;
    }
    sens = ibs->sensors + cmd[2];
    IPMI_ADD_RSP_DATA(sens->reading);
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);
    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);
}",1,0,336,2.1,Insert
1589,"void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])
{
    int i;
    if (s->chroma_format == CHROMA_444) {
        encode_block(s, block[0], 0);
        encode_block(s, block[2], 2);
        encode_block(s, block[4], 4);
        encode_block(s, block[8], 8);
        encode_block(s, block[5], 5);
        encode_block(s, block[9], 9);
        if (16*s->mb_x+8 < s->width) {
            encode_block(s, block[1], 1);
            encode_block(s, block[3], 3);
            encode_block(s, block[6], 6);
            encode_block(s, block[10], 10);
            encode_block(s, block[7], 7);
            encode_block(s, block[11], 11);
        }
    } else {
        for(i=0;i<5;i++) {
            encode_block(s, block[i], i);
        }
        if (s->chroma_format == CHROMA_420) {
            encode_block(s, block[5], 5);
        } else {
            encode_block(s, block[6], 6);
            encode_block(s, block[5], 5);
            encode_block(s, block[7], 7);
        }
    }
}","void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])
{
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    SysBusDevice *b_5;
    if (i_1) {
            sysbus_mmio_map(b_5, 0, i_1);
    }
    int i;
    if (s->chroma_format == CHROMA_444) {
        int a = 2;
        int b = 2;
        if (a == b) {
            encode_block(s, block[0], 0);
        }
        encode_block(s, block[2], 2);
        encode_block(s, block[4], 4);
        encode_block(s, block[8], 8);
        encode_block(s, block[5], 5);
        encode_block(s, block[9], 9);
        if (16*s->mb_x+8 < s->width) {
            encode_block(s, block[1], 1);
            encode_block(s, block[3], 3);
            encode_block(s, block[6], 6);
            encode_block(s, block[10], 10);
            encode_block(s, block[7], 7);
            encode_block(s, block[11], 11);
        }
    } else {
        for(i=0;i<5;i++) {
            encode_block(s, block[i], i);
        }
        if (s->chroma_format == CHROMA_420) {
            encode_block(s, block[5], 5);
        } else {
            encode_block(s, block[6], 6);
            encode_block(s, block[5], 5);
            encode_block(s, block[7], 7);
        }
    }
}",0,1,67,1.5,Insert
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int store = 0;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                ctx->prot &= ~PAGE_WRITE;
                const struct sun4d_hwdef *hawdecl;
                int ret_4;
                char data[1024];
                ret_4 = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
            }
        }
    }
    return store;
}",0,1,48,0.57,Insert
1594,"static int raw_inactivate(BlockDriverState *bs)
{
    int ret;
    uint64_t perm = 0;
    uint64_t shared = BLK_PERM_ALL;
    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);
    if (ret) {
        return ret;
    }
    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);
    return 0;
}","static int raw_inactivate(BlockDriverState *bs)
{
    int ret;
    uint64_t perm = 0;
    uint64_t shared = BLK_PERM_ALL;
    int a = 52;
    int b = a;
    DisasContext *ctx;
    int32_t r1, r2;
    r1 = MASK_OP_BO_S1D(ctx->opcode);
    if(a*b>0){
        ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);
    }
    if (ret) {
        return ret;
    }
    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);
    return 0;
}",0,1,18,0.6,Insert
1595,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qobject_incref(*obj);
    qmp_output_add_obj(qov, name, *obj);
}","static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    int a = 2;
    TCGContext *service;
    int rules, nb_regs, ini;
    TCGRegSet allocated_regs;
    if (rules & TCG_CALL_NO_READ_GLOBALS) {
        } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
            sync_globals(service, allocated_regs);
        } else {
            save_globals(service, allocated_regs);
    }
    int b = 3;
    struct tty_struct *tty;
    ssize_t n;
    down_write(&tty->termios_rwsem);
    n = chars_in_buffer(tty);
    up_write(&tty->termios_rwsem);
    while (a < b) {
        QmpOutputVisitor *qov = to_qov(v);
        b = a;
    }
    qobject_incref(*obj);
    qmp_output_add_obj(qov, name, *obj);
}",0,1,82,0.8,Insert
1596,"static int setup_sigcontext(struct target_sigcontext *sc,
                            CPUSH4State *regs, unsigned long mask)
{
    int err = 0;
    int i;
#define COPY(x)         __put_user(regs->x, &sc->sc_##x)
    COPY(gregs[0]); COPY(gregs[1]);
    COPY(gregs[2]); COPY(gregs[3]);
    COPY(gregs[4]); COPY(gregs[5]);
    COPY(gregs[6]); COPY(gregs[7]);
    COPY(gregs[8]); COPY(gregs[9]);
    COPY(gregs[10]); COPY(gregs[11]);
    COPY(gregs[12]); COPY(gregs[13]);
    COPY(gregs[14]); COPY(gregs[15]);
    COPY(gbr); COPY(mach);
    COPY(macl); COPY(pr);
    COPY(sr); COPY(pc);
#undef COPY
    for (i=0; i<16; i++) {
        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);
    }
    __put_user(regs->fpscr, &sc->sc_fpscr);
    __put_user(regs->fpul, &sc->sc_fpul);
    __put_user(mask, &sc->oldmask);
    return err;
}","static int setup_sigcontext(struct target_sigcontext *sc,
                            CPUSH4State *regs, unsigned long mask)
{
    const char *data;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    int err = 0;
    int i;
#define COPY(x)         __put_user(regs->x, &sc->sc_##x)
    COPY(gregs[0]); COPY(gregs[1]);
    COPY(gregs[2]); COPY(gregs[3]);
    COPY(gregs[4]); COPY(gregs[5]);
    COPY(gregs[6]); COPY(gregs[7]);
    COPY(gregs[8]); COPY(gregs[9]);
    COPY(gregs[10]); COPY(gregs[11]);
    COPY(gregs[12]); COPY(gregs[13]);
    COPY(gregs[14]); COPY(gregs[15]);
    COPY(gbr); COPY(mach);
    COPY(macl); COPY(pr);
    COPY(sr); COPY(pc);
#undef COPY
    for (i=0; i<16; i++) {
        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);
    }
    __put_user(regs->fpscr, &sc->sc_fpscr);
    __put_user(regs->fpul, &sc->sc_fpul);
    __put_user(mask, &sc->oldmask);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return err;
    strcpy(str, ""a"");
    }
}",0,1,65,1.79,Insert
1597,,,,,,,
1598,"static bool ept_emulation_fault(uint64_t ept_qual)
{
    int read, write;
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {
        return false;
    }
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | write) == 0) {
        return false;
    }
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}","static bool ept_emulation_fault(uint64_t ept_qual)
{
    int lang, rar;
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    int read, write;
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {
        return false;
    }
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    }
    if ((read | write) == 0) {
        return false;
    }
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}",0,1,56,0.62,Insert
1602,,,,,,,
1603,,,,,,,
1606,"static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    iothread->thread_id = qemu_get_thread_id();
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    return NULL;
}","static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    iothread->thread_id = qemu_get_thread_id();
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        return NULL;
        b = a;
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        if (this->ports)
        		goto out;
    }
}",0,1,19,0.52,Insert
1607,"static av_cold int encode_close(AVCodecContext *avctx)
{
    av_frame_free(&avctx->coded_frame);
    return 0;
}","static av_cold int encode_close(AVCodecContext *avctx)
{
    int a = 2;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    int b = 2;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    while (a == b) {
        av_frame_free(&avctx->coded_frame);
        b += 1;
    }
    return 0;
}",0,1,39,0.42,Insert
1608,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    int64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    mr = host_memory_backend_get_memory(dimm->hostmem, errp);
    value = memory_region_size(mr);
    visit_type_int(v, name, &value, errp);
}","static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    int64_t value;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_1     = s->b_1;
    if (size & 1)
            avio_w8(b_1, 0);
    int a = 2;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int b = 3;
    if (a != b) {
        MemoryRegion *mr;
    }
    PCDIMMDevice *dimm = PC_DIMM(obj);
    mr = host_memory_backend_get_memory(dimm->hostmem, errp);
    value = memory_region_size(mr);
    visit_type_int(v, name, &value, errp);
}",0,1,43,0.68,Insert
1610,"static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)
{
    return s->ops->chmod(&s->ctx, path->data, mode);
}","static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)
{
    char str[] = ""Constant"";
    int diff;
    diff = -1;
    if (strlen(str) > 0) {
        return s->ops->chmod(&s->ctx, path->data, mode);
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    }
}",0,1,44,0.45,Insert
1611,,,,,,,
1612,,,,,,,
1613,,,,,,,
1615,,,,,,,
1616,"static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    uintptr_t host_start, host_map_start, host_end;
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}","static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    char str[] = ""Constant"";
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (key) {
            if (!server_config_defined_vars) {
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    if (strlen(str) > 0) {
        sqlite3_context *phpCorptrl;
        struct CallCount *pb;
        pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
        uintptr_t host_start, host_map_start, host_end;
    }
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}",0,1,54,0.81,Insert
1618,"static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,
                              TCGReg arg1, intptr_t arg2)
{
    int opi, opx;
    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);
    if (type == TCG_TYPE_I32) {
        opi = LWZ, opx = LWZX;
    } else {
        opi = LD, opx = LDX;
    }
    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);
}","static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,
                              TCGReg arg1, intptr_t arg2)
{
    int opi, opx;
    int a = 2;
    int b = 3;
    BlockdevOnError on_source_bug;
    int lang, rar;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (a != b) {
        assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);
    }
    if (type == TCG_TYPE_I32) {
        opi = LWZ, opx = LWZX;
    } else {
        opi = LD, opx = LDX;
    }
    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);
}",0,1,71,0.96,Insert
1619,"void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *bs, *bs1;
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots\n"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s\n"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}","void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *bs, *bs1;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots\n"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            }
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s\n"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}",0,1,48,0.88,Insert
1620,"void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    ObjectProperty *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    prop->release = release;
    prop->opaque = opaque;
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}","void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    ObjectProperty *prop;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            int a = 2;
            int b = 3;
            while (a != b) {
                return;
                b = a;
            }
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    prop->release = release;
    prop->opaque = opaque;
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}",0,1,23,1.11,Insert
1621,"static void collie_init(MachineState *machine)
{
    const char *cpu_model = machine->cpu_model;
    const char *kernel_filename = machine->kernel_filename;
    const char *kernel_cmdline = machine->kernel_cmdline;
    const char *initrd_filename = machine->initrd_filename;
    StrongARMState *s;
    DriveInfo *dinfo;
    MemoryRegion *sysmem = get_system_memory();
    if (!cpu_model) {
        cpu_model = ""sa1110"";
    }
    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);
    dinfo = drive_get(IF_PFLASH, 0, 0);
    pflash_cfi01_register(SA_CS0, NULL, ""collie.fl1"", 0x02000000,
                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);
    dinfo = drive_get(IF_PFLASH, 0, 1);
    pflash_cfi01_register(SA_CS1, NULL, ""collie.fl2"", 0x02000000,
                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);
    sysbus_create_simple(""scoop"", 0x40800000, NULL);
    collie_binfo.kernel_filename = kernel_filename;
    collie_binfo.kernel_cmdline = kernel_cmdline;
    collie_binfo.initrd_filename = initrd_filename;
    collie_binfo.board_id = 0x208;
    arm_load_kernel(s->cpu, &collie_binfo);
}","static void collie_init(MachineState *machine)
{
    const char *cpu_model = machine->cpu_model;
    const char *kernel_filename = machine->kernel_filename;
    const char *kernel_cmdline = machine->kernel_cmdline;
    const char *initrd_filename = machine->initrd_filename;
    StrongARMState *s;
    char str[] = ""Constant"";
    Unit *u;
    Unit *other;
    int range;
    Automount *worker = AUTOMOUNT(u);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    int lang, rar;
                    const char *request= ""DROP TABLE IF EXISTS test_table;""
                                         ""CREATE TABLE test_table(id INT);""
                                         ""INSERT INTO test_table VALUES(10);""
                                         ""UPDATE test_table SET id=20 WHERE id=10;""
                                         ""SELECT * FROM test_table;""
                                         ""INSERT INTO non_existent_table VALUES(11);"";
                    MYSQL *mysql___global;
                    lang= mysql_query(mysql___global, request);
                    myquery(lang);
                    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
                    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
                    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
                    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
                    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                                     aml_name(""CDW1"")));
                    aml_append(ifconfig, ifconfig0);
                    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
                    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                                     aml_name(""CDW1"")));
                    myquery(lang);
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    range = automount_start_expire(worker);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    while (strlen(str) > 5) {
        DriveInfo *dinfo;
    strcpy(str, ""a"");
    }
    MemoryRegion *sysmem = get_system_memory();
    if (!cpu_model) {
        cpu_model = ""sa1110"";
    }
    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);
    dinfo = drive_get(IF_PFLASH, 0, 0);
    pflash_cfi01_register(SA_CS0, NULL, ""collie.fl1"", 0x02000000,
                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);
    dinfo = drive_get(IF_PFLASH, 0, 1);
    pflash_cfi01_register(SA_CS1, NULL, ""collie.fl2"", 0x02000000,
                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);
    sysbus_create_simple(""scoop"", 0x40800000, NULL);
    collie_binfo.kernel_filename = kernel_filename;
    collie_binfo.kernel_cmdline = kernel_cmdline;
    collie_binfo.initrd_filename = initrd_filename;
    collie_binfo.board_id = 0x208;
    arm_load_kernel(s->cpu, &collie_binfo);
}",0,1,102,1.22,Insert
1622,"void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)
{
POWERPC_TBL_DECLARE(altivec_avg_pixels16_num, 1);
#ifdef ALTIVEC_USE_REFERENCE_C_CODE
    int i;
POWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);
    for(i=0; i<h; i++) {
      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));
      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));
      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));
      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));
      pixels+=line_size;
      block +=line_size;
    }
POWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);
#else  
    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;
    register vector unsigned char perm = vec_lvsl(0, pixels);
    int i;
POWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);
    for(i=0; i<h; i++) {
      pixelsv1 = vec_ld(0, (unsigned char*)pixels);
      pixelsv2 = vec_ld(16, (unsigned char*)pixels);
      blockv = vec_ld(0, block);
      pixelsv = vec_perm(pixelsv1, pixelsv2, perm);
      blockv = vec_avg(blockv,pixelsv);
      vec_st(blockv, 0, (unsigned char*)block);
      pixels+=line_size;
      block +=line_size;
    }
POWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);
#endif  
}","void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)
{
GF_Filter *process;
CTXLoadPriv *git = gf_filter_get_udta(process);
const GF_PropertyValue *proc;
git->base_stream_id = proc ? proc->value.uint : -1;
git->pck_time = -1;
char str[] = ""Constant"";
int c, cnt;
int val;
struct timeval t1, t2;
int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
register ssize_t
    i_2;
QuantizationTable
    *table_10;
ssize_t
    j;
XMLTreeInfo
    *description_5,
    *levels_4,
    *quantization_tables_9,
    *table_iterator_1;
for (j=i_2; j < 64; j++)
    table_10->levels_4[j]=table_10->levels_4[j-1];
int64_t alpha;
int total = 0;
print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
QuantizationTable
    *table;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
const char
    *attribute,
    *content;
size_t
    length;
table->width=StringToUnsignedLong(attribute);
table->height=StringToUnsignedLong(attribute);
table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
length=(size_t) table->width*table->height;
table->levels=(unsigned int *) AcquireQuantumMemory(length,
    sizeof(*table->levels));
while (strlen(str) > 5) {
    POWERPC_TBL_DECLARE(altivec_avg_pixels16_num, 1);
strcpy(str, ""a"");
}
#ifdef ALTIVEC_USE_REFERENCE_C_CODE
    int i;
POWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);
    for(i=0; i<h; i++) {
      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));
      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));
      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));
      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));
      pixels+=line_size;
      block +=line_size;
    }
POWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);
#else  
    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;
    register vector unsigned char perm = vec_lvsl(0, pixels);
    int i;
POWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);
    for(i=0; i<h; i++) {
      pixelsv1 = vec_ld(0, (unsigned char*)pixels);
      pixelsv2 = vec_ld(16, (unsigned char*)pixels);
      blockv = vec_ld(0, block);
      pixelsv = vec_perm(pixelsv1, pixelsv2, perm);
      blockv = vec_avg(blockv,pixelsv);
      vec_st(blockv, 0, (unsigned char*)block);
      pixels+=line_size;
      block +=line_size;
    }
POWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);
#endif  
}",0,1,158,1.96,Insert
1623,"static void blk_send_response_all(struct XenBlkDev *blkdev)
{
    struct ioreq *ioreq;
    int send_notify = 0;
    while (!LIST_EMPTY(&blkdev->finished)) {
        ioreq = LIST_FIRST(&blkdev->finished);
	send_notify += blk_send_response_one(ioreq);
	ioreq_release(ioreq);
    }
    if (send_notify)
	xen_be_send_notify(&blkdev->xendev);
}","static void blk_send_response_all(struct XenBlkDev *blkdev)
{
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev_4 = &serial->serial->dev_4->dev_4;
    if (status)
    		dev_dbg(dev_4, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev_4, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    int ret = -EIO;
    ret = 0;
    struct ioreq *ioreq;
    u8 * Datapp;
    MachineState *machine;
    char *filename_5;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    filename_5 = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename_5 = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    struct ath6kl_vif *vif;
    char *filename;
    if (!filename) {
            error_report(""Could not find LPAR rtas '%s'"", ""spapr-rtas.bin"");
            exit(1);
    }
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    int send_notify = 0;
    while (!LIST_EMPTY(&blkdev->finished)) {
        char str[] = ""Constant"";
        DictionaryValue* strings;
        strings->SetString(""proceed"",
              l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));
        if (strlen(str) > 0) {
            ioreq = LIST_FIRST(&blkdev->finished);
        }
	send_notify += blk_send_response_one(ioreq);
	ioreq_release(ioreq);
    }
    if (send_notify)
	xen_be_send_notify(&blkdev->xendev);
}",0,1,162,0.89,Insert
1628,"static void save_native_fp_fsave(CPUState *env)
{
    int fptag, i, j;
    uint16_t fpuc;
    struct fpstate fp1, *fp = &fp1;
    asm volatile (""fsave %0"" : : ""m"" (*fp));
    env->fpuc = fp->fpuc;
    env->fpstt = (fp->fpus >> 11) & 7;
    env->fpus = fp->fpus & ~0x3800;
    fptag = fp->fptag;
    for(i = 0;i < 8; i++) {
        env->fptags[i] = ((fptag & 3) == 3);
        fptag >>= 2;
    }
    j = env->fpstt;
    for(i = 0;i < 8; i++) {
        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
        j = (j + 1) & 7;
    }
    fpuc = 0x037f | (env->fpuc & (3 << 10));
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));
}","static void save_native_fp_fsave(CPUState *env)
{
    int fptag, i, j;
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    esi->card_status &= ~CARD_STATUS_B;
    sd_set_status(esi);
    esi->current_cmd = err->cmd;
    uint16_t fpuc;
    struct fpstate fp1, *fp = &fp1;
    asm volatile (""fsave %0"" : : ""m"" (*fp));
    env->fpuc = fp->fpuc;
    env->fpstt = (fp->fpus >> 11) & 7;
    env->fpus = fp->fpus & ~0x3800;
    fptag = fp->fptag;
    if (clean == nullptr)
        strecleanonnection->FindStream(uri);
        AVPacket * pk;
        struct fp_5 *fp_5;
        int pet;
        pet = seq_open(fp_5, &show_traces_seq_ops);
        AVFormatContext *s;
        const int stream_index =  pk->stream_index;
        int size               =  pk->size;
        AVIOContext *b     = s->b;
        avio_write(b,  pk->data, size);
    for(i = 0;i < 8; i++) {
        env->fptags[i] = ((fptag & 3) == 3);
        fptag >>= 2;
    }
    j = env->fpstt;
    for(i = 0;i < 8; i++) {
        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
        j = (j + 1) & 7;
    }
    fpuc = 0x037f | (env->fpuc & (3 << 10));
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));
}",0,1,127,1.22,Insert
1631,,,,,,,
1633,,,,,,,
1635,,,,,,,
1636,"static void vmxnet3_update_features(VMXNET3State *s)
{
    uint32_t guest_features;
    int rxcso_supported;
    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,
                                               devRead.misc.uptFeatures);
    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);
    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);
    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);
    VMW_CFPRN(""Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d"",
              s->lro_supported, rxcso_supported,
              s->rx_vlan_stripping);
    if (s->peer_has_vhdr) {
        qemu_peer_set_offload(qemu_get_queue(s->nic),
                        rxcso_supported,
                        s->lro_supported,
                        s->lro_supported,
                        0,
                        0);
    }
}","static void vmxnet3_update_features(VMXNET3State *s)
{
    uint32_t guest_features;
    int a = 2;
    int b = 3;
    while (a < b) {
        int rxcso_supported;
        b = a;
    }
    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,
                                               devRead.misc.uptFeatures);
                                               int i, qa;
                                               qa = libusb_init(&ctx);
    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);
    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);
    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);
    VMW_CFPRN(""Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d"",
              s->lro_supported, rxcso_supported,
              s->rx_vlan_stripping);
    if (s->peer_has_vhdr) {
        qemu_peer_set_offload(qemu_get_queue(s->nic),
                        rxcso_supported,
                        s->lro_supported,
                        s->lro_supported,
                        0,
                        0);
    }
}",0,1,16,0.69,Insert
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);
    return virtio_exit_pci(pci_dev);
}","static int virtio_blk_exit_pci(PCIDevice *pci_dev)
{
    char str[] = ""Constant"";
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    while (strlen(str) > 5) {
        VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    strcpy(str, ""a"");
    }
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);
    return virtio_exit_pci(pci_dev);
}",0,1,10,0.24,Insert
1639,"static void uhci_async_complete(USBPacket *packet, void *opaque)
{
    UHCIState *s = opaque;
    UHCIAsync *async = (UHCIAsync *) packet;
    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);
    async->done = 1;
    uhci_process_frame(s);
}","static void uhci_async_complete(USBPacket *packet, void *opaque)
{
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        UHCIState *s = opaque;
    }
    UHCIAsync *async = (UHCIAsync *) packet;
    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);
    async->done = 1;
    uhci_process_frame(s);
}",0,1,17,0.39,Insert
1640,"static void gen_neon_unzip(int reg, int q, int tmp, int size)
{
    int n;
    TCGv t0, t1;
    for (n = 0; n < q + 1; n += 2) {
        t0 = neon_load_reg(reg, n);
        t1 = neon_load_reg(reg, n + 1);
        switch (size) {
        case 0: gen_neon_unzip_u8(t0, t1); break;
        case 1: gen_neon_zip_u16(t0, t1); break;  
        case 2:  ; break;
        default: abort();
        }
        neon_store_scratch(tmp + n, t0);
        neon_store_scratch(tmp + n + 1, t1);
    }
}","static void gen_neon_unzip(int reg, int q, int tmp, int size)
{
    int n;
    TCGv t0, t1;
    for (n = 0; n < q + 1; n += 2) {
        t0 = neon_load_reg(reg, n);
        int a = 2;
        int b = 3;
        while (a < b) {
            t1 = neon_load_reg(reg, n + 1);
            b = a;
        }
        switch (size) {
        case 0: gen_neon_unzip_u8(t0, t1); break;
        case 1: gen_neon_zip_u16(t0, t1); break;  
        case 2:  ; break;
        default: abort();
        }
        neon_store_scratch(tmp + n, t0);
        neon_store_scratch(tmp + n + 1, t1);
    }
}",0,1,9,0.12,Replace
1641,"static void parse_numa_distance(NumaDistOptions *dist, Error **errp)
{
    uint16_t src = dist->src;
    uint16_t dst = dist->dst;
    uint8_t val = dist->val;
    if (src >= MAX_NODES || dst >= MAX_NODES) {
        error_setg(errp,
                   ""Invalid node %"" PRIu16
                   "", max possible could be %"" PRIu16,
                   MAX(src, dst), MAX_NODES);
        return;
    }
    if (!numa_info[src].present || !numa_info[dst].present) {
        error_setg(errp, ""Source/Destination NUMA node is missing. ""
                   ""Please use '-numa node' option to declare it first."");
        return;
    }
    if (val < NUMA_DISTANCE_MIN) {
        error_setg(errp, ""NUMA distance (%"" PRIu8 "") is invalid, ""
                   ""it shouldn't be less than %d."",
                   val, NUMA_DISTANCE_MIN);
        return;
    }
    if (src == dst && val != NUMA_DISTANCE_MIN) {
        error_setg(errp, ""Local distance of node %d should be %d."",
                   src, NUMA_DISTANCE_MIN);
        return;
    }
    numa_info[src].distance[dst] = val;
    have_numa_distance = true;
}","static void parse_numa_distance(NumaDistOptions *dist, Error **errp)
{
    uint16_t src = dist->src;
    uint16_t dst = dist->dst;
    uint8_t val = dist->val;
    if (src >= MAX_NODES || dst >= MAX_NODES) {
        error_setg(errp,
                   ""Invalid node %"" PRIu16
                   "", max possible could be %"" PRIu16,
                   MAX(src, dst), MAX_NODES);
                   Rocker *r;
                   DescInfo *info;
                   char *buf = desc_get_buf(info, true);
                   RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
                   char *buf = desc_get_buf(info, true);
                   PCIDevice *dev = PCI_DEVICE(r);
                   RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
                   uint32_t pport;
                   rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
                   pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        int a = 70;
        int b = a;
        if(a*b>0){
            return;
        }
    }
    if (!numa_info[src].present || !numa_info[dst].present) {
        error_setg(errp, ""Source/Destination NUMA node is missing. ""
                   ""Please use '-numa node' option to declare it first."");
        return;
    }
    if (val < NUMA_DISTANCE_MIN) {
        error_setg(errp, ""NUMA distance (%"" PRIu8 "") is invalid, ""
                   ""it shouldn't be less than %d."",
                   val, NUMA_DISTANCE_MIN);
        return;
    }
    if (src == dst && val != NUMA_DISTANCE_MIN) {
        error_setg(errp, ""Local distance of node %d should be %d."",
                   src, NUMA_DISTANCE_MIN);
        return;
    }
    numa_info[src].distance[dst] = val;
    have_numa_distance = true;
}",0,1,19,0.88,Insert
1642,,,,,,,
1643,"static int compare_int64(const void *a, const void *b)
{
    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;
    return va < vb ? -1 : va > vb ? +1 : 0;
}","static int compare_int64(const void *a, const void *b)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int64_t va = *(int64_t *)a, vb = *(int64_t *)b;
    }
    struct super_block *sb = inode->i_sb;
    int bl, err;
    struct hfs_find_data fd;
    err = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);
    err = hfs_brec_find(&fd);
    return va < vb ? -1 : va > vb ? +1 : 0;
}",1,0,5,0.34,Insert
1644,,,,,,,
1645,"static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,
                          uint8_t **bufptr, DumpState *s)
{
    GuestPhysBlock *block = *blockptr;
    hwaddr addr;
    uint8_t *buf;
    if (!block) {
        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);
        *blockptr = block;
        assert(block->target_start % s->page_size == 0);
        assert(block->target_end % s->page_size == 0);
        *pfnptr = paddr_to_pfn(block->target_start);
        if (bufptr) {
            *bufptr = block->host_addr;
        }
        return true;
    }
    *pfnptr = *pfnptr + 1;
    addr = pfn_to_paddr(*pfnptr);
    if ((addr >= block->target_start) &&
        (addr + s->page_size <= block->target_end)) {
        buf = block->host_addr + (addr - block->target_start);
    } else {
        block = QTAILQ_NEXT(block, next);
        *blockptr = block;
        if (!block) {
            return false;
        }
        assert(block->target_start % s->page_size == 0);
        assert(block->target_end % s->page_size == 0);
        *pfnptr = paddr_to_pfn(block->target_start);
        buf = block->host_addr;
    }
    if (bufptr) {
        *bufptr = buf;
    }
    return true;
}","static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,
                          uint8_t **bufptr, DumpState *s)
{
    GuestPhysBlock *block = *blockptr;
    hwaddr addr;
    uint8_t *buf;
    if (!block) {
        int a = 2;
        int b = 3;
        while (a != b) {
            block = QTAILQ_FIRST(&s->guest_phys_blocks.head);
            b = a;
        }
        *blockptr = block;
        assert(block->target_start % s->page_size == 0);
        assert(block->target_end % s->page_size == 0);
        *pfnptr = paddr_to_pfn(block->target_start);
        if (bufptr) {
            *bufptr = block->host_addr;
        }
        return true;
    }
    *pfnptr = *pfnptr + 1;
    addr = pfn_to_paddr(*pfnptr);
    if ((addr >= block->target_start) &&
        (addr + s->page_size <= block->target_end)) {
        buf = block->host_addr + (addr - block->target_start);
    } else {
        block = QTAILQ_NEXT(block, next);
        *blockptr = block;
        if (!block) {
            return false;
        }
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        assert(block->target_start % s->page_size == 0);
        assert(block->target_end % s->page_size == 0);
        *pfnptr = paddr_to_pfn(block->target_start);
        buf = block->host_addr;
    }
    if (bufptr) {
        *bufptr = buf;
    }
    return true;
}",0,1,49,1.27,Insert
1647,"int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)
{
    const USBDesc *desc = dev->info->usb_desc;
    uint8_t buf[256];
    uint8_t type = value >> 8;
    uint8_t index = value & 0xff;
    int ret = -1;
    switch(type) {
    case USB_DT_DEVICE:
        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));
        trace_usb_desc_device(dev->addr, len, ret);
        break;
    case USB_DT_CONFIG:
        if (index < desc->full->bNumConfigurations) {
            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));
        }
        trace_usb_desc_config(dev->addr, index, len, ret);
        break;
    case USB_DT_STRING:
        ret = usb_desc_string(dev, index, buf, sizeof(buf));
        trace_usb_desc_string(dev->addr, index, len, ret);
        break;
    default:
        fprintf(stderr, ""%s: %d unknown type %d (len %zd)\n"", __FUNCTION__,
                dev->addr, type, len);
        break;
    }
    if (ret > 0) {
        if (ret > len) {
            ret = len;
        }
        memcpy(dest, buf, ret);
    }
    return ret;
}","int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)
{
    const USBDesc *desc = dev->info->usb_desc;
    uint8_t buf[256];
    uint8_t type = value >> 8;
    uint8_t index = value & 0xff;
    int ret = -1;
    switch(type) {
    case USB_DT_DEVICE:
        int a = 2;
        int b = 3;
        while (a < b) {
            ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));
            b = a;
        }
        trace_usb_desc_device(dev->addr, len, ret);
        break;
    case USB_DT_CONFIG:
        double f;
        f = get_float64 (buffer, &error);
        if (index < desc->full->bNumConfigurations) {
            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));
        }
        trace_usb_desc_config(dev->addr, index, len, ret);
        break;
    case USB_DT_STRING:
        ret = usb_desc_string(dev, index, buf, sizeof(buf));
        trace_usb_desc_string(dev->addr, index, len, ret);
        break;
    default:
        fprintf(stderr, ""%s: %d unknown type %d (len %zd)\n"", __FUNCTION__,
                dev->addr, type, len);
                QEMUMachineInitArgs *args;
                char *filename;
                ram_addr_t ram_size = args->ram_size;
                long load_limit, rtas_limit, fw_size;
                spapr->next_irq = XICS_IRQ_BASE;
                spapr->ram_limit = ram_size;
                filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
                spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                           rtas_limit - spapr->rtas_addr);
                spapr_events_init(spapr);
        break;
    }
    if (ret > 0) {
        if (ret > len) {
            ret = len;
        }
        memcpy(dest, buf, ret);
    }
    return ret;
}",0,1,72,1.56,Insert
1648,"static void connex_init(MachineState *machine)
{
    PXA2xxState *cpu;
    DriveInfo *dinfo;
    int be;
    MemoryRegion *address_space_mem = get_system_memory();
    uint32_t connex_rom = 0x01000000;
    uint32_t connex_ram = 0x04000000;
    cpu = pxa255_init(address_space_mem, connex_ram);
    dinfo = drive_get(IF_PFLASH, 0, 0);
    if (!dinfo && !qtest_enabled()) {
        fprintf(stderr, ""A flash image must be given with the ""
                ""'pflash' parameter\n"");
        exit(1);
    }
#ifdef TARGET_WORDS_BIGENDIAN
    be = 1;
#else
    be = 0;
#endif
    if (!pflash_cfi01_register(0x00000000, NULL, ""connext.rom"", connex_rom,
                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                               sector_len, connex_rom / sector_len,
                               2, 0, 0, 0, 0, be)) {
        fprintf(stderr, ""qemu: Error registering flash memory.\n"");
        exit(1);
    }
    smc91c111_init(&nd_table[0], 0x04000300,
                    qdev_get_gpio_in(cpu->gpio, 36));
}","static void connex_init(MachineState *machine)
{
    PXA2xxState *cpu;
    DriveInfo *dinfo;
    int be;
    MemoryRegion *address_space_mem = get_system_memory();
    uint32_t connex_rom = 0x01000000;
    uint32_t connex_ram = 0x04000000;
    cpu = pxa255_init(address_space_mem, connex_ram);
    dinfo = drive_get(IF_PFLASH, 0, 0);
    if (!dinfo && !qtest_enabled()) {
        fprintf(stderr, ""A flash image must be given with the ""
                ""'pflash' parameter\n"");
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            exit(1);
        strcpy(str, ""a"");
        }
    }
#ifdef TARGET_WORDS_BIGENDIAN
    be = 1;
#else
    be = 0;
#endif
    if (!pflash_cfi01_register(0x00000000, NULL, ""connext.rom"", connex_rom,
                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                               sector_len, connex_rom / sector_len,
                               2, 0, 0, 0, 0, be)) {
        int lang, rar;
        VirtioCcwDevice *dev;
        Image *image;
        MagickOffsetType
            offset;
        offset=TellBlob(image);
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        mysql_close(mysql___global);
        fprintf(stderr, ""qemu: Error registering flash memory.\n"");
        exit(1);
    }
    smc91c111_init(&nd_table[0], 0x04000300,
                    qdev_get_gpio_in(cpu->gpio, 36));
}",0,1,93,1.03,Insert
1650,"void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
                   uint8_t *iv, int decrypt)
{
    int i;
    while (count > 0) {
        if (decrypt) {
            xtea_crypt_ecb(ctx, dst, src, decrypt);
            if (iv) {
                for (i = 0; i < 8; i++)
                    dst[i] = dst[i] ^ iv[i];
                memcpy(iv, src, 8);
            }
        } else {
            if (iv) {
                for (i = 0; i < 8; i++)
                    dst[i] = src[i] ^ iv[i];
                xtea_crypt_ecb(ctx, dst, dst, decrypt);
                memcpy(iv, dst, 8);
            } else {
                xtea_crypt_ecb(ctx, dst, src, decrypt);
            }
        }
        src   += 8;
        dst   += 8;
        count -= 8;
    }
}","void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
                   uint8_t *iv, int decrypt)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int i;
    }
    while (count > 0) {
        if (decrypt) {
            xtea_crypt_ecb(ctx, dst, src, decrypt);
            if (iv) {
                for (i = 0; i < 8; i++)
                    dst[i] = dst[i] ^ iv[i];
                memcpy(iv, src, 8);
            }
        } else {
            if (iv) {
                for (i = 0; i < 8; i++)
                    dst[i] = src[i] ^ iv[i];
                xtea_crypt_ecb(ctx, dst, dst, decrypt);
                memcpy(iv, dst, 8);
            } else {
                xtea_crypt_ecb(ctx, dst, src, decrypt);
            }
        }
        src   += 8;
        dst   += 8;
        count -= 8;
    }
}",0,1,2,0.12,Replace
1651,"static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)
{
    AVRational time_base = {1, 1000};
    uint32_t start, end;
    AVChapter *chapter;
    uint8_t *dst = NULL;
    int taglen;
    char tag[5];
    decode_str(s, pb, 0, &dst, &len);
    if (len < 16)
        return;
    start = avio_rb32(pb);
    end   = avio_rb32(pb);
    avio_skip(pb, 8);
    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);
    if (!chapter) {
        av_free(dst);
        return;
    }
    len -= 16;
    while (len > 10) {
        avio_read(pb, tag, 4);
        tag[4] = 0;
        taglen = avio_rb32(pb);
        avio_skip(pb, 2);
        len -= 10;
        if (taglen < 0 || taglen > len) {
            av_free(dst);
            return;
        }
        if (tag[0] == 'T')
            read_ttag(s, pb, taglen, &chapter->metadata, tag);
        else
            avio_skip(pb, taglen);
        len -= taglen;
    }
    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);
    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);
    av_free(dst);
}","static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)
{
    AVRational time_base = {1, 1000};
    uint32_t start, end;
    AVChapter *chapter;
    uint8_t *dst = NULL;
    int taglen;
    char tag[5];
    decode_str(s, pb, 0, &dst, &len);
    if (len < 16)
        return;
    start = avio_rb32(pb);
    end   = avio_rb32(pb);
    avio_skip(pb, 8);
    int a = 2;
    int b = 2;
    while (a == b) {
        chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);
        b += 1;
    }
    if (!chapter) {
        av_free(dst);
        return;
    }
    len -= 16;
    while (len > 10) {
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        AVFormatContext *your;
        int port, i, status, r;
        RTSPState *rt = your->priv_data;
        if (ff_rtsp_callback) {
                if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                     NULL, 0, rt->last_reply) < 0) {
                    r = AVERROR_INVALIDDATA;
                    goto fail;
                }
        }
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        avio_read(pb, tag, 4);
        tag[4] = 0;
        taglen = avio_rb32(pb);
        avio_skip(pb, 2);
        len -= 10;
        if (taglen < 0 || taglen > len) {
            av_free(dst);
            return;
        }
        if (tag[0] == 'T')
            read_ttag(s, pb, taglen, &chapter->metadata, tag);
        else
            avio_skip(pb, taglen);
        len -= taglen;
    }
    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);
    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);
    av_free(dst);
}",0,1,71,1.62,Insert
1652,,,,,,,
1653,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,
                                 unsigned npfd, int64_t timeout)
{
    if (!ctx->epoll_available) {
        return false;
    }
    if (aio_epoll_enabled(ctx)) {
        return true;
    }
    if (npfd >= EPOLL_ENABLE_THRESHOLD) {
        if (aio_epoll_try_enable(ctx)) {
            return true;
        } else {
            aio_epoll_disable(ctx);
        }
    }
    return false;
}","static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,
                                 unsigned npfd, int64_t timeout)
{
    int nb_oargs;
    u8 * Datapp;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    int nb_iargs;
    const TCGArg * const args;
    brcmf_dbg(TRACE, ""enter: %s type %d
    "", name, length);
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    if (!ctx->epoll_available) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return false;
        }
    }
    if (aio_epoll_enabled(ctx)) {
        return true;
    }
    if (npfd >= EPOLL_ENABLE_THRESHOLD) {
        if (aio_epoll_try_enable(ctx)) {
            return true;
        } else {
            aio_epoll_disable(ctx);
        }
    }
    return false;
}",0,1,83,0.66,Insert
1654,"static void aarch64_cpu_register_types(void)
{
    int i;
    type_register_static(&aarch64_cpu_type_info);
    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {
        aarch64_cpu_register(&aarch64_cpus[i]);
    }
}","static void aarch64_cpu_register_types(void)
{
    int i;
    int a = 2;
    int b = 3;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    while (a < b) {
        type_register_static(&aarch64_cpu_type_info);
        b = a;
    }
    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {
        aarch64_cpu_register(&aarch64_cpus[i]);
    }
}",0,1,44,0.51,Insert
1655,"static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,
                               uint64_t value, unsigned size)
{
    musicpal_lcd_state *s = opaque;
    switch (offset) {
    case MP_LCD_IRQCTRL:
        s->irqctrl = value;
        break;
    case MP_LCD_SPICTRL:
        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {
            s->mode = value;
        } else {
            s->mode = MP_LCD_SPI_INVALID;
        }
        break;
    case MP_LCD_INST:
        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {
            s->page = value - MP_LCD_INST_SETPAGE0;
            s->page_off = 0;
        }
        break;
    case MP_LCD_DATA:
        if (s->mode == MP_LCD_SPI_CMD) {
            if (value >= MP_LCD_INST_SETPAGE0 &&
                value <= MP_LCD_INST_SETPAGE7) {
                s->page = value - MP_LCD_INST_SETPAGE0;
                s->page_off = 0;
            }
        } else if (s->mode == MP_LCD_SPI_DATA) {
            s->video_ram[s->page*128 + s->page_off] = value;
            s->page_off = (s->page_off + 1) & 127;
        }
        break;
    }
}","static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,
                               uint64_t value, unsigned size)
{
    musicpal_lcd_state *s = opaque;
    switch (offset) {
    case MP_LCD_IRQCTRL:
        int a = 2;
        int b = 2;
        if (a == b) {
            s->irqctrl = value;
        }
        break;
    case MP_LCD_SPICTRL:
        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {
            s->mode = value;
        } else {
            s->mode = MP_LCD_SPI_INVALID;
        }
        break;
    case MP_LCD_INST:
        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {
            s->page = value - MP_LCD_INST_SETPAGE0;
            s->page_off = 0;
        }
        break;
    case MP_LCD_DATA:
        if (s->mode == MP_LCD_SPI_CMD) {
            if (value >= MP_LCD_INST_SETPAGE0 &&
            struct file *filp;
            fl_owner_t id;
            int nb_oargs;
            int nb_iargs;
            const TCGArg * const args;
            int rules, nb_regs, ini;
            rules = args[nb_oargs + nb_iargs + 1];
            dnotify_flush(filp, id);
            locks_remove_posix(filp, id);
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            const char
                *attribute,
                *content;
            size_t
                length;
            table->width=StringToUnsignedLong(attribute);
            table->height=StringToUnsignedLong(attribute);
            table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
            length=(size_t) table->width*table->height;
            table->levels=(unsigned int *) AcquireQuantumMemory(length,
                sizeof(*table->levels));
                value <= MP_LCD_INST_SETPAGE7) {
                VirtioCcwDevice *dev;
                Error *err = NULL;
                VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
                DeviceState *parent = DEVICE(dev);
                if (k->realize) {
                        k->realize(dev, &err);
                }
                s->page = value - MP_LCD_INST_SETPAGE0;
                s->page_off = 0;
            }
        } else if (s->mode == MP_LCD_SPI_DATA) {
            s->video_ram[s->page*128 + s->page_off] = value;
            s->page_off = (s->page_off + 1) & 127;
        }
        break;
    }
}",0,1,118,1.5,Insert
1656,"static inline uint32_t nvic_gprio_mask(NVICState *s)
{
    return ~0U << (s->prigroup + 1);
}","static inline uint32_t nvic_gprio_mask(NVICState *s)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return ~0U << (s->prigroup + 1);
        SysBusDevice *b;
        if (i) {
                sysbus_mmio_map(b, 0, i);
        }
    }
}",0,1,9,0.2,Insert
1657,,,,,,,
1659,"void HELPER(wsr_ibreakenable)(uint32_t v)
{
    uint32_t change = v ^ env->sregs[IBREAKENABLE];
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        if (change & (1 << i)) {
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
}","void HELPER(wsr_ibreakenable)(uint32_t v)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        uint32_t change = v ^ env->sregs[IBREAKENABLE];
    strcpy(str, ""a"");
    }
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        if (change & (1 << i)) {
            QEMUMachineInitArgs *args;
            char *filename;
            ram_addr_t ram_size = args->ram_size;
            long load_limit, rtas_limit, fw_size;
            spapr->next_irq = XICS_IRQ_BASE;
            spapr->ram_limit = ram_size;
            filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
            spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                       rtas_limit - spapr->rtas_addr);
            spapr_events_init(spapr);
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
}",0,1,31,0.68,Insert
1660,"static void openrisc_cpu_class_init(ObjectClass *oc, void *data)
{
    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);
    CPUClass *cc = CPU_CLASS(occ);
    DeviceClass *dc = DEVICE_CLASS(oc);
    occ->parent_realize = dc->realize;
    dc->realize = openrisc_cpu_realizefn;
    occ->parent_reset = cc->reset;
    cc->reset = openrisc_cpu_reset;
    cc->class_by_name = openrisc_cpu_class_by_name;
    cc->has_work = openrisc_cpu_has_work;
    cc->do_interrupt = openrisc_cpu_do_interrupt;
    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;
    cc->dump_state = openrisc_cpu_dump_state;
    cc->set_pc = openrisc_cpu_set_pc;
    cc->gdb_read_register = openrisc_cpu_gdb_read_register;
    cc->gdb_write_register = openrisc_cpu_gdb_write_register;
#ifdef CONFIG_USER_ONLY
    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;
#else
    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;
    dc->vmsd = &vmstate_openrisc_cpu;
#endif
    cc->gdb_num_core_regs = 32 + 3;
    dc->cannot_destroy_with_object_finalize_yet = true;
}","static void openrisc_cpu_class_init(ObjectClass *oc, void *data)
{
    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);
    CPUClass *cc = CPU_CLASS(occ);
    DeviceClass *dc = DEVICE_CLASS(oc);
    int a = 2;
    int b = 2;
    while (a == b) {
        occ->parent_realize = dc->realize;
        b += 1;
    }
    dc->realize = openrisc_cpu_realizefn;
    occ->parent_reset = cc->reset;
    cc->reset = openrisc_cpu_reset;
    cc->class_by_name = openrisc_cpu_class_by_name;
    cc->has_work = openrisc_cpu_has_work;
    cc->do_interrupt = openrisc_cpu_do_interrupt;
    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;
    struct ucma_multicast *mc;
    mc->ctx = ctx;
    list_add_tail(&mc->list, &ctx->mc_list);
    cc->dump_state = openrisc_cpu_dump_state;
    cc->set_pc = openrisc_cpu_set_pc;
    cc->gdb_read_register = openrisc_cpu_gdb_read_register;
    cc->gdb_write_register = openrisc_cpu_gdb_write_register;
    void __user *arg;
    int n = 0, size, fee;
    int n = 0, size, fee;
    struct rfcomm_dev_info *di;
    u16 dev_num;
    int n = 0, size, fee;
    struct rfcomm_dev_list_req *dl;
    size = sizeof(*dl) + dev_num * sizeof(*di);
    dl = kmalloc(size, GFP_KERNEL);
    size = sizeof(*dl) + n * sizeof(*di);
    fee = copy_to_user(arg, dl, size);
#ifdef CONFIG_USER_ONLY
    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;
#else
    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;
    dc->vmsd = &vmstate_openrisc_cpu;
#endif
    cc->gdb_num_core_regs = 32 + 3;
    dc->cannot_destroy_with_object_finalize_yet = true;
}",1,0,74,1.07,Insert
1661,,,,,,,
1662,,,,,,,
1663,,,,,,,
1666,"int xen_be_send_notify(struct XenDevice *xendev)
{
    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
}","int xen_be_send_notify(struct XenDevice *xendev)
{
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    int a = 12;
    int b = a;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if(a*b>0){
        return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
    }
}",0,1,43,0.39,Insert
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)
{
    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {
        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&
            timestamp < st->pts_wrap_reference)
            return timestamp + (1ULL<<st->pts_wrap_bits);
        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&
            timestamp >= st->pts_wrap_reference)
            return timestamp - (1ULL<<st->pts_wrap_bits);
    }
    return timestamp;
}","static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)
{
    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {
        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&
            timestamp < st->pts_wrap_reference)
            int a = 20;
            int b = a;
            if(a*b>0){
                return timestamp + (1ULL<<st->pts_wrap_bits);
            }
        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&
            timestamp >= st->pts_wrap_reference)
            return timestamp - (1ULL<<st->pts_wrap_bits);
    }
    return timestamp;
}",0,1,3,0.08,Replace
1669,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,
                                  uint32_t val)
{
    MiscState *s = opaque;
    uint32_t saddr;
    saddr = addr & LED_MAXADDR;
    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,
                 val);
    switch (saddr) {
    case 0:
        s->leds = val;
        break;
    default:
        break;
    }
}","static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,
                                  uint32_t val)
{
    VirtIOSCSIReq *req;
    struct ldb_context *ydm;
    const char *attr;
    struct ldb_context *ydm_9;
    const char *attr_2;
    const struct ldb_schema_attribute *a_5;
    a_5 = ldb_schema_attribute_by_name_1(ydm_9, attr_2);
    const struct ldb_schema_attribute *a_2;
    a_2 = ldb_schema_attribute_by_name(ydm, attr);
    VirtIOSCSI *sb;
    req->dev = sb;
    int a = 7;
    int b = a;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if(a*b>0){
        MiscState *s = opaque;
    }
    uint32_t saddr;
    saddr = addr & LED_MAXADDR;
    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,
                 val);
    switch (saddr) {
    case 0:
        s->leds = val;
        break;
    default:
        break;
    }
}",0,1,104,0.88,Insert
1671,"static void xlnx_ep108_machine_init(MachineClass *mc)
{
    mc->desc = ""Xilinx ZynqMP EP108 board"";
    mc->init = xlnx_ep108_init;
    mc->block_default_type = IF_IDE;
    mc->units_per_default_bus = 1;
    mc->ignore_memory_transaction_failures = true;
}","static void xlnx_ep108_machine_init(MachineClass *mc)
{
    mc->desc = ""Xilinx ZynqMP EP108 board"";
    int a = 2;
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    int b = 2;
    MpegEncContext *s;
    if (s->current_picture.reference)
            ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
    while (a == b) {
        mc->init = xlnx_ep108_init;
        b += 1;
    }
    mc->block_default_type = IF_IDE;
    mc->units_per_default_bus = 1;
    mc->ignore_memory_transaction_failures = true;
}",0,1,43,0.49,Insert
1672,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,
                             TCGReg rd, TCGReg rn, uint64_t limm)
{
    unsigned h, l, r, c;
    assert(is_limm(limm));
    h = clz64(limm);
    l = ctz64(limm);
    if (l == 0) {
        r = 0;                   
        c = ctz64(~limm) - 1;
        if (h == 0) {
            r = clz64(~limm);    
            c += r;
        }
    } else {
        r = 64 - l;              
        c = r - h - 1;
    }
    if (ext == TCG_TYPE_I32) {
        r &= 31;
        c &= 31;
    }
    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);
}","static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,
                             TCGReg rd, TCGReg rn, uint64_t limm)
{
    hwaddr val;
    CPUAlphaState *viron = &cpu->viron;
    viron->trap_arg0 = val;
    unsigned h, l, r, c;
    assert(is_limm(limm));
    h = clz64(limm);
    l = ctz64(limm);
    if (l == 0) {
        r = 0;                   
        c = ctz64(~limm) - 1;
        if (h == 0) {
            r = clz64(~limm);    
            c += r;
        }
    } else {
        r = 64 - l;              
        c = r - h - 1;
    }
    if (ext == TCG_TYPE_I32) {
        r &= 31;
        int a = 71;
        int b = a;
        if(a*b>0){
            c &= 31;
        }
    }
    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);
}",0,1,53,1.25,Insert
1675,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,
                                            const char *json_string)
{
    return visitor_input_test_init_internal(data, json_string, NULL);
}","static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,
                                            const char *json_string)
{
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    char str[] = ""Constant"";
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    item->type = QEMU_INPUT_QUEUE_SYNC;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (strlen(str) > 0) {
        return visitor_input_test_init_internal(data, json_string, NULL);
    }
}",0,1,69,0.5,Insert
1676,"static void do_info_version(Monitor *mon)
{
    monitor_printf(mon, ""%s\n"", QEMU_VERSION);
}","static void do_info_version(Monitor *mon)
{
    int a = 61;
    int b = a;
    struct socket *sock;
    int protocol;
    struct object *object;
    struct sock *ock;
    struct sock *ock;
    ock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);
    if(a*b>0){
        monitor_printf(mon, ""%s\n"", QEMU_VERSION);
    }
}",0,1,3,0.24,Insert
1677,,,,,,,
1684,,,,,,,
1685,"static void lsi53c895a_register_devices(void)
{
    type_register_static(&lsi_info);
    type_register_static_alias(&lsi_info, ""lsi"");
}","static void lsi53c895a_register_devices(void)
{
    int a = 2;
    int b = 3;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_10;
    a_10 = ldb_schema_attribute_by_name(ydm, attr);
    while (a != b) {
        type_register_static(&lsi_info);
        b = a;
    }
    type_register_static_alias(&lsi_info, ""lsi"");
}",0,1,5,0.27,Insert
1686,,,,,,,
1687,,,,,,,
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)
{
    int ch, bw_code;
    if (cutoff) {
        int fbw_coeffs;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->lfe_on)
        s->nb_coefs[s->lfe_channel] = 7;  
}","static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)
{
    int ch, bw_code;
    if (cutoff) {
        APEContext *ctx;
        int32_t predictionA, currentA, A, sign;
        APEPredictor *pb = &ctx->predictor;
        currentA = pb->lastA[0];
        pb->lastA[0] = currentA;
        int fbw_coeffs;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        int a = 21;
        int b = a;
        if(a*b>0){
            bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);
        }
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->lfe_on)
        s->nb_coefs[s->lfe_channel] = 7;  
}",0,1,21,0.79,Insert
1690,"static void xtensa_kc705_init(MachineState *machine)
{
    static const LxBoardDesc kc705_board = {
        .flash_base = 0xf0000000,
        .flash_size = 0x08000000,
        .flash_boot_base = 0x06000000,
        .flash_sector_size = 0x20000,
        .sram_size = 0x2000000,
    };
    lx_init(&kc705_board, machine);
}","static void xtensa_kc705_init(MachineState *machine)
{
    static const LxBoardDesc kc705_board = {
        .flash_base = 0xf0000000,
        .flash_size = 0x08000000,
        .flash_boot_base = 0x06000000,
        .flash_sector_size = 0x20000,
        .sram_size = 0x2000000,
    };
    char str[] = ""Constant"";
    RAMBlock *news_work;
    news_work = g_malloc0(sizeof(*news_work));
    news_work->err = err;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    news_work->realized = realized;
    news_work->used_length = size;
    news_work->max_length = maxlennumber;
    while (strlen(str) > 5) {
        lx_init(&kc705_board, machine);
    strcpy(str, ""a"");
    }
}",0,1,61,0.52,Insert
1691,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
                               unsigned int len)
{
    unsigned int offset;
    int i;
    offset = 0;
    for (i = 0; i < elem->in_num; i++) {
        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,
                                  elem->in_sg[i].iov_len,
                                  1, size);
        offset += size;
    }
    for (i = 0; i < elem->out_num; i++)
        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
                                  elem->out_sg[i].iov_len,
                                  0, elem->out_sg[i].iov_len);
}","static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
                               unsigned int len)
{
    int diff;
    diff = -1;
    unsigned int offset;
    MpegEncContext *ses;
    MotionEstContext * const k= &ses->me;
    MotionEstContext * const k= &ses->me;
    GOutputStream *os;
    GInputStream *isa;
    test_common_bounds_server(isa, os);
    k->hpel_avg= ses->dsp.avg_pixels_tab;
    char str[] = ""Constant"";
    struct irda_sock *data;
    discinfo_t *discovery;
    GF_BitStream *bs_3;
    GF_Box *s_10;
    FilePartitionBox *inter_3 = (FilePartitionBox *)s_10;
    inter_3->nb_entries = gf_bs_read_int_3(bs_3, inter_3->version ? 32 : 16);
    ISOM_DECREASE_SIZE_7(inter_3, inter_3->nb_entries * 6 );
    GF_SAFE_ALLOC_N_4(inter_3->entries, inter_3->nb_entries, FilePartitionEntry_4);
    int	code;
    discovery = irlmp_get_discoveries(&code, data->mask.word,
    					    data->nslots);
    					    char **names;
    					    char *p;
    					    char *ea_namelist = smallbuf;
    					    size_t num_names;
    					    for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen_10(p)+1) {
    					    		names[num_names++] = p;
    					    }
    					    GF_BitStream *bs_5;
    					    GF_Box *s;
    					    FilePartitionBox *inter = (FilePartitionBox *)s;
    					    inter->nb_entries = gf_bs_read_int(bs_5, inter->version ? 32 : 16);
    					    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    					    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    while (strlen(str) > 5) {
        BlockDriverState *bs;
        int max_discussion;
        max_discussion = bs->bl.max_discussion ?  bs->bl.max_discussion : MAX_DISCARD_DEFAULT;
        int i;
    strcpy(str, ""a"");
    }
    offset = 0;
    for (i = 0; i < elem->in_num; i++) {
        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,
                                  elem->in_sg[i].iov_len,
                                  1, size);
        offset += size;
    }
    for (i = 0; i < elem->out_num; i++)
        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
                                  elem->out_sg[i].iov_len,
                                  0, elem->out_sg[i].iov_len);
}",0,1,620,3.62,Insert
1693,"static inline void tcg_out_goto_label(TCGContext *s, int label_index)
{
    TCGLabel *l = &s->labels[label_index];
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);
        tcg_out_goto_noaddr(s);
    } else {
        tcg_out_goto(s, l->u.value_ptr);
    }
}","static inline void tcg_out_goto_label(TCGContext *s, int label_index)
{
    TCGLabel *l = &s->labels[label_index];
    if (!l->has_value) {
        int a = 2;
        int b = 3;
        if (a != b) {
            BlockdevOnError on_source_bug;
            VdpDecoderProfile profile;
            AVCodecContext *AVcas;
            VdpDecoderQueryCapabilities *decoder_query_caps;
            uint32_t max_level, max_mb, max_width, max_height;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpStatus status;
            VdpVideoSurfaceQueryCapabilities *surface_query_caps;
            VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
            uint32_t max_level, max_mb, max_width, max_height;
            uint32_t max_level, max_mb, max_width, max_height;
            void *pack;
            VdpBool supported;
            VdpChromaType type;
            status = hdtx->get_proc_address(hdtx->device,
                                                 VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                                 &pack);
            status = surface_query_caps(hdtx->device, type, &supported,
                                            &max_width, &max_height);
            status = hdtx->get_proc_address(hdtx->device,
                                                 VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                                 &pack);
            status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                            &max_mb, &max_width, &max_height);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                                 &pack);
            BlockdevOnError on_source_complete;
            const char *dev;
            enum MirrorSyncMode stage;
            int64_t peed;
            const char *data;
            int data;
            Error *localxer = NULL;
            BlockDriverState *source_vs;
            int64_t store;
            BlockDriverState *bes;
            bes = bdrv_find(dev);
            data = bes->open_flags | BDRV_O_RDWR;
            store = bdrv_getlength(bes);
            backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                             block_job_cb, bes, &localxer);
            tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);
        }
        tcg_out_goto_noaddr(s);
    } else {
        tcg_out_goto(s, l->u.value_ptr);
    }
}",0,1,63,0.64,Insert
1694,"static void ac97_map (PCIDevice *pci_dev, int region_num,
                      uint32_t addr, uint32_t size, int type)
{
    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;
    AC97LinkState *s = &d->ac97;
    if (!region_num) {
        s->base[0] = addr;
        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);
        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);
        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);
        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);
        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);
        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);
    }
    else {
        s->base[1] = addr;
        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);
        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);
        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);
        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);
        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);
        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);
    }
}","static void ac97_map (PCIDevice *pci_dev, int region_num,
                      uint32_t addr, uint32_t size, int type)
{
    const char
        *attribute,
        *content;
        DisasContext *ctx;
        const struct hldefinition *hldefinition;
        int port, is_output, ttl, remote_host;
        char val[1024];
        int port_7, is_output_10, ttl_2, remote_host_3;
        char val_5[1024];
        int port_7, is_output_10, ttl_2, remote_host_3;
        int port_7, is_output_10, ttl_2, remote_host_3;
        char hostname_1[256];
        build_udp_url_10(val_5, sizeof(val_5),
                          hostname_1, port_7, remote_host_3, ttl_2);
        build_udp_url_10(val_5, sizeof(val_5),
                          hostname_1, port_7 + 1, remote_host_3 + 1, ttl_2);
        int port, is_output, ttl, remote_host;
        int port, is_output, ttl, remote_host;
        char hostname[256];
        int (*compare)(const char *, const char *, size_t);
        const char *name1;
        const char *name2;
        int cmp;
        unsigned char c1, mc7;
        cmp = compare(name1, name2, len);
        c1 = name1[len];
        build_udp_url(val, sizeof(val),
                          hostname, port, remote_host, ttl);
        build_udp_url(val, sizeof(val),
                          hostname, port + 1, remote_host + 1, ttl);
        unsigned int i;
        size_t num_names;
        char *p;
        char *ea_namelist = smallbuf;
        for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen_5(p)+1) {
        		num_names += 1;
        }
        if (hldefinition->console_serial_base) {
                serial_mm_init(hldefinition->console_serial_base, 0, NULL, 115200,
                               serial_hds[i], 1);
                i++;
        }
        int32_t r1, r2;
        r2  = MASK_OP_BO_S2(ctx->opcode);
    QuantizationTable
        *table;
        GF_BitStream *bs;
        GF_Box *s_7;
        FilePartitionBox *inter = (FilePartitionBox *)s_7;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
    register const xmlChar *m;
    m = ctxt->input->cur;
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    char str[] = ""Constant"";
    TCGReg rar;
    TCGType ir;
    AArch64Insn insna;
    TCGContext *services;
    TCGReg ril;
    unsigned k, b, err, C;
    unsigned k, b, err, C;
    tcg_out_insn_3404(services, insna, ir, rar, ril, ir, err, C);
    while (strlen(str) > 5) {
        PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;
    strcpy(str, ""a"");
    }
    AC97LinkState *s = &d->ac97;
    if (!region_num) {
        s->base[0] = addr;
        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);
        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);
        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);
        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);
        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);
        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);
    }
    else {
        s->base[1] = addr;
        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);
        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);
        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);
        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);
        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);
        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);
    }
}",0,1,434,2.78,Insert
1695,"void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,
                        void *opaque)
{
    SaveStateEntry *se, *new_se;
    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {
        if (se->vmsd == vmsd && se->opaque == opaque) {
            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);
            if (se->compat) {
                g_free(se->compat);
            }
            g_free(se);
        }
    }
}","void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,
                        void *opaque)
{
    SaveStateEntry *se, *new_se;
    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {
        if (se->vmsd == vmsd && se->opaque == opaque) {
            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);
            if (se->compat) {
                char str[] = ""Constant"";
                while (strlen(str) > 5) {
                    g_free(se->compat);
                strcpy(str, ""a"");
                }
            }
            int lang, rar;
            GF_BitStream *bits;
            GF_Box *s;
            GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
            GF_Err e;
            e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
            ISOM_DECREASE_SIZE(buf, 8);
            const char *request= ""DROP TABLE IF EXISTS test_table;""
            DisasContext *ctx;
            int32_t r1, r2;
            r2  = MASK_OP_BO_S2(ctx->opcode);
                                 ""CREATE TABLE test_table(id INT);""
                                 ""INSERT INTO test_table VALUES(10);""
                                 ""UPDATE test_table SET id=20 WHERE id=10;""
                                 ""SELECT * FROM test_table;""
                                 ""INSERT INTO non_existent_table VALUES(11);"";
            MYSQL *mysql___global;
            lang= mysql_query(mysql___global, request);
            lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
            mysql_close(mysql___global);
            g_free(se);
        }
    }
}",0,1,84,0.76,Insert
1696,"static int xenfb_send_motion(struct XenInput *xenfb,
			     int rel_x, int rel_y, int rel_z)
{
    union xenkbd_in_event event;
    memset(&event, 0, XENKBD_IN_EVENT_SIZE);
    event.type = XENKBD_TYPE_MOTION;
    event.motion.rel_x = rel_x;
    event.motion.rel_y = rel_y;
#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207
    event.motion.rel_z = rel_z;
#endif
    return xenfb_kbd_event(xenfb, &event);
}","static int xenfb_send_motion(struct XenInput *xenfb,
			     int rel_x, int rel_y, int rel_z)
{
    union xenkbd_in_event event;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_9;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_9;
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
    aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
    int a = 64;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    int b = a;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    if(a*b>0){
        memset(&event, 0, XENKBD_IN_EVENT_SIZE);
    }
    event.type = XENKBD_TYPE_MOTION;
    event.motion.rel_x = rel_x;
    event.motion.rel_y = rel_y;
#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207
    event.motion.rel_z = rel_z;
#endif
    return xenfb_kbd_event(xenfb, &event);
}",0,1,89,0.78,Insert
1699,"static int slirp_socket_load(QEMUFile *f, struct socket *so)
{
    if (tcp_attach(so) < 0)
        return -ENOMEM;
    so->so_urgc = qemu_get_be32(f);
    so->so_ffamily = qemu_get_be16(f);
    switch (so->so_ffamily) {
    case AF_INET:
        so->so_faddr.s_addr = qemu_get_be32(f);
        so->so_fport = qemu_get_be16(f);
        break;
    default:
        error_report(
                ""so_ffamily unknown, unable to restore so_faddr and so_lport\n"");
    }
    so->so_lfamily = qemu_get_be16(f);
    switch (so->so_lfamily) {
    case AF_INET:
        so->so_laddr.s_addr = qemu_get_be32(f);
        so->so_lport = qemu_get_be16(f);
        break;
    default:
        error_report(
                ""so_ffamily unknown, unable to restore so_laddr and so_lport\n"");
    }
    so->so_iptos = qemu_get_byte(f);
    so->so_emu = qemu_get_byte(f);
    so->so_type = qemu_get_byte(f);
    so->so_state = qemu_get_be32(f);
    if (slirp_sbuf_load(f, &so->so_rcv) < 0)
        return -ENOMEM;
    if (slirp_sbuf_load(f, &so->so_snd) < 0)
        return -ENOMEM;
    slirp_tcp_load(f, so->so_tcpcb);
    return 0;
}","static int slirp_socket_load(QEMUFile *f, struct socket *so)
{
    const char
    const char *filename;
    int64_t parent;
    unsigned maxpages;
    size_t *start;
    struct iov_iter *i;
    unsigned int iter_head, npages;
    unsigned int iter_head, npages;
    size_t capacity;
    npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
    capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    int ecd;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned maxpages_9;
    size_t *start_7;
    struct iov_iter *i_4;
    unsigned int iter_head_9, npages_7;
    unsigned int iter_head_9, npages_7;
    size_t capacity_2;
    npages_7 = pipe_space_for_user_4(iter_head_9, i_4->pipe->tail, i_4->pipe);
    capacity_2 = min_4(npages_7, maxpages_9) * PAGE_SIZE_2 - *start_7;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    ecd = open(filename, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (tcp_attach(so) < 0)
        return -ENOMEM;
    so->so_urgc = qemu_get_be32(f);
    int a = 2;
    int b = 3;
    while (a < b) {
        so->so_ffamily = qemu_get_be16(f);
        b = a;
    }
    switch (so->so_ffamily) {
    case AF_INET:
        so->so_faddr.s_addr = qemu_get_be32(f);
        so->so_fport = qemu_get_be16(f);
        break;
    default:
        error_report(
                ""so_ffamily unknown, unable to restore so_faddr and so_lport\n"");
    }
    so->so_lfamily = qemu_get_be16(f);
    switch (so->so_lfamily) {
    case AF_INET:
        so->so_laddr.s_addr = qemu_get_be32(f);
        so->so_lport = qemu_get_be16(f);
        break;
    default:
        error_report(
                ""so_ffamily unknown, unable to restore so_laddr and so_lport\n"");
    }
    so->so_iptos = qemu_get_byte(f);
    so->so_emu = qemu_get_byte(f);
    so->so_type = qemu_get_byte(f);
    so->so_state = qemu_get_be32(f);
    if (slirp_sbuf_load(f, &so->so_rcv) < 0)
        return -ENOMEM;
    if (slirp_sbuf_load(f, &so->so_snd) < 0)
        return -ENOMEM;
    slirp_tcp_load(f, so->so_tcpcb);
    return 0;
}",0,1,152,1.68,Insert
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)
{
    int pos = 0;
    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",
                    info->name, info->bus_info->name);
    if (info->alias)
        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);
    if (info->desc)
        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);
    if (info->no_user)
        pos += snprintf(dest+pos, len-pos, "", no-user"");
    return pos;
}","static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)
{
    int a = 2;
    double f;
    f = get_float64 (buffer, &error);
    int b = 3;
    qemu_irq rx[128];
    u16 request;
    bool from_ap;
    struct sk_buff *img;
    if (from_ap && request)
    		NLA_PUT_U16(img, NL80211_ATTR_REASON_CODE, request);
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    if (a != b) {
        int pos = 0;
    }
    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",
                    info->name, info->bus_info->name);
    if (info->alias)
        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);
    if (info->desc)
        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);
    if (info->no_user)
        pos += snprintf(dest+pos, len-pos, "", no-user"");
    return pos;
}",0,1,73,1.08,Insert
1701,"static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)
{
    int next_avc    = h->is_avc ? 0 : buf_size;
    int nal_index   = 0;
    int buf_index   = 0;
    int nals_needed = 0;
    while(1) {
        int nalsize = 0;
        int dst_length, bit_length, consumed;
        const uint8_t *ptr;
        if (buf_index >= next_avc) {
            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);
            if (nalsize < 0)
                break;
            next_avc = buf_index + nalsize;
        } else {
            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);
            if (buf_index >= buf_size)
                break;
        }
        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,
                                 next_avc - buf_index);
        if (ptr == NULL || dst_length < 0)
            return AVERROR_INVALIDDATA;
        buf_index += consumed;
        bit_length = get_bit_length(h, buf, ptr, dst_length,
                                    buf_index, next_avc);
        nal_index++;
        switch (h->nal_unit_type) {
        case NAL_SPS:
        case NAL_PPS:
            nals_needed = nal_index;
            break;
        case NAL_DPA:
        case NAL_IDR_SLICE:
        case NAL_SLICE:
            init_get_bits(&h->gb, ptr, bit_length);
            if (!get_ue_golomb(&h->gb))
                nals_needed = nal_index;
        }
    }
    return nals_needed;
}","static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)
{
    int next_avc    = h->is_avc ? 0 : buf_size;
    int nal_index   = 0;
    int buf_index   = 0;
    int nals_needed = 0;
    while(1) {
        int nalsize = 0;
        DisasContext *ctx;
        int32_t r1, r2;
        r1 = MASK_OP_BO_S1D(ctx->opcode);
        int dst_length, bit_length, consumed;
        const uint8_t *ptr;
        if (buf_index >= next_avc) {
            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);
            if (nalsize < 0)
                break;
            next_avc = buf_index + nalsize;
        } else {
            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);
            if (buf_index >= buf_size)
                break;
        }
        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,
                                 next_avc - buf_index);
        if (ptr == NULL || dst_length < 0)
            return AVERROR_INVALIDDATA;
        buf_index += consumed;
        bit_length = get_bit_length(h, buf, ptr, dst_length,
                                    buf_index, next_avc);
        nal_index++;
        switch (h->nal_unit_type) {
        case NAL_SPS:
        case NAL_PPS:
            int a = 28;
            int b = a;
            if(a*b>0){
                nals_needed = nal_index;
            }
            break;
        case NAL_DPA:
        case NAL_IDR_SLICE:
        case NAL_SLICE:
            init_get_bits(&h->gb, ptr, bit_length);
            if (!get_ue_golomb(&h->gb))
                nals_needed = nal_index;
        }
    }
    return nals_needed;
}",0,1,34,1.2,Insert
1704,,,,,,,
1706,,,,,,,
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    int r, b;
    b = cdt[p2];
    r = cdt[p1]<<16;
    return (b+r) << 1;
}","static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    int r, b;
    b = cdt[p2];
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        r = cdt[p1]<<16;
    strcpy(str_1, ""a"");
    }
    return (b+r) << 1;
}",1,0,1,0.04,Replace
1709,"static void matroska_add_index_entries(MatroskaDemuxContext *matroska)
{
    EbmlList *index_list;
    MatroskaIndex *index;
    int index_scale = 1;
    int i, j;
    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)
        return;
    index_list = &matroska->index;
    index      = index_list->elem;
    if (index_list->nb_elem &&
        index[0].time > 1E14 / matroska->time_scale) {
        av_log(matroska->ctx, AV_LOG_WARNING, ""Working around broken index.\n"");
        index_scale = matroska->time_scale;
    }
    for (i = 0; i < index_list->nb_elem; i++) {
        EbmlList *pos_list    = &index[i].pos;
        MatroskaIndexPos *pos = pos_list->elem;
        for (j = 0; j < pos_list->nb_elem; j++) {
            MatroskaTrack *track = matroska_find_track_by_num(matroska,
                                                              pos[j].track);
            if (track && track->stream)
                av_add_index_entry(track->stream,
                                   pos[j].pos + matroska->segment_start,
                                   index[i].time / index_scale, 0, 0,
                                   AVINDEX_KEYFRAME);
        }
    }
}","static void matroska_add_index_entries(MatroskaDemuxContext *matroska)
{
    EbmlList *index_list;
    MatroskaIndex *index;
    int index_scale = 1;
    int i, j;
    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)
        return;
    index_list = &matroska->index;
    index      = index_list->elem;
    if (index_list->nb_elem &&
        index[0].time > 1E14 / matroska->time_scale) {
        int a = 2;
        int b = 3;
        while (a != b) {
            av_log(matroska->ctx, AV_LOG_WARNING, ""Working around broken index.\n"");
            u32 handle;
            struct route4_filter *fold, *fold2, *pfp, *new = NULL;
            struct route4_filter *fold, *fold2, *pfp, *new = NULL;
            struct route4_filter __rcu **fp;
            for (pfp = rtnl_dereference(*fp);
            	     (fold2 = rtnl_dereference(*fp)) != NULL;
            	     fp = &fold2->next)
            		if (f->newandle < fold2->handle)
            			break;
            b = a;
        }
        index_scale = matroska->time_scale;
    }
    for (i = 0; i < index_list->nb_elem; i++) {
        EbmlList *pos_list    = &index[i].pos;
        MatroskaIndexPos *pos = pos_list->elem;
        for (j = 0; j < pos_list->nb_elem; j++) {
            MatroskaTrack *track = matroska_find_track_by_num(matroska,
                                                              pos[j].track);
            if (track && track->stream)
                av_add_index_entry(track->stream,
                                   pos[j].pos + matroska->segment_start,
                                   index[i].time / index_scale, 0, 0,
                                   AVINDEX_KEYFRAME);
        }
    }
}",1,0,34,0.98,Insert
1710,"static inline void downmix_3f_2r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;
    }
}","static inline void downmix_3f_2r_to_mono(float *samples)
{
    hwaddr val;
    CPUAlphaState *viron = &cpu->viron;
    viron->trap_arg0 = val;
    sqlite3_context *phpCorptrl;
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    int a = 2;
    int b = 3;
    char *filename;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    while (a < b) {
        int i;
        b = a;
    }
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;
    }
}",0,1,76,1.01,Insert
1711,,,,,,,
1712,,,,,,,
1714,,,,,,,
1716,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)
{
    c->high = 255;
    c->bits = -16;
    c->buffer = buf;
    c->end = buf + buf_size;
    c->code_word = bytestream_get_be24(&c->buffer);
}","void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)
{
    c->high = 255;
    c->bits = -16;
    c->buffer = buf;
    int a = 2;
    int b = 3;
    while (a < b) {
        c->end = buf + buf_size;
        MOVContext *c_5;
        AVIOContext *pb;
        uint32_t minor_ver;
        char minor_ver_str[11];
        minor_ver = avio_rb32(pb);
        snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
        av_dict_set(&c_5->fc->metadata, ""minor_version"", minor_ver_str, 0);
        b = a;
    }
    c->code_word = bytestream_get_be24(&c->buffer);
}",1,0,12,0.52,Insert
1718,"static int ftp_connect_control_connection(URLContext *h)
{
    char buf[CONTROL_BUFFER_SIZE], opts_format[20];
    int err;
    AVDictionary *opts = NULL;
    FTPContext *s = h->priv_data;
    const int connect_codes[] = {220, 0};
    s->conn_control_block_flag = 0;
    if (!s->conn_control) {
        ff_url_join(buf, sizeof(buf), ""tcp"", NULL,
                    s->hostname, s->server_control_port, NULL);
        if (s->rw_timeout != -1) {
            snprintf(opts_format, sizeof(opts_format), ""%d"", s->rw_timeout);
            av_dict_set(&opts, ""timeout"", opts_format, 0);
        }  
        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,
                         &s->conn_control_interrupt_cb, &opts);
        av_dict_free(&opts);
        if (err < 0) {
            av_log(h, AV_LOG_ERROR, ""Cannot open control connection\n"");
            return err;
        }
        if (!ftp_status(s, NULL, connect_codes)) {
            av_log(h, AV_LOG_ERROR, ""FTP server not ready for new users\n"");
            err = AVERROR(EACCES);
            return err;
        }
        if ((err = ftp_auth(s)) < 0) {
            av_log(h, AV_LOG_ERROR, ""FTP authentication failed\n"");
            return err;
        }
        if ((err = ftp_type(s)) < 0) {
            av_dlog(h, ""Set content type failed\n"");
            return err;
        }
    }
    return 0;
}","static int ftp_connect_control_connection(URLContext *h)
{
    char buf[CONTROL_BUFFER_SIZE], opts_format[20];
    int a = 2;
    int b = 3;
    while (a < b) {
        int err;
        b = a;
    }
    AVDictionary *opts = NULL;
    const char *data;
    AVPacket *mctx;
    uint8_t *uf8 = NULL;
    GetBitContext gb;
    PutBitContext pb, pb2;
    int w;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    PutBitContext pb, pb2;
    int i, size, ure;
    size = put_bits_count(&pb2);
    init_get_bits(&gb, uf8, size);
    size -= 7;
    mctx->size   = put_bits_count(&pb) >> 3;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    FTPContext *s = h->priv_data;
    const int connect_codes[] = {220, 0};
    s->conn_control_block_flag = 0;
    if (!s->conn_control) {
        VirtIOSCSIReq *req;
        VirtIOSCSI *sb;
        req->dev = sb;
        ff_url_join(buf, sizeof(buf), ""tcp"", NULL,
                    s->hostname, s->server_control_port, NULL);
        if (s->rw_timeout != -1) {
            snprintf(opts_format, sizeof(opts_format), ""%d"", s->rw_timeout);
            av_dict_set(&opts, ""timeout"", opts_format, 0);
            VirtioCcwDevice *dev;
            Error *err_5 = NULL;
            VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
            DeviceState *parent = DEVICE(dev);
            if (k->realize) {
                    k->realize(dev, &err_5);
            }
        }  
        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,
                         &s->conn_control_interrupt_cb, &opts);
        av_dict_free(&opts);
        if (err < 0) {
            av_log(h, AV_LOG_ERROR, ""Cannot open control connection\n"");
            return err;
        }
        if (!ftp_status(s, NULL, connect_codes)) {
            av_log(h, AV_LOG_ERROR, ""FTP server not ready for new users\n"");
            err = AVERROR(EACCES);
            return err;
        }
        if ((err = ftp_auth(s)) < 0) {
            av_log(h, AV_LOG_ERROR, ""FTP authentication failed\n"");
            return err;
        }
        if ((err = ftp_type(s)) < 0) {
            av_dlog(h, ""Set content type failed\n"");
            return err;
        }
    }
    return 0;
}",0,1,366,2.84,Insert
1719,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)
{
    uintptr_t addr = (uintptr_t)data;
    g_assert(addr >= QPCI_PIO_LIMIT);
    dev->bus->memread(dev->bus, addr, buf, len);
}","void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)
{
    GstDateTime *dt, *dt2;
    fail_unless (gst_date_time_get_hour (dt) == 15);
    fail_unless (gst_date_time_get_minute (dt) == 50);
    fail_unless (gst_date_time_get_second (dt) == 33);
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""15:50:33Z"");
    uintptr_t addr = (uintptr_t)data;
    g_assert(addr >= QPCI_PIO_LIMIT);
    int a = 2;
    int b = 3;
    while (a < b) {
        dev->bus->memread(dev->bus, addr, buf, len);
        b = a;
    }
}",1,0,24,0.62,Insert
1721,,,,,,,
1722,,,,,,,
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,
                                                         PutBitContext *pb, const float *in, float *out,
                                                         const float *scaled, int size, int scale_idx,
                                                         int cb, const float lambda, const float uplim,
                                                         int *bits, const float ROUNDING) {
    int i;
    if (bits)
        *bits = 0;
    if (out) {
        for (i = 0; i < size; i += 4) {
           out[i  ] = 0.0f;
           out[i+1] = 0.0f;
           out[i+2] = 0.0f;
           out[i+3] = 0.0f;
        }
    }
}","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,
                                                         PutBitContext *pb, const float *in, float *out,
                                                         const float *scaled, int size, int scale_idx,
                                                         int cb, const float lambda, const float uplim,
                                                         int *bits, const float ROUNDING) {
    int i;
    if (bits)
        *bits = 0;
    if (out) {
        for (i = 0; i < size; i += 4) {
           struct ipc_ids *changes;
           struct kern_ipc_perm *where;
           int id;
           int next_id = changes->next_id;
           spin_lock_init(&where->lock);
           rcu_read_lock();
           spin_lock(&where->lock);
           id = idr_alloc(&changes->ipcs_idr, where,
            		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
            		       GFP_NOWAIT);
           out[i  ] = 0.0f;
           out[i+1] = 0.0f;
           int a = 2;
           int b = 3;
           if (a != b) {
               out[i+2] = 0.0f;
           }
           out[i+3] = 0.0f;
        }
    }
}",1,0,12,0.85,Insert
1724,,,,,,,
1725,"static void mmap_release_buffer(AVPacket *pkt)
{
    struct v4l2_buffer buf;
    int res, fd;
    struct buff_data *buf_descriptor = pkt->priv;
    if (pkt->data == NULL)
        return;
    memset(&buf, 0, sizeof(struct v4l2_buffer));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = buf_descriptor->index;
    fd = buf_descriptor->fd;
    av_free(buf_descriptor);
    res = ioctl(fd, VIDIOC_QBUF, &buf);
    if (res < 0)
        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",
               strerror(errno));
    pkt->data = NULL;
    pkt->size = 0;
}","static void mmap_release_buffer(AVPacket *pkt)
{
    struct v4l2_buffer buf;
    int res, fd;
    struct buff_data *buf_descriptor = pkt->priv;
    if (pkt->data == NULL)
        return;
    memset(&buf, 0, sizeof(struct v4l2_buffer));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = buf_descriptor->index;
    fd = buf_descriptor->fd;
    av_free(buf_descriptor);
    char str[] = ""Constant"";
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    while (strlen(str) > 5) {
        res = ioctl(fd, VIDIOC_QBUF, &buf);
    strcpy(str, ""a"");
    }
    if (res < 0)
        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",
               strerror(errno));
    pkt->data = NULL;
    pkt->size = 0;
}",0,1,46,0.81,Insert
1726,"static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *c2 = opaque;
    qemu_coroutine_enter(c2, NULL);
}","static void coroutine_fn c1_fn(void *opaque)
{
    AVFormatContext *s;
    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;
    HLSContext *c = s->priv_data;
    if (u) {
            update_options(&c->user_agent, ""user-agent"", u);
            update_options(&c->cookies, ""cookies"", u);
            update_options(&c->headers, ""headers"", u);
            update_options(&c->http_proxy, ""http_proxy"", u);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        Coroutine *c2 = opaque;
        b = a;
    }
    qemu_coroutine_enter(c2, NULL);
}",1,0,5,0.35,Insert
1727,,,,,,,
1728,,,,,,,
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        ERRPRINT(""Can't write to data buffer: buffer full\n"");
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        s->data_count++;
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",
                    s->data_count);
            s->data_count = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            if (s->prnsts & SDHC_DOING_WRITE) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        ERRPRINT(""Can't write to data buffer: buffer full\n"");
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        int a = 2;
        int b = 2;
        if (a == b) {
            s->data_count++;
        }
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",
                    s->data_count);
            s->data_count = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            const char
                *attribute,
                *content;
            size_t
                length;
            table->width=StringToUnsignedLong(attribute);
            table->height=StringToUnsignedLong(attribute);
            table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
            length=(size_t) table->width*table->height;
            table->levels=(unsigned int *) AcquireQuantumMemory(length,
                sizeof(*table->levels));
            if (s->prnsts & SDHC_DOING_WRITE) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}",0,1,42,0.91,Insert
1731,"static int milkymist_memcard_init(SysBusDevice *dev)
{
    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);
    DriveInfo *dinfo;
    BlockDriverState *bs;
    dinfo = drive_get_next(IF_SD);
    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
    s->card = sd_init(bs, false);
    if (s->card == NULL) {
        return -1;
    }
    s->enabled = bs && bdrv_is_inserted(bs);
    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,
            ""milkymist-memcard"", R_MAX * 4);
    sysbus_init_mmio(dev, &s->regs_region);
    return 0;
}","static int milkymist_memcard_init(SysBusDevice *dev)
{
    Network::ConnectionEvent id;
    if (id == Network::ConnectionEvent::LocalClose ||
          id == Network::ConnectionEvent::RemoteClose) {
        downstream_closed_ = true;
    }
    char str1[] = ""Constant"";
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    char str2[] = ""Constant"";
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    if (strcmp(str1, str2) == 0) {
        MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);
    }
    DriveInfo *dinfo;
    BlockDriverState *bs;
    dinfo = drive_get_next(IF_SD);
    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
    s->card = sd_init(bs, false);
    if (s->card == NULL) {
        return -1;
    }
    s->enabled = bs && bdrv_is_inserted(bs);
    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,
            ""milkymist-memcard"", R_MAX * 4);
    sysbus_init_mmio(dev, &s->regs_region);
    return 0;
}",0,1,624,3.5,Insert
1732,"static void visitor_output_setup_internal(TestOutputVisitorData *data,
                                          bool human)
{
    data->human = human;
    data->sov = string_output_visitor_new(human);
    g_assert(data->sov);
    data->ov = string_output_get_visitor(data->sov);
    g_assert(data->ov);
}","static void visitor_output_setup_internal(TestOutputVisitorData *data,
                                          bool human)
{
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    data->human = human;
    GF_Filter *process;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    git->base_stream_id = proc ? proc->value.uint : -1;
    git->pck_time = -1;
    int a = 83;
    int b = a;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    if(a*b>0){
        data->sov = string_output_visitor_new(human);
    }
    g_assert(data->sov);
    data->ov = string_output_get_visitor(data->sov);
    g_assert(data->ov);
}",0,1,78,0.83,Insert
1733,,,,,,,
1734,,,,,,,
1736,,,,,,,
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)
{
    uint16_t v = tswap16(val);
    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
}","void stw_phys(target_phys_addr_t addr, uint32_t val)
{
    char *filename;
    if (!filename) {
            error_report(""Could not find LPAR rtas '%s'"", ""spapr-rtas.bin"");
            exit(1);
    }
    char str[] = ""Constant"";
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    while (strlen(str) > 5) {
        uint16_t v = tswap16(val);
    strcpy(str, ""a"");
    }
    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
}",0,1,62,0.55,Insert
1739,"void slirp_cleanup(Slirp *slirp)
{
    TAILQ_REMOVE(&slirp_instances, slirp, entry);
    unregister_savevm(""slirp"", slirp);
    qemu_free(slirp->tftp_prefix);
    qemu_free(slirp->bootp_filename);
    qemu_free(slirp);
}","void slirp_cleanup(Slirp *slirp)
{
    const struct dom_sid *alias;
    MachineState *machine;
    char *filename;
    int wb;
    uint32_t lvcall;
    struct edgeport_serial *serial;
    u8 *data_7;
    int status;
    struct device *dev_2 = &serial->serial->dev_2->dev_2;
    if (status)
    		dev_dbg(dev_2, ""%s - read 3 status error = %d
    "", __func___1, status);
    	else
    		dev_dbg(dev_2, ""%s - read 2 data = 0x%x
    "", __func___1, *data_7);
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct ldb_dn *anon;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct dom_sid_buf buf;
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    NT_STATUS_HAVE_NO_MEMORY(mem_context);
    anon = ldb_dn_new_fmt(
    		mem_context,
    		area->ldb,
    		""<SID=%s>"",
    		dom_sid_str_buf(alias, &buf));
    talloc_free(mem_context);
    TAILQ_REMOVE(&slirp_instances, slirp, entry);
    char str[] = ""Constant"";
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (strlen(str) > 0) {
        unregister_savevm(""slirp"", slirp);
    }
    qemu_free(slirp->tftp_prefix);
    qemu_free(slirp->bootp_filename);
    qemu_free(slirp);
}",0,1,134,0.85,Insert
1740,"void scsi_req_abort(SCSIRequest *req, int status)
{
    if (!req->enqueued) {
        return;
    }
    scsi_req_ref(req);
    scsi_req_dequeue(req);
    req->io_canceled = true;
    if (req->ops->cancel_io) {
        req->ops->cancel_io(req);
    }
    scsi_req_complete(req, status);
    scsi_req_unref(req);
}","void scsi_req_abort(SCSIRequest *req, int status)
{
    if (!req->enqueued) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return;
        }
    }
    scsi_req_ref(req);
    scsi_req_dequeue(req);
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status_9;
    if (status_9 == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    req->io_canceled = true;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    if (req->ops->cancel_io) {
        req->ops->cancel_io(req);
    }
    scsi_req_complete(req, status);
    scsi_req_unref(req);
}",0,1,49,0.66,Insert
1741,"rdt_free_extradata (PayloadContext *rdt)
{
    int i;
    for (i = 0; i < MAX_STREAMS; i++)
        if (rdt->rmst[i]) {
            ff_rm_free_rmstream(rdt->rmst[i]);
            av_freep(&rdt->rmst[i]);
        }
    if (rdt->rmctx)
        av_close_input_stream(rdt->rmctx);
    av_freep(&rdt->mlti_data);
    av_free(rdt);
}","rdt_free_extradata (PayloadContext *rdt)
{
    int i;
    DisasContext *ctx;
    int32_t r1, r2;
    r1 = MASK_OP_BO_S1D(ctx->opcode);
    for (i = 0; i < MAX_STREAMS; i++)
        if (rdt->rmst[i]) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                ff_rm_free_rmstream(rdt->rmst[i]);
            }
            av_freep(&rdt->rmst[i]);
        }
    if (rdt->rmctx)
        av_close_input_stream(rdt->rmctx);
    av_freep(&rdt->mlti_data);
    av_free(rdt);
}",0,1,24,0.51,Insert
1744,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    return pcms->nvdimm;
}","static bool pc_machine_get_nvdimm(Object *obj, Error **errp)
{
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    int a = 2;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    int b = 3;
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    while (a != b) {
        PCMachineState *pcms = PC_MACHINE(obj);
        b = a;
    }
    return pcms->nvdimm;
}",0,1,73,0.58,Insert
1745,"build_header(GArray *linker, GArray *table_data,
             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,
             const char *oem_table_id)
{
    memcpy(&h->signature, sig, 4);
    h->length = cpu_to_le32(len);
    h->revision = rev;
    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);
    if (oem_table_id) {
        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));
    } else {
        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);
        memcpy(h->oem_table_id + 4, sig, 4);
    }
    h->oem_revision = cpu_to_le32(1);
    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);
    h->asl_compiler_revision = cpu_to_le32(1);
    h->checksum = 0;
    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
                                    table_data->data, h, len, &h->checksum);
}","build_header(GArray *linker, GArray *table_data,
             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,
             const char *oem_table_id)
{
    memcpy(&h->signature, sig, 4);
    h->length = cpu_to_le32(len);
    h->revision = rev;
    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
    AVCodecContext *avctx;
    PutBitContext pb, pb2;
    int comps;
    const int near         = avctx->prediction_method;
    put_bits(&pb, 16, 6 + comps * 2);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 8, near);
    put_bits(&pb, 8, (comps > 1) ? 1 : 0);
    put_bits(&pb, 8, 0);
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if (oem_table_id) {
        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));
    } else {
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);
        memcpy(h->oem_table_id + 4, sig, 4);
    }
    h->oem_revision = cpu_to_le32(1);
    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);
    h->asl_compiler_revision = cpu_to_le32(1);
    h->checksum = 0;
    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
                                    table_data->data, h, len, &h->checksum);
}",0,1,98,1.13,Insert
1746,,,,,,,
1747,,,,,,,
1753,,,,,,,
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}","static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int a = 7;
    int b = a;
    if(a*b>0){
        int tmp;
    }
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}",0,1,3,0.15,Replace
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)
{
    unsigned int tag;
    int64_t size;
    for (;;) {
        if (url_feof(pb))
            return AVERROR_EOF;
        size = next_tag(pb, &tag);
        if (tag == tag1)
            break;
        wav_seek_tag(pb, size, SEEK_CUR);
    }
    return size;
}","static int64_t find_tag(AVIOContext *pb, uint32_t tag1)
{
    int a = 2;
    int b = 3;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    while (a < b) {
        unsigned int tag;
        b = a;
    }
    int64_t size;
    for (;;) {
        if (url_feof(pb))
            return AVERROR_EOF;
        size = next_tag(pb, &tag);
        if (tag == tag1)
            break;
        wav_seek_tag(pb, size, SEEK_CUR);
    }
    return size;
}",0,1,25,0.55,Insert
1758,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)
{
    *range = 8 * (1 << (f_code - 1));
    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)
	*range *= 2;
    if (s->unrestricted_mv) {
        *xmin = -16;
        *ymin = -16;
        if (s->h263_plus)
            *range *= 2;
        if(s->avctx->codec->id!=CODEC_ID_MPEG4){
            *xmax = s->mb_width*16;
            *ymax = s->mb_height*16;
        }else {
            *xmax = s->width;
            *ymax = s->height;
        }
    } else {
        *xmin = 0;
        *ymin = 0;
        *xmax = s->mb_width*16 - 16;
        *ymax = s->mb_height*16 - 16;
    }
}","static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)
{
    char str[] = ""Constant"";
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (strlen(str) > 0) {
        *range = 8 * (1 << (f_code - 1));
    }
    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)
	*range *= 2;
    if (s->unrestricted_mv) {
        *xmin = -16;
        *ymin = -16;
        if (s->h263_plus)
            *range *= 2;
        if(s->avctx->codec->id!=CODEC_ID_MPEG4){
            *xmax = s->mb_width*16;
            *ymax = s->mb_height*16;
        }else {
            *xmax = s->width;
            *ymax = s->height;
        }
    } else {
        *xmin = 0;
        *ymin = 0;
        *xmax = s->mb_width*16 - 16;
        *ymax = s->mb_height*16 - 16;
    }
}",0,1,29,0.8,Insert
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
{
    int ich, i;
    int order        = s->mclms_order;
    int num_channels = s->num_channels;
    for (ich = 0; ich < num_channels; ich++) {
        pred[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
        for (i = 0; i < ich; i++)
            pred[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        pred[ich] += 1 << s->mclms_scaling - 1;
        pred[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += pred[ich];
    }
}","static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
{
    int ich, i;
    int order        = s->mclms_order;
    int num_channels = s->num_channels;
    for (ich = 0; ich < num_channels; ich++) {
        pred[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
                         PadContext *s_5 = inlink->dst->priv;
                         AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                                                  w + (s_5->w - s_5->in_w),
                                                                  z + (s_5->z - s_5->in_h));
                         int sea;
                         for (sea = 0; sea < 4 && frame->data[sea]; sea++) {
                                 int hsub = s_5->draw.hsub[sea];
                                 int vsub = s_5->draw.vsub[sea];
                                 frame->data[sea] += (s_5->x >> hsub) * s_5->draw.pixelstep[sea] +
                                                       (s_5->y >> vsub) * frame->linesize[sea];
                         }
        for (i = 0; i < ich; i++)
            pred[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        int a = 2;
        int b = 3;
        if (a != b) {
            pred[ich] += 1 << s->mclms_scaling - 1;
        }
        pred[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += pred[ich];
    }
}",1,0,25,1.37,Insert
1762,,,,,,,
1763,,,,,,,
1764,,,,,,,
1767,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)
{
    qpci_device_enable(d->pdev);
    d->addr = qpci_iomap(d->pdev, 0, NULL);
    g_assert(d->addr != NULL);
}","void qvirtio_pci_device_enable(QVirtioPCIDevice *d)
{
    qpci_device_enable(d->pdev);
    char str1[] = ""Constant"";
    ppc4xx_bd_info_t *bd;
    int i, n;
    ram_addr_t bdloc;
    for (i = 0; i < 6; i++)
            stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        d->addr = qpci_iomap(d->pdev, 0, NULL);
    }
    g_assert(d->addr != NULL);
}",1,0,29,0.39,Insert
1768,"static int movie_request_frame(AVFilterLink *outlink)
{
    AVFilterBufferRef *outpicref;
    MovieContext *movie = outlink->src->priv;
    int ret;
    if (movie->is_done)
        return AVERROR_EOF;
    if ((ret = movie_get_frame(outlink)) < 0)
        return ret;
    outpicref = avfilter_ref_buffer(movie->picref, ~0);
    ff_start_frame(outlink, outpicref);
    ff_draw_slice(outlink, 0, outlink->h, 1);
    ff_end_frame(outlink);
    avfilter_unref_buffer(movie->picref);
    movie->picref = NULL;
    return 0;
}","static int movie_request_frame(AVFilterLink *outlink)
{
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    AVFilterBufferRef *outpicref;
    MovieContext *movie = outlink->src->priv;
    int ret;
    if (movie->is_done)
        return AVERROR_EOF;
    if ((ret = movie_get_frame(outlink)) < 0)
        return ret;
    outpicref = avfilter_ref_buffer(movie->picref, ~0);
    int a = 2;
    int b = 3;
    while (a < b) {
        ff_start_frame(outlink, outpicref);
        b = a;
    }
    ff_draw_slice(outlink, 0, outlink->h, 1);
    ff_end_frame(outlink);
    avfilter_unref_buffer(movie->picref);
    movie->picref = NULL;
    return 0;
}",0,1,22,0.64,Insert
1773,"static CharDriverState *qemu_chr_open_pipe(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    ChardevHostdev *opts = backend->u.pipe;
    const char *filename = opts->device;
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    s = g_new0(WinCharState, 1);
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename, errp) < 0) {
        g_free(s);
        g_free(chr);
        return NULL;
    }
    return chr;
}","static CharDriverState *qemu_chr_open_pipe(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    int i, qa;
    qa = libusb_init(&ctx);
    int a = 16;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    int b = a;
    bool has_mode;
    const char *data;
    int data;
    if (!has_mode) {
            data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
    }
    if(a*b>0){
        ChardevHostdev *opts = backend->u.pipe;
    }
    const char *filename = opts->device;
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    s = g_new0(WinCharState, 1);
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename, errp) < 0) {
        g_free(s);
        g_free(chr);
        return NULL;
    }
    return chr;
}",0,1,115,1.23,Insert
1774,"uint32_t HELPER(clz)(uint32_t x)
{
    int count;
    for (count = 32; x; count--)
        x >>= 1;
    return count;
}","uint32_t HELPER(clz)(uint32_t x)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int count;
    strcpy(str, ""a"");
    }
    for (count = 32; x; count--)
        x >>= 1;
    return count;
}",0,1,2,0.05,Replace
1776,"void helper_iret_protected(int shift)
{
    helper_ret_protected(shift, 1, 0);
}","void helper_iret_protected(int shift)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        helper_ret_protected(shift, 1, 0);
    }
}",0,1,2,0.04,Replace
1777,"void qemu_bh_schedule(QEMUBH *bh)
{
    AioContext *ctx;
    ctx = bh->ctx;
    bh->idle = 0;
    if (atomic_xchg(&bh->scheduled, 1) == 0) {
        aio_notify(ctx);
    }
}","void qemu_bh_schedule(QEMUBH *bh)
{
    AioContext *ctx;
    ctx = bh->ctx;
    DisasContext *ctx_7;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx_7->opcode);
    bh->idle = 0;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if (atomic_xchg(&bh->scheduled, 1) == 0) {
        aio_notify(ctx);
    }
}",0,1,40,0.38,Insert
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)
{
    SpiceTimer *timer;
    timer = qemu_mallocz(sizeof(*timer));
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, next);
    return timer;
}","static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)
{
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    char str[] = ""Constant"";
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    if (strlen(str) > 0) {
        SpiceTimer *timer;
    }
    timer = qemu_mallocz(sizeof(*timer));
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, next);
    return timer;
}",0,1,47,0.57,Insert
1779,"static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,
                                        unsigned int queue_no,
                                        unsigned int vector,
                                        MSIMessage msg)
{
    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);
    EventNotifier *n = virtio_queue_get_guest_notifier(vq);
    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];
    int ret;
    if (irqfd->users == 0) {
        ret = kvm_irqchip_add_msi_route(kvm_state, msg);
        if (ret < 0) {
            return ret;
        }
        irqfd->virq = ret;
    }
    irqfd->users++;
    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);
    if (ret < 0) {
        if (--irqfd->users == 0) {
            kvm_irqchip_release_virq(kvm_state, irqfd->virq);
        }
        return ret;
    }
    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);
    return 0;
}","static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,
                                        unsigned int queue_no,
                                        unsigned int vector,
                                        MSIMessage msg)
{
    AUXReply ret_6 = AUX_NACK;
    DPRINTF(""reply: %u
    "", ret_6);
    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);
    EventNotifier *n = virtio_queue_get_guest_notifier(vq);
    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];
    int ret;
    if (irqfd->users == 0) {
        ret = kvm_irqchip_add_msi_route(kvm_state, msg);
        if (ret < 0) {
            return ret;
        }
        irqfd->virq = ret;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        irqfd->users++;
    }
    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);
    if (ret < 0) {
        if (--irqfd->users == 0) {
            kvm_irqchip_release_virq(kvm_state, irqfd->virq);
        }
        return ret;
    }
    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);
    return 0;
}",0,1,28,0.88,Insert
1782,"static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)
{
    int ret = -EIO;
    total_size += 512;
    if (ftruncate(fd, total_size) != 0) {
        ret = -errno;
        goto fail;
    }
    if (lseek(fd, -512, SEEK_END) < 0) {
        goto fail;
    }
    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {
        goto fail;
    }
    ret = 0;
 fail:
    return ret;
}","static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)
{
    int ret = -EIO;
    total_size += 512;
    apr_pool_t *pid;
    apr_pool_cleanup_register(pid, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
    if (ftruncate(fd, total_size) != 0) {
        ret = -errno;
        size_t num_names;
        char *p;
        char *ea_namelist = smallbuf;
        for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
        		num_names += 1;
        }
        goto fail;
    }
    if (lseek(fd, -512, SEEK_END) < 0) {
        goto fail;
    }
    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {
        int a = 2;
        int b = 2;
        if (a == b) {
            goto fail;
        }
    }
    ret = 0;
 fail:
    return ret;
}",0,1,55,0.78,Insert
1783,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,
                           struct dirent *entry,
                           struct dirent **result)
{
    return readdir_r(fs->dir, entry, result);
}","static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,
                           struct dirent *entry,
                           struct dirent **result)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        return readdir_r(fs->dir, entry, result);
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    }
}",0,1,41,0.48,Insert
1785,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,
                                     unsigned size)
{
    MMIOState *s= opaque;
    return ide_status_read(&s->bus, 0);
}","static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,
                                     unsigned size)
{
    MMIOState *s= opaque;
    int a = 2;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    int b = 2;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    while (a == b) {
        return ide_status_read(&s->bus, 0);
        b += 1;
    }
}",0,1,92,0.78,Insert
1786,"void tlb_flush_page(CPUState *env, target_ulong addr)
{
    int i;
#if defined(DEBUG_TLB)
    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);
#endif
    env->current_tb = NULL;
    addr &= TARGET_PAGE_MASK;
    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
    tlb_flush_entry(&env->tlb_table[0][i], addr);
    tlb_flush_entry(&env->tlb_table[1][i], addr);
#if (NB_MMU_MODES >= 3)
    tlb_flush_entry(&env->tlb_table[2][i], addr);
#if (NB_MMU_MODES == 4)
    tlb_flush_entry(&env->tlb_table[3][i], addr);
#endif
#endif
    tlb_flush_jmp_cache(env, addr);
#ifdef USE_KQEMU
    if (env->kqemu_enabled) {
        kqemu_flush_page(env, addr);
    }
#endif
}","void tlb_flush_page(CPUState *env, target_ulong addr)
{
    int i;
    Aml *var;
    u32 trackNumber;
    GF_ISOFile  *photo;
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    GF_Err                      e;
    GF_TrackBox                 *trak;
    e = CanAccessMovie(photo, GF_ISOM_OPEN_WRITE);
    trak = gf_isom_get_track_from_file(photo, trackNumber);
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(var, dev);
#if defined(DEBUG_TLB)
    int a = 2;
    int b = 2;
    if (a == b) {
        printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);
    }
#endif
    env->current_tb = NULL;
    addr &= TARGET_PAGE_MASK;
    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
    tlb_flush_entry(&env->tlb_table[0][i], addr);
    tlb_flush_entry(&env->tlb_table[1][i], addr);
#if (NB_MMU_MODES >= 3)
    tlb_flush_entry(&env->tlb_table[2][i], addr);
#if (NB_MMU_MODES == 4)
    tlb_flush_entry(&env->tlb_table[3][i], addr);
#endif
#endif
    tlb_flush_jmp_cache(env, addr);
#ifdef USE_KQEMU
    if (env->kqemu_enabled) {
        kqemu_flush_page(env, addr);
    }
#endif
}",0,1,93,1.3,Insert
1787,,,,,,,
1788,,,,,,,
1790,,,,,,,
1791,,,,,,,
1792,,,,,,,
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)
{
    uint64_t *v = pv;
    qemu_put_be64s(f, v);
}","static void put_uint64(QEMUFile *f, void *pv, size_t size)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        uint64_t *v = pv;
        SwsContext *c;
        int needsDither;
        const enum PixelFormat srcFormat = c->srcFormat;
        const enum PixelFormat dstFormat = c->dstFormat;
        const enum PixelFormat srcFormat = c->srcFormat;
        needsDither = isAnyRGB(dstFormat) &&
                    c->dstFormatBpp < 24 &&
                   (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat)));
    }
    qemu_put_be64s(f, v);
}",1,0,6,0.35,Insert
1796,"QJSON *qjson_new(void)
{
    QJSON *json = QJSON(object_new(TYPE_QJSON));
    return json;
}","QJSON *qjson_new(void)
{
    int a = 2;
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    int b = 2;
    while (a == b) {
        QJSON *json = QJSON(object_new(TYPE_QJSON));
        b += 1;
    }
    return json;
}",0,1,13,0.34,Insert
1797,"void kqemu_record_dump(void)
{
    PCRecord **pr, *r;
    int i, h;
    FILE *f;
    int64_t total, sum;
    pr = malloc(sizeof(PCRecord *) * nb_pc_records);
    i = 0;
    total = 0;
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {
            pr[i++] = r;
            total += r->count;
        }
    }
    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);
    f = fopen(""/tmp/kqemu.stats"", ""w"");
    if (!f) {
        perror(""/tmp/kqemu.stats"");
        exit(1);
    }
    fprintf(f, ""total: %"" PRId64 ""\n"", total);
    sum = 0;
    for(i = 0; i < nb_pc_records; i++) {
        r = pr[i];
        sum += r->count;
        fprintf(f, ""%08lx: %"" PRId64 "" %0.2f%% %0.2f%%\n"",
                r->pc,
                r->count,
                (double)r->count / (double)total * 100.0,
                (double)sum / (double)total * 100.0);
    }
    fclose(f);
    free(pr);
    kqemu_record_flush();
}","void kqemu_record_dump(void)
{
    PCRecord **pr, *r;
    int a = 9;
    int b = a;
    if(a*b>0){
        int i, h;
    }
    FILE *f;
    int64_t total, sum;
    pr = malloc(sizeof(PCRecord *) * nb_pc_records);
    i = 0;
    total = 0;
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {
            pr[i++] = r;
            total += r->count;
        }
    }
    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);
    f = fopen(""/tmp/kqemu.stats"", ""w"");
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    if (!f) {
        perror(""/tmp/kqemu.stats"");
        exit(1);
    }
    fprintf(f, ""total: %"" PRId64 ""\n"", total);
    sum = 0;
    for(i = 0; i < nb_pc_records; i++) {
        r = pr[i];
        sum += r->count;
        fprintf(f, ""%08lx: %"" PRId64 "" %0.2f%% %0.2f%%\n"",
                r->pc,
                r->count,
                (double)r->count / (double)total * 100.0,
                (double)sum / (double)total * 100.0);
    }
    fclose(f);
    free(pr);
    kqemu_record_flush();
}",0,1,51,1.54,Insert
1799,"static void nbd_reply_ready(void *opaque)
{
    NbdClientSession *s = opaque;
    uint64_t i;
    int ret;
    if (s->reply.handle == 0) {
        ret = nbd_receive_reply(s->sock, &s->reply);
        if (ret == -EAGAIN) {
            return;
        }
        if (ret < 0) {
            s->reply.handle = 0;
            goto fail;
        }
    }
    i = HANDLE_TO_INDEX(s, s->reply.handle);
    if (i >= MAX_NBD_REQUESTS) {
        goto fail;
    }
    if (s->recv_coroutine[i]) {
        qemu_coroutine_enter(s->recv_coroutine[i], NULL);
        return;
    }
fail:
    nbd_teardown_connection(s);
}","static void nbd_reply_ready(void *opaque)
{
    NbdClientSession *s = opaque;
    uint64_t i;
    int ret;
    if (s->reply.handle == 0) {
        ret = nbd_receive_reply(s->sock, &s->reply);
        if (ret == -EAGAIN) {
            return;
        }
        if (ret < 0) {
            s->reply.handle = 0;
            goto fail;
        }
    }
    i = HANDLE_TO_INDEX(s, s->reply.handle);
    if (i >= MAX_NBD_REQUESTS) {
        goto fail;
    }
    if (s->recv_coroutine[i]) {
        int a = 2;
        int b = 3;
        while (a != b) {
            qemu_coroutine_enter(s->recv_coroutine[i], NULL);
            b = a;
        }
        return;
    }
fail:
    nbd_teardown_connection(s);
}",0,1,1,0.14,Replace
1800,"static void ffm_write_data(AVFormatContext *s,
                           const uint8_t *buf, int size,
                           int64_t pts, int header)
{
    FFMContext *ffm = s->priv_data;
    int len;
    if (header && ffm->frame_offset == 0) {
        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;
        ffm->pts = pts;
    }
    while (size > 0) {
        len = ffm->packet_end - ffm->packet_ptr;
        if (len > size)
            len = size;
        memcpy(ffm->packet_ptr, buf, len);
        ffm->packet_ptr += len;
        buf += len;
        size -= len;
        if (ffm->packet_ptr >= ffm->packet_end) {
            if (ffm->pts == 0)
                ffm->pts = pts;
            flush_packet(s);
        }
    }
}","static void ffm_write_data(AVFormatContext *s,
                           const uint8_t *buf, int size,
                           int64_t pts, int header)
{
    int a = 2;
    int b = 3;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    while (a < b) {
        FFMContext *ffm = s->priv_data;
        b = a;
    }
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    AVPacket *afpud;
    AVPacket *afpud_10;
    AVCodecContext *avctx_10;
    int sample_scale_4, c_4, n_4, i_7;
    int sample_scale_4, c_4, n_4, i_7;
    int buf_size_4 = afpud_10->size;
    PCMDecode *s_10 = avctx_10->priv_data;
    sample_scale_4 = av_get_bits_per_sample_5(avctx_10->codec_id)/8;
    n_4 = avctx_10->channels * sample_scale_4;
    n_4 = buf_size_4/sample_scale_4;
    AVCodecContext *avctx;
    int sample_scale, c_9, n, i_7;
    int sample_scale, c_9, n, i_7;
    int buf_size = afpud->size;
    PCMDecode *s_7 = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    n = buf_size/sample_scale;
    int err;
    int path, i;
    for (i = err-2; i >= 0; i--)
            if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
    int len;
    if (header && ffm->frame_offset == 0) {
        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;
        ffm->pts = pts;
    }
    while (size > 0) {
        len = ffm->packet_end - ffm->packet_ptr;
        if (len > size)
            len = size;
        memcpy(ffm->packet_ptr, buf, len);
        ffm->packet_ptr += len;
        buf += len;
        size -= len;
        if (ffm->packet_ptr >= ffm->packet_end) {
            if (ffm->pts == 0)
                ffm->pts = pts;
            flush_packet(s);
        }
    }
}",0,1,126,1.72,Insert
1801,"static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
                struct vmsvga_cursor_definition_s *c)
{
    QEMUCursor *qc;
    int i, pixels;
    qc = cursor_alloc(c->width, c->height);
    qc->hot_x = c->hot_x;
    qc->hot_y = c->hot_y;
    switch (c->bpp) {
    case 1:
        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,
                        1, (void*)c->mask);
#ifdef DEBUG
        cursor_print_ascii_art(qc, ""vmware/mono"");
#endif
        break;
    case 32:
        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,
                        1, (void*)c->mask);
        pixels = c->width * c->height;
        for (i = 0; i < pixels; i++) {
            qc->data[i] |= c->image[i] & 0xffffff;
        }
#ifdef DEBUG
        cursor_print_ascii_art(qc, ""vmware/32bit"");
#endif
        break;
    default:
        fprintf(stderr, ""%s: unhandled bpp %d, using fallback cursor\n"",
                __FUNCTION__, c->bpp);
        cursor_put(qc);
        qc = cursor_builtin_left_ptr();
    }
    dpy_cursor_define(s->vga.ds, qc);
    cursor_put(qc);
}","static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
                struct vmsvga_cursor_definition_s *c)
{
    QEMUCursor *qc;
    int i, pixels;
    qc = cursor_alloc(c->width, c->height);
    int a = 2;
    int b = 2;
    GF_Filter *process;
    AvahiLookupFlags *flags;
    const char *domain;
    AvahiServer *s_4;
    if (!s_4->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s_4->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    while (a == b) {
        qc->hot_x = c->hot_x;
        b += 1;
    }
    qc->hot_y = c->hot_y;
    switch (c->bpp) {
    case 1:
        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,
                        1, (void*)c->mask);
#ifdef DEBUG
        cursor_print_ascii_art(qc, ""vmware/mono"");
#endif
        break;
    case 32:
        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,
                        1, (void*)c->mask);
        pixels = c->width * c->height;
        for (i = 0; i < pixels; i++) {
            qc->data[i] |= c->image[i] & 0xffffff;
        }
#ifdef DEBUG
        cursor_print_ascii_art(qc, ""vmware/32bit"");
#endif
        break;
    default:
        fprintf(stderr, ""%s: unhandled bpp %d, using fallback cursor\n"",
                __FUNCTION__, c->bpp);
        cursor_put(qc);
        qc = cursor_builtin_left_ptr();
    }
    dpy_cursor_define(s->vga.ds, qc);
    cursor_put(qc);
}",0,1,76,1.45,Insert
1802,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,
                                          ptrdiff_t stride)
{
    int i;
    pixel *pix = (pixel*)_pix;
    const dctcoef *block = (const dctcoef*)_block;
    stride >>= sizeof(pixel)-1;
    for(i=0; i<4; i++){
        pixel v = pix[-1];
        pix[0]= v += block[0];
        pix[1]= v += block[1];
        pix[2]= v += block[2];
        pix[3]= v +  block[3];
        pix+= stride;
        block+= 4;
    }
}","static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,
                                          ptrdiff_t stride)
{
    int size;
    const uint8_t *buf;
    const uint8_t *t, *p_ad;
    p_ad = buf + size;
    int i;
    DeviceState *mem = NULL;
    GF_BitStream *bs;
    GF_Box *s;
    u32 len;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
    if (cap->item_name) {
    		len = (u32) strlen(cap->item_name)+1;
    		gf_bs_write_data(bs, cap->item_name, len);
    	} else {
    		gf_bs_write_byte(bs, 0, 1);
    }
    SysBusDevice *busDev;
    const AVFrame *capt;
    const AVFrame *const p_9 = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p_9->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff3c000);
    struct socket *sock;
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    int protocol;
    struct object *object;
    struct sock *ock;
    struct sock *ock;
    ock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);
    pixel *pix = (pixel*)_pix;
    int a = 2;
    int b = 2;
    struct tty_struct *reader;
    struct awm *awm = reader->driver_data;
    struct acm_wb *sth;
    struct awm *awm = reader->driver_data;
    if (sth->len == awm->writesize) {
    		acm_tty_flush_chars(reader);
    		goto overflow;
    }
    while (a == b) {
        const dctcoef *block = (const dctcoef*)_block;
        b += 1;
    }
    stride >>= sizeof(pixel)-1;
    for(i=0; i<4; i++){
        pixel v = pix[-1];
        pix[0]= v += block[0];
        pix[1]= v += block[1];
        pix[2]= v += block[2];
        pix[3]= v +  block[3];
        pix+= stride;
        block+= 4;
    }
}",0,1,254,1.86,Insert
1803,"static void set_proc_name(const char *s)
{
#ifdef __linux__
    char name[16];
    if (!s)
        return;
    name[sizeof(name) - 1] = 0;
    strncpy(name, s, sizeof(name));
    prctl(PR_SET_NAME, name);
#endif    	
}","static void set_proc_name(const char *s)
{
#ifdef __linux__
    char str[] = ""Constant"";
    brcmf_dbg(TRACE, ""enter: %s type %d
    "", name_7, length);
    if (strlen(str) > 0) {
        char name[16];
    }
    if (!s)
        return;
    name[sizeof(name) - 1] = 0;
    strncpy(name, s, sizeof(name));
    prctl(PR_SET_NAME, name);
#endif    	
}",0,1,9,0.44,Insert
1804,,,,,,,
1805,"int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)
{
    cl_int status;
    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,
                                      CL_TRUE,CL_MAP_READ, 0, buf_size,
                                      0, NULL, NULL, &status);
    if (status != CL_SUCCESS) {
        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));
        return AVERROR_EXTERNAL;
    }
    memcpy(dst_buf, mapped, buf_size);
    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);
    if (status != CL_SUCCESS) {
        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));
        return AVERROR_EXTERNAL;
    }
    return 0;
}","int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)
{
    cl_int status;
    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,
                                      CL_TRUE,CL_MAP_READ, 0, buf_size,
                                      0, NULL, NULL, &status);
    if (status != CL_SUCCESS) {
        int a = 2;
        int b = 2;
        if (a == b) {
            av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));
        }
        return AVERROR_EXTERNAL;
    }
    memcpy(dst_buf, mapped, buf_size);
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (key) {
            if (!server_config_defined_vars) {
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);
    QEMUMachineInitArgs *args;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    if (status != CL_SUCCESS) {
        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));
        return AVERROR_EXTERNAL;
    }
    return 0;
}",0,1,102,1.18,Insert
1806,,,,,,,
1807,"static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,
                        uint32_t size)
{
    AVIOContext *pb = s->pb;
    char key[5]     = { 0 };
    char *value;
    size += (size & 1);
    if (size == UINT_MAX)
        return AVERROR(EINVAL);
    value = av_malloc(size + 1);
    if (!value)
        return AVERROR(ENOMEM);
    avio_read(pb, value, size);
    value[size] = 0;
    AV_WL32(key, tag);
    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,
                       AV_DICT_DONT_STRDUP_VAL);
}","static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,
                        uint32_t size)
{
    AVIOContext *pb = s->pb;
    char key[5]     = { 0 };
    char *value;
    size += (size & 1);
    if (size == UINT_MAX)
        return AVERROR(EINVAL);
    value = av_malloc(size + 1);
    if (!value)
        return AVERROR(ENOMEM);
    avio_read(pb, value, size);
    int a = 2;
    int b = 3;
    while (a != b) {
        value[size] = 0;
        b = a;
    }
    AV_WL32(key, tag);
    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,
                       AV_DICT_DONT_STRDUP_VAL);
}",0,1,10,0.15,Replace
1809,,,,,,,
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    QObjectInputVisitor *qiv = to_qiv(v);
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    QBool *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = qbool_get_bool(qbool);
}","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    QObjectInputVisitor *qiv = to_qiv(v);
    int a = 2;
    int b = 3;
    while (a < b) {
        QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
        b = a;
    }
    QBool *qbool;
    if (!qobj) {
        return;
        BlockAIOCBCoroutine *acb;
        acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, fp, opaque);
        acb->child = child;
        acb->need_bh = true;
        acb->req.error = -EINPROGRESS;
        acb->req.sector = sector___name;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = qbool_get_bool(qbool);
}",1,0,16,0.53,Insert
1812,"int select_watchdog(const char *p)
{
    WatchdogTimerModel *model;
    QemuOpts *opts;
    if (strcmp(p, ""?"") == 0) {
        LIST_FOREACH(model, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s\n"",
                     model->wdt_name, model->wdt_description);
        }
        return 2;
    }
    LIST_FOREACH(model, &watchdog_list, entry) {
        if (strcasecmp(model->wdt_name, p) == 0) {
            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");
    LIST_FOREACH(model, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s\n"",
                 model->wdt_name, model->wdt_description);
    }
    return 1;
}","int select_watchdog(const char *p)
{
    WatchdogTimerModel *model;
    QemuOpts *opts;
    char *filename;
    long load_limit, fw_size;
    if (fw_size <= 0) {
            error_report(""Could not load LPAR firmware '%s'"", filename);
            exit(1);
    }
    bool use_pubs;
    const struct smb_filename *smb_fhandle;
    uint32_t access_mask;
    struct connection_struct *connected;
    uint32_t rejected_share_error;
    uint32_t rejected_mask = access_mask;
    struct security_descriptor *sd = NULL;
    NTSTATUS success;
    rejected_share_error = access_mask & ~(connected->share_access);
    success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
    			(SECINFO_OWNER |
    			SECINFO_GROUP |
    			 SECINFO_DACL), talloc_tos(), &sd);
    			 Image *image;
    			 const LayerInfo* layer_info;
    			 int wb;
    			 uint32_t lvcall;
    			 CPUState *env;
    			 unsigned int valpages;
    			 uint32_t r_cause;
    			 int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    			 uint32_t tlb_vpn, tlb_pfn = 0;
    			 uint32_t tlb_vpn, tlb_pfn = 0;
    			 uint32_t pid, lo, hi;
    			 int set, match = 0;
    			 r_cause = env->sregs[SFR_R_MM_CAUSE];
    			 D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    			 		  "" %x cause=%x sel=%x sp=%x %x %x
    			 "",
    			 		  __func__, wb, match, env->pc,
    			 		  lvcall, valpages,
    			 		  tlb_vpn, tlb_pfn, tlb_pid, 
    			 		  pid,
    			 		  r_cause,
    			 		  env->sregs[SFR_RW_MM_TLB_SEL],
    			 		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    			 const size_t url;
    			 MagickOffsetType
    			     offset;
    			 MagickStatusType
    			     status;
    			 if (status == MagickFalse)
    			     SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    success = se_file_access_check(sd,
    				get_current_nttok(connected),
    				use_pubs,
    				(access_mask & ~do_not_check_mask),
    				&rejected_mask);
    if (strcmp(p, ""?"") == 0) {
        LIST_FOREACH(model, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s\n"",
                     model->wdt_name, model->wdt_description);
        }
        return 2;
    }
    LIST_FOREACH(model, &watchdog_list, entry) {
        if (strcasecmp(model->wdt_name, p) == 0) {
            int a = 51;
            int b = a;
            if(a*b>0){
                opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            }
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p_4,
            *xml;
        xml=FileToString(filename_9,~0UL,exception);
        quantization_tables=NewXMLTree(xml,exception);
        xml=DestroyString(xml);
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");
    LIST_FOREACH(model, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s\n"",
                 model->wdt_name, model->wdt_description);
    }
    return 1;
}",0,1,144,1.61,Insert
1813,"static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
{
    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
    VirtQueueElement elem;
    MemoryRegionSection section;
    while (virtqueue_pop(vq, &elem)) {
        size_t offset = 0;
        uint32_t pfn;
        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {
            ram_addr_t pa;
            ram_addr_t addr;
            int p = virtio_ldl_p(vdev, &pfn);
            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;
            offset += 4;
            section = memory_region_find(get_system_memory(), pa, 1);
            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))
                continue;
            trace_virtio_balloon_handle_output(memory_region_name(section.mr),
                                               pa);
            addr = section.offset_within_region;
            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,
                         !!(vq == s->dvq));
            memory_region_unref(section.mr);
        }
        virtqueue_push(vq, &elem, offset);
        virtio_notify(vdev, vq);
    }
}","static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
{
    int a = 2;
    int b = 2;
    Unit *u;
    const char *nptr;
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    Unit *other;
    Automount *worker = AUTOMOUNT(u);
    if (MOUNT(other)->state == MOUNT_DEAD)
                    (void) automount_send_ready(worker, worker->expire_tokens, 0);
                    int c, cnt;
                    int val;
                    struct timeval t1, t2;
                    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
                    int64_t alpha;
                    int total = 0;
                    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    while (a == b) {
        VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
        b += 1;
        scoped_refptr<IndexedDBCallbacks> Callcallback;
        IndexedDBTransaction* intermission;
        int64_t object_store_id;
        intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                                   this, object_store_id, Callcallback));
    }
    VirtQueueElement elem;
    MemoryRegionSection section;
    while (virtqueue_pop(vq, &elem)) {
        size_t offset = 0;
        uint32_t pfn;
        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {
            ram_addr_t pa;
            ram_addr_t addr;
            int p = virtio_ldl_p(vdev, &pfn);
            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;
            offset += 4;
            section = memory_region_find(get_system_memory(), pa, 1);
            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))
                continue;
            trace_virtio_balloon_handle_output(memory_region_name(section.mr),
                                               pa);
            addr = section.offset_within_region;
            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,
                         !!(vq == s->dvq));
            memory_region_unref(section.mr);
        }
        virtqueue_push(vq, &elem, offset);
        virtio_notify(vdev, vq);
    }
}",0,1,122,1.7,Insert
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)
{
    int len;
    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;
    if (block_mig_state.zero_blocks &&
        buffer_is_zero(blk->buf, BLOCK_SIZE)) {
        flags |= BLK_MIG_FLAG_ZERO_BLOCK;
    }
    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)
                     | flags);
    len = strlen(bdrv_get_device_name(blk->bmds->bs));
    qemu_put_byte(f, len);
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);
    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {
        qemu_fflush(f);
        return;
    }
    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);
}","static void blk_send(QEMUFile *f, BlkMigBlock * blk)
{
    int len;
    int a = 2;
    int b = 3;
    while (a < b) {
        uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;
        b = a;
    }
    if (block_mig_state.zero_blocks &&
        buffer_is_zero(blk->buf, BLOCK_SIZE)) {
        flags |= BLK_MIG_FLAG_ZERO_BLOCK;
        SSL *ses;
        int al, ind, ind;
        long i, param_len, f_6, alg_k, alg_a;
        f_6 = ses->method->ssl_get_message(ses,
                                           SSL3_ST_CR_KEY_EXCH_A,
                                           SSL3_ST_CR_KEY_EXCH_B,
                                           -1, ses->max_cert_list, &ind);
    }
    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)
                     | flags);
    len = strlen(bdrv_get_device_name(blk->bmds->bs));
    qemu_put_byte(f, len);
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);
    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {
        qemu_fflush(f);
        return;
    }
    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);
}",1,0,23,0.92,Insert
1816,,,,,,,
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *property, const char *string)
{
    int offset;
    offset = fdt_path_offset(fdt, node_path);
    if (offset < 0)
        return offset;
    return fdt_setprop_string(fdt, offset, property, string);
}","int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *property, const char *string)
{
    int offset;
    int a = 2;
    int b = 3;
    while (a < b) {
        offset = fdt_path_offset(fdt, node_path);
        b = a;
    }
    if (offset < 0)
        return offset;
    return fdt_setprop_string(fdt, offset, property, string);
}",1,0,1,0.06,Replace
1818,,,,,,,
1819,,,,,,,
1820,,,,,,,
1821,,,,,,,
1822,,,,,,,
1825,,,,,,,
1826,"int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)
{
    unsigned int idx, rec_off, old_idx, new_idx;
    uint32_t rec_len = sizeof(TraceRecord) + datasize;
    uint64_t event_u64 = event;
    uint64_t timestamp_ns = get_clock();
    do {
        old_idx = g_atomic_int_get(&trace_idx);
        smp_rmb();
        new_idx = old_idx + rec_len;
        if (new_idx - writeout_idx > TRACE_BUF_LEN) {
            g_atomic_int_inc(&dropped_events);
            return -ENOSPC;
        }
    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));
    idx = old_idx % TRACE_BUF_LEN;
    rec_off = idx;
    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
    rec->tbuf_idx = idx;
    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
    return 0;
}","int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)
{
    unsigned int idx, rec_off, old_idx, new_idx;
    uint32_t rec_len = sizeof(TraceRecord) + datasize;
    int a = 2;
    int b = 3;
    while (a < b) {
        uint64_t event_u64 = event;
        b = a;
    }
    uint64_t timestamp_ns = get_clock();
    do {
        old_idx = g_atomic_int_get(&trace_idx);
        smp_rmb();
        new_idx = old_idx + rec_len;
        if (new_idx - writeout_idx > TRACE_BUF_LEN) {
            g_atomic_int_inc(&dropped_events);
            return -ENOSPC;
        }
    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));
    idx = old_idx % TRACE_BUF_LEN;
    rec_off = idx;
    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
    rec->tbuf_idx = idx;
    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
    return 0;
}",1,0,11,0.2,Replace
1828,,,,,,,
1829,,,,,,,
1830,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)
{
    DynBuffer *d = opaque;
    int new_size, new_allocated_size;
    UINT8 *new_buffer;
    new_size = d->pos + buf_size;
    new_allocated_size = d->allocated_size;
    while (new_size > new_allocated_size) {
        if (!new_allocated_size)
            new_allocated_size = new_size;
        else
            new_allocated_size = (new_allocated_size * 3) / 2;
    }
    if (new_allocated_size > d->allocated_size) {
        new_buffer = av_malloc(new_allocated_size);
        if (!new_buffer)
            return;
        memcpy(new_buffer, d->buffer, d->size);
        av_free(d->buffer);
        d->buffer = new_buffer;
        d->allocated_size = new_allocated_size;
    }
    memcpy(d->buffer + d->pos, buf, buf_size);
    d->pos = new_size;
    if (d->pos > d->size)
        d->size = d->pos;
}","static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)
{
    DynBuffer *d = opaque;
    int new_size, new_allocated_size;
    UINT8 *new_buffer;
    new_size = d->pos + buf_size;
    new_allocated_size = d->allocated_size;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    while (new_size > new_allocated_size) {
        if (!new_allocated_size)
            new_allocated_size = new_size;
        else
            new_allocated_size = (new_allocated_size * 3) / 2;
    }
    if (new_allocated_size > d->allocated_size) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            new_buffer = av_malloc(new_allocated_size);
        strcpy(str, ""a"");
        }
        if (!new_buffer)
            return;
        memcpy(new_buffer, d->buffer, d->size);
        av_free(d->buffer);
        d->buffer = new_buffer;
        d->allocated_size = new_allocated_size;
    }
    memcpy(d->buffer + d->pos, buf, buf_size);
    d->pos = new_size;
    if (d->pos > d->size)
        d->size = d->pos;
}",0,1,37,1.11,Insert
1832,"static int hex_to_data(uint8_t *data, const char *p)
{
    int c, len, v;
    len = 0;
    v = 1;
    for(;;) {
        skip_spaces(&p);
        if (*p == '\0')
            break;
        c = toupper((unsigned char)*p++);
        if (c >= '0' && c <= '9')
            c = c - '0';
        else if (c >= 'A' && c <= 'F')
            c = c - 'A' + 10;
        else
            break;
        v = (v << 4) | c;
        if (v & 0x100) {
            if (data)
                data[len] = v;
            len++;
            v = 1;
        }
    }
    return len;
}","static int hex_to_data(uint8_t *data, const char *p)
{
    int c, len, v;
    len = 0;
    v = 1;
    for(;;) {
        skip_spaces(&p);
        if (*p == '\0')
            break;
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            c = toupper((unsigned char)*p++);
        strcpy(str, ""a"");
        }
        if (c >= '0' && c <= '9')
            c = c - '0';
        else if (c >= 'A' && c <= 'F')
            c = c - 'A' + 10;
        else
            break;
        v = (v << 4) | c;
        if (v & 0x100) {
            if (data)
                data[len] = v;
            len++;
            v = 1;
        }
    }
    return len;
}",0,1,5,0.16,Replace
1836,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);","static void bitmap_free(Qcow2Bitmap *bm)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        g_free(bm->name);
        b += 1;
    }
    g_free(bm);",1,0,1,0.03,Replace
1838,"static int ftp_passive_mode_epsv(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r\n"";
    static const int epsv_codes[] = {229, 0};
    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!start || !end)
        goto fail;
    *end = '\0';
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)
        goto fail;
    start += 3;
    end[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->server_data_port = -1;
    return AVERROR(ENOSYS);
}","static int ftp_passive_mode_epsv(FTPContext *s)
{
    char str[] = ""Constant"";
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (strlen(str) > 5) {
        char *res = NULL, *start = NULL, *end = NULL;
    strcpy(str, ""a"");
    }
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r\n"";
    static const int epsv_codes[] = {229, 0};
    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!start || !end)
        goto fail;
    *end = '\0';
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)
        goto fail;
    start += 3;
    end[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->server_data_port = -1;
    return AVERROR(ENOSYS);
}",0,1,85,1.44,Insert
1839,"static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    memcpy(packet->data, buf, size);
    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
}","static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    memcpy(packet->data, buf, size);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_bug_9;
        BlockdevOnError on_source_complete_1;
        const char *dev_9;
        enum MirrorSyncMode stage_9;
        int64_t peed_1;
        const char *data_10;
        int data_10;
        Error *localxer_8 = NULL;
        BlockDriverState *source_vs_3;
        int64_t store_2;
        BlockDriverState *bes_5;
        bes_5 = bdrv_find_5(dev_9);
        data_10 = bes_5->open_flags | BDRV_O_RDWR_3;
        store_2 = bdrv_getlength_6(bes_5);
        backup_start_3(bes_5, source_vs_3, peed_1, stage_9, on_source_bug_9, on_source_complete_1,
                         block_job_cb_4, bes_5, &localxer_8);
        BlockdevOnError on_source_complete;
        char *filename;
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
    strcpy(str, ""a"");
    }
}",0,1,82,0.82,Insert
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)
{
    return 0;
}","static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)
{
    char str[] = ""Constant"";
    QDict *rss, *lst, *resource, *vne, *acl, *diffen;
    QObject *row, *reader;
    reader = qdict_crumple(rss, &error_abort);
    QDECREF(rss);
    if (strlen(str) > 0) {
        return 0;
    }
}",0,1,8,0.18,Insert
1841,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,
                             uint8_t *addrs, uint8_t *buf)
{
    uint32_t sum = 0;
    sum += net_checksum_add(length, buf);          
    sum += net_checksum_add(8, addrs);             
    sum += proto + length;                         
    return net_checksum_finish(sum);
}","uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,
                             uint8_t *addrs, uint8_t *buf)
{
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i, size, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size   = put_bits_count(&pb) >> 3;
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    int a = 51;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    int b = a;
    if(a*b>0){
        uint32_t sum = 0;
    }
    sum += net_checksum_add(length, buf);          
    sum += net_checksum_add(8, addrs);             
    sum += proto + length;                         
    return net_checksum_finish(sum);
}",0,1,72,0.71,Insert
1842,"void cpu_loop_exit(CPUState *env1)
{
    env1->current_tb = NULL;
    longjmp(env1->jmp_env, 1);
}","void cpu_loop_exit(CPUState *env1)
{
    env1->current_tb = NULL;
    char str[] = ""Constant"";
    UserDefAnonUnion *var = NULL;
    Visitor *V;
    Error * erP = NULL;
    visit_type_UserDefAnonUnion(V, &var, NULL, & erP);
    g_assert(error_is_set(& erP));
    if (strlen(str) > 0) {
        longjmp(env1->jmp_env, 1);
    }
}",0,1,18,0.25,Insert
1845,,,,,,,
1848,,,,,,,
1849,"static int rle_unpack(const unsigned char *src, unsigned char *dest,
                      int src_count, int src_size, int dest_len)
{
    unsigned char *pd;
    int i, l;
    unsigned char *dest_end = dest + dest_len;
    GetByteContext gb;
    bytestream2_init(&gb, src, src_size);
    pd = dest;
    if (src_count & 1) {
        if (bytestream2_get_bytes_left(&gb) < 1)
            return 0;
        *pd++ = bytestream2_get_byteu(&gb);
    }
    src_count >>= 1;
    i = 0;
    do {
        if (bytestream2_get_bytes_left(&gb) < 1)
            break;
        l = bytestream2_get_byteu(&gb);
        if (l & 0x80) {
            l = (l & 0x7F) * 2;
            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)
                return bytestream2_tell(&gb);
            bytestream2_get_bufferu(&gb, pd, l);
            pd += l;
        } else {
            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)
                return bytestream2_tell(&gb);
            for (i = 0; i < l; i++) {
                *pd++ = bytestream2_get_byteu(&gb);
                *pd++ = bytestream2_get_byteu(&gb);
            }
            bytestream2_skip(&gb, 2);
        }
        i += l;
    } while (i < src_count);
    return bytestream2_tell(&gb);
}","static int rle_unpack(const unsigned char *src, unsigned char *dest,
                      int src_count, int src_size, int dest_len)
{
    unsigned char *pd;
    int i, l;
    AvahiLookupFlags *flags_10;
    const char *domain_1;
    AvahiServer *s_4;
    if (!s_4->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers_10(s_4->wide_area_lookup_engine) ||
            avahi_domain_ends_with_4(domain_1, AVAHI_MDNS_SUFFIX_LOCAL_7) ||
            avahi_domain_ends_with_4(domain_1, AVAHI_MDNS_SUFFIX_ADDR_IPV4_3) ||
            avahi_domain_ends_with_4(domain_1, AVAHI_MDNS_SUFFIX_ADDR_IPV6_8))
            *flags_10 |= AVAHI_LOOKUP_USE_MULTICAST_9;
        else
            *flags_10 |= AVAHI_LOOKUP_USE_WIDE_AREA_10;
    unsigned char *dest_end = dest + dest_len;
    GetByteContext gb;
    int a = 2;
    int b = 3;
    int c, cnt;
    AvahiLookupFlags *flags;
    const char *domain;
    AvahiServer *s;
    if (!s->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    while (a != b) {
        bytestream2_init(&gb, src, src_size);
        b = a;
    }
    pd = dest;
    if (src_count & 1) {
        if (bytestream2_get_bytes_left(&gb) < 1)
            return 0;
        *pd++ = bytestream2_get_byteu(&gb);
    }
    src_count >>= 1;
    i = 0;
    do {
        if (bytestream2_get_bytes_left(&gb) < 1)
            break;
        l = bytestream2_get_byteu(&gb);
        if (l & 0x80) {
            l = (l & 0x7F) * 2;
            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)
                return bytestream2_tell(&gb);
            bytestream2_get_bufferu(&gb, pd, l);
            pd += l;
        } else {
            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)
                return bytestream2_tell(&gb);
            for (i = 0; i < l; i++) {
                *pd++ = bytestream2_get_byteu(&gb);
                *pd++ = bytestream2_get_byteu(&gb);
            }
            bytestream2_skip(&gb, 2);
        }
        i += l;
    } while (i < src_count);
    return bytestream2_tell(&gb);
}",0,1,111,1.98,Insert
1850,"static int recheck_discard_flags(AVFormatContext *s, int first)
{
    HLSContext *c = s->priv_data;
    int i, changed = 0;
    for (i = 0; i < c->n_playlists; i++)
        c->playlists[i]->cur_needed = 0;
    for (i = 0; i < s->nb_streams; i++) {
        AVStream *st = s->streams[i];
        struct playlist *pls = c->playlists[s->streams[i]->id];
        if (st->discard < AVDISCARD_ALL)
            pls->cur_needed = 1;
    }
    for (i = 0; i < c->n_playlists; i++) {
        struct playlist *pls = c->playlists[i];
        if (pls->cur_needed && !pls->needed) {
            pls->needed = 1;
            changed = 1;
            pls->cur_seq_no = select_cur_seq_no(c, pls);
            pls->pb.eof_reached = 0;
            if (c->cur_timestamp != AV_NOPTS_VALUE) {
                pls->seek_timestamp = c->cur_timestamp;
                pls->seek_flags = AVSEEK_FLAG_ANY;
                pls->seek_stream_index = -1;
            }
            av_log(s, AV_LOG_INFO, ""Now receiving playlist %d, segment %d\n"", i, pls->cur_seq_no);
        } else if (first && !pls->cur_needed && pls->needed) {
            if (pls->input)
                ff_format_io_close(pls->parent, &pls->input);
            pls->needed = 0;
            changed = 1;
            av_log(s, AV_LOG_INFO, ""No longer receiving playlist %d\n"", i);
        }
    }
    return changed;
}","static int recheck_discard_flags(AVFormatContext *s, int first)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        HLSContext *c = s->priv_data;
    }
    int i, changed = 0;
    for (i = 0; i < c->n_playlists; i++)
        c->playlists[i]->cur_needed = 0;
    for (i = 0; i < s->nb_streams; i++) {
        AVStream *st = s->streams[i];
        struct playlist *pls = c->playlists[s->streams[i]->id];
        if (st->discard < AVDISCARD_ALL)
            pls->cur_needed = 1;
    }
    for (i = 0; i < c->n_playlists; i++) {
        struct playlist *pls = c->playlists[i];
        AVCodecContext *avctx;
        struct request_list *repl;
        bool lock;
        struct request_queue *q = repl->q;
        struct request_queue *q = repl->q;
        QEMUBH *phi;
        phi = g_malloc0(sizeof(QEMUBH));
        phi->ctx = ctx;
        phi->cb = cb;
        phi->opaque = opaque;
        phi->next = ctx->first_bh;
        q->nr_rqs[lock]--;
        repl->cache[lock]--;
        register ssize_t
            i_9;
        QuantizationTable
            *table;
        ssize_t
            j;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        for (j=i_9; j < 64; j++)
            table->levels[j]=table->levels[j-1];
        __freed_request(repl, lock);
        int sample_scale, c_4, n, i_4;
        MpegEncContext *ses;
        MotionEstContext * const k= &ses->me;
        CharDriverState *chr;
        SpiceCharDriver *sb;
        chr = chr_open(""port"", spice_port_set_fe_open);
        sb = chr->opaque;
        MotionEstContext * const k= &ses->me;
        k->avctx= ses->avctx;
        ff_set_cmp(&ses->dsp, ses->dsp.me_pre_cmp, k->avctx->me_pre_cmp);
        ff_set_cmp(&ses->dsp, ses->dsp.me_cmp, k->avctx->me_cmp);
        ff_set_cmp(&ses->dsp, ses->dsp.me_sub_cmp, k->avctx->me_sub_cmp);
        ff_set_cmp(&ses->dsp, ses->dsp.mb_cmp, k->avctx->mb_cmp);
        int sample_scale, c_4, n, i_4;
        struct fp *fp;
        int pet;
        pet = seq_open(fp, &show_traces_seq_ops);
        PCMDecode *s_9 = avctx->priv_data;
        sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
        n = avctx->channels * sample_scale;
        if (pls->cur_needed && !pls->needed) {
            pls->needed = 1;
            changed = 1;
            pls->cur_seq_no = select_cur_seq_no(c, pls);
            pls->pb.eof_reached = 0;
            if (c->cur_timestamp != AV_NOPTS_VALUE) {
                pls->seek_timestamp = c->cur_timestamp;
                pls->seek_flags = AVSEEK_FLAG_ANY;
                pls->seek_stream_index = -1;
            }
            av_log(s, AV_LOG_INFO, ""Now receiving playlist %d, segment %d\n"", i, pls->cur_seq_no);
        } else if (first && !pls->cur_needed && pls->needed) {
            if (pls->input)
                ff_format_io_close(pls->parent, &pls->input);
            pls->needed = 0;
            changed = 1;
            av_log(s, AV_LOG_INFO, ""No longer receiving playlist %d\n"", i);
        }
    }
    GF_BitStream *bs;
    GF_Box *s_2;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_2;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_2;
    GF_Err e;
    e = gf_isom_full_box_write(s_2, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    return changed;
}",0,1,518,3.89,Insert
1852,,,,,,,
1854,,,,,,,
1856,"static inline unsigned int msi_nr_vectors(uint16_t flags)
{
    return 1U <<
        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));
}","static inline unsigned int msi_nr_vectors(uint16_t flags)
{
    int flags_9;
    RTPContext *http;
    char val[1024];
    if (url_open(&http->rtp_hd, val, flags_9) < 0)
            goto fail;
    return 1U <<
        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));
}",0,1,3,0.13,Insert
1857,"static void openrisc_sim_init(MachineState *machine)
{
    ram_addr_t ram_size = machine->ram_size;
    const char *cpu_model = machine->cpu_model;
    const char *kernel_filename = machine->kernel_filename;
    OpenRISCCPU *cpu = NULL;
    MemoryRegion *ram;
    int n;
    if (!cpu_model) {
        cpu_model = ""or1200"";
    }
    for (n = 0; n < smp_cpus; n++) {
        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));
        qemu_register_reset(main_cpu_reset, cpu);
        main_cpu_reset(cpu);
    }
    ram = g_malloc(sizeof(*ram));
    memory_region_init_ram(ram, NULL, ""openrisc.ram"", ram_size, &error_fatal);
    memory_region_add_subregion(get_system_memory(), 0, ram);
    cpu_openrisc_pic_init(cpu);
    cpu_openrisc_clock_init(cpu);
    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],
                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);
    if (nd_table[0].used) {
        openrisc_sim_net_init(get_system_memory(), 0x92000000,
                              0x92000400, cpu->env.irq[4], nd_table);
    }
    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);
}","static void openrisc_sim_init(MachineState *machine)
{
    ram_addr_t ram_size = machine->ram_size;
    const char *cpu_model = machine->cpu_model;
    const char *kernel_filename = machine->kernel_filename;
    OpenRISCCPU *cpu = NULL;
    int a = 2;
    int b = 3;
    double f;
    f = get_float64 (buffer, &error);
    while (a != b) {
        BlockdevOnError on_source_bug;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        levels=GetXMLTreeChild(table_iterator,""levels"");
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(levels,""width"");
        attribute=GetXMLTreeAttribute(levels,""height"");
        attribute=GetXMLTreeAttribute(levels,""divisor"");
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        MemoryRegion *ram;
        b = a;
    }
    int n;
    if (!cpu_model) {
        cpu_model = ""or1200"";
    }
    for (n = 0; n < smp_cpus; n++) {
        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));
        qemu_register_reset(main_cpu_reset, cpu);
        main_cpu_reset(cpu);
    }
    ram = g_malloc(sizeof(*ram));
    memory_region_init_ram(ram, NULL, ""openrisc.ram"", ram_size, &error_fatal);
    memory_region_add_subregion(get_system_memory(), 0, ram);
    cpu_openrisc_pic_init(cpu);
    cpu_openrisc_clock_init(cpu);
    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],
                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);
    if (nd_table[0].used) {
        openrisc_sim_net_init(get_system_memory(), 0x92000000,
                              0x92000400, cpu->env.irq[4], nd_table);
    }
    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);
}",0,1,94,1.28,Insert
1858,"static void ohci_reset(void *opaque)
{
    OHCIState *ohci = opaque;
    OHCIPort *port;
    int i;
    ohci_bus_stop(ohci);
    ohci->ctl = 0;
    ohci->old_ctl = 0;
    ohci->status = 0;
    ohci->intr_status = 0;
    ohci->intr = OHCI_INTR_MIE;
    ohci->hcca = 0;
    ohci->ctrl_head = ohci->ctrl_cur = 0;
    ohci->bulk_head = ohci->bulk_cur = 0;
    ohci->per_cur = 0;
    ohci->done = 0;
    ohci->done_count = 7;
    ohci->fsmps = 0x2778;
    ohci->fi = 0x2edf;
    ohci->fit = 0;
    ohci->frt = 0;
    ohci->frame_number = 0;
    ohci->pstart = 0;
    ohci->lst = OHCI_LS_THRESH;
    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;
    ohci->rhdesc_b = 0x0;  
    ohci->rhstatus = 0;
    for (i = 0; i < ohci->num_ports; i++)
      {
        port = &ohci->rhport[i];
        port->ctrl = 0;
        if (port->port.dev) {
            usb_attach(&port->port, port->port.dev);
        }
      }
    if (ohci->async_td) {
        usb_cancel_packet(&ohci->usb_packet);
        ohci->async_td = 0;
    }
    DPRINTF(""usb-ohci: Reset %s\n"", ohci->name);
}","static void ohci_reset(void *opaque)
{
    OHCIState *ohci = opaque;
    OHCIPort *port;
    int i;
    ohci_bus_stop(ohci);
    ohci->ctl = 0;
    ohci->old_ctl = 0;
    ohci->status = 0;
    ohci->intr_status = 0;
    ohci->intr = OHCI_INTR_MIE;
    ohci->hcca = 0;
    ohci->ctrl_head = ohci->ctrl_cur = 0;
    ohci->bulk_head = ohci->bulk_cur = 0;
    ohci->per_cur = 0;
    ohci->done = 0;
    ohci->done_count = 7;
    ohci->fsmps = 0x2778;
    ohci->fi = 0x2edf;
    ohci->fit = 0;
    ohci->frt = 0;
    ohci->frame_number = 0;
    ohci->pstart = 0;
    ohci->lst = OHCI_LS_THRESH;
    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;
    ohci->rhdesc_b = 0x0;  
    ohci->rhstatus = 0;
    for (i = 0; i < ohci->num_ports; i++)
      {
        port = &ohci->rhport[i];
        port->ctrl = 0;
        if (port->port.dev) {
            char str[] = ""Constant"";
            DisplayState *ds;
            const struct sun4d_hwdef *hawdecl;
            ram_addr_t gram_size, prom_reset, tcx64off;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
            tcx64off = qemu_ram_alloc(hawdecl->vram_size);
            tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                         hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
            vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                                    hawdecl->nvram_size, 8);
            slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                                      sbi_cpu_arq, smp_cpus);
            slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                          nographic, ESCC_CLOCK, 1);
            while (strlen(str) > 5) {
                usb_attach(&port->port, port->port.dev);
            strcpy(str, ""a"");
            }
        }
      }
    if (ohci->async_td) {
        usb_cancel_packet(&ohci->usb_packet);
        ohci->async_td = 0;
    }
    DPRINTF(""usb-ohci: Reset %s\n"", ohci->name);
}",0,1,50,0.93,Insert
1859,"uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    CPU_DoubleU farg1, farg2;
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&
                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
        }
        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);
    }
    return farg1.ll;
}","uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)
{
    CPU_DoubleU farg1, farg2;
    farg1.ll = arg1;
    farg2.ll = arg2;
    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {
        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);
    } else {
        if (unlikely(float64_is_signaling_nan(farg1.d) ||
                     float64_is_signaling_nan(farg2.d))) {
            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);
            VdpDecoderProfile profile;
            AVCodecContext *AVcas;
            uint32_t input;
            VdpDecoderQueryCapabilities *decoder_query_caps;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpDecoderCreate *create;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpStatus status_7;
            VDPAUHWContext *hwctx = AVcas->hwaccel_context;
            VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
            uint32_t max_level, max_mb, max_width, max_height;
            uint32_t max_level, max_mb, max_width, max_height;
            void *pack;
            VdpBool supported;
            status_7 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                            &max_mb, &max_width, &max_height);
            status_7 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                                 &pack);
            status_7 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                                 &pack);
            status_7 = create(hdtx->device, profile, width, input, AVcas->refs,
                                &hdtx->decoder);
        }
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);
        }
    }
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    return farg1.ll;
}",0,1,88,0.96,Insert
1860,,,,,,,
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefAnonUnion *tmp = NULL;
    Visitor *v;
    Error *errp = NULL;
    v = validate_test_init(data, ""3.14"");
    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefAnonUnion(tmp);
}","static void test_validate_fail_union_anon(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefAnonUnion *tmp = NULL;
    char str[] = ""Constant"";
    SysBusDevice *b;
    apr_pool_t *pid;
    apr_pool_cleanup_register(pid, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
    if (i) {
            sysbus_mmio_map(b, 0, i);
    }
    if (strlen(str) > 0) {
        Visitor *v;
    }
    Error *errp = NULL;
    v = validate_test_init(data, ""3.14"");
    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefAnonUnion(tmp);
}",0,1,45,0.49,Insert
1863,,,,,,,
1864,,,,,,,
1866,"static USBDevice *usb_msd_init(const char *filename)
{
    static int nr=0;
    char id[8];
    QemuOpts *opts;
    DriveInfo *dinfo;
    USBDevice *dev;
    int fatal_error;
    const char *p1;
    char fmt[32];
    snprintf(id, sizeof(id), ""usb%d"", nr++);
    opts = qemu_opts_create(&qemu_drive_opts, id, 0);
    p1 = strchr(filename, ':');
    if (p1++) {
        const char *p2;
        if (strstart(filename, ""format="", &p2)) {
            int len = MIN(p1 - p2, sizeof(fmt));
            pstrcpy(fmt, len, p2);
            qemu_opt_set(opts, ""format"", fmt);
        } else if (*filename != ':') {
            printf(""unrecognized USB mass-storage option %s\n"", filename);
        filename = p1;
    if (!*filename) {
        printf(""block device specification needed\n"");
    qemu_opt_set(opts, ""file"", filename);
    qemu_opt_set(opts, ""if"", ""none"");
    dinfo = drive_init(opts, NULL, &fatal_error);
    if (!dinfo) {
        qemu_opts_del(opts);
    dev = usb_create(NULL  , ""usb-storage"");
    qdev_prop_set_drive(&dev->qdev, ""drive"", dinfo);
    if (qdev_init(&dev->qdev) < 0)
    return dev;","static USBDevice *usb_msd_init(const char *filename)
{
    static int nr=0;
    char id[8];
    QemuOpts *opts;
    DriveInfo *dinfo;
    USBDevice *dev;
    int fatal_error;
    const char *p1;
    char fmt[32];
    snprintf(id, sizeof(id), ""usb%d"", nr++);
    opts = qemu_opts_create(&qemu_drive_opts, id, 0);
    p1 = strchr(filename, ':');
    if (p1++) {
        const char *p2;
        if (strstart(filename, ""format="", &p2)) {
            int len = MIN(p1 - p2, sizeof(fmt));
            pstrcpy(fmt, len, p2);
            qemu_opt_set(opts, ""format"", fmt);
        } else if (*filename != ':') {
            printf(""unrecognized USB mass-storage option %s\n"", filename);
        filename = p1;
    if (!*filename) {
        printf(""block device specification needed\n"");
    qemu_opt_set(opts, ""file"", filename);
    qemu_opt_set(opts, ""if"", ""none"");
    dinfo = drive_init(opts, NULL, &fatal_error);
    if (!dinfo) {
        qemu_opts_del(opts);
    int a = 2;
    int b = 2;
    SCSIDiskState *s;
    int bus_num;
    USBHostDevice *dev_8;
    int addr;
    int fd = -1, ret;
    fd = usb_host_open_device(bus_num, addr);
    dev_8->fd = fd;
    dev_8->descr_len = read(fd, dev_8->descr, sizeof(dev_8->descr));
    qemu_set_fd_handler(dev_8->fd, NULL, async_complete, dev_8);
    SCSIDiskReq *r;
    while (!QTAILQ_EMPTY(&s->qdev.requests)) {
            r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));
            if (r->req.aiocb) {
                bdrv_aio_cancel(r->req.aiocb);
            }
            scsi_remove_request(r);
    }
    while (a == b) {
        dev = usb_create(NULL  , ""usb-storage"");
        b += 1;
    }
    qdev_prop_set_drive(&dev->qdev, ""drive"", dinfo);
    if (qdev_init(&dev->qdev) < 0)
    return dev;",1,0,75,1.56,Insert
1868,,,,,,,
1870,"static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,
                                unsigned size)
{
    CMD646BAR *cmd646bar = opaque;
    if (addr != 2 || size != 1) {
        return ((uint64_t)1 << (size * 8)) - 1;
    }
    return ide_status_read(cmd646bar->bus, addr + 2);
}","static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,
                                unsigned size)
{
    CMD646BAR *cmd646bar = opaque;
    Unit *u;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    Unit *other;
    int range;
    Automount *worker = AUTOMOUNT(u);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    range = automount_start_expire(worker);
                    struct edgeport_serial *serial;
                    u8 *data;
                    struct device *dev = &serial->serial->dev->dev;
                    struct device *dev = &serial->serial->dev->dev;
                    int status;
                    data = kmalloc(1, GFP_KERNEL);
                    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
                    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
                    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
                    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    if (addr != 2 || size != 1) {
        return ((uint64_t)1 << (size * 8)) - 1;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return ide_status_read(cmd646bar->bus, addr + 2);
        b += 1;
    }
}",0,1,84,0.79,Insert
1874,"void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)
{
    int cssid, ssid, schid, m;
    SubchDev *sch;
    SCHIB schib;
    uint64_t addr;
    int ret = -ENODEV;
    int cc;
    CPUS390XState *env = &cpu->env;
    uint8_t ar;
    addr = decode_basedisp_s(env, ipb, &ar);
    if (addr & 3) {
        program_interrupt(env, PGM_SPECIFICATION, 2);
        return;
    }
    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {
        return;
    }
    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||
        !ioinst_schib_valid(&schib)) {
        program_interrupt(env, PGM_OPERAND, 2);
        return;
    }
    trace_ioinst_sch_id(""msch"", cssid, ssid, schid);
    sch = css_find_subch(m, cssid, ssid, schid);
    if (sch && css_subch_visible(sch)) {
        ret = css_do_msch(sch, &schib);
    }
    switch (ret) {
    case -ENODEV:
        cc = 3;
        break;
    case -EBUSY:
        cc = 2;
        break;
    case 0:
        cc = 0;
        break;
    default:
        cc = 1;
        break;
    }
    setcc(cpu, cc);
}","void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)
{
    int cssid, ssid, schid, m;
    SubchDev *sch;
    SCHIB schib;
    uint64_t addr;
    int ret = -ENODEV;
    int cc;
    int a = 86;
    int b = a;
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {
            error_report(""Could not load LPAR rtas '%s'"", filename);
            struct client_session *c;
            int http_status;
            struct session_request *sr;
            struct mk_list *host_list = &config->hosts;
            struct mk_list *sr_list = &c->request_list;
            if (http_status > 0) {
                    if (!sr->host_conf) {
                        int wb;
                        uint32_t lvcall;
                        CPUState *env_5;
                        unsigned int valpages;
                        uint32_t r_cause;
                        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
                        uint32_t tlb_vpn, tlb_pfn = 0;
                        uint32_t tlb_vpn, tlb_pfn = 0;
                        uint32_t pid_7, lo, hi;
                        int set, match = 0;
                        r_cause = env_5->sregs[SFR_R_MM_CAUSE];
                        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
                        		  "" %x cause=%x sel=%x sp=%x %x %x
                        "",
                        		  __func__, wb, match, env_5->pc,
                        		  lvcall, valpages,
                        		  tlb_vpn, tlb_pfn, tlb_pid, 
                        		  pid_7,
                        		  r_cause,
                        		  env_5->sregs[SFR_RW_MM_TLB_SEL],
                        		  env_5->regs[R_SP], env_5->pregs[PR_USP], env_5->ksp));
                        sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
                    }
                    mk_request_error(http_status, c, sr);
                    mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                        NULL, c, sr);
            }
            exit(1);
    }
    if(a*b>0){
        CPUS390XState *env = &cpu->env;
        struct edgeport_serial *serial;
        int cpu_9;
        int mult;
        mult = 1 << cpu_9;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        GF_Filter *process;
        GF_FilterPid *pid;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
        gf_filter_pid_set_udta(pid, git->out_pid);
        git->file_size = 0;
        git->load_flags = 0;
        int status;
        data = kmalloc(1, GFP_KERNEL);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    }
    uint8_t ar;
    addr = decode_basedisp_s(env, ipb, &ar);
    if (addr & 3) {
        program_interrupt(env, PGM_SPECIFICATION, 2);
        return;
    }
    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {
        return;
    }
    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||
        !ioinst_schib_valid(&schib)) {
        program_interrupt(env, PGM_OPERAND, 2);
        return;
    }
    trace_ioinst_sch_id(""msch"", cssid, ssid, schid);
    sch = css_find_subch(m, cssid, ssid, schid);
    if (sch && css_subch_visible(sch)) {
        ret = css_do_msch(sch, &schib);
    }
    switch (ret) {
    case -ENODEV:
        cc = 3;
        break;
    case -EBUSY:
        cc = 2;
        break;
    case 0:
        cc = 0;
        break;
    default:
        cc = 1;
        break;
    }
    setcc(cpu, cc);
}",0,1,1057,6.38,Insert
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
        int flags)
{
    int i;
    cpu_fprintf(f, ""PC=%08x\n"", env->pc);
    for (i = 0; i < 16; ++i) {
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '\n' : ' ');
    }
}","void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
        int flags)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        int i;
        b = a;
    }
    cpu_fprintf(f, ""PC=%08x\n"", env->pc);
    for (i = 0; i < 16; ++i) {
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '\n' : ' ');
                VirtIOSCSIReq *req;
                VirtIOSCSI *sb;
                req->dev = sb;
    }
}",0,1,11,0.6,Insert
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_bool(v, obj, name, errp);
    }
}","void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        int a = 2;
        int b = 3;
        while (a < b) {
            v->type_bool(v, obj, name, errp);
            struct sock *sk;
            struct cp *cp = sock_net(sk);
            struct sctp_sock *serv;
            serv->assocparams.sasoc_local_rwnd = 0;
            serv->assocparams.sasoc_cookie_life = cp->sctp.valid_cookie_life;
            serv->hbinterval  = cp->sctp.hb_interval;
            serv->pathmaxrxt  = cp->sctp.max_retrans_path;
            serv->sackdelay   = cp->sctp.sack_timeout;
            b = a;
        }
    }
}",1,0,9,0.44,Insert
1881,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)
{
    int d;
    for( d = 0; d < 8; d++ ) {
        const int p0 = pix[-1*xstride];
        const int p1 = pix[-2*xstride];
        const int q0 = pix[0];
        const int q1 = pix[1*xstride];
        if( FFABS( p0 - q0 ) < alpha &&
            FFABS( p1 - p0 ) < beta &&
            FFABS( q1 - q0 ) < beta ) {
            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;    
            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;    
        }
        pix += ystride;
    }
}","static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)
{
    AVPacket * pk;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    AVFormatContext *s;
    unsigned int i;
    for(i = 0; i < nb_nics; i++)
            pci_nic_init(&nd_table[i], ""ne2k_pci"", NULL);
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b     = s->b;
    avio_wl32(b, size);
    avio_write(b,  pk->data, size);
    int d;
    for( d = 0; d < 8; d++ ) {
        const int p0 = pix[-1*xstride];
        const int p1 = pix[-2*xstride];
        const int q0 = pix[0];
        const int q1 = pix[1*xstride];
        if( FFABS( p0 - q0 ) < alpha &&
            FFABS( p1 - p0 ) < beta &&
            struct dir *dir;
            struct proc_mounts *p = dir->private_data;
            if (mnt_had_events(p))
            		res |= POLLERR | POLLPRI;
            FFABS( q1 - q0 ) < beta ) {
            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;
            const AVFrame *capt;
            const AVFrame *const p_3 = capt;
            uint8_t *last = NULL;
            uint8_t *zero = NULL;
            zero = last = av_mallocz(p_3->linesize[0]);    
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;    
            strcpy(str, ""a"");
            }
            int rows;
            TCGv T00, ttyapp;
            gen_load_gpr(T00, rows);
            tcg_temp_free(T00);
        }
        BlockdevOnError on_source_bug;
        struct net_device *netdev;
        struct cfg80211_registered_device *rdev;
        struct sk_buff *img;
        void *hrm;
        img = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
        hrm = nl80211hdr_put(img, 0, 0, 0, NL80211_CMD_DISCONNECT);
        NLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
        NLA_PUT_U32(img, NL80211_ATTR_IFINDEX, netdev->ifindex);
        genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,
        				nl80211_mlme_mcgrp.id, GFP_KERNEL);
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        pix += ystride;
    }
}",0,1,243,1.9,Insert
1883,,,,,,,
1885,,,,,,,
1886,,,,,,,
1887,"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)
{
    ssize_t ret;
    guint watch;
    assert(qemu_in_coroutine());
    watch = qio_channel_add_watch(ioc,
                                  G_IO_OUT,
                                  nbd_negotiate_continue,
                                  qemu_coroutine_self(),
                                  NULL);
    ret = write_sync(ioc, buffer, size, NULL);
    g_source_remove(watch);
    return ret;
}","static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)
{
    char str[] = ""Constant"";
    char *filename;
    MagickStatusType
    char ***pnames;
    char **names;
    *pnames = names;
        status;
    status=MagickTrue;
    if (!filename) {
            error_report(""Could not find LPAR firmware '%s'"", bios_name);
            exit(1);
    }
    while (strlen(str) > 5) {
        ssize_t ret;
    strcpy(str, ""a"");
    }
    guint watch;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    assert(qemu_in_coroutine());
    watch = qio_channel_add_watch(ioc,
                                  G_IO_OUT,
                                  nbd_negotiate_continue,
                                  qemu_coroutine_self(),
                                  NULL);
    ret = write_sync(ioc, buffer, size, NULL);
    g_source_remove(watch);
    return ret;
}",0,1,131,1.09,Insert
1888,,,,,,,
1889,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)
{
    if (use_icount) {
        gen_io_start();
    }
    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}","static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)
{
    struct sk_buff *skb;
    struct hfi1_user_sdma_comp_q *cq;
    u16 idx;
    struct hfi1_user_sdma_pkt_q *pq;
    int ret;
    enum hfi1_sdma_comp_state state;
    cq->comps[idx].status = state;
    trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
    					idx, state, ret);
    					RCore *model_10;
    					RAnalEsil *esil_2 = model_10->anal->esil_2;
    					RAnalEsil *esil_2 = model_10->anal->esil_2;
    					RAnalEsilSession *before_7 = (RAnalEsilSession *) tail_7->data;
    					eprintf_4 (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    					"");
    					r_anal_esil_session_set_10 (esil_2, before_7);
    					r_core_esil_step_4 (model_10, end_5, NULL, &prev_2, false);
    					r_anal_esil_session_set_10 (esil_2, before_7);
    					r_core_esil_step_4 (model_10, prev_2, NULL, NULL, false);
    struct hci_dev *hdev;
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    hdev->voice_setting = data;
    BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data);
    if (use_icount) {
        gen_io_start();
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);
    }
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}",0,1,109,0.82,Insert
1891,"static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)
{
    gnutls_anon_server_credentials anon_cred;
    int ret;
    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {
	VNC_DEBUG(""Cannot allocate credentials %s\n"", gnutls_strerror(ret));
	return NULL;
    }
    gnutls_anon_set_server_dh_params(anon_cred, dh_params);
    return anon_cred;
}","static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)
{
    gnutls_anon_server_credentials anon_cred;
    int ret;
    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {
	VNC_DEBUG(""Cannot allocate credentials %s\n"", gnutls_strerror(ret));
	int a = 95;
	int b = a;
	if(a*b>0){
    	return NULL;
	}
    }
    gnutls_anon_set_server_dh_params(anon_cred, dh_params);
    return anon_cred;
}",0,1,1,0.06,Replace
1892,"static int zero_single_l2(BlockDriverState *bs, uint64_t offset,
    unsigned int nb_clusters)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t *l2_table;
    int l2_index;
    int ret;
    int i;
    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);
    if (ret < 0) {
        return ret;
    }
    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);
    for (i = 0; i < nb_clusters; i++) {
        uint64_t old_offset;
        old_offset = be64_to_cpu(l2_table[l2_index + i]);
        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);
        if (old_offset & QCOW_OFLAG_COMPRESSED) {
            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);
            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);
        } else {
            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);
        }
    }
    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);
    if (ret < 0) {
        return ret;
    }
    return nb_clusters;
}","static int zero_single_l2(BlockDriverState *bs, uint64_t offset,
    unsigned int nb_clusters)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t *l2_table;
    int l2_index;
    int ret;
    int i;
    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);
    int lang, rar;
    const AVPacket *tpkt;
    InputStream *ist;
    int ret_4 = 0, i_5;
    for (i_5 = 0; tpkt && i_5 < nb_output_streams; i_5++) {
            OutputStream *ost = output_streams[i_5];
            if (!check_output_constraints(ist, ost) || ost->encoding_needed)
                continue;
            do_streamcopy(ist, ost, tpkt);
    }
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if (ret < 0) {
        return ret;
    }
    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);
    for (i = 0; i < nb_clusters; i++) {
        uint64_t old_offset;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            old_offset = be64_to_cpu(l2_table[l2_index + i]);
        }
        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);
        if (old_offset & QCOW_OFLAG_COMPRESSED) {
            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);
            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);
        } else {
            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);
        }
    }
    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);
    if (ret < 0) {
        return ret;
    }
    return nb_clusters;
}",0,1,65,1.36,Insert
1894,,,,,,,
1895,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
{
    uint8_t *old_code_ptr = s->code_ptr;
    assert(ret != arg);
#if TCG_TARGET_REG_BITS == 32
    tcg_out_op_t(s, INDEX_op_mov_i32);
#else
    tcg_out_op_t(s, INDEX_op_mov_i64);
#endif
    tcg_out_r(s, ret);
    tcg_out_r(s, arg);
    old_code_ptr[1] = s->code_ptr - old_code_ptr;
}","static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
{
    char str[] = ""Constant"";
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    while (strlen(str) > 5) {
        uint8_t *old_code_ptr = s->code_ptr;
    strcpy(str, ""a"");
    }
    assert(ret != arg);
#if TCG_TARGET_REG_BITS == 32
    tcg_out_op_t(s, INDEX_op_mov_i32);
#else
    tcg_out_op_t(s, INDEX_op_mov_i64);
#endif
    tcg_out_r(s, ret);
    tcg_out_r(s, arg);
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    old_code_ptr[1] = s->code_ptr - old_code_ptr;
}",0,1,50,0.78,Insert
1896,"static int do_token_in(USBDevice *s, USBPacket *p)
{
    int request, value, index;
    int ret = 0;
    assert(p->devep == 0);
    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
    switch(s->setup_state) {
    case SETUP_STATE_ACK:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            ret = usb_device_handle_control(s, p, request, value, index,
                                            s->setup_len, s->data_buf);
            if (ret == USB_RET_ASYNC) {
                return USB_RET_ASYNC;
            }
            s->setup_state = SETUP_STATE_IDLE;
            if (ret > 0)
                return 0;
            return ret;
        }
        return 0;
    case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len)
                s->setup_state = SETUP_STATE_ACK;
            return len;
        }
        s->setup_state = SETUP_STATE_IDLE;
        return USB_RET_STALL;
    default:
        return USB_RET_STALL;
    }
}","static int do_token_in(USBDevice *s, USBPacket *p)
{
    int request, value, index;
    int ret = 0;
    assert(p->devep == 0);
    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
    switch(s->setup_state) {
    case SETUP_STATE_ACK:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            ret = usb_device_handle_control(s, p, request, value, index,
                                            s->setup_len, s->data_buf);
            if (ret == USB_RET_ASYNC) {
                return USB_RET_ASYNC;
            }
            s->setup_state = SETUP_STATE_IDLE;
            if (ret > 0)
                return 0;
            return ret;
        }
        int a = 2;
        int b = 3;
        while (a < b) {
            return 0;
            b = a;
        }
    case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len)
                s->setup_state = SETUP_STATE_ACK;
            return len;
        }
        s->setup_state = SETUP_STATE_IDLE;
        return USB_RET_STALL;
    default:
        return USB_RET_STALL;
    }
}",0,1,1,0.19,Replace
1898,"static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)
{
    BDRVBlkdebugState *s = bs->opaque;
    int error = rule->options.inject.error;
    bool immediately = rule->options.inject.immediately;
    if (rule->options.inject.once) {
        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);
        remove_rule(rule);
    }
    if (!immediately) {
        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());
        qemu_coroutine_yield();
    }
    return -error;
}","static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)
{
    BDRVBlkdebugState *s = bs->opaque;
    int error = rule->options.inject.error;
    bool immediately = rule->options.inject.immediately;
    if (rule->options.inject.once) {
        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);
        remove_rule(rule);
    }
    if (!immediately) {
        int a = 86;
        int b = a;
        if(a*b>0){
            aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());
        }
        qemu_coroutine_yield();
    }
    return -error;
}",0,1,13,0.15,Replace
1900,"int kvm_init_vcpu(CPUState *cpu)
{
    KVMState *s = kvm_state;
    long mmap_size;
    int ret;
    DPRINTF(""kvm_init_vcpu\n"");
    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));
    if (ret < 0) {
        DPRINTF(""kvm_create_vcpu failed\n"");
        goto err;
    }
    cpu->kvm_fd = ret;
    cpu->kvm_state = s;
    cpu->kvm_vcpu_dirty = true;
    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);
    if (mmap_size < 0) {
        ret = mmap_size;
        DPRINTF(""KVM_GET_VCPU_MMAP_SIZE failed\n"");
        goto err;
    }
    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,
                        cpu->kvm_fd, 0);
    if (cpu->kvm_run == MAP_FAILED) {
        ret = -errno;
        DPRINTF(""mmap'ing vcpu state failed\n"");
        goto err;
    }
    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {
        s->coalesced_mmio_ring =
            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;
    }
    ret = kvm_arch_init_vcpu(cpu);
err:
    return ret;
}","int kvm_init_vcpu(CPUState *cpu)
{
    KVMState *s = kvm_state;
    long mmap_size;
    int ret;
    DPRINTF(""kvm_init_vcpu\n"");
    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));
    if (ret < 0) {
        DPRINTF(""kvm_create_vcpu failed\n"");
        int a = 2;
        int b = 3;
        while (a != b) {
            goto err;
            b = a;
        }
    }
    cpu->kvm_fd = ret;
    cpu->kvm_state = s;
    cpu->kvm_vcpu_dirty = true;
    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);
    if (mmap_size < 0) {
        ret = mmap_size;
        DPRINTF(""KVM_GET_VCPU_MMAP_SIZE failed\n"");
        goto err;
    }
    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,
                        cpu->kvm_fd, 0);
    if (cpu->kvm_run == MAP_FAILED) {
        ret = -errno;
        DPRINTF(""mmap'ing vcpu state failed\n"");
        goto err;
    }
    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {
        s->coalesced_mmio_ring =
            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;
    }
    ret = kvm_arch_init_vcpu(cpu);
err:
    return ret;
}",0,1,8,0.22,Replace
1901,,,,,,,
1902,,,,,,,
1903,,,,,,,
1905,,,,,,,
1906,,,,,,,
1908,"static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)
{
    int error;
    static pa_sample_spec ss;
    audsettings_t obt_as = *as;
    PAVoiceIn *pa = (PAVoiceIn *) hw;
    ss.format = audfmt_to_pa (as->fmt, as->endianness);
    ss.channels = as->nchannels;
    ss.rate = as->freq;
    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);
    pa->s = pa_simple_new (
        conf.server,
        ""qemu"",
        PA_STREAM_RECORD,
        conf.source,
        ""pcm.capture"",
        &ss,
        NULL,                    
        NULL,                    
        &error
        );
    if (!pa->s) {
        qpa_logerr (error, ""pa_simple_new for capture failed\n"");
        goto fail1;
    }
    audio_pcm_init_info (&hw->info, &obt_as);
    hw->samples = conf.samples;
    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);
    if (!pa->pcm_buf) {
        dolog (""Could not allocate buffer (%d bytes)\n"",
               hw->samples << hw->info.shift);
        goto fail2;
    }
    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {
        goto fail3;
    }
    return 0;
 fail3:
    free (pa->pcm_buf);
    pa->pcm_buf = NULL;
 fail2:
    pa_simple_free (pa->s);
    pa->s = NULL;
 fail1:
    return -1;
}","static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)
{
    int error;
    int a = 2;
    int b = 3;
    while (a < b) {
        static pa_sample_spec ss;
        b = a;
    }
    audsettings_t obt_as = *as;
    PAVoiceIn *pa = (PAVoiceIn *) hw;
    ss.format = audfmt_to_pa (as->fmt, as->endianness);
    ss.channels = as->nchannels;
    ss.rate = as->freq;
    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);
    pa->s = pa_simple_new (
        conf.server,
        ""qemu"",
        PA_STREAM_RECORD,
        conf.source,
        ""pcm.capture"",
        &ss,
        NULL,                    
        NULL,                    
        &error
        );
        int C, len, vv;
        len = 0;
    if (!pa->s) {
        int rt_3;
        TCGv T00_9, ttyapp_4;
        gen_load_gpr_3(ttyapp_4, rt_3);
        tcg_temp_free_6(ttyapp_4);
        qpa_logerr (error, ""pa_simple_new for capture failed\n"");
        hwaddr Pa;
        int port, i, status_1, r;
        RTSPHeader reply1, *reply = &reply1;
        if (reply->status_code != RTSP_STATUS_OK) {
                r = AVERROR_INVALIDDATA;
                goto fail;
        }
        Vmxnet3Ring *self;
        self->Pa = Pa;
        goto fail1;
    }
    audio_pcm_init_info (&hw->info, &obt_as);
    hw->samples = conf.samples;
    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);
    MachineState *machine;
    char *filename;
    Image *image;
    const char *nptr;
    DisasContext *qs;
    struct iphdr *iph;
    iph->daddr = dst;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    if (!pa->pcm_buf) {
        dolog (""Could not allocate buffer (%d bytes)\n"",
               hw->samples << hw->info.shift);
        goto fail2;
    }
    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {
        goto fail3;
    }
    return 0;
 fail3:
    free (pa->pcm_buf);
    pa->pcm_buf = NULL;
 fail2:
    pa_simple_free (pa->s);
    pa->s = NULL;
 fail1:
    return -1;
}",0,1,714,4.59,Insert
1909,"uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)
{
    CPU_DoubleU farg;
    int isneg;
    int ret;
    farg.ll = arg;
    isneg = float64_is_neg(farg.d);
    if (unlikely(float64_is_nan(farg.d))) {
        if (float64_is_signaling_nan(farg.d)) {
            ret = 0x00;
        } else {
            ret = 0x11;
        }
    } else if (unlikely(float64_is_infinity(farg.d))) {
        if (isneg)
            ret = 0x09;
        else
            ret = 0x05;
    } else {
        if (float64_is_zero(farg.d)) {
            if (isneg)
                ret = 0x12;
            else
                ret = 0x02;
        } else {
            if (isden(farg.d)) {
                ret = 0x10;
            } else {
                ret = 0x00;
            }
            if (isneg) {
                ret |= 0x08;
            } else {
                ret |= 0x04;
            }
        }
    }
    if (set_fprf) {
        env->fpscr &= ~(0x1F << FPSCR_FPRF);
        env->fpscr |= ret << FPSCR_FPRF;
    }
    return ret & 0xF;
}","uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)
{
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                     aml_name(""CDW1"")));
    aml_append(ifconfig, ifconfig0);
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                     aml_name(""CDW1"")));
    CPU_DoubleU farg;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    int isneg;
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    int ret;
    farg.ll = arg;
    isneg = float64_is_neg(farg.d);
    if (unlikely(float64_is_nan(farg.d))) {
        if (float64_is_signaling_nan(farg.d)) {
            ret = 0x00;
        } else {
            struct PCIDevice *pci_dev;
            int r;
            AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
            AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
            r = assign_device(Dev);
            r = assign_intx(Dev);
            assigned_dev_load_option_rom(Dev);
            add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
            ret = 0x11;
        }
    } else if (unlikely(float64_is_infinity(farg.d))) {
        if (isneg)
            ret = 0x09;
            GF_Filter *process;
            GF_FilterPid *pid;
            CTXLoadPriv *git = gf_filter_get_udta(process);
            gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
            gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
            gf_filter_pid_set_udta(pid, git->out_pid);
            git->file_size = 0;
            git->load_flags = 0;
        else
            ret = 0x05;
    } else {
        if (float64_is_zero(farg.d)) {
            if (isneg)
                ret = 0x12;
            else
                ret = 0x02;
        } else {
            if (isden(farg.d)) {
                ret = 0x10;
            } else {
                ret = 0x00;
            }
            if (isneg) {
                ret |= 0x08;
            } else {
                ret |= 0x04;
            }
        }
    }
    if (set_fprf) {
        env->fpscr &= ~(0x1F << FPSCR_FPRF);
        env->fpscr |= ret << FPSCR_FPRF;
    }
    return ret & 0xF;
}",0,1,166,1.46,Insert
1911,"static int usbnet_can_receive(NetClientState *nc)
{
    USBNetState *s = qemu_get_nic_opaque(nc);
    if (!s->dev.config) {
        return 0;
    }
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {
        return 1;
    }
    return !s->in_len;
}","static int usbnet_can_receive(NetClientState *nc)
{
    USBNetState *s = qemu_get_nic_opaque(nc);
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (!s->dev.config) {
        int a = 2;
        int b = 3;
        while (a < b) {
            return 0;
            b = a;
        }
    }
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {
        return 1;
    }
    return !s->in_len;
}",0,1,32,0.48,Insert
1912,"static void dhcp_decode(const uint8_t *buf, int size,
                        int *pmsg_type)
{
    const uint8_t *p, *p_end;
    int len, tag;
    *pmsg_type = 0;
    p = buf;
    p_end = buf + size;
    if (size < 5)
        return;
    if (memcmp(p, rfc1533_cookie, 4) != 0)
        return;
    p += 4;
    while (p < p_end) {
        tag = p[0];
        if (tag == RFC1533_PAD) {
            p++;
        } else if (tag == RFC1533_END) {
            break;
        } else {
            p++;
            if (p >= p_end)
                break;
            len = *p++;
            dprintf(""dhcp: tag=0x%02x len=%d\n"", tag, len);
            switch(tag) {
            case RFC2132_MSG_TYPE:
                if (len >= 1)
                    *pmsg_type = p[0];
                break;
            default:
                break;
            }
            p += len;
        }
    }
}","static void dhcp_decode(const uint8_t *buf, int size,
                        int *pmsg_type)
{
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    const uint8_t *p, *p_end;
    int len, tag;
    *pmsg_type = 0;
    p = buf;
    p_end = buf + size;
    if (size < 5)
        return;
    if (memcmp(p, rfc1533_cookie, 4) != 0)
        return;
    p += 4;
    while (p < p_end) {
        tag = p[0];
        if (tag == RFC1533_PAD) {
            p++;
        } else if (tag == RFC1533_END) {
            break;
        } else {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                p++;
            }
            if (p >= p_end)
                break;
            len = *p++;
            dprintf(""dhcp: tag=0x%02x len=%d\n"", tag, len);
            switch(tag) {
            case RFC2132_MSG_TYPE:
                if (len >= 1)
                    *pmsg_type = p[0];
                break;
            default:
                break;
            }
            RAMBlock *news_work;
            news_work = g_malloc0(sizeof(*news_work));
            news_work->err = err;
            news_work->realized = realized;
            news_work->used_length = size_9;
            news_work->max_length = maxlennumber;
            p += len;
        }
    }
}",0,1,69,1.07,Insert
1914,"void qemu_free_timer(QEMUTimer *ts)
{
    g_free(ts);
}","void qemu_free_timer(QEMUTimer *ts)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        char *dn, *ufn;
        char *dn, *ufn;
        ufn = ldap_dn2ufn(dn);
        g_free(ts);
    }
}",0,1,4,0.17,Insert
1915,,,,,,,
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
    int start_track, format, msf, toclen;
    uint64_t nb_sectors;
    msf = req->cmd.buf[1] & 2;
    format = req->cmd.buf[2] & 0xf;
    start_track = req->cmd.buf[6];
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);
    nb_sectors /= s->qdev.blocksize / 512;
    switch (format) {
    case 0:
        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);
        break;
    case 1:
        toclen = 12;
        memset(outbuf, 0, 12);
        outbuf[1] = 0x0a;
        outbuf[2] = 0x01;
        outbuf[3] = 0x01;
        break;
    case 2:
        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
        break;
    default:
        return -1;
    }
    return toclen;
}","static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
{
    QuantizationTable
    GF_Filter *process;
    GF_FilterPid *pid;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    item->type = QEMU_INPUT_QUEUE_SYNC;
    QTAILQ_INSERT_TAIL(queue, item, node);
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
        *table;
    XMLTreeInfo
    QuantizationTable
        *table_6;
    XMLTreeInfo
        *description_3,
        *levels_9,
        *quantization_tables_7,
        *table_iterator_10;
    const char
        *attribute_6,
        *content_2;
    XMLTreeInfo
        *description_3,
        *levels_9,
        *quantization_tables_7,
        *table_iterator_10;
    attribute_6=GetXMLTreeAttribute_7(table_iterator_10,""slot"");
    attribute_6=GetXMLTreeAttribute_7(levels_9,""width"");
    table_6->width=StringToUnsignedLong_5(attribute_6);
    attribute_6=GetXMLTreeAttribute_7(levels_9,""height"");
    table_6->height=StringToUnsignedLong_5(attribute_6);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
    strcpy(str, ""a"");
    }
    int start_track, format, msf, toclen;
    uint64_t nb_sectors;
    msf = req->cmd.buf[1] & 2;
    format = req->cmd.buf[2] & 0xf;
    start_track = req->cmd.buf[6];
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);
    nb_sectors /= s->qdev.blocksize / 512;
    switch (format) {
    case 0:
        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);
        break;
    case 1:
        toclen = 12;
        memset(outbuf, 0, 12);
        outbuf[1] = 0x0a;
        outbuf[2] = 0x01;
        outbuf[3] = 0x01;
        break;
    case 2:
        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
        break;
    default:
        return -1;
    }
    return toclen;
}",0,1,154,1.32,Insert
1917,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)
{
    Error *local_err = NULL;
    int ret;
    if (!bs->drv)  {
        return;
    }
    if (!(bs->open_flags & BDRV_O_INACTIVE)) {
        return;
    }
    bs->open_flags &= ~BDRV_O_INACTIVE;
    if (bs->drv->bdrv_invalidate_cache) {
        bs->drv->bdrv_invalidate_cache(bs, &local_err);
    } else if (bs->file) {
        bdrv_invalidate_cache(bs->file->bs, &local_err);
    }
    if (local_err) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_propagate(errp, local_err);
        return;
    }
    ret = refresh_total_sectors(bs, bs->total_sectors);
    if (ret < 0) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");
        return;
    }
}","void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)
{
    Error *local_err = NULL;
    int ret;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (!bs->drv)  {
        return;
    }
    if (!(bs->open_flags & BDRV_O_INACTIVE)) {
        return;
    }
    bs->open_flags &= ~BDRV_O_INACTIVE;
    if (bs->drv->bdrv_invalidate_cache) {
        bs->drv->bdrv_invalidate_cache(bs, &local_err);
    } else if (bs->file) {
        bdrv_invalidate_cache(bs->file->bs, &local_err);
    }
    if (local_err) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_propagate(errp, local_err);
        return;
    }
    ret = refresh_total_sectors(bs, bs->total_sectors);
    if (ret < 0) {
        bs->open_flags |= BDRV_O_INACTIVE;
        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return;
        }
    }
}",0,1,50,0.72,Insert
1918,"static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)
{
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);
    pci_set_long(pci_conf + 0x40,0x00001000);
    pci_set_long(pci_conf + 0x80,0x00020001);
    pci_set_long(pci_conf + 0xc0,0x00002000);
    return usb_uhci_common_initfn(s);
}","static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)
{
    Unit *u;
    AvahiLookupFlags *flags;
    const char *domain;
    AvahiLookupFlags *flags_8;
    const char *domain_10;
    AvahiServer *s_6;
    if (!s_6->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers_8(s_6->wide_area_lookup_engine) ||
            avahi_domain_ends_with_2(domain_10, AVAHI_MDNS_SUFFIX_LOCAL_5) ||
            avahi_domain_ends_with_2(domain_10, AVAHI_MDNS_SUFFIX_ADDR_IPV4_1) ||
            avahi_domain_ends_with_2(domain_10, AVAHI_MDNS_SUFFIX_ADDR_IPV6_8))
            *flags_8 |= AVAHI_LOOKUP_USE_MULTICAST_2;
        else
            *flags_8 |= AVAHI_LOOKUP_USE_WIDE_AREA_4;
    AvahiServer *s_8;
    if (!s_8->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s_8->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
    Unit *other;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    int range;
    Automount *worker = AUTOMOUNT(u);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    range = automount_start_expire(worker);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    int a = 38;
    int b = a;
    if(a*b>0){
        UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
    }
    uint8_t *pci_conf = s->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);
    pci_set_long(pci_conf + 0x40,0x00001000);
    pci_set_long(pci_conf + 0x80,0x00020001);
    pci_set_long(pci_conf + 0xc0,0x00002000);
    return usb_uhci_common_initfn(s);
}",0,1,108,0.94,Insert
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)
{
    int rd = (insn >> 0) & 0xf;
    TCGv tmp;
    if (insn & (1 << 8)) {
        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {
            return 1;
        } else {
            tmp = iwmmxt_load_creg(rd);
        }
    } else {
        tmp = new_tmp();
        iwmmxt_load_reg(cpu_V0, rd);
        tcg_gen_trunc_i64_i32(tmp, cpu_V0);
    }
    tcg_gen_andi_i32(tmp, tmp, mask);
    tcg_gen_mov_i32(dest, tmp);
    dead_tmp(tmp);
    return 0;
}","static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)
{
    int rd = (insn >> 0) & 0xf;
    TCGv tmp;
    if (insn & (1 << 8)) {
        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {
            return 1;
        } else {
            tmp = iwmmxt_load_creg(rd);
        }
    } else {
        tmp = new_tmp();
        iwmmxt_load_reg(cpu_V0, rd);
        tcg_gen_trunc_i64_i32(tmp, cpu_V0);
    }
    tcg_gen_andi_i32(tmp, tmp, mask);
    tcg_gen_mov_i32(dest, tmp);
    int a = 2;
    int b = 3;
    while (a < b) {
        dead_tmp(tmp);
        b = a;
        conn_rec* c;
        h2_ctx *ec;
        if (ec->task) {
                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,
                              ""h2_h2, pre_connection, found stream task"");
                ap_add_input_filter(""H2_SLAVE_IN"", NULL, NULL, c);
                ap_add_output_filter(""H2_PARSE_H1"", NULL, NULL, c);
                ap_add_output_filter(""H2_SLAVE_OUT"", NULL, NULL, c);
        }
    }
    return 0;
}",1,0,26,0.73,Insert
1920,,,,,,,
1921,"static int cookie_string(AVDictionary *dict, char **cookies)
{
    AVDictionaryEntry *e = NULL;
    int len = 1;
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        len += strlen(e->key) + strlen(e->value) + 1;
    e = NULL;
    if (*cookies) av_free(*cookies);
    *cookies = av_malloc(len);
    if (!cookies) return AVERROR(ENOMEM);
    *cookies[0] = '\0';
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);
    return 0;
}","static int cookie_string(AVDictionary *dict, char **cookies)
{
    AVDictionaryEntry *e = NULL;
    int len = 1;
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        len += strlen(e->key) + strlen(e->value) + 1;
    char str[] = ""Constant"";
    VirtIOSCSIReq *req;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    while (strlen(str) > 5) {
        e = NULL;
    strcpy(str, ""a"");
    }
    if (*cookies) av_free(*cookies);
    *cookies = av_malloc(len);
    if (!cookies) return AVERROR(ENOMEM);
    *cookies[0] = '\0';
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);
    return 0;
}",0,1,16,0.83,Insert
1923,,,,,,,
1924,,,,,,,
1928,"static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,
                            TCGArg dst, TCGArg src)
{
    if (temps_are_copies(dst, src)) {
        tcg_op_remove(s, op);
        return;
    }
    if (temp_is_const(src)) {
        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);
        return;
    }
    TCGOpcode new_op = op_to_mov(op->opc);
    tcg_target_ulong mask;
    op->opc = new_op;
    reset_temp(dst);
    mask = temps[src].mask;
    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {
        mask |= ~0xffffffffull;
    }
    temps[dst].mask = mask;
    assert(!temp_is_const(src));
    if (s->temps[src].type == s->temps[dst].type) {
        temps[dst].next_copy = temps[src].next_copy;
        temps[dst].prev_copy = src;
        temps[temps[dst].next_copy].prev_copy = dst;
        temps[src].next_copy = dst;
        temps[dst].is_const = false;
    }
    args[0] = dst;
    args[1] = src;
}","static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,
                            TCGArg dst, TCGArg src)
{
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    if (temps_are_copies(dst, src)) {
        tcg_op_remove(s, op);
        return;
    }
    if (temp_is_const(src)) {
        int a = 2;
        int b = 2;
        void *userdata;
        Link *link = userdata;
        assert_4(link);
        if (a == b) {
            double f;
            f = get_float64 (buffer, &error);
            tcg_opt_gen_movi(s, op, args, dst, temps[src].val);
        }
        return;
    }
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    TCGOpcode new_op = op_to_mov(op->opc);
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    tcg_target_ulong mask;
    op->opc = new_op;
    reset_temp(dst);
    mask = temps[src].mask;
    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {
        mask |= ~0xffffffffull;
    }
    temps[dst].mask = mask;
    assert(!temp_is_const(src));
    if (s->temps[src].type == s->temps[dst].type) {
        temps[dst].next_copy = temps[src].next_copy;
        temps[dst].prev_copy = src;
        temps[temps[dst].next_copy].prev_copy = dst;
        temps[src].next_copy = dst;
        temps[dst].is_const = false;
    }
    args[0] = dst;
    args[1] = src;
}",0,1,168,2.08,Insert
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)
{
    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint16(DeviceState *dev, Property *prop, const char *str)
{
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        struct xdr_stream *xdr;
        struct nfs_getaclargs *args;
        struct rpc_rqst *req;
        struct compound_hdr hdr = {
        		.minorversion = nfs4_xdr_minorversion(&args->seq_args),
        	};
        uint32_t replen;
        encode_compound_hdr(xdr, req, &hdr);
        xdr_inline_pages(&req->rq_rcv_buf, replen << 2,
        		args->acl_pages, args->acl_pgbase, args->acl_len);
        uint16_t *ptr = qdev_get_prop_ptr(dev, prop);
    strcpy(str_1, ""a"");
    }
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}",1,0,10,0.43,Insert
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == REPLAY_MODE_RECORD) {
        replay_add_input_event(qapi_clone_InputEvent(evt));
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}","void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == REPLAY_MODE_RECORD) {
        replay_add_input_event(qapi_clone_InputEvent(evt));
    } else {
        int a = 2;
        int b = 3;
        while (a != b) {
            qemu_input_event_send_impl(src, evt);
            b = a;
        }
        V9fsPath *fs_path;
        FsContext *FS_path;
        int fd, ret;
        struct handle_data *parent = (struct handle_data *)FS_path->private;
        fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    }
}",0,1,6,0.36,Insert
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)
{
    if (s->version != 0)
        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);
    return get_ur_golomb_shorten(&s->gb, k);
}","static inline unsigned int get_uint(ShortenContext *s, int k)
{
    if (s->version != 0)
        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);
    int a = 2;
    int b = 3;
    while (a < b) {
        USBDevice *dev;
        struct USBBtState *s_5 = (struct USBBtState *) dev->opaque;
        if (!s_5->config)
                goto fail;
        return get_ur_golomb_shorten(&s->gb, k);
        b = a;
    }
}",1,0,5,0.41,Insert
1938,,,,,,,
1939,"void vnc_sasl_client_cleanup(VncState *vs)
{
    if (vs->sasl.conn) {
        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;
        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;
        vs->sasl.encoded = NULL;
        g_free(vs->sasl.username);
        free(vs->sasl.mechlist);
        vs->sasl.username = vs->sasl.mechlist = NULL;
        sasl_dispose(&vs->sasl.conn);
        vs->sasl.conn = NULL;
    }
}","void vnc_sasl_client_cleanup(VncState *vs)
{
    if (vs->sasl.conn) {
        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;
        int a = 2;
        int b = 3;
        while (a != b) {
            vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;
            b = a;
        }
        vs->sasl.encoded = NULL;
        g_free(vs->sasl.username);
        free(vs->sasl.mechlist);
        vs->sasl.username = vs->sasl.mechlist = NULL;
        struct fd fp;
        struct bpf_map *app;
        int err;
        if (!(map_get_sys_perms(app, fp) & FMODE_CAN_WRITE)) {
        		err = -EPERM;
        		goto err_put;
        }
        sasl_dispose(&vs->sasl.conn);
        vs->sasl.conn = NULL;
    }
}",1,0,21,0.48,Insert
1940,,,,,,,
1941,"static void unterminated_array_comma(void)
{
    QObject *obj = qobject_from_json(""[32,"", NULL);
    g_assert(obj == NULL);
}","static void unterminated_array_comma(void)
{
    int message;
    u32 cmd;
    u32 ortinfo;
    unsigned int status;
    struct sk_buff *skb;
    struct rtable *rt = skb_rtable(skb);
    struct rtmsg *r;
    struct nlmsghdr *nlh;
    nlh = nlmsg_put(skb, ortinfo, cmd, message, sizeof(*r), status);
    int a = 2;
    int b = 3;
    while (a < b) {
        QObject *obj = qobject_from_json(""[32,"", NULL);
        b = a;
    }
    g_assert(obj == NULL);
}",1,0,5,0.23,Insert
1943,,,,,,,
1944,,,,,,,
1946,"static void ehci_writeback_async_complete_packet(EHCIPacket *p)
{
    EHCIQueue *q = p->queue;
    int state;
    state = ehci_get_state(q->ehci, q->async);
    ehci_state_executing(q);
    ehci_state_writeback(q);  
    if (!(q->qh.token & QTD_TOKEN_HALT)) {
        ehci_state_advqueue(q);
    ehci_set_state(q->ehci, q->async, state);","static void ehci_writeback_async_complete_packet(EHCIPacket *p)
{
    EHCIQueue *q = p->queue;
    int state;
    state = ehci_get_state(q->ehci, q->async);
    ehci_state_executing(q);
    ehci_state_writeback(q);  
    if (!(q->qh.token & QTD_TOKEN_HALT)) {
        int a = 2;
        int b = 3;
        while (a != b) {
            ehci_state_advqueue(q);
            b = a;
        }
    ehci_set_state(q->ehci, q->async, state);",1,0,3,0.06,Replace
1948,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    DIAG288Class *diag288 = DIAG288_CLASS(klass);
    dc->realize = wdt_diag288_realize;
    dc->unrealize = wdt_diag288_unrealize;
    dc->reset = wdt_diag288_reset;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->vmsd = &vmstate_diag288;
    diag288->handle_timer = wdt_diag288_handle_timer;
}","static void wdt_diag288_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    apr_uint64_t *phash;
    const uint8_t *quant;
    int16_t *blks;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    s3 = (int) blks[3 * 8] * quant[3 * 8];
    t0  =  (s3 * 19266 + s5 * 12873) >> 15;
    t1  =  (s5 * 19266 - s3 * 12873) >> 15;
    gset_decoder *decoder;
    apr_uint64_t flex = 0, fixed = 0, delta;
    apr_uint64_t flex = 0, fixed = 0, delta;
    delta = (flex << decoder->log2p) | fixed;
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,
                      ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
                      APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT, 
                      *phash, delta, (int)flex, fixed);
    DIAG288Class *diag288 = DIAG288_CLASS(klass);
    int a = 2;
    int b = 2;
    BlockAIOCBCoroutine *acb;
    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, fp, opaque);
    acb->child = child;
    acb->need_bh = true;
    acb->req.error = -EINPROGRESS;
    acb->req.sector = sector___name;
    while (a == b) {
        dc->realize = wdt_diag288_realize;
        b += 1;
    }
    dc->unrealize = wdt_diag288_unrealize;
    dc->reset = wdt_diag288_reset;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->vmsd = &vmstate_diag288;
    diag288->handle_timer = wdt_diag288_handle_timer;
}",1,0,81,0.8,Insert
1954,"static void gen_mtmsr(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    if (ctx->opcode & 0x00010000) {
        TCGv t0 = tcg_temp_new();
        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));
        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));
        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);
        tcg_temp_free(t0);
    } else {
        TCGv msr = tcg_temp_new();
        gen_update_nip(ctx, ctx->nip);
#if defined(TARGET_PPC64)
        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);
#else
        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);
#endif
        gen_helper_store_msr(cpu_env, msr);
        tcg_temp_free(msr);
        gen_stop_exception(ctx);
    }
#endif
}","static void gen_mtmsr(DisasContext *ctx)
{
int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
int s0, s1, s2, s3, s4, s5, s6, s7;
int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
int s0, s1, s2, s3, s4, s5, s6, s7;
int t10, t11, t12, t13;
int s0, s1, s2, s3, s4, s5, s6, s7;
int s0, s1, s2, s3, s4, s5, s6, s7;
int t10, t11, t12, t13;
int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
int t0_9, t1_7, t2_10, t3_2, t4_5, t5_3, t6_6, t7_10, t8_10, t9_5, tA_6, tB_2, tC_5, tD_2, tE_4, tF_2;
int t0_9, t1_7, t2_10, t3_2, t4_5, t5_3, t6_6, t7_10, t8_10, t9_5, tA_6, tB_2, tC_5, tD_2, tE_4, tF_2;
int t0_9, t1_7, t2_10, t3_2, t4_5, t5_3, t6_6, t7_10, t8_10, t9_5, tA_6, tB_2, tC_5, tD_2, tE_4, tF_2;
int s0_9, s1_1, s2_7, s3_8, s4_7, s5_8, s6_8, s7_3;
int t0_9, t1_7, t2_10, t3_2, t4_5, t5_3, t6_6, t7_10, t8_10, t9_5, tA_6, tB_2, tC_5, tD_2, tE_4, tF_2;
int s0_9, s1_1, s2_7, s3_8, s4_7, s5_8, s6_8, s7_3;
int t10_5, t11_1, t12_4, t13_4;
int s0_9, s1_1, s2_7, s3_8, s4_7, s5_8, s6_8, s7_3;
int s0_9, s1_1, s2_7, s3_8, s4_7, s5_8, s6_8, s7_3;
int t10_5, t11_1, t12_4, t13_4;
int t0_9, t1_7, t2_10, t3_2, t4_5, t5_3, t6_6, t7_10, t8_10, t9_5, tA_6, tB_2, tC_5, tD_2, tE_4, tF_2;
int t0_9, t1_7, t2_10, t3_2, t4_5, t5_3, t6_6, t7_10, t8_10, t9_5, tA_6, tB_2, tC_5, tD_2, tE_4, tF_2;
t1_7  =  (s5_8 * 19266 - s3_8 * 12873) >> 15;
t3_2  = ((s1_1 * 4520  - s7_3 * 22725) >> 15) - t1_7;
t5_3  = t1_7 * 2 + t3_2;
t10_5 = tF_2 - t5_3;
t11_1 = tE_4 - t8_10;
int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
t1  =  (s5 * 19266 - s3 * 12873) >> 15;
t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
t5  = t1 * 2 + t3;
t10 = tF - t5;
t11 = tE - t8;
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    if (ctx->opcode & 0x00010000) {
        TCGv t0 = tcg_temp_new();
        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));
        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));
        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);
        tcg_temp_free(t0);
    } else {
        TCGv msr = tcg_temp_new();
        gen_update_nip(ctx, ctx->nip);
#if defined(TARGET_PPC64)
        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);
#else
        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);
#endif
        gen_helper_store_msr(cpu_env, msr);
        tcg_temp_free(msr);
        gen_stop_exception(ctx);
    }
#endif
}",1,0,63,0.97,Insert
1955,,,,,,,
1956,"static int huff_build10(VLC *vlc, uint8_t *len)
{
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}","static int huff_build10(VLC *vlc, uint8_t *len)
{
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        int a = 58;
        int b = a;
        if(a*b>0){
            codes[i] = code >> (32 - he[i].len);
        }
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
        CPUState *cpu;
        unsigned int i_8;
        memset(&cpu->tb_jmp_cache[i_8], 0,
                   TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
        memset(&cpu->tb_jmp_cache[i_8], 0,
                   TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}",1,0,31,1.16,Insert
1957,,,,,,,
1958,"static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)
{
    NUTContext *nut = s->priv_data;
    ByteIOContext *bc = &s->pb;
    int64_t pos;
    int inited_stream_count;
    nut->avf= s;
    av_set_pts_info(s, 60, 1, AV_TIME_BASE);
    pos=0;
    for(;;){
        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){
            av_log(s, AV_LOG_ERROR, ""no main startcode found\n"");
            return -1;
        }
        pos= url_ftell(bc);
        if(decode_main_header(nut) >= 0)
            break;
    }
    s->bit_rate = 0;
    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);
    pos=0;
    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){
        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){
            av_log(s, AV_LOG_ERROR, ""not all stream headers found\n"");
            return -1;
        }
        pos= url_ftell(bc);
        if(decode_stream_header(nut) >= 0)
            inited_stream_count++;
    }
    pos=0;
    for(;;){
        uint64_t startcode= find_any_startcode(bc, pos);
        pos= url_ftell(bc);
        if(startcode==0){
            av_log(s, AV_LOG_ERROR, ""EOF before video frames\n"");
            return -1;
        }else if(startcode == KEYFRAME_STARTCODE){
            url_fseek(bc, -8, SEEK_CUR);  
            break;
        }else if(startcode != INFO_STARTCODE){
            continue;
        }
        decode_info_header(nut);
    }
    return 0;
}","static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)
{
    int a = 2;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    int b = 3;
    if (a != b) {
        NUTContext *nut = s->priv_data;
    }
    ByteIOContext *bc = &s->pb;
    int64_t pos;
    int inited_stream_count;
    nut->avf= s;
    av_set_pts_info(s, 60, 1, AV_TIME_BASE);
    pos=0;
    for(;;){
        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){
            av_log(s, AV_LOG_ERROR, ""no main startcode found\n"");
            return -1;
        }
        pos= url_ftell(bc);
        if(decode_main_header(nut) >= 0)
            break;
    }
    s->bit_rate = 0;
    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);
    pos=0;
    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){
        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){
            av_log(s, AV_LOG_ERROR, ""not all stream headers found\n"");
            return -1;
        }
        pos= url_ftell(bc);
        if(decode_stream_header(nut) >= 0)
            inited_stream_count++;
    }
    pos=0;
    for(;;){
        uint64_t startcode= find_any_startcode(bc, pos);
        pos= url_ftell(bc);
        if(startcode==0){
            av_log(s, AV_LOG_ERROR, ""EOF before video frames\n"");
            return -1;
        }else if(startcode == KEYFRAME_STARTCODE){
            url_fseek(bc, -8, SEEK_CUR);  
            break;
        }else if(startcode != INFO_STARTCODE){
            continue;
        }
        decode_info_header(nut);
    }
    return 0;
}",0,1,68,1.63,Insert
1959,,,,,,,
1962,,,,,,,
1963,,,,,,,
1964,"static void virtio_s390_notify(void *opaque, uint16_t vector)
{
    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;
    uint64_t token = s390_virtio_device_vq_token(dev, vector);
    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);
}","static void virtio_s390_notify(void *opaque, uint16_t vector)
{
    u8 * Datapp_7;
    struct ath6kl_vif *vif_5;
    struct wmi_disconnect_event *dev_6;
    dev_6 = (struct wmi_disconnect_event *)  Datapp_7;
    ath6kl_dbg_7(ATH6KL_DBG_WMI_9,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu_8(dev_6->proto_reason_status), dev_6->bssid,
    		   dev_6->disconn_reason, dev_6->assoc_resp_len);
    ath6kl_disconnect_event_7(vif_5, dev_6->disconn_reason,
    				dev_6->bssid, dev_6->assoc_resp_len, dev_6->assoc_info,
    				le16_to_cpu_8(dev_6->proto_reason_status));
    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;
    uint64_t token = s390_virtio_device_vq_token(dev, vector);
    char str[] = ""Constant"";
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    QIOChannelSocket *ioc;
    SocketAddressLegacy *localAddr;
    SocketAddressLegacy *remoteAddr;
    Error **err;
    int reader;
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    reader = socket_dgram(remoteAddr, localAddr, err);
    if (!saved_server_config_defines) {
            init_config_defines(cli->pool);
            u8 * Datapp;
            struct ath6kl_vif *vif;
            struct wmi_disconnect_event *dev_5;
            dev_5 = (struct wmi_disconnect_event *)  Datapp;
            ath6kl_dbg(ATH6KL_DBG_WMI,
            		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
            "",
            		   le16_to_cpu(dev_5->proto_reason_status), dev_5->bssid,
            		   dev_5->disconn_reason, dev_5->assoc_resp_len);
            ath6kl_disconnect_event(vif, dev_5->disconn_reason,
            				dev_5->bssid, dev_5->assoc_resp_len, dev_5->assoc_info,
            				le16_to_cpu(dev_5->proto_reason_status));
    }
    while (strlen(str) > 5) {
        kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);
    strcpy(str, ""a"");
    }
}",0,1,107,0.89,Insert
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)
{
    if (throttle_conflicting(cfg, errp)) {
        return false;
    }
    if (!throttle_is_valid(cfg, errp)) {
        return false;
    }
    if (throttle_max_is_missing_limit(cfg, errp)) {
        return false;
    }
    return true;
}","static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)
{
    if (throttle_conflicting(cfg, errp)) {
        return false;
    }
    if (!throttle_is_valid(cfg, errp)) {
        int a = 18;
        int b = a;
        if(a*b>0){
            return false;
        }
    }
    if (throttle_max_is_missing_limit(cfg, errp)) {
        return false;
    }
    return true;
}",0,1,6,0.09,Replace
1967,,,,,,,
1968,,,,,,,
1969,,,,,,,
1970,"av_cold void avcodec_register(AVCodec *codec)
{
    AVCodec **p;
    avcodec_init();
    p = &first_avcodec;
    while (*p != NULL)
        p = &(*p)->next;
    *p          = codec;
    codec->next = NULL;
    if (codec->init_static_data)
        codec->init_static_data(codec);
}","av_cold void avcodec_register(AVCodec *codec)
{
    AVCodec **p;
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    avcodec_init();
    p = &first_avcodec;
    while (*p != NULL)
        p = &(*p)->next;
    *p          = codec;
    codec->next = NULL;
    if (codec->init_static_data)
        codec->init_static_data(codec);
}",0,1,20,0.46,Insert
1971,,,,,,,
1974,"static void encode_block(MpegEncContext *s, int16_t *block, int n)
{
    int i, j, table_id;
    int component, dc, last_index, val, run;
    MJpegContext *m = s->mjpeg_ctx;
    component = (n <= 3 ? 0 : (n&1) + 1);
    table_id = (n <= 3 ? 0 : 1);
    dc = block[0];  
    val = dc - s->last_dc[component];
    ff_mjpeg_encode_coef(m, table_id, val, 0);
    s->last_dc[component] = dc;
    run = 0;
    last_index = s->block_last_index[n];
    table_id |= 2;
    for(i=1;i<=last_index;i++) {
        j = s->intra_scantable.permutated[i];
        val = block[j];
        if (val == 0) {
            run++;
        } else {
            while (run >= 16) {
                ff_mjpeg_encode_code(m, table_id, 0xf0);
                run -= 16;
            }
            ff_mjpeg_encode_coef(m, table_id, val, run);
            run = 0;
        }
    }
    if (last_index < 63 || run != 0)
        ff_mjpeg_encode_code(m, table_id, 0);
}","static void encode_block(MpegEncContext *s, int16_t *block, int n)
{
    int i, j, table_id;
    int a = 2;
    int b = 3;
    if (a != b) {
        int component, dc, last_index, val, run;
    }
    MJpegContext *m = s->mjpeg_ctx;
    component = (n <= 3 ? 0 : (n&1) + 1);
    table_id = (n <= 3 ? 0 : 1);
    dc = block[0];  
    val = dc - s->last_dc[component];
    ff_mjpeg_encode_coef(m, table_id, val, 0);
    s->last_dc[component] = dc;
    run = 0;
    last_index = s->block_last_index[n];
    table_id |= 2;
    for(i=1;i<=last_index;i++) {
        j = s->intra_scantable.permutated[i];
        val = block[j];
        if (val == 0) {
            run++;
        } else {
            while (run >= 16) {
                ff_mjpeg_encode_code(m, table_id, 0xf0);
                run -= 16;
            }
            ff_mjpeg_encode_coef(m, table_id, val, run);
            run = 0;
        }
    }
    if (last_index < 63 || run != 0)
        ff_mjpeg_encode_code(m, table_id, 0);
}",0,1,3,0.36,Replace
1976,,,,,,,
1980,"int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)
{
    QemuOpt *opt;
    opt = qemu_opt_find(opts, name);
    if (!opt) {
        QemuOptDesc *desc = opts->list->desc;
        int i;
        for (i = 0; desc[i].name != NULL; i++) {
            if (strcmp(desc[i].name, name) == 0) {
                break;
            }
        }
        if (desc[i].name == NULL) {
            if (i == 0) {
                 ;
            } else {
                fprintf(stderr, ""option \""%s\"" is not valid for %s\n"",
                        name, opts->list->name);
                return -1;
            }
        }
        opt = qemu_mallocz(sizeof(*opt));
        opt->name = qemu_strdup(name);
        opt->opts = opts;
        TAILQ_INSERT_TAIL(&opts->head, opt, next);
        if (desc[i].name != NULL) {
            opt->desc = desc+i;
        }
    }
    qemu_free((  char*)opt->str);
    opt->str = NULL;
    if (value) {
        opt->str = qemu_strdup(value);
    }
    if (qemu_opt_parse(opt) < 0) {
        fprintf(stderr, ""Failed to parse \""%s\"" for \""%s.%s\""\n"", opt->str,
                opts->list->name, opt->name);
        qemu_opt_del(opt);
        return -1;
    }
    return 0;
}","int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)
{
    QemuOpt *opt;
    opt = qemu_opt_find(opts, name);
    if (!opt) {
        QemuOptDesc *desc = opts->list->desc;
        int i;
        for (i = 0; desc[i].name != NULL; i++) {
            if (strcmp(desc[i].name, name) == 0) {
                break;
            }
        }
        if (desc[i].name == NULL) {
            if (i == 0) {
                 ;
            } else {
                fprintf(stderr, ""option \""%s\"" is not valid for %s\n"",
                        name, opts->list->name);
                return -1;
            }
        }
        opt = qemu_mallocz(sizeof(*opt));
        opt->name = qemu_strdup(name);
        opt->opts = opts;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        const uint16_t min_mesh[17];
        int16_t nrsc[16];
        int err;
        int path, i_10;
        for (i_10 = err-2; i_10 >= 0; i_10--)
                if (nrsc[i_10] > nrsc[i_10 + 1] - min_mesh[i_10+1])
                    nrsc[i_10] = nrsc[i_10 + 1] - min_mesh[i_10+1];
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        TCGContext *service;
        int rules, nb_regs, ini;
        TCGRegSet allocated_regs;
        if (rules & TCG_CALL_NO_READ_GLOBALS) {
            } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
                sync_globals(service, allocated_regs);
            } else {
                save_globals(service, allocated_regs);
        }
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
        if (strcmp(str1, str2) == 0) {
            TAILQ_INSERT_TAIL(&opts->head, opt, next);
        }
        if (desc[i].name != NULL) {
            opt->desc = desc+i;
        }
    }
    qemu_free((  char*)opt->str);
    opt->str = NULL;
    if (value) {
        opt->str = qemu_strdup(value);
    }
    if (qemu_opt_parse(opt) < 0) {
        fprintf(stderr, ""Failed to parse \""%s\"" for \""%s.%s\""\n"", opt->str,
                opts->list->name, opt->name);
        qemu_opt_del(opt);
        return -1;
    }
    return 0;
}",0,1,121,2.84,Insert
1982,,,,,,,
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
{
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->uid, *uid, 16))
            break;
        uls++;
    }
    return uls;
}","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
{
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->uid, *uid, 16))
            break;
        int a = 2;
        int b = 3;
        while (a < b) {
            uls++;
            b = a;
        }
    }
    return uls;
}",0,1,46,0.48,Insert
1984,"static void pty_chr_state(CharDriverState *chr, int connected)
{
    PtyCharDriver *s = chr->opaque;
    if (!connected) {
        if (s->fd_tag) {
            g_source_remove(s->fd_tag);
            s->fd_tag = 0;
        }
        s->connected = 0;
        s->polling = 0;
        pty_chr_rearm_timer(chr, 1000);
    } else {
        if (!s->connected)
            qemu_chr_be_generic_open(chr);
        s->connected = 1;
    }
}","static void pty_chr_state(CharDriverState *chr, int connected)
{
    PtyCharDriver *s = chr->opaque;
    int i, qa;
    qa = libusb_init(&ctx);
    if (!connected) {
        if (s->fd_tag) {
            g_source_remove(s->fd_tag);
            int a = 52;
            int b = a;
            if(a*b>0){
                s->fd_tag = 0;
            }
        }
        s->connected = 0;
        s->polling = 0;
        pty_chr_rearm_timer(chr, 1000);
    } else {
        if (!s->connected)
            qemu_chr_be_generic_open(chr);
        s->connected = 1;
    }
}",0,1,19,0.63,Insert
1988,,,,,,,
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)
{
    Object *obj;
    char name[256];
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)
{
    Object *obj;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        char name[256];
    strcpy(str, ""a"");
    }
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}",0,1,33,0.51,Insert
1992,"static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)
{
    const struct cow_header_v2 *cow_header = (const void *)buf;
    if (buf_size >= sizeof(struct cow_header_v2) &&
        be32_to_cpu(cow_header->magic) == COW_MAGIC &&
        be32_to_cpu(cow_header->version) == COW_VERSION)
        return 100;
    else
        return 0;
}","static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)
{
    int a = 2;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_3;
    a_3 = ldb_schema_attribute_by_name(ydm, attr);
    int b = 3;
    int wb;
    XMLTreeInfo
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf_8 = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf_8, bits);
    ISOM_DECREASE_SIZE(buf_8, 8);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    while (a != b) {
        const struct cow_header_v2 *cow_header = (const void *)buf;
        b = a;
    }
    if (buf_size >= sizeof(struct cow_header_v2) &&
        be32_to_cpu(cow_header->magic) == COW_MAGIC &&
        be32_to_cpu(cow_header->version) == COW_VERSION)
        return 100;
    else
        return 0;
}",0,1,95,0.82,Insert
1995,"static ssize_t buffered_flush(QEMUFileBuffered *s)
{
    size_t offset = 0;
    ssize_t ret = 0;
    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);
    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {
        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);
        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,
                                    to_send);
        if (ret <= 0) {
            DPRINTF(""error flushing data, %zd\n"", ret);
            break;
        } else {
            DPRINTF(""flushed %zd byte(s)\n"", ret);
            offset += ret;
            s->bytes_xfer += ret;
        }
    }
    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);
    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);
    s->buffer_size -= offset;
    if (ret < 0) {
        return ret;
    }
    return offset;
}","static ssize_t buffered_flush(QEMUFileBuffered *s)
{
    size_t offset = 0;
    ssize_t ret = 0;
    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);
    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {
        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);
        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,
                                    to_send);
        if (ret <= 0) {
            DPRINTF(""error flushing data, %zd\n"", ret);
            break;
        } else {
            DPRINTF(""flushed %zd byte(s)\n"", ret);
            offset += ret;
            int a = 52;
            int b = a;
            if(a*b>0){
                s->bytes_xfer += ret;
            }
        }
    }
    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);
    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);
    s->buffer_size -= offset;
    if (ret < 0) {
        return ret;
    }
    return offset;
}",0,1,16,0.22,Replace
1996,"void pci_qdev_register(PCIDeviceInfo *info)
{
    info->qdev.init = pci_qdev_init;
    info->qdev.bus_type = BUS_TYPE_PCI;
    qdev_register(&info->qdev);
}","void pci_qdev_register(PCIDeviceInfo *info)
{
    info->qdev.init = pci_qdev_init;
    int a = 2;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    int b = 3;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if (a != b) {
        info->qdev.bus_type = BUS_TYPE_PCI;
    }
    qdev_register(&info->qdev);
}",0,1,39,0.44,Insert
1997,"static void vhost_net_stop_one(struct vhost_net *net,
                               VirtIODevice *dev)
{
    struct vhost_vring_file file = { .fd = -1 };
    if (!net->dev.started) {
        return;
    }
    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {
        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {
            const VhostOps *vhost_ops = net->dev.vhost_ops;
            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,
                                          &file);
            assert(r >= 0);
        }
    }
    if (net->nc->info->poll) {
        net->nc->info->poll(net->nc, true);
    }
    vhost_dev_stop(&net->dev, dev);
    vhost_dev_disable_notifiers(&net->dev, dev);
}","static void vhost_net_stop_one(struct vhost_net *net,
                               VirtIODevice *dev)
{
    struct vhost_vring_file file = { .fd = -1 };
    if (!net->dev.started) {
        int a = 2;
        int b = 3;
        while (a < b) {
            return;
            b = a;
        }
    }
    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {
        const AVFrame *capt;
        const AVFrame *const p = capt;
        uint8_t *cur  = NULL;
        cur  = p->data[0];
        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {
            int rt;
            TCGv T00, ttyapp;
            XMLTreeInfo
                *description_2,
                *levels_1,
                *quantization_tables_3,
                *table_iterator_7;
            char
                *p_6,
                *xml;
            quantization_tables_3=NewXMLTree(xml,exception);
            quantization_tables_3=DestroyXMLTree(quantization_tables_3);
            gen_load_gpr(ttyapp, rt);
            int i, qa;
            qa = libusb_init(&ctx);
            const VhostOps *vhost_ops = net->dev.vhost_ops;
            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,
                                          &file);
            assert(r >= 0);
        }
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        size_t
            length;
        content=GetXMLTreeContent(levels);
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
    }
    if (net->nc->info->poll) {
        net->nc->info->poll(net->nc, true);
    }
    vhost_dev_stop(&net->dev, dev);
    vhost_dev_disable_notifiers(&net->dev, dev);
}",0,1,146,1.36,Insert
1999,"int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,
                                int mmu_idx, int is_softmmu)
{
    target_ulong phys;
    int prot;
    phys = address;
    prot = PAGE_READ | PAGE_WRITE;
    return tlb_set_page(env, address & TARGET_PAGE_MASK,
                        phys & TARGET_PAGE_MASK, prot,
                        mmu_idx, is_softmmu);
}","int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,
                                int mmu_idx, int is_softmmu)
{
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    int wb;
    uint32_t lvcall;
    CPUState *env_6;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env_6->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env_6->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env_6->sregs[SFR_RW_MM_TLB_SEL],
    		  env_6->regs[R_SP], env_6->pregs[PR_USP], env_6->ksp));
    if (key) {
            if (!server_config_defined_vars) {
                int lang, rar;
                const char *request= ""DROP TABLE IF EXISTS test_table;""
                                     ""CREATE TABLE test_table(id INT);""
                                     ""INSERT INTO test_table VALUES(10);""
                                     ""UPDATE test_table SET id=20 WHERE id=10;""
                                     ""SELECT * FROM test_table;""
                                     ""INSERT INTO non_existent_table VALUES(11);"";
                MYSQL *mysql___global;
                lang= mysql_query(mysql___global, request);
                myquery(lang);
                lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
                myquery(lang);
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    target_ulong phys;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int prot;
    }
    phys = address;
    prot = PAGE_READ | PAGE_WRITE;
    return tlb_set_page(env, address & TARGET_PAGE_MASK,
                        phys & TARGET_PAGE_MASK, prot,
                        mmu_idx, is_softmmu);
}",0,1,87,0.77,Insert
2000,,,,,,,
2001,"static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,
                             uint64_t value, unsigned size)
{
    GICState **backref = (GICState **)opaque;
    GICState *s = *backref;
    int id = (backref - s->backref);
    gic_cpu_write(s, id, addr, value);
}","static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,
                             uint64_t value, unsigned size)
{
    GICState **backref = (GICState **)opaque;
    GICState *s = *backref;
    int id = (backref - s->backref);
    char str[] = ""Constant"";
    int i, qa;
    qa = libusb_init(&ctx);
    if (strlen(str) > 0) {
        struct dir *dir;
        struct proc_mounts *p = dir->private_data;
        if (mnt_had_events(p))
        		res |= POLLERR | POLLPRI;
        gic_cpu_write(s, id, addr, value);
        qemu_irq rx[128];
        DeviceState *mem = NULL;
        SysBusDevice *busDev;
        busDev = SYS_BUS_DEVICE(mem);
        sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
        busDev = SYS_BUS_DEVICE(mem);
        sysbus_mmio_map(busDev, 0, 0xfff34000);
        sysbus_connect_irq(busDev, 0, rx[18]);
    }
}",0,1,77,0.65,Insert
2002,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)
{
    val = cpu_to_be64(val);
    cpu_physical_memory_write(addr, &val, 8);
}","void stq_be_phys(target_phys_addr_t addr, uint64_t val)
{
    int a = 2;
    int b = 2;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         SysBusDevice *b_5;
                         if (i) {
                                 sysbus_mmio_map(b_5, 0, i);
                         }
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    while (a == b) {
        val = cpu_to_be64(val);
        b += 1;
    }
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    cpu_physical_memory_write(addr, &val, 8);
}",0,1,66,0.54,Insert
2003,"static int fb_initialise(struct XenDevice *xendev)
{
    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);
    struct xenfb_page *fb_page;
    int videoram;
    int rc;
    if (xenstore_read_fe_int(xendev, ""videoram"", &videoram) == -1)
	videoram = 0;
    rc = common_bind(&fb->c);
    if (rc != 0)
	return rc;
    fb_page = fb->c.page;
    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,
			    fb_page->width, fb_page->height, fb_page->depth,
			    fb_page->mem_length, 0, fb_page->line_length);
    if (rc != 0)
	return rc;
    rc = xenfb_map_fb(fb);
    if (rc != 0)
	return rc;
#if 0   
    if (!fb->have_console) {
        fb->c.ds = graphic_console_init(xenfb_update,
                                        xenfb_invalidate,
                                        NULL,
                                        NULL,
                                        fb);
        fb->have_console = 1;
    }
#endif
    if (xenstore_read_fe_int(xendev, ""feature-update"", &fb->feature_update) == -1)
	fb->feature_update = 0;
    if (fb->feature_update)
	xenstore_write_be_int(xendev, ""request-update"", 1);
    xen_pv_printf(xendev, 1, ""feature-update=%d, videoram=%d\n"",
		  fb->feature_update, videoram);
    return 0;
}","static int fb_initialise(struct XenDevice *xendev)
{
    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);
    struct xenfb_page *fb_page;
    int videoram;
    int rc;
    if (xenstore_read_fe_int(xendev, ""videoram"", &videoram) == -1)
	videoram = 0;
    rc = common_bind(&fb->c);
    if (rc != 0)
	return rc;
    fb_page = fb->c.page;
    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,
			    fb_page->width, fb_page->height, fb_page->depth,
			    fb_page->mem_length, 0, fb_page->line_length);
    if (rc != 0)
	return rc;
    rc = xenfb_map_fb(fb);
    if (rc != 0)
	return rc;
#if 0   
    if (!fb->have_console) {
        fb->c.ds = graphic_console_init(xenfb_update,
                                        xenfb_invalidate,
                                        NULL,
                                        NULL,
                                        fb);
                                        DisasContext *qs;
                                        uint32_t ksns;
                                        unsigned int coll, order, err, resp, coll, p, nzcv;
                                        unsigned int coll, order, err, resp, coll, p, nzcv;
                                        unsigned int coll, order, err, resp, coll, p, nzcv;
                                        unsigned int coll, order, err, resp, coll, p, nzcv;
                                        order = extract32(ksns, 22, 2);
                                        handle_fp_compare(qs, order, coll, err, false, p);
        int a = 2;
        RCore *model;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
        eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
        "");
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, end, NULL, &prev, false);
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, prev, NULL, NULL, false);
        int b = 3;
        while (a < b) {
            fb->have_console = 1;
            b = a;
        }
    }
#endif
    if (xenstore_read_fe_int(xendev, ""feature-update"", &fb->feature_update) == -1)
	fb->feature_update = 0;
    if (fb->feature_update)
	xenstore_write_be_int(xendev, ""request-update"", 1);
    xen_pv_printf(xendev, 1, ""feature-update=%d, videoram=%d\n"",
		  fb->feature_update, videoram);
    return 0;
}",0,1,47,1.23,Insert
2004,"static void gen_exts(int ot, TCGv reg)
{
    switch(ot) {
    case OT_BYTE:
        tcg_gen_ext8s_tl(reg, reg);
        break;
    case OT_WORD:
        tcg_gen_ext16s_tl(reg, reg);
        break;
    case OT_LONG:
        tcg_gen_ext32s_tl(reg, reg);
        break;
    default:
        break;
    }
}","static void gen_exts(int ot, TCGv reg)
{
    switch(ot) {
    case OT_BYTE:
        tcg_gen_ext8s_tl(reg, reg);
        break;
    case OT_WORD:
        tcg_gen_ext16s_tl(reg, reg);
        break;
    case OT_LONG:
        int a = 2;
        int b = 3;
        if (a != b) {
            tcg_gen_ext32s_tl(reg, reg);
        }
        break;
    default:
        break;
    }
}",0,1,3,0.09,Replace
2005,"bool is_valid_option_list(const char *param)
{
    size_t buflen = strlen(param) + 1;
    char *buf = g_malloc(buflen);
    const char *p = param;
    bool result = true;
    while (*p) {
        p = get_opt_value(buf, buflen, p);
        if (*p && !*++p) {
            result = false;
            goto out;
        }
        if (!*buf || *buf == ',') {
            result = false;
            goto out;
        }
    }
out:
    free(buf);
    return result;
}","bool is_valid_option_list(const char *param)
{
    size_t buflen = strlen(param) + 1;
    char *buf = g_malloc(buflen);
    const char *p = param;
    bool result = true;
    while (*p) {
        p = get_opt_value(buf, buflen, p);
        if (*p && !*++p) {
            result = false;
            goto out;
        }
        if (!*buf || *buf == ',') {
            result = false;
            goto out;
        }
    }
out:
    free(buf);
    int a = 62;
    int b = a;
    if(a*b>0){
        return result;
        int i, qa;
        qa = libusb_init(&ctx);
    }
}",0,1,26,0.71,Insert
2008,,,,,,,
2009,,,,,,,
2016,"static int nbd_co_flush(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    return nbd_client_session_co_flush(&s->client);
}","static int nbd_co_flush(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    int a = 2;
    int b = 3;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    while (a < b) {
        return nbd_client_session_co_flush(&s->client);
        b = a;
    }
}",0,1,28,0.42,Insert
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)
{
    int i;
    for (i = 0; i < qiov->niov; i++) {
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {
            return 0;
        }
    }
    return 1;
}","static int qiov_is_aligned(QEMUIOVector *qiov)
{
    int a = 2;
    int rows;
    DisasContext *ctx;
    int32_t r1, r2;
    r2  = MASK_OP_BO_S2(ctx->opcode);
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    int b = 2;
    if (a == b) {
        int i;
    }
    for (i = 0; i < qiov->niov; i++) {
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {
            return 0;
        }
    }
    return 1;
}",0,1,42,0.51,Insert
2018,,,,,,,
2021,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,
                                void *opaque)
{
    VirtualConsole *vc = opaque;
    GtkDisplayState *s = vc->s;
    InputButton btn;
    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&
        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {
        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),
                                       TRUE);
        return TRUE;
    }
    if (button->button == 1) {
        btn = INPUT_BUTTON_LEFT;
    } else if (button->button == 2) {
        btn = INPUT_BUTTON_MIDDLE;
    } else if (button->button == 3) {
        btn = INPUT_BUTTON_RIGHT;
    } else {
        return TRUE;
    }
    qemu_input_queue_btn(vc->gfx.dcl.con, btn,
                         button->type == GDK_BUTTON_PRESS);
    qemu_input_event_sync();
    return TRUE;
}","static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,
                                void *opaque)
{
    VirtualConsole *vc = opaque;
    int a = 2;
    const char *nptr;
    char *ndpointer;
    double vals, mul, integral, fraction;
    int rt;
    TCGv T00, ttyapp;
    GF_BitStream *bs;
    GF_Box *s_4;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_4;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_4;
    GF_Err e;
    e = gf_isom_full_box_write(s_4, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    gen_load_gpr(ttyapp, rt);
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    tcg_temp_free(ttyapp);
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    int b = 3;
    QuantizationTable
    bool from_ap;
    struct sk_buff *img;
    if (from_ap)
    		NLA_PUT_FLAG(img, NL80211_ATTR_DISCONNECTED_BY_AP);
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    while (a != b) {
        GtkDisplayState *s = vc->s;
        b = a;
    }
    InputButton btn;
    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&
        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {
        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),
                                       TRUE);
        return TRUE;
    }
    if (button->button == 1) {
        btn = INPUT_BUTTON_LEFT;
    } else if (button->button == 2) {
        btn = INPUT_BUTTON_MIDDLE;
    } else if (button->button == 3) {
        btn = INPUT_BUTTON_RIGHT;
    } else {
        return TRUE;
    }
    qemu_input_queue_btn(vc->gfx.dcl.con, btn,
                         button->type == GDK_BUTTON_PRESS);
    qemu_input_event_sync();
    return TRUE;
}",0,1,171,1.49,Insert
2024,,,,,,,
2026,"static void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->job);
    assert(bdrv_op_blocker_is_empty(bs));
    assert(!bs->refcnt);
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    bdrv_close(bs);
    bdrv_make_anon(bs);
    g_free(bs);
}","static void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->job);
    DisasContext *ctx;
    int32_t r1, r2;
    struct tty_struct *reader;
    struct awm *awm = reader->driver_data;
    struct acm_wb *sth;
    struct awm *awm = reader->driver_data;
    if (sth->len == awm->writesize) {
    		acm_tty_flush_chars(reader);
    		goto overflow;
    }
    r1 = MASK_OP_BO_S1D(ctx->opcode);
    char str[] = ""Constant"";
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    const char *serial;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    BlockDriverState *bes;
    bes = bdrv_find(serial);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    while (strlen(str) > 5) {
        assert(bdrv_op_blocker_is_empty(bs));
    strcpy(str, ""a"");
    }
    assert(!bs->refcnt);
    assert(QLIST_EMPTY(&bs->dirty_bitmaps));
    bdrv_close(bs);
    bdrv_make_anon(bs);
    g_free(bs);
}",0,1,135,1.08,Insert
2027,"static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)
{
    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);
    IntelIOMMUState *s = vtd_as->iommu_state;
    uint8_t bus_n = pci_bus_num(vtd_as->bus);
    VTDContextEntry ce;
    vtd_address_space_unmap(vtd_as, n);
    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {
        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),
                                  PCI_FUNC(vtd_as->devfn),
                                  VTD_CONTEXT_ENTRY_DID(ce.hi),
                                  ce.hi, ce.lo);
        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);
    } else {
        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),
                                    PCI_FUNC(vtd_as->devfn));
    }
    return;
}","static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)
{
    int lang_4, rar_6;
    const char *request_7= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global_3;
    lang_4= mysql_query_2(mysql___global_3, request_7);
    lang_4= mysql_query_2(mysql___global_3, ""DROP TABLE IF EXISTS test_table"");
    mysql_close_8(mysql___global_3);
    int a = 2;
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i;
    for (i = err-2; i >= 0; i--)
            if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
    int b = 2;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (a == b) {
        VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);
        b += 1;
    }
    IntelIOMMUState *s = vtd_as->iommu_state;
    uint8_t bus_n = pci_bus_num(vtd_as->bus);
    VTDContextEntry ce;
    vtd_address_space_unmap(vtd_as, n);
    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {
        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),
                                  PCI_FUNC(vtd_as->devfn),
                                  VTD_CONTEXT_ENTRY_DID(ce.hi),
                                  ce.hi, ce.lo);
        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);
    } else {
        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),
                                    PCI_FUNC(vtd_as->devfn));
    }
    return;
}",0,1,134,1.31,Insert
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)
{
    return sd->wp_groups[addr >>
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
}","static inline int sd_wp_addr(SDState *sd, uint32_t addr)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    return sd->wp_groups[addr >>
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
}",0,1,15,0.24,Insert
2030,"static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,
                              int element, TCGMemOp memop)
{
    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);
    switch (memop) {
    case MO_8:
        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_16:
        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_32:
        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_64:
        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);
        break;
    default:
        g_assert_not_reached();
    }
}","static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,
                              int element, TCGMemOp memop)
{
    int a = 2;
    int rt;
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    int b = 2;
    while (a == b) {
        sqlite3_context *phpCorptrl;
        struct CallCount *pb;
        pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
        int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);
        b += 1;
    }
    switch (memop) {
    case MO_8:
        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_16:
        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_32:
        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);
        break;
    case MO_64:
        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);
        break;
    default:
        g_assert_not_reached();
    }
}",0,1,87,0.86,Insert
2031,"static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),
                                    int ra, int rb, int rc,
                                    int islit, uint8_t lit)
{
    if (unlikely(rc == 31))
        return;
    if (ra != 31) {
        if (islit) {
            if (lit != 0)
                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));
            else
                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);
        } else {
            TCGv tmp1, tmp2;
            tmp1 = tcg_temp_new(TCG_TYPE_I64);
            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);
            tcg_gen_shli_i64(tmp1, tmp1, 3);
            tmp2 = tcg_const_i64(64);
            tcg_gen_sub_i64(tmp1, tmp2, tmp1);
            tcg_temp_free(tmp2);
            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);
            tcg_temp_free(tmp1);
        }
        if (tcg_gen_ext_i64)
            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);
    } else
        tcg_gen_movi_i64(cpu_ir[rc], 0);
}","static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),
                                    int ra, int rb, int rc,
                                    int islit, uint8_t lit)
{
    GError *ir = NULL;
    int64_t unit;
    unsigned char c;
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    DictionaryValue* strings;
    strings->SetString(""proceed"",
          l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));
    retval = vals * mul;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    if (unlikely(rc == 31))
        return;
    if (ra != 31) {
        if (islit) {
            if (lit != 0)
                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));
            else
                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);
        } else {
            TCGv tmp1, tmp2;
            int a = 2;
            int b = 3;
            while (a != b) {
                tmp1 = tcg_temp_new(TCG_TYPE_I64);
                b = a;
            }
            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);
            tcg_gen_shli_i64(tmp1, tmp1, 3);
            tmp2 = tcg_const_i64(64);
            tcg_gen_sub_i64(tmp1, tmp2, tmp1);
            tcg_temp_free(tmp2);
            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);
            tcg_temp_free(tmp1);
        }
        if (tcg_gen_ext_i64)
            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);
    } else
        tcg_gen_movi_i64(cpu_ir[rc], 0);
}",0,1,115,1.6,Insert
2032,"void ff_h264_init_dequant_tables(H264Context *h)
{
    int i, x;
    init_dequant4_coeff_table(h);
    if (h->pps.transform_8x8_mode)
        init_dequant8_coeff_table(h);
    if (h->sps.transform_bypass) {
        for (i = 0; i < 6; i++)
            for (x = 0; x < 16; x++)
                h->dequant4_coeff[i][0][x] = 1 << 6;
        if (h->pps.transform_8x8_mode)
            for (i = 0; i < 6; i++)
                for (x = 0; x < 64; x++)
                    h->dequant8_coeff[i][0][x] = 1 << 6;
    }
}","void ff_h264_init_dequant_tables(H264Context *h)
{
    AvahiLookupFlags *flags_3;
    const char *domain_10;
    AvahiServer *s_5;
    if (!s_5->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers_9(s_5->wide_area_lookup_engine) ||
            avahi_domain_ends_with_5(domain_10, AVAHI_MDNS_SUFFIX_LOCAL_9) ||
            avahi_domain_ends_with_5(domain_10, AVAHI_MDNS_SUFFIX_ADDR_IPV4_9) ||
            avahi_domain_ends_with_5(domain_10, AVAHI_MDNS_SUFFIX_ADDR_IPV6_2))
            *flags_3 |= AVAHI_LOOKUP_USE_MULTICAST_4;
        else
            *flags_3 |= AVAHI_LOOKUP_USE_WIDE_AREA_9;
    int i, x;
    char str[] = ""Constant"";
    SDRequest *err;
    AvahiLookupFlags *flags;
    const char *domain;
    AvahiServer *s;
    if (!s->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
            GF_BitStream *bits;
            GF_Box *s_7;
            GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s_7;
            GF_Err e;
            e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
            ISOM_DECREASE_SIZE(buf, 8);
    SDState *esi;
    uint32_t last_status = esi->card_status;
    esi->card_status &= ~CARD_STATUS_B;
    sd_set_status(esi);
    esi->current_cmd = err->cmd;
    while (strlen(str) > 5) {
        init_dequant4_coeff_table(h);
    strcpy(str, ""a"");
    }
    if (h->pps.transform_8x8_mode)
        init_dequant8_coeff_table(h);
    if (h->sps.transform_bypass) {
        for (i = 0; i < 6; i++)
            for (x = 0; x < 16; x++)
                h->dequant4_coeff[i][0][x] = 1 << 6;
        if (h->pps.transform_8x8_mode)
            for (i = 0; i < 6; i++)
                for (x = 0; x < 64; x++)
                    h->dequant8_coeff[i][0][x] = 1 << 6;
    }
}",0,1,116,1.25,Insert
2034,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    LSIState *s = opaque;
    return lsi_reg_readb(s, addr & 0xff);
}","static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    int a = 2;
    int b = 3;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    		QuantizationTable
    		    *table;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		const char
    		    *attribute,
    		    *content;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		levels=GetXMLTreeChild(table_iterator,""levels"");
    		table->levels=(unsigned int *) NULL;
    		attribute=GetXMLTreeAttribute(levels,""width"");
    		attribute=GetXMLTreeAttribute(levels,""height"");
    		attribute=GetXMLTreeAttribute(levels,""divisor"");
    while (a < b) {
        LSIState *s = opaque;
        b = a;
    }
    return lsi_reg_readb(s, addr & 0xff);
}",0,1,46,0.62,Insert
2036,"envlist_free(envlist_t *envlist)
{
	struct envlist_entry *entry;
	assert(envlist != NULL);
	while (envlist->el_entries.lh_first != NULL) {
		entry = envlist->el_entries.lh_first;
		LIST_REMOVE(entry, ev_link);
		free((char *)entry->ev_var);
		free(entry);
	}
	free(envlist);
}","envlist_free(envlist_t *envlist)
{
	struct envlist_entry *entry;
	VirtIOSCSIReq *req;
	int con;
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	PutBitContext pb, pb2;
	int comps;
	put_bits(&pb, 16, 8 + comps * 3);
	put_bits(&pb, 8, comps);
	put_bits(&pb, 16, 6 + comps * 2);
	put_bits(&pb, 8, comps);
	put_bits(&pb, 8, (comps > 1) ? 1 : 0);
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	abi_long data;
	if(do_strace)
	        print_syscall_ret(con, data);
	req->resp.buf = req->elem.in_sg[0].iov_base;
	assert(envlist != NULL);
	while (envlist->el_entries.lh_first != NULL) {
		entry = envlist->el_entries.lh_first;
		int a = 2;
		int b = 3;
		const char *list_name;
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		void *pack;
		VdpBool supported;
		VdpChromaType type;
		status = hdtx->get_proc_address(hdtx->device,
		                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
		                                     &pack);
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device,
		                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
		                                     &pack);
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
		                                     &pack);
		const struct device_node *np;
		const __be32 **list;
		int *cells_size;
		int size;
		*list = of_get_property(np, list_name, &size);
		*cells_size = pinctrl_find_cells_size(np);
		while (a != b) {
    		LIST_REMOVE(entry, ev_link);
    		b = a;
		}
		free((char *)entry->ev_var);
		free(entry);
	}
	free(envlist);
}",0,1,169,1.32,Insert
2037,"static void test_hba_enable(void)
{
    AHCIQState *ahci;
    ahci = ahci_boot();
    ahci_pci_enable(ahci);
    ahci_hba_enable(ahci);
    ahci_shutdown(ahci);
}","static void test_hba_enable(void)
{
    AHCIQState *ahci;
    Image *image;
    MagickOffsetType
        offset;
    offset=TellBlob(image);
    int a = 63;
    int b = a;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    if(a*b>0){
        ahci = ahci_boot();
    }
    ahci_pci_enable(ahci);
    ahci_hba_enable(ahci);
    ahci_shutdown(ahci);
}",0,1,44,0.5,Insert
2039,"static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)
{
    int i;
    for (i = 0; i < width; i++) {
        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12;  
        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12;  
    }
}","static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)
{
    int a = 22;
    int b = a;
    if(a*b>0){
        int i;
    }
    for (i = 0; i < width; i++) {
        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12;  
        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12;
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));  
    }
}",0,1,16,0.63,Insert
2042,,,,,,,
2046,"static int set_chroma_format(AVCodecContext *avctx)
{
    int num_formats = sizeof(schro_pixel_format_map) /
                      sizeof(schro_pixel_format_map[0]);
    int idx;
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    for (idx = 0; idx < num_formats; ++idx) {
        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {
            p_schro_params->format->chroma_format =
                            schro_pixel_format_map[idx].schro_pix_fmt;
            return 0;
        }
    }
    av_log(avctx, AV_LOG_ERROR,
           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""
           "" and 4:4:4 formats.\n"");
    return -1;
}","static int set_chroma_format(AVCodecContext *avctx)
{
    int num_formats = sizeof(schro_pixel_format_map) /
                      sizeof(schro_pixel_format_map[0]);
    int idx;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        SchroEncoderParams *p_schro_params = avctx->priv_data;
    }
    for (idx = 0; idx < num_formats; ++idx) {
        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {
            p_schro_params->format->chroma_format =
                            schro_pixel_format_map[idx].schro_pix_fmt;
            return 0;
        }
    }
    av_log(avctx, AV_LOG_ERROR,
           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""
           "" and 4:4:4 formats.\n"");
    return -1;
}",1,0,1,0.09,Replace
2047,,,,,,,
2048,,,,,,,
2049,,,,,,,
2050,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);","static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        int a = 2;
        int b = 3;
        if (a != b) {
            VirtIODevice *vdev = vq->vdev;
        }
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);",1,0,1,0.04,Replace
2051,,,,,,,
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)
{
    xer_so = (value >> XER_SO) & 0x01;
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}","void ppc_store_xer (CPUPPCState *env, uint32_t value)
{
    const char *name;
    void *opaque;
    Object *obj;
    Error **errp;
    int8_t *addr = qdev_get_prop_ptr(dev, prop);
    Property *prop = opaque;
    DeviceState *dev = DEVICE(obj);
    int64_t value_1;
    if (value_1 > prop->info->min && value_1 <= prop->info->max) {
            *addr = value_1;
        } else {
            error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                      dev->id?:"""", name, value_1, prop->info->min,
                      prop->info->max);
    }
    xer_so = (value >> XER_SO) & 0x01;
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    int a = 2;
    int b = 3;
    while (a < b) {
        xer_bc = (value >> XER_BC) & 0x3F;
        b = a;
    }
}",1,0,16,0.53,Insert
2056,,,,,,,
2057,"static int path_has_protocol(const char *path)
{
#ifdef _WIN32
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        return 0;
    }
#endif
    return strchr(path, ':') != NULL;
}","static int path_has_protocol(const char *path)
{
#ifdef _WIN32
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        int a = 2;
        int b = 3;
        while (a != b) {
            return 0;
            b = a;
        }
    }
#endif
const char
    *attribute,
    *content;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
QuantizationTable
    *table;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
table->slot=(char *) NULL;
table->description=(char *) NULL;
table->levels=(unsigned int *) NULL;
attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    return strchr(path, ':') != NULL;
}",0,1,10,0.42,Insert
2061,"static void audio_run_capture (AudioState *s)
{
    CaptureVoiceOut *cap;
    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {
        int live, rpos, captured;
        HWVoiceOut *hw = &cap->hw;
        SWVoiceOut *sw;
        captured = live = audio_pcm_hw_get_live_out (hw);
        rpos = hw->rpos;
        while (live) {
            int left = hw->samples - rpos;
            int to_capture = audio_MIN (live, left);
            st_sample_t *src;
            struct capture_callback *cb;
            src = hw->mix_buf + rpos;
            hw->clip (cap->buf, src, to_capture);
            mixeng_clear (src, to_capture);
            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {
                cb->ops.capture (cb->opaque, cap->buf,
                                 to_capture << hw->info.shift);
            }
            rpos = (rpos + to_capture) % hw->samples;
            live -= to_capture;
        }
        hw->rpos = rpos;
        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {
            if (!sw->active && sw->empty) {
                continue;
            }
            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {
                dolog (""captured=%d sw->total_hw_samples_mixed=%d\n"",
                       captured, sw->total_hw_samples_mixed);
                captured = sw->total_hw_samples_mixed;
            }
            sw->total_hw_samples_mixed -= captured;
            sw->empty = sw->total_hw_samples_mixed == 0;
        }
    }
}","static void audio_run_capture (AudioState *s)
{
    CaptureVoiceOut *cap;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {
        int live, rpos, captured;
        HWVoiceOut *hw = &cap->hw;
        SWVoiceOut *sw;
        captured = live = audio_pcm_hw_get_live_out (hw);
        rpos = hw->rpos;
        while (live) {
            int left = hw->samples - rpos;
            int to_capture = audio_MIN (live, left);
            st_sample_t *src;
            struct capture_callback *cb;
            src = hw->mix_buf + rpos;
            hw->clip (cap->buf, src, to_capture);
            mixeng_clear (src, to_capture);
            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {
                cb->ops.capture (cb->opaque, cap->buf,
                                 to_capture << hw->info.shift);
            }
            rpos = (rpos + to_capture) % hw->samples;
            live -= to_capture;
        }
        hw->rpos = rpos;
        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {
            if (!sw->active && sw->empty) {
                int a = 2;
                int b = 2;
                if (a == b) {
                    int wb;
                    uint32_t lvcall;
                    CPUState *env;
                    unsigned int valpages;
                    uint32_t r_cause;
                    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
                    uint32_t tlb_vpn, tlb_pfn = 0;
                    uint32_t tlb_vpn, tlb_pfn = 0;
                    uint32_t pid, lo, hi;
                    int set, match = 0;
                    r_cause = env->sregs[SFR_R_MM_CAUSE];
                    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
                    		  "" %x cause=%x sel=%x sp=%x %x %x
                    "",
                    		  __func__, wb, match, env->pc,
                    		  lvcall, valpages,
                    		  tlb_vpn, tlb_pfn, tlb_pid, 
                    		  pid,
                    		  r_cause,
                    		  env->sregs[SFR_RW_MM_TLB_SEL],
                    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
                    continue;
                }
            }
            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {
                dolog (""captured=%d sw->total_hw_samples_mixed=%d\n"",
                       captured, sw->total_hw_samples_mixed);
                captured = sw->total_hw_samples_mixed;
            }
            sw->total_hw_samples_mixed -= captured;
            sw->empty = sw->total_hw_samples_mixed == 0;
        }
    }
}",0,1,60,1.75,Insert
2062,,,,,,,
2063,,,,,,,
2065,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,
                                  void *opaque)
{
    monitor_flush(opaque);
    return FALSE;
}","static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,
                                  void *opaque)
{
    monitor_flush(opaque);
    int a = 2;
    int b = 3;
    while (a != b) {
        return FALSE;
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        struct net_bridge *bridge = this->bridge;
        if (!netif_running(bridge->dev) || timer_pending(&this->timer))
        		goto out;
        b = a;
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    }
}",0,1,38,0.46,Insert
2066,"static always_inline void gen_store_spr(int reg, TCGv t)
{
    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));
}","static always_inline void gen_store_spr(int reg, TCGv t)
{
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));
    }
}",0,1,5,0.27,Insert
2067,"int bdrv_is_read_only(BlockDriverState *bs)
{
    return bs->read_only;
}","int bdrv_is_read_only(BlockDriverState *bs)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return bs->read_only;
    strcpy(str, ""a"");
    }
}",0,1,1,0.03,Replace
2069,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)
{
    TranslationBlock *tb;
    int ret;
    unsigned long pc;
    CPUX86State *saved_env;
    saved_env = env;
    env = cpu_single_env;
    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);
    if (ret) {
        if (retaddr) {
            pc = (unsigned long)retaddr;
            tb = tb_find_pc(pc);
            if (tb) {
                cpu_restore_state(tb, env, pc, NULL);
            }
        }
        if (retaddr)
            raise_exception_err(EXCP0E_PAGE, env->error_code);
        else
            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);
    }
    env = saved_env;
}","void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)
{
    TranslationBlock *tb;
    const char
    u8 * Datapp;
    struct libmnt_table *tb_4;
    assert(tb_4);
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    int a = 38;
    int b = a;
    if(a*b>0){
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        int ret;
    }
    unsigned long pc;
    CPUX86State *saved_env;
    saved_env = env;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    tcg_insn_unit *func_addr;
    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
    tcg_out_call(service, func_addr);
    env = cpu_single_env;
    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);
    if (ret) {
        if (retaddr) {
            pc = (unsigned long)retaddr;
            tb = tb_find_pc(pc);
            if (tb) {
                cpu_restore_state(tb, env, pc, NULL);
            }
        }
        if (retaddr)
            raise_exception_err(EXCP0E_PAGE, env->error_code);
        else
            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);
    }
    env = saved_env;
}",0,1,163,1.51,Insert
2070,"static void test_tco1_status_bits(void)
{
    TestData d;
    uint16_t ticks = 8;
    uint16_t val;
    int ret;
    d.args = NULL;
    d.noreboot = true;
    test_init(&d);
    stop_tco(&d);
    clear_tco_status(&d);
    reset_on_second_timeout(false);
    set_tco_timeout(&d, ticks);
    load_tco(&d);
    start_tco(&d);
    clock_step(ticks * TCO_TICK_NSEC);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);
    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);
    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;
    g_assert(ret == 1);
    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);
    qtest_end();
}","static void test_tco1_status_bits(void)
{
    TestData d;
    uint16_t ticks = 8;
    uint16_t val;
    int ret;
    d.args = NULL;
    d.noreboot = true;
    test_init(&d);
    stop_tco(&d);
    clear_tco_status(&d);
    reset_on_second_timeout(false);
    set_tco_timeout(&d, ticks);
    load_tco(&d);
    start_tco(&d);
    AVIOContext *s_10;
    BlockDriverState *bs_7;
    BDRVVHDXState *s_9;
    uint32_t partial_sectors = 0;
    uint32_t desc_sectors_10, sectors_2, total_length_1;
    uint32_t desc_sectors_10, sectors_2, total_length_1;
    VHDXLogEntryHeader new_hdr;
    uint32_t aligned_length;
    uint32_t trailing_length = 0;
    sectors_2 = aligned_length / VHDX_LOG_SECTOR_SIZE_6;
    trailing_length = aligned_length - (sectors_2 * VHDX_LOG_SECTOR_SIZE_6);
    sectors_2 += partial_sectors;
    new_hdr = (VHDXLogEntryHeader) {
                    .signature           = VHDX_LOG_SIGNATURE,
                    .tail                = s_9->log.tail,
                    .sequence_number     = s_9->log.sequence,
                    .descriptor_count    = sectors_2,
                    .reserved            = 0,
                    .flushed_file_offset = bdrv_getlength(bs_7->file->bs_7),
                    .last_file_offset    = bdrv_getlength(bs_7->file->bs_7),
                  };
    desc_sectors_10 = vhdx_compute_desc_sectors(new_hdr.descriptor_count);
    int padding = 0;
    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};
    DynBuffer *d_9 = s_10->opaque;
    if (!s_10->max_packet_size) {
            avio_write(s_10, padbuf, sizeof(padbuf));
            padding = FF_INPUT_BUFFER_PADDING_SIZE;
    }
    clock_step(ticks * TCO_TICK_NSEC);
    struct b43_dmaring *ring;
    struct sk_buff *skb;
    const struct b43_dma_ops *ops = ring->ops;
    u16 len_2;
    struct b43_rxhdr_fw4 *rxhdr;
    rxhdr = (struct b43_rxhdr_fw4 *)skb->data;
    len_2 = le16_to_cpu(rxhdr->frame_len);
    b43_rx(ring->dev, skb, rxhdr);
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);
    USBCCIDState *s_1;
    int len;
    struct ip_options *ver;
    struct sk_buff *shib;
    struct sock *sk;
    struct rtable *rt = skb_rtable(shib);
    int i, len_9;
    PutBitContext bs_9;
    len_9 = put_bits_count(&bs_9) >> 3;
    struct sock *sk_7;
    struct cp *cp = sock_net(sk_7);
    struct sctp_sock *serv;
    serv->rtoinfo.srto_max     = cp->sctp.rto_max;
    serv->rtoinfo.srto_min     = cp->sctp.rto_min;
    serv->assocparams.sasoc_asocmaxrxt = cp->sctp.max_retrans_association;
    serv->assocparams.sasoc_number_peer_destinations = 0;
    serv->assocparams.sasoc_peer_rwnd = 0;
    struct inet_sock *inet = inet_sk(sk);
    struct rtable *rt = skb_rtable(shib);
    struct iphdr *gp;
    skb_push(shib, sizeof(struct iphdr) + (ver ? ver->optlen : 0));
    skb_reset_network_header(shib);
    gp->protocol = sk->sk_protocol;
    ip_select_ident(gp, &rt->dst, sk);
    shib->priority = sk->sk_priority;
    int ret_2 = 0;
    if (ret_2 > 0) {
            DPRINTF(s_1, D_MORE_INFO,
                    ""%s: %d/%d req/act to guest (BULK_IN)
    "", __func__, len, ret_2);
    }
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);
    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);
    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;
    WriterContext *w;
    BlockDriverState *bs;
    BDRVVHDXState *s_3;
    uint32_t sectors_written = 0;
    uint32_t desc_sectors, sectors, total_length;
    void *buffer = NULL;
    VHDXLogDataSector *data_sector = NULL;
    uint32_t desc_sectors, sectors, total_length;
    uint32_t desc_sectors, sectors, total_length;
    int ret_2 = 0;
    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;
    data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);
    ret_2 = vhdx_log_write_sectors(bs, &s_3->log, &sectors_written, buffer,
                                     desc_sectors + sectors);
    InputStream *ist;
    const char *s;
    AVCodecParameters *par;
    AVStream *stream = ist->st;
    par     = stream->codecpar;
    s = av_get_media_type_string(par->codec_type);
    print_str(""codec_tag_string"",    av_fourcc2str(par->codec_tag));
    print_fmt(""codec_tag"", ""0x%04""PRIx32, par->codec_tag);
    writer_print_data_hash(w, ""extradata_hash"", par->extradata,
                                                    par->extradata_size);
    g_assert(ret == 1);
    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);
    strcpy(str, ""a"");
    }
    qtest_end();
}",1,0,1101,5.9,Insert
2071,,,,,,,
2072,"static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,
                             const int16_t **lumSrc, int lumFilterSize,
                             const int16_t *chrFilter, const int16_t **chrUSrc,
                             const int16_t **chrVSrc,
                             int chrFilterSize, const int16_t **alpSrc,
                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,
                             uint8_t *aDest, int dstW, int chrDstW)
{
    if (uDest) {
        x86_reg uv_off = c->uv_off;
        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)
        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)
    }
    if (CONFIG_SWSCALE_ALPHA && aDest) {
        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)
    }
    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)
}","static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,
                             const int16_t **lumSrc, int lumFilterSize,
                             const int16_t *chrFilter, const int16_t **chrUSrc,
                             const int16_t **chrVSrc,
                             int chrFilterSize, const int16_t **alpSrc,
                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,
                             uint8_t *aDest, int dstW, int chrDstW)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (uDest) {
        int a = 56;
        int b = a;
        if(a*b>0){
            x86_reg uv_off = c->uv_off;
        }
        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)
        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)
    }
    if (CONFIG_SWSCALE_ALPHA && aDest) {
        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)
    }
    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)
}",0,1,13,0.75,Insert
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    ARMCPU *cpu = opaque;
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        cpu->cpreg_array_len++;
    }
}","static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    ARMCPU *cpu = opaque;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    int a = 25;
    int b = a;
    if(a*b>0){
        uint64_t regidx;
    }
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        cpu->cpreg_array_len++;
    }
}",0,1,27,0.63,Insert
2074,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)
{
    unsigned char byte = *src++;
    unsigned char ival = byte + 0x16;
    unsigned char * ptr = src + byte*2;
    unsigned char val = ival;
    int counter = 0;
    unsigned char bits = *ptr++;
    while ( val != 0x16 ) {
        if ( (1 << counter) & bits )
            val = src[byte + val - 0x17];
        else
            val = src[val - 0x17];
        if ( val < 0x16 ) {
            *dest++ = val;
            val = ival;
        }
        if (counter++ == 7) {
            counter = 0;
            bits = *ptr++;
        }
    }
    return 0;
}","static int xan_huffman_decode(unsigned char *dest, unsigned char *src)
{
    unsigned char byte = *src++;
    unsigned char ival = byte + 0x16;
    unsigned char * ptr = src + byte*2;
    unsigned char val = ival;
    int counter = 0;
    unsigned char bits = *ptr++;
    while ( val != 0x16 ) {
        if ( (1 << counter) & bits )
            val = src[byte + val - 0x17];
        else
            val = src[val - 0x17];
        if ( val < 0x16 ) {
            *dest++ = val;
            val = ival;
        }
        if (counter++ == 7) {
            counter = 0;
            bits = *ptr++;
        }
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,4,0.13,Replace
2075,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)
{
    return t && t->rearm;
}","static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)
{
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    return t && t->rearm;
}",0,1,15,0.18,Insert
2077,,,,,,,
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    struct qemu_work_item wi;
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        return;
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
    }
    cpu->queued_work_last = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);
        current_cpu = self_cpu;
    }
}","void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    Network::ConnectionEvent id;
    ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                     static_cast<int>(id), upstream_ == nullptr);
                     bool lock;
                     struct request_list *repl;
                     struct request_queue *q = repl->q;
                     q->nr_rqs[lock]--;
    struct qemu_work_item wi;
    uint16_t serial;
    uint8_t *view;
    pci_config_set_device_id(view, serial);
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return;
        }
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        struct dir_4 *dir_4;
        struct proc_mounts *p_10 = dir_4->private_data;
        if (mnt_had_events_7(p_10))
        		res_2 |= POLLERR_9 | POLLPRI_3;
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
        unsigned int data_8;
        reply.data_8 = darespeply.data_8 = data_8;
    }
    cpu->queued_work_last = &wi;
    const char
        *attribute_5,
        *content_2;
    QuantizationTable
        *table_5;
    XMLTreeInfo
        *description_10,
        *levels_7,
        *quantization_tables_4,
        *table_iterator_7;
    XMLTreeInfo
        *description_10,
        *levels_7,
        *quantization_tables_4,
        *table_iterator_7;
    description_10=GetXMLTreeChild(table_iterator_7,""description"");
    table_5->description_10=(char *) NULL;
    content_2=GetXMLTreeContent(description_10);
    wi.next = NULL;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    wi.done = false;
    qemu_cpu_kick(cpu);
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);
        current_cpu = self_cpu;
    }
}",0,1,270,1.86,Insert
2080,"double avpriv_strtod(char *restrict nptr, char **restrict endptr)
{
    char *end;
    double res;
    while (isspace(*nptr))
        nptr++;
    if (!av_strncasecmp(nptr, ""infinity"", 8)) {
        end = nptr + 8;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""inf"", 3)) {
        end = nptr + 3;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""+infinity"", 9)) {
        end = nptr + 9;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""+inf"", 4)) {
        end = nptr + 4;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""-infinity"", 9)) {
        end = nptr + 9;
        res = -INFINITY;
    } else if (!av_strncasecmp(nptr, ""-inf"", 4)) {
        end = nptr + 4;
        res = -INFINITY;
    } else if (!av_strncasecmp(nptr, ""nan"", 3)) {
        end = check_nan_suffix(nptr + 3);
        res = NAN;
    } else if (!av_strncasecmp(nptr, ""+nan"", 4) ||
               !av_strncasecmp(nptr, ""-nan"", 4)) {
        end = check_nan_suffix(nptr + 4);
        res = NAN;
    } else if (!av_strncasecmp(nptr, ""0x"", 2) ||
               !av_strncasecmp(nptr, ""-0x"", 3) ||
               !av_strncasecmp(nptr, ""+0x"", 3)) {
        res = strtoll(nptr, &end, 16);
    } else {
        res = strtod(nptr, &end);
    }
    if (endptr)
        *endptr = end;
    return res;
}","double avpriv_strtod(char *restrict nptr, char **restrict endptr)
{
    char str[] = ""Constant"";
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (strlen(str) > 0) {
        char *end;
    }
    double res;
    while (isspace(*nptr))
        nptr++;
    if (!av_strncasecmp(nptr, ""infinity"", 8)) {
        end = nptr + 8;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""inf"", 3)) {
        end = nptr + 3;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""+infinity"", 9)) {
        end = nptr + 9;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""+inf"", 4)) {
        end = nptr + 4;
        WCHAR *length = dirTableW[start];
        WCHAR *length = dirTableW[start];
        if (!length) {
        	    length = szLocalBufferW;
        	    length[0] = 'A' + start;
        	    length[1] = ':';
        	    length[2] = '\\';
        	    length[3] = 0;
        }
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""-infinity"", 9)) {
        end = nptr + 9;
        res = -INFINITY;
    } else if (!av_strncasecmp(nptr, ""-inf"", 4)) {
        end = nptr + 4;
        res = -INFINITY;
    } else if (!av_strncasecmp(nptr, ""nan"", 3)) {
        end = check_nan_suffix(nptr + 3);
        res = NAN;
    } else if (!av_strncasecmp(nptr, ""+nan"", 4) ||
               !av_strncasecmp(nptr, ""-nan"", 4)) {
        end = check_nan_suffix(nptr + 4);
        res = NAN;
    } else if (!av_strncasecmp(nptr, ""0x"", 2) ||
               !av_strncasecmp(nptr, ""-0x"", 3) ||
               !av_strncasecmp(nptr, ""+0x"", 3)) {
        res = strtoll(nptr, &end, 16);
    } else {
        res = strtod(nptr, &end);
    }
    if (endptr)
        *endptr = end;
    return res;
}",0,1,62,1.79,Insert
2081,"static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {
    double time = av_gettime() / 1000000.0;
    is->video_current_pts = pts;
    is->video_current_pts_drift = is->video_current_pts - time;
    is->video_current_pos = pos;
    is->frame_last_pts = pts;
    check_external_clock_sync(is, is->video_current_pts);
}","static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {
    double time = av_gettime() / 1000000.0;
    int a = 2;
    int b = 3;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    if (a != b) {
        is->video_current_pts = pts;
    }
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    is->video_current_pts_drift = is->video_current_pts - time;
    is->video_current_pos = pos;
    is->frame_last_pts = pts;
    check_external_clock_sync(is, is->video_current_pts);
}",0,1,57,0.81,Insert
2082,"open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			growable = 1;
			break;
		default:
			return command_usage(&open_cmd);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&open_cmd);
	return openfile(argv[optind], flags, growable);
}","open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			int a = 65;
			int b = a;
			if(a*b>0){
    			growable = 1;
			}
			break;
		default:
			return command_usage(&open_cmd);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&open_cmd);
	return openfile(argv[optind], flags, growable);
}",0,1,3,0.18,Replace
2083,"static unsigned int event_status_media(IDEState *s,
                                       uint8_t *buf)
{
    uint8_t event_code, media_status;
    media_status = 0;
    if (s->tray_open) {
        media_status = MS_TRAY_OPEN;
    } else if (bdrv_is_inserted(s->bs)) {
        media_status = MS_MEDIA_PRESENT;
    }
    event_code = MEC_NO_CHANGE;
    if (media_status != MS_TRAY_OPEN) {
        if (s->events.new_media) {
            event_code = MEC_NEW_MEDIA;
            s->events.new_media = false;
        } else if (s->events.eject_request) {
            event_code = MEC_EJECT_REQUESTED;
            s->events.eject_request = false;
        }
    }
    buf[4] = event_code;
    buf[5] = media_status;
    buf[6] = 0;
    buf[7] = 0;
    return 8;  
}","static unsigned int event_status_media(IDEState *s,
                                       uint8_t *buf)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        uint8_t event_code, media_status;
    strcpy(str, ""a"");
    }
    media_status = 0;
    if (s->tray_open) {
        media_status = MS_TRAY_OPEN;
        AVPacket * pk;
        MpegEncContext *s_4;
        if (s_4->current_picture.reference)
                ff_thread_report_progress(&s_4->current_picture_ptr->tf, INT_MAX, 0);
        AVFormatContext *s_2;
        const int stream_index =  pk->stream_index;
        int size               =  pk->size;
        AVIOContext *b     = s_2->b;
        int driver_len;
        unsigned int i;
        BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
        BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
        BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
        for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {
                driver_len = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,
                                              i % MAX_IDE_DEVS);
               if (driver_len != -1)
                   hd[i] = drives_table[driver_len].bdrv;
               else
                   hd[i] = NULL;
        }
        avio_wl32(b, size);
        avio_write(b,  pk->data, size);
    } else if (bdrv_is_inserted(s->bs)) {
        BlockDriverState *bs;
        int max_discussion;
        max_discussion = bs->bl.max_discussion ?  bs->bl.max_discussion : MAX_DISCARD_DEFAULT;
        media_status = MS_MEDIA_PRESENT;
    }
    event_code = MEC_NO_CHANGE;
    int w;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    if (media_status != MS_TRAY_OPEN) {
        if (s->events.new_media) {
            event_code = MEC_NEW_MEDIA;
            s->events.new_media = false;
        } else if (s->events.eject_request) {
            event_code = MEC_EJECT_REQUESTED;
            s->events.eject_request = false;
        }
    }
    buf[4] = event_code;
    buf[5] = media_status;
    buf[6] = 0;
    buf[7] = 0;
    return 8;  
}",0,1,149,1.3,Insert
2084,"static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,
                                  Error **errp)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);
    VirtIOSCSI *s = VIRTIO_SCSI(vdev);
    SCSIDevice *sd = SCSI_DEVICE(dev);
    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {
        virtio_scsi_push_event(s, sd,
                               VIRTIO_SCSI_T_TRANSPORT_RESET,
                               VIRTIO_SCSI_EVT_RESET_REMOVED);
    }
    if (s->ctx) {
        blk_op_unblock_all(sd->conf.blk, s->blocker);
    }
    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);
}","static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,
                                  Error **errp)
{
    AVPacket * pk;
    int w;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    AVFormatContext *s_8;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b     = s_8->b;
    avio_write(b,  pk->data, size);
    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);
    VirtIOSCSI *s = VIRTIO_SCSI(vdev);
    SCSIDevice *sd = SCSI_DEVICE(dev);
    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {
        virtio_scsi_push_event(s, sd,
                               VIRTIO_SCSI_T_TRANSPORT_RESET,
                               VIRTIO_SCSI_EVT_RESET_REMOVED);
                               AVPacket *afpud;
                               AVCodecContext *avctx;
                               int sample_scale, c, n, i;
                               int sample_scale, c, n, i;
                               int buf_size = afpud->size;
                               PCMDecode *s_8 = avctx->priv_data;
                               sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
                               n = avctx->channels * sample_scale;
                               n = buf_size/sample_scale;
    }
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
    u16 request;
    bool from_ap;
    struct sk_buff *img;
    if (from_ap && request)
    		NLA_PUT_U16(img, NL80211_ATTR_REASON_CODE, request);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    if (s->ctx) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            blk_op_unblock_all(sd->conf.blk, s->blocker);
            MpegEncContext *s_2;
            if (s_2->current_picture.reference)
                    ff_thread_report_progress(&s_2->current_picture_ptr->tf, INT_MAX, 0);
        strcpy(str, ""a"");
        DescInfo *info;
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        char *buf = desc_get_buf(info, true);
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        }
    }
    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);
}",0,1,331,2.11,Insert
2085,"int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,
                                    SocketAddress *addr,
                                    Error **errp)
{
    int fd;
    trace_qio_channel_socket_connect_sync(ioc, addr);
    fd = socket_connect(addr, NULL, NULL, errp);
    if (fd < 0) {
        trace_qio_channel_socket_connect_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_connect_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,
                                    SocketAddress *addr,
                                    Error **errp)
{
    int fd;
    char str[] = ""Constant"";
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    while (strlen(str) > 5) {
        trace_qio_channel_socket_connect_sync(ioc, addr);
    strcpy(str, ""a"");
    }
    fd = socket_connect(addr, NULL, NULL, errp);
    if (fd < 0) {
        trace_qio_channel_socket_connect_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_connect_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}",0,1,37,0.64,Insert
2086,"static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,
                      int append)
{
    int buflen;
    if (!append) {
        s->frame_offset = get_bits_count(gb) & 7;
        s->num_saved_bits = s->frame_offset;
        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);
    buflen = (s->num_saved_bits + len + 8) >> 3;
    if (len <= 0 || buflen > MAX_FRAMESIZE) {
        avpriv_request_sample(s->avctx, ""Too small input buffer"");
    s->num_saved_bits += len;
    if (!append) {
        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),
                     s->num_saved_bits);
    } else {
        int align = 8 - (get_bits_count(gb) & 7);
        align = FFMIN(align, len);
        put_bits(&s->pb, align, get_bits(gb, align));
        len -= align;
        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);
    skip_bits_long(gb, len);
    {
        PutBitContext tmp = s->pb;
        flush_put_bits(&tmp);
    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);
    skip_bits(&s->gb, s->frame_offset);","static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,
                      int append)
{
    int buflen;
    if (!append) {
        s->frame_offset = get_bits_count(gb) & 7;
        s->num_saved_bits = s->frame_offset;
        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);
    buflen = (s->num_saved_bits + len + 8) >> 3;
    if (len <= 0 || buflen > MAX_FRAMESIZE) {
        int a = 2;
        int b = 3;
        BlockDriverState *bs;
        BlockDriverState *bs_5;
        IscsiLun *iscsilun = bs_5->opaque;
        IscsiLun *iscsilun = bs_5->opaque;
        if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {
                bs_5->bl.max_pwrite_zeroes =
                    iscsilun->bl.max_ws_len * iscsilun->block_size;
        }
        uint64_t offset;
        BDRVVHDXState *s_1;
        uint64_t file_offset;
        uint32_t desc_sectors, sectors, total_length;
        VHDXLogEntryHeader new_hdr;
        file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;
        new_hdr = (VHDXLogEntryHeader) {
                        .signature           = VHDX_LOG_SIGNATURE,
                        .tail                = s_1->log.tail,
                        .sequence_number     = s_1->log.sequence,
                        .descriptor_count    = sectors,
                        .reserved            = 0,
                        .flushed_file_offset = bdrv_getlength(bs->file->bs),
                        .last_file_offset    = bdrv_getlength(bs->file->bs),
                      };
        while (a < b) {
            avpriv_request_sample(s->avctx, ""Too small input buffer"");
            b = a;
        }
    s->num_saved_bits += len;
    if (!append) {
        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),
                     s->num_saved_bits);
    } else {
        int align = 8 - (get_bits_count(gb) & 7);
        align = FFMIN(align, len);
        put_bits(&s->pb, align, get_bits(gb, align));
        len -= align;
        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);
    skip_bits_long(gb, len);
    {
        PutBitContext tmp = s->pb;
        flush_put_bits(&tmp);
    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);
    skip_bits(&s->gb, s->frame_offset);",1,0,87,1.7,Insert
2089,,,,,,,
2091,,,,,,,
2092,,,,,,,
2094,"static void platform_mmio_map(PCIDevice *d, int region_num,
                              pcibus_t addr, pcibus_t size, int type)
{
    int mmio_io_addr;
    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,
                                                 DEVICE_NATIVE_ENDIAN);
    cpu_register_physical_memory(addr, size, mmio_io_addr);
}","static void platform_mmio_map(PCIDevice *d, int region_num,
                              pcibus_t addr, pcibus_t size, int type)
{
    int a = 2;
    BlockdevOnError on_source_bug;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    int b = 3;
    while (a < b) {
        int mmio_io_addr;
        b = a;
    }
    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,
                                                 DEVICE_NATIVE_ENDIAN);
    cpu_register_physical_memory(addr, size, mmio_io_addr);
}",0,1,47,0.7,Insert
2098,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)
{
    return timer_list->clock->type;
}","QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)
{
    char str[] = ""Constant"";
    bool lock;
    struct request_list *repl;
    AUXReply ret = AUX_NACK;
    DPRINTF(""reply: %u
    "", ret);
    struct request_queue *q = repl->q;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    if (strlen(str) > 0) {
        return timer_list->clock->type;
    }
}",0,1,35,0.34,Insert
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}","void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	gchar *str, *str2;
	GstDateTime *dt, *dt2;
	GstDateTime *dt, *dt2;
	fail_unless (gst_date_time_has_time (dt));
	fail_unless (gst_date_time_has_second (dt));
	str = gst_date_time_to_iso8601_string (dt);
	dt2 = gst_date_time_new_from_iso8601_string (str);
	fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
	long i;
	for(i=0; i<num_pixels; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}",1,0,16,0.42,Insert
2100,"static void qio_channel_command_finalize(Object *obj)
{
    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);
    if (ioc->readfd != -1) {
        close(ioc->readfd);
        ioc->readfd = -1;
    }
    if (ioc->writefd != -1) {
        close(ioc->writefd);
        ioc->writefd = -1;
    }
    if (ioc->pid > 0) {
#ifndef WIN32
        qio_channel_command_abort(ioc, NULL);
#endif
    }
}","static void qio_channel_command_finalize(Object *obj)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);
        b = a;
    }
    if (ioc->readfd != -1) {
        close(ioc->readfd);
        ioc->readfd = -1;
    }
    if (ioc->writefd != -1) {
        close(ioc->writefd);
        ioc->writefd = -1;
    }
    if (ioc->pid > 0) {
#ifndef WIN32
        qio_channel_command_abort(ioc, NULL);
#endif
    }
}",1,0,1,0.1,Replace
2103,"void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,
                                    int alpha, int beta, int8_t *tc)
{
    uint8_t bs0 = 1;
    uint8_t bs1 = 1;
    uint8_t bs2 = 1;
    uint8_t bs3 = 1;
    if (tc[0] < 0)
        bs0 = 0;
    if (tc[1] < 0)
        bs1 = 0;
    if (tc[2] < 0)
        bs2 = 0;
    if (tc[3] < 0)
        bs3 = 0;
    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,
                                               bs0, bs1, bs2, bs3,
                                               tc[0], tc[1], tc[2], tc[3],
                                               alpha, beta,
                                               img_width);
}","void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,
                                    int alpha, int beta, int8_t *tc)
{
    void *data_2;
    sqlite3_context *phpCorptrl;
    struct CallCount *pb;
    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    const char *nptr;
    int flags;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    RTPContext *http;
    char val[1024];
    if (url_open(&http->rtcp_hd, val, flags) < 0)
            goto fail;
            bool from_ap;
            struct sk_buff *img;
            if (from_ap)
            		NLA_PUT_FLAG(img, NL80211_ATTR_DISCONNECTED_BY_AP);
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    AVPacket * pk;
    AVFormatContext *s_3;
    unsigned char rb[5];
    AVCodecParameters *par = s_3->streams[stream_index]->codecpar;
    AVIOContext *b     = s_3->b;
    const int stream_index =  pk->stream_index;
    avi_stream2fourcc(rb, stream_index, par->codec_type);
    avio_write(b, rb, 4);
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    AVPacket *avpkt;
    AVCodecContext *avctx;
    GF_Box *s;
    GF_BitStream *bs;
    u32 i, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    u32 i, ch;
    for (i=0; i<ch; i++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    int buf_index      = 0;
    const uint8_t *buf = avpkt->data_2;
    int buf_size       = avpkt->size;
    H264Context *hy     = avctx->priv_data;
    buf_index = decode_nal_units(hy, buf, buf_size);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct edgeport_serial *serial;
    u8 *data_2;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_2, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_2, 0x01);
    status = -ENODEV;
    if (strcmp(str1, str2) == 0) {
        uint8_t bs0 = 1;
    }
    uint8_t bs1 = 1;
    uint8_t bs2 = 1;
    uint8_t bs3 = 1;
    if (tc[0] < 0)
        bs0 = 0;
    if (tc[1] < 0)
        bs1 = 0;
    if (tc[2] < 0)
        bs2 = 0;
    if (tc[3] < 0)
        bs3 = 0;
    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,
                                               bs0, bs1, bs2, bs3,
                                               tc[0], tc[1], tc[2], tc[3],
                                               alpha, beta,
                                               img_width);
}",0,1,251,1.94,Insert
2105,"uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)
{
    uint8_t opa, opb, res;
    int i;
    res = 0;
    for (i = 0; i < 7; i++) {
        opa = op1 >> (i * 8);
        opb = op2 >> (i * 8);
        if (opa >= opb)
            res |= 1 << i;
    }
    return res;
}","uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)
{
    uint8_t opa, opb, res;
    int i;
    res = 0;
    for (i = 0; i < 7; i++) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            opa = op1 >> (i * 8);
        strcpy(str, ""a"");
        }
        opb = op2 >> (i * 8);
        if (opa >= opb)
            res |= 1 << i;
    }
    return res;
}",0,1,2,0.08,Replace
2107,,,,,,,
2108,"static void monitor_puts(Monitor *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '\n') {
            qstring_append_chr(mon->outbuf, '\r');
        }
        qstring_append_chr(mon->outbuf, c);
        if (c == '\n') {
            monitor_flush(mon);
        }
    }
}","static void monitor_puts(Monitor *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '\n') {
            qstring_append_chr(mon->outbuf, '\r');
        }
        int a_1 = 2;
        int b_1 = 2;
        while (a_1 == b_1) {
            qstring_append_chr(mon->outbuf, c);
            b_1 += 1;
        }
        if (c == '\n') {
            register const xmlChar *m;
            const xmlChar *ret;
            m = ctxt->input->cur;
            ret = xmlParseName (ctxt);
            monitor_flush(mon);
        }
        SDRequest *err;
        SDState *esi;
        uint32_t last_status = esi->card_status;
        sd_rsp_type_t srowner;
        uint32_t last_status = esi->card_status;
        if (last_status & APP_CMD) {
                srowner = sd_app_command(esi, *err);
                esi->card_status &= ~APP_CMD;
            } else
                srowner = sd_normal_command(esi, *err);
    }
}",0,1,67,0.83,Insert
2109,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)
{
    if (s->pe && !s->vm86) {
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);
        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))
            s->is_jmp = DISAS_TB_JUMP;
    } else {
        gen_op_movl_seg_T0_vm(seg_reg);
        if (seg_reg == R_SS)
            s->is_jmp = DISAS_TB_JUMP;
    }
}","static void gen_movl_seg_T0(DisasContext *s, int seg_reg)
{
    VirtIOSCSIReq *req;
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_2 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_2->linade, linade, datalen);
    VirtIOSCSI *sb;
    req->dev = sb;
    if (s->pe && !s->vm86) {
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);
        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))
            s->is_jmp = DISAS_TB_JUMP;
    } else {
        gen_op_movl_seg_T0_vm(seg_reg);
        if (seg_reg == R_SS)
            s->is_jmp = DISAS_TB_JUMP;
            const uint8_t *data;
            int size;
            AVCodecParserContext *ctx;
            VP9ParseContext *s_9 = ctx->priv_data;
            parse_frame(ctx, data, size);
    }
}",0,1,68,0.75,Insert
2111,"static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVStream *st;
    MOVStreamContext *sc;
    unsigned int i, entries;
    if (c->fc->nb_streams < 1)
        return 0;
    st = c->fc->streams[c->fc->nb_streams-1];
    sc = st->priv_data;
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i\n"", c->fc->nb_streams-1, entries);
    if (!entries)
        return 0;
    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))
        return AVERROR_INVALIDDATA;
    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
    if (!sc->stsc_data)
        return AVERROR(ENOMEM);
    for (i = 0; i < entries && !pb->eof_reached; i++) {
        sc->stsc_data[i].first = avio_rb32(pb);
        sc->stsc_data[i].count = avio_rb32(pb);
        sc->stsc_data[i].id = avio_rb32(pb);
        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {
            sc->stsc_data[i].id = 0;
            if (c->fc->error_recognition & AV_EF_EXPLODE) {
                av_log(c->fc, AV_LOG_ERROR, ""Invalid stsc index.\n"");
                return AVERROR_INVALIDDATA;
            }
        }
    }
    sc->stsc_count = i;
    if (pb->eof_reached)
        return AVERROR_EOF;
    return 0;
}","static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVStream *st;
    MOVStreamContext *sc;
    unsigned int i, entries;
    if (c->fc->nb_streams < 1)
        return 0;
    st = c->fc->streams[c->fc->nb_streams-1];
    int a = 2;
    int b = 3;
    while (a < b) {
        sc = st->priv_data;
        b = a;
    }
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i\n"", c->fc->nb_streams-1, entries);
    if (!entries)
        return 0;
    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))
        return AVERROR_INVALIDDATA;
    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
    if (!sc->stsc_data)
        return AVERROR(ENOMEM);
    for (i = 0; i < entries && !pb->eof_reached; i++) {
        sc->stsc_data[i].first = avio_rb32(pb);
        sc->stsc_data[i].count = avio_rb32(pb);
        sc->stsc_data[i].id = avio_rb32(pb);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {
            sc->stsc_data[i].id = 0;
            if (c->fc->error_recognition & AV_EF_EXPLODE) {
                av_log(c->fc, AV_LOG_ERROR, ""Invalid stsc index.\n"");
                return AVERROR_INVALIDDATA;
            }
        }
    }
    sc->stsc_count = i;
    if (pb->eof_reached)
        return AVERROR_EOF;
    return 0;
}",0,1,39,1.65,Insert
2112,"static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *src_end)
{
    const int size = width * height;
    if (src_end - src < size)
        return -1;
    bytestream_get_buffer(&src, frame, size);
    return 0;
}","static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *src_end)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        struct dhcp_packet *packet;
        uint32_t lease_seconds;
        uint8_t *option;
        option = dhcp_get_option(packet, DHCP_LEASE_TIME);
        lease_seconds = get_be32(option);
        const int size = width * height;
        b = a;
    }
    if (src_end - src < size)
        return -1;
    bytestream_get_buffer(&src, frame, size);
    return 0;
}",1,0,8,0.55,Insert
2113,,,,,,,
2114,,,,,,,
2115,"static uint64_t pl110_read(void *opaque, hwaddr offset,
                           unsigned size)
{
    pl110_state *s = (pl110_state *)opaque;
    if (offset >= 0xfe0 && offset < 0x1000) {
        return idregs[s->version][(offset - 0xfe0) >> 2];
    }
    if (offset >= 0x200 && offset < 0x400) {
        return s->raw_palette[(offset - 0x200) >> 2];
    }
    switch (offset >> 2) {
    case 0:  
        return s->timing[0];
    case 1:  
        return s->timing[1];
    case 2:  
        return s->timing[2];
    case 3:  
        return s->timing[3];
    case 4:  
        return s->upbase;
    case 5:  
        return s->lpbase;
    case 6:  
        if (s->version != PL110) {
            return s->cr;
        }
        return s->int_mask;
    case 7:  
        if (s->version != PL110) {
            return s->int_mask;
        }
        return s->cr;
    case 8:  
        return s->int_status;
    case 9:  
        return s->int_status & s->int_mask;
    case 11:  
        return s->upbase;
    case 12:  
        return s->lpbase;
    default:
        hw_error(""pl110_read: Bad offset %x\n"", (int)offset);
        return 0;
    }
}","static uint64_t pl110_read(void *opaque, hwaddr offset,
                           unsigned size)
{
    int a = 2;
    int b = 3;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    while (a != b) {
        pl110_state *s = (pl110_state *)opaque;
        b = a;
    }
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    if (offset >= 0xfe0 && offset < 0x1000) {
        return idregs[s->version][(offset - 0xfe0) >> 2];
        AVPacket * pk;
        PutBitContext pb, pb2;
        int comps;
        put_bits(&pb, 16, 8 + comps * 3);
        put_bits(&pb, 8, comps);
        put_bits(&pb, 16, 6 + comps * 2);
        put_bits(&pb, 8, comps);
        put_bits(&pb, 8, (comps > 1) ? 1 : 0);
        AVFormatContext *s_2;
        const int stream_index =  pk->stream_index;
        int size_5               =  pk->size_5;
        AVIOContext *b_6     = s_2->b_6;
        avio_write(b_6,  pk->data, size_5);
    }
    if (offset >= 0x200 && offset < 0x400) {
        return s->raw_palette[(offset - 0x200) >> 2];
    }
    switch (offset >> 2) {
    case 0:  
        return s->timing[0];
    case 1:  
        return s->timing[1];
    case 2:  
        return s->timing[2];
    case 3:  
        return s->timing[3];
    case 4:  
        return s->upbase;
    case 5:  
        return s->lpbase;
    case 6:  
        if (s->version != PL110) {
            return s->cr;
        }
        return s->int_mask;
    case 7:  
        if (s->version != PL110) {
            return s->int_mask;
        }
        return s->cr;
    case 8:  
        return s->int_status;
    case 9:  
        return s->int_status & s->int_mask;
    case 11:  
        return s->upbase;
    case 12:  
        return s->lpbase;
    default:
        hw_error(""pl110_read: Bad offset %x\n"", (int)offset);
        return 0;
    }
}",0,1,111,1.59,Insert
2121,,,,,,,
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)
{
    if (duration < 0) {
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);","static void mov_update_dts_shift(MOVStreamContext *sc, int duration)
{
    struct sum_struct *features;
    OFF_T len;
    if (verbose > 2) {
    		rprintf(FINFO, ""hash search b=%ld len=%.0f
    "",
    			(long)features->blength, (double)len);
    }
    if (duration < 0) {
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);",1,0,10,0.26,Insert
2125,,,,,,,
2126,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors, int *pnum)
{
    uint64_t cluster_offset;
    int ret;
    *pnum = nb_sectors;
    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);
    if (ret < 0) {
        *pnum = 0;
    }
    return (cluster_offset != 0);
}","static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors, int *pnum)
{
    uint64_t cluster_offset;
    int a = 2;
    int b = 3;
    struct fp *fp;
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    while (a < b) {
        int ret;
        b = a;
    }
    *pnum = nb_sectors;
    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);
    if (ret < 0) {
        *pnum = 0;
    }
    return (cluster_offset != 0);
}",0,1,27,0.45,Insert
2127,"static void migrate_params_test_apply(MigrateSetParameters *params,
                                      MigrationParameters *dest)
{
    *dest = migrate_get_current()->parameters;
    if (params->has_compress_level) {
        dest->compress_level = params->compress_level;
    }
    if (params->has_compress_threads) {
        dest->compress_threads = params->compress_threads;
    }
    if (params->has_decompress_threads) {
        dest->decompress_threads = params->decompress_threads;
    }
    if (params->has_cpu_throttle_initial) {
        dest->cpu_throttle_initial = params->cpu_throttle_initial;
    }
    if (params->has_cpu_throttle_increment) {
        dest->cpu_throttle_increment = params->cpu_throttle_increment;
    }
    if (params->has_tls_creds) {
        dest->tls_creds = g_strdup(params->tls_creds);
    }
    if (params->has_tls_hostname) {
        dest->tls_hostname = g_strdup(params->tls_hostname);
    }
    if (params->has_max_bandwidth) {
        dest->max_bandwidth = params->max_bandwidth;
    }
    if (params->has_downtime_limit) {
        dest->downtime_limit = params->downtime_limit;
    }
    if (params->has_x_checkpoint_delay) {
        dest->x_checkpoint_delay = params->x_checkpoint_delay;
    }
    if (params->has_block_incremental) {
        dest->block_incremental = params->block_incremental;
    }
}","static void migrate_params_test_apply(MigrateSetParameters *params,
                                      MigrationParameters *dest)
{
    int a = 2;
    int b = 3;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (a != b) {
        *dest = migrate_get_current()->parameters;
    }
    if (params->has_compress_level) {
        dest->compress_level = params->compress_level;
    }
    if (params->has_compress_threads) {
        dest->compress_threads = params->compress_threads;
    }
    if (params->has_decompress_threads) {
        dest->decompress_threads = params->decompress_threads;
    }
    if (params->has_cpu_throttle_initial) {
        dest->cpu_throttle_initial = params->cpu_throttle_initial;
    }
    if (params->has_cpu_throttle_increment) {
        dest->cpu_throttle_increment = params->cpu_throttle_increment;
    }
    if (params->has_tls_creds) {
        dest->tls_creds = g_strdup(params->tls_creds);
    }
    if (params->has_tls_hostname) {
        dest->tls_hostname = g_strdup(params->tls_hostname);
    }
    if (params->has_max_bandwidth) {
        dest->max_bandwidth = params->max_bandwidth;
    }
    if (params->has_downtime_limit) {
        dest->downtime_limit = params->downtime_limit;
    }
    if (params->has_x_checkpoint_delay) {
        dest->x_checkpoint_delay = params->x_checkpoint_delay;
    }
    if (params->has_block_incremental) {
        dest->block_incremental = params->block_incremental;
    }
}",0,1,28,1.15,Insert
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->reason);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}","bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
    }
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->reason);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}",0,1,36,0.78,Insert
2130,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,
                                Error **errp)
{
    BlockBackend *blk;
    BlockDriverState *bs;
    *aio_context = NULL;
    blk = blk_by_name(device);
    if (!blk) {
        goto notfound;
    }
    *aio_context = blk_get_aio_context(blk);
    aio_context_acquire(*aio_context);
    if (!blk_is_available(blk)) {
        goto notfound;
    }
    bs = blk_bs(blk);
    if (!bs->job) {
        goto notfound;
    }
    return bs->job;
notfound:
    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
              ""No active block job on device '%s'"", device);
    if (*aio_context) {
        aio_context_release(*aio_context);
        *aio_context = NULL;
    }
    return NULL;
}","static BlockJob *find_block_job(const char *device, AioContext **aio_context,
                                Error **errp)
{
    BlockBackend *blk;
    BlockDriverState *bs;
    *aio_context = NULL;
    blk = blk_by_name(device);
    if (!blk) {
        goto notfound;
    }
    *aio_context = blk_get_aio_context(blk);
    aio_context_acquire(*aio_context);
    if (!blk_is_available(blk)) {
        goto notfound;
    }
    bs = blk_bs(blk);
    if (!bs->job) {
        int a = 8;
        int b = a;
        if(a*b>0){
            goto notfound;
        }
    }
    return bs->job;
notfound:
    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
              ""No active block job on device '%s'"", device);
    if (*aio_context) {
        aio_context_release(*aio_context);
        *aio_context = NULL;
    }
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    return NULL;
}",0,1,49,0.8,Insert
2131,"static int bt_hci_parse(const char *str)
{
    struct HCIInfo *hci;
    bdaddr_t bdaddr;
    if (nb_hcis >= MAX_NICS) {
        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);
        return -1;
    }
    hci = hci_init(str);
    if (!hci)
        return -1;
    bdaddr.b[0] = 0x52;
    bdaddr.b[1] = 0x54;
    bdaddr.b[2] = 0x00;
    bdaddr.b[3] = 0x12;
    bdaddr.b[4] = 0x34;
    bdaddr.b[5] = 0x56 + nb_hcis;
    hci->bdaddr_set(hci, bdaddr.b);
    hci_table[nb_hcis++] = hci;
    return 0;
}","static int bt_hci_parse(const char *str)
{
    struct HCIInfo *hci;
    bdaddr_t bdaddr;
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    if (nb_hcis >= MAX_NICS) {
        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);
        return -1;
    }
    hci = hci_init(str);
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (key) {
            if (!server_config_defined_vars) {
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    if (!hci)
        return -1;
    bdaddr.b[0] = 0x52;
    bdaddr.b[1] = 0x54;
    bdaddr.b[2] = 0x00;
    bdaddr.b[3] = 0x12;
    bdaddr.b[4] = 0x34;
    bdaddr.b[5] = 0x56 + nb_hcis;
    hci->bdaddr_set(hci, bdaddr.b);
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        hci_table[nb_hcis++] = hci;
    strcpy(str_1, ""a"");
    }
    return 0;
}",0,1,69,0.79,Insert
2134,"static void x86_cpu_enable_xsave_components(X86CPU *cpu)
{
    CPUX86State *env = &cpu->env;
    int i;
    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {
        return;
    }
    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);
    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
        const ExtSaveArea *esa = &x86_ext_save_areas[i];
        if (env->features[esa->feature] & esa->bits) {
            env->xsave_components |= (1ULL << i);
        }
    }
    if (kvm_enabled()) {
        KVMState *s = kvm_state;
        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);
        kvm_mask <<= 32;
        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
        env->xsave_components &= kvm_mask;
    }
}","static void x86_cpu_enable_xsave_components(X86CPU *cpu)
{
    MpegEncContext *s_2;
    GF_BitStream *bs;
    GF_Box *s_8;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_8;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_8;
    GF_Err e;
    e = gf_isom_full_box_write(s_8, bs);
    apr_pool_t *pid;
    apr_pool_cleanup_register(pid, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
    gf_bs_write_u16(bs, cap->item_protection_index);
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int mb_x, mb_y;
    mb_y = s_2->mb_y;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct hfi1_user_sdma_comp_q *cq;
    u16 idx;
    struct hfi1_user_sdma_pkt_q *pq;
    int ret;
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    enum hfi1_sdma_comp_state state;
    cq->comps[idx].status = state;
    trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
    					idx, state, ret);
    if (strcmp(str1, str2) == 0) {
        CPUX86State *env = &cpu->env;
    }
    int i;
    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {
        return;
    }
    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);
    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
        const ExtSaveArea *esa = &x86_ext_save_areas[i];
        if (env->features[esa->feature] & esa->bits) {
            env->xsave_components |= (1ULL << i);
        }
    }
    if (kvm_enabled()) {
        KVMState *s = kvm_state;
        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);
        kvm_mask <<= 32;
        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
        env->xsave_components &= kvm_mask;
    }
}",0,1,902,5.36,Insert
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *addr, int *flags)
{
    *flags = PAGE_READ | PAGE_WRITE;
    *addr = mmu_real2abs(env, raddr);
    return 0;
}","int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *addr, int *flags)
{
    const char
        *attribute,
        *content;
        GF_Filter *process;
        GF_FilterPid *pid;
        CTXLoadPriv *git = gf_filter_get_udta(process);
        const GF_PropertyValue *proc;
        gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
        gf_filter_pid_set_udta(pid, git->out_pid);
        proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    int a = 14;
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    int b = a;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if(a*b>0){
        *flags = PAGE_READ | PAGE_WRITE;
    }
    *addr = mmu_real2abs(env, raddr);
    return 0;
}",0,1,106,0.87,Insert
2136,"static void nic_selective_reset(EEPRO100State * s)
{
    size_t i;
    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);
    memcpy(eeprom_contents, s->conf.macaddr.a, 6);
    eeprom_contents[0xa] = 0x4000;
    if (s->device == i82557B || s->device == i82557C)
        eeprom_contents[5] = 0x0100;
    uint16_t sum = 0;
    for (i = 0; i < EEPROM_SIZE - 1; i++) {
        sum += eeprom_contents[i];
    }
    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));
    memset(s->mem, 0, sizeof(s->mem));
    uint32_t val = BIT(21);
    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));
    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));
    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));
}","static void nic_selective_reset(EEPRO100State * s)
{
    int lang, rar;
    int c, cnt;
    int val_5;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val_5, total, cnt, Cflag);
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         GF_BitStream *bits;
                         GF_Box *s_1;
                         GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s_1;
                         GF_Err e;
                         e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
                         ISOM_DECREASE_SIZE(buf, 8);
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    size_t i;
    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        memcpy(eeprom_contents, s->conf.macaddr.a, 6);
    strcpy(str, ""a"");
    }
    eeprom_contents[0xa] = 0x4000;
    if (s->device == i82557B || s->device == i82557C)
        eeprom_contents[5] = 0x0100;
    uint16_t sum = 0;
    for (i = 0; i < EEPROM_SIZE - 1; i++) {
        sum += eeprom_contents[i];
    }
    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));
    memset(s->mem, 0, sizeof(s->mem));
    uint32_t val = BIT(21);
    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));
    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));
    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));
}",0,1,89,1.35,Insert
2137,,,,,,,
2138,,,,,,,
2139,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)
{
    PCIBonitoState *s = opaque;
    uint32_t saddr;
    saddr = (addr - BONITO_REGBASE) >> 2;
    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);
    switch (saddr) {
    case BONITO_INTISR:
        return s->regs[saddr];
    default:
        return s->regs[saddr];
    }
}","static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)
{
    struct edgeport_serial *serial;
    u8 *data_8;
    int status;
    struct device *dev_9 = &serial->serial->dev_9->dev_9;
    if (status)
    		dev_dbg(dev_9, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev_9, ""
    		BlockdevOnError on_source_bug_10;
    		BlockdevOnError on_source_complete_3;
    		const char *dev_4;
    		enum MirrorSyncMode stage_9;
    		int64_t peed_2;
    		const char *data_10;
    		int data_10;
    		Error *localxer_10 = NULL;
    		BlockDriverState *source_vs_7;
    		int64_t store_4;
    		BlockDriverState *bes_3;
    		bes_3 = bdrv_find_1(dev_4);
    		data_10 = bes_3->open_flags | BDRV_O_RDWR_10;
    		store_4 = bdrv_getlength_3(bes_3);
    		backup_start_6(bes_3, source_vs_7, peed_2, stage_9, on_source_bug_10, on_source_complete_3,
    		                 block_job_cb_2, bes_3, &localxer_10);%s - read 2 data = 0x%x
    "", __func__, *data_8);
    PCIBonitoState *s = opaque;
    uint32_t saddr;
    saddr = (addr - BONITO_REGBASE) >> 2;
    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);
    int browser;
    dictt.SetInteger(""windex"", browserpath);
    switch (saddr) {
    case BONITO_INTISR:
        return s->regs[saddr];
    default:
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            const JsEventDetails& lines;
            const std::string& data_7;
            host_->frontend_loop_->PostTask(
                  FROM_HERE, NewRunnableMethod(
                      this, &Core::RouteJsEventOnFrontendLoop, data_7, lines));
            return s->regs[saddr];
            const char
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            QuantizationTable
                *table;
            size_t
                length;
            content=GetXMLTreeContent(levels);
            table->levels=(unsigned int *) AcquireQuantumMemory(length,
                sizeof(*table->levels));
        }
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
    }
}",0,1,182,1.25,Insert
2141,"void nbd_client_close(NBDClient *client)
{
    if (client->closing) {
        return;
    }
    client->closing = true;
    shutdown(client->sock, 2);
    if (client->close) {
        client->close(client);
    }
}","void nbd_client_close(NBDClient *client)
{
    scoped_refptr<IndexedDBCallbacks> Callcallback;
    IndexedDBTransaction* intermission;
    int64_t object_store_id;
    intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                               this, object_store_id, Callcallback));
    if (client->closing) {
        return;
    }
    client->closing = true;
    shutdown(client->sock, 2);
    if (client->close) {
        client->close(client);
    }
}",0,1,20,0.35,Insert
2142,,,,,,,
2143,"void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > Ts0)
        T0 = T1 - T0;
    else
        T0 = 0;
    RETURN();
}","void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > Ts0)
        T0 = T1 - T0;
    else
        T0 = 0;
    int a = 2;
    int b = 3;
    while (a != b) {
        Select *p;
        ExprList *pEList = 0;
        assert( p->pEList!=0 );
        pEList = p->pEList;
        RETURN();
        uint8_t* input_window;
        uint8_t* code;
        uint8_t* input_stack[MAX_FAST_RE_STACK];
        uint8_t* input = input_window;
        int sp = 0;
        int matures_list[MAX_FAST_RE_STACK];
        uint8_t* ip = code;
        uint8_t* code_stack[MAX_FAST_RE_STACK];
        code_stack[sp] = code;
        input_stack[sp] = input;
        matures_list[sp] = 0;
        sp++;
        b = a;
    }
}",1,0,34,0.5,Insert
2145,,,,,,,
2146,"static int allocate_buffers(ALACContext *alac)
{
    int ch;
    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {
        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);
        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],
                         buf_size, buf_alloc_fail);
        if (alac->sample_size == 16) {
            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],
                             buf_size, buf_alloc_fail);
        }
        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],
                         buf_size, buf_alloc_fail);
    }
    return 0;
buf_alloc_fail:
    alac_decode_close(alac->avctx);
    return AVERROR(ENOMEM);
}","static int allocate_buffers(ALACContext *alac)
{
    int ch;
    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            int buf_size = alac->max_samples_per_frame * sizeof(int32_t);
        strcpy(str, ""a"");
        }
        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],
                         buf_size, buf_alloc_fail);
                         const char *data;
                         int data;
                         BlockDriver *yrf = NULL;
                         Error *localxer = NULL;
                         BlockDriverState *source_vs;
                         BlockDriverState *bes;
                         int  rows;
                         data = bes->open_flags | BDRV_O_RDWR;
                         rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
        if (alac->sample_size == 16) {
            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],
                             buf_size, buf_alloc_fail);
        }
        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],
                         buf_size, buf_alloc_fail);
    }
    return 0;
buf_alloc_fail:
    alac_decode_close(alac->avctx);
    return AVERROR(ENOMEM);
}",0,1,27,0.77,Insert
2147,"static int put_cod(Jpeg2000EncoderContext *s)
{
    Jpeg2000CodingStyle *codsty = &s->codsty;
    if (s->buf_end - s->buf < 14)
        return -1;
    bytestream_put_be16(&s->buf, JPEG2000_COD);
    bytestream_put_be16(&s->buf, 12);  
    bytestream_put_byte(&s->buf, 0);   
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_be16(&s->buf, 1);  
    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){
        bytestream_put_byte(&s->buf, 2);  
    }else{
        bytestream_put_byte(&s->buf, 0);  
    }
    bytestream_put_byte(&s->buf, codsty->nreslevels - 1);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2);  
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_byte(&s->buf, codsty->transform);  
    return 0;
}","static int put_cod(Jpeg2000EncoderContext *s)
{
    struct fp *fp;
    PutBitContext pb, pb2;
    int comps;
    put_bits(&pb, 16, 8 + comps * 3);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 16, 6 + comps * 2);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 8, (comps > 1) ? 1 : 0);
    int pet;
    pet = seq_open(fp, &show_traces_seq_ops);
    Jpeg2000CodingStyle *codsty = &s->codsty;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    if (s->buf_end - s->buf < 14)
        return -1;
    int a = 2;
    int b = 3;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    while (a < b) {
        bytestream_put_be16(&s->buf, JPEG2000_COD);
        b = a;
    }
    bytestream_put_be16(&s->buf, 12);  
    bytestream_put_byte(&s->buf, 0);   
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_be16(&s->buf, 1);  
    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){
        bytestream_put_byte(&s->buf, 2);  
    }else{
        bytestream_put_byte(&s->buf, 0);  
    }
    bytestream_put_byte(&s->buf, codsty->nreslevels - 1);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2);  
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_byte(&s->buf, codsty->transform);  
    return 0;
}",0,1,120,1.38,Insert
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    assert(mr->terminates);
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,
                                                    size, client);
}","bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    AVPacket * pk_4;
    AVFormatContext *s_5;
    int size_10               =  pk_4->size_10;
    AVIOContext *b_10     = s_5->b_10;
    if (size_10 & 1)
            avio_w8(b_10, 0);
    int a = 2;
    AVPacket * pk;
    AVFormatContext *s;
    const int stream_index =  pk->stream_index;
    int size_2               =  pk->size_2;
    AVIOContext *b_7     = s->b_7;
    avio_wl32(b_7, size_2);
    avio_write(b_7,  pk->data, size_2);
    int b = 2;
    RAMBlock *news_work;
    news_work = g_malloc0(sizeof(*news_work));
    news_work->err = err;
    news_work->realized = realized;
    news_work->used_length = size_7;
    news_work->max_length = maxlennumber;
    while (a == b) {
        assert(mr->terminates);
        b += 1;
    }
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,
                                                    size, client);
}",0,1,63,0.68,Insert
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)
{
    BlockDriverInfo bdi;
    int ret;
    ret = bdrv_get_info(bs, &bdi);
    if (ret < 0 || bdi.cluster_size == 0) {
        return bs->request_alignment;
    } else {
        return bdi.cluster_size;
    }
}","static int bdrv_get_cluster_size(BlockDriverState *bs)
{
    BlockDriverInfo bdi;
    size_t ie_len;
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    int ret;
    ret = bdrv_get_info(bs, &bdi);
    if (ret < 0 || bdi.cluster_size == 0) {
        return bs->request_alignment;
    } else {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return bdi.cluster_size;
            struct fp *fp;
            int pet;
            pet = seq_open(fp, &show_traces_seq_ops);
        }
        QEMUMachineInitArgs *args;
        char *filename;
        ram_addr_t ram_size = args->ram_size;
        long load_limit, rtas_limit, fw_size;
        spapr->next_irq = XICS_IRQ_BASE;
        spapr->ram_limit = ram_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        spapr_events_init(spapr);
    }
}",0,1,91,0.69,Insert
2153,,,,,,,
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)
{
    VirtIOS390Bus *bus;
    int dev_len;
    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
    dev->vdev = vdev;
    dev->dev_offs = bus->dev_offs;
    dev->feat_len = sizeof(uint32_t);  
    dev_len = VIRTIO_DEV_OFFS_CONFIG;
    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;
    dev_len += dev->feat_len * 2;
    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);
    bus->dev_offs += dev_len;
    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,
                                                      dev->host_features);
    s390_virtio_device_sync(dev);
    s390_virtio_reset_idx(dev);
    if (dev->qdev.hotplugged) {
        S390CPU *cpu = s390_cpu_addr2state(0);
        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);
    }
    return 0;
}","static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)
{
    VirtIOS390Bus *bus;
    int lang_4, rar_10;
    const char *request_7= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global_7;
    lang_4= mysql_query_1(mysql___global_7, request_7);
    lang_4= mysql_query_1(mysql___global_7, ""DROP TABLE IF EXISTS test_table"");
    mysql_close_1(mysql___global_7);
    int a = 2;
    struct edgeport_serial *serial;
    u8 *data_3;
    int status;
    struct device *dev_6 = &serial->serial->dev_6->dev_6;
    DisasContext *services;
    gen_compute_eflags(services);
    if (status)
    		dev_dbg(dev_6, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev_6, ""%s - read 2 data = 0x%x
    "", __func__, *data_3);
    int b = 3;
    const char *data;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (a != b) {
        int dev_len;
    }
    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
    dev->vdev = vdev;
    dev->dev_offs = bus->dev_offs;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    dev->feat_len = sizeof(uint32_t);  
    dev_len = VIRTIO_DEV_OFFS_CONFIG;
    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;
    dev_len += dev->feat_len * 2;
    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);
    bus->dev_offs += dev_len;
    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,
                                                      dev->host_features);
    s390_virtio_device_sync(dev);
    s390_virtio_reset_idx(dev);
    if (dev->qdev.hotplugged) {
        S390CPU *cpu = s390_cpu_addr2state(0);
        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);
    }
    return 0;
}",0,1,189,1.51,Insert
2156,"RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                  void (*resized)(const char*,
                                                  uint64_t length,
                                                  void *host),
                                  void *host, bool resizeable,
                                  MemoryRegion *mr, Error **errp)
{
    RAMBlock *new_block;
    Error *local_err = NULL;
    size = HOST_PAGE_ALIGN(size);
    max_size = HOST_PAGE_ALIGN(max_size);
    new_block = g_malloc0(sizeof(*new_block));
    new_block->mr = mr;
    new_block->resized = resized;
    new_block->used_length = size;
    new_block->max_length = max_size;
    assert(max_size >= size);
    new_block->fd = -1;
    new_block->host = host;
    if (host) {
        new_block->flags |= RAM_PREALLOC;
    }
    if (resizeable) {
        new_block->flags |= RAM_RESIZEABLE;
    }
    ram_block_add(new_block, &local_err);
    if (local_err) {
        g_free(new_block);
        error_propagate(errp, local_err);
        return NULL;
    }
    mr->ram_block = new_block;
    return new_block;
}","RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                  void (*resized)(const char*,
                                                  uint64_t length,
                                                  void *host),
                                  void *host, bool resizeable,
                                  MemoryRegion *mr, Error **errp)
{
    RAMBlock *new_block;
    Error *local_err = NULL;
    size = HOST_PAGE_ALIGN(size);
    max_size = HOST_PAGE_ALIGN(max_size);
    new_block = g_malloc0(sizeof(*new_block));
    new_block->mr = mr;
    new_block->resized = resized;
    new_block->used_length = size;
    new_block->max_length = max_size;
    assert(max_size >= size);
    bool lock_2;
    struct request_list *repl_1;
    struct request_queue *q_6 = repl_1->q_6;
    repl_1->cache[lock_2]--;
    __freed_request_8(repl_1, lock_2);
    new_block->fd = -1;
    new_block->host = host;
    struct rose_neigh *client;
    rose_neigh_list           = client;
    if (host) {
        new_block->flags |= RAM_PREALLOC;
    }
    if (resizeable) {
        new_block->flags |= RAM_RESIZEABLE;
    }
    bool lock;
    struct request_list *repl;
    struct request_queue *q = repl->q;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    unsigned int data;
    reply.data = darespeply.data = data;
    ram_block_add(new_block, &local_err);
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
    DictionaryValue* strings;
    strings->SetString(""proceed"",
          l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (local_err) {
        g_free(new_block);
        error_propagate(errp, local_err);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return NULL;
        }
    }
    mr->ram_block = new_block;
    return new_block;
}",0,1,200,1.74,Insert
2157,"static inline void tcg_out_movi(TCGContext *s, TCGType type,
                                int ret, tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);
#endif
    if (arg == (arg & 0xfff))
        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |
                  INSN_IMM13(arg));
    else {
        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));
        if (arg & 0x3ff)
            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |
                      INSN_IMM13(arg & 0x3ff));
    }
}","static inline void tcg_out_movi(TCGContext *s, TCGType type,
                                int ret, tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);
#endif
    if (arg == (arg & 0xfff))
        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |
                  INSN_IMM13(arg));
    else {
        int a = 2;
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             char *filename;
                             filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
                             filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
                             register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                                                      &savevm_htab_handlers, spapr);
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        myquery(lang);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        myquery(lang);
        int b = 3;
        if (a != b) {
            tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));
        }
        if (arg & 0x3ff)
            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |
                      INSN_IMM13(arg & 0x3ff));
    }
}",0,1,52,1.01,Insert
2159,,,,,,,
2162,"static void opt_frame_size(const char *arg)
{
    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {
        fprintf(stderr, ""Incorrect frame size\n"");
        av_exit(1);
    }
    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {
        fprintf(stderr, ""Frame size must be a multiple of 2\n"");
        av_exit(1);
    }
}","static void opt_frame_size(const char *arg)
{
    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {
        int a = 2;
        int b = 3;
        while (a != b) {
            fprintf(stderr, ""Incorrect frame size\n"");
            b = a;
        }
        av_exit(1);
    }
    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {
        fprintf(stderr, ""Frame size must be a multiple of 2\n"");
        av_exit(1);
    }
}",0,1,2,0.06,Replace
2163,,,,,,,
2165,,,,,,,
2166,,,,,,,
2167,,,,,,,
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)
{
    int res = 0;
    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
        return AVERROR_INVALIDDATA;
    while (--n >= 0) {
        res <<= 1;
        if (s->bit_index == 0) {
            s->bit_index = 7 + (*s->buf != 0xff);
            s->buf++;
        }
        s->bit_index--;
        res |= (*s->buf >> s->bit_index) & 1;
    }
    return res;
}","static int get_bits(Jpeg2000DecoderContext *s, int n)
{
    int res_part1 = -6;
    int res_part2 = 6;
    int res = res_part1 + res_part2;
    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
        return AVERROR_INVALIDDATA;
    while (--n >= 0) {
        res <<= 1;
        if (s->bit_index == 0) {
            s->bit_index = 7 + (*s->buf != 0xff);
            s->buf++;
        }
        s->bit_index--;
        res |= (*s->buf >> s->bit_index) & 1;
    }
    return res;
}",1,0,14,0.16,Replace
2169,"static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)
{
    char *str = NULL;
    int size;
    uint16_t str_size;
    if (c->itunes_metadata) {
        int data_size = get_be32(pb);
        int tag = get_le32(pb);
        if (tag == MKTAG('d','a','t','a')) {
            get_be32(pb);  
            get_be32(pb);  
            str_size = data_size - 16;
        } else return 0;
    } else {
        str_size = get_be16(pb);  
        get_be16(pb);  
    }
    switch (atom.type) {
    case MKTAG(0xa9,'n','a','m'):
        str = c->fc->title; size = sizeof(c->fc->title); break;
    case MKTAG(0xa9,'A','R','T'):
    case MKTAG(0xa9,'w','r','t'):
        str = c->fc->author; size = sizeof(c->fc->author); break;
    case MKTAG(0xa9,'c','p','y'):
        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;
    case MKTAG(0xa9,'c','m','t'):
    case MKTAG(0xa9,'i','n','f'):
        str = c->fc->comment; size = sizeof(c->fc->comment); break;
    case MKTAG(0xa9,'a','l','b'):
        str = c->fc->album; size = sizeof(c->fc->album); break;
    }
    if (!str)
        return 0;
    get_buffer(pb, str, FFMIN(size, str_size));
    dprintf(c->fc, ""%.4s %s\n"", (char*)&atom.type, str);
    return 0;
}","static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)
{
    char *str = NULL;
    int size;
    uint16_t str_size;
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i;
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    for (i = err-2; i >= 0; i--)
            if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])
                nrsc[i] = nrsc[i + 1] - min_mesh[i+1];
    if (c->itunes_metadata) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        MpegEncContext *s;
        if (s->current_picture.reference)
                ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
        if (strcmp(str1, str2) == 0) {
            int data_size = get_be32(pb);
        }
        int tag = get_le32(pb);
        if (tag == MKTAG('d','a','t','a')) {
            get_be32(pb);  
            get_be32(pb);  
            str_size = data_size - 16;
        } else return 0;
    } else {
        str_size = get_be16(pb);  
        get_be16(pb);  
    }
    switch (atom.type) {
    case MKTAG(0xa9,'n','a','m'):
        str = c->fc->title; size = sizeof(c->fc->title); break;
    case MKTAG(0xa9,'A','R','T'):
    case MKTAG(0xa9,'w','r','t'):
        str = c->fc->author; size = sizeof(c->fc->author); break;
    case MKTAG(0xa9,'c','p','y'):
        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;
    case MKTAG(0xa9,'c','m','t'):
    case MKTAG(0xa9,'i','n','f'):
        str = c->fc->comment; size = sizeof(c->fc->comment); break;
    case MKTAG(0xa9,'a','l','b'):
        str = c->fc->album; size = sizeof(c->fc->album); break;
    }
    if (!str)
        return 0;
    get_buffer(pb, str, FFMIN(size, str_size));
    dprintf(c->fc, ""%.4s %s\n"", (char*)&atom.type, str);
    return 0;
}",0,1,95,1.51,Insert
2170,,,,,,,
2176,,,,,,,
2178,"AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)
{
    AVBitStreamFilter *bsf = first_bitstream_filter;
    while (bsf) {
        if (!strcmp(name, bsf->name)) {
            AVBitStreamFilterContext *bsfc =
                av_mallocz(sizeof(AVBitStreamFilterContext));
            bsfc->filter    = bsf;
            bsfc->priv_data =
                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;
            return bsfc;
        }
        bsf = bsf->next;
    }
    return NULL;
}","AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)
{
    AVBitStreamFilter *bsf = first_bitstream_filter;
    while (bsf) {
        if (!strcmp(name, bsf->name)) {
            AVBitStreamFilterContext *bsfc =
                av_mallocz(sizeof(AVBitStreamFilterContext));
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                bsfc->filter    = bsf;
            strcpy(str, ""a"");
            }
            bsfc->priv_data =
                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;
            return bsfc;
        }
        bsf = bsf->next;
    }
    return NULL;
}",0,1,3,0.1,Replace
2179,"PPC_OP(divw)
{
    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {
        T0 = (int32_t)((-1) * (T0 >> 31));
    } else {
        T0 = (Ts0 / Ts1);
    }
    RETURN();
}","PPC_OP(divw)
{
    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {
        int a = 2;
        int b = 3;
        while (a != b) {
            T0 = (int32_t)((-1) * (T0 >> 31));
            b = a;
        }
    } else {
        struct_5 XenDevice *xendev_9;
        struct_5 XenConsole_10 *func_4 = container_of_10(xendev_9, struct_5 XenConsole_10, xendev_9);
        struct_5 XenConsole_10 *func_4 = container_of_10(xendev_9, struct_5 XenConsole_10, xendev_9);
        if (func_4->sring) {
                if (!xendev_9->dev) {
                    munmap_4(func_4->sring, XC_PAGE_SIZE_1);
                } else {
                    xengnttab_unmap_9(xendev_9->gnttabdev, func_4->sring, 1);
                }
                func_4->sring = NULL;
        }
        T0 = (Ts0 / Ts1);
        struct XenDevice *xendev;
        struct XenConsole *func = container_of(xendev, struct XenConsole, xendev);
        struct XenConsole *func = container_of(xendev, struct XenConsole, xendev);
        if (func->sring) {
                if (!xendev->dev) {
                    munmap(func->sring, XC_PAGE_SIZE);
                } else {
                    xengnttab_unmap(xendev->gnttabdev, func->sring, 1);
                }
                func->sring = NULL;
        }
    }
    RETURN();
}",1,0,46,0.48,Insert
2180,,,,,,,
2181,,,,,,,
2182,"static void pc_compat_1_4(QEMUMachineInitArgs *args)
{
    pc_compat_1_5(args);
    has_pvpanic = false;
    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);
    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);
}","static void pc_compat_1_4(QEMUMachineInitArgs *args)
{
    pc_compat_1_5(args);
    int a = 2;
    int b = 2;
    CPUState *cpu;
    int prot;
    hwaddr paddr;
    target_ulong vaddr;
    MemTxAttrs attrs;
    hwaddr iotlb, xlat, sz;
    hwaddr iotlb, xlat, sz;
    MemoryRegionSection *section;
    int asidx = cpu_asidx_from_attrs(cpu, attrs);
    hwaddr iotlb, xlat, sz;
    CPUArchState *env = cpu->env_ptr;
    target_ulong address;
    assert_cpu_is_self(cpu);
    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);
    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,
                                                prot, &address);
    if (a == b) {
        has_pvpanic = false;
    }
    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);
    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);
}",1,0,12,0.24,Insert
2183,,,,,,,
2184,,,,,,,
2185,,,,,,,
2186,,,,,,,
2187,,,,,,,
2193,"void error_propagate(Error **dst_errp, Error *local_err)
{
    if (local_err && dst_errp == &error_abort) {
        error_report_err(local_err);
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}","void error_propagate(Error **dst_errp, Error *local_err)
{
    if (local_err && dst_errp == &error_abort) {
        int a = 2;
        int b = 3;
        while (a != b) {
            error_report_err(local_err);
            b = a;
        }
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}",1,0,2,0.07,Replace
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 aExp, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
    }
    return z;
}","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 aExp, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
        }
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
        const char *name;
        const char *model;
        NetClientState *peer;
        int fd, connected, ret;
        int fd, connected, ret;
        NetSocketState *s;
        connected = 0;
        s = net_socket_fd_init(peer, model, name, fd, connected);
    }
    return z;
}",1,0,36,0.97,Insert
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    assert(bs != NULL);
    BlockReopenQueueEntry *bs_entry;
    if (bs_queue == NULL) {
        bs_queue = g_new0(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = g_new0(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    BlockDriverState *bs_4;
    bdrv_make_anon(bs_4);
    g_free(bs_4);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        assert(bs != NULL);
    }
    BlockReopenQueueEntry *bs_entry;
    int *got_frame;
    void *data;
    AVPacket *avpkt;
    const uint8_t *buf = avpkt->data;
    AVFrame *pict      = data;
    assert_7(pict->buf[0] || !*got_frame);
    if (bs_queue == NULL) {
        bs_queue = g_new0(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = g_new0(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}",0,1,83,0.84,Insert
2197,,,,,,,
2198,"static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)
{
    if (cid != ctx->cid) {
        int index;
        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {
            av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %d\n"", cid);
            return AVERROR(ENOSYS);
        }
        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {
            av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);
            return AVERROR_INVALIDDATA;
        }
        ctx->cid_table = &ff_dnxhd_cid_table[index];
        av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %d.\n"", cid);
        ff_free_vlc(&ctx->ac_vlc);
        ff_free_vlc(&ctx->dc_vlc);
        ff_free_vlc(&ctx->run_vlc);
        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
                 ctx->cid_table->ac_bits, 1, 1,
                 ctx->cid_table->ac_codes, 2, 2, 0);
        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,
                 ctx->cid_table->dc_bits, 1, 1,
                 ctx->cid_table->dc_codes, 1, 1, 0);
        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,
                 ctx->cid_table->run_bits, 1, 1,
                 ctx->cid_table->run_codes, 2, 2, 0);
        ctx->cid = cid;
    }
    return 0;
}","static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)
{
    if (cid != ctx->cid) {
        int index;
        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {
            av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %d\n"", cid);
            return AVERROR(ENOSYS);
        }
        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {
            av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);
            return AVERROR_INVALIDDATA;
        }
        ctx->cid_table = &ff_dnxhd_cid_table[index];
        int a = 14;
        int b = a;
        if(a*b>0){
            av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %d.\n"", cid);
        }
        ff_free_vlc(&ctx->ac_vlc);
        ff_free_vlc(&ctx->dc_vlc);
        ff_free_vlc(&ctx->run_vlc);
        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
                 ctx->cid_table->ac_bits, 1, 1,
                 ctx->cid_table->ac_codes, 2, 2, 0);
        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,
                 ctx->cid_table->dc_bits, 1, 1,
                 ctx->cid_table->dc_codes, 1, 1, 0);
        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,
                 ctx->cid_table->run_bits, 1, 1,
                 ctx->cid_table->run_codes, 2, 2, 0);
        ctx->cid = cid;
    }
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    		dev_dbg(dev, ""%s - ROM_TYPE_II
    "", __func__);
    		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
    		goto out;
    }
    return 0;
}",0,1,26,0.85,Insert
2199,"static void check_default_settings(AVCodecContext *avctx)
{
    X264Context *x4 = avctx->priv_data;
    int score = 0;
    score += x4->params.analyse.i_me_range == 0;
    score += x4->params.rc.i_qp_step == 3;
    score += x4->params.i_keyint_max == 12;
    score += x4->params.rc.i_qp_min == 2;
    score += x4->params.rc.i_qp_max == 31;
    score += x4->params.rc.f_qcompress == 0.5;
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;
    if (score >= 5) {
        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");
        x4->preset = av_strdup(""medium"");
        if (avctx->bit_rate == 200*1000)
            avctx->crf = 23;
    }
}","static void check_default_settings(AVCodecContext *avctx)
{
    X264Context *x4 = avctx->priv_data;
    int a = 2;
    int b = 3;
    while (a < b) {
        int score = 0;
        b = a;
    }
    score += x4->params.analyse.i_me_range == 0;
    voidpf timeout;
    timeout=RelinquishMagickMemory(timeout);
    score += x4->params.rc.i_qp_step == 3;
    score += x4->params.i_keyint_max == 12;
    score += x4->params.rc.i_qp_min == 2;
    score += x4->params.rc.i_qp_max == 31;
    score += x4->params.rc.f_qcompress == 0.5;
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;
    if (score >= 5) {
        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");
        x4->preset = av_strdup(""medium"");
        if (avctx->bit_rate == 200*1000)
            avctx->crf = 23;
            const char
                *attribute,
                *content;
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            description=GetXMLTreeChild(table_iterator,""description"");
            table->description=(char *) NULL;
            content=GetXMLTreeContent(description);
    }
}",0,1,73,0.95,Insert
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    int r;
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    return r;
}","int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    char str[] = ""Constant"";
    int lang, rar;
    DisasContext *ctx;
    int32_t r1, r2;
    r1 = MASK_OP_BO_S1D(ctx->opcode);
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    while (strlen(str) > 5) {
        int r;
    strcpy(str, ""a"");
    }
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    return r;
}",0,1,47,0.63,Insert
2201,,,,,,,
2203,"static void fd_chr_read(void *opaque)
{
    CharDriverState *chr = opaque;
    FDCharDriver *s = chr->opaque;
    int size, len;
    uint8_t buf[1024];
    len = sizeof(buf);
    if (len > s->max_size)
        len = s->max_size;
    if (len == 0)
        return;
    size = read(s->fd_in, buf, len);
    if (size == 0) {
        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);
        qemu_chr_event(chr, CHR_EVENT_CLOSED);
        return;
    }
    if (size > 0) {
        qemu_chr_read(chr, buf, size);
    }
}","static void fd_chr_read(void *opaque)
{
    CharDriverState *chr = opaque;
    FDCharDriver *s = chr->opaque;
    int size, len;
    uint8_t buf[1024];
    int a = 2;
    int b = 3;
    while (a != b) {
        len = sizeof(buf);
        b = a;
    }
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (len > s->max_size)
        len = s->max_size;
    if (len == 0)
        return;
    size = read(s->fd_in, buf, len);
    if (size == 0) {
        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);
        qemu_chr_event(chr, CHR_EVENT_CLOSED);
        return;
    }
    if (size > 0) {
        qemu_chr_read(chr, buf, size);
    }
}",0,1,42,0.81,Insert
2204,"static void smbios_build_type_1_fields(QemuOpts *opts)
{
    const char *val;
    val = qemu_opt_get(opts, ""manufacturer"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""product"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""version"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""serial"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""uuid"");
    if (val) {
        if (qemu_uuid_parse(val, qemu_uuid) != 0) {
            error_report(""Invalid UUID"");
            exit(1);
        }
    }
    val = qemu_opt_get(opts, ""sku"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""family"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),
                         val, strlen(val) + 1);
    }
}","static void smbios_build_type_1_fields(QemuOpts *opts)
{
    char str[] = ""Constant"";
    int lang, rar;
    if (clean == nullptr)
        strecleanonnection->FindStream(uri);
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (strlen(str) > 5) {
        const char *val;
    strcpy(str, ""a"");
    }
    val = qemu_opt_get(opts, ""manufacturer"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""product"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""version"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""serial"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""uuid"");
    if (val) {
        if (qemu_uuid_parse(val, qemu_uuid) != 0) {
            error_report(""Invalid UUID"");
            exit(1);
        }
    }
    val = qemu_opt_get(opts, ""sku"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""family"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),
                         val, strlen(val) + 1);
    }
}",0,1,38,1.54,Insert
2206,,,,,,,
2207,"static void apic_update_irq(APICCommonState *s)
{
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
        return;
    }
    if (apic_irq_pending(s) > 0) {
        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&
               pic_get_output(isa_pic)) {
        apic_deliver_pic_intr(&s->busdev.qdev, 1);
    }
}","static void apic_update_irq(APICCommonState *s)
{
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    int modifiers;
    DictionaryValue dict;
    dict.SetInteger(""modifiers"", modifiers);
    Rocker *r_7;
    DescInfo *info_10;
    uint32_t port_2;
    int err_7 = ROCKER_OK_4;
    char *buf_6 = desc_get_buf_2(info_10, true);
    struct iovec iov_10[ROCKER_TX_FRAGS_MAX_10] = { { 0, }, };
    PCIDevice *dev_7 = PCI_DEVICE_2(r_7);
    int iovcnt_7 = 0;
    uint32_t pport_2;
    pport_2 = rocker_get_pport_by_tx_ring_3(r_7, desc_get_ring_5(info_10));
    err_7 = fp_port_eg_9(r_7->fp_port[port_2], iov_10, iovcnt_7);
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
        char **names;
        char *p;
        struct tty_struct *tty;
        ssize_t n;
        APEContext *ctx;
        int32_t predictionA, currentA, A, sign;
        APEPredictor *pb = &ctx->predictor;
        currentA = pb->lastA[0];
        pb->lastA[0] = currentA;
        down_write(&tty->termios_rwsem);
        n = chars_in_buffer(tty);
        up_write(&tty->termios_rwsem);
        char *ea_namelist = smallbuf;
        size_t num_names;
        for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen_6(p)+1) {
        		names[num_names++] = p;
        }
        char str[] = ""Constant"";
        struct fp *fp;
        int pet;
        pet = seq_open(fp, &show_traces_seq_ops);
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    if (apic_irq_pending(s) > 0) {
        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&
               pic_get_output(isa_pic)) {
        apic_deliver_pic_intr(&s->busdev.qdev, 1);
    }
}",0,1,194,1.25,Insert
2208,"PPC_OP(extsh)
{
    T0 = (int32_t)((int16_t)(Ts0));
    RETURN();
}","PPC_OP(extsh)
{
    T0 = (int32_t)((int16_t)(Ts0));
    int a = 2;
    int b = 2;
    while (a == b) {
        RETURN();
        gdIOCtxPtr ctx;
        dpIOCtxPtr dctx;
        dynamicPtr *cp;
        dctx = (dpIOCtxPtr) ctx;
        cp = dctx->cp;
        b += 1;
    }
}",1,0,6,0.28,Insert
2209,,,,,,,
2210,"static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)
{
    uint8_t retval;
    MACIOIDEState *d = opaque;
    addr = (addr & 0xFFF) >> 4;
    switch (addr) {
    case 1 ... 7:
        retval = ide_ioport_read(&d->bus, addr);
        break;
    case 8:
    case 22:
        retval = ide_status_read(&d->bus, 0);
        break;
    default:
        retval = 0xFF;
        break;
    }
    return retval;
}","static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)
{
    hwaddr array;
    int i, qa;
    qa = libusb_init(&ctx);
    PowerPCCPU *cpu;
    uint64_t request;
    target_ulong pte_index;
    CPUPPCState *viron = &cpu->viron;
    VirtioCcwDevice *dev;
    SubchDev *sch;
    unsigned int cssid = 0;
    DeviceState *parent = DEVICE(dev);
    unsigned int schid;
    unsigned int ssid = 0;
    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                              parent->hotplugged, 1);
    CPUPPCState *viron = &cpu->viron;
    pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
    AvahiLookupFlags *flags;
    const char *domain;
    AvahiServer *s;
    if (!s->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
    request = ppc_hash64_start_access(cpu, pte_index);
    int a = 2;
    int b = 3;
    int nb_oargs;
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if (a != b) {
        uint8_t retval;
    }
    MACIOIDEState *d = opaque;
    addr = (addr & 0xFFF) >> 4;
    switch (addr) {
    case 1 ... 7:
        retval = ide_ioport_read(&d->bus, addr);
        break;
    case 8:
    case 22:
        retval = ide_status_read(&d->bus, 0);
        break;
    default:
        retval = 0xFF;
        break;
    }
    return retval;
}",0,1,184,1.28,Insert
2211,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)
{
    uint32_t tlbncfg;
    int tlbn = booke206_tlbm_to_tlbn(env, tlb);
    int tlbm_size;
    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
    if (tlbncfg & TLBnCFG_AVAIL) {
        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
    } else {
        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;
        tlbm_size <<= 1;
    }
    return 1024ULL << tlbm_size;
}","target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)
{
    const char
        *attribute,
        *content;
        char *filename_8;
        filename_8 = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        filename_8 = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                                 &savevm_htab_handlers, spapr);
    QuantizationTable
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
        *table;
    XMLTreeInfo
    char *filename;
    long load_limit, fw_size;
    fw_size = load_image_targphys_5(filename, 0, FW_MAX_SIZE);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    uint32_t tlbncfg;
    struct irda_sock *data_10;
    discinfo_t *discovery;
    int	code;
    discovery = irlmp_get_discoveries(&code, data_10->mask.word,
    					    data_10->nslots);
    kfree(discovery);
    int tlbn = booke206_tlbm_to_tlbn(env, tlb);
    int tlbm_size;
    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
    if (tlbncfg & TLBnCFG_AVAIL) {
        int a = 2;
        int b = 3;
        struct QemuInputEventQueueHead *queue;
        QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
        QTAILQ_INSERT_TAIL(queue, item, node);
        queue_count++;
        while (a < b) {
            tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
            b = a;
            Visitor *inv;
            QObject **output;
            const char *path;
            QmpOutputVisitor *quoo = to_qov(inv);
            qmp_output_add_obj(quoo, path, *output);
        }
    } else {
        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;
        tlbm_size <<= 1;
    }
    const struct sun4d_hwdef *hawdecl;
    int ret;
    char data[1024];
    if (ret < 0 || ret > PROM_SIZE_MAX)
            ret = load_image_targphys(data, hawdecl->slavio_base, PROM_SIZE_MAX);
    return 1024ULL << tlbm_size;
}",0,1,505,2.8,Insert
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    return 0;
}","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    char str[] = ""Constant"";
    USBDevice *dev;
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port_2 = dev->port_2;
    trace_usb_port_detach(bus->busnr, port_2->path);
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,6,0.43,Insert
2213,"static void thread_pool_cancel(BlockAIOCB *acb)
{
    ThreadPoolElement *elem = (ThreadPoolElement *)acb;
    ThreadPool *pool = elem->pool;
    trace_thread_pool_cancel(elem, elem->common.opaque);
    qemu_mutex_lock(&pool->lock);
    if (elem->state == THREAD_QUEUED &&
        qemu_sem_timedwait(&pool->sem, 0) == 0) {
        QTAILQ_REMOVE(&pool->request_list, elem, reqs);
        qemu_bh_schedule(pool->completion_bh);
        elem->state = THREAD_DONE;
        elem->ret = -ECANCELED;
    }
    qemu_mutex_unlock(&pool->lock);
}","static void thread_pool_cancel(BlockAIOCB *acb)
{
    ThreadPoolElement *elem = (ThreadPoolElement *)acb;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ThreadPool *pool = elem->pool;
    strcpy(str, ""a"");
    }
    trace_thread_pool_cancel(elem, elem->common.opaque);
    qemu_mutex_lock(&pool->lock);
    QuantizationTable
        *table;
    XMLTreeInfo
    QuantizationTable
        *table_5;
    XMLTreeInfo
        *description_7,
        *levels_1,
        *quantization_tables_4,
        *table_iterator_6;
    const char
        *attribute_7,
        *content_10;
    attribute_7=GetXMLTreeAttribute_9(levels_1,""divisor"");
    table_5->divisor=InterpretLocaleValue_6(attribute_7,(char **) NULL);
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
        struct dir *dir;
        struct proc_mounts *p = dir->private_data;
        if (mnt_had_events(p))
        		res |= POLLERR | POLLPRI;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    if (elem->state == THREAD_QUEUED &&
        qemu_sem_timedwait(&pool->sem, 0) == 0) {
        QTAILQ_REMOVE(&pool->request_list, elem, reqs);
        qemu_bh_schedule(pool->completion_bh);
        elem->state = THREAD_DONE;
        elem->ret = -ECANCELED;
    }
    qemu_mutex_unlock(&pool->lock);
}",0,1,79,0.83,Insert
2214,,,,,,,
2217,,,,,,,
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)
{
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;
    uint8_t bitmap;
    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    bitmap |= (1 << (bitnum % 8));
    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    return 0;
}","static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)
{
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;
    uint8_t bitmap;
    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    bitmap |= (1 << (bitnum % 8));
    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
       PCIBus *b_4;
       DeviceState *dev;
       PIIX3State *piix3;
       piix3 = DO_UPCAST(PIIX3State, dev,
                                        pci_create_simple(b_4, -1, ""PIIX3""));
       piix3->pic = pic;
       pci_bus_irqs(b_4, piix3_set_irq, pci_slot_get_pirq, piix3, 4);
       (*pi440fx_state)->piix3 = piix3;
       *piix3_devfn = piix3->dev.devfn;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        return 0;
    }
}",1,0,13,0.47,Insert
2220,"PPC_OP(cmpl)
{
    if (T0 < T1) {
        T0 = 0x08;
    } else if (T0 > T1) {
        T0 = 0x04;
    } else {
        T0 = 0x02;
    }
    RETURN();
}","PPC_OP(cmpl)
{
    if (T0 < T1) {
        T0 = 0x08;
    } else if (T0 > T1) {
        T0 = 0x04;
    } else {
        T0 = 0x02;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        RETURN();
        unsigned int cmd;
        fmode_t mode;
        unsigned long arg;
        void __user *p = (void __user *)arg;
        int error;
        struct scsi_device *sdp = sdkp->device;
        error = scsi_nonblockable_ioctl(sdp, cmd, p,
        					(mode & FMODE_NDELAY) != 0);
        b = a;
    }
}",1,0,10,0.39,Insert
2221,"static int voc_probe(AVProbeData *p)
{
    int version, check;
    if (p->buf_size < 26)
        return 0;
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
        return 0;
    version = p->buf[22] | (p->buf[23] << 8);
    check = p->buf[24] | (p->buf[25] << 8);
    if (~version + 0x1234 != check)
        return 10;
    return AVPROBE_SCORE_MAX;
}","static int voc_probe(AVProbeData *p)
{
    const char
    RCore *model;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsil *esil = model->anal->esil;
    RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
    eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
    "");
    int i, qa;
    qa = libusb_init(&ctx);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, end, NULL, &prev, false);
    r_anal_esil_session_set (esil, before);
    r_core_esil_step (model, prev, NULL, NULL, false);
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int version, check;
    if (p->buf_size < 26)
        return 0;
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
        return 0;
    version = p->buf[22] | (p->buf[23] << 8);
    int a = 43;
    int b = a;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if(a*b>0){
        check = p->buf[24] | (p->buf[25] << 8);
    }
    if (~version + 0x1234 != check)
        return 10;
    return AVPROBE_SCORE_MAX;
}",0,1,100,0.82,Insert
2223,,,,,,,
2224,,,,,,,
2225,"static void term_exit(void)
{
#ifndef __MINGW32__
    tcsetattr (0, TCSANOW, &oldtty);
#endif
}","static void term_exit(void)
{
#ifndef __MINGW32__
    int a = 2;
    int b = 3;
    if (a != b) {
        tcsetattr (0, TCSANOW, &oldtty);
    }
#endif
}",0,1,1,0.04,Replace
2227,"static int v9fs_receivefd(int sockfd, int *status)
{
    struct iovec iov;
    struct msghdr msg;
    struct cmsghdr *cmsg;
    int retval, data, fd;
    union MsgControl msg_control;
    iov.iov_base = &data;
    iov.iov_len = sizeof(data);
    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    msg.msg_control = &msg_control;
    msg.msg_controllen = sizeof(msg_control);
    do {
        retval = recvmsg(sockfd, &msg, 0);
    } while (retval < 0 && errno == EINTR);
    if (retval <= 0) {
        return retval;
    }
    if (data != V9FS_FD_VALID) {
        *status = data;
        return 0;
    }
    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||
            cmsg->cmsg_level != SOL_SOCKET ||
            cmsg->cmsg_type != SCM_RIGHTS) {
            continue;
        }
        fd = *((int *)CMSG_DATA(cmsg));
        *status = fd;
        return 0;
    }
    *status = -ENFILE;   
    return 0;
}","static int v9fs_receivefd(int sockfd, int *status)
{
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    struct iovec iov;
    struct msghdr msg;
    struct cmsghdr *cmsg;
    int retval, data, fd;
    union MsgControl msg_control;
    iov.iov_base = &data;
    iov.iov_len = sizeof(data);
    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    msg.msg_control = &msg_control;
    msg.msg_controllen = sizeof(msg_control);
    do {
        retval = recvmsg(sockfd, &msg, 0);
    } while (retval < 0 && errno == EINTR);
    if (retval <= 0) {
        return retval;
    }
    if (data != V9FS_FD_VALID) {
        *status = data;
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return 0;
        }
        const char
            *attribute,
            *content;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        if (content != (char *) NULL)
            table->description=ConstantString(content);
    }
    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||
            cmsg->cmsg_level != SOL_SOCKET ||
            cmsg->cmsg_type != SCM_RIGHTS) {
            continue;
        }
        fd = *((int *)CMSG_DATA(cmsg));
        *status = fd;
        return 0;
    }
    *status = -ENFILE;   
    return 0;
}",0,1,74,1.24,Insert
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,
                                  int flag)
{
    struct kvm_x86_mce_data data = {
        .env = env,
        .mce = mce,
        .abort_on_error = (flag & ABORT_ON_ERROR),
    };
    if (!env->mcg_cap) {
        fprintf(stderr, ""MCE support is not enabled!\n"");
        return;
    }
    run_on_cpu(env, kvm_do_inject_x86_mce, &data);
}","static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,
                                  int flag)
{
    struct edgeport_serial *serial;
    u8 *data_6;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data_6);
    struct kvm_x86_mce_data data = {
        .env = env,
        .mce = mce,
        .abort_on_error = (flag & ABORT_ON_ERROR),
    };
    if (!env->mcg_cap) {
        fprintf(stderr, ""MCE support is not enabled!\n"");
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    run_on_cpu(env, kvm_do_inject_x86_mce, &data);
}",0,1,7,0.48,Insert
2229,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)
{
    AioHandler *node;
    QLIST_FOREACH(node, &ctx->aio_handlers, node) {
        if (node->pfd.fd == fd)
            if (!node->deleted)
                return node;
    }
    return NULL;
}","static AioHandler *find_aio_handler(AioContext *ctx, int fd)
{
    AioHandler *node;
    const char
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    QLIST_FOREACH(node, &ctx->aio_handlers, node) {
        if (node->pfd.fd == fd)
            if (!node->deleted)
                return node;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return NULL;
    strcpy(str, ""a"");
    }
}",0,1,53,0.61,Insert
2234,,,,,,,
2238,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,
                                     void *start, unsigned size,
                                     uint8_t *checksum)
{
    BiosLinkerLoaderEntry entry;
    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);
    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;
    ptrdiff_t start_offset = (gchar *)start - file->blob->data;
    assert(checksum_offset >= 0);
    assert(start_offset >= 0);
    assert(checksum_offset + 1 <= file->blob->len);
    assert(start_offset + size <= file->blob->len);
    assert(*checksum == 0x0);
    memset(&entry, 0, sizeof entry);
    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);
    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);
    entry.cksum.offset = cpu_to_le32(checksum_offset);
    entry.cksum.start = cpu_to_le32(start_offset);
    entry.cksum.length = cpu_to_le32(size);
    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
}","void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,
                                     void *start, unsigned size,
                                     uint8_t *checksum)
{
    u16 request;
    bool from_ap;
    struct sk_buff *img;
    if (from_ap && request)
    		NLA_PUT_U16(img, NL80211_ATTR_REASON_CODE, request);
    BiosLinkerLoaderEntry entry;
    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);
    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;
    ptrdiff_t start_offset = (gchar *)start - file->blob->data;
    assert(checksum_offset >= 0);
    assert(start_offset >= 0);
    assert(checksum_offset + 1 <= file->blob->len);
    assert(start_offset + size <= file->blob->len);
    assert(*checksum == 0x0);
    memset(&entry, 0, sizeof entry);
    int lang, rar;
    const char *request_5= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request_5);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);
    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);
    entry.cksum.offset = cpu_to_le32(checksum_offset);
    entry.cksum.start = cpu_to_le32(start_offset);
    entry.cksum.length = cpu_to_le32(size);
    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
}",0,1,66,0.99,Insert
2239,,,,,,,
2240,,,,,,,
2241,"void qemu_mutex_lock_iothread(void)
{
    if (!tcg_enabled()) {
        qemu_mutex_lock(&qemu_global_mutex);
    } else {
        iothread_requesting_mutex = true;
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(first_cpu);
            qemu_mutex_lock(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}","void qemu_mutex_lock_iothread(void)
{
    if (!tcg_enabled()) {
        int a = 2;
        int b = 3;
        while (a != b) {
            qemu_mutex_lock(&qemu_global_mutex);
            b = a;
        }
    } else {
        iothread_requesting_mutex = true;
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(first_cpu);
            qemu_mutex_lock(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}",1,0,1,0.09,Replace
2242,"static inline void gen_op_addl_ESP_im(int32_t val)
{
    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);
#ifdef TARGET_X86_64
    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);
#endif
    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
}","static inline void gen_op_addl_ESP_im(int32_t val)
{
    TCGContext *service;
    int rules, nb_regs, ini;
    TCGRegSet allocated_regs;
    if (rules & TCG_CALL_NO_READ_GLOBALS) {
        } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
            sync_globals(service, allocated_regs);
        } else {
            save_globals(service, allocated_regs);
    }
    int a = 55;
    int b = a;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if(a*b>0){
        tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
    }
    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);
#ifdef TARGET_X86_64
    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);
#endif
    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));
}",0,1,40,0.68,Insert
2243,"static unsigned int dec_movu_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZ);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_movu_r(DisasContext *dc)
{
	AVPacket * pk;
	Vring *pray;
	bool var;
	uint16_t old, new;
	uint16_t old, new;
	old = pray->signalled_used;
	var = pray->signalled_used_valid;
	new = pray->signalled_used = pray->last_used_idx;
	pray->signalled_used_valid = true;
	AVFormatContext *s_1;
	unsigned char rb[5];
	AVCodecParameters *par = s_1->streams[stream_index]->codecpar;
	APEContext *ctx;
	int32_t predictionA, currentA, A, sign;
	APEPredictor *pb = &ctx->predictor;
	currentA = pb->lastA[0];
	pb->lastA[0] = currentA;
	AVIOContext *b     = s_1->b;
	const int stream_index =  pk->stream_index;
	avi_stream2fourcc(rb, stream_index, par->codec_type);
	avio_write(b, rb, 4);
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	char str[] = ""Constant"";
	files_struct *lsp;
	GF_Box *s;
	GF_BitStream *bs;
	u32 i, ch;
	GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
	u32 i, ch;
	for (i=0; i<ch; i++) {
			GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);
			gf_bs_write_u16(bs, isl->size);
			gf_bs_write_data(bs, isl->data, isl->size);
	}
	const struct dom_sid *group_sid = NULL;
	TALLOC_CTX *frame = talloc_stackframe();
	struct security_descriptor *psd = NULL;
	RAMBlock *news_work;
	size_5 = HOST_PAGE_ALIGN(size_5);
	news_work = g_malloc0(sizeof(*news_work));
	news_work->used_length = size_5;
	assert(maxlennumber >= size_5);
	const struct dom_sid *owner_sid = NULL;
	struct security_descriptor *parent_desc = NULL;
	struct security_token *token = lsp->conn->session_info->security_token;
	status = se_create_child_secdesc(frame,
				&psd,
				&size_5,
				parent_desc,
				owner_sid,
				group_sid,
				lsp->is_directory);
	status = SMB_VFS_FSET_NT_ACL(lsp,
				security_info_sent,
				psd);
	while (strlen(str) > 5) {
    	cris_cc_mask(dc, CC_MASK_NZ);
	strcpy(str, ""a"");
	}
	t0 = tcg_temp_new(TCG_TYPE_TL);
	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}",0,1,172,1.44,Insert
2244,"AVInputFormat *av_find_input_format(const char *short_name)
{
    AVInputFormat *fmt = NULL;
    while ((fmt = av_iformat_next(fmt)))
        if (match_format(short_name, fmt->name))
            return fmt;
    return NULL;
}","AVInputFormat *av_find_input_format(const char *short_name)
{
    int a = 2;
    int b = 3;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    while (a != b) {
        AVInputFormat *fmt = NULL;
        b = a;
    }
    while ((fmt = av_iformat_next(fmt)))
        if (match_format(short_name, fmt->name))
            return fmt;
    return NULL;
}",0,1,14,0.46,Insert
2245,,,,,,,
2246,"static int au_probe(AVProbeData *p)
{
    if (p->buf_size <= 24)
        return 0;
    if (p->buf[0] == '.' && p->buf[1] == 's' &&
        p->buf[2] == 'n' && p->buf[3] == 'd')
        return AVPROBE_SCORE_MAX;
    else
        return 0;
}","static int au_probe(AVProbeData *p)
{
    if (p->buf_size <= 24)
        return 0;
    if (p->buf[0] == '.' && p->buf[1] == 's' &&
        p->buf[2] == 'n' && p->buf[3] == 'd')
        char str[] = ""Constant"";
        VirtioCcwDevice *dev;
        Error *err = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err);
        }
        while (strlen(str) > 5) {
            return AVPROBE_SCORE_MAX;
        strcpy(str, ""a"");
        }
    else
        return 0;
}",0,1,13,0.38,Insert
2247,,,,,,,
2248,"void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,
                        int *duration)
{
    int64_t out_pts = AV_NOPTS_VALUE;
    int removed_samples = 0;
#ifdef DEBUG
    ff_af_queue_log_state(afq);
#endif
    if (afq->frame_queue) {
        if (afq->frame_queue->pts != AV_NOPTS_VALUE)
            out_pts = afq->frame_queue->pts - afq->remaining_delay;
    } else {
        if (afq->next_pts != AV_NOPTS_VALUE)
            out_pts = afq->next_pts - afq->remaining_delay;
    }
    if (pts) {
        if (out_pts != AV_NOPTS_VALUE)
            *pts = ff_samples_to_time_base(afq->avctx, out_pts);
        else
            *pts = AV_NOPTS_VALUE;
    }
    if (afq->remaining_delay >= nb_samples) {
        removed_samples      += nb_samples;
        afq->remaining_delay -= nb_samples;
    }
    while (removed_samples < nb_samples && afq->frame_queue) {
        removed_samples += afq->frame_queue->duration;
        delete_next_frame(afq);
    }
    afq->remaining_samples -= removed_samples;
    if (removed_samples < nb_samples && afq->remaining_samples > 0) {
        int add_samples = FFMIN(afq->remaining_samples,
                                nb_samples - removed_samples);
        removed_samples        += add_samples;
        afq->remaining_samples -= add_samples;
    }
    if (removed_samples > nb_samples)
        av_log(afq->avctx, AV_LOG_WARNING, ""frame_size is too large\n"");
    if (duration)
        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);
}","void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,
                        int *duration)
{
    int64_t out_pts = AV_NOPTS_VALUE;
    int removed_samples = 0;
#ifdef DEBUG
    int a = 2;
    int b = 3;
    while (a < b) {
        ff_af_queue_log_state(afq);
        b = a;
    }
#endif
    if (afq->frame_queue) {
        if (afq->frame_queue->pts != AV_NOPTS_VALUE)
            out_pts = afq->frame_queue->pts - afq->remaining_delay;
    } else {
        if (afq->next_pts != AV_NOPTS_VALUE)
            out_pts = afq->next_pts - afq->remaining_delay;
    }
    if (pts) {
        if (out_pts != AV_NOPTS_VALUE)
            *pts = ff_samples_to_time_base(afq->avctx, out_pts);
        else
            *pts = AV_NOPTS_VALUE;
    }
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    if (afq->remaining_delay >= nb_samples) {
        removed_samples      += nb_samples;
        afq->remaining_delay -= nb_samples;
    }
    while (removed_samples < nb_samples && afq->frame_queue) {
        removed_samples += afq->frame_queue->duration;
        delete_next_frame(afq);
    }
    afq->remaining_samples -= removed_samples;
    if (removed_samples < nb_samples && afq->remaining_samples > 0) {
        int add_samples = FFMIN(afq->remaining_samples,
                                nb_samples - removed_samples);
        removed_samples        += add_samples;
        afq->remaining_samples -= add_samples;
    }
    if (removed_samples > nb_samples)
        av_log(afq->avctx, AV_LOG_WARNING, ""frame_size is too large\n"");
    if (duration)
        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);
}",0,1,22,1.2,Insert
2249,,,,,,,
2250,,,,,,,
2252,"PPC_OP(srawi)
{
    T1 = T0;
    T0 = (Ts0 >> PARAM(1));
    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {
        xer_ca = 1;
    } else {
        xer_ca = 0;
    }
    RETURN();
}","PPC_OP(srawi)
{
    T1 = T0;
    int a = 2;
    int b = 2;
    while (a == b) {
        T0 = (Ts0 >> PARAM(1));
        b += 1;
    }
    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {
        xer_ca = 1;
        int w;
        int h;
        png_structp pgAMproc;
        png_infop info_fp;
        png_byte color_type;
        info_fp = png_create_info_struct(pgAMproc);
        png_set_IHDR(pgAMproc, info_fp, w, h,
                         8, color_type, PNG_INTERLACE_NONE,
                         PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
        png_write_info(pgAMproc, info_fp);
        png_destroy_write_struct(&pgAMproc, &info_fp);
    } else {
        xer_ca = 0;
    }
    RETURN();
}",1,0,17,0.36,Insert
2253,,,,,,,
2254,,,,,,,
2255,,,,,,,
2256,,,,,,,
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->run_vlc);
    av_freep(&ctx->mb_scan_index);
    av_freep(&ctx->rows);
    return 0;
}","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        DNXHDContext *ctx = avctx->priv_data;
    }
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->run_vlc);
    av_freep(&ctx->mb_scan_index);
    GstDateTime *dt, *dt2;
    gst_date_time_unref (dt);
    dt = gst_date_time_new_from_iso8601_string (""2010-00-30"");
    fail_unless (gst_date_time_get_year (dt) == 2010);
    fail_unless (!gst_date_time_has_month (dt));
    fail_unless (!gst_date_time_has_day (dt));
    av_freep(&ctx->rows);
    return 0;
}",1,0,21,0.42,Insert
2258,,,,,,,
2263,"static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)
{
    int16_t input[MDCT_SAMPLES];
    int32_t output[AC3_MAX_COEFS];
    float input1[MDCT_SAMPLES];
    float output1[AC3_MAX_COEFS];
    float s, a, err, e, emax;
    int i, k, n;
    for (i = 0; i < MDCT_SAMPLES; i++) {
        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;
        input1[i] = input[i];
    }
    mdct512(mdct, output, input);
    for (k = 0; k < AC3_MAX_COEFS; k++) {
        s = 0;
        for (n = 0; n < MDCT_SAMPLES; n++) {
            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));
            s += input1[n] * cos(a);
        }
        output1[k] = -2 * s / MDCT_SAMPLES;
    }
    err  = 0;
    emax = 0;
    for (i = 0; i < AC3_MAX_COEFS; i++) {
        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);
        e = output[i] - output1[i];
        if (e > emax)
            emax = e;
        err += e * e;
    }
    av_log(NULL, AV_LOG_DEBUG, ""err2=%f emax=%f\n"", err / AC3_MAX_COEFS, emax);
}","static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)
{
    int16_t input[MDCT_SAMPLES];
    int32_t output[AC3_MAX_COEFS];
    int a_1 = 2;
    int b_1 = 3;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (a_1 != b_1) {
        float input1[MDCT_SAMPLES];
    }
    float output1[AC3_MAX_COEFS];
    float s, a, err, e, emax;
    int i, k, n;
    for (i = 0; i < MDCT_SAMPLES; i++) {
        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;
        input1[i] = input[i];
    }
    mdct512(mdct, output, input);
    for (k = 0; k < AC3_MAX_COEFS; k++) {
        s = 0;
        for (n = 0; n < MDCT_SAMPLES; n++) {
            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));
            s += input1[n] * cos(a);
        }
        output1[k] = -2 * s / MDCT_SAMPLES;
    }
    err  = 0;
    emax = 0;
    for (i = 0; i < AC3_MAX_COEFS; i++) {
        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);
        e = output[i] - output1[i];
        if (e > emax)
            emax = e;
        err += e * e;
    }
    av_log(NULL, AV_LOG_DEBUG, ""err2=%f emax=%f\n"", err / AC3_MAX_COEFS, emax);
}",0,1,39,1.42,Insert
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)
{
    if (!sar.num)
        sar = (AVRational){1, 1};
    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});
    return sar;
}","static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)
{
    if (!sar.num)
        sar = (AVRational){1, 1};
    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});
    journal_t *fat = EXT4_SB(sb)->s_journal;
    struct ext4_inode *raw_incode;
    struct inode *inode;
    inode = iget_locked(sb, lon);
    inode->i_size = ext4_isize(sb, raw_incode);
    return sar;
}",1,0,10,0.29,Insert
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    return inl(0xcfc);
}","static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
        b = a;
    }
    AVFormatContext *s;
    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;
    HLSContext *c = s->priv_data;
    if (u) {
            update_options(&c->user_agent, ""user-agent"", u);
            update_options(&c->cookies, ""cookies"", u);
            update_options(&c->headers, ""headers"", u);
            update_options(&c->http_proxy, ""http_proxy"", u);
    }
    return inl(0xcfc);
}",1,0,7,0.32,Insert
2267,,,,,,,
2268,,,,,,,
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)
{
    if (migrate_use_xbzrle()) {
        info->has_xbzrle_cache = true;
        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));
        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();
        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();
        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();
        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();
        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();
    }
}","static void get_xbzrle_cache_stats(MigrationInfo *info)
{
    if (migrate_use_xbzrle()) {
        struct super_block *sb = NULL;
        umode_t mode = S_IRWXUGO | S_ISVTX;
        struct v9fs_session_info *gnineses = NULL;
        sb = sget(ns_type, NULL, v9fs_set_super, fee, gnineses);
        retval = v9fs_fill_super(sb, gnineses, fee, mode);
        info->has_xbzrle_cache = true;
        int a = 2;
        int b = 3;
        while (a < b) {
            info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));
            b = a;
        }
        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();
        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();
        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();
        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();
        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();
    }
}",1,0,27,0.53,Insert
2270,,,,,,,
2271,,,,,,,
2272,"void ff_af_queue_close(AudioFrameQueue *afq)
{
    while (afq->frame_queue)
        delete_next_frame(afq);
    memset(afq, 0, sizeof(*afq));
}","void ff_af_queue_close(AudioFrameQueue *afq)
{
    while (afq->frame_queue)
        delete_next_frame(afq);
    int a = 2;
    int b = 2;
    while (a == b) {
        memset(afq, 0, sizeof(*afq));
        b += 1;
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    }
}",0,1,10,0.29,Insert
2273,,,,,,,
2279,,,,,,,
2280,,,,,,,
2281,"void qemu_opts_print(QemuOpts *opts)
{
    QemuOpt *opt;
    QemuOptDesc *desc = opts->list->desc;
    if (desc[0].name == NULL) {
        QTAILQ_FOREACH(opt, &opts->head, next) {
            printf(""%s=\""%s\"" "", opt->name, opt->str);
        }
        return;
    }
    for (; desc && desc->name; desc++) {
        const char *value;
        QemuOpt *opt = qemu_opt_find(opts, desc->name);
        value = opt ? opt->str : desc->def_value_str;
        if (!value) {
            continue;
        }
        if (desc->type == QEMU_OPT_STRING) {
            printf(""%s='%s' "", desc->name, value);
        } else if ((desc->type == QEMU_OPT_SIZE ||
                    desc->type == QEMU_OPT_NUMBER) && opt) {
            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);
        } else {
            printf(""%s=%s "", desc->name, value);
        }
    }
}","void qemu_opts_print(QemuOpts *opts)
{
    QemuOpt *opt;
    QemuOptDesc *desc = opts->list->desc;
    if (desc[0].name == NULL) {
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        aml_append(coll,
                aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
        aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                        aml_name(""CTRL"")));
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
        QTAILQ_FOREACH(opt, &opts->head, next) {
            printf(""%s=\""%s\"" "", opt->name, opt->str);
        }
        int a = 2;
        int b = 2;
        if (a == b) {
            return;
        }
    }
    const uint8_t *data;
    int size;
    AVCodecParserContext *ctx;
    VP9ParseContext *s = ctx->priv_data;
    parse_frame(ctx, data, size);
    Unit *u;
    Unit *other;
    int range;
    Automount *worker = AUTOMOUNT(u);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    range = automount_start_expire(worker);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    for (; desc && desc->name; desc++) {
        const char *value;
        QemuOpt *opt = qemu_opt_find(opts, desc->name);
        value = opt ? opt->str : desc->def_value_str;
        if (!value) {
            continue;
        }
        if (desc->type == QEMU_OPT_STRING) {
            printf(""%s='%s' "", desc->name, value);
        } else if ((desc->type == QEMU_OPT_SIZE ||
                    desc->type == QEMU_OPT_NUMBER) && opt) {
            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);
        } else {
            printf(""%s=%s "", desc->name, value);
        }
    }
}",0,1,89,1.28,Insert
2286,"static SocketAddress *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddress *saddr;
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddress, 1);
    saddr->type = SOCKET_ADDRESS_KIND_INET;
    saddr->u.inet.data = iaddr;
    return saddr;
}","static SocketAddress *tcp_build_address(const char *host_port, Error **errp)
{
    int i, qa;
    struct PCIDevice *pci_dev;
    uint8_t e_intx;
    Error *local_ = NULL;
    struct ttm_buffer_object *bo;
    struct ttm_bo_device *tdev = bo->tdev;
    struct ttm_bo_device *tdev = bo->tdev;
    dma_resv_assert_held(bo->base.resv);
    bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    assigned_dev_register_regions(Dev->real_device.regions,
                                      Dev->real_device.region_number, Dev,
                                      &local_);
    e_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;
    Dev->intpin = e_intx;
    Dev->intx_route.mode = PCI_INTX_DISABLED;
    Dev->intx_route.irq = -1;
    qa = libusb_init(&ctx);
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddress *saddr;
    bool has_mode;
    struct hfi1_user_sdma_comp_q *cq;
    u16 idx;
    struct hfi1_user_sdma_pkt_q *pq;
    int ret;
    enum hfi1_sdma_comp_state state;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    cq->comps[idx].status = state;
    char *filename;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
    					idx, state, ret);
    const char *data;
    int data;
    if (!has_mode) {
            data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
    }
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddress, 1);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        saddr->type = SOCKET_ADDRESS_KIND_INET;
    strcpy(str, ""a"");
    }
    saddr->u.inet.data = iaddr;
    return saddr;
}",0,1,211,1.3,Insert
2287,"static void nbd_close(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    qemu_opts_del(s->socket_opts);
    nbd_client_session_close(&s->client);
}","static void nbd_close(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    BdrvDirtyBitmap *Bitmaps;
    BlockDriverState *bos;
    Bitmaps = bdrv_find_dirty_bitmap(bos, key);
    qemu_opts_del(s->socket_opts);
    SysBusDevice *b;
    if (i) {
            sysbus_mmio_map(b, 0, i);
    }
    nbd_client_session_close(&s->client);
}",0,1,64,0.47,Insert
2288,"static void reset(DeviceState *d)
{
    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);
    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
    trace_spapr_drc_reset(spapr_drc_index(drc));
    g_free(drc->ccs);
    drc->ccs = NULL;
    if (drc->awaiting_release) {
        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);
        if (drc->awaiting_release) {
            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);
        }
        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&
            drc->awaiting_release) {
            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);
        }
    }
}","static void reset(DeviceState *d)
{
    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);
    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
    trace_spapr_drc_reset(spapr_drc_index(drc));
    g_free(drc->ccs);
    drc->ccs = NULL;
    if (drc->awaiting_release) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);
        strcpy(str, ""a"");
        }
        if (drc->awaiting_release) {
            blink::WebURLRequest& quest;
            ResourceType resource_type = WebURLRequestToResourceType(quest);
            quest.SetDownloadToNetworkCacheOnly(
                  is_for_no_state_prefetch && resource_type != RESOURCE_TYPE_MAIN_FRAME);
            quest.SetRequestorID(render_view_->GetRoutingID());
            quest.SetHasUserGesture(
                  WebUserGestureIndicator::IsProcessingUserGesture(frame_));
            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);
        }
        struct QemuInputEventQueueHead *queue;
        QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
        V9fsPath *fs_path;
        FsContext *FS_path;
        int fd, ret;
        struct handle_data *parent = (struct handle_data *)FS_path->private;
        fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
        QTAILQ_INSERT_TAIL(queue, item, node);
        queue_count++;
        char *filename;
        long load_limit, fw_size;
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&
        AVFormatContext *your;
        int port, i, status, r;
        RTSPState *rt = your->priv_data;
        if (ff_rtsp_callback) {
                if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                     NULL, 0, rt->last_reply) < 0) {
                    r = AVERROR_INVALIDDATA;
                    goto fail;
                }
        }
            drc->awaiting_release) {
            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);
        }
    }
}",0,1,157,1.41,Insert
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    CPUState *env;
    int err;
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, addr);
        if (!bp)
            return -ENOENT;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    CPUState *env;
    int a = 2;
    int b = 3;
    if (a != b) {
        char *filename;
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        int err;
    }
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, addr);
        if (!bp)
            return -ENOENT;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}",0,1,37,1.18,Insert
2290,"void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)
{
    int relation;
    set_float_exception_flags(0, &env->fp_status);
    relation = float64_compare(t0, t1, &env->fp_status);
    if (unlikely(relation == float_relation_unordered)) {
        update_fpscr(env, GETPC());
    } else {
        env->sr_t = (relation == float_relation_greater);
    }
}","void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)
{
    int relation;
    set_float_exception_flags(0, &env->fp_status);
    relation = float64_compare(t0, t1, &env->fp_status);
    if (unlikely(relation == float_relation_unordered)) {
        int a = 2;
        int c, cnt;
        int val;
        struct timeval t1_7, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        int b = 2;
        while (a == b) {
            update_fpscr(env, GETPC());
            GError *ir = NULL;
            secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
            			server, secret, NULL, &ir,
            			""label"", label,
            			""server"", server,
            			""username"", username,
            			""docker_cli"", ""1"",
            			NULL);
            b += 1;
        }
        char *filename;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                                 &savevm_htab_handlers, spapr);
    } else {
        env->sr_t = (relation == float_relation_greater);
    }
}",0,1,77,0.96,Insert
2292,"int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,
                                 SocketAddressLegacy *addr,
                                 size_t *naddrs,
                                 SocketAddressLegacy ***addrs,
                                 Error **errp)
{
    switch (addr->type) {
    case SOCKET_ADDRESS_LEGACY_KIND_INET:
        return qio_dns_resolver_lookup_sync_inet(resolver,
                                                 addr,
                                                 naddrs,
                                                 addrs,
                                                 errp);
    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:
    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:
    case SOCKET_ADDRESS_LEGACY_KIND_FD:
        return qio_dns_resolver_lookup_sync_nop(resolver,
                                                addr,
                                                naddrs,
                                                addrs,
                                                errp);
    default:
        abort();
    }
}","int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,
                                 SocketAddressLegacy *addr,
                                 size_t *naddrs,
                                 SocketAddressLegacy ***addrs,
                                 Error **errp)
{
    BlockdevOnError on_source_bug;
    u64 id;
    struct blkif_response *resp;
    resp->id        = id;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    int con;
    abi_long data_6;
    if(do_strace)
            print_syscall_ret(con, data_6);
    const char *data;
    QuantizationTable
    bool human;
    TestOutputVisitorData *data_10;
    data_10->human = human;
    data_10->sov = string_output_visitor_new(human);
    g_assert(data_10->sov);
    data_10->ov = string_output_get_visitor(data_10->sov);
    g_assert(data_10->ov);
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
                     struct rose_neigh *client;
                     rose_neigh_list           = client;
    switch (addr->type) {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    case SOCKET_ADDRESS_LEGACY_KIND_INET:
        return qio_dns_resolver_lookup_sync_inet(resolver,
                                                 addr,
                                                 naddrs,
                                                 addrs,
                                                 errp);
    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:
    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:
    case SOCKET_ADDRESS_LEGACY_KIND_FD:
        return qio_dns_resolver_lookup_sync_nop(resolver,
                                                addr,
                                                naddrs,
                                                addrs,
                                                errp);
    default:
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            abort();
        strcpy(str, ""a"");
        }
    }
}",0,1,248,1.88,Insert
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)
{
    int hours, minutes, seconds;
    if (!show_bits(gb, 23)) {
        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");
        return -1;
    }
    hours   = get_bits(gb, 5);
    minutes = get_bits(gb, 6);
    skip_bits1(gb);
    seconds = get_bits(gb, 6);
    s->time_base = seconds + 60*(minutes + 60*hours);
    skip_bits1(gb);
    skip_bits1(gb);
    return 0;
}","static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)
{
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    int hours, minutes, seconds;
    if (!show_bits(gb, 23)) {
        int a = 2;
        int b = 3;
        while (a != b) {
            av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");
            b = a;
        }
        return -1;
    }
    hours   = get_bits(gb, 5);
    minutes = get_bits(gb, 6);
    skip_bits1(gb);
    seconds = get_bits(gb, 6);
    s->time_base = seconds + 60*(minutes + 60*hours);
    skip_bits1(gb);
    skip_bits1(gb);
    return 0;
}",0,1,33,0.85,Insert
2295,"static int ftp_restart(FTPContext *s, int64_t pos)
{
    char command[CONTROL_BUFFER_SIZE];
    const int rest_codes[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return AVERROR(EIO);
    return 0;
}","static int ftp_restart(FTPContext *s, int64_t pos)
{
    MpegEncContext *s_8;
    int mb_x, mb_y;
    mb_y = s_8->mb_y;
    int a = 2;
    BlockDriverState *bs;
    SheepdogInode *linade;
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i_3, size, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size   = put_bits_count(&pb) >> 3;
    BDRVSheepdogState *s_8 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_8->linade, linade, datalen);
    TCGReg rar;
    TCGType ir;
    struct f2fs_sb_info *sbi;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
    		dir = ALLOC_RIGHT;
    AArch64Insn insna;
    TCGContext *services;
    TCGReg ril;
    unsigned k, b_5, err, C;
    unsigned k, b_5, err, C;
    tcg_out_insn_3404(services, insna, ir, rar, ril, ir, err, C);
    int b = 3;
    SysBusDevice *b_6;
    if (i) {
            sysbus_mmio_map(b_6, 0, i);
    }
    while (a < b) {
        char command[CONTROL_BUFFER_SIZE];
        b = a;
    }
    const int rest_codes[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return AVERROR(EIO);
    return 0;
}",0,1,161,1.14,Insert
2296,"static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,
        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)
{
    BlockDriverState *bs = child->bs;
    void *bounce_buffer;
    BlockDriver *drv = bs->drv;
    struct iovec iov;
    QEMUIOVector bounce_qiov;
    int64_t cluster_offset;
    unsigned int cluster_bytes;
    size_t skip_bytes;
    int ret;
    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);
    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,
                                   cluster_offset, cluster_bytes);
    iov.iov_len = cluster_bytes;
    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);
    if (bounce_buffer == NULL) {
        ret = -ENOMEM;
        goto err;
    }
    qemu_iovec_init_external(&bounce_qiov, &iov, 1);
    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,
                             &bounce_qiov, 0);
    if (ret < 0) {
        goto err;
    }
    bdrv_debug_event(bs, BLKDBG_COR_WRITE);
    if (drv->bdrv_co_pwrite_zeroes &&
        buffer_is_zero(bounce_buffer, iov.iov_len)) {
        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);
    } else {
        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,
                                  &bounce_qiov, 0);
    }
    if (ret < 0) {
        goto err;
    }
    skip_bytes = offset - cluster_offset;
    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);
err:
    qemu_vfree(bounce_buffer);
    return ret;
}","static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,
        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)
{
    BlockDriverState *bs = child->bs;
    void *bounce_buffer;
    char *filename;
    long load_limit, rtas_limit, fw_size;
    UHCI_TD *dev;
    int i, ret_8;
    ret_8 = 0;
    uint8_t val;
    val = dev->token & 0xff;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    char *filename_4;
    filename_4 = qemu_find_file_3(QEMU_FILE_TYPE_BIOS_9, ""spapr-rtas.bin"");
    filename_4 = qemu_find_file_3(QEMU_FILE_TYPE_BIOS_9, bios_name_7);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr_8);
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    BlockDriver *drv = bs->drv;
    struct iovec iov;
    QEMUIOVector bounce_qiov;
    int64_t cluster_offset;
    unsigned int cluster_bytes;
    size_t skip_bytes;
    int ret;
    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);
    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,
                                   cluster_offset, cluster_bytes);
    iov.iov_len = cluster_bytes;
    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);
    if (bounce_buffer == NULL) {
        ret = -ENOMEM;
        goto err;
    }
    qemu_iovec_init_external(&bounce_qiov, &iov, 1);
    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,
                             &bounce_qiov, 0);
    if (ret < 0) {
        goto err;
    }
    bdrv_debug_event(bs, BLKDBG_COR_WRITE);
    if (drv->bdrv_co_pwrite_zeroes &&
        buffer_is_zero(bounce_buffer, iov.iov_len)) {
        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);
    } else {
        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,
                                  &bounce_qiov, 0);
    }
    if (ret < 0) {
        goto err;
    }
    skip_bytes = offset - cluster_offset;
    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);
err:
    qemu_vfree(bounce_buffer);
    return ret;
}",0,1,122,1.72,Insert
2297,"int kvm_ioctl(KVMState *s, int type, ...)
{
    int ret;
    void *arg;
    va_list ap;
    va_start(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    ret = ioctl(s->fd, type, arg);
    if (ret == -1)
        ret = -errno;
    return ret;
}","int kvm_ioctl(KVMState *s, int type, ...)
{
    Monitor *mor;
    monitor_read_command(mor, 1);
    int ret;
    void *arg;
    va_list ap;
    SysBusDevice *b;
    if (i) {
            sysbus_mmio_map(b, 0, i);
    }
    va_start(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ret = ioctl(s->fd, type, arg);
    strcpy(str, ""a"");
    }
    if (ret == -1)
        ret = -errno;
    return ret;
}",0,1,52,0.67,Insert
2299,"theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)
{
    struct ogg *ogg = ctx->priv_data;
    struct ogg_stream *os = ogg->streams + idx;
    struct theora_params *thp = os->private;
    uint64_t iframe = gp >> thp->gpshift;
    uint64_t pframe = gp & thp->gpmask;
    if (thp->version < 0x030201)
        iframe++;
    if(!pframe)
        os->pflags |= AV_PKT_FLAG_KEY;
    if (dts)
        *dts = iframe + pframe;
    return iframe + pframe;
}","theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)
{
    struct ogg *ogg = ctx->priv_data;
    struct ogg_stream *os = ogg->streams + idx;
    struct theora_params *thp = os->private;
    uint64_t iframe = gp / (2**thp)->gpshift;
    uint64_t pframe = gp & thp->gpmask;
    if (thp->version < 0x030201)
        iframe++;
    if(!pframe)
        os->pflags |= AV_PKT_FLAG_KEY;
    if (dts)
        *dts = iframe + pframe;
    return iframe + pframe;
}",0,1,4,0.09,Replace
2300,"static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int ret;
    AVStream *st;
    st = s->streams[0];
    av_read_frame_flush(s);
    url_fseek(&s->pb, s->data_offset, SEEK_SET);
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}","static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int a = 2;
    int b = 3;
    while (a != b) {
        int ret;
        b = a;
    }
    AVStream *st;
    st = s->streams[0];
    BlockDriverState *bs;
    bdrv_make_anon(bs);
    g_free(bs);
    av_read_frame_flush(s);
    url_fseek(&s->pb, s->data_offset, SEEK_SET);
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}",0,1,56,0.95,Insert
2302,"int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,
                  target_ulong *raddr, int *flags)
{
    int r = -1;
    uint8_t *sk;
    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
    vaddr &= TARGET_PAGE_MASK;
    if (!(env->psw.mask & PSW_MASK_DAT)) {
        *raddr = vaddr;
        r = 0;
        goto out;
    }
    switch (asc) {
    case PSW_ASC_PRIMARY:
    case PSW_ASC_HOME:
        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);
        break;
    case PSW_ASC_SECONDARY:
        if (rw == 2) {
            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,
                                  rw);
            *flags &= ~(PAGE_READ | PAGE_WRITE);
        } else {
            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,
                                  rw);
            *flags &= ~(PAGE_EXEC);
        }
        break;
    case PSW_ASC_ACCREG:
    default:
        hw_error(""guest switched to unknown asc mode\n"");
        break;
    }
 out:
    *raddr = mmu_real2abs(env, *raddr);
    if (*raddr <= ram_size) {
        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];
        if (*flags & PAGE_READ) {
            *sk |= SK_R;
        }
        if (*flags & PAGE_WRITE) {
            *sk |= SK_C;
        }
    }
    return r;
}","int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,
                  target_ulong *raddr, int *flags)
{
    int r = -1;
    uint8_t *sk;
    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
    vaddr &= TARGET_PAGE_MASK;
    if (!(env->psw.mask & PSW_MASK_DAT)) {
        *raddr = vaddr;
        r = 0;
        goto out;
    }
    switch (asc) {
    case PSW_ASC_PRIMARY:
    case PSW_ASC_HOME:
        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);
        break;
    case PSW_ASC_SECONDARY:
        if (rw == 2) {
            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,
                                  rw);
            *flags &= ~(PAGE_READ | PAGE_WRITE);
        } else {
            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,
                                  rw);
                                  AVFormatContext *your;
                                  int port, i, status, r_9;
                                  RTSPState *rt = your->priv_data;
                                  if (ff_rtsp_callback) {
                                          if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                                               NULL, 0, rt->last_reply) < 0) {
                                              r_9 = AVERROR_INVALIDDATA;
                                              goto fail;
                                          }
                                  }
            *flags &= ~(PAGE_EXEC);
        }
        break;
    case PSW_ASC_ACCREG:
    default:
        hw_error(""guest switched to unknown asc mode\n"");
        break;
    }
 out:
    *raddr = mmu_real2abs(env, *raddr);
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (*raddr <= ram_size) {
        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];
        if (*flags & PAGE_READ) {
            int a = 2;
            int b = 3;
            while (a != b) {
                *sk |= SK_R;
                b = a;
            }
        }
        if (*flags & PAGE_WRITE) {
            *sk |= SK_C;
        }
    }
    return r;
}",0,1,56,1.53,Insert
2303,,,,,,,
2304,,,,,,,
2307,"get_net_error_message(gint error)
{
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'\n' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        LocalFree(msg);
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}","get_net_error_message(gint error)
{
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setXSSAuditorEnabled(enableXSSAuditor);
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int a = 2;
    int b = 3;
    while (a < b) {
        int flags;
        b = a;
    }
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'\n' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        LocalFree(msg);
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}",1,0,34,1.04,Insert
2308,"static void kqemu_record_flush(void)
{
    PCRecord *r, *r_next;
    int h;
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {
            r_next = r->next;
            free(r);
        }
        pc_rec_hash[h] = NULL;
    }
    nb_pc_records = 0;
}","static void kqemu_record_flush(void)
{
    PCRecord *r, *r_next;
    char str[] = ""Constant"";
    int nb_oargs;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    while (strlen(str) > 5) {
        int h;
    strcpy(str, ""a"");
    }
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {
            r_next = r->next;
            free(r);
        }
        pc_rec_hash[h] = NULL;
    }
    nb_pc_records = 0;
}",0,1,69,0.8,Insert
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,
                                    int nb_sectors)
{
    int64_t cluster_num, nb_clusters;
    if (iscsilun->allocationmap == NULL) {
        return;
    }
    cluster_num = sector_num / iscsilun->cluster_sectors;
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
                               iscsilun->cluster_sectors) - cluster_num;
    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
}","static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,
                                    int nb_sectors)
{
    int a = 2;
    int b = 2;
    RAMBlock *news_work;
    news_work = g_malloc0(sizeof(*news_work));
    news_work->err = err;
    news_work->realized = realized;
    news_work->used_length = size;
    news_work->max_length = maxlennumber;
    if (a == b) {
        int64_t cluster_num, nb_clusters;
    }
    if (iscsilun->allocationmap == NULL) {
        return;
    }
    cluster_num = sector_num / iscsilun->cluster_sectors;
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
                               iscsilun->cluster_sectors) - cluster_num;
    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
}",0,1,34,0.43,Insert
2311,"static void test_qemu_strtosz_metric(void)
{
    const char *str = ""12345k"";
    char *endptr = NULL;
    int64_t res;
    res = qemu_strtosz_metric(str, &endptr);
    g_assert_cmpint(res, ==, 12345000);
    g_assert(endptr == str + 6);
}","static void test_qemu_strtosz_metric(void)
{
    const char *str = ""12345k"";
    char *endptr = NULL;
    int64_t res;
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        res = qemu_strtosz_metric(str, &endptr);
    }
    g_assert_cmpint(res, ==, 12345000);
    g_assert(endptr == str + 6);
}",0,1,5,0.08,Replace
2312,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    int a = 28;
    int b = a;
    if(a*b>0){
        RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
    }
}",0,1,2,0.05,Replace
2315,,,,,,,
2316,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = arm_mptimer_realize;
    dc->vmsd = &vmstate_arm_mptimer;
    dc->reset = arm_mptimer_reset;
    dc->no_user = 1;
    dc->props = arm_mptimer_properties;
}","static void arm_mptimer_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    int a = 2;
    int b = 2;
    while (a == b) {
        dc->realize = arm_mptimer_realize;
        b += 1;
        H264Context *h;
        AVCodecContext *const avctx = h->avctx;
        AVCodecContext *const avctx = h->avctx;
        if (CONFIG_H264_VDPAU_DECODER &&
                h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)
                ff_vdpau_h264_picture_complete(h);
    }
    dc->vmsd = &vmstate_arm_mptimer;
    dc->reset = arm_mptimer_reset;
    dc->no_user = 1;
    dc->props = arm_mptimer_properties;
}",1,0,34,0.54,Insert
2319,,,,,,,
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    bit = (S & s->and) | s->or;
    bit = ((S + bit) << s->shift) - bit;
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            int a = 2;
            int b = 3;
            GDateTime *gdt, *gdt2;
            GstDateTime *dt, *dt2;
            fail_unless (gst_date_time_get_day (dt) ==
                  g_date_time_get_day_of_month (gdt));
            fail_unless (gst_date_time_get_hour (dt) == 15);
            fail_unless (gst_date_time_get_minute (dt) == 50);
            fail_unless (!gst_date_time_has_second (dt));
            gst_date_time_unref (dt);
            while (a < b) {
                *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
                b = a;
            }
        }
    }
    bit = (S & s->and) | s->or;
    bit = ((S + bit) << s->shift) - bit;
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}",1,0,24,1.03,Insert
2322,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)
{
    int i;
    for (i = 0; i < 64; i++) {
        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];
        int v = get_bits(&s->gb, 8);
        if (v == 0) {
            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");
            return -1;
        }
        if (intra && i == 0 && v != 8) {
            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);
            v = 8;  
        }
        matrix0[j] = v;
        if (matrix1)
            matrix1[j] = v;
    }
    return 0;
}","static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)
{
    int i;
    for (i = 0; i < 64; i++) {
        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];
        int v = get_bits(&s->gb, 8);
        if (v == 0) {
            int a = 2;
            int b = 3;
            while (a != b) {
                av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");
                b = a;
            }
            return -1;
        }
        if (intra && i == 0 && v != 8) {
            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);
            v = 8;  
        }
        matrix0[j] = v;
        if (matrix1)
            matrix1[j] = v;
    }
    return 0;
}",0,1,5,0.12,Replace
2323,,,,,,,
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");
        return AVERROR(EINVAL);
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    return 0;
}","static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");
        int a = 2;
        int b = 3;
        if (a != b) {
            return AVERROR(EINVAL);
        }
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    return 0;
}",0,1,21,0.82,Insert
2325,"static void imx_epit_reset(DeviceState *dev)
{
    IMXEPITState *s = IMX_EPIT(dev);
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    s->lr = TIMER_MAX;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}","static void imx_epit_reset(DeviceState *dev)
{
    IMXEPITState *s = IMX_EPIT(dev);
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    int a = 2;
    SysBusDevice *b_2;
    if (i) {
            sysbus_mmio_map(b_2, 0, i);
    }
    int b = 2;
    AVPacket * pk;
    int w;
    V9fsPath *fs_path;
    FsContext *FS_path;
    int fd, ret;
    char **sdst;
    struct token t;
    *sdst = t.val;
    struct handle_data *parent = (struct handle_data *)FS_path->private;
    register const xmlChar *m;
    m = ctxt->input->cur;
    fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    AVFormatContext *s_3;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b_1     = s_3->b_1;
    avio_write(b_1,  pk->data, size);
    while (a == b) {
        s->lr = TIMER_MAX;
        b += 1;
    }
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}",0,1,178,1.54,Insert
2326,"static void quit_timers(void)
{
    alarm_timer->stop(alarm_timer);
    alarm_timer = NULL;
}","static void quit_timers(void)
{
    alarm_timer->stop(alarm_timer);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        alarm_timer = NULL;
    }
}",0,1,1,0.04,Replace
2328,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,
        int64_t sector_num, uint8_t *buf, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    RawAIOCB *acb;
    BDRVRawState *s = bs->opaque;
    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {
        QEMUBH *bh;
        acb = qemu_aio_get(bs, cb, opaque);
        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);
        bh = qemu_bh_new(raw_aio_em_cb, acb);
        qemu_bh_schedule(bh);
        return &acb->common;
    }
    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);
    if (!acb)
        return NULL;
    if (aio_read(&acb->aiocb) < 0) {
        qemu_aio_release(acb);
        return NULL;
    }
    return &acb->common;
}","static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,
        int64_t sector_num, uint8_t *buf, int nb_sectors,
        BlockDriverCompletionFunc *cb, void *opaque)
{
    RawAIOCB *acb;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        BDRVRawState *s = bs->opaque;
    }
    BlockDriverState *bs_3;
    SheepdogInode *linade;
    BDRVSheepdogState *s_1 = bs_3->opaque;
    unsigned int datalen;
    memcpy(&s_1->linade, linade, datalen);
    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {
        char **names;
        char *p;
        char *ea_namelist = smallbuf;
        size_t num_names;
        for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
        		names[num_names++] = p;
        }
        QEMUBH *bh;
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        int rules, nb_regs, ini;
        rules = args[nb_oargs + nb_iargs + 1];
        acb = qemu_aio_get(bs, cb, opaque);
        register ssize_t
            i;
        QuantizationTable
            *table;
        ssize_t
            j;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        for (j=i; j < 64; j++)
            table->levels[j]=table->levels[j-1];
        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);
        bh = qemu_bh_new(raw_aio_em_cb, acb);
        qemu_bh_schedule(bh);
        return &acb->common;
    }
    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);
    if (!acb)
        return NULL;
    if (aio_read(&acb->aiocb) < 0) {
        qemu_aio_release(acb);
        return NULL;
    }
    return &acb->common;
}",0,1,130,1.45,Insert
2329,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,
    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,
    BdrvRequestFlags flags)
{
    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {
        return -EINVAL;
    }
    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,
                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);
}","static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,
    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,
    BdrvRequestFlags flags)
{
    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {
        char str[] = ""Constant"";
        char *filename;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        while (strlen(str) > 5) {
            return -EINVAL;
        strcpy(str, ""a"");
        }
    }
    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,
                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);
}",0,1,37,0.57,Insert
2330,"static void sigchld_handler(int signal)
{
    qemu_bh_schedule(sigchld_bh);
}","static void sigchld_handler(int signal)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    qemu_bh_schedule(sigchld_bh);
}",0,1,7,0.15,Insert
2331,"static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)
{
    MpegTSFilter *tss;
    PESContext *pes;
    pes = av_mallocz(sizeof(PESContext));
    if (!pes)
        return 0;
    pes->ts = ts;
    pes->stream = ts->stream;
    pes->pid = pid;
    pes->pcr_pid = pcr_pid;
    pes->stream_type = stream_type;
    pes->state = MPEGTS_SKIP;
    pes->pts = AV_NOPTS_VALUE;
    pes->dts = AV_NOPTS_VALUE;
    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);
    if (!tss) {
        av_free(pes);
        return 0;
    }
    return pes;
}","static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)
{
    MpegTSFilter *tss;
    PESContext *pes;
    pes = av_mallocz(sizeof(PESContext));
    if (!pes)
        return 0;
    pes->ts = ts;
    pes->stream = ts->stream;
    pes->pid = pid;
    pes->pcr_pid = pcr_pid;
    pes->stream_type = stream_type;
    pes->state = MPEGTS_SKIP;
    pes->pts = AV_NOPTS_VALUE;
    pes->dts = AV_NOPTS_VALUE;
    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);
    if (!tss) {
        int a = 2;
        int b = 2;
        while (a == b) {
            av_free(pes);
            b += 1;
        }
        return 0;
    }
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    return pes;
}",0,1,31,0.7,Insert
2333,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)
{
    if (kvm_enabled()) {
        kvm_s390_virtio_irq(cpu, config_change, token);
    } else {
        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);
    }
}","static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)
{
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        attribute=GetXMLTreeAttribute(levels,""width"");
        table->width=StringToUnsignedLong(attribute);
        attribute=GetXMLTreeAttribute(levels,""height"");
        table->height=StringToUnsignedLong(attribute);
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    if (kvm_enabled()) {
        kvm_s390_virtio_irq(cpu, config_change, token);
    } else {
        int a = 56;
        int b = a;
        if(a*b>0){
            cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);
        }
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
    }
}",0,1,78,0.68,Insert
2335,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,
                const AVIOInterruptCB *int_cb)
{
    URLProtocol *up = NULL;
    char proto_str[128], proto_nested[128], *ptr;
    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);
    if (filename[proto_len] != ':' || is_dos_path(filename))
        strcpy(proto_str, ""file"");
    else
        av_strlcpy(proto_str, filename,
                   FFMIN(proto_len + 1, sizeof(proto_str)));
    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));
    if ((ptr = strchr(proto_nested, '+')))
        *ptr = '\0';
    while (up = ffurl_protocol_next(up)) {
        if (!strcmp(proto_str, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&
            !strcmp(proto_nested, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
    }
    *puc = NULL;
    return AVERROR_PROTOCOL_NOT_FOUND;
}","int ffurl_alloc(URLContext **puc, const char *filename, int flags,
                const AVIOInterruptCB *int_cb)
{
    URLProtocol *up = NULL;
    char proto_str[128], proto_nested[128], *ptr;
    int a = 2;
    int b = 2;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    item->type = QEMU_INPUT_QUEUE_SYNC;
    const struct dom_sid *alias;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    Image *image;
    const LayerInfo* layer_info;
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    unsigned int num_members;
    NTSTATUS obj;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct dom_sid_buf buf;
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    anon = ldb_dn_new_fmt(
    		mem_context,
    		area->ldb,
    		""<SID=%s>"",
    		dom_sid_str_buf(alias, &buf));
    obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (a == b) {
        size_t proto_len = strspn(filename, URL_SCHEME_CHARS);
    }
    if (filename[proto_len] != ':' || is_dos_path(filename))
        strcpy(proto_str, ""file"");
    else
        av_strlcpy(proto_str, filename,
                   FFMIN(proto_len + 1, sizeof(proto_str)));
    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));
    if ((ptr = strchr(proto_nested, '+')))
        *ptr = '\0';
    while (up = ffurl_protocol_next(up)) {
        if (!strcmp(proto_str, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&
            !strcmp(proto_nested, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
    }
    *puc = NULL;
    return AVERROR_PROTOCOL_NOT_FOUND;
}",0,1,120,1.48,Insert
2336,"BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        return QTAILQ_FIRST(&bdrv_states);
    }
    return QTAILQ_NEXT(bs, device_list);
}","BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        return QTAILQ_FIRST(&bdrv_states);
    }
    int a = 77;
    int b = a;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    if(a*b>0){
        return QTAILQ_NEXT(bs, device_list);
    }
}",0,1,29,0.44,Insert
2337,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,
                    uint64_t val, unsigned size)
{
    mcf_uart_state *s = (mcf_uart_state *)opaque;
    switch (addr & 0x3f) {
    case 0x00:
        s->mr[s->current_mr] = val;
        s->current_mr = 1;
        break;
    case 0x04:
        break;
    case 0x08:  
        mcf_do_command(s, val);
        break;
    case 0x0c:  
        s->sr &= ~MCF_UART_TxEMP;
        s->tb = val;
        mcf_uart_do_tx(s);
        break;
    case 0x10:
        break;
    case 0x14:
        s->imr = val;
        break;
    default:
        break;
    }
    mcf_uart_update(s);
}","void mcf_uart_write(void *opaque, target_phys_addr_t addr,
                    uint64_t val, unsigned size)
{
    SDRequest *err;
    SDState *esi;
    uint32_t last_status = esi->card_status;
    sd_rsp_type_t srowner;
    uint32_t last_status = esi->card_status;
    GF_BitStream *bs;
    GF_Box *s_7;
    FilePartitionBox *inter = (FilePartitionBox *)s_7;
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    gf_bs_read_u8(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    if (last_status & APP_CMD) {
            srowner = sd_app_command(esi, *err);
            esi->card_status &= ~APP_CMD;
        } else
            srowner = sd_normal_command(esi, *err);
    char str1[] = ""Constant"";
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    ram_addr_t gram_size, prom_reset, tcx64off;
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
                  serial_hds[0], ESCC_CLOCK, 1);
    char str2[] = ""Constant"";
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if (strcmp(str1, str2) == 0) {
        mcf_uart_state *s = (mcf_uart_state *)opaque;
    }
    switch (addr & 0x3f) {
    case 0x00:
        s->mr[s->current_mr] = val;
        s->current_mr = 1;
        break;
    case 0x04:
        break;
    case 0x08:  
        mcf_do_command(s, val);
        break;
    case 0x0c:  
        s->sr &= ~MCF_UART_TxEMP;
        s->tb = val;
        mcf_uart_do_tx(s);
        break;
    case 0x10:
        break;
    case 0x14:
        s->imr = val;
        break;
    default:
        break;
    }
    mcf_uart_update(s);
}",0,1,133,1.06,Insert
2338,"MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)
{
    ARMCPU *cpu;
    uint32_t switched_level;
    if (kvm_irqchip_in_kernel()) {
        return MEMTXATTRS_UNSPECIFIED;
    }
    cpu = ARM_CPU(cs);
    if (run->s.regs.device_irq_level != cpu->device_irq_level) {
        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;
        qemu_mutex_lock_iothread();
        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {
            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],
                         !!(run->s.regs.device_irq_level &
                            KVM_ARM_DEV_EL1_VTIMER));
            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;
        }
        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {
            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],
                         !!(run->s.regs.device_irq_level &
                            KVM_ARM_DEV_EL1_PTIMER));
            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;
        }
        if (switched_level) {
            qemu_log_mask(LOG_UNIMP, ""%s: unhandled in-kernel device IRQ %x\n"",
                          __func__, switched_level);
        }
        cpu->device_irq_level = run->s.regs.device_irq_level;
        qemu_mutex_unlock_iothread();
    }
    return MEMTXATTRS_UNSPECIFIED;
}","MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)
{
    ARMCPU *cpu;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint32_t switched_level;
    }
    if (kvm_irqchip_in_kernel()) {
        return MEMTXATTRS_UNSPECIFIED;
    }
    cpu = ARM_CPU(cs);
    if (run->s.regs.device_irq_level != cpu->device_irq_level) {
        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;
        qemu_mutex_lock_iothread();
        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {
            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],
                         !!(run->s.regs.device_irq_level &
                            KVM_ARM_DEV_EL1_VTIMER));
            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;
        }
        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {
            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],
                         !!(run->s.regs.device_irq_level &
                            KVM_ARM_DEV_EL1_PTIMER));
            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;
        }
        if (switched_level) {
            qemu_log_mask(LOG_UNIMP, ""%s: unhandled in-kernel device IRQ %x\n"",
                          __func__, switched_level);
        }
        cpu->device_irq_level = run->s.regs.device_irq_level;
        qemu_mutex_unlock_iothread();
    }
    return MEMTXATTRS_UNSPECIFIED;
}",0,1,14,0.24,Replace
2340,"static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,
                                  unsigned size)
{
    if (size != 2) {
        return omap_badwidth_read16(opaque, addr);
    }
    if (addr == OMAP_MPUI_BASE)	 
        return 0xfe4d;
    OMAP_BAD_REG(addr);
    return 0;
}","static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,
                                  unsigned size)
{
    QuantizationTable
    char *filename;
    int nb_oargs;
    int nb_iargs;
    JLSState *state;
    if (!state)
            goto memfail;
    const TCGArg * const args;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    g_free(filename);
        *table;
    XMLTreeInfo
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (size != 2) {
        int a = 2;
        int b = 3;
        if (a != b) {
            return omap_badwidth_read16(opaque, addr);
        }
    }
    if (addr == OMAP_MPUI_BASE)	 
        return 0xfe4d;
    OMAP_BAD_REG(addr);
    return 0;
}",0,1,185,1.28,Insert
2341,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    PCIAC97LinkState *d = opaque;
    AC97LinkState *s = &d->ac97;
    dolog (""U nam writeb %#x <- %#x\n"", addr, val);
    s->cas = 0;
}","static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    AVPacket * pk;
    AVFormatContext *s_5;
    int size               =  pk->size;
    int i, qa;
    qa = libusb_init(&ctx);
    AVIOContext *b     = s_5->b;
    if (size & 1)
            avio_w8(b, 0);
    PCIAC97LinkState *d = opaque;
    AC97LinkState *s = &d->ac97;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        dolog (""U nam writeb %#x <- %#x\n"", addr, val);
    strcpy(str, ""a"");
    BlockdevOnError on_source_bug;
    int rows;
    int rd;
    const char *opn = ""loongson"";
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    }
    s->cas = 0;
}",0,1,100,0.83,Insert
2342,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    S390FLICState *fs = S390_FLIC_COMMON(dev);
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    fs->ais_supported = true;
}","static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    char str[] = ""Constant"";
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (!saved_server_config_defines) {
            const char *filename_1;
            int64_t parent;
            int ecd;
            ecd = open(filename_1, O_RDONLY | O_BINARY);
            parent = lseek(ecd, 0, SEEK_END);
            close(ecd);
            init_config_defines(cli->pool);
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (strlen(str) > 0) {
        S390FLICState *fs = S390_FLIC_COMMON(dev);
    }
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    fs->ais_supported = true;
}",0,1,82,0.74,Insert
2343,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)
{
    InputStream  *ist = s->opaque;
    DXVA2Context *ctx = ist->hwaccel_ctx;
    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);
}","static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)
{
    AvahiLookupFlags *flags_3;
    const char *domain;
    AvahiServer *s_10;
    if (!s_10->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s_10->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags_3 |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags_3 |= AVAHI_LOOKUP_USE_WIDE_AREA;
    InputStream  *ist = s->opaque;
    const uint16_t min_mesh[17];
    int16_t nrsc[16];
    int err;
    int path, i;
    for (i = 1; i < err; i++)
            if (nrsc[i] < nrsc[i - 1] + min_mesh[i])
                nrsc[i] = nrsc[i - 1] + min_mesh[i];
    int a = 2;
    int nb_oargs;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    int b = 2;
    if (a == b) {
        DXVA2Context *ctx = ist->hwaccel_ctx;
    }
    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);
}",0,1,97,0.79,Insert
2345,,,,,,,
2348,,,,,,,
2351,,,,,,,
2352,"static int do_bit_allocation(AC3DecodeContext *ctx, int flags)
{
    ac3_audio_block *ab = &ctx->audio_block;
    int i, snroffst = 0;
    if (!flags)  
        return 0;
    if (ab->flags & AC3_AB_SNROFFSTE) {  
        snroffst += ab->csnroffst;
        if (ab->flags & AC3_AB_CPLINU)
            snroffst += ab->cplfsnroffst;
        for (i = 0; i < ctx->bsi.nfchans; i++)
            snroffst += ab->fsnroffst[i];
        if (ctx->bsi.flags & AC3_BSI_LFEON)
            snroffst += ab->lfefsnroffst;
        if (!snroffst) {
            memset(ab->cplbap, 0, sizeof (ab->cplbap));
            for (i = 0; i < ctx->bsi.nfchans; i++)
                memset(ab->bap[i], 0, sizeof (ab->bap[i]));
            memset(ab->lfebap, 0, sizeof (ab->lfebap));
            return 0;
        }
    }
    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))
        if (_do_bit_allocation(ctx, 5))
            return -1;
    for (i = 0; i < ctx->bsi.nfchans; i++)
        if (flags & (1 << i))
            if (_do_bit_allocation(ctx, i))
                return -1;
    if ((ctx->bsi.flags & AC3_BSI_LFEON) && (flags & 32))
        if (_do_bit_allocation(ctx, 6))
            return -1;
    return 0;
}","static int do_bit_allocation(AC3DecodeContext *ctx, int flags)
{
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    int a = 2;
    if (clean == nullptr)
        strecleanonnection->FindStream(uri);
    int b = 3;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if (a != b) {
        ac3_audio_block *ab = &ctx->audio_block;
    }
    int i, snroffst = 0;
    if (!flags)  
        return 0;
    if (ab->flags & AC3_AB_SNROFFSTE) {  
        snroffst += ab->csnroffst;
        if (ab->flags & AC3_AB_CPLINU)
            snroffst += ab->cplfsnroffst;
        for (i = 0; i < ctx->bsi.nfchans; i++)
            snroffst += ab->fsnroffst[i];
        if (ctx->bsi.flags & AC3_BSI_LFEON)
            snroffst += ab->lfefsnroffst;
        if (!snroffst) {
            memset(ab->cplbap, 0, sizeof (ab->cplbap));
            for (i = 0; i < ctx->bsi.nfchans; i++)
                memset(ab->bap[i], 0, sizeof (ab->bap[i]));
            memset(ab->lfebap, 0, sizeof (ab->lfebap));
            return 0;
        }
    }
    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))
        if (_do_bit_allocation(ctx, 5))
            return -1;
    for (i = 0; i < ctx->bsi.nfchans; i++)
        if (flags & (1 << i))
            if (_do_bit_allocation(ctx, i))
                return -1;
    if ((ctx->bsi.flags & AC3_BSI_LFEON) && (flags & 32))
        if (_do_bit_allocation(ctx, 6))
            return -1;
    return 0;
}",0,1,81,1.51,Insert
2356,"build_hpet(GArray *table_data, GArray *linker)
{
    Acpi20Hpet *hpet;
    hpet = acpi_data_push(table_data, sizeof(*hpet));
    hpet->timer_block_id = cpu_to_le32(0x8086a201);
    hpet->addr.address = cpu_to_le64(HPET_BASE);
    build_header(linker, table_data,
                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);
}","build_hpet(GArray *table_data, GArray *linker)
{
    Acpi20Hpet *hpet;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    scoped_refptr<IndexedDBCallbacks> Callcallback;
    IndexedDBTransaction* intermission;
    int64_t object_store_id;
    intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                               this, object_store_id, Callcallback));
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    int a = 2;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    int b = 3;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    while (a != b) {
        hpet = acpi_data_push(table_data, sizeof(*hpet));
        b = a;
    }
    hpet->timer_block_id = cpu_to_le32(0x8086a201);
    hpet->addr.address = cpu_to_le64(HPET_BASE);
    build_header(linker, table_data,
                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);
}",0,1,108,0.88,Insert
2357,"static inline void downmix_3f_1r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;
    }
}","static inline void downmix_3f_1r_to_mono(float *samples)
{
    int flags;
    RTPContext *http;
    char val[1024];
    const struct hldefinition *hldefinition;
    unsigned int i_1;
    if (hldefinition->console_serial_base) {
            serial_mm_init(hldefinition->console_serial_base, 0, NULL, 115200,
                           serial_hds[i_1], 1);
            i_1++;
    }
    if (url_open(&http->rtp_hd, val, flags) < 0)
            goto fail;
            char *filename;
            long load_limit, fw_size;
            struct ldb_dn *dn;
            if (dn->valid_case) {
            		unsigned int i_10;
            		for (i_10 = 0; i_10 < dn->comp_num; i_10++) {
            			LDB_FREE(dn->components[i_10].cf_name);
            			LDB_FREE(dn->components[i_10].cf_value.data);
            		}
            		dn->valid_case = false;
            }
            if (fw_size <= 0) {
                    error_report(""Could not load LPAR firmware '%s'"", filename);
                    exit(1);
            }
    int i;
    for (i = 0; i < 256; i++) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);
        strcpy(str, ""a"");
        register const xmlChar *cmp = other;
        register const xmlChar *m;
        while (*m != 0 && *m == *cmp) {
        	++m;
        	++cmp;
        	ctxt->input->col++;
        }
        }
        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;
        u32 trackNumber;
        GF_ISOFile  *photo;
        GF_Err                      e;
        GF_TrackBox                 *trak;
        e = CanAccessMovie(photo, GF_ISOM_OPEN_WRITE);
        trak = gf_isom_get_track_from_file(photo, trackNumber);
    }
}",0,1,158,1.14,Insert
2359,"static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,
                                         VirtIOPCIRegion *region,
                                         struct virtio_pci_cap *cap)
{
    memory_region_add_subregion(&proxy->modern_bar,
                                region->offset,
                                &region->mr);
    cap->cfg_type = region->type;
    cap->offset = cpu_to_le32(region->offset);
    cap->length = cpu_to_le32(memory_region_size(&region->mr));
    virtio_pci_add_mem_cap(proxy, cap);
}","static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,
                                         VirtIOPCIRegion *region,
                                         struct virtio_pci_cap *cap)
{
    memory_region_add_subregion(&proxy->modern_bar,
                                region->offset,
                                &region->mr);
    cap->cfg_type = region->type;
    S390CPU *console;
    Error *order = NULL;
    object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
    DisasContext *services;
    gen_compute_eflags(services);
    int a = 11;
    GF_BitStream *bs;
    GF_Box *s;
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    av_freep(&zero);
    av_freep(&zero);
    GF_ItemInfoEntryBox *cap_10 = (GF_ItemInfoEntryBox *)s;
    GF_ItemInfoEntryBox *cap_10 = (GF_ItemInfoEntryBox *)s;
    GF_Err e;
    e = gf_isom_full_box_write(s, bs);
    gf_bs_write_u16(bs, cap_10->item_protection_index);
    int b = a;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
    if(a*b>0){
        cap->offset = cpu_to_le32(region->offset);
    }
    cap->length = cpu_to_le32(memory_region_size(&region->mr));
    virtio_pci_add_mem_cap(proxy, cap);
}",0,1,147,1.14,Insert
2361,,,,,,,
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)
{
    uintptr_t ra = GETPC();
    switch (addr & 3) {
    case 3:
        cpu_stb_data_ra(env, addr, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, addr, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, addr, val >> 16, ra);
            cpu_stw_data_ra(env, addr + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, addr, val, ra);
        break;
    }
}","void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)
{
    char *filename;
    if (!filename) {
            error_report(""Could not find LPAR rtas '%s'"", ""spapr-rtas.bin"");
            BlockDriverState *bos;
            bos = bdrv_lookup_bs(object, object, NULL);
            exit(1);
    }
    int a = 67;
    GError *ir = NULL;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
    int b = a;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if(a*b>0){
        uintptr_t ra = GETPC();
    }
    switch (addr & 3) {
    case 3:
        cpu_stb_data_ra(env, addr, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, addr, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, addr, val >> 16, ra);
            cpu_stw_data_ra(env, addr + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, addr, val, ra);
        break;
    }
}",0,1,114,1.43,Insert
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
{
    int64_t scaled_dim;
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    return AVERROR(EINVAL);
}","int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
{
    GF_BitStream *bs;
    u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
    VVC_SPS *sps;
    if (sps->alf_enabled_flag && sps->chroma_format_idc) {
    		gf_bs_read_int_log(bs, 1, ""sps_ccalf_enabled_flag"");
    }
    int64_t scaled_dim;
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    int a = 2;
    int b = 2;
    if (a == b) {
        return AVERROR(EINVAL);
    }
}",1,0,6,0.66,Insert
2364,,,,,,,
2365,,,,,,,
2368,,,,,,,
2369,"static void conditional_branch(DBDMA_channel *ch)
{
    dbdma_cmd *current = &ch->current;
    uint16_t br;
    uint16_t sel_mask, sel_value;
    uint32_t status;
    int cond;
    DBDMA_DPRINTF(""conditional_branch\n"");
    br = le16_to_cpu(current->command) & BR_MASK;
    switch(br) {
    case BR_NEVER:   
        next(ch);
        return;
    case BR_ALWAYS:  
        branch(ch);
        return;
    }
    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
    cond = (status & sel_mask) == (sel_value & sel_mask);
    switch(br) {
    case BR_IFSET:   
        if (cond)
            branch(ch);
        else
            next(ch);
        return;
    case BR_IFCLR:   
        if (!cond)
            branch(ch);
        else
            next(ch);
        return;
    }
}","static void conditional_branch(DBDMA_channel *ch)
{
    size_t ie_len;
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    dbdma_cmd *current = &ch->current;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    uint16_t br;
    uint16_t sel_mask, sel_value;
    uint32_t status;
    int cond;
    DBDMA_DPRINTF(""conditional_branch\n"");
    br = le16_to_cpu(current->command) & BR_MASK;
    switch(br) {
    case BR_NEVER:   
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            next(ch);
        strcpy(str, ""a"");
        }
        return;
    case BR_ALWAYS:
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        mysql_close(mysql___global);  
        branch(ch);
        return;
    }
    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
    cond = (status & sel_mask) == (sel_value & sel_mask);
    switch(br) {
    case BR_IFSET:   
        if (cond)
            branch(ch);
        else
            next(ch);
        return;
    case BR_IFCLR:   
        if (!cond)
            branch(ch);
        else
            next(ch);
        return;
    }
}",0,1,102,1.52,Insert
2370,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,
                               Jpeg2000Component *comp,
                               Jpeg2000T1Context *t1, Jpeg2000Band *band)
{
    int i, j;
    int w = cblk->coord[0][1] - cblk->coord[0][0];
    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {
        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];
        int *src = t1->data[j];
        if (band->i_stepsize == 16384) {
            for (i = 0; i < w; ++i)
                datap[i] = src[i] / 2;
        } else {
            for (i = 0; i < w; ++i)
                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;
        }
    }
}","static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,
                               Jpeg2000Component *comp,
                               Jpeg2000T1Context *t1, Jpeg2000Band *band)
{
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    int a = 94;
    int b = a;
    if(a*b>0){
        int i, j;
    }
    int w = cblk->coord[0][1] - cblk->coord[0][0];
    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {
        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];
        int *src = t1->data[j];
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        if (band->i_stepsize == 16384) {
            for (i = 0; i < w; ++i)
                datap[i] = src[i] / 2;
        } else {
            for (i = 0; i < w; ++i)
                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;
        }
    }
}",0,1,42,1.3,Insert
2371,"static void gdb_accept(void)
{
    GDBState *s;
    struct sockaddr_in sockaddr;
    socklen_t len;
    int fd;
    for(;;) {
        len = sizeof(sockaddr);
        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);
        if (fd < 0 && errno != EINTR) {
            perror(""accept"");
            return;
        } else if (fd >= 0) {
#ifndef _WIN32
            fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
            break;
        }
    }
    socket_set_nodelay(fd);
    s = g_malloc0(sizeof(GDBState));
    s->c_cpu = first_cpu;
    s->g_cpu = first_cpu;
    s->fd = fd;
    gdb_has_xml = false;
    gdbserver_state = s;
    fcntl(fd, F_SETFL, O_NONBLOCK);
}","static void gdb_accept(void)
{
    GDBState *s;
    struct sockaddr_in sockaddr;
    socklen_t len;
    int fd;
    for(;;) {
        int a = 2;
        int b = 3;
        while (a != b) {
            len = sizeof(sockaddr);
            b = a;
        }
        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);
        if (fd < 0 && errno != EINTR) {
            perror(""accept"");
            return;
        } else if (fd >= 0) {
#ifndef _WIN32
            fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
            break;
        }
    }
    AVPacket * pk;
    AVFormatContext *s_4;
    int size               =  pk->size;
    AVIOContext *b_5     = s_4->b_5;
    if (size & 1)
            avio_w8(b_5, 0);
    socket_set_nodelay(fd);
    s = g_malloc0(sizeof(GDBState));
    s->c_cpu = first_cpu;
    s->g_cpu = first_cpu;
    s->fd = fd;
    gdb_has_xml = false;
    gdbserver_state = s;
    fcntl(fd, F_SETFL, O_NONBLOCK);
}",0,1,47,0.97,Insert
2374,"static av_cold int g726_init(AVCodecContext * avctx)
{
    AVG726Context* c = (AVG726Context*)avctx->priv_data;
    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;
    if (
        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&
         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {
        av_log(avctx, AV_LOG_ERROR, ""G726: unsupported audio format\n"");
        return -1;
    }
    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {
        av_log(avctx, AV_LOG_ERROR, ""G726: unsupported audio format\n"");
        return -1;
    }
    if(avctx->channels != 1){
        av_log(avctx, AV_LOG_ERROR, ""Only mono is supported\n"");
        return -1;
    }
    if(index>3){
        av_log(avctx, AV_LOG_ERROR, ""Unsupported number of bits %d\n"", index+2);
        return -1;
    }
    g726_reset(&c->c, index);
    c->code_size = c->c.tbls->bits;
    c->bit_buffer = 0;
    c->bits_left = 0;
    avctx->coded_frame = avcodec_alloc_frame();
    if (!avctx->coded_frame)
        return AVERROR(ENOMEM);
    avctx->coded_frame->key_frame = 1;
    return 0;
}","static av_cold int g726_init(AVCodecContext * avctx)
{
    AVG726Context* c = (AVG726Context*)avctx->priv_data;
    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;
    if (
        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderCreate *create;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        void *pack;
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {
        VdpDecoderProfile profile_7;
        AVCodecContext *AVcas_9;
        uint32_t input_8;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create_5;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status_1;
        VDPAUHWContext *hwctx_1 = AVcas_9->hwaccel_context;
        VDPAUContext *hdtx_1 = AVcas_9->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack_6;
        VdpBool supported;
        status_1 = decoder_query_caps(hdtx_1->device, profile_7, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status_1 = hdtx_1->get_proc_address(hdtx_1->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack_6);
        status_1 = hdtx_1->get_proc_address(hdtx_1->device, VDP_FUNC_ID_DECODER_RENDER_4,
                                             &pack_6);
        status_1 = create_5(hdtx_1->device, profile_7, width_6, input_8, AVcas_9->refs,
                            &hdtx_1->decoder);
        av_log(avctx, AV_LOG_ERROR, ""G726: unsupported audio format\n"");
        return -1;
    }
    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {
        av_log(avctx, AV_LOG_ERROR, ""G726: unsupported audio format\n"");
        return -1;
    }
    if(avctx->channels != 1){
        av_log(avctx, AV_LOG_ERROR, ""Only mono is supported\n"");
        return -1;
    }
    if(index>3){
        av_log(avctx, AV_LOG_ERROR, ""Unsupported number of bits %d\n"", index+2);
        return -1;
    }
    g726_reset(&c->c, index);
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    c->code_size = c->c.tbls->bits;
    int a = 87;
    QEMUBH *phi;
    phi->cb = cb;
    int b = a;
    QuantizationTable
    XMLTreeInfo
        *description_8,
        *levels_3,
        *quantization_tables_1,
        *table_iterator_4;
    XMLTreeInfo
        *description_8,
        *levels_3,
        *quantization_tables_1,
        *table_iterator_4;
    const char
        *attribute_10,
        *content_3;
    XMLTreeInfo
        *description_8,
        *levels_3,
        *quantization_tables_1,
        *table_iterator_4;
    description_8=GetXMLTreeChild(table_iterator_4,""description"");
    levels_3=GetXMLTreeChild(table_iterator_4,""levels"");
    attribute_10=GetXMLTreeAttribute_6(table_iterator_4,""slot"");
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    if(a*b>0){
        c->bit_buffer = 0;
    }
    c->bits_left = 0;
    avctx->coded_frame = avcodec_alloc_frame();
    if (!avctx->coded_frame)
        return AVERROR(ENOMEM);
    avctx->coded_frame->key_frame = 1;
    return 0;
}",0,1,261,1.95,Insert
2375,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,
				 unsigned long offset)
{
    const unsigned long *p = addr + BITOP_WORD(offset);
    unsigned long result = offset & ~(BITS_PER_LONG-1);
    unsigned long tmp;
    if (offset >= size) {
        return size;
    }
    size -= result;
    offset %= BITS_PER_LONG;
    if (offset) {
        tmp = *(p++);
        tmp |= ~0UL >> (BITS_PER_LONG - offset);
        if (size < BITS_PER_LONG) {
            goto found_first;
        }
        if (~tmp) {
            goto found_middle;
        }
        size -= BITS_PER_LONG;
        result += BITS_PER_LONG;
    }
    while (size & ~(BITS_PER_LONG-1)) {
        if (~(tmp = *(p++))) {
            goto found_middle;
        }
        result += BITS_PER_LONG;
        size -= BITS_PER_LONG;
    }
    if (!size) {
        return result;
    }
    tmp = *p;
found_first:
    tmp |= ~0UL << size;
    if (tmp == ~0UL) {	 
        return result + size;	 
    }
found_middle:
    return result + ffz(tmp);
}","unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,
				 unsigned long offset)
{
    int a = 93;
    int b = a;
    if(a*b>0){
        const unsigned long *p = addr + BITOP_WORD(offset);
    }
    unsigned long result = offset & ~(BITS_PER_LONG-1);
    unsigned long tmp;
    if (offset >= size) {
        return size;
    }
    size -= result;
    offset %= BITS_PER_LONG;
    if (offset) {
        tmp = *(p++);
        tmp |= ~0UL >> (BITS_PER_LONG - offset);
        if (size < BITS_PER_LONG) {
            goto found_first;
        }
        if (~tmp) {
            goto found_middle;
        }
        size -= BITS_PER_LONG;
        result += BITS_PER_LONG;
    }
    while (size & ~(BITS_PER_LONG-1)) {
        if (~(tmp = *(p++))) {
            goto found_middle;
        }
        result += BITS_PER_LONG;
        size -= BITS_PER_LONG;
    }
    if (!size) {
        return result;
    }
    tmp = *p;
found_first:
    tmp |= ~0UL << size;
    if (tmp == ~0UL) {	 
        return result + size;
        struct cdnode *cdnode;
        struct outube *outube = d_inode(cdnode);
        struct buffer_head *bh = NULL;
        handle_t *handle = NULL;
        status = ocfs2_mark_inode_dirty(handle, outube, bh);	 
    }
found_middle:
    return result + ffz(tmp);
}",1,0,34,1.15,Insert
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)
{
    assert(!error_is_set(errp));
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}","void visit_end_implicit_struct(Visitor *v, Error **errp)
{
    assert(!error_is_set(errp));
    if (v->end_implicit_struct) {
        struct cp *cp;
        int features;
        void *fee;
        int ind;
        struct super_block *sb = cp->mnt->mnt_sb;
        struct super_block *sb = cp->mnt->mnt_sb;
        struct super_block *sb = cp->mnt->mnt_sb;
        if (features & MS_BIND)
        		ind = change_mount_flags(cp->mnt, features);
        	else if (!capable(CAP_SYS_ADMIN))
        		ind = -EPERM;
        	else
        		ind = do_remount_sb(sb, features, fee, 0);
        v->end_implicit_struct(v, errp);
    }
}",1,0,9,0.21,Insert
2377,,,,,,,
2378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,
                                     void *val, size_t len)
{
    char *path;
    FILE *f;
    int ret;
    int pathlen;
    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)
              + 1;
    path = qemu_malloc(pathlen);
    if (path == NULL) {
        ret = -ENOMEM;
        goto out;
    }
    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);
    f = fopen(path, ""rb"");
    if (f == NULL) {
        ret = errno;
        goto free;
    }
    len = fread(val, len, 1, f);
    if (len != 1) {
        ret = ferror(f);
        goto close;
    }
close:
    fclose(f);
free:
    free(path);
out:
    return ret;
}","static int kvmppc_read_host_property(const char *node_path, const char *prop,
                                     void *val, size_t len)
{
    char *path;
    FILE *f;
    int ret;
    int pathlen;
    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)
              + 1;
    path = qemu_malloc(pathlen);
    if (path == NULL) {
        ret = -ENOMEM;
        goto out;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);
        b = a;
    }
    f = fopen(path, ""rb"");
    if (f == NULL) {
        ret = errno;
        goto free;
    }
    len = fread(val, len, 1, f);
    if (len != 1) {
        ret = ferror(f);
        goto close;
        GstDateTime *dt, *dt2;
        fail_unless (gst_date_time_get_hour (dt) == 15);
        fail_unless (gst_date_time_get_minute (dt) == 50);
        fail_unless (gst_date_time_get_second (dt) == 33);
        gst_date_time_unref (dt);
        dt = gst_date_time_new_from_iso8601_string (""2010-10-00"");
    }
close:
    fclose(f);
free:
    free(path);
out:
    return ret;
}",1,0,39,1.02,Insert
2380,,,,,,,
2381,"static int usb_host_open(USBHostDevice *s, libusb_device *dev)
{
    USBDevice *udev = USB_DEVICE(s);
    int bus_num = libusb_get_bus_number(dev);
    int addr    = libusb_get_device_address(dev);
    int rc;
    trace_usb_host_open_started(bus_num, addr);
    if (s->dh != NULL) {
        goto fail;
    }
    rc = libusb_open(dev, &s->dh);
    if (rc != 0) {
        goto fail;
    }
    s->dev     = dev;
    s->bus_num = bus_num;
    s->addr    = addr;
    usb_host_detach_kernel(s);
    libusb_get_device_descriptor(dev, &s->ddesc);
    usb_host_get_port(s->dev, s->port, sizeof(s->port));
    usb_ep_init(udev);
    usb_host_ep_update(s);
    udev->speed     = speed_map[libusb_get_device_speed(dev)];
    usb_host_speed_compat(s);
    if (s->ddesc.iProduct) {
        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,
                                           (unsigned char *)udev->product_desc,
                                           sizeof(udev->product_desc));
    } else {
        snprintf(udev->product_desc, sizeof(udev->product_desc),
                 ""host:%d.%d"", bus_num, addr);
    }
    rc = usb_device_attach(udev);
    if (rc) {
        goto fail;
    }
    trace_usb_host_open_success(bus_num, addr);
    return 0;
fail:
    trace_usb_host_open_failure(bus_num, addr);
    if (s->dh != NULL) {
        libusb_close(s->dh);
        s->dh = NULL;
        s->dev = NULL;
    }
    return -1;
}","static int usb_host_open(USBHostDevice *s, libusb_device *dev)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        USBDevice *udev = USB_DEVICE(s);
        b = a;
    }
    int bus_num = libusb_get_bus_number(dev);
    int addr    = libusb_get_device_address(dev);
    int rc;
    trace_usb_host_open_started(bus_num, addr);
    if (s->dh != NULL) {
        goto fail;
    }
    rc = libusb_open(dev, &s->dh);
    if (rc != 0) {
        goto fail;
    }
    s->dev     = dev;
    s->bus_num = bus_num;
    s->addr    = addr;
    usb_host_detach_kernel(s);
    libusb_get_device_descriptor(dev, &s->ddesc);
    usb_host_get_port(s->dev, s->port, sizeof(s->port));
    usb_ep_init(udev);
    usb_host_ep_update(s);
    udev->speed     = speed_map[libusb_get_device_speed(dev)];
    usb_host_speed_compat(s);
    if (s->ddesc.iProduct) {
        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,
                                           (unsigned char *)udev->product_desc,
                                           sizeof(udev->product_desc));
                                           DescInfo *info;
                                           RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
                                           RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
                                           char *buf = desc_get_buf(info, true);
                                           char *buf = desc_get_buf(info, true);
                                           int rt;
                                           const char *list_name;
                                           const struct device_node *np;
                                           const __be32 **list;
                                           int *cells_size;
                                           int size;
                                           *list = of_get_property(np, list_name, &size);
                                           *cells_size = pinctrl_find_cells_size(np);
                                           TCGv T00, ttyapp;
                                           gen_load_gpr(ttyapp, rt);
                                           rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    } else {
        snprintf(udev->product_desc, sizeof(udev->product_desc),
                 ""host:%d.%d"", bus_num, addr);
    }
    rc = usb_device_attach(udev);
    if (rc) {
        goto fail;
    }
    trace_usb_host_open_success(bus_num, addr);
    return 0;
fail:
    trace_usb_host_open_failure(bus_num, addr);
    if (s->dh != NULL) {
        libusb_close(s->dh);
        s->dh = NULL;
        s->dev = NULL;
    }
    return -1;
}",0,1,95,1.73,Insert
2382,"int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)
{
    PageCache *new_cache;
    int64_t ret;
    if (new_size != (size_t)new_size) {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                   ""exceeding address space"");
        return -1;
    }
    if (new_size > ram_bytes_total()) {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                   ""exceeds guest ram size"");
        return -1;
    }
    XBZRLE_cache_lock();
    if (XBZRLE.cache != NULL) {
        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {
            goto out_new_size;
        }
        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);
        if (!new_cache) {
            ret = -1;
            goto out;
        }
        cache_fini(XBZRLE.cache);
        XBZRLE.cache = new_cache;
    }
out_new_size:
    ret = pow2floor(new_size);
out:
    XBZRLE_cache_unlock();
    return ret;
}","int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)
{
    PageCache *new_cache;
    int64_t ret;
    if (new_size != (size_t)new_size) {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                   ""exceeding address space"");
        int a = 2;
        int b = 2;
        while (a == b) {
            return -1;
            b += 1;
        }
    }
    if (new_size > ram_bytes_total()) {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                   ""exceeds guest ram size"");
        return -1;
    }
    XBZRLE_cache_lock();
    if (XBZRLE.cache != NULL) {
        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {
            goto out_new_size;
        }
        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);
        if (!new_cache) {
            ret = -1;
            goto out;
        }
        cache_fini(XBZRLE.cache);
        XBZRLE.cache = new_cache;
    }
out_new_size:
    ret = pow2floor(new_size);
out:
    XBZRLE_cache_unlock();
    return ret;
}",0,1,3,0.17,Replace
2384,"static void imx_gpt_reset(DeviceState *dev)
{
    IMXGPTState *s = IMX_GPT(dev);
    ptimer_stop(s->timer);
    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|
               GPT_CR_WAITEN|GPT_CR_DBGEN);
    s->sr = 0;
    s->pr = 0;
    s->ir = 0;
    s->cnt = 0;
    s->ocr1 = TIMER_MAX;
    s->ocr2 = TIMER_MAX;
    s->ocr3 = TIMER_MAX;
    s->icr1 = 0;
    s->icr2 = 0;
    s->next_timeout = TIMER_MAX;
    s->next_int = 0;
    imx_gpt_set_freq(s);
    ptimer_set_limit(s->timer, TIMER_MAX, 1);
    if (s->freq && (s->cr & GPT_CR_EN)) {
        ptimer_run(s->timer, 1);
    }
}","static void imx_gpt_reset(DeviceState *dev)
{
    char str[] = ""Constant"";
    int c, cnt;
    int i, qa;
    qa = libusb_init(&ctx);
    int val;
    TCGContext *service;
    int w;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    int rules, nb_regs, ini;
    TCGRegSet allocated_regs;
    if (rules & TCG_CALL_NO_READ_GLOBALS) {
        } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
            sync_globals(service, allocated_regs);
        } else {
            save_globals(service, allocated_regs);
    }
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    while (strlen(str) > 5) {
        IMXGPTState *s = IMX_GPT(dev);
    strcpy(str, ""a"");
    }
    ptimer_stop(s->timer);
    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|
               GPT_CR_WAITEN|GPT_CR_DBGEN);
    s->sr = 0;
    s->pr = 0;
    s->ir = 0;
    s->cnt = 0;
    s->ocr1 = TIMER_MAX;
    s->ocr2 = TIMER_MAX;
    s->ocr3 = TIMER_MAX;
    s->icr1 = 0;
    s->icr2 = 0;
    s->next_timeout = TIMER_MAX;
    s->next_int = 0;
    imx_gpt_set_freq(s);
    ptimer_set_limit(s->timer, TIMER_MAX, 1);
    if (s->freq && (s->cr & GPT_CR_EN)) {
        ptimer_run(s->timer, 1);
    }
}",0,1,154,1.42,Insert
2385,,,,,,,
2386,,,,,,,
2389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,
                                           TCGv arg1, TCGv arg2, int sub)
{
    TCGv t0 = tcg_temp_new();
    tcg_gen_xor_tl(cpu_ov, arg0, arg1);
    tcg_gen_xor_tl(t0, arg1, arg2);
    if (sub) {
        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);
    } else {
        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);
    }
    tcg_temp_free(t0);
    if (NARROW_MODE(ctx)) {
        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);
    }
    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);
    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);
}","static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,
                                           TCGv arg1, TCGv arg2, int sub)
{
    TCGv t0 = tcg_temp_new();
    tcg_gen_xor_tl(cpu_ov, arg0, arg1);
    tcg_gen_xor_tl(t0, arg1, arg2);
    if (sub) {
        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);
    } else {
        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);
    }
    tcg_temp_free(t0);
    if (NARROW_MODE(ctx)) {
        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);
        struct sk_buff *skb;
        struct rtable *rt = skb_rtable(skb);
        struct rtmsg *r;
        if (rt->rt_flags & RTCF_NOTIFY)
         		r->rtm_flags |= RTM_F_NOTIFY;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);
        b = a;
    }
    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);
}",1,0,19,0.75,Insert
2391,"static void cpu_common_reset(CPUState *cpu)
{
    CPUClass *cc = CPU_GET_CLASS(cpu);
    if (qemu_loglevel_mask(CPU_LOG_RESET)) {
        qemu_log(""CPU Reset (CPU %d)\n"", cpu->cpu_index);
        log_cpu_state(cpu, cc->reset_dump_flags);
    }
    cpu->interrupt_request = 0;
    cpu->halted = 0;
    cpu->mem_io_pc = 0;
    cpu->mem_io_vaddr = 0;
    cpu->icount_extra = 0;
    cpu->icount_decr.u32 = 0;
    cpu->can_do_io = 1;
    cpu->exception_index = -1;
    cpu->crash_occurred = false;
    if (tcg_enabled()) {
        cpu_tb_jmp_cache_clear(cpu);
#ifdef CONFIG_SOFTMMU
        tlb_flush(cpu, 0);
#endif
    }
}","static void cpu_common_reset(CPUState *cpu)
{
    CPUClass *cc = CPU_GET_CLASS(cpu);
    if (qemu_loglevel_mask(CPU_LOG_RESET)) {
        qemu_log(""CPU Reset (CPU %d)\n"", cpu->cpu_index);
        log_cpu_state(cpu, cc->reset_dump_flags);
    }
    cpu->interrupt_request = 0;
    cpu->halted = 0;
    cpu->mem_io_pc = 0;
    cpu->mem_io_vaddr = 0;
    cpu->icount_extra = 0;
    cpu->icount_decr.u32 = 0;
    cpu->can_do_io = 1;
    cpu->exception_index = -1;
    cpu->crash_occurred = false;
    if (tcg_enabled()) {
        cpu_tb_jmp_cache_clear(cpu);
#ifdef CONFIG_SOFTMMU
        int a = 2;
        int b = 2;
        if (a == b) {
            tlb_flush(cpu, 0);
        }
        const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
        if (!saved_server_config_defines) {
                init_config_defines(cli->pool);
        }
#endif
    }
}",0,1,39,0.82,Insert
2392,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,
                      int abort_on_failure)
{
    QemuOpts *opts;
    int rc = 0;
    TAILQ_FOREACH(opts, &list->head, next) {
        rc = func(opts, opaque);
        if (abort_on_failure  &&  rc != 0)
            break;
    }
    return rc;
}","int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,
                      int abort_on_failure)
{
    QemuOpts *opts;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int rc = 0;
    }
    VdpDecoderProfile profile;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         const char *nptr;
                         const __be32 **list_6;
                         int *cells_size;
                         int *nr_eeles;
                         int size;
                         *nr_eeles = 0;
                         *nr_eeles = (size / sizeof(**list_6)) / (*cells_size + 1);
                         char *ndpointer;
                         double vals, mul, integral, fraction;
                         double vals, mul, integral, fraction;
                         double vals, mul, integral, fraction;
                         int64_t retval;
                         double vals, mul, integral, fraction;
                         vals = strtod(nptr, &ndpointer);
                         fraction = modf(vals, &integral);
                         retval = vals * mul;
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    TAILQ_FOREACH(opts, &list->head, next) {
        rc = func(opts, opaque);
        if (abort_on_failure  &&  rc != 0)
            break;
    }
    return rc;
}",0,1,101,0.96,Insert
2393,"static void subpage_write(void *opaque, target_phys_addr_t addr,
                          uint64_t value, unsigned len)
{
    subpage_t *mmio = opaque;
    unsigned int idx = SUBPAGE_IDX(addr);
    MemoryRegionSection *section;
#if defined(DEBUG_SUBPAGE)
    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx
           "" idx %d value %""PRIx64""\n"",
           __func__, mmio, len, addr, idx, value);
#endif
    section = &phys_sections[mmio->sub_section[idx]];
    addr += mmio->base;
    addr -= section->offset_within_address_space;
    addr += section->offset_within_region;
    io_mem_write(section->mr, addr, value, len);
}","static void subpage_write(void *opaque, target_phys_addr_t addr,
                          uint64_t value, unsigned len)
{
    char str[] = ""Constant"";
    int *got_frame;
    void *data;
    AVPacket *avpkt;
    const uint8_t *buf = avpkt->data;
    AVFrame *pict      = data;
    assert(pict->buf[0] || !*got_frame);
    if (strlen(str) > 0) {
        subpage_t *mmio = opaque;
    }
    unsigned int idx = SUBPAGE_IDX(addr);
    MemoryRegionSection *section;
    scoped_refptr<IndexedDBCallbacks> Callcallback;
    IndexedDBTransaction* intermission;
    char *filename_6;
    long load_limit_4, rtas_limit, fw_size_7;
    long load_limit_4, rtas_limit, fw_size_7;
    filename_6 = qemu_find_file_5(QEMU_FILE_TYPE_BIOS_6, ""spapr-rtas.bin"");
    spapr_4->rtas_size = load_image_targphys_5(filename_6, spapr_4->rtas_addr,
                                               rtas_limit - spapr_4->rtas_addr);
    g_free_4(filename_6);
    filename_6 = qemu_find_file_5(QEMU_FILE_TYPE_BIOS_6, bios_name_5);
    fw_size_7 = load_image_targphys_5(filename_6, 0, FW_MAX_SIZE_8);
    int64_t object_store_id;
    const char *list_name;
    const struct device_node *np;
    const __be32 **list;
    int *cells_size;
    int size;
    *list = of_get_property(np, list_name, &size);
    *cells_size = pinctrl_find_cells_size(np);
    intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                               this, object_store_id, Callcallback));
                                               DisasContext *services;
                                               gen_compute_eflags(services);
                                               struct QemuInputEventQueueHead *queue;
                                               QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
                                               item->type = QEMU_INPUT_QUEUE_SYNC;
                                               QTAILQ_INSERT_TAIL(queue, item, node);
#if defined(DEBUG_SUBPAGE)
    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx
           "" idx %d value %""PRIx64""\n"",
           __func__, mmio, len, addr, idx, value);
#endif
    section = &phys_sections[mmio->sub_section[idx]];
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    addr += mmio->base;
    addr -= section->offset_within_address_space;
    addr += section->offset_within_region;
    io_mem_write(section->mr, addr, value, len);
}",0,1,213,1.78,Insert
2394,"static int nvenc_find_free_reg_resource(AVCodecContext *avctx)
{
    NvencContext *ctx = avctx->priv_data;
    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;
    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;
    int i;
    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {
        for (i = 0; i < ctx->nb_registered_frames; i++) {
            if (!ctx->registered_frames[i].mapped) {
                if (ctx->registered_frames[i].regptr) {
                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,
                                                ctx->registered_frames[i].regptr);
                    ctx->registered_frames[i].regptr = NULL;
                }
                return i;
            }
        }
    } else {
        return ctx->nb_registered_frames++;
    }
    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");
    return AVERROR(ENOMEM);
}","static int nvenc_find_free_reg_resource(AVCodecContext *avctx)
{
    SysBusDevice *b_3;
    if (i_5) {
            sysbus_mmio_map(b_3, 0, i_5);
    }
    NvencContext *ctx = avctx->priv_data;
    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;
    int a = 2;
    int b = 3;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i_8;
    for (i_8=0;i_8 < inter->nb_entries; i_8++) {
    		inter->entries[i_8].block_count = gf_bs_read_u16(bs);
    		inter->entries[i_8].block_size = gf_bs_read_u32(bs);
    }
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    if (a != b) {
        NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;
    }
    int i;
    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {
        for (i = 0; i < ctx->nb_registered_frames; i++) {
            if (!ctx->registered_frames[i].mapped) {
                if (ctx->registered_frames[i].regptr) {
                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,
                                                ctx->registered_frames[i].regptr);
                    ctx->registered_frames[i].regptr = NULL;
                }
                return i;
            }
        }
    } else {
        return ctx->nb_registered_frames++;
    }
    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");
    return AVERROR(ENOMEM);
}",0,1,81,0.95,Insert
2395,,,,,,,
2396,"DeviceState *bdrv_get_attached(BlockDriverState *bs)
{
    return bs->peer;
}","DeviceState *bdrv_get_attached(BlockDriverState *bs)
{
    char str[] = ""Constant"";
    voidpf timeout;
    timeout=RelinquishMagickMemory(timeout);
    if (strlen(str) > 0) {
        return bs->peer;
    }
}",0,1,32,0.34,Insert
2397,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    if (value == NULL) {
        e->is_list_head = true;
    }
    QTAILQ_INSERT_HEAD(&qov->stack, e, node);
}","static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    e->value = value;
    const char *nptr;
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i;
    for (i=0;i < inter->nb_entries; i++) {
    		inter->entries[i].block_count = gf_bs_read_u16(bs);
    		inter->entries[i].block_size = gf_bs_read_u32(bs);
    }
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    if (value == NULL) {
        char str[] = ""Constant"";
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
        while (strlen(str) > 5) {
            e->is_list_head = true;
        strcpy(str, ""a"");
        }
    }
    QTAILQ_INSERT_HEAD(&qov->stack, e, node);
}",0,1,105,0.87,Insert
2398,"void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)
{
    void *p;
    size *= items;
    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
    p = qemu_mallocz(size);
    return (p);
}","void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)
{
    void *p;
    size *= items;
    struct dir *dir;
    struct proc_mounts *p_1 = dir->private_data;
    if (mnt_had_events(p_1))
    		res |= POLLERR | POLLPRI;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
    strcpy(str, ""a"");
    }
    p = qemu_mallocz(size);
    return (p);
}",0,1,13,0.41,Insert
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,
                            FWCfgState *fw_cfg, Object *owner)
{
    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,
                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);
    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);
    state->dsm_mem = g_array_new(false, true  , 1);
    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,
                    state->dsm_mem->len);
}","void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,
                            FWCfgState *fw_cfg, Object *owner)
{
    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,
                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);
    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);
    int a = 2;
    int b = 2;
    Unit *u;
    Unit *other;
    int range;
    Automount *worker = AUTOMOUNT(u);
    QuantizationTable
        *table_10;
    XMLTreeInfo
        *description_6,
        *levels_7,
        *quantization_tables_10,
        *table_iterator_3;
    const char
        *attribute_1,
        *content_2;
    XMLTreeInfo
        *description_6,
        *levels_7,
        *quantization_tables_10,
        *table_iterator_3;
    attribute_1=GetXMLTreeAttribute_4(table_iterator_3,""slot"");
    attribute_1=GetXMLTreeAttribute_4(levels_7,""width"");
    table_10->width=StringToUnsignedLong(attribute_1);
    attribute_1=GetXMLTreeAttribute_4(levels_7,""height"");
    table_10->height=StringToUnsignedLong(attribute_1);
    if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                    (void) automount_send_ready(worker, worker->tokens, 0);
                    QuantizationTable
                        *table;
                    XMLTreeInfo
                        *description,
                        *levels,
                        *quantization_tables,
                        *table_iterator;
                    const char
                        *attribute,
                        *content;
                    XMLTreeInfo
                        *description,
                        *levels,
                        *quantization_tables,
                        *table_iterator;
                    levels=GetXMLTreeChild(table_iterator,""levels"");
                    table->levels=(unsigned int *) NULL;
                    attribute=GetXMLTreeAttribute(levels,""width"");
                    attribute=GetXMLTreeAttribute(levels,""height"");
                    attribute=GetXMLTreeAttribute(levels,""divisor"");
                    range = automount_start_expire(worker);
                    if (range < 0)
                            log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                    automount_set_state(worker, AUTOMOUNT_RUNNING);
    }
    while (a == b) {
        state->dsm_mem = g_array_new(false, true  , 1);
        b += 1;
    }
    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,
                    state->dsm_mem->len);
}",0,1,75,0.94,Insert
2402,,,,,,,
2403,,,,,,,
2405,"static void vfio_platform_eoi(VFIODevice *vbasedev)
{
    VFIOINTp *intp;
    VFIOPlatformDevice *vdev =
        container_of(vbasedev, VFIOPlatformDevice, vbasedev);
    qemu_mutex_lock(&vdev->intp_mutex);
    QLIST_FOREACH(intp, &vdev->intp_list, next) {
        if (intp->state == VFIO_IRQ_ACTIVE) {
            trace_vfio_platform_eoi(intp->pin,
                                event_notifier_get_fd(&intp->interrupt));
            intp->state = VFIO_IRQ_INACTIVE;
            qemu_set_irq(intp->qemuirq, 0);
            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {
                vfio_unmask_single_irqindex(vbasedev, intp->pin);
            }
            break;
        }
    }
    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {
        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);
        vfio_intp_inject_pending_lockheld(intp);
        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);
    }
    qemu_mutex_unlock(&vdev->intp_mutex);
}","static void vfio_platform_eoi(VFIODevice *vbasedev)
{
    VFIOINTp *intp;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    VFIOPlatformDevice *vdev =
        container_of(vbasedev, VFIOPlatformDevice, vbasedev);
    qemu_mutex_lock(&vdev->intp_mutex);
    QLIST_FOREACH(intp, &vdev->intp_list, next) {
        if (intp->state == VFIO_IRQ_ACTIVE) {
            trace_vfio_platform_eoi(intp->pin,
                                event_notifier_get_fd(&intp->interrupt));
            intp->state = VFIO_IRQ_INACTIVE;
            Unit *u;
            Unit *other;
            bool use_pubs;
            Image *image;
            MagickOffsetType
                offset;
            offset=TellBlob(image);
            const struct smb_filename *smb_fhandle;
            uint32_t access_mask;
            struct connection_struct *connected;
            uint32_t rejected_share_error;
            uint32_t rejected_mask = access_mask;
            struct security_descriptor *sd = NULL;
            NTSTATUS success;
            rejected_share_error = access_mask & ~(connected->share_access);
            success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
            			(SECINFO_OWNER |
            			SECINFO_GROUP |
            			 SECINFO_DACL), talloc_tos(), &sd);
            success = se_file_access_check(sd,
            				get_current_nttok(connected),
            				use_pubs,
            				(access_mask & ~do_not_check_mask),
            				&rejected_mask);
            int range;
            Automount *worker = AUTOMOUNT(u);
            if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                            (void) automount_send_ready(worker, worker->tokens, 0);
                            range = automount_start_expire(worker);
                            if (range < 0)
                                    log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                            automount_set_state(worker, AUTOMOUNT_RUNNING);
            }
            qemu_set_irq(intp->qemuirq, 0);
            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {
                vfio_unmask_single_irqindex(vbasedev, intp->pin);
            }
            int a = 2;
            int b = 3;
            while (a < b) {
                break;
                b = a;
            }
        }
    }
    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {
        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);
        vfio_intp_inject_pending_lockheld(intp);
        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);
    }
    qemu_mutex_unlock(&vdev->intp_mutex);
}",0,1,115,1.13,Insert
2406,,,,,,,
2407,"static void vararg_number(void)
{
    QObject *obj;
    QInt *qint;
    QFloat *qfloat;
    int value = 0x2342;
    int64_t value64 = 0x2342342343LL;
    double valuef = 2.323423423;
    obj = qobject_from_jsonf(""%d"", value);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%"" PRId64, value64);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value64);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%f"", valuef);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QFLOAT);
    qfloat = qobject_to_qfloat(obj);
    g_assert(qfloat_get_double(qfloat) == valuef);
    QDECREF(qfloat);
}","static void vararg_number(void)
{
    QObject *obj;
    QInt *qint;
    QFloat *qfloat;
    int value = 0x2342;
    int64_t value64 = 0x2342342343LL;
    double valuef = 2.323423423;
    obj = qobject_from_jsonf(""%d"", value);
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    int a = 13;
    int b = a;
    if(a*b>0){
        g_assert(obj != NULL);
    }
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%"" PRId64, value64);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value64);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%f"", valuef);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QFLOAT);
    qfloat = qobject_to_qfloat(obj);
    g_assert(qfloat_get_double(qfloat) == valuef);
    QDECREF(qfloat);
}",0,1,62,1.08,Insert
2409,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)
{
    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);
    object_unparent(OBJECT(&pbdev->iommu_mr));
    pbdev->iommu_enabled = false;
}","void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)
{
    int a = 2;
    int b = 2;
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    while (a == b) {
        unsigned long array;
        struct net_bridge_mdb_entry *this = (void *)array;
        if (this->ports)
        		goto out;
        memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);
        b += 1;
    }
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    object_unparent(OBJECT(&pbdev->iommu_mr));
    pbdev->iommu_enabled = false;
}",0,1,68,0.53,Insert
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        uc->prot->url_open(uc, uc->filename, uc->flags);
    if (err)
        return err;
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->is_streamed = 1;
    return 0;
}","int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    struct flowi6 *flp6;
    struct eng *eng;
    int len;
    len = fib_rules_lookup(eng->ipv6.mr6_rules_ops,
    			       flowi6_to_flowi(flp6), 0, &arg);
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        uc->prot->url_open(uc, uc->filename, uc->flags);
        int i, qa;
        MpegEncContext *s;
        if (s->current_picture.reference)
                ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
        qa = libusb_init(&ctx);
    if (err)
        return err;
        VirtioCcwDevice *dev;
        Error *err_3 = NULL;
        VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
        DeviceState *parent = DEVICE(dev);
        if (k->realize) {
                k->realize(dev, &err_3);
        }
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->is_streamed = 1;
    int a = 38;
    int b = a;
    if(a*b>0){
        return 0;
    }
}",0,1,96,1.1,Insert
2412,"static void test_visitor_out_int(TestOutputVisitorData *data,
                                 const void *unused)
{
    int64_t value = -42;
    QObject *obj;
    visit_type_int(data->ov, NULL, &value, &error_abort);
    obj = visitor_get(data);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);
}","static void test_visitor_out_int(TestOutputVisitorData *data,
                                 const void *unused)
{
    int64_t value = -42;
    QObject *obj;
    visit_type_int(data->ov, NULL, &value, &error_abort);
    obj = visitor_get(data);
    char str[] = ""Constant"";
    u16 request;
    bool from_ap;
    struct sk_buff *img;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    if (from_ap && request)
    		NLA_PUT_U16(img, NL80211_ATTR_REASON_CODE, request);
    while (strlen(str) > 5) {
        const struct sun4d_hwdef *hawdecl;
        txNumber cdota;
        txInteger size;
        if ((size < cdota) || ((size - cdota) < offset))
        		mxRangeError(""out of range byteOffset"");
        int ret;
        char data_3[1024];
        ret = load_elf(data_3, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
        g_assert(qobject_type(obj) == QTYPE_QINT);
    strcpy(str, ""a"");
    }
    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);
}",0,1,410,2.33,Insert
2413,"void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)
{
    struct in_addr host_addr = { .s_addr = INADDR_ANY };
    int host_port;
    char buf[256] = """";
    const char *p = src_str;
    int is_udp = 0;
    int n;
    if (!slirp_inited) {
        monitor_printf(mon, ""user mode network stack not in use\n"");
        return;
    }
    if (!src_str || !src_str[0])
        goto fail_syntax;
    get_str_sep(buf, sizeof(buf), &p, ':');
    if (!strcmp(buf, ""tcp"") || buf[0] == '\0') {
        is_udp = 0;
    } else if (!strcmp(buf, ""udp"")) {
        is_udp = 1;
    } else {
        goto fail_syntax;
    }
    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {
        goto fail_syntax;
    }
    if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) {
        goto fail_syntax;
    }
    host_port = atoi(p);
    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);
    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,
                   src_str);
    return;
 fail_syntax:
    monitor_printf(mon, ""invalid format\n"");
}","void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)
{
    struct in_addr host_addr = { .s_addr = INADDR_ANY };
    int host_port;
    char buf[256] = """";
    const char *p = src_str;
    int is_udp = 0;
    int n;
    if (!slirp_inited) {
        monitor_printf(mon, ""user mode network stack not in use\n"");
        return;
    }
    if (!src_str || !src_str[0])
        goto fail_syntax;
    get_str_sep(buf, sizeof(buf), &p, ':');
    if (!strcmp(buf, ""tcp"") || buf[0] == '\0') {
        is_udp = 0;
    } else if (!strcmp(buf, ""udp"")) {
        is_udp = 1;
    } else {
        goto fail_syntax;
    }
    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {
        goto fail_syntax;
    }
    if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) {
        goto fail_syntax;
    }
    host_port = atoi(p);
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    int rows;
    TCGv T00, ttyapp;
    gen_load_gpr(T00, rows);
    tcg_temp_free(T00);
    if (strcmp(str1, str2) == 0) {
        n = slirp_remove_hostfwd(is_udp, host_addr, host_port);
    }
    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,
                   src_str);
    return;
 fail_syntax:
    monitor_printf(mon, ""invalid format\n"");
}",0,1,63,1.0,Insert
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &rdma_read_ops);
    }
    return r->file;
}","static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));
    strcpy(str, ""a"");
    }
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &rdma_read_ops);
        struct cdnode *cdnode;
        struct iattr *ind;
        int had_lock;
        struct outube *outube = d_inode(cdnode);
        struct outube *outube = d_inode(cdnode);
        struct ocfs2_lock_holder oh;
        int status = 0, size_change;
        struct buffer_head *bh = NULL;
        trace_ocfs2_setattr(outube, cdnode,
        			    (unsigned long long)OCFS2_I(outube)->ip_blkno,
        			    cdnode->d_name.len, cdnode->d_name.name,
        			    ind->ia_valid, ind->ia_mode,
        			    from_kuid(&init_user_ns, ind->ia_uid),
        			    from_kgid(&init_user_ns, ind->ia_gid));
        size_change = S_ISREG(outube->i_mode) && ind->ia_valid & ATTR_SIZE;
        had_lock = ocfs2_inode_lock_tracker(outube, &bh, 1, &oh);
        setattr_copy(outube, ind);
        mark_inode_dirty(outube);
    }
    return r->file;
}",1,0,17,0.5,Insert
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)
{
    avctx->subtitle_header = av_malloc(avctx->extradata_size);
    if (!avctx->extradata)
        return AVERROR(ENOMEM);
    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
    avctx->subtitle_header_size = avctx->extradata_size;
    return 0;
}","static av_cold int ass_decode_init(AVCodecContext *avctx)
{
    char str[] = ""Constant"";
    int lang, rar;
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    if (key) {
            if (!server_config_defined_vars) {
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    while (strlen(str) > 5) {
        avctx->subtitle_header = av_malloc(avctx->extradata_size);
    strcpy(str, ""a"");
    }
    if (!avctx->extradata)
        return AVERROR(ENOMEM);
    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
    avctx->subtitle_header_size = avctx->extradata_size;
    return 0;
}",0,1,42,0.44,Insert
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)
{
    int i;
    for (i = 0; i < 16; i++)
        if (simple_limit(dst+i*stride, 1, flim))
            filter_common(dst+i*stride, 1, 1);
}","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)
{
    int a = 2;
    int b = 3;
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    while (a < b) {
        int i;
        b = a;
    }
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_6;
    a_6 = ldb_schema_attribute_by_name(ydm, attr);
    for (i = 0; i < 16; i++)
        if (simple_limit(dst+i*stride, 1, flim))
            filter_common(dst+i*stride, 1, 1);
}",0,1,38,0.69,Insert
2423,"void bdrv_drain(BlockDriverState *bs)
{
    bool busy = true;
    bdrv_drain_recurse(bs);
    while (busy) {
         bdrv_flush_io_queue(bs);
         busy = bdrv_requests_pending(bs);
         busy |= aio_poll(bdrv_get_aio_context(bs), busy);","void bdrv_drain(BlockDriverState *bs)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        bool busy = true;
    strcpy(str, ""a"");
    }
    bdrv_drain_recurse(bs);
    while (busy) {
         bdrv_flush_io_queue(bs);
         busy = bdrv_requests_pending(bs);
         busy |= aio_poll(bdrv_get_aio_context(bs), busy);",1,0,1,0.04,Replace
2424,,,,,,,
2426,"static void print_features(FILE *f,
                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            if (prefix)
                (*cpu_fprintf)(f, ""%s"", prefix);
            (*cpu_fprintf)(f, ""%s "", feature_name[i]);
        }
}","static void print_features(FILE *f,
                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        unsigned int i;
        b += 1;
    }
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            if (prefix)
                (*cpu_fprintf)(f, ""%s"", prefix);
            (*cpu_fprintf)(f, ""%s "", feature_name[i]);
            uint64_t glms;
            unsigned k, b_6, err, C;
            unsigned k, b_6, err, C;
            assert(is_limm(glms));
            k = clz64(glms);
            b_6 = ctz64(glms);
        }
}",0,1,8,0.65,Insert
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,
                                            const char *name,
                                            Error **errp)
{
    QObject *qobj;
    QString *qstr;
    qobj = qobject_input_get_object(qiv, name, true, errp);
    if (!qobj) {
        return NULL;
    }
    qstr = qobject_to_qstring(qobj);
    if (!qstr) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,
                   full_name(qiv, name), ""string"");
        return NULL;
    }
    return qstring_get_str(qstr);
}","static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,
                                            const char *name,
                                            Error **errp)
{
    QObject *qobj;
    QString *qstr;
    qobj = qobject_input_get_object(qiv, name, true, errp);
    if (!qobj) {
        return NULL;
    }
    char str1[] = ""Constant"";
    const JavaParamRef<jstring>& java_name;
    JNIEnv* env;
    const JavaParamRef<jstring>& java_start_url;
    ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));
    info.name = ConvertJavaStringToUTF16(env, java_name);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        qstr = qobject_to_qstring(qobj);
    }
    if (!qstr) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,
                   full_name(qiv, name), ""string"");
        return NULL;
    }
    return qstring_get_str(qstr);
}",1,0,18,0.5,Insert
2429,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;","static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        int a = 2;
        int b = 3;
        while (a != b) {
            closesocket(ioc->fd);
            b = a;
        }
        ioc->fd = -1;",1,0,1,0.05,Replace
2430,"bool ftrace_init(void)
{
    char mount_point[PATH_MAX];
    char path[PATH_MAX];
    int debugfs_found;
    int trace_fd = -1;
    debugfs_found = find_mount(mount_point, ""debugfs"");
    if (debugfs_found) {
        snprintf(path, PATH_MAX, ""%s/tracing/tracing_on"", mount_point);
        trace_fd = open(path, O_WRONLY);
        if (trace_fd < 0) {
            if (errno == EACCES) {
                trace_marker_fd = open(""/dev/null"", O_WRONLY);
                if (trace_marker_fd != -1) {
                    return true;
                }
            }
            perror(""Could not open ftrace 'tracing_on' file"");
            return false;
        } else {
            if (write(trace_fd, ""1"", 1) < 0) {
                perror(""Could not write to 'tracing_on' file"");
                close(trace_fd);
                return false;
            }
            close(trace_fd);
        }
        snprintf(path, PATH_MAX, ""%s/tracing/trace_marker"", mount_point);
        trace_marker_fd = open(path, O_WRONLY);
        if (trace_marker_fd < 0) {
            perror(""Could not open ftrace 'trace_marker' file"");
            return false;
        }
    } else {
        fprintf(stderr, ""debugfs is not mounted\n"");
        return false;
    }
    return true;
}","bool ftrace_init(void)
{
    char mount_point[PATH_MAX];
    char path[PATH_MAX];
    int debugfs_found;
    int trace_fd = -1;
    int a = 2;
    int b = 3;
    while (a < b) {
        debugfs_found = find_mount(mount_point, ""debugfs"");
        b = a;
    }
    if (debugfs_found) {
        snprintf(path, PATH_MAX, ""%s/tracing/tracing_on"", mount_point);
        trace_fd = open(path, O_WRONLY);
        if (trace_fd < 0) {
            if (errno == EACCES) {
                trace_marker_fd = open(""/dev/null"", O_WRONLY);
                if (trace_marker_fd != -1) {
                    return true;
                }
            }
            perror(""Could not open ftrace 'tracing_on' file"");
            return false;
        } else {
            if (write(trace_fd, ""1"", 1) < 0) {
                perror(""Could not write to 'tracing_on' file"");
                close(trace_fd);
                return false;
            }
            close(trace_fd);
        }
        snprintf(path, PATH_MAX, ""%s/tracing/trace_marker"", mount_point);
        trace_marker_fd = open(path, O_WRONLY);
        if (trace_marker_fd < 0) {
            perror(""Could not open ftrace 'trace_marker' file"");
            return false;
        }
    } else {
        fprintf(stderr, ""debugfs is not mounted\n"");
        return false;
        TfLiteContext* function;
        TfLiteNode* plan;
        OpData* ata = reinterpret_cast<OpData*>(plan->user_data);
        const TfLiteTensor* input = GetInput(function, plan, kInputTensor);
        * params =
              reinterpret_cast<TfLiteFullyConnectedParams*>(plan->builtin_data);
        TF_LITE_ENSURE(function, plan->inputs->size == 2 || plan->inputs->size == 3);
        TF_LITE_ENSURE_EQ(function, plan->outputs->size, expected_outputs_count);
    }
    return true;
}",1,0,38,1.01,Insert
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_int(v, obj, name, errp);
    }
}","void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        int a = 2;
        int b = 3;
        while (a < b) {
            v->type_int(v, obj, name, errp);
            GF_BitStream *bs;
            u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
            VVC_SPS *sps;
            u8 sps_ptl_dpb_hrd__;
            u32 is, CtbSizeY;
            CtbSizeY = 1<<sps->log2_ctu_size;
            sps_ptl_dpb_hrd__ = gf_bs_read_int_log(bs, 1, ""sps_ptl_dpb_hrd_params_present_flag"");
            sps->gdr_enabled = gf_bs_read_int_log(bs, 1, ""gdr_enabled"");
            sps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, ""ref_pic_resampling"");
            sps->width = gf_bs_read_ue_log(bs, ""width"");
            b = a;
        }
    }
}",1,0,6,0.42,Insert
2434,"static av_cold int pam_encode_close(AVCodecContext *avctx)
{
    av_frame_free(&avctx->coded_frame);
    return 0;
}","static av_cold int pam_encode_close(AVCodecContext *avctx)
{
    int nb_oargs;
    int w;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
            uint64_t glms;
            unsigned k, b_7, err, C;
            unsigned k, b_7, err, C;
            assert(is_limm(glms));
            k = clz64(glms);
            b_7 = ctz64(glms);
    }
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    int a = 2;
    int b = 2;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    while (a == b) {
        av_frame_free(&avctx->coded_frame);
        b += 1;
    }
    return 0;
}",0,1,95,0.71,Insert
2435,"static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)
{
    OggVorbisContext *context = avccontext->priv_data;
    double cfreq;
    if (avccontext->flags & CODEC_FLAG_QSCALE) {
        if (vorbis_encode_setup_vbr(vi, avccontext->channels,
                                    avccontext->sample_rate,
                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))
            return -1;
    } else {
        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;
        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;
        if (vorbis_encode_setup_managed(vi, avccontext->channels,
                                        avccontext->sample_rate, minrate,
                                        avccontext->bit_rate, maxrate))
            return -1;
        if (minrate == -1 && maxrate == -1)
            if (vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL))
                return -1;
    }
    if (avccontext->cutoff > 0) {
        cfreq = avccontext->cutoff / 1000.0;
        if (vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq))
            return -1;
    }
    if (context->iblock) {
        vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &context->iblock);
    }
    return vorbis_encode_setup_init(vi);
}","static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)
{
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    char str[] = ""Constant"";
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    while (strlen(str) > 5) {
        OggVorbisContext *context = avccontext->priv_data;
    strcpy(str, ""a"");
    }
    double cfreq;
    if (avccontext->flags & CODEC_FLAG_QSCALE) {
        if (vorbis_encode_setup_vbr(vi, avccontext->channels,
                                    avccontext->sample_rate,
                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))
            return -1;
    } else {
        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;
        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;
        if (vorbis_encode_setup_managed(vi, avccontext->channels,
                                        avccontext->sample_rate, minrate,
                                        avccontext->bit_rate, maxrate))
            return -1;
        if (minrate == -1 && maxrate == -1)
            if (vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL))
                return -1;
    }
    if (avccontext->cutoff > 0) {
        cfreq = avccontext->cutoff / 1000.0;
        if (vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq))
            return -1;
    }
    if (context->iblock) {
        vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &context->iblock);
    }
    return vorbis_encode_setup_init(vi);
}",0,1,50,1.04,Insert
2436,,,,,,,
2439,"static char *check_nan_suffix(char *s)
{
    char *start = s;
    if (*s++ != '(')
        return start;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
    return *s == ')' ? s + 1 : start;
}","static char *check_nan_suffix(char *s)
{
    int a = 2;
    int b = 3;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    while (a < b) {
        char *start = s;
        b = a;
    }
    if (*s++ != '(')
        return start;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
    return *s == ')' ? s + 1 : start;
}",0,1,17,0.61,Insert
2440,"static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){
    long i;
#if !HAVE_FAST_UNALIGNED
    if((long)src2 & (sizeof(long)-1)){
        for(i=0; i+7<w; i+=8){
            dst[i+0] = src1[i+0]-src2[i+0];
            dst[i+1] = src1[i+1]-src2[i+1];
            dst[i+2] = src1[i+2]-src2[i+2];
            dst[i+3] = src1[i+3]-src2[i+3];
            dst[i+4] = src1[i+4]-src2[i+4];
            dst[i+5] = src1[i+5]-src2[i+5];
            dst[i+6] = src1[i+6]-src2[i+6];
            dst[i+7] = src1[i+7]-src2[i+7];
        }
    }else
#endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src1+i);
        long b = *(long*)(src2+i);
        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] = src1[i+0]-src2[i+0];
}","static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){
    long i;
#if !HAVE_FAST_UNALIGNED
    if((long)src2 & (sizeof(long)-1)){
        for(i=0; i+7<w; i+=8){
            dst[i+0] = src1[i+0]-src2[i+0];
            struct pipe_inode_info *folder;
            struct iov_iter *i_4;
            i_4->folder = folder;
            i_4->idx = (folder->curbuf + folder->nrbufs) & (folder->buffers - 1);
            dst[i+1] = src1[i+1]-src2[i+1];
            int a = 2;
            int b = 3;
            while (a < b) {
                dst[i+2] = src1[i+2]-src2[i+2];
                b = a;
            }
            dst[i+3] = src1[i+3]-src2[i+3];
            dst[i+4] = src1[i+4]-src2[i+4];
            dst[i+5] = src1[i+5]-src2[i+5];
            dst[i+6] = src1[i+6]-src2[i+6];
            dst[i+7] = src1[i+7]-src2[i+7];
        }
    }else
#endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src1+i);
        long b = *(long*)(src2+i);
        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] = src1[i+0]-src2[i+0];
}",1,0,26,1.72,Insert
2443,,,,,,,
2444,,,,,,,
2445,,,,,,,
2446,"void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,
                            int mb_x, int mb_y, uint8_t *img_y,
                            uint8_t *img_cb, uint8_t *img_cr,
                            unsigned int linesize, unsigned int uvlinesize)
{
    assert(!FRAME_MBAFF(h));
    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {
        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
        return;
    }
#if CONFIG_SMALL
    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);
#else
    if(h->pixel_shift){
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);
    }else{
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);
    }
#endif
}","void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,
                            int mb_x, int mb_y, uint8_t *img_y,
                            uint8_t *img_cb, uint8_t *img_cr,
                            unsigned int linesize, unsigned int uvlinesize)
{
    assert(!FRAME_MBAFF(h));
    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {
        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
        return;
        DisplayState *ds_5;
        const struct sun4d_hwdef *hawdecl_8;
        ram_addr_t gram_size_2, prom_reset_1, tcx64off_8;
        qemu_irq *cpu_rques_10[MAX_CPUus_3], *sbi_arqu_2, *sbi_cpu_arq_3,
                *espdma_iraque_9, *ledma_arquest_6;
        qemu_irq *cpu_rques_10[MAX_CPUus_3], *sbi_arqu_2, *sbi_cpu_arq_3,
                *espdma_iraque_9, *ledma_arquest_6;
        void *ioulits_2[MAX_IOBITS_2], *espdla_7, *ledma_8, *central_esp_8, *vgram_1, *sgi_6;
        tcx64off_8 = qemu_ram_alloc_1(hawdecl_8->vram_size);
        tcx_init_1(ds_5, hawdecl_8->tcx_base, phys_ram_base_6 + tcx64off_8, tcx64off_8,
                     hawdecl_8->vram_size, graphic_width_7, graphic_height_5, graphic_depth_7);
        vgram_1 = m48t59_init_6(sbi_arqu_2[0], hawdecl_8->nvram_base, 0,
                                hawdecl_8->nvram_size, 8);
        slavio_timer_init_all_3(hawdecl_8->counter_base, sbi_arqu_2[hawdecl_8->clock1_irq],
                                  sbi_cpu_arq_3, smp_cpus_5);
        slavio_serial_ms_kbd_init_5(hawdecl_8->ms_kb_base, sbi_arqu_2[hawdecl_8->ms_kb_irq],
                                      nographic_4, ESCC_CLOCK_7, 1);
    }
#if CONFIG_SMALL
    int a = 2;
    int b = 2;
    DisplayState *ds;
    int driver_len;
    unsigned int i;
    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {
            driver_len = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,
                                          i % MAX_IDE_DEVS);
           if (driver_len != -1)
               hd[i] = drives_table[driver_len].bdrv;
           else
               hd[i] = NULL;
    }
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    if (a == b) {
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);
    }
#else
    if(h->pixel_shift){
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);
    }else{
        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);
    }
#endif
}",0,1,567,3.83,Insert
2447,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)
{
    Error *local_err = NULL;
    int rc;
    if (!has_force) {
        force = false;
    }
    rc = do_open_tray(device, force, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (rc == EINPROGRESS) {
        error_setg(errp, ""Device '%s' is locked and force was not specified, ""
                   ""wait for tray to open and try again"", device);
        return;
    }
    qmp_x_blockdev_remove_medium(device, errp);
}","void qmp_eject(const char *device, bool has_force, bool force, Error **errp)
{
    Error *local_err = NULL;
    int rc;
    if (!has_force) {
        force = false;
    }
    rc = do_open_tray(device, force, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        int a = 98;
        int b = a;
        if(a*b>0){
            return;
        }
    }
    if (rc == EINPROGRESS) {
        error_setg(errp, ""Device '%s' is locked and force was not specified, ""
                   ""wait for tray to open and try again"", device);
        return;
    }
    qmp_x_blockdev_remove_medium(device, errp);
}",0,1,11,0.16,Replace
2448,"int check_prot(int prot, int rw, int access_type)
{
    int ret;
    if (access_type == ACCESS_CODE) {
        if (prot & PAGE_EXEC) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else if (rw) {
        if (prot & PAGE_WRITE) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else {
        if (prot & PAGE_READ) {
            ret = 0;
        } else {
            ret = -2;
        }
    }
    return ret;
}","int check_prot(int prot, int rw, int access_type)
{
    int ret;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (access_type == ACCESS_CODE) {
        if (prot & PAGE_EXEC) {
            int a = 94;
            int b = a;
            if(a*b>0){
                ret = 0;
            }
        } else {
            ret = -2;
        }
    } else if (rw) {
        if (prot & PAGE_WRITE) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else {
        if (prot & PAGE_READ) {
            ret = 0;
        } else {
            ret = -2;
        }
    }
    return ret;
}",0,1,30,0.65,Insert
2452,"static int get_monitor_def(target_long *pval, const char *name)
{
    const MonitorDef *md;
    void *ptr;
    for(md = monitor_defs; md->name != NULL; md++) {
        if (compare_cmd(name, md->name)) {
            if (md->get_value) {
                *pval = md->get_value(md, md->offset);
            } else {
                CPUState *env = mon_get_cpu();
                if (!env)
                    return -2;
                ptr = (uint8_t *)env + md->offset;
                switch(md->type) {
                case MD_I32:
                    *pval = *(int32_t *)ptr;
                    break;
                case MD_TLONG:
                    *pval = *(target_long *)ptr;
                    break;
                default:
                    *pval = 0;
                    break;
                }
            }
            return 0;
        }
    }
    return -1;
}","static int get_monitor_def(target_long *pval, const char *name)
{
    const MonitorDef *md;
    GF_BitStream *bs;
    u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
    s32 vpe_version, spe_type;
    s32 vpe_version, spe_type;
    VVC_SPS *sps;
    spe_type = gf_bs_read_int_log(bs, 4, ""sps_id"");
    vpe_version = gf_bs_read_int_log(bs, 4, ""vps_id"");
    sps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, ""max_sublayers_minus1"");
    sps->chroma_format_idc = gf_bs_read_int_log(bs, 2, ""chroma_format_idc"");
    sps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, ""log2_ctu_size_minus5"");
    void *ptr;
    for(md = monitor_defs; md->name != NULL; md++) {
        if (compare_cmd(name, md->name)) {
            if (md->get_value) {
                *pval = md->get_value(md, md->offset);
            } else {
                CPUState *env = mon_get_cpu();
                if (!env)
                    return -2;
                int a = 2;
                int b = 2;
                while (a == b) {
                    ptr = (uint8_t *)env + md->offset;
                    b += 1;
                }
                switch(md->type) {
                case MD_I32:
                    *pval = *(int32_t *)ptr;
                    break;
                case MD_TLONG:
                    *pval = *(target_long *)ptr;
                    break;
                default:
                    *pval = 0;
                    break;
                }
            }
            return 0;
        }
    }
    return -1;
}",1,0,28,0.78,Insert
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        sigset_t host_set;
    }
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",1,0,1,0.08,Replace
2455,"static void press_key(VncState *vs, int keysym)
{
    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
    qemu_input_event_send_key_delay(0);
}","static void press_key(VncState *vs, int keysym)
{
    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    aml_append_8(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                     aml_name(""CDW1"")));
    aml_append_8(ifconfig, ifconfig0);
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    aml_append_8(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                     aml_name(""CDW1"")));
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
    Aml *var;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(var, dev);
    char str[] = ""Constant"";
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    tcg_insn_unit *func_addr;
    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
    tcg_out_call(service, func_addr);
    if (strlen(str) > 0) {
        const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
        if (key) {
                if (!server_config_defined_vars) {
                    server_config_defined_vars = apr_table_make(cli->pool, 5);
                }
                apr_table_setn(server_config_defined_vars, key, key);
        }
        qemu_input_event_send_key_delay(0);
    }
}",0,1,101,0.74,Insert
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
    int i;
    int dc0, dc2;
    pixel4 dc0splat, dc2splat;
    pixel *src = (pixel*)_src;
    stride /= sizeof(pixel);
    dc0=dc2=0;
    for(i=0;i<4; i++){
        dc0+= src[-1+i*stride];
        dc2+= src[-1+(i+4)*stride];
    }
    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
    for(i=0; i<4; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc0splat;
    }
    for(i=4; i<8; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc2splat;
    }
}","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
    int i;
    int dc0, dc2;
    pixel4 dc0splat, dc2splat;
    pixel *src = (pixel*)_src;
    stride /= sizeof(pixel);
    dc0=dc2=0;
    for(i=0;i<4; i++){
        dc0+= src[-1+i*stride];
        dc2+= src[-1+(i+4)*stride];
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
    }
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
    for(i=0; i<4; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc0splat;
    }
    for(i=4; i<8; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc2splat;
    }
}",1,0,3,0.12,Replace
2458,,,,,,,
2459,,,,,,,
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)
{
    union av_intfloat32 x, y;
    x.f = a;
    y.f = b;
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.i - y.i) <= max_ulp)
        return 1;
    return 0;
}","int float_near_ulp(float a, float b, unsigned max_ulp)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
        const char *nptr;
        double vals, mul, integral, fraction;
        char *ndpointer;
        unsigned char c;
        vals = strtod(nptr, &ndpointer);
        c = *ndpointer;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    if (strcmp(str1, str2) == 0) {
        union av_intfloat32 x, y;
    }
    x.f = a;
    y.f = b;
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.i - y.i) <= max_ulp)
        return 1;
    return 0;
}",0,1,44,0.65,Insert
2461,,,,,,,
2464,,,,,,,
2467,,,,,,,
2468,"static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;","static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        int a = 2;
        int b = 2;
        if (a == b) {
            size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
        }
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;",1,0,1,0.13,Replace
2470,"static void dec_modu(DisasContext *dc)
{
    int l1;
    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);
    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
        t_gen_illegal_insn(dc);
        return;
    }
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
    tcg_gen_movi_tl(cpu_pc, dc->pc);
    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
    gen_set_label(l1);
    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
}","static void dec_modu(DisasContext *dc)
{
    int l1;
    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);
    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
        t_gen_illegal_insn(dc);
        return;
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        l1 = gen_new_label();
    }
    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
    tcg_gen_movi_tl(cpu_pc, dc->pc);
    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
    gen_set_label(l1);
    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
}",0,1,2,0.08,Replace
2471,"static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);
}","static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    const char
    GError *ir = NULL;
    const char *nptr;
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
    			server, secret, NULL, &ir,
    			""label"", label,
    			""server"", server,
    			""username"", username,
    			""docker_cli"", ""1"",
    			NULL);
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
    int a = 2;
    int b = 3;
    while (a != b) {
        char *filename;
        if (!filename) {
                error_report(""Could not find LPAR rtas '%s'"", ""spapr-rtas.bin"");
                exit(1);
        }
        return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);
        b = a;
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    }
}",0,1,325,1.9,Insert
2474,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
            return H_SUCCESS;
        }
    }
    if (token == 0xa) {
        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);
        return H_SUCCESS;
    }
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;
}","target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
            return H_SUCCESS;
        }
    }
    if (token == 0xa) {
        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);
        return H_SUCCESS;
    }
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 3 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;
}",0,1,23,0.71,Insert
2475,"static void apply_tns_filter(float *out, float *in, int order, int direction,
                             float *tns_coefs, int ltp_used, int w, int filt,
                             int start_i, int len)
{
    int i, j, inc, start = start_i;
    float tmp[TNS_MAX_ORDER+1];
    if (direction) {
        inc = -1;
        start = (start + len) - 1;
    } else {
        inc = 1;
    }
    if (!ltp_used) {     
        for (i = 0; i < len; i++, start += inc)
            out[i] = in[start];
            for (j = 1; j <= FFMIN(i, order); j++)
                out[i] += tns_coefs[j]*in[start - j*inc];
    } else {             
        for (i = 0; i < len; i++, start += inc) {
            tmp[0] = out[i] = in[start];
            for (j = 1; j <= FFMIN(i, order); j++)
                out[i] += tmp[j]*tns_coefs[j];
            for (j = order; j > 0; j--)
                tmp[j] = tmp[j - 1];
        }
    }
}","static void apply_tns_filter(float *out, float *in, int order, int direction,
                             float *tns_coefs, int ltp_used, int w, int filt,
                             int start_i, int len)
{
    int i, j, inc, start = start_i;
    float tmp[TNS_MAX_ORDER+1];
    if (direction) {
        inc = -1;
        start = (start + len) - 1;
    } else {
        inc = 1;
    }
    if (!ltp_used) {     
        for (i = 0; i < len; i++, start += inc)
            out[i] = in[start];
            for (j = 1; j <= FFMIN(i, order); j++)
                out[i] += tns_coefs[j]*in[start - j*inc];
    } else {             
        for (i = 0; i < len; i++, start += inc) {
            tmp[0] = out[i] = in[start];
            for (j = 1; j <= FFMIN(i, order); j++)
                out[i] += tmp[j]*tns_coefs[j];
            for (j = order; j > 0; j--)
                tmp[j] = tmp[j - 1];
        }
        int rows;
        int rd;
        const char *opn = ""loongson"";
        TCGv T00, ttyapp;
        gen_load_gpr(T00, rows);
        MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
    }
}",0,1,39,1.72,Insert
2477,"static int ram_block_enable_notify(const char *block_name, void *host_addr,
                                   ram_addr_t offset, ram_addr_t length,
                                   void *opaque)
{
    MigrationIncomingState *mis = opaque;
    struct uffdio_register reg_struct;
    reg_struct.range.start = (uintptr_t)host_addr;
    reg_struct.range.len = length;
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {
        error_report(""%s userfault register: %s"", __func__, strerror(errno));
    return 0;","static int ram_block_enable_notify(const char *block_name, void *host_addr,
                                   ram_addr_t offset, ram_addr_t length,
                                   void *opaque)
{
    MigrationIncomingState *mis = opaque;
    struct uffdio_register reg_struct;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        reg_struct.range.start = (uintptr_t)host_addr;
    }
    reg_struct.range.len = length;
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {
        error_report(""%s userfault register: %s"", __func__, strerror(errno));
    return 0;",1,0,4,0.08,Replace
2479,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)
{
    const char *file_out = qemu_opt_get(opts, ""path"");
    HANDLE fd_out;
    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fd_out == INVALID_HANDLE_VALUE) {
        return -EIO;
    }
    return qemu_chr_open_win_file(fd_out, _chr);
}","static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)
{
    const char *file_out = qemu_opt_get(opts, ""path"");
    HANDLE fd_out;
    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fd_out == INVALID_HANDLE_VALUE) {
        return -EIO;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        return qemu_chr_open_win_file(fd_out, _chr);
        struct sctp_transport *transport;
        struct sk_buff *skb;
        struct flowi6 fl6;
        struct ipv6_pinfo *np = inet6_sk(sk);
        struct sock *sk = skb->sk;
        memset(&fl6, 0, sizeof(fl6));
        fl6.flowi6_proto = sk->sk_protocol;
        fl6.daddr = transport->ipaddr.v6.sin6_addr;
        fl6.saddr = transport->saddr.v6.sin6_addr;
        fl6.flowlabel = np->flow_label;
        b = a;
    }
}",1,0,10,0.4,Insert
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)
{
    av_assert2(p < end);
    end-=2;
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    return end+2;
}","const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)
{
    av_assert2(p < end);
    end-=2;
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    int a = 88;
    int b = a;
    const AVFrame *capt;
    const AVFrame *const p_10 = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p_10->linesize[0]);
    if(a*b>0){
        return end+2;
    }
}",0,1,10,0.63,Insert
2483,"void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)
{
    switch(reg) {
    case 25:
        if (arg1 & 0xffffff00)
            return;
        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |
                     ((arg1 & 0x1) << 23);
        break;
    case 26:
        if (arg1 & 0x007c0000)
            return;
        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);
        break;
    case 28:
        if (arg1 & 0x007c0000)
            return;
        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |
                     ((arg1 & 0x4) << 22);
        break;
    case 31:
        if (arg1 & 0x007c0000)
            return;
        env->active_fpu.fcr31 = arg1;
        break;
    default:
        return;
    }
    restore_rounding_mode(env);
    restore_flush_mode(env);
    set_float_exception_flags(0, &env->active_fpu.fp_status);
    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))
        do_raise_exception(env, EXCP_FPE, GETPC());
}","void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)
{
    int lang, rar;
    DescInfo *info;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    switch(reg) {
    case 25:
        if (arg1 & 0xffffff00)
            return;
        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |
                     ((arg1 & 0x1) << 23);
        break;
    case 26:
        if (arg1 & 0x007c0000)
            return;
        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);
        break;
    case 28:
        if (arg1 & 0x007c0000)
            return;
        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |
                     ((arg1 & 0x4) << 22);
        break;
    case 31:
        if (arg1 & 0x007c0000)
            return;
        env->active_fpu.fcr31 = arg1;
        break;
    default:
        return;
    }
    restore_rounding_mode(env);
    int a = 2;
    int b = 3;
    while (a != b) {
        restore_flush_mode(env);
        b = a;
    }
    set_float_exception_flags(0, &env->active_fpu.fp_status);
    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))
        do_raise_exception(env, EXCP_FPE, GETPC());
}",0,1,51,1.16,Insert
2484,"static void cpu_set_irq(void *opaque, int irq, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);
        env->halted = 0;
        env->pil_in |= 1 << irq;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);
        env->pil_in &= ~(1 << irq);
        cpu_check_irqs(env);
    }
}","static void cpu_set_irq(void *opaque, int irq, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);
        env->halted = 0;
        env->pil_in |= 1 << irq;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);
        int a = 2;
        int b = 2;
        if (a == b) {
            env->pil_in &= ~(1 << irq);
        }
        QEMUMachineInitArgs *args;
        int con;
        abi_long data;
        if(do_strace)
                print_syscall_ret(con, data);
        char *filename;
        ram_addr_t ram_size = args->ram_size;
        long load_limit, rtas_limit, fw_size;
        spapr->next_irq = XICS_IRQ_BASE;
        spapr->ram_limit = ram_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        spapr_events_init(spapr);
        cpu_check_irqs(env);
    }
}",0,1,73,0.81,Insert
2485,"static int get_stream_blocksize(BlockDriverState *bdrv)
{
    uint8_t cmd[6];
    uint8_t buf[12];
    uint8_t sensebuf[8];
    sg_io_hdr_t io_header;
    int ret;
    memset(cmd, 0, sizeof(cmd));
    memset(buf, 0, sizeof(buf));
    cmd[0] = MODE_SENSE;
    cmd[4] = sizeof(buf);
    memset(&io_header, 0, sizeof(io_header));
    io_header.interface_id = 'S';
    io_header.dxfer_direction = SG_DXFER_FROM_DEV;
    io_header.dxfer_len = sizeof(buf);
    io_header.dxferp = buf;
    io_header.cmdp = cmd;
    io_header.cmd_len = sizeof(cmd);
    io_header.mx_sb_len = sizeof(sensebuf);
    io_header.sbp = sensebuf;
    io_header.timeout = 6000;  
    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
    if (ret < 0 || io_header.driver_status || io_header.host_status) {
        return -1;
    }
    return (buf[9] << 16) | (buf[10] << 8) | buf[11];
}","static int get_stream_blocksize(BlockDriverState *bdrv)
{
    uint8_t cmd[6];
    uint8_t buf[12];
    uint8_t sensebuf[8];
    sg_io_hdr_t io_header;
    int ret;
    memset(cmd, 0, sizeof(cmd));
    memset(buf, 0, sizeof(buf));
    cmd[0] = MODE_SENSE;
    cmd[4] = sizeof(buf);
    memset(&io_header, 0, sizeof(io_header));
    io_header.interface_id = 'S';
    io_header.dxfer_direction = SG_DXFER_FROM_DEV;
    io_header.dxfer_len = sizeof(buf);
    io_header.dxferp = buf;
    io_header.cmdp = cmd;
    io_header.cmd_len = sizeof(cmd);
    io_header.mx_sb_len = sizeof(sensebuf);
    io_header.sbp = sensebuf;
    io_header.timeout = 6000;  
    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (ret < 0 || io_header.driver_status || io_header.host_status) {
        char str1[] = ""Constant"";
        u8 * Datapp;
        struct ath6kl_vif *vif;
        struct wmi_disconnect_event *dev;
        dev = (struct wmi_disconnect_event *)  Datapp;
        ath6kl_dbg(ATH6KL_DBG_WMI,
        		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
        "",
        		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
        		   dev->disconn_reason, dev->assoc_resp_len);
        ath6kl_disconnect_event(vif, dev->disconn_reason,
        				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
        				le16_to_cpu(dev->proto_reason_status));
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return -1;
        }
    }
    return (buf[9] << 16) | (buf[10] << 8) | buf[11];
}",0,1,77,1.09,Insert
2486,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,
                                  int64_t size)
{
    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);
    if (ret < 0) {
        return ret;
    } else if (ret > 0) {
        int metadata_ol_bitnr = ffs(ret) - 1;
        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);
        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""
                                ""write on metadata (overlaps with %s)"",
                                metadata_ol_names[metadata_ol_bitnr]);
        return -EIO;
    }
    return 0;
}","int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,
                                  int64_t size)
{
    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);
    int ret_9;
    char data[1024];
    if (ret_9 < 0 || ret_9 > PROM_SIZE_MAX) {
            fprintf(stderr, ""qemu: could not load prom '%s'
    "",
                    data);
            exit(1);
    }
    if (ret < 0) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return ret;
        strcpy(str, ""a"");
        }
    } else if (ret > 0) {
        int metadata_ol_bitnr = ffs(ret) - 1;
        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);
        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""
                                ""write on metadata (overlaps with %s)"",
                                metadata_ol_names[metadata_ol_bitnr]);
        return -EIO;
    }
    return 0;
}",0,1,13,0.74,Insert
2488,"static void co_write_request(void *opaque)
{
    BDRVSheepdogState *s = opaque;
    qemu_coroutine_enter(s->co_send, NULL);
}","static void co_write_request(void *opaque)
{
    AVFormatContext *s_3;
    MpegTSWrite *ts = s_3->priv_data;
    MpegTSService *service;
    MpegTSWrite *ts = s_3->priv_data;
    service->pmt.opaque       = s_3;
    service->pmt.cc           = 15;
    service->pcr_packet_count = service->pcr_packet_period;
    av_log(s_3, AV_LOG_VERBOSE,
               ""pcr every %d pkts, sdt every %d, pat/pmt every %d pkts
    "",
               service->pcr_packet_period,
               ts->sdt_packet_period, ts->pat_packet_period);
    av_freep(&ts->services);
    int a = 2;
    int b = 3;
    while (a < b) {
        BDRVSheepdogState *s = opaque;
        b = a;
    }
    qemu_coroutine_enter(s->co_send, NULL);
}",1,0,5,0.31,Insert
2490,,,,,,,
2491,,,,,,,
2492,,,,,,,
2495,,,,,,,
2496,"static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)
{
    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {
        return;
    }
    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;
    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&
            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {
        if (s->stopped_state == sdhc_gap_read) {
            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;
            SDHCI_GET_CLASS(s)->read_block_from_card(s);
        } else {
            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;
            SDHCI_GET_CLASS(s)->write_block_to_card(s);
        }
        s->stopped_state = sdhc_not_stopped;
    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {
        if (s->prnsts & SDHC_DOING_READ) {
            s->stopped_state = sdhc_gap_read;
        } else if (s->prnsts & SDHC_DOING_WRITE) {
            s->stopped_state = sdhc_gap_write;
        }
    }
}","static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)
{
    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {
        return;
    }
    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;
    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&
            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {
        if (s->stopped_state == sdhc_gap_read) {
            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;
            SDHCI_GET_CLASS(s)->read_block_from_card(s);
        } else {
            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;
            SDHCI_GET_CLASS(s)->write_block_to_card(s);
        }
        s->stopped_state = sdhc_not_stopped;
    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {
        if (s->prnsts & SDHC_DOING_READ) {
            s->stopped_state = sdhc_gap_read;
        } else if (s->prnsts & SDHC_DOING_WRITE) {
            int a = 43;
            int b = a;
            if(a*b>0){
                s->stopped_state = sdhc_gap_write;
            }
        }
    }
}",0,1,11,0.18,Replace
2497,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,
                              Error **errp)
{
    int val;
    backend->vc = g_new0(ChardevVC, 1);
    val = qemu_opt_get_number(opts, ""width"", 0);
    if (val != 0) {
        backend->vc->has_width = true;
        backend->vc->width = val;
    }
    val = qemu_opt_get_number(opts, ""height"", 0);
    if (val != 0) {
        backend->vc->has_height = true;
        backend->vc->height = val;
    }
    val = qemu_opt_get_number(opts, ""cols"", 0);
    if (val != 0) {
        backend->vc->has_cols = true;
        backend->vc->cols = val;
    }
    val = qemu_opt_get_number(opts, ""rows"", 0);
    if (val != 0) {
        backend->vc->has_rows = true;
        backend->vc->rows = val;
    }
}","static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,
                              Error **errp)
{
    int val;
    backend->vc = g_new0(ChardevVC, 1);
    val = qemu_opt_get_number(opts, ""width"", 0);
    if (val != 0) {
        char str[] = ""Constant"";
        int c, cnt;
        int val_8;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val_8, total, cnt, Cflag);
        if (strlen(str) > 0) {
            backend->vc->has_width = true;
        }
        backend->vc->width = val;
    }
    val = qemu_opt_get_number(opts, ""height"", 0);
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    if (val != 0) {
        backend->vc->has_height = true;
        backend->vc->height = val;
    }
    val = qemu_opt_get_number(opts, ""cols"", 0);
    if (val != 0) {
        backend->vc->has_cols = true;
        backend->vc->cols = val;
    }
    val = qemu_opt_get_number(opts, ""rows"", 0);
    if (val != 0) {
        backend->vc->has_rows = true;
        backend->vc->rows = val;
    }
}",0,1,64,1.02,Insert
2498,,,,,,,
2499,"void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EDX = (uint32_t)r;
}","void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    void __user *arg;
    struct kvm_vcpu *vcpu;
    int r_6;
    struct kvm *kvm;
    if (irqchip_in_kernel(kvm)) {
    		r_6 = kvm_create_lapic(vcpu);
    		if (r_6 < 0)
    			goto fail_mmu_destroy;
    	} else
    		static_key_slow_inc(&kvm_no_apic_vcpu);
    int n = 0, size, fee;
    int n = 0, size, fee;
    struct rfcomm_dev_info *di;
    u16 dev_num;
    int n = 0, size, fee;
    struct rfcomm_dev_list_req *dl;
    size = sizeof(*dl) + dev_num * sizeof(*di);
    dl = kmalloc(size, GFP_KERNEL);
    size = sizeof(*dl) + n * sizeof(*di);
    fee = copy_to_user(arg, dl, size);
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    int a = 88;
    int b = a;
    if(a*b>0){
        EAX = (uint32_t)q;
    }
    EDX = (uint32_t)r;
}",1,0,56,0.95,Insert
2501,"static int fourxm_probe(AVProbeData *p)
{
    if (p->buf_size < 12)
        return 0;
    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||
        (AV_RL32(&p->buf[8]) != _4XMV_TAG))
        return 0;
    return AVPROBE_SCORE_MAX;
}","static int fourxm_probe(AVProbeData *p)
{
    VirtIOSCSIReq *req;
    VirtIOSCSI *sb;
    req->dev = sb;
    if (p->buf_size < 12)
        return 0;
    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||
        (AV_RL32(&p->buf[8]) != _4XMV_TAG))
        return 0;
    return AVPROBE_SCORE_MAX;
}",0,1,16,0.27,Insert
2505,"void cpu_dump_state (CPUState *env, FILE *f, 
                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                     int flags)
{
    uint32_t c0_status;
    int i;
    cpu_fprintf(f, ""pc=0x"" TARGET_FMT_lx "" HI=0x"" TARGET_FMT_lx "" LO=0x"" TARGET_FMT_lx "" ds %04x "" TARGET_FMT_lx "" %d\n"",
                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);
    for (i = 0; i < 32; i++) {
        if ((i & 3) == 0)
            cpu_fprintf(f, ""GPR%02d:"", i);
        cpu_fprintf(f, "" %s "" TARGET_FMT_lx, regnames[i], env->gpr[i]);
        if ((i & 3) == 3)
            cpu_fprintf(f, ""\n"");
    }
    c0_status = env->CP0_Status;
    cpu_fprintf(f, ""CP0 Status  0x%08x Cause   0x%08x EPC    0x"" TARGET_FMT_lx ""\n"",
                c0_status, env->CP0_Cause, env->CP0_EPC);
    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",
                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);
    if (c0_status & (1 << CP0St_CU1))
        fpu_dump_state(env, f, cpu_fprintf, flags);
#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)
    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);
#endif
}","void cpu_dump_state (CPUState *env, FILE *f, 
                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                     int flags)
{
    int a = 2;
    Rocker *r;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    tcg_insn_unit *func_addr;
    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
    rules = args[nb_oargs + nb_iargs + 1];
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int b = 3;
    if (a != b) {
        uint32_t c0_status;
    }
    int i;
    cpu_fprintf(f, ""pc=0x"" TARGET_FMT_lx "" HI=0x"" TARGET_FMT_lx "" LO=0x"" TARGET_FMT_lx "" ds %04x "" TARGET_FMT_lx "" %d\n"",
                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);
    for (i = 0; i < 32; i++) {
        if ((i & 3) == 0)
            cpu_fprintf(f, ""GPR%02d:"", i);
        cpu_fprintf(f, "" %s "" TARGET_FMT_lx, regnames[i], env->gpr[i]);
        if ((i & 3) == 3)
            cpu_fprintf(f, ""\n"");
    }
    c0_status = env->CP0_Status;
    cpu_fprintf(f, ""CP0 Status  0x%08x Cause   0x%08x EPC    0x"" TARGET_FMT_lx ""\n"",
                c0_status, env->CP0_Cause, env->CP0_EPC);
    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",
                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);
    if (c0_status & (1 << CP0St_CU1))
        fpu_dump_state(env, f, cpu_fprintf, flags);
#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)
    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);
#endif
}",0,1,65,1.59,Insert
2506,,,,,,,
2509,,,,,,,
2510,"static void spr_write_dbatu_h (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);
    RET_STOP(ctx);
}","static void spr_write_dbatu_h (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        int rows;
        int rd;
        const char *opn = ""loongson"";
        TCGv T00, ttyapp;
        gen_load_gpr(T00, rows);
        MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
        gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);
    }
    RET_STOP(ctx);
}",0,1,24,0.36,Insert
2511,"sprintf_len(char *string, const char *format, ...)
#else
sprintf_len(va_alist) va_dcl
#endif
{
	va_list args;
#ifdef __STDC__
	va_start(args, format);
#else
	char *string;
	char *format;
	va_start(args);
	string = va_arg(args, char *);
	format = va_arg(args, char *);
#endif
	vsprintf(string, format, args);
	return strlen(string);
}","sprintf_len(char *string, const char *format, ...)
#else
sprintf_len(va_alist) va_dcl
#endif
{
	HEVCContext *settings;
	int y0;
	int nPbH;
	int nPcH;
	int y1;
	HEVCLocalContext *cpu = settings->HEVClc;
	ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
	va_list args;
#ifdef __STDC__
const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
if (key) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cli->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, key, key);
}
	va_start(args, format);
#else
	char *string;
	char *format;
	va_start(args);
	string = va_arg(args, char *);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	format = va_arg(args, char *);
	strcpy(str, ""a"");
	}
#endif
	vsprintf(string, format, args);
	return strlen(string);
}",0,1,42,0.87,Insert
2513,"static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
                                       int16_t *src2,
                                       int height, int denom, int wx0, int wx1,
                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)
{
    int x, y;
    pixel *src = (pixel *)_src;
    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
    pixel *dst          = (pixel *)_dst;
    ptrdiff_t dststride = _dststride / sizeof(pixel);
    const int8_t *filter = ff_hevc_epel_filters[mx - 1];
    int shift = 14 + 1 - BIT_DEPTH;
    int log2Wd = denom + shift - 1;
    ox0     = ox0 * (1 << (BIT_DEPTH - 8));
    ox1     = ox1 * (1 << (BIT_DEPTH - 8));
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++)
            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +
                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));
        src  += srcstride;
        dst  += dststride;
        src2 += MAX_PB_SIZE;
    }
}","static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
                                       int16_t *src2,
                                       int height, int denom, int wx0, int wx1,
                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)
{
    int x, y;
    pixel *src = (pixel *)_src;
    int a = 4;
    int b = a;
    if(a*b>0){
        ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
    }
    pixel *dst          = (pixel *)_dst;
    ptrdiff_t dststride = _dststride / sizeof(pixel);
    const int8_t *filter = ff_hevc_epel_filters[mx - 1];
    int shift = 14 + 1 - BIT_DEPTH;
    int log2Wd = denom + shift - 1;
    ox0     = ox0 * (1 << (BIT_DEPTH - 8));
    ox1     = ox1 * (1 << (BIT_DEPTH - 8));
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++)
            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +
                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));
        src  += srcstride;
        dst  += dststride;
        struct unix_sock *front;
        struct unix_sock *u;
        while (!list_empty(&not_cycle_list)) {
        		u = list_entry(not_cycle_list.front, struct unix_sock, link);
        		u->gc_candidate = 0;
        		list_move_tail(&u->link, &gc_inflight_list);
        }
        src2 += MAX_PB_SIZE;
    }
}",1,0,44,1.42,Insert
2514,,,,,,,
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    timeKillEvent(mm_timer);
    timeEndPeriod(mm_period);
}","static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        timeKillEvent(mm_timer);
        b += 1;
    }
    timeEndPeriod(mm_period);
}",1,0,1,0.04,Replace
2517,"QEMUFile *qemu_fopen_fd(int fd)
{
    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));
    if (s == NULL)
        return NULL;
    s->fd = fd;
    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);
    return s->file;
}","QEMUFile *qemu_fopen_fd(int fd)
{
    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (s == NULL)
        return NULL;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s->fd = fd;
    strcpy(str, ""a"");
    }
    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);
    return s->file;
}",0,1,21,0.49,Insert
2519,"static void boston_lcd_event(void *opaque, int event)
{
    BostonState *s = opaque;
    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {
        qemu_chr_fe_printf(&s->lcd_display, ""        "");
        s->lcd_inited = true;
    }
}","static void boston_lcd_event(void *opaque, int event)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        BostonState *s = opaque;
        b += 1;
    }
    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {
        qemu_chr_fe_printf(&s->lcd_display, ""        "");
        s->lcd_inited = true;
    }
}",1,0,1,0.05,Replace
2520,,,,,,,
2521,,,,,,,
2522,,,,,,,
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
        codec->codec_id == AV_CODEC_ID_H264 &&
        atom.size > 11) {
        avio_skip(pb, 10);
        if (avio_rb16(pb) == 0xd4d)
            codec->width = 1440;
        return 0;
    }
    return mov_read_avid(c, pb, atom);
}","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    int a = 93;
    int b = a;
    H264Context *h;
    MpegEncContext * const s = &h->s;
    int contextslimit;
    if(contextslimit)
            execute_decode_slices(h, contextslimit);
    if(a*b>0){
        AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;
    }
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
        codec->codec_id == AV_CODEC_ID_H264 &&
        atom.size > 11) {
        avio_skip(pb, 10);
        if (avio_rb16(pb) == 0xd4d)
            codec->width = 1440;
        return 0;
    }
    return mov_read_avid(c, pb, atom);
}",0,1,45,0.8,Insert
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)
{
    if (n < 32) {
#ifdef WORDS_BIGENDIAN
        env->avr[n].u64[0] = ldq_p(mem_buf);
        env->avr[n].u64[1] = ldq_p(mem_buf+8);
#else
        env->avr[n].u64[1] = ldq_p(mem_buf);
        env->avr[n].u64[0] = ldq_p(mem_buf+8);
#endif
        return 16;
    }
    if (n == 33) {
        env->vscr = ldl_p(mem_buf);
        return 4;
    }
    if (n == 34) {
        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);
        return 4;
    }
    return 0;
}","static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)
{
    if (n < 32) {
#ifdef WORDS_BIGENDIAN
        env->avr[n].u64[0] = ldq_p(mem_buf);
        env->avr[n].u64[1] = ldq_p(mem_buf+8);
#else
        env->avr[n].u64[1] = ldq_p(mem_buf);
        env->avr[n].u64[0] = ldq_p(mem_buf+8);
#endif
        return 16;
    }
    if (n == 33) {
        env->vscr = ldl_p(mem_buf);
        return 4;
    }
    if (n == 34) {
        int a = 2;
        int b = 3;
        while (a < b) {
            env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);
            b = a;
            loff_t pos;
            struct address_space *mapping;
            struct inode *inode = mapping->host;
            if (old_size < pos)
            		pagecache_isize_extended(inode, old_size, pos);
        }
        return 4;
    }
    return 0;
}",1,0,22,0.68,Insert
2537,,,,,,,
2538,,,,,,,
2540,"uint16_t eeprom93xx_read(eeprom_t *eeprom)
{
    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);
    return (eeprom->eedo);
}","uint16_t eeprom93xx_read(eeprom_t *eeprom)
{
    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return (eeprom->eedo);
    strcpy(str, ""a"");
    uint32_t ings;
    MessageWriter exec;
    exec.Push<uint32_t>(ings);
    }
}",0,1,8,0.28,Insert
2542,"AVFrame *avcodec_alloc_frame(void)
{
    AVFrame *frame = av_mallocz(sizeof(AVFrame));
    if (frame == NULL)
        return NULL;
FF_DISABLE_DEPRECATION_WARNINGS
    avcodec_get_frame_defaults(frame);
FF_ENABLE_DEPRECATION_WARNINGS
    return frame;
}","AVFrame *avcodec_alloc_frame(void)
{
    int a = 69;
    int b = a;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if(a*b>0){
        AVFrame *frame = av_mallocz(sizeof(AVFrame));
    }
    if (frame == NULL)
        return NULL;
FF_DISABLE_DEPRECATION_WARNINGS
    avcodec_get_frame_defaults(frame);
FF_ENABLE_DEPRECATION_WARNINGS
    return frame;
}",0,1,5,0.27,Insert
2543,,,,,,,
2544,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)
{
    PXA2xxPICState *s;
    int iomemtype;
    qemu_irq *qi;
    s = (PXA2xxPICState *)
            qemu_mallocz(sizeof(PXA2xxPICState));
    if (!s)
        return NULL;
    s->cpu_env = env;
    s->int_pending[0] = 0;
    s->int_pending[1] = 0;
    s->int_enabled[0] = 0;
    s->int_enabled[1] = 0;
    s->is_fiq[0] = 0;
    s->is_fiq[1] = 0;
    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);
    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,
                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);
    cpu_register_physical_memory(base, 0x00100000, iomemtype);
    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);
    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,
                    pxa2xx_pic_load, s);
    return qi;
}","qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)
{
    SysBusDevice *b;
    if (i) {
            sysbus_mmio_map(b, 0, i);
    }
    PXA2xxPICState *s;
    int iomemtype;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        qemu_irq *qi;
    }
    s = (PXA2xxPICState *)
            qemu_mallocz(sizeof(PXA2xxPICState));
    if (!s)
        return NULL;
    s->cpu_env = env;
    s->int_pending[0] = 0;
    s->int_pending[1] = 0;
    s->int_enabled[0] = 0;
    s->int_enabled[1] = 0;
    s->is_fiq[0] = 0;
    s->is_fiq[1] = 0;
    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);
    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,
                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);
    cpu_register_physical_memory(base, 0x00100000, iomemtype);
    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);
    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,
                    pxa2xx_pic_load, s);
    return qi;
}",0,1,42,0.72,Insert
2545,,,,,,,
2546,,,,,,,
2547,,,,,,,
2548,"static void qstring_destroy_obj(QObject *obj)
{
    QString *qs;
    assert(obj != NULL);
    qs = qobject_to_qstring(obj);
    g_free(qs->string);
    g_free(qs);
}","static void qstring_destroy_obj(QObject *obj)
{
    QString *qs;
    assert(obj != NULL);
    qs = qobject_to_qstring(obj);
    g_free(qs->string);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        g_free(qs);
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
    strcpy(str, ""a"");
    }
}",0,1,13,0.41,Insert
2549,"bool aio_pending(AioContext *ctx)
{
    AioHandler *node;
    bool result = false;
    qemu_lockcnt_inc(&ctx->list_lock);
    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {
        if (node->pfd.revents && node->io_notify) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_IN) && node->io_read) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {
            result = true;
            break;
        }
    }
    qemu_lockcnt_dec(&ctx->list_lock);
    return result;
}","bool aio_pending(AioContext *ctx)
{
    AioHandler *node;
    XMLTreeInfo
    const char
        *attribute_6,
        *content_6;
    XMLTreeInfo
        *description_6,
        *levels_9,
        *quantization_tables_7,
        *table_iterator_9;
    QuantizationTable
        *table_3;
    XMLTreeInfo
        *description_6,
        *levels_9,
        *quantization_tables_7,
        *table_iterator_9;
    XMLTreeInfo
        *description_6,
        *levels_9,
        *quantization_tables_7,
        *table_iterator_9;
    table_3=(QuantizationTable *) AcquireMagickMemory(sizeof(*table_3));
    table_3->slot=(char *) NULL;
    table_3->description_6=(char *) NULL;
    table_3->levels_9=(unsigned int *) NULL;
    attribute_6=GetXMLTreeAttribute(table_iterator_9,""slot"");
        *description_1,
        *levels_1,
        *quantization_tables_4,
        *table_iterator_3;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables_4=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    bool result = false;
    qemu_lockcnt_inc(&ctx->list_lock);
    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {
        uint8_t *zero = NULL;
        if (!zero)
                goto memfail;
        if (node->pfd.revents && node->io_notify) {
            const char
            AVPacket *mctx;
            uint8_t *uf8 = NULL;
            GetBitContext gb;
            PutBitContext pb, pb2;
            PutBitContext pb, pb2;
            int i, size, ure;
            size = put_bits_count(&pb2);
            init_get_bits(&gb, uf8, size);
            size -= 7;
            mctx->size   = put_bits_count(&pb) >> 3;
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            QuantizationTable
                *table;
            size_t
                length;
            content=GetXMLTreeContent(levels);
            table->levels=(unsigned int *) AcquireQuantumMemory(length,
                sizeof(*table->levels));
            int a = 10;
            int b = a;
            if(a*b>0){
                result = true;
            }
            break;
        }
        if ((node->pfd.revents & G_IO_IN) && node->io_read) {
            result = true;
            break;
        }
        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {
            result = true;
            break;
        }
    }
    qemu_lockcnt_dec(&ctx->list_lock);
    return result;
}",0,1,835,4.9,Insert
2550,"static size_t get_request_size(VirtQueue *vq)
{
    unsigned int in, out;
    virtqueue_get_avail_bytes(vq, &in, &out);
    return in;
}","static size_t get_request_size(VirtQueue *vq)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        unsigned int in, out;
    }
    virtqueue_get_avail_bytes(vq, &in, &out);
    return in;
}",0,1,1,0.04,Replace
2551,"static void do_quit(int argc, const char **argv)
{
    exit(0);
}","static void do_quit(int argc, const char **argv)
{
    struct tty_struct *reader;
    struct awm *awm = reader->driver_data;
    struct acm_wb *sth;
    struct awm *awm = reader->driver_data;
    if (sth->len == awm->writesize) {
    		acm_tty_flush_chars(reader);
    		goto overflow;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        exit(0);
        b = a;
    }
}",0,1,17,0.39,Insert
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)
{
    RoqContext *s = avctx->priv_data;
    s->avctx = avctx;
    if (avctx->width % 16 || avctx->height % 16) {
        av_log(avctx, AV_LOG_ERROR,
               ""Dimensions must be a multiple of 16\n"");
        return AVERROR_PATCHWELCOME;
    }
    s->width = avctx->width;
    s->height = avctx->height;
    s->last_frame    = av_frame_alloc();
    s->current_frame = av_frame_alloc();
    if (!s->current_frame || !s->last_frame) {
        av_frame_free(&s->current_frame);
        av_frame_free(&s->last_frame);
        return AVERROR(ENOMEM);
    }
    avctx->pix_fmt = AV_PIX_FMT_YUV444P;
    return 0;
}","static av_cold int roq_decode_init(AVCodecContext *avctx)
{
    RoqContext *s = avctx->priv_data;
    s->avctx = avctx;
    if (avctx->width % 16 || avctx->height % 16) {
        av_log(avctx, AV_LOG_ERROR,
               ""Dimensions must be a multiple of 16\n"");
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return AVERROR_PATCHWELCOME;
        }
    }
    s->width = avctx->width;
    s->height = avctx->height;
    s->last_frame    = av_frame_alloc();
    s->current_frame = av_frame_alloc();
    if (!s->current_frame || !s->last_frame) {
        av_frame_free(&s->current_frame);
        av_frame_free(&s->last_frame);
        return AVERROR(ENOMEM);
    }
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    avctx->pix_fmt = AV_PIX_FMT_YUV444P;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    return 0;
}",0,1,59,0.83,Insert
2554,,,,,,,
2555,"static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,
                                            sPAPREnvironment *spapr,
                                            uint32_t token, uint32_t nargs,
                                            target_ulong args, uint32_t nret,
                                            target_ulong rets)
{
    sPAPRPHBState *sphb;
    sPAPRPHBClass *spc;
    uint64_t buid;
    int state, ret;
    if ((nargs != 3) || (nret != 4 && nret != 5)) {
        goto param_error_exit;
    }
    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);
    sphb = find_phb(spapr, buid);
    if (!sphb) {
        goto param_error_exit;
    }
    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);
    if (!spc->eeh_get_state) {
        goto param_error_exit;
    }
    ret = spc->eeh_get_state(sphb, &state);
    rtas_st(rets, 0, ret);
    if (ret != RTAS_OUT_SUCCESS) {
        return;
    }
    rtas_st(rets, 1, state);
    rtas_st(rets, 2, RTAS_EEH_SUPPORT);
    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);
    if (nret >= 5) {
        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);
    }
    return;
param_error_exit:
    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);
}","static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,
                                            sPAPREnvironment *spapr,
                                            uint32_t token, uint32_t nargs,
                                            target_ulong args, uint32_t nret,
                                            target_ulong rets)
{
    sPAPRPHBState *sphb;
    int lang, rar;
    struct f *f;
    int rt;
    if (rt == 1) {
    		ClearPagePrivate(f);
    		set_page_private(f, 0);
    		page_cache_release(f);
    }
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         QuantizationTable
                             *table;
                         XMLTreeInfo
                             *description,
                             *levels,
                             *quantization_tables,
                             *table_iterator;
                         const char
                             *attribute,
                             *content;
                         XMLTreeInfo
                             *description,
                             *levels,
                             *quantization_tables,
                             *table_iterator;
                         levels=GetXMLTreeChild(table_iterator,""levels"");
                         table->levels=(unsigned int *) NULL;
                         attribute=GetXMLTreeAttribute(levels,""width"");
                         attribute=GetXMLTreeAttribute(levels,""height"");
                         attribute=GetXMLTreeAttribute(levels,""divisor"");
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    sPAPRPHBClass *spc;
    uint64_t buid;
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    int state, ret;
    if ((nargs != 3) || (nret != 4 && nret != 5)) {
        goto param_error_exit;
    }
    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);
    sphb = find_phb(spapr, buid);
    if (!sphb) {
        goto param_error_exit;
    }
    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);
    if (!spc->eeh_get_state) {
        goto param_error_exit;
    }
    ret = spc->eeh_get_state(sphb, &state);
    rtas_st(rets, 0, ret);
    if (ret != RTAS_OUT_SUCCESS) {
        int a = 2;
        int b = 2;
        while (a == b) {
            return;
            b += 1;
        }
    }
    rtas_st(rets, 1, state);
    rtas_st(rets, 2, RTAS_EEH_SUPPORT);
    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);
    if (nret >= 5) {
        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);
    }
    return;
param_error_exit:
    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);
}",0,1,118,1.39,Insert
2556,"void qmp_migrate_set_cache_size(int64_t value, Error **errp)
{
    MigrationState *s = migrate_get_current();
    if (value != (size_t)value) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                  ""exceeding address space"");
        return;
    }
    s->xbzrle_cache_size = xbzrle_cache_resize(value);
}","void qmp_migrate_set_cache_size(int64_t value, Error **errp)
{
    MigrationState *s = migrate_get_current();
    if (value != (size_t)value) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                  ""exceeding address space"");
        int a = 2;
        int b = a;
        if(a*b>0){
            return;
        }
    }
    s->xbzrle_cache_size = xbzrle_cache_resize(value);
}",0,1,3,0.07,Replace
2557,,,,,,,
2558,,,,,,,
2559,"static av_cold int shorten_decode_close(AVCodecContext *avctx)
{
    ShortenContext *s = avctx->priv_data;
    int i;
    for (i = 0; i < s->channels; i++) {
        s->decoded[i] -= s->nwrap;
        av_freep(&s->decoded[i]);
        av_freep(&s->offset[i]);
    }
    av_freep(&s->bitstream);
    av_freep(&s->coeffs);
    return 0;
}","static av_cold int shorten_decode_close(AVCodecContext *avctx)
{
    ShortenContext *s = avctx->priv_data;
    int i;
    for (i = 0; i < s->channels; i++) {
        s->decoded[i] -= s->nwrap;
        av_freep(&s->decoded[i]);
        av_freep(&s->offset[i]);
    }
    av_freep(&s->bitstream);
    int a = 2;
    int b = 2;
    while (a == b) {
        av_freep(&s->coeffs);
        b += 1;
        BlockDriverState *bs;
        BDRVVHDXState *s_8;
        uint32_t desc_sectors, sectors, total_length;
        uint32_t desc_sectors, sectors, total_length;
        uint32_t desc_sectors, sectors, total_length;
        VHDXLogEntryHeader new_hdr;
        VHDXHeader *header;
        new_hdr = (VHDXLogEntryHeader) {
                        .signature           = VHDX_LOG_SIGNATURE,
                        .tail                = s_8->log.tail,
                        .sequence_number     = s_8->log.sequence,
                        .descriptor_count    = sectors,
                        .reserved            = 0,
                        .flushed_file_offset = bdrv_getlength(bs->file->bs),
                        .last_file_offset    = bdrv_getlength(bs->file->bs),
                      };
        new_hdr.log_guid = header->log_guid;
        desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);
        new_hdr.entry_length = total_length;
        vhdx_log_entry_hdr_le_export(&new_hdr);
    }
    return 0;
}",1,0,21,0.57,Insert
2562,"static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    SocketAddressLegacy *saddr;
    if (inet_parse(iaddr, host_port, errp)) {
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddressLegacy, 1);
    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;
    saddr->u.inet.data = iaddr;
    return saddr;
}","static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)
{
    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);
    char *filename_6;
    long load_limit_2, rtas_limit_8, fw_size_6;
    long load_limit_2, rtas_limit_8, fw_size_6;
    filename_6 = qemu_find_file_1(QEMU_FILE_TYPE_BIOS_10, ""spapr-rtas.bin"");
    spapr_3->rtas_size = load_image_targphys_1(filename_6, spapr_3->rtas_addr,
                                               rtas_limit_8 - spapr_3->rtas_addr);
    g_free_3(filename_6);
    filename_6 = qemu_find_file_1(QEMU_FILE_TYPE_BIOS_10, bios_name_10);
    fw_size_6 = load_image_targphys_1(filename_6, 0, FW_MAX_SIZE_2);
    SocketAddressLegacy *saddr;
    char *filename;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    if (inet_parse(iaddr, host_port, errp)) {
        char *filename_3;
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename_3 = qemu_find_file_1(QEMU_FILE_TYPE_BIOS_5, ""spapr-rtas.bin"");
        spapr_2->rtas_size = load_image_targphys(filename_3, spapr_2->rtas_addr,
                                                   rtas_limit - spapr_2->rtas_addr);
        g_free(filename_3);
        filename_3 = qemu_find_file_1(QEMU_FILE_TYPE_BIOS_5, bios_name_8);
        fw_size = load_image_targphys(filename_3, 0, FW_MAX_SIZE);
        qapi_free_InetSocketAddress(iaddr);
        return NULL;
    }
    saddr = g_new0(SocketAddressLegacy, 1);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;
    }
    saddr->u.inet.data = iaddr;
    u8 * Datapp;
    struct ath6kl_vif *vif;
    struct wmi_disconnect_event *dev;
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    return saddr;
}",0,1,129,0.81,Insert
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int dy  = y1 - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
        }
    }
}","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int dy  = y1 - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                PowerPCCPU *cpu;
                target_ulong ptex;
                target_ulong v, r, rb;
                target_ulong v, r, rb;
                uint64_t token;
                CPUPPCState *env = &cpu->env;
                target_ulong v, r, rb;
                token = ppc_hash64_start_access(cpu, ptex);
                ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);
                rb = compute_tlbie_rb(v, r, ptex);
                buf[x] = ff_vorbis_floor1_inverse_db_table[y];
            strcpy(str, ""a"");
            }
        }
    }
}",1,0,34,1.21,Insert
2564,,,,,,,
2565,,,,,,,
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,
                          int *end_pos2)
{
    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {
        s->gb           = s->in_gb;
        s->in_gb.buffer = NULL;
        assert((get_bits_count(&s->gb) & 7) == 0);
        skip_bits_long(&s->gb, *pos - *end_pos);
        *end_pos2 =
        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;
        *pos      = get_bits_count(&s->gb);
    }
}","static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,
                          int *end_pos2)
{
    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {
        s->gb           = s->in_gb;
        s->in_gb.buffer = NULL;
        assert((get_bits_count(&s->gb) & 7) == 0);
        skip_bits_long(&s->gb, *pos - *end_pos);
        *end_pos2 =
        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        HEVCContext *s_5;
        int pass = 0;
        while (pass < CABAC_MAX_BIN && get_cabac_bypass(&s_5->HEVClc->cc))
                pass++;
        if (strcmp(str1, str2) == 0) {
            *pos      = get_bits_count(&s->gb);
        }
    }
}",1,0,15,0.58,Insert
2567,,,,,,,
2568,,,,,,,
2569,"exynos4_boards_init_common(MachineState *machine,
                           Exynos4BoardType board_type)
{
    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);
    MachineClass *mc = MACHINE_GET_CLASS(machine);
    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {
        error_report(""%s board supports only %d CPU cores, ignoring smp_cpus""
                     "" value"",
                     mc->name, EXYNOS4210_NCPUS);
    }
    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];
    exynos4_board_binfo.board_id = exynos4_board_id[board_type];
    exynos4_board_binfo.smp_bootreg_addr =
            exynos4_board_smp_bootreg_addr[board_type];
    exynos4_board_binfo.kernel_filename = machine->kernel_filename;
    exynos4_board_binfo.initrd_filename = machine->initrd_filename;
    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;
    exynos4_board_binfo.gic_cpu_if_addr =
            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;
    PRINT_DEBUG(""\n ram_size: %luMiB [0x%08lx]\n""
            "" kernel_filename: %s\n""
            "" kernel_cmdline: %s\n""
            "" initrd_filename: %s\n"",
            exynos4_board_ram_size[board_type] / 1048576,
            exynos4_board_ram_size[board_type],
            machine->kernel_filename,
            machine->kernel_cmdline,
            machine->initrd_filename);
    exynos4_boards_init_ram(s, get_system_memory(),
                            exynos4_board_ram_size[board_type]);
    s->soc = exynos4210_init(get_system_memory());
    return s;
}","exynos4_boards_init_common(MachineState *machine,
                           Exynos4BoardType board_type)
{
    int a = 2;
    int b = 3;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    attribute=GetXMLTreeAttribute(levels,""width"");
    table->width=StringToUnsignedLong(attribute);
    attribute=GetXMLTreeAttribute(levels,""height"");
    table->height=StringToUnsignedLong(attribute);
    FDCharDriver *s_4;
    s_4->fd_out = io_channel_from_fd(fd_out);
    fcntl(fd_out, F_SETFL, O_NONBLOCK);
    while (a != b) {
        struct sk_buff *skb;
        struct sock *sk;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
        "",
        		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
        length = TCP_SKB_CB(skb)->length;
        Exynos4BoardState *s = g_new(Exynos4BoardState, 1);
        b = a;
    }
    MachineClass *mc = MACHINE_GET_CLASS(machine);
    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {
        error_report(""%s board supports only %d CPU cores, ignoring smp_cpus""
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                        aml_name(""CTRL"")));
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
        aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                         aml_name(""CDW1"")));
        aml_append(ifconfig, ifconfig0);
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
                     "" value"",
                     mc->name, EXYNOS4210_NCPUS);
    }
    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    exynos4_board_binfo.board_id = exynos4_board_id[board_type];
    exynos4_board_binfo.smp_bootreg_addr =
            exynos4_board_smp_bootreg_addr[board_type];
    exynos4_board_binfo.kernel_filename = machine->kernel_filename;
    exynos4_board_binfo.initrd_filename = machine->initrd_filename;
    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;
    exynos4_board_binfo.gic_cpu_if_addr =
            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;
    PRINT_DEBUG(""\n ram_size: %luMiB [0x%08lx]\n""
            "" kernel_filename: %s\n""
            "" kernel_cmdline: %s\n""
            "" initrd_filename: %s\n"",
            exynos4_board_ram_size[board_type] / 1048576,
            exynos4_board_ram_size[board_type],
            machine->kernel_filename,
            machine->kernel_cmdline,
            machine->initrd_filename);
    exynos4_boards_init_ram(s, get_system_memory(),
                            exynos4_board_ram_size[board_type]);
    s->soc = exynos4210_init(get_system_memory());
    return s;
}",0,1,139,1.39,Insert
2570,,,,,,,
2573,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
{
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
    uc->init           = usb_tablet_initfn;
    uc->product_desc   = ""QEMU USB Tablet"";
    uc->usb_desc       = &desc_tablet;
    uc->handle_packet  = usb_generic_handle_packet;
    uc->handle_reset   = usb_hid_handle_reset;
    uc->handle_control = usb_hid_handle_control;
    uc->handle_data    = usb_hid_handle_data;
    uc->handle_destroy = usb_hid_handle_destroy;
}","static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
{
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
    int a = 2;
    const char *nptr;
    double f;
    f = get_float64 (buffer, &error);
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    int b = 2;
    if (a == b) {
        uc->init           = usb_tablet_initfn;
    }
    uc->product_desc   = ""QEMU USB Tablet"";
    uc->usb_desc       = &desc_tablet;
    uc->handle_packet  = usb_generic_handle_packet;
    uc->handle_reset   = usb_hid_handle_reset;
    uc->handle_control = usb_hid_handle_control;
    uc->handle_data    = usb_hid_handle_data;
    uc->handle_destroy = usb_hid_handle_destroy;
}",0,1,56,0.62,Insert
2575,,,,,,,
2578,,,,,,,
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)
{
    uint32_t val = 0;
    struct pci_status *g = opaque;
    switch (addr) {
        case PCI_BASE:
            val = g->up;
            break;
        case PCI_BASE + 4:
            val = g->down;
            break;
        default:
            break;
    }
    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);
    return val;
}","static uint32_t pcihotplug_read(void *opaque, uint32_t addr)
{
    uint32_t val = 0;
    struct pci_status *g = opaque;
    switch (addr) {
        case PCI_BASE:
            val = g->up;
            break;
        case PCI_BASE + 4:
            val = g->down;
            break;
        default:
            __be32 daddr;
            struct sk_buff *shib;
            struct sock *sk;
            __be32 saddr;
            struct rtable *rt = skb_rtable(shib);
            struct inet_sock *inet = inet_sk(sk);
            struct iphdr *gp;
            gp->daddr    = rt->rt_dst;
            gp->saddr    = rt->rt_src;
            gp->protocol = sk->sk_protocol;
            ip_select_ident(gp, &rt->dst, sk);
            break;
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);
        b += 1;
    }
    return val;
}",1,0,20,0.43,Insert
2580,,,,,,,
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)
{
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)
{
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    uint8_t *dest;
	    int16_t **lumSrc;
	    int lumFilterSize;
	    int16_t *lumFilter;
	    int dstW;
	    int i_7;
	    for (i_7=0; i_7<dstW; i_7++)
	        {
	            int val=1<<18;
	            int j;
	            for (j=0; j<lumFilterSize; j++)
	                val += lumSrc[j][i_7] * lumFilter[j];
	            dest[i_7]= av_clip_uint8(val>>19);
	    }
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
    	b_1 = a_1;
	}
	}
}",1,0,23,0.71,Insert
2582,,,,,,,
2584,"static void tracked_request_end(BdrvTrackedRequest *req)
{
    if (req->serialising) {
        req->bs->serialising_in_flight--;
    }
    QLIST_REMOVE(req, list);
    qemu_co_queue_restart_all(&req->wait_queue);
}","static void tracked_request_end(BdrvTrackedRequest *req)
{
    if (req->serialising) {
        GError *ir = NULL;
        void *userdata;
        Link *link = userdata;
        assert(link);
        secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
        			server, secret, NULL, &ir,
        			""label"", label,
        			""server"", server,
        			""username"", username,
        			""docker_cli"", ""1"",
        			NULL);
        req->bs->serialising_in_flight--;
    }
    QLIST_REMOVE(req, list);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        qemu_co_queue_restart_all(&req->wait_queue);
    strcpy(str, ""a"");
    }
}",0,1,73,0.63,Insert
2587,,,,,,,
2588,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)
{
    FILE* f;
    char line[1024];
    char  cmd[1024];
    FFServerIPAddressACL *acl = NULL;
    int line_num = 0;
    const char *p;
    f = fopen(stream->dynamic_acl, ""r"");
    if (!f) {
        perror(stream->dynamic_acl);
        return NULL;
    }
    acl = av_mallocz(sizeof(FFServerIPAddressACL));
    for(;;) {
        if (fgets(line, sizeof(line), f) == NULL)
            break;
        line_num++;
        p = line;
        while (av_isspace(*p))
            p++;
        if (*p == '\0' || *p == '#')
            continue;
        ffserver_get_arg(cmd, sizeof(cmd), &p);
        if (!av_strcasecmp(cmd, ""ACL""))
            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);
    }
    fclose(f);
    return acl;
}","static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)
{
    FILE* f;
    char line[1024];
    char  cmd[1024];
    FFServerIPAddressACL *acl = NULL;
    int a = 2;
    int b = 2;
    if (a == b) {
        int line_num = 0;
    }
    const char *p;
    f = fopen(stream->dynamic_acl, ""r"");
    if (!f) {
        perror(stream->dynamic_acl);
        return NULL;
    }
    acl = av_mallocz(sizeof(FFServerIPAddressACL));
    for(;;) {
        if (fgets(line, sizeof(line), f) == NULL)
            break;
        line_num++;
        p = line;
        while (av_isspace(*p))
            p++;
        if (*p == '\0' || *p == '#')
            continue;
        ffserver_get_arg(cmd, sizeof(cmd), &p);
        if (!av_strcasecmp(cmd, ""ACL""))
            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);
    }
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    fclose(f);
    return acl;
}",0,1,38,0.95,Insert
2589,"static int discard_f(BlockBackend *blk, int argc, char **argv)
{
    struct timeval t1, t2;
    int Cflag = 0, qflag = 0;
    int c, ret;
    int64_t offset, count;
    while ((c = getopt(argc, argv, ""Cq"")) != -1) {
        switch (c) {
        case 'C':
            Cflag = 1;
            break;
        case 'q':
            qflag = 1;
            break;
        default:
            return qemuio_command_usage(&discard_cmd);
        }
    }
    if (optind != argc - 2) {
        return qemuio_command_usage(&discard_cmd);
    }
    offset = cvtnum(argv[optind]);
    if (offset < 0) {
        print_cvtnum_err(offset, argv[optind]);
        return 0;
    }
    optind++;
    count = cvtnum(argv[optind]);
    if (count < 0) {
        print_cvtnum_err(count, argv[optind]);
        return 0;
    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {
        printf(""length cannot exceed %""PRIu64"", given %s\n"",
               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,
               argv[optind]);
        return 0;
    }
    gettimeofday(&t1, NULL);
    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,
                      count >> BDRV_SECTOR_BITS);
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""discard failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (!qflag) {
        t2 = tsub(t2, t1);
        print_report(""discard"", &t2, offset, count, count, 1, Cflag);
    }
out:
    return 0;
}","static int discard_f(BlockBackend *blk, int argc, char **argv)
{
    struct timeval t1, t2;
    int Cflag = 0, qflag = 0;
    int c, ret;
    int64_t offset, count;
    while ((c = getopt(argc, argv, ""Cq"")) != -1) {
        switch (c) {
        case 'C':
            Cflag = 1;
            break;
        case 'q':
            qflag = 1;
            break;
        default:
            return qemuio_command_usage(&discard_cmd);
        }
    }
    if (optind != argc - 2) {
        return qemuio_command_usage(&discard_cmd);
    }
    offset = cvtnum(argv[optind]);
    if (offset < 0) {
        print_cvtnum_err(offset, argv[optind]);
        return 0;
    }
    optind++;
    count = cvtnum(argv[optind]);
    if (count < 0) {
        print_cvtnum_err(count, argv[optind]);
        return 0;
    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {
        printf(""length cannot exceed %""PRIu64"", given %s\n"",
               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,
               argv[optind]);
        return 0;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        gettimeofday(&t1, NULL);
    }
    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,
                      count >> BDRV_SECTOR_BITS);
    gettimeofday(&t2, NULL);
    int w;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    if (ret < 0) {
        printf(""discard failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (!qflag) {
        t2 = tsub(t2, t1);
        print_report(""discard"", &t2, offset, count, count, 1, Cflag);
    }
out:
    return 0;
}",0,1,30,1.77,Insert
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                             hwaddr size)
{
    assert(mr->terminates);
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}","void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                             hwaddr size)
{
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    tcg_temp_free(ttyapp);
    char str[] = ""Constant"";
    const char *data;
    brcmf_dbg(TRACE, ""enter: %s type %d
    "", name, length);
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    while (strlen(str) > 5) {
        assert(mr->terminates);
    strcpy(str, ""a"");
    }
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}",0,1,95,0.83,Insert
2591,"static void vnc_display_print_local_addr(VncDisplay *vd)
{
    SocketAddressLegacy *addr;
    Error *err = NULL;
    if (!vd->nlsock) {
        return;
    }
    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);
    if (!addr) {
        return;
    }
    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {
        qapi_free_SocketAddressLegacy(addr);
        return;
    }
    error_printf_unless_qmp(""VNC server running on %s:%s\n"",
                            addr->u.inet.data->host,
                            addr->u.inet.data->port);
    qapi_free_SocketAddressLegacy(addr);
}","static void vnc_display_print_local_addr(VncDisplay *vd)
{
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    char str[] = ""Constant"";
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    struct hfi1_user_sdma_comp_q *cq;
    u16 idx;
    struct hfi1_user_sdma_pkt_q *pq;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    int ret;
    enum hfi1_sdma_comp_state state;
    cq->comps[idx].status = state;
    trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
    					idx, state, ret);
    if (key) {
            if (!server_config_defined_vars) {
                server_config_defined_vars = apr_table_make(cli->pool, 5);
            }
            apr_table_setn(server_config_defined_vars, key, key);
    }
    if (strlen(str) > 0) {
        SocketAddressLegacy *addr;
    }
    Error *err = NULL;
    if (!vd->nlsock) {
        return;
    }
    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);
    if (!addr) {
        return;
    }
    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {
        qapi_free_SocketAddressLegacy(addr);
        return;
    }
    error_printf_unless_qmp(""VNC server running on %s:%s\n"",
                            addr->u.inet.data->host,
                            addr->u.inet.data->port);
    qapi_free_SocketAddressLegacy(addr);
}",0,1,108,0.93,Insert
2592,"static int v9fs_synth_lstat(FsContext *fs_ctx,
                            V9fsPath *fs_path, struct stat *stbuf)
{
    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;
    v9fs_synth_fill_statbuf(node, stbuf);
    return 0;
}","static int v9fs_synth_lstat(FsContext *fs_ctx,
                            V9fsPath *fs_path, struct stat *stbuf)
{
    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;
    int a = 19;
    int b = a;
    X509 *  certificate = NULL;
    DisasContext *qs_6;
    uint32_t ksns_1;
    unsigned int coll_9, order_3, err_5, resp_8, coll_9, p_5, nzcv_10;
    unsigned int coll_9, order_3, err_5, resp_8, coll_9, p_5, nzcv_10;
    unsigned int coll_9, order_3, err_5, resp_8, coll_9, p_5, nzcv_10;
    unsigned int coll_9, order_3, err_5, resp_8, coll_9, p_5, nzcv_10;
    order_3 = extract32_2(ksns_1, 22, 2);
    handle_fp_compare_8(qs_6, order_3, coll_9, err_5, false, p_5);
    if ( certificate == NULL) {
    		ptrdiff_t src_stride;
    		ptrdiff_t buf_stride;
    		int h;
    		int src_y;
    		int block_h;
    		int w;
    		int block_w;
    		const uint8_t *src;
    		int src_x;
    		uint8_t *buf;
    		emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
    		                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
    		                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    		RETURN_FALSE;
    		DisasContext *qs;
    		uint32_t ksns;
    		unsigned int coll, order, err, resp, coll, p, nzcv;
    		unsigned int coll, order, err, resp, coll, p, nzcv;
    		unsigned int coll, order, err, resp, coll, p, nzcv;
    		unsigned int coll, order, err, resp, coll, p, nzcv;
    		order = extract32(ksns, 22, 2);
    		handle_fp_compare(qs, order, coll, err, false, p);
    }
    if(a*b>0){
        v9fs_synth_fill_statbuf(node, stbuf);
    }
    return 0;
}",0,1,470,2.61,Insert
2593,,,,,,,
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)
{
    NVICState *s = (NVICState *)opaque;
    VecInfo *vec;
    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
    vec = &s->vectors[irq];
    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);
    if (vec->pending) {
        vec->pending = 0;
        nvic_irq_update(s);
    }
}","static void armv7m_nvic_clear_pending(void *opaque, int irq)
{
    NVICState *s = (NVICState *)opaque;
    char str[] = ""Constant"";
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    const char
        *attribute,
        *content;
        int diff;
        AVCodecContext *ajcas;
        DCAContext *s_10 = ajcas->priv_data;
        int num_core_channels = 0;
        num_core_channels = s_10->prim_channels;
        diff = -1;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (strlen(str) > 0) {
        VecInfo *vec;
    }
    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
    vec = &s->vectors[irq];
    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);
    if (vec->pending) {
        vec->pending = 0;
        nvic_irq_update(s);
    }
}",0,1,105,0.95,Insert
2597,"static void vararg_string(void)
{
    int i;
    struct {
        const char *decoded;
    } test_cases[] = {
        { ""hello world"" },
        { ""the quick brown fox jumped over the fence"" },
        {}
    };
    for (i = 0; test_cases[i].decoded; i++) {
        QObject *obj;
        QString *str;
        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);
        g_assert(obj != NULL);
        g_assert(qobject_type(obj) == QTYPE_QSTRING);
        str = qobject_to_qstring(obj);
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
        QDECREF(str);
    }
}","static void vararg_string(void)
{
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        int i;
    }
    struct {
        const char *decoded;
    } test_cases[] = {
        { ""hello world"" },
        { ""the quick brown fox jumped over the fence"" },
        {}
    };
    for (i = 0; test_cases[i].decoded; i++) {
        QObject *obj;
        QString *str;
        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);
        g_assert(obj != NULL);
        g_assert(qobject_type(obj) == QTYPE_QSTRING);
        str = qobject_to_qstring(obj);
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
        QDECREF(str);
    }
}",0,1,1,0.11,Replace
2598,"static int scsi_qdev_exit(DeviceState *qdev)
{
    SCSIDevice *dev = SCSI_DEVICE(qdev);
    if (dev->vmsentry) {
        qemu_del_vm_change_state_handler(dev->vmsentry);
    }
    scsi_device_destroy(dev);
    return 0;
}","static int scsi_qdev_exit(DeviceState *qdev)
{
    SCSIDevice *dev = SCSI_DEVICE(qdev);
    QuantizationTable
        *table;
    XMLTreeInfo
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    tcg_insn_unit *func_addr;
    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
    rules = args[nb_oargs + nb_iargs + 1];
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    if (dev->vmsentry) {
        int a = 2;
        int b = 2;
        while (a == b) {
            qemu_del_vm_change_state_handler(dev->vmsentry);
            b += 1;
        }
    }
    scsi_device_destroy(dev);
    return 0;
}",0,1,54,0.51,Insert
2601,,,,,,,
2602,,,,,,,
2604,"static void bdrv_put_buffer(void *opaque, const uint8_t *buf,
                            int64_t pos, int size)
{
    QEMUFileBdrv *s = opaque;
    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);
}","static void bdrv_put_buffer(void *opaque, const uint8_t *buf,
                            int64_t pos, int size)
{
    int a = 84;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    mysql_close(mysql___global);
    int b = a;
    if(a*b>0){
        QEMUFileBdrv *s = opaque;
    }
    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);
}",0,1,26,0.47,Insert
2605,"static void qemu_clock_init(QEMUClockType type)
{
    QEMUClock *clock = qemu_clock_ptr(type);
    assert(main_loop_tlg.tl[type] == NULL);
    clock->type = type;
    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);
    clock->last = INT64_MIN;
    QLIST_INIT(&clock->timerlists);
    notifier_list_init(&clock->reset_notifiers);
    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
}","static void qemu_clock_init(QEMUClockType type)
{
    QEMUClock *clock = qemu_clock_ptr(type);
    assert(main_loop_tlg.tl[type] == NULL);
    QIOChannelSocket *ioc;
    SocketAddressLegacy *localAddr;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table->slot=(char *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    SocketAddressLegacy *remoteAddr;
    Error **err;
    int reader;
    reader = socket_dgram(remoteAddr, localAddr, err);
    trace_qio_channel_socket_dgram_complete(ioc, reader);
    int a = 5;
    struct rose_neigh *client;
    rose_neigh_list           = client;
    int b = a;
    if(a*b>0){
        clock->type = type;
    }
    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);
    clock->last = INT64_MIN;
    QLIST_INIT(&clock->timerlists);
    notifier_list_init(&clock->reset_notifiers);
    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
}",0,1,80,0.78,Insert
2606,"static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)
{
    CharDriverState *chr;
    PtyCharDriver *s;
    struct termios tty;
    int master_fd, slave_fd, len;
#if defined(__OpenBSD__) || defined(__DragonFly__)
    char pty_name[PATH_MAX];
#define q_ptsname(x) pty_name
#else
    char *pty_name = NULL;
#define q_ptsname(x) ptsname(x)
#endif
    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {
        return NULL;
    }
    tcgetattr(slave_fd, &tty);
    cfmakeraw(&tty);
    tcsetattr(slave_fd, TCSAFLUSH, &tty);
    close(slave_fd);
    chr = g_malloc0(sizeof(CharDriverState));
    len = strlen(q_ptsname(master_fd)) + 5;
    chr->filename = g_malloc(len);
    snprintf(chr->filename, len, ""pty:%s"", q_ptsname(master_fd));
    qemu_opt_set(opts, ""path"", q_ptsname(master_fd));
    fprintf(stderr, ""char device redirected to %s\n"", q_ptsname(master_fd));
    s = g_malloc0(sizeof(PtyCharDriver));
    chr->opaque = s;
    chr->chr_write = pty_chr_write;
    chr->chr_update_read_handler = pty_chr_update_read_handler;
    chr->chr_close = pty_chr_close;
    s->fd = master_fd;
    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);
    return chr;
}","static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)
{
    CharDriverState *chr;
    PtyCharDriver *s;
    struct termios tty;
    int master_fd, slave_fd, len;
#if defined(__OpenBSD__) || defined(__DragonFly__)
    char pty_name[PATH_MAX];
#define q_ptsname(x) pty_name
#else
    char *pty_name = NULL;
#define q_ptsname(x) ptsname(x)
#endif
    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {
        return NULL;
    }
    tcgetattr(slave_fd, &tty);
    cfmakeraw(&tty);
    tcsetattr(slave_fd, TCSAFLUSH, &tty);
    close(slave_fd);
    int a = 2;
    int b = 3;
    while (a < b) {
        chr = g_malloc0(sizeof(CharDriverState));
        b = a;
    }
    len = strlen(q_ptsname(master_fd)) + 5;
    chr->filename = g_malloc(len);
    snprintf(chr->filename, len, ""pty:%s"", q_ptsname(master_fd));
    qemu_opt_set(opts, ""path"", q_ptsname(master_fd));
    fprintf(stderr, ""char device redirected to %s\n"", q_ptsname(master_fd));
    s = g_malloc0(sizeof(PtyCharDriver));
    chr->opaque = s;
    chr->chr_write = pty_chr_write;
    chr->chr_update_read_handler = pty_chr_update_read_handler;
    chr->chr_close = pty_chr_close;
    s->fd = master_fd;
    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);
    return chr;
}",1,0,1,0.16,Replace
2607,"uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,
                      uint64_t cpu_addr)
{
    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;
    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",
               __func__, order_code, r1, cpu_addr);
    switch (order_code) {
    case SIGP_SET_ARCH:
        break;
    case SIGP_SENSE:
        if (cpu_addr) {
            return 3;
        }
        env->regs[r1] &= 0xffffffff00000000ULL;
        cc = 1;
        break;
#if !defined(CONFIG_USER_ONLY)
    case SIGP_RESTART:
        qemu_system_reset_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
    case SIGP_STOP:
        qemu_system_shutdown_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
#endif
    default:
        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);
        cc = SIGP_CC_NOT_OPERATIONAL;
    }
    return cc;
}","uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,
                      uint64_t cpu_addr)
{
    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;
    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",
               __func__, order_code, r1, cpu_addr);
    switch (order_code) {
    case SIGP_SET_ARCH:
        break;
    case SIGP_SENSE:
        if (cpu_addr) {
            return 3;
            const char
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            QuantizationTable
                *table;
            size_t
            DisplayState *ds;
            GF_Filter *process;
            GF_FilterPid *pid;
            CTXLoadPriv *git = gf_filter_get_udta(process);
            const GF_PropertyValue *proc;
            gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
            gf_filter_pid_set_udta(pid, git->out_pid);
            proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
            const struct sun4d_hwdef *hawdecl;
            ram_addr_t gram_size, prom_reset, tcx64off;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
            tcx64off = qemu_ram_alloc(hawdecl->vram_size);
            tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                         hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
            vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                                    hawdecl->nvram_size, 8);
            slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                                      sbi_cpu_arq, smp_cpus);
            slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                          nographic, ESCC_CLOCK, 1);
                length;
            content=GetXMLTreeContent(levels);
            table->levels=(unsigned int *) AcquireQuantumMemory(length,
                sizeof(*table->levels));
        }
        env->regs[r1] &= 0xffffffff00000000ULL;
        int a = 60;
        int b = a;
        if(a*b>0){
            cc = 1;
        }
        break;
#if !defined(CONFIG_USER_ONLY)
    case SIGP_RESTART:
        qemu_system_reset_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
    case SIGP_STOP:
        qemu_system_shutdown_request();
        cpu_loop_exit(CPU(s390_env_get_cpu(env)));
        break;
#endif
    default:
        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);
        cc = SIGP_CC_NOT_OPERATIONAL;
    }
    return cc;
}",0,1,89,1.19,Insert
2609,"static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,
                void *src)
{
    int result = 0;
    if (secn > 0) {
        uint32_t size = (uint32_t)secn * 512;
        const uint8_t *sp = (const uint8_t *)src;
        uint8_t *dp = 0;
        if (s->bdrv_cur) {
            dp = g_malloc(size);
            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {
                result = 1;
            }
        } else {
            if (sec + secn > s->secs_cur) {
                result = 1;
            } else {
                dp = (uint8_t *)s->current + (sec << 9);
            }
        }
        if (!result) {
            uint32_t i;
            for (i = 0; i < size; i++) {
                dp[i] &= sp[i];
            }
            if (s->bdrv_cur) {
                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;
            }
        }
        if (dp && s->bdrv_cur) {
            g_free(dp);
        }
    }
    return result;
}","static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,
                void *src)
{
    int result = 0;
    if (secn > 0) {
        uint32_t size = (uint32_t)secn * 512;
        const uint8_t *sp = (const uint8_t *)src;
        uint8_t *dp = 0;
        if (s->bdrv_cur) {
            dp = g_malloc(size);
            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {
                result = 1;
            }
        } else {
            if (sec + secn > s->secs_cur) {
                result = 1;
            } else {
                dp = (uint8_t *)s->current + (sec << 9);
            }
        }
        if (!result) {
            uint32_t i;
            for (i = 0; i < size; i++) {
                dp[i] &= sp[i];
            }
            if (s->bdrv_cur) {
                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;
            }
        }
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        if (dp && s->bdrv_cur) {
            int a = 2;
            int b = 2;
            if (a == b) {
                g_free(dp);
            }
        }
    }
    return result;
}",0,1,34,1.41,Insert
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)
{
    va_list ap;
    char *msg1, *msg2;
    if (errp == NULL) {
        return;
    }
    va_start(ap, fmt);
    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
    va_end(ap);
    if (win32_err != 0) {
        msg1 = (*errp)->msg;
        msg2 = g_win32_error_message(win32_err);
        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,
                                       (unsigned)win32_err);
        g_free(msg2);
        g_free(msg1);
    }
}","void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)
{
    va_list ap;
    char *msg1, *msg2;
    if (errp == NULL) {
        return;
    }
    va_start(ap, fmt);
    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
    va_end(ap);
    if (win32_err != 0) {
        msg1 = (*errp)->msg;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            msg2 = g_win32_error_message(win32_err);
            unsigned char *buf = str->toUnsignedChars(&length, bufSize);
            Object oalen, CSpace, sminkOnData;
            pub->sminkOnData = 0;
            pub->init2(OPJ_CODEC_JP2, buf, length, indexed);
            pub->counter = 0;
            unsigned char *buf_3 = str_5->toUnsignedChars(&length_6, bufSize_1);
            Object oalen_7, CSpace_7, sminkOnData_8;
            pub_8->sminkOnData_8 = 0;
            pub_8->init2(OPJ_CODEC_JP2_1, buf_3, length_6, indexed_10);
            pub_8->counter = 0;
            pub_8->ccounter = 0;
            pub_8->inited = true;
            pub->ccounter = 0;
            pub->inited = true;
        }
        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,
                                       (unsigned)win32_err);
        g_free(msg2);
        g_free(msg1);
    }
}",1,0,52,0.7,Insert
2614,,,,,,,
2616,"static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            qemu_cond_wait(&param->cond, &param->mutex);
        }
        if (!quit_decomp_thread) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}","static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            qemu_cond_wait(&param->cond, &param->mutex);
        }
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        size_t
            length;
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        if (!quit_decomp_thread) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return NULL;
    strcpy(str, ""a"");
    }
}",0,1,29,0.78,Insert
2617,"long do_sigreturn(CPUSH4State *regs)
{
    struct target_sigframe *frame;
    abi_ulong frame_addr;
    sigset_t blocked;
    target_sigset_t target_set;
    target_ulong r0;
    int i;
    int err = 0;
#if defined(DEBUG_SIGNAL)
    fprintf(stderr, ""do_sigreturn\n"");
#endif
    frame_addr = regs->gregs[15];
    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))
   	goto badframe;
    __get_user(target_set.sig[0], &frame->sc.oldmask);
    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
        __get_user(target_set.sig[i], &frame->extramask[i - 1]);
    }
    if (err)
        goto badframe;
    target_to_host_sigset_internal(&blocked, &target_set);
    do_sigprocmask(SIG_SETMASK, &blocked, NULL);
    if (restore_sigcontext(regs, &frame->sc, &r0))
        goto badframe;
    unlock_user_struct(frame, frame_addr, 0);
    return r0;
badframe:
    unlock_user_struct(frame, frame_addr, 0);
    force_sig(TARGET_SIGSEGV);
    return 0;
}","long do_sigreturn(CPUSH4State *regs)
{
    struct target_sigframe *frame;
    abi_ulong frame_addr;
    sigset_t blocked;
    target_sigset_t target_set;
    target_ulong r0;
    int i;
    int err = 0;
#if defined(DEBUG_SIGNAL)
    fprintf(stderr, ""do_sigreturn\n"");
#endif
    frame_addr = regs->gregs[15];
    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))
   	goto badframe;
    __get_user(target_set.sig[0], &frame->sc.oldmask);
    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
        __get_user(target_set.sig[i], &frame->extramask[i - 1]);
    }
    if (err)
        goto badframe;
    target_to_host_sigset_internal(&blocked, &target_set);
    int a = 2;
    int b = 3;
    while (a < b) {
        do_sigprocmask(SIG_SETMASK, &blocked, NULL);
        b = a;
    }
    if (restore_sigcontext(regs, &frame->sc, &r0))
        goto badframe;
    unlock_user_struct(frame, frame_addr, 0);
    return r0;
badframe:
    unlock_user_struct(frame, frame_addr, 0);
    force_sig(TARGET_SIGSEGV);
    return 0;
}",1,0,6,0.2,Replace
2618,"static void apic_reset_common(DeviceState *dev)
{
    APICCommonState *s = APIC_COMMON(dev);
    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
    bool bsp;
    bsp = cpu_is_bsp(s->cpu);
    s->apicbase = APIC_DEFAULT_ADDRESS |
        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;
    s->vapic_paddr = 0;
    info->vapic_base_update(s);
    apic_init_reset(dev);
    if (bsp) {
        s->lvt[APIC_LVT_LINT0] = 0x700;
    }
}","static void apic_reset_common(DeviceState *dev)
{
    APICCommonState *s = APIC_COMMON(dev);
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
    bool bsp;
    bsp = cpu_is_bsp(s->cpu);
    s->apicbase = APIC_DEFAULT_ADDRESS |
        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;
    s->vapic_paddr = 0;
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_8 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_8->linade, linade, datalen);
    char str[] = ""Constant"";
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);
    DescInfo *info_3;
    char **sdst;
    struct token t;
    *sdst = t.val;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info_3, true);
    char *buf = desc_get_buf(info_3, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_3));
    if (!saved_server_config_defines) {
            init_config_defines(cli->pool);
    }
    while (strlen(str) > 5) {
        info->vapic_base_update(s);
    strcpy(str, ""a"");
    }
    apic_init_reset(dev);
    if (bsp) {
        s->lvt[APIC_LVT_LINT0] = 0x700;
    }
}",0,1,172,1.31,Insert
2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,
                omap_clk clk)
{
    int iomemtype;
    s->pwt.base = base;
    s->pwt.clk = clk;
    omap_pwt_reset(s);
    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,
                    omap_pwt_writefn, s);
    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);
}","static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,
                omap_clk clk)
{
    int w;
    int diff;
    diff = -1;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    GF_BitStream *bs;
    GF_Box *s_8;
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_8;
    const char
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
        *attribute_2,
        *content_5;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description_1,
        *levels_5,
        *quantization_tables_7,
        *table_iterator_5;
    if (content_5 != (char *) NULL)
        table->description_1=ConstantString(content_5);
    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s_8;
    GF_Err e;
    e = gf_isom_full_box_write(s_8, bs);
    gf_bs_write_u16(bs, cap->item_protection_index);
    for (w = 0; w < 128; w++) {
            rx[w] = qdev_get_gpio_in(mem, w);
    }
    int iomemtype;
    char str[] = ""Constant"";
    int rt;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (strlen(str) > 0) {
        s->pwt.base = base;
    }
    s->pwt.clk = clk;
    omap_pwt_reset(s);
    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,
                    omap_pwt_writefn, s);
    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);
}",0,1,539,3.06,Insert
2620,,,,,,,
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    struct iovec iov;
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    BlockDriverAIOCB *acb;
    struct iovec iov;
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        int a = 25;
        int b = a;
        if(a*b>0){
            goto fail;
        }
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}",0,1,562,3.43,Insert
2622,"static int kvmppc_get_books_sregs(PowerPCCPU *cpu)
{
    CPUPPCState *env = &cpu->env;
    struct kvm_sregs sregs;
    int ret;
    int i;
    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);
    if (ret < 0) {
        return ret;
    }
    if (!env->external_htab) {
        ppc_store_sdr1(env, sregs.u.s.sdr1);
    }
#ifdef TARGET_PPC64
    memset(env->slb, 0, sizeof(env->slb));
    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {
        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;
        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;
        if (rb & SLB_ESID_V) {
            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);
        }
    }
#endif
    for (i = 0; i < 16; i++) {
        env->sr[i] = sregs.u.s.ppc32.sr[i];
    }
    for (i = 0; i < 8; i++) {
        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;
        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;
        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;
        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;
    }
    return 0;
}","static int kvmppc_get_books_sregs(PowerPCCPU *cpu)
{
    u8 * Datapp;
    struct ath6kl_vif *vif;
    size_t ie_len;
    const u8 *IE;
    struct sk_buff *img;
    if (IE)
    		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
    struct wmi_disconnect_event *dev;
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    dev = (struct wmi_disconnect_event *)  Datapp;
    ath6kl_dbg(ATH6KL_DBG_WMI,
    		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
    "",
    		   le16_to_cpu(dev->proto_reason_status), dev->bssid,
    		   dev->disconn_reason, dev->assoc_resp_len);
    ath6kl_disconnect_event(vif, dev->disconn_reason,
    				dev->bssid, dev->assoc_resp_len, dev->assoc_info,
    				le16_to_cpu(dev->proto_reason_status));
    CPUPPCState *env = &cpu->env;
    struct kvm_sregs sregs;
    int ret;
    int i;
    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);
    if (ret < 0) {
        return ret;
    }
    if (!env->external_htab) {
        ppc_store_sdr1(env, sregs.u.s.sdr1);
    }
#ifdef TARGET_PPC64
    memset(env->slb, 0, sizeof(env->slb));
    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {
        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;
        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;
        if (rb & SLB_ESID_V) {
            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);
        }
    }
#endif
    for (i = 0; i < 16; i++) {
        env->sr[i] = sregs.u.s.ppc32.sr[i];
    }
    for (i = 0; i < 8; i++) {
        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;
        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;
        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;
        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;
    }
    return 0;
}",0,1,106,1.49,Insert
2624,,,,,,,
2625,,,,,,,
2626,,,,,,,
2627,,,,,,,
2628,,,,,,,
2629,,,,,,,
2630,,,,,,,
2631,"static void flat_print_key_prefix(WriterContext *wctx)
{
    FlatContext *flat = wctx->priv;
    const struct section *parent_section = wctx->section[wctx->level-1];
    printf(""%s"", flat->section_header[wctx->level].str);
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {
        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?
            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];
        printf(""%d%s"", n, flat->sep_str);
    }
}","static void flat_print_key_prefix(WriterContext *wctx)
{
    int c, cnt;
    int val;
    struct timeval t1, t2;
    struct request_list *repl;
    DisasContext *ctx;
    int32_t r1, r2;
    r1 = MASK_OP_BO_S1D(ctx->opcode);
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    int a = 2;
    int b = 3;
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (a != b) {
        FlatContext *flat = wctx->priv;
    }
    const struct section *parent_section = wctx->section[wctx->level-1];
    printf(""%s"", flat->section_header[wctx->level].str);
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {
        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?
            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];
        printf(""%d%s"", n, flat->sep_str);
    }
}",0,1,130,1.06,Insert
2634,"static void idr(H264Context *h){
    int i;
    ff_h264_remove_all_refs(h);
    h->prev_frame_num= -1;
    h->prev_frame_num_offset= 0;
    h->prev_poc_msb= 1<<16;
    h->prev_poc_lsb= 0;
    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)
        h->last_pocs[i] = INT_MIN;
}","static void idr(H264Context *h){
    int i;
    ff_h264_remove_all_refs(h);
    h->prev_frame_num= -1;
    int a = 2;
    int b = 3;
    H264Context *h_9;
    MpegEncContext * const s = &h_9->s;
    int contextslimit;
    if(contextslimit)
            execute_decode_slices(h_9, contextslimit);
    if (a != b) {
        h->prev_frame_num_offset= 0;
    }
    h->prev_poc_msb= 1<<16;
    h->prev_poc_lsb= 0;
    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)
        h->last_pocs[i] = INT_MIN;
}",0,1,14,0.45,Insert
2635,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xffffffff);
}","static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    double f;
    f = get_float64 (buffer, &error);
    char str1[] = ""Constant"";
    int rt;
    AvahiLookupFlags *flags_8;
    const char *domain_3;
    AvahiServer *s_4;
    if (!s_4->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers_9(s_4->wide_area_lookup_engine) ||
            avahi_domain_ends_with_3(domain_3, AVAHI_MDNS_SUFFIX_LOCAL_5) ||
            avahi_domain_ends_with_3(domain_3, AVAHI_MDNS_SUFFIX_ADDR_IPV4_1) ||
            avahi_domain_ends_with_3(domain_3, AVAHI_MDNS_SUFFIX_ADDR_IPV6_4))
            *flags_8 |= AVAHI_LOOKUP_USE_MULTICAST_9;
        else
            *flags_8 |= AVAHI_LOOKUP_USE_WIDE_AREA_6;
    TCGv T00, ttyapp;
    gen_load_gpr(ttyapp, rt);
    tcg_temp_free(ttyapp);
    AvahiLookupFlags *flags;
    const char *domain;
    AvahiServer *s;
    if (!s->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
    char str2[] = ""Constant"";
    VirtioCcwDevice *dev;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    if (strcmp(str1, str2) == 0) {
        IntelHDAState *d = opaque;
    }
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xffffffff);
}",0,1,147,1.0,Insert
2636,,,,,,,
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,
                                  const uint8_t *src, int srcW, int xInc)
{
    int i;
    unsigned int xpos=0;
    for (i=0;i<dstWidth;i++) {
        register unsigned int xx=xpos>>16;
        register unsigned int xalpha=(xpos&0xFFFF)>>9;
        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
        xpos+=xInc;
    }
}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,
                                  const uint8_t *src, int srcW, int xInc)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        int i;
    }
    unsigned int xpos=0;
    for (i=0;i<dstWidth;i++) {
        register unsigned int xx=xpos>>16;
        struct super_block *sb = NULL;
        struct v9fs_session_info *gnineses = NULL;
        if (gnineses->cache == CACHE_LOOSE || gnineses->cache == CACHE_FSCACHE)
        		sb->s_d_op = &v9fs_cached_dentry_operations;
        	else
        		sb->s_d_op = &v9fs_dentry_operations;
        register unsigned int xalpha=(xpos&0xFFFF)>>9;
        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
        xpos+=xInc;
    }
}",1,0,16,0.72,Insert
2639,,,,,,,
2640,"dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)
{
        struct fs_dma_ctrl *ctrl = opaque;
	int c;
	uint32_t r = 0;
	if (size != 4) {
		dma_rinvalid(opaque, addr);
	}
	c = fs_channel(addr);
	addr &= 0xff;
	addr >>= 2;
	switch (addr)
	{
		case RW_STAT:
			r = ctrl->channels[c].state & 7;
			r |= ctrl->channels[c].eol << 5;
			r |= ctrl->channels[c].stream_cmd_src << 8;
			break;
		default:
			r = ctrl->channels[c].regs[addr];
			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",
				  __func__, c, addr));
			break;
	}
	return r;
}","dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)
{
        struct fs_dma_ctrl *ctrl = opaque;
	int a = 34;
	int b = a;
	if(a*b>0){
    	int c;
    	DisasContext *qs;
    	uint32_t ksns;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	int wb;
    	uint32_t lvcall;
    	CPUState *env;
    	unsigned int valpages;
    	CPUState *viron;
    	qemu_irq *irq;
    	QEMUBH *rb;
    	rb = qemu_bh_new(tick_irq, viron);
    	rb = qemu_bh_new(stick_irq, viron);
    	rb = qemu_bh_new(hstick_irq, viron);
    	irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
    	uint32_t r_cause;
    	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    	uint32_t tlb_vpn, tlb_pfn = 0;
    	uint32_t tlb_vpn, tlb_pfn = 0;
    	uint32_t pid, lo, hi;
    	int set, match = 0;
    	r_cause = env->sregs[SFR_R_MM_CAUSE];
    	D_3(printf_5 (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    			  "" %x cause=%x sel=%x sp=%x %x %x
    	"",
    			  __func___10, wb, match, env->pc,
    			  lvcall, valpages,
    			  tlb_vpn, tlb_pfn, tlb_pid, 
    			  pid,
    			  r_cause,
    			  env->sregs[SFR_RW_MM_TLB_SEL],
    			  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	err = extract32(ksns, 16, 5);
    	handle_fp_compare(qs, order, coll, err, false, p);
	}
	uint32_t r = 0;
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args;
	TCGContext *service;
	tcg_insn_unit *func_addr;
	func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
	tcg_out_call(service, func_addr);
	if (size != 4) {
		dma_rinvalid(opaque, addr);
	}
	c = fs_channel(addr);
	addr &= 0xff;
	addr >>= 2;
	switch (addr)
	{
		case RW_STAT:
			r = ctrl->channels[c].state & 7;
			r |= ctrl->channels[c].eol << 5;
			r |= ctrl->channels[c].stream_cmd_src << 8;
			break;
		default:
			r = ctrl->channels[c].regs[addr];
			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",
				  __func__, c, addr));
			break;
	}
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
	                        hawdecl->nvram_size, 8);
	slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
	                          sbi_cpu_arq, smp_cpus);
	slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
	                              nographic, ESCC_CLOCK, 1);
	return r;
}",0,1,495,3.35,Insert
2641,"static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)
{
    struct pxa_frame_descriptor_s desc;
    target_phys_addr_t descptr;
    int i;
    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {
        s->dma_ch[i].source = 0;
        if (!s->dma_ch[i].up)
            continue;
        if (s->dma_ch[i].branch & FBR_BRA) {
            descptr = s->dma_ch[i].branch & FBR_SRCADDR;
            if (s->dma_ch[i].branch & FBR_BINT)
                pxa2xx_dma_bs_set(s, i);
            s->dma_ch[i].branch &= ~FBR_BRA;
        } else
            descptr = s->dma_ch[i].descriptor;
        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +
                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))
            continue;
        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));
        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);
        s->dma_ch[i].source = tswap32(desc.fsaddr);
        s->dma_ch[i].id = tswap32(desc.fidr);
        s->dma_ch[i].command = tswap32(desc.ldcmd);
    }
}","static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)
{
    struct pxa_frame_descriptor_s desc;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        Network::ConnectionEvent id;
        if (id == Network::ConnectionEvent::LocalClose ||
              id == Network::ConnectionEvent::RemoteClose) {
            downstream_closed_ = true;
        }
        target_phys_addr_t descptr;
    }
    int i;
    DescInfo *info;
    struct f2fs_sb_info *sbi;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
    		dir = ALLOC_RIGHT;
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    const AVFrame *capt;
    const AVFrame *const p = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p->linesize[0]);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {
        s->dma_ch[i].source = 0;
        if (!s->dma_ch[i].up)
            continue;
        if (s->dma_ch[i].branch & FBR_BRA) {
            descptr = s->dma_ch[i].branch & FBR_SRCADDR;
            if (s->dma_ch[i].branch & FBR_BINT)
                pxa2xx_dma_bs_set(s, i);
            s->dma_ch[i].branch &= ~FBR_BRA;
        } else
            descptr = s->dma_ch[i].descriptor;
        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +
                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))
            continue;
        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));
        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);
        s->dma_ch[i].source = tswap32(desc.fsaddr);
        s->dma_ch[i].id = tswap32(desc.fidr);
        s->dma_ch[i].command = tswap32(desc.ldcmd);
    }
}",0,1,177,1.88,Insert
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)
{
    DeviceState *qdev, **qdevs;
    BusChild *kid;
    int i, num, ret = 0;
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        num++;
    }
    qdevs = g_malloc(sizeof(qdev) * num);
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        qdevs[num++] = kid->child;
    }
    qsort(qdevs, num, sizeof(qdev), compare_reg);
    for (i = num - 1; i >= 0; i--) {
        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);
        ret = vio_make_devnode(dev, fdt);
        if (ret < 0) {
            goto out;
        }
    }
    ret = 0;
out:
    free(qdevs);
    return ret;
}","int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)
{
    DeviceState *qdev, **qdevs;
    int a = 2;
    int b = 2;
    if (a == b) {
        BusChild *kid;
    }
    int i, num, ret = 0;
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        num++;
    }
    qdevs = g_malloc(sizeof(qdev) * num);
    num = 0;
    int C, len, vv;
    len = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        qdevs[num++] = kid->child;
    }
    qsort(qdevs, num, sizeof(qdev), compare_reg);
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    for (i = num - 1; i >= 0; i--) {
        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);
        ret = vio_make_devnode(dev, fdt);
        if (ret < 0) {
            goto out;
        }
    }
    ret = 0;
out:
    free(qdevs);
    return ret;
}",0,1,68,1.19,Insert
2643,,,,,,,
2648,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,
                         int is_write, target_phys_addr_t access_len)
{
    if (buffer != bounce.buffer) {
        if (is_write) {
            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);
            while (access_len) {
                unsigned l;
                l = TARGET_PAGE_SIZE;
                if (l > access_len)
                    l = access_len;
                invalidate_and_set_dirty(addr1, l);
                addr1 += l;
                access_len -= l;
            }
        }
        if (xen_enabled()) {
            xen_invalidate_map_cache_entry(buffer);
        }
        return;
    }
    if (is_write) {
        address_space_write(as, bounce.addr, bounce.buffer, access_len);
    }
    qemu_vfree(bounce.buffer);
    bounce.buffer = NULL;
    cpu_notify_map_clients();
}","void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,
                         int is_write, target_phys_addr_t access_len)
{
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    const GF_PropertyValue *proc;
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
    if (buffer != bounce.buffer) {
        if (is_write) {
            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);
            Visitor *inv;
            MpegEncContext *ses;
            MotionEstContext * const k= &ses->me;
            MotionEstContext * const k= &ses->me;
            k->avctx= ses->avctx;
            ff_set_cmp(&ses->dsp, ses->dsp.me_pre_cmp, k->avctx->me_pre_cmp);
            ff_set_cmp(&ses->dsp, ses->dsp.me_cmp, k->avctx->me_cmp);
            ff_set_cmp(&ses->dsp, ses->dsp.me_sub_cmp, k->avctx->me_sub_cmp);
            ff_set_cmp(&ses->dsp, ses->dsp.mb_cmp, k->avctx->mb_cmp);
            unsigned maxpages;
            size_t *start;
            struct iov_iter *i;
            unsigned int iter_head, npages;
            unsigned int iter_head, npages;
            size_t capacity;
            npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
            capacity = min(npages, maxpages) * PAGE_SIZE - *start;
            QObject **output;
            const char *path;
            QEMUBH *phi;
            phi->cb = cb;
            QmpOutputVisitor *quoo = to_qov(inv);
            qmp_output_add_obj(quoo, path, *output);
            while (access_len) {
                unsigned l;
                l = TARGET_PAGE_SIZE;
                if (l > access_len)
                    l = access_len;
                invalidate_and_set_dirty(addr1, l);
                addr1 += l;
                access_len -= l;
            }
        }
        if (xen_enabled()) {
            xen_invalidate_map_cache_entry(buffer);
        }
        return;
    }
    if (is_write) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            address_space_write(as, bounce.addr, bounce.buffer, access_len);
        }
    }
    qemu_vfree(bounce.buffer);
    bounce.buffer = NULL;
    cpu_notify_map_clients();
}",0,1,163,1.48,Insert
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
#ifdef DEBUG_UNASSIGNED
    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);
#endif
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    do_unassigned_access(addr, 0, 0, 0, 4);
#endif
    return 0;
}","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
MOVContext *c;
AVIOContext *pb;
uint8_t type[5] = {0};
avio_read(pb, type, 4);
av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
"",(char *)&type);
av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
#ifdef DEBUG_UNASSIGNED
    int a = 2;
    int b = 3;
    while (a != b) {
        printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);
        b = a;
    }
#endif
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    do_unassigned_access(addr, 0, 0, 0, 4);
#endif
    return 0;
}",1,0,7,0.41,Insert
2651,,,,,,,
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)
{
    int i;
    for (i = 0; i < vs->num_queues + 2; i++) {
        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);
    }
    pc_alloc_uninit(vs->alloc);
    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));
    g_free(vs->dev);
    qpci_free_pc(vs->bus);
    g_free(vs);
}","static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)
{
    int i;
    for (i = 0; i < vs->num_queues + 2; i++) {
        int a = 2;
        int b = 3;
        char **names;
        char *p;
        char *ea_namelist = smallbuf;
        size_t num_names;
        for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
        		names[num_names++] = p;
        }
        if (a != b) {
            qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);
        }
    }
    pc_alloc_uninit(vs->alloc);
    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));
    g_free(vs->dev);
    qpci_free_pc(vs->bus);
    g_free(vs);
}",0,1,30,0.74,Insert
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    sPAPREventLogEntry *entry = NULL;
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
        g_free(entry->extended_log);
        g_free(entry);
    }
}","void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    sPAPREventLogEntry *entry = NULL;
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
        g_free(entry->extended_log);
        int a = 2;
        int b = 2;
        if (a == b) {
            g_free(entry);
            unsigned long array;
            struct net_bridge_mdb_entry *this = (void *)array;
            if (this->ports)
            		goto out;
        }
        struct QemuInputEventQueueHead *queue;
        QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
        QTAILQ_INSERT_TAIL(queue, item, node);
        queue_count++;
    }
}",0,1,42,0.45,Insert
2654,"static void sclp_set_write_mask(void)
{
    WriteEventMask *sccb = (void*)_sccb;
    sccb->h.length = sizeof(WriteEventMask);
    sccb->mask_length = sizeof(unsigned int);
    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);
}","static void sclp_set_write_mask(void)
{
    WriteEventMask *sccb = (void*)_sccb;
    int a = 2;
    int b = 3;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    if (this->ports)
    		goto out;
    while (a != b) {
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
        sccb->h.length = sizeof(WriteEventMask);
        b = a;
    }
    sccb->mask_length = sizeof(unsigned int);
    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);
}",0,1,49,0.59,Insert
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)
{
    json_emit_element(json, name);
    qstring_append_int(json->str, val);
}","void json_prop_int(QJSON *json, const char *name, int64_t val)
{
    u16 request;
    int browser;
    dictt.SetInteger(""windex"", browserpath);
    bool from_ap;
    struct sk_buff *img;
    if (from_ap && request)
    		NLA_PUT_U16(img, NL80211_ATTR_REASON_CODE, request);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        json_emit_element(json, name);
    }
    qstring_append_int(json->str, val);
}",0,1,40,0.42,Insert
2656,"static void pm_update_sci(PIIX4PMState *s)
{
    int sci_level, pmsts;
    pmsts = acpi_pm1_evt_get_sts(&s->ar);
    sci_level = (((pmsts & s->ar.pm1.evt.en) &
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |
                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||
        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &
          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);
    qemu_set_irq(s->irq, sci_level);
    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
}","static void pm_update_sci(PIIX4PMState *s)
{
    int sci_level, pmsts;
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    int a = 50;
    int b = a;
    if(a*b>0){
        pmsts = acpi_pm1_evt_get_sts(&s->ar);
    }
    sci_level = (((pmsts & s->ar.pm1.evt.en) &
    int nb_oargs;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |
                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||
        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &
          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);
    qemu_set_irq(s->irq, sci_level);
    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
}",0,1,72,0.98,Insert
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->and) | s->or;
    return (((S + bit) << s->shift) - bit) << s->post_shift;
}","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            char str[] = ""Constant"";
            AVFormatContext *s_1;
            MpegTSWrite *ts = s_1->priv_data;
            MpegTSWrite *ts = s_1->priv_data;
            ts->sdt.write_packet = section_write_packet;
            ts->sdt.opaque       = s_1;
            ts->last_pat_ts = AV_NOPTS_VALUE;
            ts->last_sdt_ts = AV_NOPTS_VALUE;
            ts->pat_packet_count      = ts->pat_packet_period - 1;
            if (strlen(str) > 0) {
                *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
            }
        }
    }
    bit = (S & s->and) | s->or;
    return (((S + bit) << s->shift) - bit) << s->post_shift;
}",1,0,17,0.77,Insert
2658,,,,,,,
2659,,,,,,,
2660,"static void dump_human_image_check(ImageCheck *check)
{
    if (!(check->corruptions || check->leaks || check->check_errors)) {
        printf(""No errors were found on the image.\n"");
    } else {
        if (check->corruptions) {
            printf(""\n%"" PRId64 "" errors were found on the image.\n""
                ""Data may be corrupted, or further writes to the image ""
                ""may corrupt it.\n"",
                check->corruptions);
        }
        if (check->leaks) {
            printf(""\n%"" PRId64 "" leaked clusters were found on the image.\n""
                ""This means waste of disk space, but no harm to data.\n"",
                check->leaks);
        }
        if (check->check_errors) {
            printf(""\n%"" PRId64 "" internal errors have occurred during the check.\n"",
                check->check_errors);
        }
    }
    if (check->total_clusters != 0 && check->allocated_clusters != 0) {
        printf(""%"" PRId64 ""/%"" PRId64 ""= %0.2f%% allocated, %0.2f%% fragmented\n"",
        check->allocated_clusters, check->total_clusters,
        check->allocated_clusters * 100.0 / check->total_clusters,
        check->fragmented_clusters * 100.0 / check->allocated_clusters);
    }
    if (check->image_end_offset) {
        printf(""Image end offset: %"" PRId64 ""\n"", check->image_end_offset);
    }
}","static void dump_human_image_check(ImageCheck *check)
{
    if (!(check->corruptions || check->leaks || check->check_errors)) {
        printf(""No errors were found on the image.\n"");
    } else {
        if (check->corruptions) {
            printf(""\n%"" PRId64 "" errors were found on the image.\n""
                ""Data may be corrupted, or further writes to the image ""
                ""may corrupt it.\n"",
                check->corruptions);
        }
        if (check->leaks) {
            printf(""\n%"" PRId64 "" leaked clusters were found on the image.\n""
                ""This means waste of disk space, but no harm to data.\n"",
                check->leaks);
        }
        if (check->check_errors) {
            printf(""\n%"" PRId64 "" internal errors have occurred during the check.\n"",
                check->check_errors);
        }
    }
    if (check->total_clusters != 0 && check->allocated_clusters != 0) {
        printf(""%"" PRId64 ""/%"" PRId64 ""= %0.2f%% allocated, %0.2f%% fragmented\n"",
        check->allocated_clusters, check->total_clusters,
        check->allocated_clusters * 100.0 / check->total_clusters,
        check->fragmented_clusters * 100.0 / check->allocated_clusters);
    }
    if (check->image_end_offset) {
        Image *image;
        const LayerInfo* layer_info;
        const size_t url;
        MagickOffsetType
            offset;
        MagickStatusType
            status;
        if (status == MagickFalse)
            SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            printf(""Image end offset: %"" PRId64 ""\n"", check->image_end_offset);
        strcpy(str, ""a"");
        }
    }
}",0,1,13,0.77,Insert
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )
{
    flag zSign;
    if ( a == 0 ) return 0;
    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
}","float32 int32_to_float32( int32 a STATUS_PARAM )
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        RCore *model;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsil *esil = model->anal->esil;
        RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
        eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
        "");
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, end, NULL, &prev, false);
        r_anal_esil_session_set (esil, before);
        r_core_esil_step (model, prev, NULL, NULL, false);
        flag zSign;
    }
    if ( a == 0 ) return 0;
    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
}",0,1,8,0.39,Insert
2662,,,,,,,
2663,,,,,,,
2664,"void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    CPUState *cs;
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
#endif
}","void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    CPUState *cs;
    CPU_FOREACH(cs) {
        int a = 2;
        int i, qa;
        qa = libusb_init(&ctx);
        int b = 3;
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
        if (a != b) {
            int w;
            qemu_irq rx[128];
            DeviceState *mem = NULL;
            for (w = 0; w < 128; w++) {
                    rx[w] = qdev_get_gpio_in(mem, w);
            }
            X86CPU *cpu = X86_CPU(cs);
        }
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
#endif
}",0,1,79,0.78,Insert
2665,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,
                            void *l3hdr, size_t l3hdr_len,
                            size_t l3payload_len,
                            size_t frag_offset, bool more_frags)
{
    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {
        uint16_t orig_flags;
        struct ip_header *iphdr = (struct ip_header *) l3hdr;
        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;
        uint16_t new_ip_off;
        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);
        assert((frag_off_units & ~IP_OFFMASK) == 0);
        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);
        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);
        iphdr->ip_off = cpu_to_be16(new_ip_off);
        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
    }
}","eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,
                            void *l3hdr, size_t l3hdr_len,
                            size_t l3payload_len,
                            size_t frag_offset, bool more_frags)
{
    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {
        uint16_t orig_flags;
        struct ip_header *iphdr = (struct ip_header *) l3hdr;
        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        attribute=GetXMLTreeAttribute(levels,""width"");
        table->width=StringToUnsignedLong(attribute);
        attribute=GetXMLTreeAttribute(levels,""height"");
        table->height=StringToUnsignedLong(attribute);
        int a = 2;
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        int b = 2;
        if (a == b) {
            uint16_t new_ip_off;
        }
        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);
        assert((frag_off_units & ~IP_OFFMASK) == 0);
        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);
        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);
        iphdr->ip_off = cpu_to_be16(new_ip_off);
        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
    }
}",0,1,59,0.86,Insert
2667,"do_cksum(uint8_t *dp, uint8_t *de)
{
    unsigned int bsum[2] = {0, 0}, i, sum;
    for (i = 1; dp < de; bsum[i^=1] += *dp++)
        ;
    sum = (bsum[0] << 8) + bsum[1];
    sum = (sum >> 16) + (sum & 0xffff);
    return ~(sum + (sum >> 16));
}","do_cksum(uint8_t *dp, uint8_t *de)
{
    int a = 2;
    int b = 2;
    RAMBlock *news_work;
    news_work = g_malloc0(sizeof(*news_work));
    news_work->err = err;
    news_work->realized = realized;
    news_work->used_length = size;
    news_work->max_length = maxlennumber;
    if (a == b) {
        unsigned int bsum[2] = {0, 0}, i, sum;
    }
    for (i = 1; dp < de; bsum[i^=1] += *dp++)
        ;
    sum = (bsum[0] << 8) + bsum[1];
    sum = (sum >> 16) + (sum & 0xffff);
    return ~(sum + (sum >> 16));
}",0,1,40,0.72,Insert
2668,"static void ics_simple_realize(DeviceState *dev, Error **errp)
{
    ICSState *ics = ICS_SIMPLE(dev);
    if (!ics->nr_irqs) {
        error_setg(errp, ""Number of interrupts needs to be greater 0"");
        return;
    }
    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));
    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);
    qemu_register_reset(ics_simple_reset, dev);
}","static void ics_simple_realize(DeviceState *dev, Error **errp)
{
    int a = 2;
    int b = 2;
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    while (a == b) {
        ICSState *ics = ICS_SIMPLE(dev);
        b += 1;
    }
    if (!ics->nr_irqs) {
        const char *data;
        int data;
        BlockDriver *yrf = NULL;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        BlockDriverState *bes;
        int  rows;
        data = bes->open_flags | BDRV_O_RDWR;
        rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
        error_setg(errp, ""Number of interrupts needs to be greater 0"");
        return;
    }
    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));
    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);
    qemu_register_reset(ics_simple_reset, dev);
}",0,1,48,0.61,Insert
2669,"static void vnc_flush(VncState *vs)
{
    if (vs->output.offset)
	vnc_client_write(vs);
}","static void vnc_flush(VncState *vs)
{
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (vs->output.offset)
	vnc_client_write(vs);
}",0,1,6,0.18,Insert
2670,"static void do_subchannel_work(SubchDev *sch, ORB *orb)
{
    SCSW *s = &sch->curr_status.scsw;
    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {
        sch_handle_clear_func(sch);
    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {
        sch_handle_halt_func(sch);
    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {
        sch_handle_start_func(sch, orb);
    } else {
        return;
    }
    css_inject_io_interrupt(sch);
}","static void do_subchannel_work(SubchDev *sch, ORB *orb)
{
    SCSW *s = &sch->curr_status.scsw;
    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {
        sch_handle_clear_func(sch);
    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {
        sch_handle_halt_func(sch);
    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {
        sch_handle_start_func(sch, orb);
    } else {
        int lang, rar;
        const char *request= ""DROP TABLE IF EXISTS test_table;""
                             ""CREATE TABLE test_table(id INT);""
                             ""INSERT INTO test_table VALUES(10);""
                             ""UPDATE test_table SET id=20 WHERE id=10;""
                             ""SELECT * FROM test_table;""
                             ""INSERT INTO non_existent_table VALUES(11);"";
        MYSQL *mysql___global;
        lang= mysql_query(mysql___global, request);
        myquery(lang);
        lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
        myquery(lang);
        return;
    }
    int a = 2;
    int b = a;
    if(a*b>0){
        css_inject_io_interrupt(sch);
    }
}",0,1,39,0.67,Insert
2672,,,,,,,
2675,"VncJob *vnc_job_new(VncState *vs)
{
    VncJob *job = g_malloc0(sizeof(VncJob));
    job->vs = vs;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}","VncJob *vnc_job_new(VncState *vs)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        VncJob *job = g_malloc0(sizeof(VncJob));
        b += 1;
    }
    job->vs = vs;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}",1,0,2,0.05,Replace
2676,,,,,,,
2677,"static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)
{
    NvmeSQueue *sq;
    NvmeCreateSq *c = (NvmeCreateSq *)cmd;
    uint16_t cqid = le16_to_cpu(c->cqid);
    uint16_t sqid = le16_to_cpu(c->sqid);
    uint16_t qsize = le16_to_cpu(c->qsize);
    uint16_t qflags = le16_to_cpu(c->sq_flags);
    uint64_t prp1 = le64_to_cpu(c->prp1);
    if (!cqid || nvme_check_cqid(n, cqid)) {
        return NVME_INVALID_CQID | NVME_DNR;
    }
    if (!sqid || !nvme_check_sqid(n, sqid)) {
        return NVME_INVALID_QID | NVME_DNR;
    }
    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {
        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;
    }
    if (!prp1 || prp1 & (n->page_size - 1)) {
        return NVME_INVALID_FIELD | NVME_DNR;
    }
    if (!(NVME_SQ_FLAGS_PC(qflags))) {
        return NVME_INVALID_FIELD | NVME_DNR;
    }
    sq = g_malloc0(sizeof(*sq));
    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);
    return NVME_SUCCESS;
}","static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)
{
    NvmeSQueue *sq;
    NvmeCreateSq *c = (NvmeCreateSq *)cmd;
    uint16_t cqid = le16_to_cpu(c->cqid);
    uint16_t sqid = le16_to_cpu(c->sqid);
    uint16_t qsize = le16_to_cpu(c->qsize);
    uint16_t qflags = le16_to_cpu(c->sq_flags);
    uint64_t prp1 = le64_to_cpu(c->prp1);
    if (!cqid || nvme_check_cqid(n, cqid)) {
        return NVME_INVALID_CQID | NVME_DNR;
    }
    if (!sqid || !nvme_check_sqid(n, sqid)) {
        return NVME_INVALID_QID | NVME_DNR;
    }
    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {
        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;
    }
    if (!prp1 || prp1 & (n->page_size - 1)) {
        return NVME_INVALID_FIELD | NVME_DNR;
    }
    if (!(NVME_SQ_FLAGS_PC(qflags))) {
        return NVME_INVALID_FIELD | NVME_DNR;
    }
    sq = g_malloc0(sizeof(*sq));
    int a = 2;
    int b = 3;
    while (a < b) {
        nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);
        b = a;
    }
    return NVME_SUCCESS;
}",1,0,10,0.18,Replace
2679,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,
                int x, int y, int w, int h)
{
    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];
    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;
    rect->x = x;
    rect->y = y;
    rect->w = w;
    rect->h = h;
}","static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,
                int x, int y, int w, int h)
{
    int a = 2;
    int b = 3;
    struct ldb_context *ydm;
    AVCodecContext *ajcas;
    DCAContext *s_4 = ajcas->priv_data;
    int num_core_channels = 0;
    int channels, full_channels;
    int channels, full_channels;
    num_core_channels = s_4->prim_channels;
    full_channels = channels = s_4->prim_channels + !!s_4->lfe;
    const char *attr;
    const struct ldb_schema_attribute *a_5;
    a_5 = ldb_schema_attribute_by_name(ydm, attr);
    while (a < b) {
        struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];
        b = a;
    }
    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;
    rect->x = x;
    rect->y = y;
    rect->w = w;
    rect->h = h;
}",0,1,44,0.68,Insert
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			c = tcg_temp_new(TCG_TYPE_TL);
			t_gen_mov_TN_preg(c, PR_CCS);
			tcg_gen_andi_tl(c, c, C_FLAG);
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		x = tcg_temp_new(TCG_TYPE_TL);
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(c, x);
		tcg_gen_andi_tl(c, c, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}","static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			int a = 2;
			int b = 2;
			int rows;
			int rd;
			const char *opn = ""loongson"";
			TCGv T00, ttyapp;
			gen_load_gpr(T00, rows);
			MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rows]);
			while (a == b) {
    			c = tcg_temp_new(TCG_TYPE_TL);
    			b += 1;
			}
			t_gen_mov_TN_preg(c, PR_CCS);
			tcg_gen_andi_tl(c, c, C_FLAG);
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		x = tcg_temp_new(TCG_TYPE_TL);
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(c, x);
		tcg_gen_andi_tl(c, c, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}",0,1,54,1.27,Insert
2681,"static void rtas_start_cpu(sPAPREnvironment *spapr,
                           uint32_t token, uint32_t nargs,
                           target_ulong args,
                           uint32_t nret, target_ulong rets)
{
    target_ulong id, start, r3;
    CPUState *cs;
    if (nargs != 3 || nret != 1) {
        rtas_st(rets, 0, -3);
        return;
    }
    id = rtas_ld(args, 0);
    start = rtas_ld(args, 1);
    r3 = rtas_ld(args, 2);
    cs = qemu_get_cpu(id);
    if (cs != NULL) {
        PowerPCCPU *cpu = POWERPC_CPU(cs);
        CPUPPCState *env = &cpu->env;
        if (!cs->halted) {
            rtas_st(rets, 0, -1);
            return;
        }
        kvm_cpu_synchronize_state(cs);
        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);
        env->nip = start;
        env->gpr[3] = r3;
        cs->halted = 0;
        qemu_cpu_kick(cs);
        rtas_st(rets, 0, 0);
        return;
    }
    rtas_st(rets, 0, -3);
}","static void rtas_start_cpu(sPAPREnvironment *spapr,
                           uint32_t token, uint32_t nargs,
                           target_ulong args,
                           uint32_t nret, target_ulong rets)
{
    target_ulong id, start, r3;
    int a = 2;
    int b = 3;
    while (a != b) {
        CPUState *cs;
        b = a;
    }
    if (nargs != 3 || nret != 1) {
        rtas_st(rets, 0, -3);
        return;
    }
    id = rtas_ld(args, 0);
    start = rtas_ld(args, 1);
    r3 = rtas_ld(args, 2);
    cs = qemu_get_cpu(id);
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    if (cs != NULL) {
        PowerPCCPU *cpu = POWERPC_CPU(cs);
        u8 * Datapp;
        struct wmi_disconnect_event *dev;
        dev = (struct wmi_disconnect_event *)  Datapp;
        CPUPPCState *env = &cpu->env;
        XMLTreeInfo
        int port, i, status, r;
        RTSPHeader reply1, *reply = &reply1;
        if (reply->status_code != RTSP_STATUS_OK) {
                r = AVERROR_INVALIDDATA;
                GF_Filter *process;
                GF_FilterPid *pid;
                CTXLoadPriv *git = gf_filter_get_udta(process);
                struct sk_buff *skb;
                struct sock *sk;
                struct tcp_sock *tp = tcp_sk(sk);
                u32 length, end64seq;
                struct tcp_sock *tp = tcp_sk(sk);
                u32 length, end64seq;
                SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
                "",
                		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
                length = TCP_SKB_CB(skb)->length;
                gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
                gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
                gf_filter_pid_set_udta(pid, git->out_pid);
                git->file_size = 0;
                git->load_flags = 0;
                goto fail;
        }
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        xml=FileToString(filename,~0UL,exception);
        quantization_tables=NewXMLTree(xml,exception);
        xml=DestroyString(xml);
        if (!cs->halted) {
            rtas_st(rets, 0, -1);
            return;
        }
        kvm_cpu_synchronize_state(cs);
        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);
        env->nip = start;
        env->gpr[3] = r3;
        cs->halted = 0;
        qemu_cpu_kick(cs);
        rtas_st(rets, 0, 0);
        return;
    }
    rtas_st(rets, 0, -3);
}",0,1,913,5.39,Insert
2682,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)
{
    DeviceState *qdev;
    i2c_slave *slave = NULL;
    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {
        slave = I2C_SLAVE_FROM_QDEV(qdev);
        if (slave->address == address)
            break;
    }
    if (!slave)
        return 1;
    bus->current_dev = slave;
    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);
    return 0;
}","int i2c_start_transfer(i2c_bus *bus, int address, int recv)
{
    DeviceState *qdev;
    int a = 2;
    int b = 3;
    while (a != b) {
        i2c_slave *slave = NULL;
        b = a;
        Unit *u;
        Unit *other;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        int64_t unit;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
        aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
        aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
        unsigned char c;
        double vals, mul, integral, fraction;
        int64_t retval;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        retval = vals * mul;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
        int range;
        Automount *worker = AUTOMOUNT(u);
        if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                        (void) automount_send_ready(worker, worker->tokens, 0);
                        range = automount_start_expire(worker);
                        if (range < 0)
                                log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                        automount_set_state(worker, AUTOMOUNT_RUNNING);
        }
    }
    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {
        slave = I2C_SLAVE_FROM_QDEV(qdev);
        if (slave->address == address)
            break;
    }
    if (!slave)
        return 1;
    bus->current_dev = slave;
    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);
    return 0;
}",0,1,119,1.22,Insert
2685,,,,,,,
2686,,,,,,,
2688,"static void *thread_func(void *p)
{
    struct thread_info *info = p;
    rcu_register_thread();
    atomic_inc(&n_ready_threads);
    while (!atomic_mb_read(&test_start)) {
        cpu_relax();
    }
    rcu_read_lock();
    while (!atomic_read(&test_stop)) {
        info->r = xorshift64star(info->r);
        info->func(info);
    }
    rcu_read_unlock();
    rcu_unregister_thread();
    return NULL;
}","static void *thread_func(void *p)
{
    Rocker *r;
    DescInfo *info_10;
    char *buf = desc_get_buf(info_10, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info_10, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_10));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info_10));
    struct thread_info *info = p;
    rcu_register_thread();
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        atomic_inc(&n_ready_threads);
    }
    while (!atomic_mb_read(&test_start)) {
        cpu_relax();
    }
    rcu_read_lock();
    while (!atomic_read(&test_stop)) {
        info->r = xorshift64star(info->r);
        info->func(info);
    }
    rcu_read_unlock();
    rcu_unregister_thread();
    return NULL;
}",0,1,21,0.5,Insert
2689,"static int http_start_receive_data(HTTPContext *c)
{
    int fd;
    if (c->stream->feed_opened)
        return -1;
    if (c->stream->readonly)
        return -1;
    fd = open(c->stream->feed_filename, O_RDWR);
    if (fd < 0) {
        http_log(""Error opening feeder file: %s\n"", strerror(errno));
        return -1;
    }
    c->feed_fd = fd;
    if (c->stream->truncate) {
        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);
        ftruncate(c->feed_fd, FFM_PACKET_SIZE);
        http_log(""Truncating feed file '%s'\n"", c->stream->feed_filename);
    } else {
        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {
            http_log(""Error reading write index from feed file: %s\n"", strerror(errno));
            return -1;
        }
    }
    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);
    c->stream->feed_size = lseek(fd, 0, SEEK_END);
    lseek(fd, 0, SEEK_SET);
    c->buffer_ptr = c->buffer;
    c->buffer_end = c->buffer + FFM_PACKET_SIZE;
    c->stream->feed_opened = 1;
    c->chunked_encoding = !!av_stristr(c->buffer, ""Transfer-Encoding: chunked"");
    return 0;
}","static int http_start_receive_data(HTTPContext *c)
{
    int fd;
    if (c->stream->feed_opened)
        return -1;
    if (c->stream->readonly)
        return -1;
    fd = open(c->stream->feed_filename, O_RDWR);
    if (fd < 0) {
        http_log(""Error opening feeder file: %s\n"", strerror(errno));
        return -1;
    }
    c->feed_fd = fd;
    if (c->stream->truncate) {
        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            ftruncate(c->feed_fd, FFM_PACKET_SIZE);
        strcpy(str, ""a"");
        }
        http_log(""Truncating feed file '%s'\n"", c->stream->feed_filename);
    } else {
        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {
            http_log(""Error reading write index from feed file: %s\n"", strerror(errno));
            return -1;
            struct fp *fp;
            int pet;
            pet = seq_open(fp, &show_traces_seq_ops);
        }
    }
    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);
    c->stream->feed_size = lseek(fd, 0, SEEK_END);
    lseek(fd, 0, SEEK_SET);
    c->buffer_ptr = c->buffer;
    c->buffer_end = c->buffer + FFM_PACKET_SIZE;
    c->stream->feed_opened = 1;
    c->chunked_encoding = !!av_stristr(c->buffer, ""Transfer-Encoding: chunked"");
    return 0;
}",0,1,33,1.18,Insert
2692,,,,,,,
2693,,,,,,,
2695,"static void kvm_start_vcpu(CPUState *env)
{
    env->thread = qemu_mallocz(sizeof(QemuThread));
    env->halt_cond = qemu_mallocz(sizeof(QemuCond));
    qemu_cond_init(env->halt_cond);
    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);
    while (env->created == 0)
        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);
}","static void kvm_start_vcpu(CPUState *env)
{
    env->thread = qemu_mallocz(sizeof(QemuThread));
    struct edgeport_serial *serial;
    u8 *data;
    int status;
    struct device *dev = &serial->serial->dev->dev;
    if (status)
    		dev_dbg(dev, ""%s - read 2 status error = %d
    "", __func__, status);
    	else
    		dev_dbg(dev, ""%s - read 2 data = 0x%x
    "", __func__, *data);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        env->halt_cond = qemu_mallocz(sizeof(QemuCond));
    }
    qemu_cond_init(env->halt_cond);
    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);
    while (env->created == 0)
        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);
}",0,1,10,0.32,Insert
2696,"static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,
                                     bool secondary, target_ulong ptem,
                                     ppc_hash_pte64_t *pte)
{
    CPUPPCState *env = &cpu->env;
    int i;
    uint64_t token;
    target_ulong pte0, pte1;
    target_ulong pte_index;
    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;
    token = ppc_hash64_start_access(cpu, pte_index);
    if (!token) {
        return -1;
    }
    for (i = 0; i < HPTES_PER_GROUP; i++) {
        pte0 = ppc_hash64_load_hpte0(cpu, token, i);
        pte1 = ppc_hash64_load_hpte1(cpu, token, i);
        if ((pte0 & HPTE64_V_VALID)
            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))
            && HPTE64_V_COMPARE(pte0, ptem)) {
            pte->pte0 = pte0;
            pte->pte1 = pte1;
            ppc_hash64_stop_access(token);
            return (pte_index + i) * HASH_PTE_SIZE_64;
        }
    }
    ppc_hash64_stop_access(token);
    return -1;
}","static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,
                                     bool secondary, target_ulong ptem,
                                     ppc_hash_pte64_t *pte)
{
    CPUPPCState *env = &cpu->env;
    int i;
    uint64_t token;
    target_ulong pte0, pte1;
    target_ulong pte_index;
    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;
    token = ppc_hash64_start_access(cpu, pte_index);
    if (!token) {
        int a = 30;
        int b = a;
        if(a*b>0){
            return -1;
        }
    }
    for (i = 0; i < HPTES_PER_GROUP; i++) {
        pte0 = ppc_hash64_load_hpte0(cpu, token, i);
        pte1 = ppc_hash64_load_hpte1(cpu, token, i);
        if ((pte0 & HPTE64_V_VALID)
            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))
            && HPTE64_V_COMPARE(pte0, ptem)) {
            pte->pte0 = pte0;
            pte->pte1 = pte1;
            ppc_hash64_stop_access(token);
            gpointer opsaques;
            const ARMCPRegInfo *ry;
            ARMCPU *GPU = opsaques;
            uint64_t rigindx;
            ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
            return (pte_index + i) * HASH_PTE_SIZE_64;
        }
    }
    ppc_hash64_stop_access(token);
    return -1;
}",0,1,41,1.04,Insert
2697,"static av_cold int dcadec_init(AVCodecContext *avctx)
{
    DCAContext *s = avctx->priv_data;
    s->avctx = avctx;
    s->core.avctx = avctx;
    s->exss.avctx = avctx;
    s->xll.avctx = avctx;
    s->lbr.avctx = avctx;
    ff_dca_init_vlcs();
    if (ff_dca_core_init(&s->core) < 0)
        return AVERROR(ENOMEM);
    if (ff_dca_lbr_init(&s->lbr) < 0)
        return AVERROR(ENOMEM);
    ff_dcadsp_init(&s->dcadsp);
    s->core.dcadsp = &s->dcadsp;
    s->xll.dcadsp = &s->dcadsp;
    s->lbr.dcadsp = &s->dcadsp;
    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);
    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {
    case 0:
        s->request_channel_layout = 0;
        break;
    case AV_CH_LAYOUT_STEREO:
    case AV_CH_LAYOUT_STEREO_DOWNMIX:
        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;
        break;
    case AV_CH_LAYOUT_5POINT0:
        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;
        break;
    case AV_CH_LAYOUT_5POINT1:
        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1;
        break;
    default:
        av_log(avctx, AV_LOG_WARNING, ""Invalid request_channel_layout\n"");
        break;
    }
    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;
    avctx->bits_per_raw_sample = 24;
    return 0;
}","static av_cold int dcadec_init(AVCodecContext *avctx)
{
    DCAContext *s = avctx->priv_data;
    s->avctx = avctx;
    s->core.avctx = avctx;
    s->exss.avctx = avctx;
    s->xll.avctx = avctx;
    s->lbr.avctx = avctx;
    ff_dca_init_vlcs();
    if (ff_dca_core_init(&s->core) < 0)
        return AVERROR(ENOMEM);
    if (ff_dca_lbr_init(&s->lbr) < 0)
        return AVERROR(ENOMEM);
    ff_dcadsp_init(&s->dcadsp);
    s->core.dcadsp = &s->dcadsp;
    s->xll.dcadsp = &s->dcadsp;
    s->lbr.dcadsp = &s->dcadsp;
    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);
    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {
    case 0:
        s->request_channel_layout = 0;
        break;
    case AV_CH_LAYOUT_STEREO:
    case AV_CH_LAYOUT_STEREO_DOWNMIX:
        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;
        break;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
    case AV_CH_LAYOUT_5POINT0:
        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;
        break;
    case AV_CH_LAYOUT_5POINT1:
        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1;
        break;
    default:
        av_log(avctx, AV_LOG_WARNING, ""Invalid request_channel_layout\n"");
        break;
    }
    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;
    avctx->bits_per_raw_sample = 24;
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
    }
}",0,1,83,1.28,Insert
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)
{
    val = tswap64(val);
    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));
}","void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)
{
    val = tswap64(val);
    RBuffer *b_5;
    ut64 len;
    ut8 *buf;
    st64 o_addr = r_buf_seek (b_5, 0, R_BUF_CUR);
    r = r_buf_read (b_5, buf, len);
    int a = 2;
    int b = 3;
    while (a < b) {
        spapr_tce_dma_write(dev, taddr, &val, sizeof(val));
        b = a;
    }
}",1,0,5,0.34,Insert
2701,,,,,,,
2702,"static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *pnum)
{
    BDRVParallelsState *s = bs->opaque;
    int64_t offset;
    qemu_co_mutex_lock(&s->lock);
    offset = block_status(s, sector_num, nb_sectors, pnum);
    qemu_co_mutex_unlock(&s->lock);
    if (offset < 0) {
        return 0;
    }
    return (offset << BDRV_SECTOR_BITS) |
        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;
}","static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *pnum)
{
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i, size, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size   = put_bits_count(&pb) >> 3;
        offset_6;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset_6+layer_info->channel_info[url].size-2,SEEK_SET);
    int a = 2;
    struct ldb_context *ydm;
    const char *attr;
    const struct ldb_schema_attribute *a_10;
    a_10 = ldb_schema_attribute_by_name(ydm, attr);
    int b = 3;
    struct dir *dir;
    struct proc_mounts *p = dir->private_data;
    if (mnt_had_events(p))
    		res |= POLLERR | POLLPRI;
    while (a != b) {
        BDRVParallelsState *s = bs->opaque;
        b = a;
    }
    int64_t offset;
    qemu_co_mutex_lock(&s->lock);
    offset = block_status(s, sector_num, nb_sectors, pnum);
    qemu_co_mutex_unlock(&s->lock);
    if (offset < 0) {
        return 0;
    }
    return (offset << BDRV_SECTOR_BITS) |
        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;
}",0,1,104,1.01,Insert
2704,,,,,,,
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
    RET_STOP(ctx);
}","static void spr_write_601_ubatu (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
    }
    RET_STOP(ctx);
}",0,1,19,0.28,Insert
2706,"static void ide_sector_write(IDEState *s)
{
    int64_t sector_num;
    int ret, n, n1;
    s->status = READY_STAT | SEEK_STAT;
    sector_num = ide_get_sector(s);
#if defined(DEBUG_IDE)
    printf(""write sector=%Ld\n"", sector_num);
#endif
    n = s->nsector;
    if (n > s->req_nb_sectors)
        n = s->req_nb_sectors;
    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);
    s->nsector -= n;
    if (s->nsector == 0) {
        ide_transfer_stop(s);
    } else {
        n1 = s->nsector;
        if (n1 > s->req_nb_sectors)
            n1 = s->req_nb_sectors;
        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);
    }
    ide_set_sector(s, sector_num + n);
#ifdef TARGET_I386
    if (win2k_install_hack) {
        qemu_mod_timer(s->sector_write_timer, 
                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));
    } else 
#endif
    {
        ide_set_irq(s);
    }
}","static void ide_sector_write(IDEState *s)
{
    int64_t sector_num;
    int ret, n, n1;
    char str[] = ""Constant"";
    BlockdevOnError on_source_bug;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table->slot=(char *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    while (strlen(str) > 5) {
        s->status = READY_STAT | SEEK_STAT;
    strcpy(str, ""a"");
    }
    sector_num = ide_get_sector(s);
#if defined(DEBUG_IDE)
    printf(""write sector=%Ld\n"", sector_num);
#endif
    n = s->nsector;
    if (n > s->req_nb_sectors)
        n = s->req_nb_sectors;
    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);
    s->nsector -= n;
    if (s->nsector == 0) {
        ide_transfer_stop(s);
    } else {
        n1 = s->nsector;
        if (n1 > s->req_nb_sectors)
            n1 = s->req_nb_sectors;
        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);
    }
    ide_set_sector(s, sector_num + n);
#ifdef TARGET_I386
    if (win2k_install_hack) {
        qemu_mod_timer(s->sector_write_timer, 
                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));
    } else 
#endif
    {
        ide_set_irq(s);
    }
}",0,1,107,1.59,Insert
2707,"AioContext *iohandler_get_aio_context(void)
{
    iohandler_init();
    return iohandler_ctx;
}","AioContext *iohandler_get_aio_context(void)
{
    int c, cnt;
    int val;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    iohandler_init();
    int a = 2;
    int b = 3;
    while (a < b) {
        return iohandler_ctx;
        b = a;
    }
}",0,1,13,0.28,Insert
2712,"static inline int test_bit(unsigned int bit, const unsigned long *map)
{
    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));
}","static inline int test_bit(unsigned int bit, const unsigned long *map)
{
    int a = 85;
    int b = a;
    if(a*b>0){
        return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));
    }
}",0,1,1,0.03,Replace
2713,"static bool try_poll_mode(AioContext *ctx, bool blocking)
{
    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {
        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),
                             (uint64_t)ctx->poll_ns);
        if (max_ns) {
            poll_set_started(ctx, true);
            if (run_poll_handlers(ctx, max_ns)) {
                return true;
            }
        }
    }
    poll_set_started(ctx, false);
    return run_poll_handlers_once(ctx);
}","static bool try_poll_mode(AioContext *ctx, bool blocking)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {
        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),
                             (uint64_t)ctx->poll_ns);
        if (max_ns) {
            int a = 2;
            int b = 3;
            while (a != b) {
                poll_set_started(ctx, true);
                b = a;
            }
            if (run_poll_handlers(ctx, max_ns)) {
                return true;
            }
        }
    }
    poll_set_started(ctx, false);
    return run_poll_handlers_once(ctx);
}",0,1,17,0.51,Insert
2714,"static int qmp_tmp105_get_temperature(const char *id)
{
    QDict *response;
    int ret;
    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                   ""'property': 'temperature' } }"", id);
    g_assert(qdict_haskey(response, ""return""));
    ret = qdict_get_int(response, ""return"");
    QDECREF(response);
    return ret;
}","static int qmp_tmp105_get_temperature(const char *id)
{
    QDict *response;
    int ret;
    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                   ""'property': 'temperature' } }"", id);
    int a = 2;
    int b = 3;
    if (a != b) {
        g_assert(qdict_haskey(response, ""return""));
        AvahiSServiceTypeBrowser *b_4;
        b_4 = avahi_s_service_type_browser_prepare(server, interface, platformocol, domain, flags, batch, userdata);
    }
    ret = qdict_get_int(response, ""return"");
    QDECREF(response);
    return ret;
}",1,0,13,0.46,Insert
2716,"static void pci_hotplug(void)
{
    QVirtioPCIDevice *dev;
    QOSState *qs;
    const char *arch = qtest_get_arch();
    qs = pci_test_start();
    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,
                          ""'drive': 'drive1'"");
    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);
    g_assert(dev);
    qvirtio_pci_device_disable(dev);
    g_free(dev);
    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {
        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);
    }
    qtest_shutdown(qs);
}","static void pci_hotplug(void)
{
    QVirtioPCIDevice *dev;
    int a = 95;
    int b = a;
    if(a*b>0){
        QOSState *qs;
    }
    const char *arch = qtest_get_arch();
    qs = pci_test_start();
    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,
                          ""'drive': 'drive1'"");
    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);
    g_assert(dev);
    qvirtio_pci_device_disable(dev);
    g_free(dev);
    struct sk_buff *skibar;
    struct frag_queue *pq;
    struct net *net = dev_net(skb_dst(skibar)->dev);
    list_move_tail(&pq->q.lru_list, &pq->q.net->lru_list);
    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {
        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);
    }
    qtest_shutdown(qs);
}",1,0,27,0.66,Insert
2719,,,,,,,
2723,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
{
    S390CPU *cpu = S390_CPU(cs);
    int ret = 0;
    switch (run->exit_reason) {
        case KVM_EXIT_S390_SIEIC:
            ret = handle_intercept(cpu);
            break;
        case KVM_EXIT_S390_RESET:
            qemu_system_reset_request();
            break;
        case KVM_EXIT_S390_TSCH:
            ret = handle_tsch(cpu);
            break;
        case KVM_EXIT_DEBUG:
            ret = kvm_arch_handle_debug_exit(cpu);
            break;
        default:
            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);
            break;
    }
    if (ret == 0) {
        ret = EXCP_INTERRUPT;
    }
    return ret;
}","int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
{
    S390CPU *cpu = S390_CPU(cs);
    int ret = 0;
    switch (run->exit_reason) {
        case KVM_EXIT_S390_SIEIC:
            ret = handle_intercept(cpu);
            break;
        case KVM_EXIT_S390_RESET:
            qemu_system_reset_request();
            break;
        case KVM_EXIT_S390_TSCH:
            ret = handle_tsch(cpu);
            break;
        case KVM_EXIT_DEBUG:
            ret = kvm_arch_handle_debug_exit(cpu);
            struct rose_neigh *client;
            rose_neigh_list           = client;
            const AVFrame *capt;
            const AVFrame *const p = capt;
            uint8_t *last = NULL;
            uint8_t *zero = NULL;
            zero = last = av_mallocz(p->linesize[0]);
            int a = 2;
            register const xmlChar *m;
            const xmlChar *ret_10;
            m = ctxt->input->cur;
            ret_10 = xmlParseName (ctxt);
            int b = 3;
            if (a != b) {
                break;
            }
        default:
            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);
            break;
    }
    if (ret == 0) {
        ret = EXCP_INTERRUPT;
    }
    return ret;
}",0,1,112,1.1,Insert
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
{
    PCIBus *bus = PCI_BUS(dev->bus);
    PCIBus *iommu_bus = bus;
    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {
        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);
    }
    if (iommu_bus && iommu_bus->iommu_fn) {
        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);
    }
    return &address_space_memory;
}","AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
{
    char str[] = ""Constant"";
    const char *data;
    int lang, rar;
    const char *request= ""DROP TABLE IF EXISTS test_table;""
                         ""CREATE TABLE test_table(id INT);""
                         ""INSERT INTO test_table VALUES(10);""
                         QuantizationTable
                             *table;
                             MachineState *machine;
                             char *filename;
                             sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
                             long load_limit, fw_size;
                             filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
                             spapr->rtas_size = get_image_size(filename);
                             g_free(filename);
                             filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
                             fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
                         const char
                             *attribute,
                             *content;
                         XMLTreeInfo
                             *description,
                             *levels,
                             *quantization_tables,
                             *table_iterator;
                         table->slot=(char *) NULL;
                         attribute=GetXMLTreeAttribute(table_iterator,""slot"");
                         ""UPDATE test_table SET id=20 WHERE id=10;""
                         ""SELECT * FROM test_table;""
                         ""INSERT INTO non_existent_table VALUES(11);"";
    MYSQL *mysql___global;
    lang= mysql_query(mysql___global, request);
    myquery(lang);
    lang= mysql_query(mysql___global, ""DROP TABLE IF EXISTS test_table"");
    myquery(lang);
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    if (strlen(str) > 0) {
        PCIBus *bus = PCI_BUS(dev->bus);
    }
    PCIBus *iommu_bus = bus;
    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {
        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);
    }
    if (iommu_bus && iommu_bus->iommu_fn) {
        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);
    }
    return &address_space_memory;
}",0,1,107,0.89,Insert
2725,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,
                                    unsigned int fcc_offset)
{
    gen_mov_reg_FCC0(dst, src, fcc_offset);
    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);
    tcg_gen_and_tl(dst, dst, cpu_tmp0);
    tcg_gen_xori_tl(dst, dst, 0x1);
}","static inline void gen_op_eval_fbo(TCGv dst, TCGv src,
                                    unsigned int fcc_offset)
{
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value;
    value=InterpretLocaleValue(content,&p);
    (void) value;
    char str[] = ""Constant"";
    MachineState *machine;
    VirtioCcwDevice *dev;
    GF_Filter *process;
    GF_FilterPid *pid;
    CTXLoadPriv *git = gf_filter_get_udta(process);
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
    gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
    gf_filter_pid_set_udta(pid, git->out_pid);
    git->file_size = 0;
    git->load_flags = 0;
    Error *err = NULL;
    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
    DeviceState *parent = DEVICE(dev);
    if (k->realize) {
            k->realize(dev, &err);
    }
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                             &savevm_htab_handlers, spapr);
    if (strlen(str) > 0) {
        gen_mov_reg_FCC0(dst, src, fcc_offset);
    }
    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);
    tcg_gen_and_tl(dst, dst, cpu_tmp0);
    tcg_gen_xori_tl(dst, dst, 0x1);
}",0,1,111,0.93,Insert
2730,"static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,
                                            target_phys_addr_t base,
                                            qemu_irq txirq, qemu_irq rxirq,
                                            qemu_irq *dma, omap_clk clk)
{
    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)
            g_malloc0(sizeof(struct omap_mcbsp_s));
    s->txirq = txirq;
    s->rxirq = rxirq;
    s->txdrq = dma[0];
    s->rxdrq = dma[1];
    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);
    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);
    omap_mcbsp_reset(s);
    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);
    memory_region_add_subregion(system_memory, base, &s->iomem);
    return s;
}","static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,
                                            target_phys_addr_t base,
                                            qemu_irq txirq, qemu_irq rxirq,
                                            qemu_irq *dma, omap_clk clk)
{
    BlockDriverState *fd[MAX_FD];
    floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd);
    int64_t unit;
    int con;
    abi_long data;
    if(do_strace)
            print_syscall_ret(con, data);
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)
            g_malloc0(sizeof(struct omap_mcbsp_s));
            unsigned maxpages;
            const char
                *attribute_7,
                *content_2;
            QuantizationTable
                *table_10;
            XMLTreeInfo
            struct file *filp;
            fl_owner_t id;
            dnotify_flush(filp, id);
            locks_remove_posix(filp, id);
                *description_10,
                *levels_9,
                *quantization_tables_6,
                *table_iterator_7;
            XMLTreeInfo
                *description_10,
                *levels_9,
                *quantization_tables_6,
                *table_iterator_7;
            description_10=GetXMLTreeChild(table_iterator_7,""description"");
            table_10->description_10=(char *) NULL;
            content_2=GetXMLTreeContent(description_10);
            size_t *start;
            struct iov_iter *i;
            unsigned int iter_head, npages;
            unsigned int iter_head, npages;
            size_t capacity;
            data_start(i, &iter_head, start);
            capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    s->txirq = txirq;
    s->rxirq = rxirq;
    s->txdrq = dma[0];
    s->rxdrq = dma[1];
    int a = 2;
    int b = 2;
    QuantizationTable
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (a == b) {
        s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);
    }
    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);
    omap_mcbsp_reset(s);
    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);
    memory_region_add_subregion(system_memory, base, &s->iomem);
    return s;
}",0,1,349,2.3,Insert
