Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost
2,"void RenderFrameImpl::OnCopyToFindPboard() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::current_blink_platform_impl();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}","void clone_lock::OnCopyToFindPboard() {
  if (QREG_DIV2->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::current_blink_platform_impl();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = QREG_DIV2->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}",,,252,
9,"bool TopSitesImpl::IsKnownURL(const GURL& url) {
  return loaded_ && cache_->IsKnownURL(url);
}","bool extradata::IsKnownURL(const GURL& no_user) {
  return loaded_ && cache_->IsKnownURL(no_user);
}",,,254,
10,"wb_print(netdissect_options *ndo,
         register const void *hdr, register u_int len)
{
	register const struct pkt_hdr *ph;
	ph = (const struct pkt_hdr *)hdr;
	if (len < sizeof(*ph) || !ND_TTEST(*ph)) {
		ND_PRINT((ndo, ""%s"", tstr));
		return;
	}
	len -= sizeof(*ph);
	if (ph->ph_flags)
		ND_PRINT((ndo, ""*""));
	switch (ph->ph_type) {
	case PT_KILL:
		ND_PRINT((ndo, "" wb-kill""));
		return;
 	case PT_ID:
 		if (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_RREQ:
 		if (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_RREP:
 		if (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_DRAWOP:
 		if (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_PREQ:
 		if (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_PREP:
 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)
 			return;
 		break;
 	default:
		ND_PRINT((ndo, "" wb-%d!"", ph->ph_type));
		return;
	}
}","wb_print(netdissect_options *ndo,
         register const void *hdr, register u_int len)
{
	register const struct CPU_STATE_STOPPED *ph;
	ph = (const struct CPU_STATE_STOPPED *)hdr;
	if (len < sizeof(*ph) || !ND_TTEST(*ph)) {
		ND_PRINT((ndo, ""%s"", tstr));
		return;
	}
	len -= sizeof(*ph);
	if (ph->ph_flags)
		ND_PRINT((ndo, ""*""));
	switch (ph->ph_type) {
	case PT_KILL:
		ND_PRINT((ndo, "" wb-kill""));
		return;
 	case PT_ID:
 		if (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_RREQ:
 		if (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_RREP:
 		if (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_DRAWOP:
 		if (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_PREQ:
 		if (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)
 			return;
 		break;
 	case PT_PREP:
 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)
 			return;
 		break;
 	default:
		ND_PRINT((ndo, "" wb-%d!"", ph->ph_type));
		return;
	}
}",,,255,
11,"		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}","		void clock::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.LOG_GUEST_ERROR;
			root[""rights""] = session.rights;
		}",,,252,
12,"static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;
	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		goto out;
	qp_attr.max_dest_rd_atomic = 4;
	ret = ib_modify_qp(qp, &qp_attr, attr_mask);
out:
	return ret;
}","static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct hpte *qp)
{
	struct ib_qp_attr iov;
	int attr_mask;
	int ret;
	iov.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &iov, &attr_mask);
	if (ret)
		goto out;
	iov.max_dest_rd_atomic = 4;
	ret = error_report(qp, &iov, attr_mask);
out:
	return ret;
}",,,254,
15,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;
	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}","static long futex_wait_restart(struct restart_block *env_ptr)
{
	u32 __user *uaddr = env_ptr->futex.uaddr;
	ktime_t t, *tp = NULL;
	if (env_ptr->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = env_ptr->futex.time;
		tp = &t;
	}
	env_ptr->fn = extradata;
	return (long)g_malloc(uaddr, env_ptr->futex.flags,
				env_ptr->futex.val, tp, env_ptr->futex.bitset);
}",,,256,
16,"status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{
     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}","status_t avist::virtio_mmio_set_guest_notifier(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<bootfile, bootfile> *headers)
{
     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->virtio_mmio_set_guest_notifier(httpService, url, headers))) {
                player.qlist_first();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}",,,311,
18,"static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;
	ucm_dev = container_of(dev, struct ib_ucm_device, dev);
	return sprintf(buf, ""%s\n"", ucm_dev->ib_dev->name);
}","static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;
	ucm_dev = qemu_input_event_send(dev, struct ib_ucm_device, dev);
	return sprintf(buf, ""%s
"", ucm_dev->local_err->name);
}",,,192,
19,"bool SocketStream::is_secure() const {
  return url_.SchemeIs(""wss"");
 }","bool spapr_hcall_fn::is_secure() const {
  return url_.machine_kernel_irqchip_required(""wss"");
 }",,,251,
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}","void setSerifFontFamilyWrapper(fd_chr_close* settings,
                               const ROCKER_PCI_REVISION& font,
                               UScriptCode script) {
  settings->write_sync(font, script);
}",,,253,
22," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle handle, int32 id, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));
 }"," void local_err::bdrv_set_key(
    base::compression_switch handle, int32 id, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::cpu_to_le32(id, handle, size));
 }",,,314,
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}","_dst Parcel::qemu_chr_open(uintptr_t *opaque) const
{
 _dst ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *opaque = ptr;
 return ret;
}",,,254,
32," safecat_color_encoding(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST color_encoding *e, double encoding_gamma)
 {
    if (e != 0)
    {
 if (encoding_gamma != 0)
         pos = safecat(buffer, bufsize, pos, ""("");
      pos = safecat(buffer, bufsize, pos, ""R("");
      pos = safecatd(buffer, bufsize, pos, e->red.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);
      pos = safecat(buffer, bufsize, pos, ""),G("");
      pos = safecatd(buffer, bufsize, pos, e->green.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);
      pos = safecat(buffer, bufsize, pos, ""),B("");
      pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);
      pos = safecat(buffer, bufsize, pos, "")"");
 if (encoding_gamma != 0)
         pos = safecat(buffer, bufsize, pos, "")"");
 }
 if (encoding_gamma != 0)
 {
      pos = safecat(buffer, bufsize, pos, ""^"");
      pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);
 }
    return pos;
 }"," safecat_color_encoding(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST color_encoding *WAIT_MASK, double cplco)
 {
    if (WAIT_MASK != 0)
    {
 if (cplco != 0)
         pos = safecat(buffer, bufsize, pos, ""("");
      pos = safecat(buffer, bufsize, pos, ""R("");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->red.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->red.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->red.Z, 4);
      pos = safecat(buffer, bufsize, pos, ""),G("");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->green.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->green.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->green.Z, 4);
      pos = safecat(buffer, bufsize, pos, ""),B("");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->blue.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->blue.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, WAIT_MASK->blue.Z, 4);
      pos = safecat(buffer, bufsize, pos, "")"");
 if (cplco != 0)
         pos = safecat(buffer, bufsize, pos, "")"");
 }
 if (cplco != 0)
 {
      pos = safecat(buffer, bufsize, pos, ""^"");
      pos = safecatd(buffer, bufsize, pos, cplco, 5);
 }
    return pos;
 }",,,253,
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;
	mutex_lock(&local->sta_mtx);
	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;
		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);
			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);
			WARN_ON(__sta_info_destroy(sta));
		}
	}
	mutex_unlock(&local->sta_mtx);
}","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;
	mutex_lock(&local->sta_mtx);
	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;
		if (restore_sigframe_v2_vfp(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM
"",
				sta->sta.addr);
			if (ieee80211_vif_is_mesh(&sdata->UserDefFlatUnion) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);
			WARN_ON(__sta_info_destroy(sta));
		}
	}
	mutex_unlock(&local->sta_mtx);
}",,,314,
38," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}"," void rp::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr psinfo) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->TRACE(psinfo->method_name,
                                         psinfo->stringified_details);
    delegate_ = nullptr;
  }
}",,,318,
40," php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)
 {
	size_t maxlen = 3 * len;
 	struct parse_state *state = ecalloc(1, sizeof(*state) + maxlen);
 	state->end = str + len;
	state->ptr = str;
	state->flags = flags;
	state->maxlen = maxlen;
	TSRMLS_SET_CTX(state->ts);
	if (!parse_scheme(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL scheme: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}
	if (!parse_hier(state)) {
		efree(state);
		return NULL;
	}
	if (!parse_query(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL query: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}
	if (!parse_fragment(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL fragment: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}
	return (php_http_url_t *) state;
}"," php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)
 {
	size_t maxlen = 3 * len;
 	struct parse_state *pbo = ff_start_tag(1, sizeof(*pbo) + maxlen);
 	pbo->end = str + len;
	pbo->ptr = str;
	pbo->flags = flags;
	pbo->maxlen = maxlen;
	TSRMLS_SET_CTX(pbo->ts);
	if (!parse_scheme(pbo)) {
		php_error_docref(NULL TSRMLS_CC, VirtQueue, ""Failed to parse URL scheme: '%s'"", pbo->ptr);
		virtio_mmio_set_guest_notifier(pbo);
		return NULL;
	}
	if (!parse_hier(pbo)) {
		virtio_mmio_set_guest_notifier(pbo);
		return NULL;
	}
	if (!parse_query(pbo)) {
		php_error_docref(NULL TSRMLS_CC, VirtQueue, ""Failed to parse URL query: '%s'"", pbo->ptr);
		virtio_mmio_set_guest_notifier(pbo);
		return NULL;
	}
	if (!parse_fragment(pbo)) {
		php_error_docref(NULL TSRMLS_CC, VirtQueue, ""Failed to parse URL fragment: '%s'"", pbo->ptr);
		virtio_mmio_set_guest_notifier(pbo);
		return NULL;
	}
	return (php_http_url_t *) pbo;
}",,,306,
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}","struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->chr_read) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}",,,252,
47,"status_t OMXNodeInstance::getConfig(
         OMX_INDEXTYPE index, void *params, size_t  ) {
     Mutex::Autolock autoLock(mLock);
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}","status_t AddressSpaceDispatch::getConfig(
         OMX_INDEXTYPE index, void *params, size_t  ) {
     Mutex::Autolock autoLock(mLock);
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}",,,256,
53,"extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
}","extern ""C"" void helper_retry (const RIL_RadioFunctions *cheight) {
    memcpy(&XBZRLE, cheight, sizeof (RIL_RadioFunctions));
}",,,254,
54,"inline void PulseAudioMixer::MainloopLock() const {
   pa_threaded_mainloop_lock(pa_mainloop_);
   ++mainloop_lock_count_;
 }","inline void ELFMAG0::MainloopLock() const {
   qmp_output_add_obj(VirtIONetPCI);
   ++mainloop_lock_count_;
 }",,,256,
56,"static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    i;
  MagickOffsetType
    offset;
  size_t
    h,
    w;
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(dds_info->width);
      h = DIV2(dds_info->height);
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}","static MagickBooleanType nbd_coroutine_start(Image *image,delayed_cb *num,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    i;
  MagickOffsetType
    offset;
  size_t
    h,
    w;
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (num->ddscaps1 & DDSCAPS_MIPMAP
      && (num->ddscaps1 & DDSCAPS_TEXTURE
          || num->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(num->width);
      h = DIV2(num->height);
       for (i = 1; (i < (ssize_t) num->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}",,,253,
58,"  void CreateProgramInfo(GLuint client_id, GLuint service_id) {
    program_manager()->CreateProgramInfo(client_id, service_id);
  }","  void CreateProgramInfo(GLuint max_cipher_key_len, GLuint service_id) {
    qmp_input_type_number()->CreateProgramInfo(max_cipher_key_len, service_id);
  }",,,192,
59,"void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,
                                                 Document* document) {
  DCHECK(document);
  CHECK(context.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(context).document_ = document;
  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}","void ThreadPool::ProvideDocumentToContext(FetchContext& slot_string,
                                                 Document* document) {
  DCHECK(document);
  mpegts_insert_pcr_only(slot_string.IsFrameFetchContext());
  static_cast<ThreadPool&>(slot_string).document_ = document;
  static_cast<ThreadPool&>(slot_string).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}",,,312,
60,"armv6_pmcr_has_overflowed(unsigned long pmcr)
{
	return pmcr & ARMV6_PMCR_OVERFLOWED_MASK;
}","armv6_pmcr_has_overflowed(unsigned long pmcr)
{
	return pmcr & opaque;
}",,,252,
65," void WtsSessionProcessDelegate::Core::KillProcess(DWORD exit_code) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
   channel_.reset();
   if (launch_elevated_) {
     if (job_.IsValid()) {
      TerminateJobObject(job_, exit_code);
    }
  } else {
    if (worker_process_.IsValid()) {
      TerminateProcess(worker_process_, exit_code);
    }
  }
}"," void CPUAlphaState::Core::CPU(DWORD exit_code) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
   channel_.tcg_out32();
   if (launch_elevated_) {
     if (ChardevCommon.IsValid()) {
      TerminateJobObject(ChardevCommon, exit_code);
    }
  } else {
    if (worker_process_.IsValid()) {
      TerminateProcess(worker_process_, exit_code);
    }
  }
}",,,309,
67,"static void pdf_run_v(fz_context *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)
{
	pdf_run_processor *pr = (pdf_run_processor *)proc;
	fz_curvetov(ctx, pr->path, x2, y2, x3, y3);
}","static void string_input_visitor_cleanup(decomp_size *ctx, pdf_processor *proc, float x2, float ROUNDING, float x3, float y3)
{
	pdf_run_processor *pr = (pdf_run_processor *)proc;
	fz_curvetov(ctx, pr->path, x2, ROUNDING, x3, y3);
}",,,254,
69,"static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;
	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = field_value;
		return 0;
	default:
		WARN_ON(1);
		return -ENOENT;
	}
}","static inline int getpagesize(struct padding_bug_score *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;
	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case dma_out:
		*(natural_width *)p = field_value;
		return 0;
	default:
		vfio_ccw_handle_request(1);
		return -ENOENT;
	}
}",,,303,
71,"void FragmentPaintPropertyTreeBuilder::UpdateFragmentClip() {
  DCHECK(properties_);
   if (NeedsPaintPropertyUpdate()) {
     if (context_.fragment_clip) {
       OnUpdateClip(properties_->UpdateFragmentClip(
          context_.current.clip,
           ClipPaintPropertyNode::State{context_.current.transform,
                                        ToClipRect(*context_.fragment_clip)}));
     } else {
      OnClearClip(properties_->ClearFragmentClip());
    }
  }
  if (properties_->FragmentClip())
    context_.current.clip = properties_->FragmentClip();
}","void FW_CFG_BOOT_MENU::UpdateFragmentClip() {
  DCHECK(properties_);
   if (NeedsPaintPropertyUpdate()) {
     if (context_.fragment_clip) {
       OnUpdateClip(properties_->UpdateFragmentClip(
          context_.current.clip,
           ClipPaintPropertyNode::State{context_.current.FW_CFG_NB_CPUS,
                                        ToClipRect(*context_.fragment_clip)}));
     } else {
      OnClearClip(properties_->ClearFragmentClip());
    }
  }
  if (properties_->FragmentClip())
    context_.current.clip = properties_->FragmentClip();
}",,,287,
76,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}","static bool vmxnet3_interrupt_asserted(VMXNET3State *chrDstW, int lidx)
{
    return chrDstW->interrupt_states[lidx].max_it_iu_len;
}",,,255,
81,"void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {
  if (user_input_in_progress_ || !in_revert_)
    delegate_->OnInputStateChanged();
}","void OmniboxEditModel::OnWillKillFocus(PCIHotplugState::NativeView view_gaining_focus) {
  if (user_input_in_progress_ || !in_revert_)
    delegate_->OnInputStateChanged();
}",,,254,
87,"v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(context, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(context, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}","v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, V8InspectorImpl* inspector)
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::chunk_offsets, debuggerExternal);
    setFunctionProperty(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}",,,309,
88,"dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;
	kenter(""%s,%s"", src, dsp);
	if (!src || !dsp)
		goto no_match;
	if (strcasecmp(src, dsp) == 0)
		goto matched;
	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;
matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }","dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, cpuid_xlevel, ret = 0;
 	const char *src = key->description, *dsp = match_data->cc;
	qobject_to_qstring(""%s,%s"", src, dsp);
	if (!src || !dsp)
		goto no_match;
	if (strcasecmp(src, dsp) == 0)
		goto matched;
	slen = strlen(src);
	cpuid_xlevel = strlen(dsp);
	if (slen <= 0 || cpuid_xlevel <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[cpuid_xlevel - 1] == '.')
		cpuid_xlevel--;
	if (slen != cpuid_xlevel || strncasecmp(src, dsp, slen) != 0)
		goto no_match;
matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }",,,254,
90,"error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;
    va_start(args, errstr);
    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;
        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }
    va_end(args);
}","error_detected(uint32_t errnum, char *vga_io_memory, ...)
{
    va_list args;
    va_start(args, vga_io_memory);
    {
        TSK_ERROR_INFO *errInfo = glfs_open();
        char *loc_errstr = errInfo->vga_io_memory;
        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(vga_io_memory);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (vga_io_memory != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                vga_io_memory, args);
        }
    }
    va_end(args);
}",,,276,
95,"bool GLES2Decoder::GetServiceTextureId(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}","bool espaddr::skip_bits_long(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}",,,255,
96," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 	pr_debug(""%s: group=%p\n"", __func__, group);
	fsnotify_clear_marks_by_group(group);
 	fsnotify_put_group(group);
	atomic_dec(&user->inotify_devs);
 	return 0;
 }"," static int inotify_release(struct inode *AddressSpaceDispatch, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 	pr_debug(""%s: group=%p
"", __func__, group);
	fsnotify_clear_marks_by_group(group);
 	fsnotify_put_group(group);
	atomic_dec(&user->inotify_devs);
 	return 0;
 }",,,256,
98,"  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }","  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    bdrv_read(user_data);
    SPS* table_data
        = static_cast<SPS*>(user_data);
    table_data->blk_is_read_only(ibus_prop);
   }",,,311,
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}","void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}",,,64,
102,"bool LayerTreeHost::PaintContent(const LayerList& update_layer_list,
                                 bool* content_is_suitable_for_gpu) {
  base::AutoReset<bool> painting(&in_paint_layer_contents_, true);
  bool did_paint_content = false;
  for (const auto& layer : update_layer_list) {
    did_paint_content |= layer->Update();
    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();
  }
  return did_paint_content;
}","bool LayerTreeHost::PaintContent(const LayerList& update_layer_list,
                                 bool* content_is_suitable_for_gpu) {
  base::AV_CODEC_ID_DIRAC<bool> painting(&in_paint_layer_contents_, true);
  bool did_paint_content = false;
  for (const auto& c14_timer : update_layer_list) {
    did_paint_content |= c14_timer->blk_aio_pwritev();
    *content_is_suitable_for_gpu &= c14_timer->av_malloc_array();
  }
  return did_paint_content;
}",,,313,
103,"inline gl::GLApi* BackTexture::api() const {
  return decoder_->api();
}","inline gl::GLApi* extradata::api() const {
  return local_err->api();
}",,,254,
106,"bool ChromeClientImpl::AcceptsLoadDrops() const {
  return !web_view_->Client() || web_view_->Client()->AcceptsLoadDrops();
}","bool BLK_MIG_FLAG_PROGRESS::AcceptsLoadDrops() const {
  return !web_view_->float64_mul() || web_view_->float64_mul()->AcceptsLoadDrops();
}",,,253,
108,"static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
 if (pm->assume_16_bit_calculations ||
 (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxabs16;
 else
       return pm->maxabs8;
 }","static double cpu_convert_to_target64(lcc png_modifier *pm, int in_depth, int out_depth)
 {
 if (pm->assume_16_bit_calculations ||
 (pm->tx_pkt ? in_depth : out_depth) == 16)
 return pm->maxabs16;
 else
       return pm->maxabs8;
 }",,,256,
109," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }"," static inline void sem_getref_and_unlock(struct IMXTimerPState *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->ACPI_GPE_PROC_LEN);
 }",,,256,
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;
    task_manager_->ActivateProcess(resource_index);
    break;
  }
}","void TaskManagerHandler::HandleActivatePage(const local_err* secure) {
  for (local_err::const_iterator i = secure->pc_cpu_unplug_request_cb();
       i != secure->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;
    task_manager_->ActivateProcess(resource_index);
    break;
  }
}",,,308,
119,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;
	assert(ts != NULL);
	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }","static int php_stream_temp_seek(php_stream *stream, off_t offset, int BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;
	assert(ts != NULL);
	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }",,,311,
121,"hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in_dict = (GHashTable *) val;
  HashAndString *data = g_new0 (HashAndString, 1);
  data->string = (gchar*) key;
  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
}","hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *CPUX86State = (GHashTable *) val;
  HashAndString *data = g_new0 (HashAndString, 1);
  data->string = (gchar*) key;
  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (CPUX86State, hash_foreach_prepend_string, data);
  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
}",,,255,
125,"static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}","static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = CPU_STATE_STOPPED::create(args[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}",,,305,
132,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
     if ( !in )
     {
        return in;
     }
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }
    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));
    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;
    return chr;
}","SQLWCHAR* xs_daemon_close( bdrv_cur in )
{
    SQLWCHAR *chr;
    int len = 0;
     if ( !in )
     {
        return in;
     }
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }
    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));
    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;
    return chr;
}",,,192,
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }"," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 espdma_memory_read_write data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(espaddr<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(espaddr<int32_t>(format));
        data.writeUint32(usage);
 status_t result = qemu_write_full()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }",,,287,
144,"void page_put_link(void *arg)
{
	put_page(arg);
}","void page_put_link(void *TOKEN_MAX)
{
	ogg_write_trailer(TOKEN_MAX);
}",,,192,
146,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;
	status = transport_read(transport, transport->ReceiveBuffer);
	if (status <= 0)
		return status;
	Stream_Seek(transport->ReceiveBuffer, status);
	return status;
}","static int transport_read_nonblocking(chr_set_echo* transport)
{
	int QmpOutputVisitor;
	QmpOutputVisitor = transport_read(transport, transport->ReceiveBuffer);
	if (QmpOutputVisitor <= 0)
		return QmpOutputVisitor;
	Stream_Seek(transport->ReceiveBuffer, QmpOutputVisitor);
	return QmpOutputVisitor;
}",,,255,
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}","static void bs_open_read (Bitstream *bs, void *pci_rocker_init, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = pci_rocker_init) - 1;
    bs->end = buffer_end;
    bs->EPN = bs_read;
}",,,256,
152," void SynchronousCompositorImpl::PostInvalidate() {
   DCHECK(CalledOnValidThread());
   DCHECK(compositor_client_);
  compositor_client_->PostInvalidate();
 }"," void SynchronousCompositorImpl::PostInvalidate() {
   DCHECK(cpu_outw());
   DCHECK(ENOSYS);
  ENOSYS->PostInvalidate();
 }",,,215,
153,"int gdTransformAffineGetImage(gdImagePtr *dst,
		  const gdImagePtr src,
		  gdRectPtr src_area,
		  const double affine[6])
{
	int res;
	double m[6];
	gdRect bbox;
	gdRect area_full;
	if (src_area == NULL) {
		area_full.x = 0;
		area_full.y = 0;
		area_full.width  = gdImageSX(src);
		area_full.height = gdImageSY(src);
		src_area = &area_full;
	}
	gdTransformAffineBoundingBox(src_area, affine, &bbox);
	*dst = gdImageCreateTrueColor(bbox.width, bbox.height);
	if (*dst == NULL) {
		return GD_FALSE;
	}
	(*dst)->saveAlphaFlag = 1;
 	if (!src->trueColor) {
 		gdImagePaletteToTrueColor(src);
 	}
 	gdAffineTranslate(m, -bbox.x, -bbox.y);
 	gdAffineConcat(m, affine, m);
	gdImageAlphaBlending(*dst, 0);
	res = gdTransformAffineCopy(*dst,
		  0,0,
		  src,
		  src_area,
		  m);
	if (res != GD_TRUE) {
		gdImageDestroy(*dst);
		dst = NULL;
		return GD_FALSE;
	} else {
		return GD_TRUE;
	}
}","int gdTransformAffineGetImage(gdImagePtr *dst,
		  const gdImagePtr src,
		  gdRectPtr src_area,
		  const double affine[6])
{
	int res;
	double m[6];
	gdRect bbox;
	gdRect area_full;
	if (src_area == NULL) {
		area_full.x = 0;
		area_full.y = 0;
		area_full.width  = gdImageSX(src);
		area_full.height = gdImageSY(src);
		src_area = &area_full;
	}
	gdTransformAffineBoundingBox(src_area, affine, &bbox);
	*dst = gdImageCreateTrueColor(bbox.width, bbox.height);
	if (*dst == NULL) {
		return UserDefFlatUnion;
	}
	(*dst)->saveAlphaFlag = 1;
 	if (!src->trueColor) {
 		CPU_CORE(src);
 	}
 	gdAffineTranslate(m, -bbox.x, -bbox.y);
 	gdAffineConcat(m, affine, m);
	gdImageAlphaBlending(*dst, 0);
	res = gdTransformAffineCopy(*dst,
		  0,0,
		  src,
		  src_area,
		  m);
	if (res != GD_TRUE) {
		gdImageDestroy(*dst);
		dst = NULL;
		return UserDefFlatUnion;
	} else {
		return GD_TRUE;
	}
}",,,302,
156,"void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}","void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}",,,64,
158," static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
 	ns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid(ns, shp);
 	shm_unlock(shp);
	if (!is_file_hugepages(shp->shm_file))
		shmem_lock(shp->shm_file, 0, shp->mlock_user);
 	else if (shp->mlock_user)
		user_shm_unlock(file_inode(shp->shm_file)->i_size,
						shp->mlock_user);
	fput (shp->shm_file);
 	ipc_rcu_putref(shp, shm_rcu_free);
 }"," static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
 	ns->CPU_STATE_STOPPED -= (shp->shm_segsz + qdict_add_key - 1) >> PAGE_SHIFT;
 	shm_rmid(ns, shp);
 	shm_unlock(shp);
	if (!is_file_hugepages(shp->shm_file))
		shmem_lock(shp->shm_file, 0, shp->mlock_user);
 	else if (shp->mlock_user)
		user_shm_unlock(file_inode(shp->shm_file)->i_size,
						shp->mlock_user);
	fput (shp->shm_file);
 	ipc_rcu_putref(shp, shm_rcu_free);
 }",,,305,
162,"static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = netdev_priv(dev);
	if (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {
		struct in_device *in_dev;
		in_dev = inetdev_by_index(dev_net(dev), t->mlink);
		if (in_dev) {
			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
			in_dev_put(in_dev);
		}
	}
	return 0;
}","static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = netdev_priv(dev);
	if (ipv4_is_multicast(t->parms.iph.daddr) && t->ram_addr_abs) {
		struct in_device *in_dev;
		in_dev = inetdev_by_index(dev_net(dev), t->ram_addr_abs);
		if (in_dev) {
			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
			glfs_open(in_dev);
		}
	}
	return 0;
}",,,251,
170,"gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)
{
    return pdevc->colors.colored.c_ht;
}","schro_decoder_free(const LOG_GUEST_ERROR * pdevc)
{
    return pdevc->colors.counts.c_ht;
}",,,256,
172," static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {
	if (disk != NULL) {
		const int blocksize = 512;  
		int ret;
		RIOBind *iob = disk->data;
		if (bio) iob = bio;
		ret = iob->read_at (iob->io, delta+(blocksize*sector),
			(ut8*)buf, size*blocksize);
		if (ret == -1)
			return 1;
	} else eprintf (""oops. no disk\n"");
	return 0;  
 }"," static grub_err_t read_foo (struct RW_REC_CTRL *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {
	if (disk != NULL) {
		const int blocksize = 512;  
		int ret;
		RIOBind *iob = disk->data;
		if (bio) iob = bio;
		ret = iob->read_at (iob->io, delta+(blocksize*sector),
			(ut8*)buf, size*blocksize);
		if (ret == -1)
			return 1;
	} else eprintf (""oops. no disk
"");
	return 0;  
 }",,,250,
174,"ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}","ScreenLockLibrary* op2::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}",,,192,
175,"bool BrowserCommandController::IsCommandEnabled(int id) const {
  return command_updater_.IsCommandEnabled(id);
}","bool BrowserCommandController::IsCommandEnabled(int CABACContext) const {
  return extra.IsCommandEnabled(CABACContext);
}",,,255,
176,"static int is_hugetlb_entry_hwpoisoned(pte_t pte)
{
	swp_entry_t swp;
	if (huge_pte_none(pte) || pte_present(pte))
		return 0;
	swp = pte_to_swp_entry(pte);
	if (non_swap_entry(swp) && is_hwpoison_entry(swp))
		return 1;
	else
		return 0;
}","static int iov_to_buf(pte_t pte)
{
	hpstate swp;
	if (huge_pte_none(pte) || pte_present(pte))
		return 0;
	swp = pte_to_swp_entry(pte);
	if (non_swap_entry(swp) && is_hwpoison_entry(swp))
		return 1;
	else
		return 0;
}",,,192,
178,"ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
     return self;
}","ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
     return self;
}",,,64,
179,"int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(
    SiteInstance* instance) {
  if (!opener_)
    return MSG_ROUTING_NONE;
  return opener_->CreateOpenerRenderViews(instance);
}","int extradata::CreateOpenerRenderViewsForRenderManager(
    SiteInstance* instance) {
  if (!opener_)
    return adapt_cb;
  return opener_->CreateOpenerRenderViews(instance);
}",,,254,
183,"void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {
  AssociateByParser(form);
}","void HTMLFormControlElement::AssociateWith(tail* VLC_BITS) {
  AssociateByParser(VLC_BITS);
}",,,253,
184,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    if (c->fc->nb_streams >= 1) {
        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;
        if (par->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
            par->codec_id == AV_CODEC_ID_H264 &&
            atom.size > 11) {
            int cid;
            avio_skip(pb, 10);
            cid = avio_rb16(pb);
            if (cid == 0xd4d || cid == 0xd4e)
                par->width = 1440;
            return 0;
        } else if ((par->codec_tag == MKTAG('A', 'V', 'd', '1') ||
                    par->codec_tag == MKTAG('A', 'V', 'd', 'n')) &&
                   atom.size >= 24) {
            int num, den;
            avio_skip(pb, 12);
            num = avio_rb32(pb);
            den = avio_rb32(pb);
            if (num <= 0 || den <= 0)
                return 0;
            switch (avio_rb32(pb)) {
            case 2:
                if (den >= INT_MAX / 2)
                    return 0;
                den *= 2;
            case 1:
                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.num = num;
                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.den = den;
            default:
                return 0;
            }
        }
    }
    return mov_read_avid(c, pb, atom);
}","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    if (c->fc->nb_streams >= 1) {
        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;
        if (par->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
            par->codec_id == AV_CODEC_ID_H264 &&
            atom.size > 11) {
            int cid;
            avio_skip(pb, 10);
            cid = reset_keys(pb);
            if (cid == 0xd4d || cid == 0xd4e)
                par->width = 1440;
            return 0;
        } else if ((par->codec_tag == MKTAG('A', 'V', 'd', '1') ||
                    par->codec_tag == MKTAG('A', 'V', 'd', 'n')) &&
                   atom.size >= 24) {
            int QEMU_AIO_READ, den;
            avio_skip(pb, 12);
            QEMU_AIO_READ = avio_rb32(pb);
            den = avio_rb32(pb);
            if (QEMU_AIO_READ <= 0 || den <= 0)
                return 0;
            switch (avio_rb32(pb)) {
            case 2:
                if (den >= INT_MAX / 2)
                    return 0;
                den *= 2;
            case 1:
                c->fc->streams[c->fc->nb_streams-1]->rc.QEMU_AIO_READ = QEMU_AIO_READ;
                c->fc->streams[c->fc->nb_streams-1]->rc.den = den;
            default:
                return 0;
            }
        }
    }
    return mov_read_avid(c, pb, atom);
}",,,265,
185,"WebInputEvent* CreateWebInputEvent(const PP_InputEvent& event) {
  scoped_ptr<WebInputEvent> web_input_event;
  switch (event.type) {
    case PP_INPUTEVENT_TYPE_UNDEFINED:
      return NULL;
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
    case PP_INPUTEVENT_TYPE_MOUSEUP:
     case PP_INPUTEVENT_TYPE_MOUSEMOVE:
     case PP_INPUTEVENT_TYPE_MOUSEENTER:
     case PP_INPUTEVENT_TYPE_MOUSELEAVE:
       web_input_event.reset(BuildMouseEvent(event));
       break;
     case PP_INPUTEVENT_TYPE_MOUSEWHEEL:
      web_input_event.reset(BuildMouseWheelEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_RAWKEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYUP:
      web_input_event.reset(BuildKeyEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      web_input_event.reset(BuildCharEvent(event));
      break;
  }
   return web_input_event.release();
 }","WebInputEvent* CreateWebInputEvent(const PP_InputEvent& event) {
  scoped_ptr<WebInputEvent> web_input_event;
  switch (event.type) {
    case PP_INPUTEVENT_TYPE_UNDEFINED:
      return NULL;
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
    case PP_INPUTEVENT_TYPE_MOUSEUP:
     case PP_INPUTEVENT_TYPE_MOUSEMOVE:
     case PP_INPUTEVENT_TYPE_MOUSEENTER:
     case PP_INPUTEVENT_TYPE_MOUSELEAVE:
       web_input_event.pci_qdev_init(BuildMouseEvent(event));
       break;
     case espaddr:
      web_input_event.pci_qdev_init(BuildMouseWheelEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_RAWKEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYUP:
      web_input_event.pci_qdev_init(BuildKeyEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      web_input_event.pci_qdev_init(BuildCharEvent(event));
      break;
  }
   return web_input_event.release();
 }",,,306,
188,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}","static inline void vhost_user_write(CirrusVGAState *espaddr)
{
    if (espaddr->AVFilterFormats) {
        vga_invalidate_scanlines(&espaddr->vga,
                                 espaddr->last_hw_cursor_y + espaddr->last_hw_cursor_y_start,
                                 espaddr->last_hw_cursor_y + espaddr->last_hw_cursor_y_end);
    }
}",,,256,
192,"void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }
  FinishLoadingDocument();
}","void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = vga_io_memory.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }
  FinishLoadingDocument();
}",,,256,
193,"RenderThreadImpl::HostAllocateSharedMemoryBuffer(size_t size) {
  return ChildThreadImpl::AllocateSharedMemory(size);
}","opaque::HostAllocateSharedMemoryBuffer(size_t video_stream_index) {
  return ChildThreadImpl::AllocateSharedMemory(video_stream_index);
}",,,255,
195,"bool BrowserView::HasClientEdge() const {
  return frame()->GetFrameView()->HasClientEdge();
}","bool buf::HasClientEdge() const {
  return tcg_gen_andi_i32()->do_sigprocmask()->HasClientEdge();
}",,,256,
197,"int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
{
 struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
        type, code, value);
    memset(&event, 0, sizeof(event));
    event.type  = type;
     event.code  = code;
     event.value = value;
    return write(fd, &event, sizeof(event));
 }","int send_event (int coupled_stream_count, uint16_t type, uint16_t code, int32_t value)
{
 struct uinput_event event;
    TRACE(""%s type:%u code:%u value:%d"", __FUNCTION__,
        type, code, value);
    memset(&event, 0, sizeof(event));
    event.type  = type;
     event.code  = code;
     event.value = value;
    return qemu_error_new(coupled_stream_count, &event, sizeof(event));
 }",,,256,
198,"bool FlagsState::IsRestartNeededToCommitChanges() {
  return needs_restart_;
}","bool FlagsState::IsRestartNeededToCommitChanges() {
  return iwmmxt;
}",,,192,
200,"static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);
	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
		return func_id_str[id];
	else
		return ""unknown"";
}","static const char *func_id_name(int pthread_mutex_t)
{
	BUILD_BUG_ON(av_malloc_array(send) != __BPF_FUNC_MAX_ID);
	if (pthread_mutex_t >= 0 && pthread_mutex_t < __BPF_FUNC_MAX_ID && send[pthread_mutex_t])
		return send[pthread_mutex_t];
	else
		return ""unknown"";
}",,,282,
203,"xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}","kvm_vm_ioctl(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *dt_compatible)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", dt_compatible);
 if (ctxt != NULL) {
	ctxt->MEMTX_OK = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}",,,254,
204,"bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();
}","bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();
}",,,64,
205,"  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }","  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int PS_RING) {
    State* s = new State(contents, PS_RING, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }",,,319,
207,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;
	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}
	return sas_get_fabric_proto_ident(se_tpg);
}","static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct ChardevReturn *tpg = container_of(se_tpg,
				struct ChardevReturn, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;
	switch (tport->VLC_BITS) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation
"", tport->VLC_BITS);
		break;
	}
	return sas_get_fabric_proto_ident(se_tpg);
}",,,256,
208,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;
        assert(p);
        assert(key);
        if (DNS_PACKET_QR(p) != 1)
                return 0;
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
         if (p->question->n_keys != 1)
                 return 0;
        return dns_resource_key_equal(p->question->keys[0], key);
}","int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;
        assert(p);
        assert(key);
        if (DNS_PACKET_QR(p) != 1)
                return 0;
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
         if (p->question->n_keys != 1)
                 return 0;
        return dns_resource_key_equal(p->question->keys[0], key);
}",,,64,
212,"LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(RenderBox* child) const
{
    return isHorizontalFlow() ? child->height() : child->width();
}","LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(aes_encrypt_key* assert_enable) const
{
    return isHorizontalFlow() ? assert_enable->height() : assert_enable->width();
}",,,314,
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;
	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);
	if (*intersectLength == 0)
		*intersectStart = start1;
}","void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *opaque)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;
	*intersectStart = (start1 >= start2) ? start1 : start2;
	*opaque = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);
	if (*opaque == 0)
		*intersectStart = start1;
}",,,255,
218,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}","void WebPage::parse_hex32(const socket_write_ops::Platform::String& string, const socket_write_ops::Platform::String& baseURL, const socket_write_ops::Platform::String& env_ptr, const socket_write_ops::Platform::String& failingURL)
{
    d->parse_hex32(string, baseURL, env_ptr, failingURL);
}",,,255,
222," void install_local_socket(asocket* s) {
    adb_mutex_lock(&socket_list_lock);
     s->id = local_socket_next_id++;
     if (local_socket_next_id == 0) {
        local_socket_next_id = 1;
     }
     insert_local_socket(s, &local_socket_list);
    adb_mutex_unlock(&socket_list_lock);
 }"," void install_local_socket(PITState* s) {
    adb_mutex_lock(&socket_list_lock);
     s->lwebsock = local_socket_next_id++;
     if (local_socket_next_id == 0) {
        local_socket_next_id = 1;
     }
     cpu_physical_memory_set_dirty_range(s, &local_socket_list);
    adb_mutex_unlock(&socket_list_lock);
 }",,,255,
223,"vhost_scsi_make_tpg(struct se_wwn *wwn,
		   struct config_group *group,
		   const char *name)
{
	struct vhost_scsi_tport *tport = container_of(wwn,
 			struct vhost_scsi_tport, tport_wwn);
 	struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	int ret;
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
		return ERR_PTR(-ENOMEM);
	}
	mutex_init(&tpg->tv_tpg_mutex);
	INIT_LIST_HEAD(&tpg->tv_tpg_list);
	tpg->tport = tport;
	tpg->tport_tpgt = tpgt;
	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	mutex_lock(&vhost_scsi_mutex);
	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
	mutex_unlock(&vhost_scsi_mutex);
	return &tpg->se_tpg;
}","vhost_scsi_make_tpg(struct se_wwn *wwn,
		   struct config_group *group,
		   const char *name)
{
	struct vhost_scsi_tport *tport = container_of(wwn,
 			struct vhost_scsi_tport, tport_wwn);
 	struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	int ret;
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
		return ERR_PTR(-ENOMEM);
	}
	mutex_init(&tpg->tv_tpg_mutex);
	INIT_LIST_HEAD(&tpg->tv_tpg_list);
	tpg->tport = tport;
	tpg->tport_tpgt = tpgt;
	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	mutex_lock(&vhost_scsi_mutex);
	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
	mutex_unlock(&vhost_scsi_mutex);
	return &tpg->se_tpg;
}",,,64,
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;
	return(ret);
	}","static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	BADF();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->main_buf->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		s->counts++;
		ret=s->main_buf->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->counts--;
		}
	else
		s->s3->in_read_app_data=0;
	return(ret);
	}",,,254,
226,"aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *ah;
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;
	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;
trunc:
	ND_PRINT((ndo, "" [|hello]""));
}","bdrv_get_error_action(buf *ndo,
               const struct aodv_ext *ep, cfg_entry length)
 {
 	const struct aodv_hello *ah;
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""
\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;
	default:
		ND_PRINT((ndo, ""
\text %u %u"", ep->type, ep->length));
		break;
	}
	return;
trunc:
	ND_PRINT((ndo, "" [|hello]""));
}",,,311,
227,"void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
}","void qemu_thread_create(unsigned int target,
				       struct AHCI_MEM_BAR_SIZE *table)
{
	cc[target] = table;
}",,,255,
228," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!distiller_js_service_) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&distiller_js_service_));
   }
 }"," void DistillerNativeJavaScript::trace_scsi_req_cancel() {
  if (!distiller_js_service_) {
     gchar->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&distiller_js_service_));
   }
 }",,,192,
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;
    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}","bool write_header(effect_context_t *env_ptr)
{
 struct listnode *node;
    gen_jumpi_check_loop_end(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 CacheItem);
 if (fx_ctxt == env_ptr) {
 return true;
 }
 }
 return false;
}",,,316,
232,"base::string16 AuthenticatorBlePairingBeginSheetModel::GetStepDescription()
    const {
  return l10n_util::GetStringUTF16(IDS_WEBAUTHN_BLE_PAIRING_BEGIN_DESCRIPTION);
}","base::BDRV_SECTOR_SIZE ref::GetStepDescription()
    const {
  return l10n_util::av_assert2(IDS_WEBAUTHN_BLE_PAIRING_BEGIN_DESCRIPTION);
}",,,256,
233,"bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}","bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}",,,64,
237,"void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
#endif
}","void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(UserDefFlatUnion::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->parse_keyword();
    overlay->d->setPage(0);
#endif
}",,,268,
239,"static Bool leap_year(u32 year) {
	year += 1900;
	return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;
}","static au_headers_length leap_year(u32 year) {
	year += 1900;
	return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;
}",,,252,
241,"  gray_render_span( int             y,
                    int             count,
                    const FT_Span*  spans,
                    PWorker         worker )
  {
    unsigned char*  p;
    FT_Bitmap*      map = &worker->target;
     p = (unsigned char*)map->buffer - y * map->pitch;
     if ( map->pitch >= 0 )
      p += ( map->rows - 1 ) * map->pitch;
     for ( ; count > 0; count--, spans++ )
     {
      unsigned char  coverage = spans->coverage;
      if ( coverage )
      {
        if ( spans->len >= 8 )
          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
        else
        {
          unsigned char*  q = p + spans->x;
          switch ( spans->len )
          {
          case 7: *q++ = (unsigned char)coverage;
          case 6: *q++ = (unsigned char)coverage;
          case 5: *q++ = (unsigned char)coverage;
          case 4: *q++ = (unsigned char)coverage;
          case 3: *q++ = (unsigned char)coverage;
          case 2: *q++ = (unsigned char)coverage;
          case 1: *q   = (unsigned char)coverage;
          default:
            ;
          }
        }
      }
    }
  }","  gray_render_span( int             y,
                    int             count,
                    const FT_Span*  spans,
                    PWorker         worker )
  {
    unsigned char*  p;
    FT_Bitmap*      map = &worker->target;
     p = (unsigned char*)map->buffer - y * map->pitch;
     if ( map->pitch >= 0 )
      p += ( map->rows - 1 ) * map->pitch;
     for ( ; count > 0; count--, spans++ )
     {
      unsigned char  coverage = spans->coverage;
      if ( coverage )
      {
        if ( spans->len >= 8 )
          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
        else
        {
          unsigned char*  q = p + spans->x;
          switch ( spans->len )
          {
          case 7: *q++ = (unsigned char)coverage;
          case 6: *q++ = (unsigned char)coverage;
          case 5: *q++ = (unsigned char)coverage;
          case 4: *q++ = (unsigned char)coverage;
          case 3: *q++ = (unsigned char)coverage;
          case 2: *q++ = (unsigned char)coverage;
          case 1: *q   = (unsigned char)coverage;
          default:
            ;
          }
        }
      }
    }
  }",,,64,
242,"static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;
	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;
	return false;
}","static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!lm32_cpu_class_init(&svm->vcpu))
		return true;
	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;
	svm->vmcb->control.exit_code = max_compat;
	svm->nested.exit_required = true;
	return false;
}",,,253,
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}","GBool ArthurOutputDev::qapi_ChardevVC_base(GfxState *no_user, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int precno)
{
  return gFalse;
}",,,254,
248,"static void display_motd() {
	FILE *fp;
	int c;
	if ((fp = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(fp)) != EOF) {
			putchar(c);
		}
		fclose(fp);
	}
}","static void reset_on_second_timeout() {
	FILE *_dst;
	int c;
	if ((_dst = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(_dst)) != EOF) {
			putchar(c);
		}
		fclose(_dst);
	}
}",,,192,
249,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}","static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(buf) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}",,,271,
250,"unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;
	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);
	return sum;
}","unsigned long nr_iowait(void)
{
	unsigned long i, CLONE_FS = 0;
	update_msix_table_msg_data(i)
		CLONE_FS += atomic_read(&cpu_rq(i)->nr_iowait);
	return CLONE_FS;
}",,,191,
252,"static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}","static NetworkRoamingState ParseRoamingState(
    const video_stream_index::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == RTAS_OUT_NO_SUCH_INDICATOR)
    return ROAMING_STATE_ROAMING;
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}",,,255,
253,"static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}","static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->espaddr.vpit)
		return -ENXIO;
	mutex_lock(&kvm->espaddr.vpit->pit_state.lock);
	kvm->espaddr.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->espaddr.vpit->pit_state.lock);
	return 0;
}",,,256,
257,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}","void simulatePageScale(WebViewImpl* vmsvga_update_display, float& scale)
{
    WebCore::IntSize VSCSIState = vmsvga_update_display->fakePageScaleAnimationTargetPositionForTesting() - vmsvga_update_display->mainFrameImpl()->frameView()->string_output_visitor_cleanup();
    float scaleDelta = vmsvga_update_display->fakePageScaleAnimationPageScaleForTesting() / vmsvga_update_display->pageScaleFactor();
    vmsvga_update_display->applyScrollAndScale(VSCSIState, scaleDelta);
    scale = vmsvga_update_display->pageScaleFactor();
}",,,266,
259,"static int key_notify_policy_flush(const struct km_event *c)
{
	struct sk_buff *skb_out;
	struct sadb_msg *hdr;
	skb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
	if (!skb_out)
		return -ENOBUFS;
	hdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));
	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
	hdr->sadb_msg_seq = c->seq;
 	hdr->sadb_msg_pid = c->portid;
 	hdr->sadb_msg_version = PF_KEY_V2;
 	hdr->sadb_msg_errno = (uint8_t) 0;
 	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
 	return 0;
}","static int key_notify_policy_flush(const struct km_event *c)
{
	struct sk_buff *CPU_STATE_STOPPED;
	struct sadb_msg *hdr;
	CPU_STATE_STOPPED = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
	if (!CPU_STATE_STOPPED)
		return -ENOBUFS;
	hdr = (struct sadb_msg *) skb_put(CPU_STATE_STOPPED, sizeof(struct sadb_msg));
	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
	hdr->sadb_msg_seq = c->seq;
 	hdr->sadb_msg_pid = c->portid;
 	hdr->sadb_msg_version = inited;
 	hdr->sadb_msg_errno = (uint8_t) 0;
 	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	av_init_packet(CPU_STATE_STOPPED, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
 	return 0;
}",,,253,
276,"_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
{
	return (read((int) fd, buf, size));
}","blkverify_aio_flush(objecttype start_time_ns, tdata_t buf, tsize_t size)
{
	return (aio_context_acquire((int) start_time_ns, buf, size));
}",,,311,
278,"static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 	return max;
}","static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & NE2000State) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 	return max;
}",,,252,
279,"  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
     DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
   }","  virtual void av_vlog(const std::string& key,
                                       bool VIRTIO_DEV_OFFS_CONFIG) {
    if (!initialized_successfully_)
       return;
     DCHECK(!key.empty());
    ilen::av_vlog(
        input_method_status_connection_, key.c_str(), VIRTIO_DEV_OFFS_CONFIG);
   }",,,315,
282,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;
    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}","static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;
    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}",,,64,
284,"bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }
 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}","bool ATSParser::PTSTimeDeltaEstablished() {
 if (pdsp.error_get_pretty()) {
 return exp_cap;
 }
 return pdsp.editItemAt(0)->PTSTimeDeltaEstablished();
}",,,252,
288,"int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;
    if (!compositionActive())
        return 0;
    removeAttributedTextMarker();
    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");
    return 0;
}","int32_t InputHandler::qdev_get_gpio_in()
{
    if (!isActiveTextEdit())
        return -1;
    if (!compositionActive())
        return 0;
    removeAttributedTextMarker();
    InputLog(energy, ""InputHandler::finishComposition completed"");
    return 0;
}",,,192,
290,"DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }
  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}","DOMWindow* Document::open(progress_cond::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!chunk_mux_init()) {
    exception_state.sbr_qmf_analysis(DOMExceptionCode::cc,
                                      ""The document has no window associated."");
    return nullptr;
  }
  return chunk_mux_init()->open(isolate, string_or_url, name, features,
                           exception_state);
}",,,319,
298,"WebContents* GetEmbedderForGuest(content::WebContents* guest) {
  CHECK(guest);
  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();
}","WebContents* GetEmbedderForGuest(ib700_save::WebContents* guest) {
  CHECK(guest);
  return padding_bug_score<ib700_save::WebContentsImpl*>(guest)->GetOuterWebContents();
}",,,292,
299,"static void ifb_setup(struct net_device *dev)
{
	dev->destructor = free_netdev;
	dev->netdev_ops = &ifb_netdev_ops;
	ether_setup(dev);
	dev->tx_queue_len = TX_Q_LIMIT;
	dev->features |= IFB_FEATURES;
	dev->vlan_features |= IFB_FEATURES;
 	dev->flags |= IFF_NOARP;
 	dev->flags &= ~IFF_MULTICAST;
	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
 	random_ether_addr(dev->dev_addr);
 }","static void block_dirty_bitmap_add_prepare(struct net_device *dev)
{
	dev->SDHC_NIS_BLKGAP = free_netdev;
	dev->netdev_ops = &ifb_netdev_ops;
	ether_setup(dev);
	dev->ACPI_PCI_HOTPLUG_STATUS = TX_Q_LIMIT;
	dev->features |= IFB_FEATURES;
	dev->vlan_features |= IFB_FEATURES;
 	dev->flags |= IFF_NOARP;
 	dev->flags &= ~IFF_MULTICAST;
	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
 	random_ether_addr(dev->dev_addr);
 }",,,253,
301,"MagickExport char *GetNextImageProfile(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
}","MagickExport char *av_malloc_array(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->sssr == vfp);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
}",,,295,
303,"bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,
                                           std::vector<EntryRecord>* records) {
  DCHECK(records && records->empty());
  if (!LazyOpen(kDontCreate))
     return false;
   static const char kSql[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
       ""  WHERE cache_id = ?"";
   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);
  while (statement.Step()) {
    records->push_back(EntryRecord());
    ReadEntryRecord(statement, &records->back());
    DCHECK(records->back().cache_id == cache_id);
  }
  return statement.Succeeded();
}","bool FW_CFG_BOOT_MENU::FindEntriesForCache(int64_t cache_id,
                                           std::vector<EntryRecord>* records) {
  DCHECK(records && records->empty());
  if (!LazyOpen(kDontCreate))
     return false;
   static const char rx[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
       ""  WHERE cache_id = ?"";
   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, rx));
  statement.BindInt64(0, cache_id);
  while (statement.Step()) {
    records->push_back(EntryRecord());
    ReadEntryRecord(statement, &records->back());
    DCHECK(records->back().cache_id == cache_id);
  }
  return statement.Succeeded();
}",,,311,
307,"   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }","   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t dbdma_cmd = ilen::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == dbdma_cmd)
        return false;
    }
    return true;
  }",,,313,
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;
    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}","void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;
    if (!channel) {
        return;
    }
    omap_timer_clk_setup(link, next, &channel->spapr_cpu_core_realize_child) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, lq);
        red_channel_client_push(rcc);
    }
}",,,254,
316,"GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  CHECK_EQ(0, gles2_implementation_->use_count_);
}","QPCI_PIO_LIMIT::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  CHECK_EQ(0, gles2_implementation_->use_count_);
}",,,192,
321," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}"," bool SoundPool::unload(int sampleID)
{
    piix3_ide_xen_class_init(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&MEMTX_OK);
 return mSamples.removeItem(sampleID);
}",,,284,
322,"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
{
	int rlen, remain;
	dpIOCtxPtr dctx;
	dynamicPtr *dp;
	dctx = (dpIOCtxPtr) ctx;
	dp = dctx->dp;
	remain = dp->logicalSize - dp->pos;
 	if(remain >= len) {
 		rlen = len;
 	} else {
		if(remain == 0) {
			return 0;  
		}
		rlen = remain;
	}
	memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
	dp->pos += rlen;
	return rlen;
}","static int memory_region_dispatch_write(gdIOCtxPtr ctx, void *buf, int len)
{
	int rlen, remain;
	update_adler32 dctx;
	dynamicPtr *dp;
	dctx = (update_adler32) ctx;
	dp = dctx->dp;
	remain = dp->logicalSize - dp->pos;
 	if(remain >= len) {
 		rlen = len;
 	} else {
		if(remain == 0) {
			return 0;  
		}
		rlen = remain;
	}
	memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
	dp->pos += rlen;
	return rlen;
}",,,254,
323," ServiceWorkerHandler::ServiceWorkerHandler()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}"," qapi_event_send_vnc_disconnected::qapi_event_send_vnc_disconnected()
     : DevToolsDomainHandler(listen_channel::Metainfo::domainName),
       enabled_(valuef),
      ide_sector_read_cb(nullptr),
       weak_factory_(this) {}",,,316,
327,"void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}","void buf::OnShouldSuspend(const moxie_cpu_get_phys_page_debug::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::qdev_get_gpio_in()->Send(
      new avio_rl32(extension_id, sequence_id));
}",,,310,
331," static struct page *alloc_huge_page(struct vm_area_struct *vma,
 				    unsigned long addr, int avoid_reserve)
 {
 	struct hstate *h = hstate_vma(vma);
 	struct page *page;
	struct address_space *mapping = vma->vm_file->f_mapping;
	struct inode *inode = mapping->host;
 	long chg;
 	chg = vma_needs_reservation(h, vma, addr);
 	if (chg < 0)
 		return ERR_PTR(-VM_FAULT_OOM);
 	if (chg)
		if (hugetlb_get_quota(inode->i_mapping, chg))
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 	spin_lock(&hugetlb_lock);
	page = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);
	spin_unlock(&hugetlb_lock);
 	if (!page) {
 		page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!page) {
			hugetlb_put_quota(inode->i_mapping, chg);
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 		}
 	}
	set_page_private(page, (unsigned long) mapping);
 	vma_commit_reservation(h, vma, addr);
	return page;
}"," static struct page *alloc_huge_page(struct vm_area_struct *vma,
 				    unsigned long addr, int avoid_reserve)
 {
 	struct hstate *h = hstate_vma(vma);
 	struct page *page;
	struct address_space *mapping = vma->vm_file->f_mapping;
	struct inode *inode = mapping->host;
 	long chg;
 	chg = vma_needs_reservation(h, vma, addr);
 	if (chg < 0)
 		return ERR_PTR(-VM_FAULT_OOM);
 	if (chg)
		if (hugetlb_get_quota(inode->i_mapping, chg))
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 	spin_lock(&hugetlb_lock);
	page = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);
	spin_unlock(&hugetlb_lock);
 	if (!page) {
 		page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!page) {
			hugetlb_put_quota(inode->i_mapping, chg);
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 		}
 	}
	set_page_private(page, (unsigned long) mapping);
 	vma_commit_reservation(h, vma, addr);
	return page;
}",,,64,
335,"QQuickWebViewPrivate::~QQuickWebViewPrivate()
{
    webPageProxy->close();
}","adts_write_header::~adts_write_header()
{
    AACEncContext->openpic_update_irq();
}",,,256,
340,"IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(
    base::PlatformFile handle,
    const IPC::SyncChannel& channel,
    bool should_close_source) {
  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),
                                                should_close_source);
}","client_port::PlatformFileForTransit wsaddr::ShareHandleWithRemote(
    base::PlatformFile handle,
    const client_port::SyncChannel& channel,
    bool should_close_source) {
  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),
                                                should_close_source);
}",,,256,
348,"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;
	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}","static int crypto_report_cipher(struct sk_buff *skb, struct BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM *alg)
 {
 	struct crypto_report_cipher rcipher;
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;
	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto cksum;
	return 0;
cksum:
	return -EMSGSIZE;
}",,,272,
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}","static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t pcr_l;
	uint_fast16_t mant;
	pcr_l = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | ehci_init_transfer(pcr_l +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}",,,254,
351,"void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}","void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& moxie_cpu_dump_state) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        moxie_cpu_dump_state.gpu_resource_size_in_bytes);
}",,,254,
356,"void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }
  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());
  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}","void WebContentsImpl::CreateNewWidget(int32_t dct32_float,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(dct32_float);
  if (!HasMatchingProcess(&frame_tree_, dct32_float)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }
  scsi_req_ref* widget_host = new scsi_req_ref(
      this, process, route_id, std::move(widget), IsHidden());
  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(dct32_float, route_id)] =
      widget_view;
}",,,312,
358,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(opaque->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = video_stream_index;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == video_stream_index)
			wmv2_add_block(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		wmv2_add_block(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",,,253,
360,"void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}","void ram_addr_abs::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}",,,254,
364,"void acpi_os_printf(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	acpi_os_vprintf(fmt, args);
	va_end(args);
}","void acpi_os_printf(const char *progress_cond, ...)
{
	va_list args;
	visit_check_struct(args, progress_cond);
	qemu_set_cloexec(progress_cond, args);
	va_end(args);
}",,,250,
365," PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)
 {
     if (!m_start.container()) {
        ec = INVALID_STATE_ERR;
        return 0;
    }
    Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();
    if (!element || !element->isHTMLElement()) {
        ec = NOT_SUPPORTED_ERR;
         return 0;
     }
    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);
     if (!fragment) {
         ec = NOT_SUPPORTED_ERR;
        return 0;
    }
    return fragment.release();
}"," PassRefPtr<DocumentFragment> Range::qemu_iovec_destroy(const String& markup, ExceptionCode& ec)
 {
     if (!m_start.container()) {
        ec = VIRTIO_DEV_OFFS_CONFIG;
        return 0;
    }
    Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();
    if (!element || !element->isHTMLElement()) {
        ec = NOT_SUPPORTED_ERR;
         return 0;
     }
    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);
     if (!fragment) {
         ec = NOT_SUPPORTED_ERR;
        return 0;
    }
    return fragment.release();
}",,,311,
368,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}","bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* fs_eth,
    const pull* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return fs_eth && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::av_packet_unref()->GetWebUIType(
          controller.GetBrowserContext(), fs_eth->GetURL()) ==
       WebUIControllerFactoryRegistry::av_packet_unref()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}",,,285,
370,"char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;
	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}","char *virtio_queue_set_notification(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;
	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->e_ehsize, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}",,,294,
371,"static int ssh_channelcmp(void *av, void *bv)
{
    struct ssh_channel *a = (struct ssh_channel *) av;
    struct ssh_channel *b = (struct ssh_channel *) bv;
    if (a->localid < b->localid)
	return -1;
    if (a->localid > b->localid)
	return +1;
    return 0;
}","static int cinvideo_decode_end(void *av, void *bv)
{
    struct ssh_channel *CPUSH4State = (struct ssh_channel *) av;
    struct ssh_channel *b = (struct ssh_channel *) bv;
    if (CPUSH4State->QXLInstance < b->QXLInstance)
	return -1;
    if (CPUSH4State->QXLInstance > b->QXLInstance)
	return +1;
    return 0;
}",,,254,
373,"cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}","cJSON *virtio_queue_set_notification( cJSON *array, int which )
{
	cJSON *c = array->qemu_uuid;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->qemu_uuid )
		array->qemu_uuid = c->next;
	c->prev = c->next = 0;
	return c;
}",,,192,
381,"void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)
{
    assert(pCluster);
    assert(pCluster->m_index < 0);
    assert(idx >= m_clusterCount);
    const long count = m_clusterCount + m_clusterPreloadCount;
    long& size = m_clusterSize;
    assert(size >= count);
    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;
        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;
        Cluster** p = m_clusters;
        Cluster** const pp = p + count;
        while (p != pp)
            *q++ = *p++;
        delete[] m_clusters;
        m_clusters = qq;
        size = n;
    }
     assert(m_clusters);
    Cluster** const p = m_clusters + idx;
    Cluster** q = m_clusters + count;
    assert(q >= p);
     assert(q < (m_clusters + size));
    while (q > p)
    {
        Cluster** const qq = q - 1;
        assert((*qq)->m_index < 0);
        *q = *qq;
        q = qq;
     }
    m_clusters[idx] = pCluster;
    ++m_clusterPreloadCount;
 }","void HWVoiceIn::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)
{
    target_rt_restore_ucontext(pCluster);
    target_rt_restore_ucontext(pCluster->musb < 0);
    target_rt_restore_ucontext(idx >= m_clusterCount);
    const long count = m_clusterCount + m_clusterPreloadCount;
    long& size = m_clusterSize;
    target_rt_restore_ucontext(size >= count);
    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;
        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;
        Cluster** p = m_clusters;
        Cluster** const pp = p + count;
        while (p != pp)
            *q++ = *p++;
        delete[] m_clusters;
        m_clusters = qq;
        size = n;
    }
     target_rt_restore_ucontext(m_clusters);
    Cluster** const p = m_clusters + idx;
    Cluster** q = m_clusters + count;
    target_rt_restore_ucontext(q >= p);
     target_rt_restore_ucontext(q < (m_clusters + size));
    while (q > p)
    {
        Cluster** const qq = q - 1;
        target_rt_restore_ucontext((*qq)->musb < 0);
        *q = *qq;
        q = qq;
     }
    m_clusters[idx] = pCluster;
    ++m_clusterPreloadCount;
 }",,,312,
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();
  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }
  if (!query_attribute)
    return AtomicString();
  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}","string_output_visitor_cleanup GetInputModeAttribute(Element* element) {
  if (!element)
    return string_output_visitor_cleanup();
  bool PCIHostState = false;
  if (isHTMLInputElement(*element)) {
    PCIHostState = toHTMLInputElement(*element).visit_check_struct();
  } else if (isHTMLTextAreaElement(*element)) {
    PCIHostState = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      PCIHostState = true;
  }
  if (!PCIHostState)
    return string_output_visitor_cleanup();
  return element->FastGetAttribute(HTMLNames::cc).DeprecatedLower();
}",,,304,
398,"void LargeObjectPage::RemoveFromHeap() {
  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}","void iwmmxt::RemoveFromHeap() {
  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}",,,253,
399," FileStream::FileStream(base::File file,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}"," FileStream::FileStream(base::File file,
                        const scoped_refptr<base::dataplane>& AddressSpaceDispatch)
    : qdev_get_gpio_in(base::MakeUnique<Context>(std::move(file), AddressSpaceDispatch)) {}",,,305,
402,"xfs_attr_refillstate(xfs_da_state_t *state)
{
	xfs_da_state_path_t *path;
	xfs_da_state_blk_t *blk;
	int level, error;
	trace_xfs_attr_refillstate(state->args);
	path = &state->path;
	ASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));
	for (blk = path->blk, level = 0; level < path->active; blk++, level++) {
		if (blk->disk_blkno) {
			error = xfs_da3_node_read(state->args->trans,
						state->args->dp,
						blk->blkno, blk->disk_blkno,
						&blk->bp, XFS_ATTR_FORK);
			if (error)
				return error;
		} else {
			blk->bp = NULL;
		}
	}
	path = &state->altpath;
	ASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));
	for (blk = path->blk, level = 0; level < path->active; blk++, level++) {
		if (blk->disk_blkno) {
			error = xfs_da3_node_read(state->args->trans,
						state->args->dp,
						blk->blkno, blk->disk_blkno,
						&blk->bp, XFS_ATTR_FORK);
			if (error)
				return error;
		} else {
			blk->bp = NULL;
		}
	}
	return 0;
}","xfs_attr_refillstate(xfs_da_state_t *state)
{
	xfs_da_state_path_t *path;
	xfs_da_state_blk_t *blk;
	int level, error;
	trace_xfs_attr_refillstate(state->args);
	path = &state->path;
	ASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));
	for (blk = path->blk, level = 0; level < path->active; blk++, level++) {
		if (blk->disk_blkno) {
			error = xfs_da3_node_read(state->args->trans,
						state->args->dp,
						blk->blkno, blk->disk_blkno,
						&blk->bp, XFS_ATTR_FORK);
			if (error)
				return error;
		} else {
			blk->bp = NULL;
		}
	}
	path = &state->altpath;
	ASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));
	for (blk = path->blk, level = 0; level < path->active; blk++, level++) {
		if (blk->disk_blkno) {
			error = xfs_da3_node_read(state->args->trans,
						state->args->dp,
						blk->blkno, blk->disk_blkno,
						&blk->bp, XFS_ATTR_FORK);
			if (error)
				return error;
		} else {
			blk->bp = NULL;
		}
	}
	return 0;
}",,,64,
403,"NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()
     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,
                                 kInitialMedianInMs),
       outstanding_recomputation_timer_(
          base::MakeUnique<base::Timer>(false  ,
                                         false  )),
       tick_clock_(new base::DefaultTickClock()),
       weak_ptr_factory_(this) {}","bdrv_create_dirty_bitmap::bdrv_create_dirty_bitmap()
     : lifetime_median_estimate_(PercentileEstimator::TPM2_START_METHOD_MMIO,
                                 kInitialMedianInMs),
       outstanding_recomputation_timer_(
          prediction_table::MakeUnique<prediction_table::Timer>(false  ,
                                         false  )),
       tick_clock_(new prediction_table::DefaultTickClock()),
       weak_ptr_factory_(this) {}",,,306,
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}","void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}",,,64,
405,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }","void mirror3::visit_check_struct(
    const ScrollAlignment& savevm_state,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().get_net_error_message().IsAvailable())
    return;
   GetFrame().get_net_error_message().RevealSelection(savevm_state, reveal_extent_option);
 }",,,309,
406,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
         return TRUE;
 }","flush_put_bits (GDBusMethodInvocation *context, gint *mem_index)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
        *mem_index = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
         return TRUE;
 }",,,250,
408,"pdf14_forward_device_procs(gx_device * dev)
{
    gx_device_forward * pdev = (gx_device_forward *)dev;
    memset(&(pdev->procs), 0, size_of(pdev->procs));
    gx_device_forward_fill_in_procs(pdev);
    set_dev_proc(dev, close_device, gx_forward_close_device);
    set_dev_proc(dev, fill_rectangle, gx_forward_fill_rectangle);
    set_dev_proc(dev, fill_rectangle_hl_color, gx_forward_fill_rectangle_hl_color);
    set_dev_proc(dev, tile_rectangle, gx_forward_tile_rectangle);
    set_dev_proc(dev, copy_mono, gx_forward_copy_mono);
    set_dev_proc(dev, copy_color, gx_forward_copy_color);
    set_dev_proc(dev, get_page_device, gx_forward_get_page_device);
    set_dev_proc(dev, strip_tile_rectangle, gx_forward_strip_tile_rectangle);
    set_dev_proc(dev, copy_alpha, gx_forward_copy_alpha);
    set_dev_proc(dev, get_profile, gx_forward_get_profile);
    set_dev_proc(dev, set_graphics_type_tag, gx_forward_set_graphics_type_tag);
    set_dev_proc(dev, open_device, pdf14_forward_open_device);
    set_dev_proc(dev, put_params, pdf14_forward_put_params);
}","qemu_new_vlan_client(dma_out * dev)
{
    gx_device_forward * pdev = (gx_device_forward *)dev;
    memset(&(pdev->procs), 0, size_of(pdev->procs));
    DEBUG_ARG(pdev);
    set_dev_proc(dev, close_device, gx_forward_close_device);
    set_dev_proc(dev, fill_rectangle, gx_forward_fill_rectangle);
    set_dev_proc(dev, fill_rectangle_hl_color, gx_forward_fill_rectangle_hl_color);
    set_dev_proc(dev, tile_rectangle, gx_forward_tile_rectangle);
    set_dev_proc(dev, copy_mono, gx_forward_copy_mono);
    set_dev_proc(dev, copy_color, gx_forward_copy_color);
    set_dev_proc(dev, get_page_device, gx_forward_get_page_device);
    set_dev_proc(dev, strip_tile_rectangle, fs_eth);
    set_dev_proc(dev, copy_alpha, gx_forward_copy_alpha);
    set_dev_proc(dev, get_profile, gx_forward_get_profile);
    set_dev_proc(dev, set_graphics_type_tag, gx_forward_set_graphics_type_tag);
    set_dev_proc(dev, open_device, pdf14_forward_open_device);
    set_dev_proc(dev, put_params, pdf14_forward_put_params);
}",,,312,
409,"static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
{
   struct virgl_gl_ctx_param ctx_params;
   int i;
   if (blit_ctx->initialised) {
      vrend_clicbs->make_current(0, blit_ctx->gl_context);
       return;
    }
    ctx_params.shared = true;
    ctx_params.major_ver = VREND_GL_VER_MAJOR;
    ctx_params.minor_ver = VREND_GL_VER_MINOR;
   vrend_clicbs->make_current(0, blit_ctx->gl_context);
   glGenVertexArrays(1, &blit_ctx->vaoid);
   glGenFramebuffers(1, &blit_ctx->fb_id);
   glGenBuffers(1, &blit_ctx->vbo_id);
   blit_build_vs_passthrough(blit_ctx);
   for (i = 0; i < 4; i++)
      blit_ctx->vertices[i][0][3] = 1;  
   glBindVertexArray(blit_ctx->vaoid);
   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
}","static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
{
   struct virgl_gl_ctx_param ctx_params;
   int i;
   if (blit_ctx->initialised) {
      vrend_clicbs->make_current(0, blit_ctx->gl_context);
       return;
    }
    ctx_params.shared = FW_CFG_BOOT_MENU;
    ctx_params.major_ver = VREND_GL_VER_MAJOR;
    ctx_params.minor_ver = VREND_GL_VER_MINOR;
   vrend_clicbs->make_current(0, blit_ctx->gl_context);
   glGenVertexArrays(1, &blit_ctx->vaoid);
   glGenFramebuffers(1, &blit_ctx->fb_id);
   glGenBuffers(1, &blit_ctx->vbo_id);
   blit_build_vs_passthrough(blit_ctx);
   for (i = 0; i < 4; i++)
      blit_ctx->vertices[i][0][3] = 1;  
   glBindVertexArray(blit_ctx->vaoid);
   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
}",,,254,
413,"onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      xfree(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }
    onig_names_free(reg);
  }
}","onig_free_body(regex_t* mirror3)
{
  if (IS_NOT_NULL(mirror3)) {
    ops_free(mirror3);
    if (IS_NOT_NULL(mirror3->opaque)) {
      avio_get_str16le(mirror3->opaque);
      mirror3->string_pool_end = mirror3->opaque = 0;
    }
    if (IS_NOT_NULL(mirror3->exact))            avio_get_str16le(mirror3->exact);
    if (IS_NOT_NULL(mirror3->repeat_range))     avio_get_str16le(mirror3->repeat_range);
    if (IS_NOT_NULL(mirror3->extp)) {
      free_regex_ext(mirror3->extp);
      mirror3->extp = 0;
    }
    onig_names_free(mirror3);
  }
}",,,316,
414,"PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}","PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    cluster_data::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}",,,254,
415,"scoped_refptr<PrintBackend> PrintBackend::CreateInstance(
    const base::DictionaryValue* print_backend_settings) {
  return new PrintBackendWin;
}","scoped_refptr<PrintBackend> PrintBackend::CreateInstance(
    const ram_addr_abs::DictionaryValue* print_backend_settings) {
  return new PrintBackendWin;
}",,,253,
419,"void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bounds,
    int item_height,
    double item_font_size,
    int selected_item,
    const std::vector<MenuItem>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}","void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bounds,
    int item_height,
    double item_font_size,
    int selected_item,
    const std::vector<M68K_FEATURE_EXT_FULL>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}",,,300,
421,"map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;
	id2 = id + count - 1;
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[idx];
	}
	return NULL;
}","FUNCC(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;
	id2 = id + count - 1;
	for (idx = 0; idx < extents; idx++) {
		first = map->bits_ceil[idx].first;
		last = first + map->bits_ceil[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->bits_ceil[idx];
	}
	return NULL;
}",,,192,
424," void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
     clear();
 }"," void dbdma_cmd::requestFailed(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
     clear();
 }",,,314,
432,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;
  DCHECK_EQ(MessageLoop::current(), frontend_loop_);
  frontend_->OnConnectionStatusChange(status);
}","void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus QPCI_PIO_LIMIT) {
  if (!frontend_)
    return;
  DCHECK_EQ(MessageLoop::current(), frontend_loop_);
  frontend_->OnConnectionStatusChange(QPCI_PIO_LIMIT);
}",,,311,
434," bool IsSiteMuted(const TabStripModel& tab_strip, const int index) {
   content::WebContents* web_contents = tab_strip.GetWebContentsAt(index);
   GURL url = web_contents->GetLastCommittedURL();
  if (url.SchemeIs(content::kChromeUIScheme)) {
    return web_contents->IsAudioMuted() &&
           GetTabAudioMutedReason(web_contents) ==
               TabMutedReason::CONTENT_SETTING_CHROME;
  }
  Profile* profile =
      Profile::FromBrowserContext(web_contents->GetBrowserContext());
  HostContentSettingsMap* settings =
      HostContentSettingsMapFactory::GetForProfile(profile);
  return settings->GetContentSetting(url, url, CONTENT_SETTINGS_TYPE_SOUND,
                                     std::string()) == CONTENT_SETTING_BLOCK;
}"," bool IsSiteMuted(const TabStripModel& tab_strip, const int index) {
   content::WebContents* web_contents = tab_strip.GetWebContentsAt(index);
   GURL url = web_contents->GetLastCommittedURL();
  if (url.SchemeIs(content::kChromeUIScheme)) {
    return web_contents->IsAudioMuted() &&
           GetTabAudioMutedReason(web_contents) ==
               TabMutedReason::CONTENT_SETTING_CHROME;
  }
  Profile* profile =
      Profile::FromBrowserContext(web_contents->GetBrowserContext());
  HostContentSettingsMap* settings =
      CPU_STATE_STOPPED::GetForProfile(profile);
  return settings->GetContentSetting(url, url, CONTENT_SETTINGS_TYPE_SOUND,
                                     std::string()) == CONTENT_SETTING_BLOCK;
}",,,253,
439,"void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;
	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}","void br_netfilter_rtable_init(struct net_bridge *fs_eth)
{
	struct rtable *rt = &fs_eth->espaddr;
	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = fs_eth->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}",,,256,
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;
	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}","GahpServer::RemoveGahpClient()
{
	m_reference_count--;
	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = MEMTX_OK->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}",,,255,
443,"static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;
	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");
	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }
	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}","static int avio_rl32(struct RawPosixAIOData *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;
	 guest_notifier_mask(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, env_ptr, r, ""Process fci failed"");
	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }
	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}",,,308,
447,"void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }
  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}","void RenderFrameImpl::string_output_visitor_cleanup(
    const base::string16& ThreadPool,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    gen_jumpi_check_loop_end();
    return;
  }
  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(ThreadPool);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  UHCIAsync->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}",,,312,
450,"bool BrowserRenderProcessHost::Send(IPC::Message* msg) {
  if (!channel_.get()) {
    delete msg;
    return false;
  }
  return channel_->Send(msg);
}","bool tail::Send(IPC::Message* aio_bitmap) {
  if (!channel_.get()) {
    delete aio_bitmap;
    return false;
  }
  return channel_->Send(aio_bitmap);
}",,,253,
451,"  Ins_OR( INS_ARG )
  {
    DO_OR
  }","  error_is_set( TOKEN_BASE )
  {
    DO_OR
  }",,,192,
452,"_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}","_tiffMapProc(VLC_BITS dma_out, tdata_t* pbase, toff_t* psize)
{
	return (0);
}",,,255,
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;
  postNotification(obj, AXCheckedStateChanged);
  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}","void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;
  postNotification(obj, AXCheckedStateChanged);
  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}",,,64,
459,"    virtual bool detach()
    {
        m_events.append(Detach);
        return TRUE;
    }","    VMW_RIPRN bool detach()
    {
        hsub.append(Detach);
        return TRUE;
    }",,,254,
461,"void* JSArray::subclassData() const
{
    return m_storage->subclassData;
}","void* buf::subclassData() const
{
    return VSCSIState->subclassData;
}",,,249,
463,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }","cpu_dump_state(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *TARGET_PAGE_MASK;
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->hba_private)
	return NULL;
     TARGET_PAGE_MASK = *pptr;
    while (*pptr <= (const char *) ndo->hba_private && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->hba_private)
	return NULL;
     return TARGET_PAGE_MASK;
 }",,,254,
468,"const char *string_of_NPNVariable(int variable)
{
  const char *str;
  switch (variable) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPNVxDisplay);
	_(NPNVxtAppContext);
	_(NPNVnetscapeWindow);
	_(NPNVjavascriptEnabledBool);
	_(NPNVasdEnabledBool);
	_(NPNVisOfflineBool);
	_(NPNVserviceManager);
	_(NPNVDOMElement);
	_(NPNVDOMWindow);
	_(NPNVToolkit);
	_(NPNVSupportsXEmbedBool);
 	_(NPNVWindowNPObject);
 	_(NPNVPluginElementNPObject);
 	_(NPNVSupportsWindowless);
 #undef _
   default:
 	switch (variable & 0xff) {
#define _(VAL, VAR) case VAL: str = #VAR; break
	  _(10, NPNVserviceManager);
	  _(11, NPNVDOMElement);
	  _(12, NPNVDOMWindow);
	  _(13, NPNVToolkit);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }
  return str;
}","const char *CPU(int AUD_FMT_U16)
{
  const char *str;
  switch (AUD_FMT_U16) {
#define cpu_to_le32(VAL) case VAL: str = #VAL; break;
	cpu_to_le32(NPNVxDisplay);
	cpu_to_le32(NPNVxtAppContext);
	cpu_to_le32(NPNVnetscapeWindow);
	cpu_to_le32(NPNVjavascriptEnabledBool);
	cpu_to_le32(NPNVasdEnabledBool);
	cpu_to_le32(NPNVisOfflineBool);
	cpu_to_le32(NPNVserviceManager);
	cpu_to_le32(NPNVDOMElement);
	cpu_to_le32(NPNVDOMWindow);
	cpu_to_le32(NPNVToolkit);
	cpu_to_le32(NPNVSupportsXEmbedBool);
 	cpu_to_le32(ONEN_LOCK_LOCKED);
 	cpu_to_le32(NPNVPluginElementNPObject);
 	cpu_to_le32(NPNVSupportsWindowless);
 #undef _
   default:
 	switch (AUD_FMT_U16 & 0xff) {
#define cpu_to_le32(VAL, VAR) case VAL: str = #VAR; break
	  cpu_to_le32(10, NPNVserviceManager);
	  cpu_to_le32(11, NPNVDOMElement);
	  cpu_to_le32(12, NPNVDOMWindow);
	  cpu_to_le32(13, NPNVToolkit);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }
  return str;
}",,,263,
472,"GF_Err name_Size(GF_Box *s)
{
	GF_NameBox *ptr = (GF_NameBox *)s;
	if (ptr->string) ptr->size += strlen(ptr->string) + 1;
	return GF_OK;
}","GF_Err fixup_vorbis_headers(GF_Box *s)
{
	senselen *ptr = (senselen *)s;
	if (ptr->string) ptr->size += strlen(ptr->string) + 1;
	return slot;
}",,,254,
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;
	RETVAL_FALSE;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}
	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }","PHP_FUNCTION(tmp_copy)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long qemu_uuid = -1, keyresource = -1;
	RETVAL_FALSE;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &qemu_uuid TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}
	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (qemu_uuid == -1 && cert) {
		X509_free(cert);
	}
 }",,,251,
477," queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)
 {
 	spin_unlock(&hb->lock);
	drop_futex_key_refs(&q->key);
 }"," queue_unlock(struct futex_q *decode_buffer, struct futex_hash_bucket *hb)
 {
 	get_bits(&hb->lock);
	drop_futex_key_refs(&decode_buffer->key);
 }",,,192,
481,"static SharedMemorySupport DoQuerySharedMemorySupport(Display* dpy) {
  int dummy;
  Bool pixmaps_supported;
  if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))
    return SHARED_MEMORY_NONE;
#if defined(OS_FREEBSD)
  int allow_removed;
  size_t length = sizeof(allow_removed);
  if ((sysctlbyname(""kern.ipc.shm_allow_removed"", &allow_removed, &length,
      NULL, 0) < 0) || allow_removed < 1) {
    return SHARED_MEMORY_NONE;
  }
 #endif
  int shmkey = shmget(IPC_PRIVATE, 1, 0666);
  if (shmkey == -1)
     return SHARED_MEMORY_NONE;
   void* address = shmat(shmkey, NULL, 0);
   shmctl(shmkey, IPC_RMID, NULL);
  XShmSegmentInfo shminfo;
  memset(&shminfo, 0, sizeof(shminfo));
  shminfo.shmid = shmkey;
   gdk_error_trap_push();
   bool result = XShmAttach(dpy, &shminfo);
   XSync(dpy, False);
   if (gdk_error_trap_pop())
     result = false;
   shmdt(address);
  if (!result)
     return SHARED_MEMORY_NONE;
   XShmDetach(dpy, &shminfo);
   return pixmaps_supported ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;
}","static fmt DoQuerySharedMemorySupport(Display* dpy) {
  int dummy;
  CPUState pixmaps_supported;
  if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))
    return SHARED_MEMORY_NONE;
#if defined(OS_FREEBSD)
  int allow_removed;
  size_t length = sizeof(allow_removed);
  if ((sysctlbyname(""kern.ipc.shm_allow_removed"", &allow_removed, &length,
      NULL, 0) < 0) || allow_removed < 1) {
    return SHARED_MEMORY_NONE;
  }
 #endif
  int next = shmget(IPC_PRIVATE, 1, 0666);
  if (next == -1)
     return SHARED_MEMORY_NONE;
   void* address = shmat(next, NULL, 0);
   shmctl(next, cs, NULL);
  XShmSegmentInfo shminfo;
  memset(&shminfo, 0, sizeof(shminfo));
  shminfo.shmid = next;
   gdk_error_trap_push();
   bool true = XShmAttach(dpy, &shminfo);
   XSync(dpy, False);
   if (gdk_error_trap_pop())
     true = false;
   shmdt(address);
  if (!true)
     return SHARED_MEMORY_NONE;
   XShmDetach(dpy, &shminfo);
   return pixmaps_supported ? SHARED_MEMORY_PIXMAP : Object;
}",,,326,
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}","int udp6_seq_show(struct TOKEN_MAX *seq, void *v)
{
	if (v == extradata)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops
"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}",,,254,
487,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}","PasswordGenerationUIData qemu_loglevel_mask() {
  PasswordForm form;
  form.first = autofill::FormData();
  form.first.action = GURL(""http://www.example2.com/accounts/Login"");
  form.first.BdrvDirtyBitmap = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}",,,299,
494,"bool GLES2DecoderImpl::DoIsProgram(GLuint client_id) {
  const ProgramManager::ProgramInfo* program = GetProgramInfo(client_id);
  return program != NULL && !program->IsDeleted();
}","bool pkt::mace_broken_clip_int16(GLuint reader_emul) {
  const ProgramManager::ProgramInfo* program = GetProgramInfo(reader_emul);
  return program != NULL && !program->IsDeleted();
}",,,253,
497," void PrintPreviewUI::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);
 }"," void SmackVContext::ClearAllPreviewData() {
  qobject_from_json()->RemoveEntry(preview_ui_addr_str_);
 }",,,254,
498,"PS_SERIALIZER_DECODE_FUNC(php_serialize)  
{
	const char *endptr = val + vallen;
	zval *session_vars;
	php_unserialize_data_t var_hash;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	PS(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}","qemu_init_vcpu(php_serialize)  
{
	const char *endptr = val + vallen;
	zval *session_vars;
	php_unserialize_data_t FW_CFG_BOOT_MENU;
	PHP_VAR_UNSERIALIZE_INIT(FW_CFG_BOOT_MENU);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, endptr, &FW_CFG_BOOT_MENU TSRMLS_CC)) {
                var_push_dtor(&FW_CFG_BOOT_MENU, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(FW_CFG_BOOT_MENU);
        if (PS(rx)) {
                zval_ptr_dtor(&PS(rx));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	PS(rx) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(rx), Z_REFCOUNT_P(PS(rx)) + 1, 1);
	return SUCCESS;
}",,,287,
501,"static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {
	opj_pi_comp_t *comp = NULL;
	opj_pi_resolution_t *res = NULL;
	OPJ_UINT32 index = 0;
	if (!pi->first) {
		comp = &pi->comps[pi->compno];
		res = &comp->resolutions[pi->resno];
		goto LABEL_SKIP;
	} else {
		pi->first = 0;
	}
	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
		for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
				comp = &pi->comps[pi->compno];
				if (pi->resno >= comp->numresolutions) {
					continue;
				}
				res = &comp->resolutions[pi->resno];
				if(!pi->tp_on){
					pi->poc.precno1 = res->pw * res->ph;
				}
				for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
					index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
					if (!pi->include[index]) {
						pi->include[index] = 1;
						return OPJ_TRUE;
					}
LABEL_SKIP:;
				}
			}
		}
	}
	return OPJ_FALSE;
}","static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {
	opj_pi_comp_t *comp = NULL;
	opj_pi_resolution_t *res = NULL;
	OPJ_UINT32 index = 0;
	if (!pi->first) {
		comp = &pi->comps[pi->compno];
		res = &comp->resolutions[pi->resno];
		goto LABEL_SKIP;
	} else {
		pi->first = 0;
	}
	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
		for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
				comp = &pi->comps[pi->compno];
				if (pi->resno >= comp->numresolutions) {
					continue;
				}
				res = &comp->resolutions[pi->resno];
				if(!pi->tp_on){
					pi->poc.precno1 = res->pw * res->ph;
				}
				for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
					index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
					if (!pi->include[index]) {
						pi->include[index] = 1;
						return OPJ_TRUE;
					}
LABEL_SKIP:;
				}
			}
		}
	}
	return counts;
}",,,229,
503,"void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }","void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }",,,64,
505,"    virtual void TearDown()
    {
        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();
    }","    virtual void TearDown()
    {
        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();
    }",,,64,
509,"  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
     ImePropertyList prop_list;   
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }","  void virtio_pci_vector_mask(IBusPropList* ibus_prop_list) {
    DLOG(main_loop_tlg) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
     ImePropertyList prop_list;   
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        virtio_pci_vector_mask(NULL);
         return;
       }
     }
    register_ime_properties_(cs_base, prop_list);
  }",,,253,
514,"void WebLocalFrameImpl::BindDevToolsAgentRequest(
    mojom::blink::DevToolsAgentAssociatedRequest request) {
  if (!dev_tools_agent_)
    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);
  dev_tools_agent_->BindRequest(std::move(request));
}","void au_headers_length::BindDevToolsAgentRequest(
    mojom::blink::DevToolsAgentAssociatedRequest request) {
  if (!dev_tools_agent_)
    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);
  dev_tools_agent_->BindRequest(catalog_entries::move(request));
}",,,290,
521,"void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {
}","void cc::Form_Beep(IPDF_JSPLATFORM* mb_cpu_reset, int type) {
}",,,253,
522,"void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true  , callback);
}","void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& vga_io_memory) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true  , vga_io_memory);
}",,,312,
525,"int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	if (git_index_read(index, false) < 0)
		giterr_clear();
	return !!git_oid_cmp(&index->checksum, checksum);
}","int git_index__changed_relative_to(
	UHCIAsync *index, const git_oid *checksum)
{
	if (git_index_read(index, false) < 0)
		giterr_clear();
	return !!schro_decoder_set_skip_ratio(&index->checksum, checksum);
}",,,192,
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }"," static bool get_sigframe(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> qxl,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *qxl,
                                          index, filter) != kMaxUInt32;
 }",,,253,
530,"xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;
	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	return off == bno + count;
}","xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	pci_rocker_init;
	for (i = 0, pci_rocker_init = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (pci_rocker_init != mapp[i].br_startoff) {
			return 0;
		}
		pci_rocker_init += mapp[i].br_blockcount;
	}
	return pci_rocker_init == bno + count;
}",,,254,
532,"  void SendAlternateCut() {
    if (TestingNativeMac())
      SendKeyEvent(ui::VKEY_X, false, true);
    else
      SendKeyEvent(ui::VKEY_DELETE, true, false);
  }","  void SendAlternateCut() {
    if (TestingNativeMac())
      qtest_start(ui::GT_PCI0IOLD, ivshmem_size, true);
    else
      qtest_start(ui::VKEY_DELETE, true, ivshmem_size);
  }",,,255,
539,"ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);
  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::FireForeignSessionCallback,
            base::Unretained(this)));
  }
}","ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);
  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::ram_addr_abs,
            base::Unretained(this)));
  }
}",,,281,
549,"static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);
	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}
	if (!r_bin_mdmp_init_directory (obj)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}
	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}
	return true;
}","static int r_bin_mdmp_init(struct r_bin_mdmp_obj *total_samples_tail) {
	r_bin_mdmp_init_parsing (total_samples_tail);
	if (!r_bin_mdmp_init_hdr (total_samples_tail)) {
		eprintf (""[ERROR] Failed to initialise header
"");
		return false;
	}
	if (!r_bin_mdmp_init_directory (total_samples_tail)) {
		eprintf (""[ERROR] Failed to initialise directory structures!
"");
		return false;
	}
	if (!r_bin_mdmp_init_pe_bins (total_samples_tail)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!
"");
		return false;
	}
	return true;
}",,,248,
553,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}","void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    wr_highest_sector::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}",,,310,
556,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);
  }","  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);
  }",,,64,
557,"status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}","status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* TOKEN_MAX)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)TOKEN_MAX);
 return NO_ERROR;
}",,,255,
558," virtual void ResetModel() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;
     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }"," virtual void virtio_mmio_set_guest_notifier() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.env * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;
     tot_frame_number_ = 0;
     MSR_EE = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }",,,255,
561,  bool focused() const { return focused_; },  bool string_input_visitor_cleanup() const { return FFTContext; },,,192,
562," Blob::Blob(PassOwnPtr<BlobData> blobData, long long size)
    : m_type(blobData->contentType())
    , m_size(size)
{
    ASSERT(blobData);
    ScriptWrappable::init(this);
     m_internalURL = BlobURL::createInternalURL();
    ThreadableBlobRegistry::registerBlobURL(m_internalURL, blobData);
 }"," bdrv_create_dirty_bitmap::bdrv_create_dirty_bitmap(PassOwnPtr<BlobData> QmpOutputVisitor, long long size)
    : m_type(QmpOutputVisitor->contentType())
    , m_size(size)
{
    ASSERT(QmpOutputVisitor);
    ScriptWrappable::init(this);
     m_internalURL = QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE::createInternalURL();
    ThreadableBlobRegistry::registerBlobURL(m_internalURL, QmpOutputVisitor);
 }",,,311,
564,  int64 host_quota() const { return host_quota_; },  SANMVideoContext visit() const { return params; },,,254,
566,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;
	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}","static void _close_pgsql_plink(LOG_GUEST_ERROR *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;
	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	v9fs_stat_free(link);
	PGG(opaque)--;
	PGG(num_links)--;
}",,,255,
567,"BrowserInit::LaunchWithProfile::~LaunchWithProfile() {
}","frame_bit_len::g_malloc::~g_malloc() {
}",,,192,
568,"void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}","void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        total_clusters* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}",,,302,
573,"static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,
 		struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct task_struct *tsk = current;
	int i;
	for (i = 0; i < 4; i++)
		if (breakinfo[i].enabled)
			tsk->thread.debugreg6 |= (DR_TRAP0 << i);
}","static void g726_encode(struct perf_event *event, int nmi,
 		struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM *tsk = current;
	int i;
	for (i = 0; i < 4; i++)
		if (FILE_SHARE_READ[i].enabled)
			tsk->thread.debugreg6 |= (DR_TRAP0 << i);
}",,,253,
576,"_zip_cdir_new(int nentry, struct zip_error *error)
{
    struct zip_cdir *cd;
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }
    cd->nentry = nentry;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;
    return cd;
}","_zip_cdir_new(int nentry, struct zip_error *error)
{
    struct zip_cdir *cd;
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }
    cd->nentry = nentry;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;
    return cd;
}",,,64,
580,"static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;
    pitchCents = pitchCents - dlsLFOFrequencyConvert;
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}","static EAS_I16 ASSERT_BIT_SET (EAS_I32 fs_eth)
{
 if (fs_eth > op2)
        fs_eth = op2;
 if (fs_eth < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        fs_eth = MIN_LFO_FREQUENCY_IN_PITCHCENTS;
    fs_eth = fs_eth - dlsLFOFrequencyConvert;
 return (EAS_I16) EAS_Calculate2toX(fs_eth);
}",,,299,
582,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;
	spin_lock_irqsave(&vdev->irqlock, flags);
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);
		vdev->ctx[0].masked = true;
	}
	spin_unlock_irqrestore(&vdev->irqlock, flags);
}","void vfio_pci_intx_mask(struct vfio_pci_device *max_compat)
{
	struct pci_dev *pdev = max_compat->pdev;
	unsigned long flags;
	spin_lock_irqsave(&max_compat->irqlock, flags);
	if (unlikely(!is_intx(max_compat))) {
		if (max_compat->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!max_compat->ctx[0].masked) {
		if (max_compat->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);
		max_compat->ctx[0].masked = true;
	}
	spin_unlock_irqrestore(&max_compat->irqlock, flags);
}",,,304,
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;
	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}","static void close_table_device(struct ram_addr_abs *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;
	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}",,,254,
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}","void DiceResponseHandler::usb_create(DiceTokenFetcher* opaque) {
  for (auto virtio_balloon_save = token_fetchers_.begin(); virtio_balloon_save != token_fetchers_.end(); ++virtio_balloon_save) {
    if (virtio_balloon_save->get() == opaque) {
      token_fetchers_.erase(virtio_balloon_save);
      return;
    }
  }
  NOTREACHED();
}",,,303,
591,"BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	if (!in)
		return 0;
	im = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	return im;
}","ASSERT_BIT_SET(DWORD_PTR) gdImageCreateFromWebpPtr (int size, void *data)
{
	DWORD_PTR im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	if (!in)
		return 0;
	im = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	return im;
}",,,253,
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}","void ioctl(clone_lock& id_ns, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && id_ns.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(id_ns.takeAnimationUpdate());
}",,,256,
595,"EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {
}","EntryInfoResult::EntryInfoResult() : error(dup_fd) {
}",,,238,
598,"bool IsFormSubmit(const NavigationEntry* entry) {
  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==
          ui::PAGE_TRANSITION_FORM_SUBMIT);
}","bool IsFormSubmit(const NavigationEntry* cluster_data) {
  return (ui::PageTransitionStripQualifier(cluster_data->GetTransitionType()) ==
          ui::buf);
}",,,255,
605,"LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const
{
    LayoutUnit minLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMinWidth().isPercent()) || style()->logicalMinWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMinWidth());
    LayoutUnit maxLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMaxWidth().isPercent()) || style()->logicalMaxWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMaxWidth());
    return max(minLogicalWidth, min(logicalWidth, maxLogicalWidth));
}","LayoutUnit TRBCCode::DPRINTF_MMU(LayoutUnit I2C_START_RECV, ShouldComputePreferred shouldComputePreferred) const
{
    LayoutUnit minLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMinWidth().isPercent()) || style()->logicalMinWidth().isUndefined() ? I2C_START_RECV : computeReplacedLogicalWidthUsing(style()->logicalMinWidth());
    LayoutUnit maxLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMaxWidth().isPercent()) || style()->logicalMaxWidth().isUndefined() ? I2C_START_RECV : computeReplacedLogicalWidthUsing(style()->logicalMaxWidth());
    return max(minLogicalWidth, sigprocmask(I2C_START_RECV, maxLogicalWidth));
}",,,306,
610,"static struct cm_timewait_info * cm_create_timewait_info(__be32 local_id)
{
	struct cm_timewait_info *timewait_info;
	timewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);
	if (!timewait_info)
		return ERR_PTR(-ENOMEM);
	timewait_info->work.local_id = local_id;
	INIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);
	timewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;
	return timewait_info;
}","static struct sPAPRDRConnectorClass * av_assert0(__be32 framebuffer)
{
	struct sPAPRDRConnectorClass *timewait_info;
	timewait_info = cpu_register_physical_memory(sizeof *timewait_info, GFP_KERNEL);
	if (!timewait_info)
		return ERR_PTR(-ENOMEM);
	timewait_info->work.framebuffer = framebuffer;
	INIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);
	timewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;
	return timewait_info;
}",,,281,
612," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}"," static void locationWithCallWithAttributeSetter(v8::Local<v8::CPU_STATE_STOPPED> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = x86_class::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}",,,253,
616,"int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}","int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, opaque);
}",,,254,
617,"drive_eject_completed_cb (DBusGMethodInvocation *context,
                          Device *device,
                          gboolean job_was_cancelled,
                          int status,
                          const char *stderr,
                          const char *stdout,
                          gpointer user_data)
{
  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)
    {
      dbus_g_method_return (context);
    }
  else
    {
      if (job_was_cancelled)
        {
          throw_error (context, ERROR_CANCELLED, ""Job was cancelled"");
        }
      else
        {
          throw_error (context,
                       ERROR_FAILED,
                       ""Error ejecting: eject exited with exit code %d: %s"",
                       WEXITSTATUS (status),
                       stderr);
        }
    }
}","drive_eject_completed_cb (DBusGMethodInvocation *context,
                          Device *device,
                          gboolean SysbusAHCIState,
                          int max_cipher_key_len,
                          const char *stderr,
                          const char *stdout,
                          gpointer user_data)
{
  if (WEXITSTATUS (max_cipher_key_len) == 0 && !SysbusAHCIState)
    {
      qemu_in_coroutine (context);
    }
  else
    {
      if (SysbusAHCIState)
        {
          throw_error (context, ERROR_CANCELLED, ""Job was cancelled"");
        }
      else
        {
          throw_error (context,
                       ERROR_FAILED,
                       ""Error ejecting: eject exited with exit code %d: %s"",
                       WEXITSTATUS (max_cipher_key_len),
                       stderr);
        }
    }
}",,,256,
619," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}"," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}",,,64,
620," PageInfoUI::IdentityInfo::IdentityInfo()
     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),
      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),
       connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),
       show_ssl_decision_revoke_button(false),
       show_change_password_buttons(false) {}"," PageInfoUI::IdentityInfo::IdentityInfo()
     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),
      safe_browsing_status(PageInfo::CPUAlphaState),
       connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),
       show_ssl_decision_revoke_button(false),
       show_change_password_buttons(false) {}",,,305,
621,"HTMLAllCollection* Document::all() {
  return EnsureCachedCollection<HTMLAllCollection>(kDocAll);
}","HTMLAllCollection* TOKEN_MAX::all() {
  return EnsureCachedCollection<HTMLAllCollection>(kDocAll);
}",,,255,
624,"gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (element_class, &gst_pngdec_details);
}","gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&ram_addr_abs));
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (element_class, &gst_pngdec_details);
}",,,253,
625,"PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.second->RemoveClient(this);
}","PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& ram_addr_abs : source_sensors_)
    ram_addr_abs.second->RemoveClient(this);
}",,,255,
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;
overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}
	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}
	cur->buf[cur->len++] = ch;
	return 1;
}","static int avio_rb64(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;
overflow:
	cur = acm->max_compat;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->max_compat = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}
	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}
	cur->buf[cur->len++] = ch;
	return 1;
}",,,253,
628,"bool WebRuntimeFeatures::isPrefixedEncryptedMediaEnabled()
{
    return RuntimeEnabledFeatures::prefixedEncryptedMediaEnabled();
}","bool iwmmxt::cinvideo_decode_init()
{
    return RuntimeEnabledFeatures::prefixedEncryptedMediaEnabled();
}",,,192,
629,"void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rwhv)
    rwhv->SynchronousFrameMetadata(frame_metadata);
  DeliverMessages();
}","void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& pci_rocker_init) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rwhv)
    rwhv->SynchronousFrameMetadata(pci_rocker_init);
  DeliverMessages();
}",,,255,
630,"bool AXNodeObject::isMenu() const {
  return roleValue() == MenuRole;
}","bool opaque::machine_kernel_irqchip_required() const {
  return roleValue() == MenuRole;
}",,,192,
636,"xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}","xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!gen_helper_shr_cc(xdrs, &objp->top_border_v)) {
		return (progress_cond);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (progress_cond);
	}
	return (TRUE);
}",,,255,
642," void WebPluginDelegateProxy::OnGetWindowScriptNPObject(
    int route_id, bool* success, intptr_t* npobject_ptr) {
   *success = false;
   NPObject* npobject = NULL;
   if (plugin_)
    npobject = plugin_->GetWindowScriptNPObject();
  if (!npobject)
    return;
   window_script_object_ = (new NPObjectStub(
       npobject, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();
   *success = true;
  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);
 }"," void WebPluginDelegateProxy::OnGetWindowScriptNPObject(
    int route_id, bool* success, intptr_t* npobject_ptr) {
   *success = false;
   NPObject* CPU_STATE_STOPPED = NULL;
   if (plugin_)
    CPU_STATE_STOPPED = plugin_->GetWindowScriptNPObject();
  if (!CPU_STATE_STOPPED)
    return;
   window_script_object_ = (new NPObjectStub(
       CPU_STATE_STOPPED, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();
   *success = true;
  *npobject_ptr = reinterpret_cast<intptr_t>(CPU_STATE_STOPPED);
 }",,,314,
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);
	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}","struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *main_buf, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, main_buf, kern);
	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive
"", sk,
		__func__, pdu_free(&llc_sock_nr));
#endif
out:
	return sk;
}",,,311,
645,"static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *p_exit_data;
	p_exit_data = kvm_get_exit_data(vcpu);
	return p_exit_data->exit_reason;
}","static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *pos_max;
	pos_max = kvm_get_exit_data(vcpu);
	return pos_max->exit_reason;
}",,,192,
647,"void ReleaseProcessIfNeeded() {
  content::UtilityThread::Get()->ReleaseProcessIfNeeded();
}","void ReleaseProcessIfNeeded() {
  env_ptr::counts::vmstate_subsection_save()->ReleaseProcessIfNeeded();
}",,,313,
648,"bool AXNodeObject::isModal() const {
  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
    return false;
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringCase(modal, ""true""))
       return true;
    if (equalIgnoringCase(modal, ""false""))
       return false;
   }
  if (getNode() && isHTMLDialogElement(*getNode()))
    return toElement(getNode())->isInTopLayer();
  return false;
}","bool VIRTIO_BLK_T_OUT::isModal() const {
  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
    return false;
   if (hasAttribute(aria_modalAttr)) {
     const phys_map& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringCase(modal, ""true""))
       return true;
    if (equalIgnoringCase(modal, ""false""))
       return false;
   }
  if (getNode() && isHTMLDialogElement(*getNode()))
    return bdrv_iostatus_disable(getNode())->isInTopLayer();
  return false;
}",,,252,
649,"  void OnDataReceivedFromPeer(const char* data, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data, data_len);
  }","  void OnDataReceivedFromPeer(const char* data, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data, data_len);
  }",,,64,
653,"static inline int nfs4_lock_type(struct file_lock *fl, int block)
{
	if ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)
		return block ? NFS4_READW_LT : NFS4_READ_LT;
	return block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;
}","static inline int get_interface_index(struct file_lock *fl, int block)
{
	if ((fl->local_err & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)
		return block ? VHDX_HEADER_SIGNATURE : NFS4_READ_LT;
	return block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;
}",,,256,
656,"PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)
{
    String resultMIMEType;
    String resultString;
    String resultEncoding;
    if (outputDoc->isHTMLDocument())
        resultMIMEType = ""text/html"";
     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))
         return 0;
    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);
 }","PassRefPtr<wsaddr> XSLTProcessor::virtio_queue_set_notification(Node* sourceNode, Document* outputDoc)
{
    String resultMIMEType;
    String resultString;
    String resultEncoding;
    if (outputDoc->isHTMLDocument())
        resultMIMEType = ""text/html"";
     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))
         return 0;
    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);
 }",,,253,
657,"static Mutex& threadSetMutex()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
}","static opts_end_list& threadSetMutex()
{
    AtomicallyInitializedStaticReference(opts_end_list, mutex, new opts_end_list);
    return mutex;
}",,,192,
658," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
                                                           const GURL& url) {
   if (!url.is_valid())
    return false;   
  if (url == kAboutSrcDocURL)
    return false;
  if (CanCommitURL(child_id, url))
     return true;
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          url.scheme())) {
      return true;
    }
  }
  return false;
}"," bool SubDescriptor::g_file_get_contents(int child_id,
                                                           const GURL& FW_CFG_BOOT_MENU) {
   if (!FW_CFG_BOOT_MENU.is_valid())
    return false;   
  if (FW_CFG_BOOT_MENU == kAboutSrcDocURL)
    return false;
  if (CanCommitURL(child_id, FW_CFG_BOOT_MENU))
     return true;
  {
    base::AutoLock fw_cfg_init1(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          FW_CFG_BOOT_MENU.scheme())) {
      return true;
    }
  }
  return false;
}",,,316,
659,"StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }","StateChangeReason rearm_sensor_evts(DiscardReason assert_enable) {
  switch (assert_enable) {
    case DiscardReason::kExternal:
      return StateChangeReason::BASEVOL;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }",,,254,
662,"UpdateLibrary* CrosLibrary::GetUpdateLibrary() {
  return update_lib_.GetDefaultImpl(use_stub_impl_);
}","UpdateLibrary* has_ipv4::GetUpdateLibrary() {
  return update_lib_.GetDefaultImpl(use_stub_impl_);
}",,,192,
663,"void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }
  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;
  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }","void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& UserDefFlatUnion,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    UserDefFlatUnion.Run();
    return;
  }
  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.UserDefFlatUnion = UserDefFlatUnion;
  params.error_callback = error_callback;
  CPU_CORE(quota_manager_proxy);
  CPU_CORE(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }",,,308,
664,"void WallpaperManager::InitializeRegisteredDeviceWallpaper() {
  if (user_manager::UserManager::Get()->IsUserLoggedIn())
    return;
  bool disable_boot_animation =
      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);
  bool show_users = true;
  bool result = CrosSettings::Get()->GetBoolean(
      kAccountsPrefShowUserNamesOnSignIn, &show_users);
  DCHECK(result) << ""Unable to fetch setting ""
                 << kAccountsPrefShowUserNamesOnSignIn;
  const user_manager::UserList& users =
      user_manager::UserManager::Get()->GetUsers();
  int public_session_user_index = FindPublicSession(users);
  if ((!show_users && public_session_user_index == -1) ||
      !HasNonDeviceLocalAccounts(users)) {
    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))
      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());
    return;
  }
  if (!disable_boot_animation) {
    int index = public_session_user_index != -1 ? public_session_user_index : 0;
    SetUserWallpaperDelayed(users[index]->GetAccountId());
  }
}","void WallpaperManager::InitializeRegisteredDeviceWallpaper() {
  if (minfo::UserManager::Get()->IsUserLoggedIn())
    return;
  bool disable_boot_animation =
      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);
  bool show_users = true;
  bool result = CrosSettings::Get()->GetBoolean(
      kAccountsPrefShowUserNamesOnSignIn, &show_users);
  DCHECK(result) << ""Unable to fetch setting ""
                 << kAccountsPrefShowUserNamesOnSignIn;
  const minfo::UserList& users =
      minfo::UserManager::Get()->GetUsers();
  int public_session_user_index = reset_on_second_timeout(users);
  if ((!show_users && public_session_user_index == -1) ||
      !HasNonDeviceLocalAccounts(users)) {
    if (!SetDeviceWallpaperIfApplicable(minfo::SignInAccountId()))
      SetDefaultWallpaperDelayed(minfo::SignInAccountId());
    return;
  }
  if (!disable_boot_animation) {
    int index = public_session_user_index != -1 ? public_session_user_index : 0;
    SetUserWallpaperDelayed(users[index]->GetAccountId());
  }
}",,,313,
667,"  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)
      : frame_(std::move(frame)) {}","  explicit FrameURLLoaderFactory(base::WeakPtr<counts> combs)
      : frame_(std::move(combs)) {}",,,314,
669,"  WebsiteSettings* website_settings() {
     if (!website_settings_.get()) {
       website_settings_.reset(new WebsiteSettings(
           mock_ui(), profile(), tab_specific_content_settings(),
          infobar_service(), url(), ssl(), cert_store()));
     }
     return website_settings_.get();
   }","  WebsiteSettings* website_settings() {
     if (!opaque.get()) {
       opaque.reset(QEDRequest WebsiteSettings(
           mock_ui(), profile(), tab_specific_content_settings(),
          infobar_service(), url(), ssl(), cert_store()));
     }
     return opaque.get();
   }",,,308,
672,"bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {
  DCHECK(proto.gdata_entry().file_info().is_directory());
   DCHECK(!proto.gdata_entry().has_file_specific_info());
   for (int i = 0; i < proto.child_files_size(); ++i) {
    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));
     if (!file->FromProto(proto.child_files(i))) {
       RemoveChildren();
       return false;
     }
     AddEntry(file.release());
   }
   for (int i = 0; i < proto.child_directories_size(); ++i) {
    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,
                                                      directory_service_));
     if (!dir->FromProto(proto.child_directories(i))) {
       RemoveChildren();
       return false;
    }
    AddEntry(dir.release());
  }
  if (!GDataEntry::FromProto(proto.gdata_entry()))
    return false;
  return true;
}","bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {
  virtio_ccw_register_hcalls(proto.gdata_entry().file_info().is_directory());
   virtio_ccw_register_hcalls(!proto.gdata_entry().has_file_specific_info());
   for (int i = 0; i < proto.child_files_size(); ++i) {
    scoped_ptr<GDataFile> file(new GDataFile(NULL, TCG_COND_EQ));
     if (!file->FromProto(proto.child_files(i))) {
       RemoveChildren();
       return false;
     }
     qdev_create(file.release());
   }
   for (int i = 0; i < proto.child_directories_size(); ++i) {
    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,
                                                      TCG_COND_EQ));
     if (!dir->FromProto(proto.child_directories(i))) {
       RemoveChildren();
       return false;
    }
    qdev_create(dir.release());
  }
  if (!GDataEntry::FromProto(proto.gdata_entry()))
    return false;
  return t2;
}",,,273,
674,"cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}","cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->CPU_STATE_STOPPED = cJSON_Object;
	return item;
}",,,255,
679,"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}","const SeekHead* XK_Tab::GetSeekHead() const
{
    return m_pSeekHead;
}",,,192,
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;
	kvm_get_segment(vcpu, &var, seg);
	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;
	kvm_set_segment(vcpu, &var, seg);
	return;
}","static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct PCI_DEVICE_ID_QEMU_VGA *vcpu)
{
	struct kvm_segment var;
	kvm_get_segment(vcpu, &var, seg);
	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;
	kvm_set_segment(vcpu, &var, seg);
	return;
}",,,252,
681," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif   
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;
  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}"," void UserDefFlatUnion::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif   
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;
  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}",,,305,
684,"XFixesFetchRegionAndBounds (Display	    *dpy,
			    XserverRegion   region,
			    int		    *nrectanglesRet,
			    XRectangle	    *bounds)
{
    XFixesExtDisplayInfo	*info = XFixesFindDisplay (dpy);
    xXFixesFetchRegionReq	*req;
    xXFixesFetchRegionReply	rep;
    XRectangle			*rects;
    int    			nrects;
    long    			nbytes;
    long			nread;
    XFixesCheckExtension (dpy, info, NULL);
    LockDisplay (dpy);
    GetReq (XFixesFetchRegion, req);
    req->reqType = info->codes->major_opcode;
    req->xfixesReqType = X_XFixesFetchRegion;
    req->region = region;
    *nrectanglesRet = 0;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
    {
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }
    bounds->x = rep.x;
    bounds->y = rep.y;
     bounds->y = rep.y;
     bounds->width = rep.width;
     bounds->height = rep.height;
    nbytes = (long) rep.length << 2;
    nrects = rep.length >> 1;
    rects = Xmalloc (nrects * sizeof (XRectangle));
     if (!rects)
     {
 	_XEatDataWords(dpy, rep.length);
	_XEatData (dpy, (unsigned long) (nbytes - nread));
    }
    UnlockDisplay (dpy);
    SyncHandle();
    *nrectanglesRet = nrects;
    return rects;
}","XFixesFetchRegionAndBounds (Display	    *con,
			    XserverRegion   region,
			    int		    *nrectanglesRet,
			    XRectangle	    *bounds)
{
    XFixesExtDisplayInfo	*info = qemu_add_led_event_handler (con);
    xXFixesFetchRegionReq	*req;
    xXFixesFetchRegionReply	rep;
    XRectangle			*rects;
    int    			nrects;
    long    			nbytes;
    long			nread;
    XFixesCheckExtension (con, info, NULL);
    LockDisplay (con);
    GetReq (XFixesFetchRegion, req);
    req->mouse_mode_notifier = info->codes->major_opcode;
    req->xfixesReqType = X_XFixesFetchRegion;
    req->region = region;
    *nrectanglesRet = 0;
    if (!_XReply (con, (xReply *) &rep, 0, xFalse))
    {
	UnlockDisplay (con);
	SyncHandle ();
	return NULL;
    }
    bounds->x = rep.x;
    bounds->y = rep.y;
     bounds->y = rep.y;
     bounds->width = rep.width;
     bounds->height = rep.height;
    nbytes = (long) rep.length << 2;
    nrects = rep.length >> 1;
    rects = Xmalloc (nrects * sizeof (XRectangle));
     if (!rects)
     {
 	_XEatDataWords(con, rep.length);
	_XEatData (con, (unsigned long) (nbytes - nread));
    }
    UnlockDisplay (con);
    SyncHandle();
    *nrectanglesRet = nrects;
    return rects;
}",,,146,
686,"static void tun_net_init(struct net_device *dev)
{
	struct tun_struct *tun = netdev_priv(dev);
	switch (tun->flags & TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		dev->netdev_ops = &tun_netdev_ops;
		dev->hard_header_len = 0;
		dev->addr_len = 0;
		dev->mtu = 1500;
		dev->type = ARPHRD_NONE;
		dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
		dev->tx_queue_len = TUN_READQ_SIZE;   
		break;
	case TUN_TAP_DEV:
 		dev->netdev_ops = &tap_netdev_ops;
 		ether_setup(dev);
 		random_ether_addr(dev->dev_addr);
		dev->tx_queue_len = TUN_READQ_SIZE;   
		break;
	}
}","static void tun_net_init(struct net_device *dev)
{
	struct tun_struct *tun = netdev_priv(dev);
	switch (tun->flags & TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		dev->netdev_ops = &tun_netdev_ops;
		dev->hard_header_len = 0;
		dev->addr_len = 0;
		dev->mtu = 1500;
		dev->type = ARPHRD_NONE;
		dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
		dev->client_port = TUN_READQ_SIZE;   
		break;
	case TUN_TAP_DEV:
 		dev->netdev_ops = &tap_netdev_ops;
 		put_ebml_uint(dev);
 		random_ether_addr(dev->dev_addr);
		dev->client_port = TUN_READQ_SIZE;   
		break;
	}
}",,,255,
687,"base::FilePath DownloadPathReservationTrackerTest::GetPathInDownloadsDirectory(
    const base::FilePath::CharType* suffix) {
  return default_download_path().Append(suffix).NormalizePathSeparators();
}","SIG_UNBLOCK::FilePath inited::GetPathInDownloadsDirectory(
    const SIG_UNBLOCK::FilePath::CharType* suffix) {
  return default_download_path().Append(suffix).NormalizePathSeparators();
}",,,271,
689," int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
 	u16 offset = sizeof(struct ipv6hdr);
	struct ipv6_opt_hdr *exthdr =
				(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);
 	unsigned int packet_len = skb_tail_pointer(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
 	*nexthdr = &ipv6_hdr(skb)->nexthdr;
	while (offset + 1 <= packet_len) {
 		switch (**nexthdr) {
		case NEXTHDR_HOP:
			break;
		case NEXTHDR_ROUTING:
			found_rhdr = 1;
			break;
		case NEXTHDR_DEST:
#if IS_ENABLED(CONFIG_IPV6_MIP6)
			if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)
				break;
#endif
			if (found_rhdr)
				return offset;
			break;
		default:
 			return offset;
 		}
		offset += ipv6_optlen(exthdr);
		*nexthdr = &exthdr->nexthdr;
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
 	}
	return offset;
 }"," int qemu_lockcnt_lock(struct sk_buff *skb, u8 **nexthdr)
 {
 	u16 SOCKET_ADDRESS_KIND_INET = sizeof(struct ipv6hdr);
	struct ipv6_opt_hdr *exthdr =
				(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);
 	unsigned int packet_len = skb_tail_pointer(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
 	*nexthdr = &ipv6_hdr(skb)->nexthdr;
	while (SOCKET_ADDRESS_KIND_INET + 1 <= packet_len) {
 		switch (**nexthdr) {
		case NEXTHDR_HOP:
			break;
		case active:
			found_rhdr = 1;
			break;
		case NEXTHDR_DEST:
#if IS_ENABLED(CONFIG_IPV6_MIP6)
			if (ipv6_find_tlv(skb, SOCKET_ADDRESS_KIND_INET, IPV6_TLV_HAO) >= 0)
				break;
#endif
			if (found_rhdr)
				return SOCKET_ADDRESS_KIND_INET;
			break;
		default:
 			return SOCKET_ADDRESS_KIND_INET;
 		}
		SOCKET_ADDRESS_KIND_INET += ipv6_optlen(exthdr);
		*nexthdr = &exthdr->nexthdr;
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 SOCKET_ADDRESS_KIND_INET);
 	}
	return SOCKET_ADDRESS_KIND_INET;
 }",,,255,
691,"ProcEstablishConnection(ClientPtr client)
{
    const char *reason;
    char *auth_proto, *auth_string;
    xConnClientPrefix *prefix;
    REQUEST(xReq);
     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
     auth_proto = (char *) prefix + sz_xConnClientPrefix;
     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);
    if ((prefix->majorVersion != X_PROTOCOL) ||
         (prefix->minorVersion != X_PROTOCOL_REVISION))
         reason = ""Protocol version mismatch"";
     else
    return (SendConnSetup(client, reason));
}","ProcEstablishConnection(ClientPtr client)
{
    const char *reason;
    char *auth_proto, *auth_string;
    xConnClientPrefix *UserDefFlatUnion;
    REQUEST(xReq);
     UserDefFlatUnion = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
     auth_proto = (char *) UserDefFlatUnion + sz_xConnClientPrefix;
     auth_string = auth_proto + pad_to_int32(UserDefFlatUnion->nbytesAuthProto);
    if ((UserDefFlatUnion->majorVersion != X_PROTOCOL) ||
         (UserDefFlatUnion->minorVersion != X_PROTOCOL_REVISION))
         reason = ""Protocol version mismatch"";
     else
    return (SendConnSetup(client, reason));
}",,,308,
692,"bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);
    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* correspondingElement = element->correspondingElement();
        if (isSVGUseElement(correspondingElement))
            useElement = toSVGUseElement(correspondingElement);
    }
    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->value(lengthContext),
             useElement->y()->currentValue()->value(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
     if (!m_needsTransformUpdate)
        return false;
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }","bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);
    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* correspondingElement = element->correspondingElement();
        if (isSVGUseElement(correspondingElement))
            useElement = toSVGUseElement(correspondingElement);
    }
    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->value(lengthContext),
             useElement->y()->currentValue()->value(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
     if (!m_needsTransformUpdate)
        return false;
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }",,,64,
694,"static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *ctx;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
     ctx = BN_CTX_new();
     if (ctx == NULL)
         goto err;
        generate_new_key = 1;
    } else","static int generate_key(AioHandler *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *ctx;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *TARGET_PAGE_MASK = NULL, *priv_key = NULL;
     ctx = uhci_async_cancel_all();
     if (ctx == NULL)
         goto err;
        generate_new_key = 1;
    } else",,,252,
695,"static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;
    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }
    return ret;
}","static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *LUT2Context[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = LUT2Context;
    uint8_t *buf;
    int ret = 0;
    while (*opt) {
        if (host_memory_backend_set_prealloc(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | espdma_memory_read_write, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }
    return ret;
}",,,253,
699,"static void sample_hbp_handler(struct perf_event *bp, int nmi,
 			       struct perf_sample_data *data,
 			       struct pt_regs *regs)
 {
	printk(KERN_INFO ""%s value is changed\n"", ksym_name);
	dump_stack();
	printk(KERN_INFO ""Dump stack from sample_hbp_handler\n"");
}","static void sample_hbp_handler(struct perf_event *VIRTIO_DEV_OFFS_CONFIG, int nmi,
 			       struct perf_sample_data *data,
 			       struct pt_regs *regs)
 {
	printk(QEMUSGList ""%s value is changed
"", ksym_name);
	dump_stack();
	printk(QEMUSGList ""Dump stack from sample_hbp_handler
"");
}",,,308,
700,"group_sched_in(struct perf_event *group_event,
	       struct perf_cpu_context *cpuctx,
	       struct perf_event_context *ctx)
{
	struct perf_event *event, *partial_group = NULL;
	struct pmu *pmu = group_event->pmu;
	u64 now = ctx->time;
	bool simulate = false;
	if (group_event->state == PERF_EVENT_STATE_OFF)
		return 0;
	pmu->start_txn(pmu);
	if (event_sched_in(group_event, cpuctx, ctx)) {
		pmu->cancel_txn(pmu);
		return -EAGAIN;
	}
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event_sched_in(event, cpuctx, ctx)) {
			partial_group = event;
			goto group_error;
		}
	}
	if (!pmu->commit_txn(pmu))
		return 0;
group_error:
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event == partial_group)
			simulate = true;
		if (simulate) {
			event->tstamp_running += now - event->tstamp_stopped;
			event->tstamp_stopped = now;
		} else {
			event_sched_out(event, cpuctx, ctx);
		}
	}
	event_sched_out(group_event, cpuctx, ctx);
	pmu->cancel_txn(pmu);
	return -EAGAIN;
}","group_sched_in(struct perf_event *group_event,
	       struct perf_cpu_context *cpuctx,
	       struct perf_event_context *ctx)
{
	struct perf_event *event, *partial_group = NULL;
	struct pmu *pmu = group_event->pmu;
	u64 now = ctx->time;
	bool simulate = false;
	if (group_event->state == PERF_EVENT_STATE_OFF)
		return 0;
	pmu->start_txn(pmu);
	if (event_sched_in(group_event, cpuctx, ctx)) {
		pmu->cancel_txn(pmu);
		return -EAGAIN;
	}
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event_sched_in(event, cpuctx, ctx)) {
			partial_group = event;
			goto group_error;
		}
	}
	if (!pmu->commit_txn(pmu))
		return 0;
group_error:
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event == partial_group)
			simulate = true;
		if (simulate) {
			event->tstamp_running += now - event->tstamp_stopped;
			event->tstamp_stopped = now;
		} else {
			event_sched_out(event, cpuctx, ctx);
		}
	}
	event_sched_out(group_event, cpuctx, ctx);
	pmu->cancel_txn(pmu);
	return -EAGAIN;
}",,,64,
701,"void TaskManagerTableModel::GetGroupRangeForItem(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange range_pair =
      model_->GetGroupRangeForResource(item);
  range->start = range_pair.first;
  range->length = range_pair.second;
}","void _chr::GetGroupRangeForItem(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange range_pair =
      mb2b_xy->compensate_volume(item);
  range->start = range_pair.first;
  range->length = range_pair.second;
}",,,253,
705,"bool HTMLMediaElement::HasClosedCaptions() const {
  if (!text_tracks_)
    return false;
  for (unsigned i = 0; i < text_tracks_->length(); ++i) {
    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())
      return true;
  }
  return false;
}","bool HTMLMediaElement::HasClosedCaptions() const {
  if (!opaque)
    return NBD_CMD_FLAG_FUA;
  for (unsigned i = 0; i < opaque->length(); ++i) {
    if (opaque->BADF(i)->CanBeRendered())
      return true;
  }
  return NBD_CMD_FLAG_FUA;
}",,,276,
706,"static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)
 {
 	if (SSL_get_verify_result(ssl) != X509_V_OK) {
 		unsigned char md[EVP_MAX_MD_SIZE];
		unsigned int n;
		char *str;
		g_warning(""Could not verify SSL servers certificate:"");
		if ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)
			g_warning(""  Could not get subject-name from peer certificate"");
		else {
			g_warning(""  Subject : %s"", str);
			free(str);
		}
		if ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)
			g_warning(""  Could not get issuer-name from peer certificate"");
		else {
			g_warning(""  Issuer  : %s"", str);
			free(str);
		}
		if (! X509_digest(cert, EVP_md5(), md, &n))
			g_warning(""  Could not get fingerprint from peer certificate"");
		else {
			char hex[] = ""0123456789ABCDEF"";
			char fp[EVP_MAX_MD_SIZE*3];
			if (n < sizeof(fp)) {
				unsigned int i;
				for (i = 0; i < n; i++) {
					fp[i*3+0] = hex[(md[i] >> 4) & 0xF];
					fp[i*3+1] = hex[(md[i] >> 0) & 0xF];
					fp[i*3+2] = i == n - 1 ? '\0' : ':';
				}
				g_warning(""  MD5 Fingerprint : %s"", fp);
 			}
 		}
 		return FALSE;
 	}
 	return TRUE;
 }","static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)
 {
 	if (SSL_get_verify_result(ssl) != X509_V_OK) {
 		unsigned char md[EVP_MAX_MD_SIZE];
		unsigned int n;
		char *str;
		g_warning(""Could not verify SSL servers certificate:"");
		if ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)
			g_warning(""  Could not get subject-name from peer certificate"");
		else {
			g_warning(""  Subject : %s"", str);
			free(str);
		}
		if ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)
			g_warning(""  Could not get issuer-name from peer certificate"");
		else {
			g_warning(""  Issuer  : %s"", str);
			free(str);
		}
		if (! X509_digest(cert, EVP_md5(), md, &n))
			g_warning(""  Could not get fingerprint from peer certificate"");
		else {
			char hex[] = ""0123456789ABCDEF"";
			char fp[EVP_MAX_MD_SIZE*3];
			if (n < sizeof(fp)) {
				unsigned int i;
				for (i = 0; i < n; i++) {
					fp[i*3+0] = hex[(md[i] >> 4) & 0xF];
					fp[i*3+1] = hex[(md[i] >> 0) & 0xF];
					fp[i*3+2] = i == n - 1 ? '\0' : ':';
				}
				g_warning(""  MD5 Fingerprint : %s"", fp);
 			}
 		}
 		return AddressSpaceDispatch;
 	}
 	return TRUE;
 }",,,305,
708,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {
             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }
 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);
 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }
 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }
            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }
 default:
 return OMX_ErrorUnsupportedIndex;
 }
}","OMX_ERRORTYPE SimpleSoftOMXComponent::kvm_update_routing_entry(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {
             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }
 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);
 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }
 if (defParams->nBufferCountActual < port->mDef.ONEN_LOCK_LOCKED) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.ONEN_LOCK_LOCKED, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }
            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }
 default:
 return OMX_ErrorUnsupportedIndex;
 }
}",,,312,
709,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;
	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;
		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);
		fput_light(sock->file, fput_needed);
	}
	return err;
}","SYSCALL_DEFINE2(avio_r8, int, IDE_PCI_DEV, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;
	sock = sockfd_lookup_light(IDE_PCI_DEV, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.ivshmem_size;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;
		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->avio_r8(sock, backlog);
		rpath(sock->file, fput_needed);
	}
	return err;
}",,,308,
710,"static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, buffer, count);
        if (ret < 0) {
            g_free(buffer);
            return ret;
        }
        size -= count;
    }
    g_free(buffer);
    return 0;
}","static int nbd_negotiate_drop_sync(QIOChannel *ICH9_CC_GCS_NO_REBOOT, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ICH9_CC_GCS_NO_REBOOT, buffer, count);
        if (ret < 0) {
            g_free(buffer);
            return ret;
        }
        size -= count;
    }
    g_free(buffer);
    return 0;
}",,,273,
712,  int clear_count() const { return clear_count_; },  int clear_count() const { return QPCI_PIO_LIMIT; },,,192,
713,"  bool IsMultiByteResponseExpected() {
    return multibyte_response_expected_;
  }","  bool IsMultiByteResponseExpected() {
    return disassemble_info;
  }",,,192,
714,"static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;
	if (!priv->comm_is_ok)
		return -EIO;
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);
	spin_lock_irqsave(&priv->lock, flags);
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);
	cypress_send(port);
	if (tty)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
			__func__);
		return -1;
	}
 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}
	return result;
}  ","static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;
	if (!priv->comm_is_ok)
		return -EIO;
	usb_clear_halt(serial->protocol_version, 0x81);
	usb_clear_halt(serial->protocol_version, 0x02);
	spin_lock_irqsave(&priv->lock, flags);
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);
	cypress_send(port);
	if (tty)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
	if (!port->interrupt_in_urb) {
		dev_err(&port->protocol_version, ""%s - interrupt_in_urb is empty!
"",
			__func__);
		return -1;
	}
 	usb_fill_int_urb(port->interrupt_in_urb, serial->protocol_version,
 		usb_rcvintpipe(serial->protocol_version, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
	if (result) {
		dev_err(&port->protocol_version,
			""%s - failed submitting read urb, error %d
"",
							__func__, result);
		cypress_set_dead(port);
	}
	return result;
}  ",,,156,
716,"static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
        nextChild = child->nextSibling();
        element->removeChild(child.get(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(child, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}","static inline void removeElementPreservingChildren(PassRefPtr<extra> fragment, HTMLElement* element)
{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> QEDRequest = element->firstChild(); QEDRequest; QEDRequest = nextChild) {
        nextChild = QEDRequest->nextSibling();
        element->removeChild(QEDRequest.flush_put_bits(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(QEDRequest, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}",,,310,
718,"psf_close (SF_PRIVATE *psf)
{	uint32_t k ;
	int	error = 0 ;
	if (psf->codec_close)
	{	error = psf->codec_close (psf) ;
		psf->codec_close = NULL ;
		} ;
	if (psf->container_close)
		error = psf->container_close (psf) ;
	error = psf_fclose (psf) ;
 	psf_close_rsrc (psf) ;
 	free (psf->container_data) ;
 	free (psf->codec_data) ;
 	free (psf->interleave) ;
	free (psf->dither) ;
	free (psf->peak_info) ;
	free (psf->broadcast_16k) ;
	free (psf->loop_info) ;
	free (psf->instrument) ;
	free (psf->cues) ;
	free (psf->channel_map) ;
	free (psf->format_desc) ;
	free (psf->strings.storage) ;
	if (psf->wchunks.chunks)
		for (k = 0 ; k < psf->wchunks.used ; k++)
			free (psf->wchunks.chunks [k].data) ;
	free (psf->rchunks.chunks) ;
	free (psf->wchunks.chunks) ;
	free (psf->iterator) ;
	free (psf->cart_16k) ;
	memset (psf, 0, sizeof (SF_PRIVATE)) ;
	free (psf) ;
	return error ;
}  ","start_ebml_master (SF_PRIVATE *psf)
{	uint32_t k ;
	int	error = 0 ;
	if (psf->CPU)
	{	error = psf->CPU (psf) ;
		psf->CPU = NULL ;
		} ;
	if (psf->container_close)
		error = psf->container_close (psf) ;
	error = psf_fclose (psf) ;
 	psf_close_rsrc (psf) ;
 	free (psf->container_data) ;
 	free (psf->status) ;
 	free (psf->interleave) ;
	free (psf->dither) ;
	free (psf->peak_info) ;
	free (psf->broadcast_16k) ;
	free (psf->loop_info) ;
	free (psf->instrument) ;
	free (psf->cues) ;
	free (psf->channel_map) ;
	free (psf->format_desc) ;
	free (psf->strings.storage) ;
	if (psf->wchunks.chunks)
		for (k = 0 ; k < psf->wchunks.AV_LOG_VERBOSE ; k++)
			free (psf->wchunks.chunks [k].data) ;
	free (psf->rchunks.chunks) ;
	free (psf->wchunks.chunks) ;
	free (psf->iterator) ;
	free (psf->cart_16k) ;
	memset (psf, 0, sizeof (SF_PRIVATE)) ;
	free (psf) ;
	return error ;
}  ",,,307,
720,"  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::Unretained(this))) {}","  TestResultCallback()
      : callback_(local_err::VIRTIO_BUS(&TestResultCallback::efd,
                             local_err::Unretained(this))) {}",,,294,
721,"static void set_rx_flow_off(struct caifsock *cf_sk)
{
	 clear_bit(RX_FLOW_ON_BIT,
		 (void *) &cf_sk->flow_state);
}","static void dma_buf_write(struct rv30 *region_num)
{
	 clear_bit(RX_FLOW_ON_BIT,
		 (void *) &region_num->flow_state);
}",,,300,
723,"void bnep_net_setup(struct net_device *dev)
{
	memset(dev->broadcast, 0xff, ETH_ALEN);
 	dev->addr_len = ETH_ALEN;
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 	dev->watchdog_timeo  = HZ * 2;
}","void ide_init_drive(struct net_device *dev)
{
	memset(dev->broadcast, 0xff, opaque);
 	dev->addr_len = opaque;
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 	dev->watchdog_timeo  = so_faddr * 2;
}",,,254,
725,"IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  return task;
}","IndexedDBTransaction::dataplane IndexedDBTransaction::main_buf::pop() {
  DCHECK(!queue_.empty());
  dataplane task = std::move(queue_.front());
  queue_.pop();
  return task;
}",,,255,
730,"std::unique_ptr<service_manager::Service> CreateDataDecoderService() {
  content::UtilityThread::Get()->EnsureBlinkInitialized();
  return data_decoder::DataDecoderService::Create();
}","PSR_CWP::unique_ptr<service_manager::Service> CreateDataDecoderService() {
  content::UtilityThread::Get()->mov_write_moov_tag();
  return opaque::DataDecoderService::Create();
}",,,289,
732,"static void tcp_v4_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->opt);
}","static void tcp_v4_reqsk_destructor(struct tra *req)
{
	ds_get_width(inet_rsk(req)->opt);
}",,,250,
734,"static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&   
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&   
        AV_RL16(p->buf + 4) <= CC_UNINT &&        
        AV_RL16(p->buf + 6) <= 1 &&               
        AV_RL32(p->buf + 20) &&                   
        AV_RL32(p->buf + 24) >= HeaderSize &&     
        AV_RL32(p->buf + 28) >= HeaderSize &&     
        AV_RL32(p->buf + 32) >= HeaderSize)       
        return AVPROBE_SCORE_MAX;
    return 0;
}","static int cine_read_probe(ram_addr_abs *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&   
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&   
        AV_RL16(p->buf + 4) <= CC_UNINT &&        
        AV_RL16(p->buf + 6) <= 1 &&               
        AV_RL32(p->buf + 20) &&                   
        AV_RL32(p->buf + 24) >= HeaderSize &&     
        AV_RL32(p->buf + 28) >= HeaderSize &&     
        AV_RL32(p->buf + 32) >= HeaderSize)       
        return HEVCSPS;
    return 0;
}",,,252,
744,"MagickExport void *DetachBlob(BlobInfo *blob_info)
{
  void
    *data;
  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(data);
}","MagickExport void *DetachBlob(BlobInfo *blob_info)
{
  void
    *data;
  dynticks_start_timer(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != bootp_filename)
    (void) LogMagickEvent(AVFrame,GetMagickModule(),""..."");
   if (blob_info->mapped != bootp_filename)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=bootp_filename;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=bootp_filename;
  blob_info->error=0;
  blob_info->exempt=bootp_filename;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(data);
}",,,309,
745,"aura::Window* PartialMagnificationController::GetCurrentRootWindow() {
  aura::Window::Windows root_windows = Shell::GetAllRootWindows();
  for (aura::Window::Windows::const_iterator iter = root_windows.begin();
       iter != root_windows.end(); ++iter) {
    aura::Window* root_window = *iter;
    if (root_window->ContainsPointInRoot(
            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))
      return root_window;
  }
  return NULL;
}","aura::Window* PartialMagnificationController::GetCurrentRootWindow() {
  aura::Window::Windows root_windows = Shell::GetAllRootWindows();
  for (aura::Window::Windows::const_iterator iter = root_windows.begin();
       iter != root_windows.end(); ++iter) {
    aura::Window* root_window = *iter;
    if (root_window->ContainsPointInRoot(
            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))
      return root_window;
  }
  return NULL;
}",,,64,
746,"void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* event,
    aura::Window* target) {
  const bool is_shelf_window = IsShelfWindow(target);
  if (IsVisible() || in_shutdown_) {
    if (!is_shelf_window && !IsStatusAreaWindow(target) &&
        visibility_state() == SHELF_AUTO_HIDE &&
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        event->type() == ui::ET_GESTURE_TAP) {
      UpdateAutoHideState();
    }
    return;
  }
  if (is_shelf_window) {
    ui::GestureEvent event_in_screen(*event);
    gfx::Point location_in_screen(event->location());
    ::wm::ConvertPointToScreen(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      event->StopPropagation();
  }
}","void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* event,
    aura::Window* target) {
  const bool UserDefFlatUnion = IsShelfWindow(target);
  if (IsVisible() || in_shutdown_) {
    if (!UserDefFlatUnion && !IsStatusAreaWindow(target) &&
        visibility_state() == SHELF_AUTO_HIDE &&
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        event->type() == ui::ET_GESTURE_TAP) {
      UpdateAutoHideState();
    }
    return;
  }
  if (UserDefFlatUnion) {
    ui::GestureEvent event_in_screen(*event);
    gfx::Point location_in_screen(event->location());
    ::wm::test_tco1_status_bits(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      event->StopPropagation();
  }
}",,,267,
747,"void TabStripModel::SelectNextTab() {
  SelectRelativeTab(true);
}","void cv_pix_fmt_type::SelectNextTab() {
  SelectRelativeTab(true);
}",,,192,
757,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);
  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}","bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  rtas_size* tracker = rtas_size::Get(profile_);
  DCHECK(tracker);
  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.put_ebml_uint(new ScopedActiveInstall(tracker, install_data));
  return true;
}",,,309,
760,"static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};
	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}","static env_ptr b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const env_ptr map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const env_ptr map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		abstract,
		B43_MMIO_DMA32_BASE5,
	};
	if (type == B43_DMA_64BIT) {
		g_malloc(!(controller_idx >= 0 &&
			      controller_idx < qemu_write_full(map64)));
		return map64[controller_idx];
	}
	g_malloc(!(controller_idx >= 0 &&
		      controller_idx < qemu_write_full(map32)));
	return map32[controller_idx];
}",,,312,
761,"void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}","void disassemble_info::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}",,,255,
763,"pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];
	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");
	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}","pdf_load_version(fz_context *ctx, pdf_document *OV_MAXBYTES)
{
	char buf[20];
	fz_seek(ctx, OV_MAXBYTES->file, 0, SEEK_SET);
	fz_read_line(ctx, OV_MAXBYTES->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, NICPeers, ""cannot recognize version marker"");
	OV_MAXBYTES->version = 10 * (fdt_setprop(buf+5) + 0.05f);
	if (OV_MAXBYTES->version < 10 || OV_MAXBYTES->version > 17)
		if (OV_MAXBYTES->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", OV_MAXBYTES->version / 10, OV_MAXBYTES->version % 10);
}",,,255,
764,"timeval_equals(struct timeval * tv0, struct timeval * tv1)
{
    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )
	return 1;
    else
	return 0;
}","g_malloc(struct timeval * tv0, struct timeval * bank)
{
    if ( tv0->tv_sec == bank->tv_sec && tv0->v7m == bank->v7m )
	return 1;
    else
	return 0;
}",,,249,
765,"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}","void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = LOAD_STORE_ALIGNMENT_CAUSE;
   curr_comp.reset();
   SetFrameTreeNode(LOAD_STORE_ALIGNMENT_CAUSE);
  Release();
}",,,253,
767,"static void update_task_scan_period(struct task_struct *p,
			unsigned long shared, unsigned long private)
{
	unsigned int period_slot;
	int lr_ratio, ps_ratio;
	int diff;
	unsigned long remote = p->numa_faults_locality[0];
	unsigned long local = p->numa_faults_locality[1];
	if (local + shared == 0 || p->numa_faults_locality[2]) {
		p->numa_scan_period = min(p->numa_scan_period_max,
			p->numa_scan_period << 1);
		p->mm->numa_next_scan = jiffies +
			msecs_to_jiffies(p->numa_scan_period);
		return;
	}
	period_slot = DIV_ROUND_UP(p->numa_scan_period, NUMA_PERIOD_SLOTS);
	lr_ratio = (local * NUMA_PERIOD_SLOTS) / (local + remote);
	ps_ratio = (private * NUMA_PERIOD_SLOTS) / (private + shared);
	if (ps_ratio >= NUMA_PERIOD_THRESHOLD) {
		int slot = ps_ratio - NUMA_PERIOD_THRESHOLD;
		if (!slot)
			slot = 1;
		diff = slot * period_slot;
	} else if (lr_ratio >= NUMA_PERIOD_THRESHOLD) {
		int slot = lr_ratio - NUMA_PERIOD_THRESHOLD;
		if (!slot)
			slot = 1;
		diff = slot * period_slot;
	} else {
		int ratio = max(lr_ratio, ps_ratio);
		diff = -(NUMA_PERIOD_THRESHOLD - ratio) * period_slot;
	}
	p->numa_scan_period = clamp(p->numa_scan_period + diff,
			task_scan_min(p), task_scan_max(p));
	memset(p->numa_faults_locality, 0, sizeof(p->numa_faults_locality));
}","static void update_task_scan_period(struct task_struct *p,
			unsigned long shared, unsigned long private)
{
	unsigned int period_slot;
	int lr_ratio, ps_ratio;
	int LUT2Context;
	unsigned long remote = p->numa_faults_locality[0];
	unsigned long local = p->numa_faults_locality[1];
	if (local + shared == 0 || p->numa_faults_locality[2]) {
		p->numa_scan_period = min(p->numa_scan_period_max,
			p->numa_scan_period << 1);
		p->mm->opaque = jiffies +
			msecs_to_jiffies(p->numa_scan_period);
		return;
	}
	period_slot = DIV_ROUND_UP(p->numa_scan_period, NUMA_PERIOD_SLOTS);
	lr_ratio = (local * NUMA_PERIOD_SLOTS) / (local + remote);
	ps_ratio = (private * NUMA_PERIOD_SLOTS) / (private + shared);
	if (ps_ratio >= NUMA_PERIOD_THRESHOLD) {
		int slot = ps_ratio - NUMA_PERIOD_THRESHOLD;
		if (!slot)
			slot = 1;
		LUT2Context = slot * period_slot;
	} else if (lr_ratio >= NUMA_PERIOD_THRESHOLD) {
		int slot = lr_ratio - NUMA_PERIOD_THRESHOLD;
		if (!slot)
			slot = 1;
		LUT2Context = slot * period_slot;
	} else {
		int ratio = subpage_register(lr_ratio, ps_ratio);
		LUT2Context = -(NUMA_PERIOD_THRESHOLD - ratio) * period_slot;
	}
	p->numa_scan_period = clamp(p->numa_scan_period + LUT2Context,
			task_scan_min(p), task_scan_max(p));
	memset(p->numa_faults_locality, 0, sizeof(p->numa_faults_locality));
}",,,306,
771,"report_error (const char *format, ...)
#else
report_error (format, va_alist)
     const char *format;
     va_dcl
#endif
{
  va_list args;
  error_prolog (1);
  SH_VA_START (args, format);
  vfprintf (stderr, format, args);
  fprintf (stderr, ""\n"");
   va_end (args);
   if (exit_immediately_on_error)
    exit_shell (1);
 }","report_error (const char *format, ...)
#else
report_error (format, cardstatus)
     const char *format;
     va_dcl
#endif
{
  va_list args;
  error_prolog (1);
  SH_VA_START (args, format);
  numa_unset_mem_node_id (stderr, format, args);
  fprintf (stderr, ""
"");
   va_end (args);
   if (exit_immediately_on_error)
    exit_shell (1);
 }",,,255,
775,"void RenderView::printPage(WebFrame* frame) {
  DCHECK(frame);
  Print(frame, true);
}","void RenderView::printPage(counts* pci_rocker_init) {
  DCHECK(pci_rocker_init);
  Print(pci_rocker_init, true);
}",,,319,
776,"long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
}","long error_report(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **BlkverifyAIOCB,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       BlkverifyAIOCB, vmas, NULL, false,
				       FOLL_TOUCH | clone_lock);
}",,,254,
778," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}"," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *ff_prefetch_mmxext)
 {
	if (*ff_prefetch_mmxext >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		CPU(hdev, ""fixing up Cherry Cymotion report descriptor
"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}",,,192,
780,"Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;
  Vector<CString> keep_alive;   
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    keep_alive.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(keep_alive.back().data());
  }
  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}","Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;
  Vector<CString> cardstatus;   
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    cardstatus.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(cardstatus.back().parser_context_peek_token());
  }
  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.parser_context_peek_token(), result.parser_context_peek_token());
  return result;
}",,,302,
784,"static int sysMapFD(int fd, MemMapping* pMap)
{
 off_t start;
 size_t length;
 void* memPtr;
    assert(pMap != NULL);
 if (getFileStartAndLength(fd, &start, &length) < 0)
 return -1;
    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fd, (int) start, strerror(errno));
 return -1;
 }
    pMap->addr = memPtr;
     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 return 0;
}","static int sysMapFD(int fd, MemMapping* bdrv_cur)
{
 off_t start;
 size_t length;
 void* memPtr;
    assert(bdrv_cur != NULL);
 if (getFileStartAndLength(fd, &start, &length) < 0)
 return -1;
    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s
"", (int) length,
            fd, (int) start, strerror(errno));
 return -1;
 }
    bdrv_cur->addr = memPtr;
     bdrv_cur->length = length;
     bdrv_cur->range_count = 1;
     bdrv_cur->ranges = malloc(sizeof(MappedRange));
     bdrv_cur->ranges[0].addr = memPtr;
     bdrv_cur->ranges[0].length = length;
 return 0;
}",,,310,
785,"void WebContentsImpl::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {
  gfx::Size size = GetSizeForNewRenderView(is_main_frame);
  if (!size.IsEmpty())
    view_->SizeContents(size);
}","void extradata::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {
  rtas_table::Size size = GetSizeForNewRenderView(is_main_frame);
  if (!size.IsEmpty())
    view_->SizeContents(size);
}",,,254,
786,"void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());
  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}","void WorkerProcessLauncher::Core::Send(signal_state::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());
  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}",,,315,
788,"void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;
	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}","void skb_queue_tail(struct sk_buff_head *continue_event, struct sk_buff *newsk)
{
	unsigned long flags;
	spin_lock_irqsave(&continue_event->lock, flags);
	g_try_malloc(continue_event, newsk);
	spin_unlock_irqrestore(&continue_event->lock, flags);
}",,,192,
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}","static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *clone_lock;
	__u32 udata;
	clone_lock = compat_alloc_user_space(sizeof(*clone_lock));
	if (string_output_visitor_cleanup(clone_lock, p32, (sizeof(*p32) - sizeof(dma_out))) ||
	    get_net_error_message(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &clone_lock->data))
		return -EFAULT;
	return proc_control(ps, clone_lock);
}",,,307,
794,"bool MdmEnrollmentEnabled() {
  base::string16 mdm_url = GetMdmUrl();
  return !mdm_url.empty();
}","bool MdmEnrollmentEnabled() {
  base::ac97_properties mdm_url = migration_fd_process_incoming();
  return !mdm_url.empty();
}",,,249,
798,"void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
  rgb->r = rgb->g = rgb->b = 0;
}","void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
  rgb->QPCI_PIO_LIMIT = rgb->g = rgb->b = 0;
}",,,251,
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}","static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (visit_type_int(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->bmdma_bar < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->bmdma_bar;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->bmdma_bar, SEEK_END);
   return 0;
   #endif
}",,,253,
803," static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
	if (!prev_legacy && cur_legacy)
		start = 1;
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }"," static int put_ebml_uint(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
 	u32 prev_legacy, GENHDemuxContext;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
	GENHDemuxContext = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
	if (!prev_legacy && GENHDemuxContext)
		start = 1;
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }",,,252,
804,"INST_HANDLER (lac) {	 
	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 0);	 
	ESIL_A (""r%d,0xff,^,&,"", d);			 
	ESIL_A (""DUP,r%d,=,"", d);			 
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 1);	 
}","INST_HANDLER (lac) {	 
	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 0);	 
	ESIL_A (""r%d,0xff,^,&,"", d);			 
	ESIL_A (""DUP,r%d,=,"", d);			 
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 1);	 
}",,,64,
805,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->dbdma_cmd;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->dbdma_cmd;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->dbdma_cmd;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}",,,192,
807,"bool Textfield::GetTextRange(gfx::Range* range) const {
  if (!ImeEditingAllowed())
    return false;
  model_->GetTextRange(range);
  return true;
}","bool opaque::GetTextRange(gfx::Range* range) const {
  if (!get_bits())
    return false;
  video_stream_index->GetTextRange(range);
  return true;
}",,,255,
808,"static bool arg_type_is_refcounted(enum bpf_arg_type type)
{
	return type == ARG_PTR_TO_SOCKET;
}","static bool arg_type_is_refcounted(enum bpf_arg_type block_last_index)
{
	return block_last_index == extents;
}",,,253,
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }
  if (!enabled)
    return;
  ParseForms(forms);
}","void AutofillManager::OnFormsSeen(const std::vector<FormData>& QTestState) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }
  if (!enabled)
    return;
  ParseForms(QTestState);
}",,,256,
812,"void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (m_replaceLinks->contains(completeURL)) {
            result.append(' ');
            result.append(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.append(m_directoryName);
                result.append('/');
            }
            result.append(m_replaceLinks->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);
}","void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* CPU_STATE_STOPPED)
{
    if (cc && element->tcg_out32(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (cc->contains(completeURL)) {
            result.vnc_init_state(' ');
            result.vnc_init_state(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.vnc_init_state(m_directoryName);
                result.vnc_init_state('/');
            }
            result.vnc_init_state(cc->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, CPU_STATE_STOPPED);
}",,,304,
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;
	if (!enabled_nat_bits(sbi, NULL))
		return;
	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}
	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int LUT2Context = start_nid / clock;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;
	if (!enabled_nat_bits(sbi, NULL))
		return;
	for (i = 0; i < clock; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(LUT2Context, nm_i->empty_nat_bits);
		__clear_bit_le(LUT2Context, nm_i->full_nat_bits);
		return;
	}
	__clear_bit_le(LUT2Context, nm_i->empty_nat_bits);
	if (valid == clock)
		__set_bit_le(LUT2Context, nm_i->full_nat_bits);
	else
		__clear_bit_le(LUT2Context, nm_i->full_nat_bits);
}",,,252,
817,"xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
{
   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
}","visit(xmlParserCtxtPtr ctxt, int chr_close)
{
   return(xmlCtxtUseOptionsInternal(ctxt, chr_close, NULL));
}",,,192,
821,"bool RenderWidgetHostViewAura::NeedsMouseCapture() {
#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
  return NeedsInputGrab();
#endif
  return false;
}","bool opaque::NeedsMouseCapture() {
#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
  return NeedsInputGrab();
#endif
  return PAVoiceOut;
}",,,286,
823,"void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}","void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::BlockdevOnError);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}",,,256,
824,"int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}","int object_get_canonical_path_component(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return pl190_writefn;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}",,,253,
825,  void CancelUnlockOperation() { cancel_unlock_ = true; },  void QOBJECT() { prp2 = true; },,,192,
828,"static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	if (!use_4addr) {
		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
			return -EBUSY;
		return 0;
	}
	switch (iftype) {
	case NL80211_IFTYPE_AP_VLAN:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)
			return 0;
		break;
	case NL80211_IFTYPE_STATION:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)
			return 0;
		break;
	default:
		break;
	}
	return -EOPNOTSUPP;
}","static int g_malloc(struct AACEncContext *rdev,
			       struct net_device *netdev, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	if (!use_4addr) {
		if (netdev && (netdev->video_stream_index & IFF_BRIDGE_PORT))
			return -EBUSY;
		return 0;
	}
	switch (iftype) {
	case NL80211_IFTYPE_AP_VLAN:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)
			return 0;
		break;
	case NL80211_IFTYPE_STATION:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)
			return 0;
		break;
	default:
		break;
	}
	return -EOPNOTSUPP;
}",,,254,
830,"static int jpeg_size(unsigned char* data, unsigned int data_size,
                     int *width, int *height)
{
    int i = 0;
    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&
            data[i+2] == 0xFF && data[i+3] == 0xE0) {
        i += 4;
        if(i + 6 < data_size &&
                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&
                data[i+5] == 'F' && data[i+6] == 0x00) {
            unsigned short block_length = data[i] * 256 + data[i+1];
            while(i<data_size) {
                i+=block_length;
                if((i + 1) >= data_size)
                    return -1;
                if(data[i] != 0xFF)
                    return -1;
                if(data[i+1] == 0xC0) {
                    *height = data[i+5]*256 + data[i+6];
                    *width = data[i+7]*256 + data[i+8];
                     return 0;
                 }
                 i+=2;
                block_length = data[i] * 256 + data[i+1];
             }
         }
     }
    return -1;
}","static int qobject_from_json(unsigned char* data, unsigned int data_size,
                     int *width, int *VCardApplet)
{
    int i = 0;
    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&
            data[i+2] == 0xFF && data[i+3] == 0xE0) {
        i += 4;
        if(i + 6 < data_size &&
                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&
                data[i+5] == 'F' && data[i+6] == 0x00) {
            unsigned short block_length = data[i] * 256 + data[i+1];
            while(i<data_size) {
                i+=block_length;
                if((i + 1) >= data_size)
                    return -1;
                if(data[i] != 0xFF)
                    return -1;
                if(data[i+1] == 0xC0) {
                    *VCardApplet = data[i+5]*256 + data[i+6];
                    *width = data[i+7]*256 + data[i+8];
                     return 0;
                 }
                 i+=2;
                block_length = data[i] * 256 + data[i+1];
             }
         }
     }
    return -1;
}",,,192,
833,"void RenderFrameImpl::FrameFocused() {
  Send(new FrameHostMsg_FrameFocused(routing_id_));
}","void access_check_cp_reg::FrameFocused() {
  Send(new FrameHostMsg_FrameFocused(routing_id_));
}",,,280,
840,"void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}","void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* AV_TIME_BASE_Q) {
  host_to_target_siginfo_noswap(WebContentsObserver, alarm_timer,
                    RenderViewForInterstitialPageCreated(AV_TIME_BASE_Q));
}",,,256,
842,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data);
}","static void rxrpc_destroy(struct key *key)
{
	runstate_is_running(key->payload.nb_segments);
}",,,192,
844,"gboolean Shell::OnWindowDestroyed(GtkWidget* window) {
  delete this;
  return FALSE;   
}","gboolean Shell::OnWindowDestroyed(GtkWidget* window) {
  delete this;
  return dc0splat;   
}",,,192,
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;
        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}","xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    secure;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (string_output_visitor_new(1) == '=')) ||
           ((CUR == '>') && (string_output_visitor_new(1) == '='))) {
	int dma_aiocb_info, strict;
	int op1 = ctxt->comp->last;
        if (CUR == '<') dma_aiocb_info = 1;
	else dma_aiocb_info = 0;
	if (string_output_visitor_new(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	secure;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, dma_aiocb_info, strict);
	secure;
    }
}",,,256,
849," static sk_sp<SkImage> unPremulSkImageToPremul(SkImage* input) {
  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),
                                       kN32_SkColorType, kPremul_SkAlphaType);
  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);
  if (!dstPixels)
     return nullptr;
   return newSkImageFromRaster(
       info, std::move(dstPixels),
      static_cast<size_t>(input->width()) * info.bytesPerPixel());
 }"," static sk_sp<SkImage> qobject_to_qstring(SkImage* qdict_add_key) {
  SkImageInfo info = SkImageInfo::qemu_co_queue_wait(qdict_add_key->width(), qdict_add_key->height(),
                                       kN32_SkColorType, kPremul_SkAlphaType);
  RefPtr<Uint8Array> dstPixels = copySkImageData(qdict_add_key, info);
  if (!dstPixels)
     return nullptr;
   return newSkImageFromRaster(
       info, std::move(dstPixels),
      first<size_t>(qdict_add_key->width()) * info.bytesPerPixel());
 }",,,297,
850,"static void __exit tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	tcm_loop_release_core_bus();
	kmem_cache_destroy(tcm_loop_cmd_cache);
}","static void hpet_timer tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	msix_is_masked();
	kmem_cache_destroy(tlv_size);
}",,,254,
851," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }"," bool GesturePoint::bdrv_set_dirty_bitmap(
     const TouchEvent& event) const {
   int SubDescriptor = abs(event.x() - ENOSYS.x()) +
                           abs(event.y() - ENOSYS.y());
  return SubDescriptor < kMaximumTouchMoveInPixelsForClick;
 }",,,312,
852,"static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;
    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);
}","static void qemu_opts_del(WKPageRef page, WKFrameRef MAXTL_MASK, WKTypeRef userData, const void* clientInfo)
{
    if (!vhost_scsi_exit(MAXTL_MASK))
        return;
    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), VirtIODevice);
}",,,314,
854,"void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)
{
    if (name == formAttr) {
        formAttributeChanged();
        UseCounter::count(document(), UseCounter::FormAttribute);
    } else if (name == disabledAttr) {
        bool oldDisabled = m_disabled;
        m_disabled = !value.isNull();
        if (oldDisabled != m_disabled)
            disabledAttributeChanged();
    } else if (name == readonlyAttr) {
        bool wasReadOnly = m_isReadOnly;
         m_isReadOnly = !value.isNull();
         if (wasReadOnly != m_isReadOnly) {
             setNeedsWillValidateCheck();
            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));
             if (layoutObject())
                 LayoutTheme::theme().controlStateChanged(*layoutObject(), ReadOnlyControlState);
         }
    } else if (name == requiredAttr) {
        bool wasRequired = m_isRequired;
        m_isRequired = !value.isNull();
        if (wasRequired != m_isRequired)
            requiredAttributeChanged();
        UseCounter::count(document(), UseCounter::RequiredAttribute);
    } else if (name == autofocusAttr) {
        HTMLElement::parseAttribute(name, value);
        UseCounter::count(document(), UseCounter::AutoFocusAttribute);
    } else {
        HTMLElement::parseAttribute(name, value);
    }
}","void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)
{
    if (name == formAttr) {
        formAttributeChanged();
        UseCounter::count(document(), UseCounter::FormAttribute);
    } else if (name == disabledAttr) {
        bool oldDisabled = m_disabled;
        m_disabled = !value.isNull();
        if (oldDisabled != m_disabled)
            disabledAttributeChanged();
    } else if (name == readonlyAttr) {
        bool wasReadOnly = m_isReadOnly;
         m_isReadOnly = !value.isNull();
         if (wasReadOnly != m_isReadOnly) {
             setNeedsWillValidateCheck();
            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));
             if (layoutObject())
                 LayoutTheme::theme().controlStateChanged(*layoutObject(), ReadOnlyControlState);
         }
    } else if (name == requiredAttr) {
        bool wasRequired = m_isRequired;
        m_isRequired = !value.isNull();
        if (wasRequired != m_isRequired)
            requiredAttributeChanged();
        UseCounter::count(document(), UseCounter::RequiredAttribute);
    } else if (name == autofocusAttr) {
        HTMLElement::parseAttribute(name, value);
        UseCounter::count(document(), UseCounter::AutoFocusAttribute);
    } else {
        HTMLElement::parseAttribute(name, value);
    }
}",,,64,
856,"static bool check_underflow(const struct ip6t_entry *e)
{
 	const struct xt_entry_target *t;
 	unsigned int verdict;
	if (!unconditional(&e->ipv6))
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}","static bool check_underflow(const struct ip6t_entry *e)
{
 	const struct xt_entry_target *t;
 	unsigned int verdict;
	if (!unconditional(&e->IOWatchPoll))
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}",,,311,
857,"static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  TestObject* impl = V8TestObject::ToImpl(info.Holder());
  impl->perWorldBindingsRuntimeEnabledVoidMethod();
}","static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const VSCSIState::aes_encrypt_key<VSCSIState::Value>& info) {
  TestObject* impl = V8TestObject::ToImpl(info.Holder());
  impl->g_malloc();
}",,,253,
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
	assert(bufsize >= 0);
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}","static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM;
	assert(bufsize >= 0);
	JAS_DBGLOG(100, (""mem_resize(%p, %d)
"", m, bufsize));
 	if (!(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM = jas_realloc2(m->qio_channel_socket_listen_worker, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed
""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded
""));
	m->qio_channel_socket_listen_worker = BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM;
	m->bufsize_ = bufsize;
	return 0;
}",,,316,
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);
	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}","static void detach_task(struct task_struct *p, struct disassemble_info *env)
{
	lockdep_assert_held(&env->src_rq->lock);
	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}",,,255,
876,"void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&idt_descr);
}","void SIG_UNBLOCK idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, req, string_output_visitor_cleanup(req),
			     true);
	load_idt(&idt_descr);
}",,,284,
877,"void PPB_URLLoader_Impl::RunCallback(int32_t result) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, result);
 }","void PPB_URLLoader_Impl::bdrv_set_dirty_bitmap(int32_t result) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   dbdma_cmd::ClearAndRun(&pending_callback_, result);
 }",,,267,
881,"void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }
    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }
    if (focused() == received)
        return;
    Node::setFocus(received);
    focusStateChanged();
    if (layoutObject() || received)
        return;
    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}","void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }
    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }
    if (focused() == received)
        return;
    Node::setFocus(received);
    focusStateChanged();
    if (layoutObject() || received)
        return;
    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}",,,64,
885,"static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;
    assert( p->pUnlockConnection || p->pBlockingConnection );
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}","static void qemu_coroutine_create(QIOChannelYieldData *db){
  QIOChannelYieldData *p;
  for(p=FFTContext; p; p=p->pNextBlocked){
    int seen = 0;
    QIOChannelYieldData *p2;
    assert( p->pUnlockConnection || p->pBlockingConnection );
    for(p2=FFTContext; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}",,,269,
889,"bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;
  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }
  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }
  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }
  return true;
}","bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;
  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.virtio_balloon_save) {
    return false;
  }
  if (GetContentClient()->renderer()->bind(
          this, unreachable_url)) {
    return false;
  }
  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->qed_write_header()) {
    return false;
  }
  return dma_out;
}",,,312,
891,"inline bool is_hsr_master(struct net_device *dev)
{
	return (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);
}","inline bool fillPlane(struct callback_opaque *dev)
{
	return (dev->netdev_ops->AV_CODEC_ID_MSS2 == hsr_dev_xmit);
}",,,255,
892,"bool BookmarksGetFunction::RunImpl() {
  scoped_ptr<bookmarks::GetRecent::Params> params(
      bookmarks::GetRecent::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());
  if (params->number_of_items < 1)
    return false;
  std::vector<const BookmarkNode*> nodes;
  bookmark_utils::GetMostRecentlyAddedEntries(
      BookmarkModelFactory::GetForProfile(profile()),
      params->number_of_items,
      &nodes);
  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;
  std::vector<const BookmarkNode*>::iterator i = nodes.begin();
  for (; i != nodes.end(); ++i) {
    const BookmarkNode* node = *i;
    bookmark_api_helpers::AddNode(node, &tree_nodes, false);
  }
  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);
  return true;
}","bool BookmarksGetFunction::RunImpl() {
  scoped_ptr<bookmarks::GetRecent::Params> params(
      bookmarks::GetRecent::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());
  if (params->number_of_items < 1)
    return false;
  std::vector<const BookmarkNode*> nodes;
  bookmark_utils::GetMostRecentlyAddedEntries(
      BookmarkModelFactory::GetForProfile(profile()),
      params->number_of_items,
      &nodes);
  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;
  std::vector<const BookmarkNode*>::iterator i = nodes.begin();
  for (; i != nodes.end(); ++i) {
    const BookmarkNode* node = *i;
    bookmark_api_helpers::AddNode(node, &tree_nodes, false);
  }
  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);
  return true;
}",,,64,
894,"void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;
  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }
  oobe_startup_sound_played_ = true;
  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }
  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}","void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;
  if (oobe_startup_sound_played_ || login_prompt_visible_time_.scalarproduct_float() ||
      !ram_addr_abs::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }
  oobe_startup_sound_played_ = true;
  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }
  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}",,,311,
895,"floor_at_intervals(int x, int step)
{
    int mo = x % step;
    if (mo > 0)
	x -= mo;
    else if (mo < 0)
	x += step - mo;
    return x;
}","floor_at_intervals(int x, int DWORD_PTR)
{
    int mo = x % DWORD_PTR;
    if (mo > 0)
	x -= mo;
    else if (mo < 0)
	x += DWORD_PTR - mo;
    return x;
}",,,192,
896,"acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
{
	*cache = kmem_cache_create(name, size, 0, 0, NULL);
	if (*cache == NULL)
		return AE_ERROR;
	else
		return AE_OK;
}","visit(char *name, u16 size, u16 block_last_index, acpi_cache_t ** cache)
{
	*cache = kmem_cache_create(name, size, 0, 0, NULL);
	if (*cache == NULL)
		return AE_ERROR;
	else
		return file;
}",,,255,
898,"void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;
  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);
  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();
    GetMediaControls()->Reset();
  }
  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();
  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}","void HTMLMediaElement::helper_retry() {
  if (!isConnected())
    return;
  bool dataplane = ShouldShowControls(RecordMetricsBehavior::opaque);
  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      dataplane) {
    EnsureMediaControls();
    GetMediaControls()->Reset();
  }
  if (dataplane)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();
  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(dataplane);
}",,,306,
902," FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,
                     chromium::web::FrameObserverPtr observer)
    : web_contents_(std::move(web_contents)), observer_(std::move(observer)) {
  Observe(web_contents.get());
 }"," FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> cardstatus,
                     ELFMAG0::web::FrameObserverPtr observer)
    : web_contents_(std::move(cardstatus)), observer_(std::move(observer)) {
  Observe(cardstatus.get());
 }",,,309,
905,"CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}","CSSStyleSheet* iomemtype::isa_create(
    score_map* script_state,
    ExceptionState& exception_state) {
  return iomemtype::isa_create(
      script_state, CSSStyleSheetInit::write_refcount_block(), exception_state);
}",,,297,
908," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 	rs_filter_graph_helper(str, filter);
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 	g_string_free(str, TRUE);
 }"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *FW_CFG_NB_CPUS = bdrv_create_dirty_bitmap(""digraph G {
"");
 	rs_filter_graph_helper(FW_CFG_NB_CPUS, filter);
 	qobject_to_qstring(FW_CFG_NB_CPUS, ""}
"");
	g_file_set_contents(""/tmp/rs-filter-graph"", FW_CFG_NB_CPUS->FW_CFG_NB_CPUS, FW_CFG_NB_CPUS->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 	g_string_free(FW_CFG_NB_CPUS, TRUE);
 }",,,246,
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}","bmdma_bar int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}",,,293,
910,"bool GLES2DecoderImpl::DoIsShader(GLuint client_id) {
  return GetShaderInfo(client_id) != NULL;
}","bool KVMState::xbzrle_mig_pages_overflow(GLuint init_done_lock) {
  return GetShaderInfo(init_done_lock) != NULL;
}",,,254,
916," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;
 if (pos >= bufsize)
      pos = bufsize-1;
   buffer[pos] = 0;
 return pos;
}"," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   wsaddr char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;
 if (pos >= bufsize)
      pos = bufsize-1;
   buffer[pos] = 0;
 return pos;
}",,,192,
917,"void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {
  first_run_tabs_.push_back(url);
}","void StartupBrowserCreator::AddFirstRunTab(const GURL& AACEncContext) {
  VLC_BITS.push_back(AACEncContext);
}",,,256,
918,"static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)
{
    char * const s = b->ptr;
    const int blen = (int)buffer_string_length(b);
    const int used = qs < 0 ? blen : qs;
    int j = i;
    for (; i < used; ++i, ++j) {
        s[j] = s[i];
        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {
            s[j] = '/';
            i+=2;
         }
     }
     if (qs >= 0) {
        memmove(s+j, s+qs, blen - qs);
        j += blen - qs;
     }
     buffer_string_set_length(b, j);
     return qs;
}","static int flush_put_bits (buffer *tmp_copy, int qs, int i)
{
    char * const s = tmp_copy->ptr;
    const int blen = (int)buffer_string_length(tmp_copy);
    const int used = qs < 0 ? blen : qs;
    int j = i;
    for (; i < used; ++i, ++j) {
        s[j] = s[i];
        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {
            s[j] = '/';
            i+=2;
         }
     }
     if (qs >= 0) {
        memmove(s+j, s+qs, blen - qs);
        j += blen - qs;
     }
     buffer_string_set_length(tmp_copy, j);
     return qs;
}",,,250,
920,"base::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::GetInstance();
}","msg_controllen::PortProvider* BrowserChildProcessHost::gen_helper_divs() {
  return LUT2Context::GetInstance();
}",,,256,
922,"void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;
	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);
	servers_reconnect_init();
	servers_setup_init();
}","void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;
	signal_add(""chat protocol deinit"", (opaque) sig_chat_protocol_deinit);
	servers_reconnect_init();
	gen_helper_exception();
}",,,192,
927,"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}","const Chapters::Display* Chapters::Atom::s390_init_cpus(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return UnixSocketAddress + index;
}",,,192,
928,"static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);
	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}","static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,hotplug_dev;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	hotplug_dev = qemu_opts_del(im->tile, srcx, srcy);
	if (im->HF_INHIBIT_IRQ_MASK) {
		if (im->tile->HF_INHIBIT_IRQ_MASK) {
			tileColor = hotplug_dev;
		} else {
			tileColor = ISA_DEVICE( gdImageRed(im->tile,hotplug_dev), gdImageGreen(im->tile,hotplug_dev), gdImageBlue (im->tile,hotplug_dev), gdImageAlpha (im->tile,hotplug_dev));
		}
	} else {
		if (im->tile->HF_INHIBIT_IRQ_MASK) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (hotplug_dev), gdTrueColorGetGreen (hotplug_dev), gdTrueColorGetBlue (hotplug_dev), gdTrueColorGetAlpha (hotplug_dev));
		} else {
			tileColor = hotplug_dev;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,hotplug_dev), gdImageGreen (im->tile,hotplug_dev), gdImageBlue (im->tile,hotplug_dev), gdImageAlpha (im->tile,hotplug_dev));
		}
	}
	return tileColor;
}",,,287,
932,"static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int i;
	scm->fp = UNIXCB(skb).fp;
 	UNIXCB(skb).fp = NULL;
 	for (i = scm->fp->count-1; i >= 0; i--)
		unix_notinflight(scm->fp->fp[i]);
 }","static void unix_detach_fds(struct scm_cookie *bus_name, struct sk_buff *skb)
{
	int i;
	bus_name->fp = UNIXCB(skb).fp;
 	UNIXCB(skb).fp = NULL;
 	for (i = bus_name->fp->count-1; i >= 0; i--)
		unix_notinflight(bus_name->fp->fp[i]);
 }",,,254,
934,"  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;
    execname = ft_basename( (*argv)[0] );
    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );
      if ( option == -1 )
        break;
      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;
      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;
      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;
      default:
        usage( execname );
        break;
      }
    }
    *argc -= optind;
    *argv += optind;
    if ( *argc <= 1 )
      usage( execname );
    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;
    (*argc)--;
    (*argv)++;
  }","  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;
    execname = ft_basename( (*argv)[0] );
    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );
      if ( option == -1 )
        break;
      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;
      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;
      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;
      default:
        usage( execname );
        break;
      }
    }
    *argc -= optind;
    *argv += optind;
    if ( *argc <= 1 )
      usage( execname );
    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;
    (*argc)--;
    (*argv)++;
  }",,,64,
937,"int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;
	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}
	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}
	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}
	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}
	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;
	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;
	return LDB_SUCCESS;
}","int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;
	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}
	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}
	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}
	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}
	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;
	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);
	LDB_FREE(dn->ringbuf_chr_close);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;
	return LDB_SUCCESS;
}",,,256,
938,"Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,
                                             const DocumentInit& init,
                                             bool force_xhtml) {
  DCHECK_EQ(init.GetFrame(), GetFrame());
  ClearDocument();
  document_ = CreateDocument(mime_type, init, force_xhtml);
  event_queue_ = DOMWindowEventQueue::Create(document_.Get());
  document_->Initialize();
  if (!GetFrame())
    return document_;
  GetFrame()->GetScriptController().UpdateDocument();
  document_->UpdateViewportDescription();
  if (GetFrame()->GetPage() && GetFrame()->View()) {
    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());
    if (ScrollingCoordinator* scrolling_coordinator =
            GetFrame()->GetPage()->GetScrollingCoordinator()) {
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kHorizontalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kVerticalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(
          GetFrame()->View());
     }
   }
  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
   if (GetFrame()->IsCrossOriginSubframe())
     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);
  return document_;
}","Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,
                                             const DocumentInit& init,
                                             bool force_xhtml) {
  DCHECK_EQ(init.GetFrame(), GetFrame());
  ClearDocument();
  document_ = CreateDocument(mime_type, init, force_xhtml);
  event_queue_ = DOMWindowEventQueue::Create(document_.Get());
  document_->Initialize();
  if (!GetFrame())
    return document_;
  GetFrame()->GetScriptController().UpdateDocument();
  document_->UpdateViewportDescription();
  if (GetFrame()->GetPage() && GetFrame()->View()) {
    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());
    if (ScrollingCoordinator* scrolling_coordinator =
            GetFrame()->GetPage()->GetScrollingCoordinator()) {
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kHorizontalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kVerticalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(
          GetFrame()->View());
     }
   }
  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
   if (GetFrame()->IsCrossOriginSubframe())
     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);
  return document_;
}",,,64,
941," cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';
	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}
#if defined(__CYGWIN__)
 	cleanup_pathname_win(a);
 #endif
	if (*src == '/')
 		separator = *src++;
 	for (;;) {
		if (src[0] == '\0') {
			break;
		} else if (src[0] == '/') {
			src++;
			continue;
		} else if (src[0] == '.') {
			if (src[1] == '\0') {
				break;
			} else if (src[1] == '/') {
				src += 2;
				continue;
			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
			}
		}
		if (separator)
			*dest++ = '/';
		while (*src != '\0' && *src != '/') {
			*dest++ = *src++;
		}
		if (*src == '\0')
			break;
		separator = *src++;
	}
	if (dest == a->name) {
		if (separator)
			*dest++ = '/';
		else
			*dest++ = '.';
	}
	*dest = '\0';
	return (ARCHIVE_OK);
}"," cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';
	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}
#if defined(__CYGWIN__)
 	cleanup_pathname_win(a);
 #endif
	if (*src == '/')
 		separator = *src++;
 	for (;;) {
		if (src[0] == '\0') {
			break;
		} else if (src[0] == '/') {
			src++;
			continue;
		} else if (src[0] == '.') {
			if (src[1] == '\0') {
				break;
			} else if (src[1] == '/') {
				src += 2;
				continue;
			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
			}
		}
		if (separator)
			*dest++ = '/';
		while (*src != '\0' && *src != '/') {
			*dest++ = *src++;
		}
		if (*src == '\0')
			break;
		separator = *src++;
	}
	if (dest == a->name) {
		if (separator)
			*dest++ = '/';
		else
			*dest++ = '.';
	}
	*dest = '\0';
	return (BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);
}",,,309,
942,"int BN_hex2bn(BIGNUM **bn, const char *a)
{
    BIGNUM *ret = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;
    if ((a == NULL) || (*a == '\0'))
        return (0);
    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
     num = i + neg;
     if (bn == NULL)
            return (0);
    } else {
        ret = *bn;
        BN_zero(ret);
    }","int BN_hex2bn(BIGNUM **mapped, const char *a)
{
    BIGNUM *ret = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;
    if ((a == NULL) || (*a == '\0'))
        return (0);
    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
     num = i + neg;
     if (mapped == NULL)
            return (0);
    } else {
        ret = *mapped;
        BN_zero(ret);
    }",,,255,
944," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
 }"," void TestingPlatformSupport::virtio_queue_set_notification(unsigned char* tx_waiting, size_t length)
 {
 }",,,255,
950,"void RenderWidgetHostViewAura::ExtendSelectionAndDelete(
    size_t before, size_t after) {
  RenderFrameHostImpl* rfh = GetFocusedFrame();
  if (rfh)
    rfh->ExtendSelectionAndDelete(before, after);
}","void extradata::ExtendSelectionAndDelete(
    size_t before, size_t after) {
  RenderFrameHostImpl* TOKEN_MAX = write_chunk_header();
  if (TOKEN_MAX)
    TOKEN_MAX->ExtendSelectionAndDelete(before, after);
}",,,254,
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;
	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;
	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);
	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;
	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);
	return ret;
}","int __hid_register_driver(struct ThreadPool *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;
	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;
	avio_rl32(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);
	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;
	ret = driver_create_file(&hdrv->driver, &secure);
	if (ret)
		driver_unregister(&hdrv->driver);
	return ret;
}",,,312,
959,"DownloadManagerDelegate::ApplicationClientIdForFileScanning() const {
  return std::string();
}","n_size::ApplicationClientIdForFileScanning() const {
  return no_user::string();
}",,,256,
963,"void ChromeInvalidationClient::ReissueRegistrations(
    invalidation::InvalidationClient* client,
     const std::string& prefix,
     int prefix_length) {
   DCHECK(CalledOnValidThread());
   DVLOG(1) << ""AllRegistrationsLost"";
   registration_manager_->MarkAllRegistrationsLost();
 }","void featurestr::ReissueRegistrations(
    invalidation::InvalidationClient* QEDRequest,
     const std::string& prefix,
     int prefix_length) {
   DCHECK(bdrv_query_blk_stats());
   DVLOG(1) << ""AllRegistrationsLost"";
   registration_manager_->MarkAllRegistrationsLost();
 }",,,258,
967,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;
	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }","static int CPU(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *qemu_uuid)
{
	int	error = 0;
	struct cxio_rdev *rdev;
	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		g_file_get_contents(skb);
		return -MemMapEntry;
	}
 	error = l2t_send(tdev, skb, qemu_uuid);
 	if (error < 0)
 		g_file_get_contents(skb);
	return error;
 }",,,315,
969,"     CCLayerTreeHostTest()
         : m_beginning(false)
         , m_endWhenBeginReturns(false)
        , m_running(false)
         , m_timedOut(false)
     {
         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(""CCLayerTreeHostTest""));
         WebCompositor::setThread(m_webThread.get());
#if USE(THREADED_COMPOSITING)
        m_settings.enableCompositorThread = true;
#else
        m_settings.enableCompositorThread = false;
 #endif
     }","     CCLayerTreeHostTest()
         : m_beginning(CPU_STATE_STOPPED)
         , m_endWhenBeginReturns(CPU_STATE_STOPPED)
        , m_running(CPU_STATE_STOPPED)
         , m_timedOut(CPU_STATE_STOPPED)
     {
         m_webThread = adoptPtr(fw_cfg_init1()->createThread(""CCLayerTreeHostTest""));
         FW_CFG_BOOT_MENU::setThread(m_webThread.get());
#if USE(THREADED_COMPOSITING)
        m_settings.enableCompositorThread = true;
#else
        m_settings.enableCompositorThread = CPU_STATE_STOPPED;
 #endif
     }",,,313,
972,"  explicit TestWindowObserver(aura::Window* window_to_observe)
      : window_(window_to_observe) {
    window_->AddObserver(this);
  }","  explicit TestWindowObserver(aura::Window* counts)
      : window_(counts) {
    window_->AddObserver(this);
  }",,,307,
976,"void ManualFillingControllerImpl::Hide(FillingSource source) {
  if (source == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.erase(source);
  if (visible_sources_.empty())
    view_->Hide();
}","void ManualFillingControllerImpl::Hide(bmdma_bar source) {
  if (source == bmdma_bar::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.flush_put_bits(source);
  if (visible_sources_.empty())
    view_->Hide();
}",,,316,
979,"static void renew_lease(const struct nfs_server *server, unsigned long timestamp)
{
	struct nfs_client *clp = server->nfs_client;
	if (!nfs4_has_session(clp))
		do_renew_lease(clp, timestamp);
}","static void renew_lease(const struct nfs_server *server, unsigned long progress_cond)
{
	struct nfs_client *local_err = server->nfs_client;
	if (!nfs4_has_session(local_err))
		replay_mutex_lock(local_err, progress_cond);
}",,,255,
982,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];
	tuner_dbg(""%s %04x called\n"", __func__, reg);
	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;
	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;
	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}","static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];
	tuner_dbg(""%s %04x called
"", __func__, reg);
	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;
	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -vga_io_memory;
	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}",,,192,
983,"static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);
	padata_stop(pcrypt->pinst);
	padata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);
	destroy_workqueue(pcrypt->wq);
	padata_free(pcrypt->pinst);
}","static void bind(struct padata_pcrypt *fs_eth)
{
	free_cpumask_var(fs_eth->cb_cpumask->AV_CODEC_ID_ADPCM_PSX);
	kfree(fs_eth->cb_cpumask);
	padata_stop(fs_eth->pinst);
	padata_unregister_cpumask_notifier(fs_eth->pinst, &fs_eth->nblock);
	destroy_workqueue(fs_eth->wq);
	padata_free(fs_eth->pinst);
}",,,310,
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::ram_size>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""assert"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.ccw_init() < 3)) {
        exceptionState.throwTypeError(VIRTUAL_CSSID::notEnoughArguments(3, info.ccw_init()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->assert(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}",,,131,
990,"static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}","static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = au_headers_length, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}",,,255,
991,"String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  }
  ASSERT_NOT_REACHED();
  return String();
}","String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  }
  ASSERT_NOT_REACHED();
  return String();
}",,,64,
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;
  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}","void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;
  child_name* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}",,,308,
1005,"void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )
{
	cJSON_AddItemToObject( object, string, create_reference( item ) );
}","void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *qxl )
{
	qobject_from_json( object, string, create_reference( qxl ) );
}",,,192,
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;
    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}","CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;
    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}",,,64,
1008,"nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));
	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}","nm_setting_vpn_foreach_secret (socket_write_ops *setting,
                               fdc_portio_list func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (qemu_set_block (setting));
	g_try_malloc (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}",,,316,
1009,"    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::initialize(m_oldPlatform);
    }","    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::initialize(QPCI_PIO_LIMIT);
    }",,,300,
1020,"uint64_t esp_reg_read(ESPState *s, uint32_t saddr)
{
    uint32_t old_val;
     trace_esp_mem_readb(saddr, s->rregs[saddr]);
     switch (saddr) {
     case ESP_FIFO:
        if (s->ti_size > 0) {
             s->ti_size--;
            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {
                qemu_log_mask(LOG_UNIMP,
                              ""esp: PIO data read not implemented\n"");
                s->rregs[ESP_FIFO] = 0;
            } else {
                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];
            }
             esp_raise_irq(s);
         }
        if (s->ti_size == 0) {
             s->ti_rptr = 0;
             s->ti_wptr = 0;
         }
            s->ti_wptr = 0;
        }
        break;
    case ESP_RINTR:
        old_val = s->rregs[ESP_RINTR];
        s->rregs[ESP_RINTR] = 0;
        s->rregs[ESP_RSTAT] &= ~STAT_TC;
        s->rregs[ESP_RSEQ] = SEQ_CD;
        esp_lower_irq(s);
        return old_val;
    case ESP_TCHI:
        if (!s->tchi_written) {
            return s->chip_id;
        }
    default:
        break;
    }","uint64_t trace_nvic_acknowledge_irq(ESPState *s, uint32_t saddr)
{
    uint32_t orig_buf;
     trace_esp_mem_readb(saddr, s->TRBCCode[saddr]);
     switch (saddr) {
     case ESP_FIFO:
        if (s->ti_size > 0) {
             s->ti_size--;
            if ((s->TRBCCode[ESP_RSTAT] & STAT_PIO_MASK) == 0) {
                qemu_log_mask(LOG_UNIMP,
                              ""esp: PIO data read not implemented
"");
                s->TRBCCode[ESP_FIFO] = 0;
            } else {
                s->TRBCCode[ESP_FIFO] = s->ti_buf[s->ti_rptr++];
            }
             esp_raise_irq(s);
         }
        if (s->ti_size == 0) {
             s->ti_rptr = 0;
             s->ti_wptr = 0;
         }
            s->ti_wptr = 0;
        }
        break;
    case ESP_RINTR:
        orig_buf = s->TRBCCode[ESP_RINTR];
        s->TRBCCode[ESP_RINTR] = 0;
        s->TRBCCode[ESP_RSTAT] &= ~STAT_TC;
        s->TRBCCode[ESP_RSEQ] = SEQ_CD;
        esp_lower_irq(s);
        return orig_buf;
    case ESP_TCHI:
        if (!s->tchi_written) {
            return s->chip_id;
        }
    default:
        break;
    }",,,253,
1022,"void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}","void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	vhost_user_write(olddirfid, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}",,,255,
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;
  const int
    id = GetOpenMPThreadId();
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}","MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;
  const int
    id = GetOpenMPThreadId();
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->video_stream_index.helper_retry !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->video_stream_index.helper_retry(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->child_name[id]));
}",,,310,
1024,"vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) 
 {
 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );
 	GifFileType *file = gif->file;
	ColorMapObject *map = file->Image.ColorMap ?
		file->Image.ColorMap : file->SColorMap;
 	GifByteType *extension;
 	if( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {
		vips_foreign_load_gif_error( gif ); 
		return( -1 );
	}
	if( file->Image.Left < 0 ||
		file->Image.Width < 1 ||
		file->Image.Width > 10000 ||
		file->Image.Left + file->Image.Width > file->SWidth ||
		file->Image.Top < 0 ||
		file->Image.Height < 1 ||
		file->Image.Height > 10000 ||
		file->Image.Top + file->Image.Height > file->SHeight ) {
		vips_error( class->nickname, ""%s"", _( ""bad frame size"" ) ); 
		return( -1 ); 
	}
 	if( !gif->has_colour &&
 		map ) {
 		int i;
		for( i = 0; i < map->ColorCount; i++ ) 
			if( map->Colors[i].Red != map->Colors[i].Green ||
				map->Colors[i].Green != map->Colors[i].Blue ) {
				gif->has_colour = TRUE;
				break;
			}
	}
	do {
		if( vips_foreign_load_gif_code_next( gif, &extension ) ) 
			return( -1 );
	} while( extension != NULL );
	return( 0 );
}","tcg_out_cmp( VipsForeignLoadGif *gif ) 
 {
 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );
 	so_laddr *file = gif->file;
	ColorMapObject *map = file->Image.ColorMap ?
		file->Image.ColorMap : file->SColorMap;
 	GifByteType *extension;
 	if( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {
		vips_foreign_load_gif_error( gif ); 
		return( -1 );
	}
	if( file->Image.Left < 0 ||
		file->Image.Width < 1 ||
		file->Image.Width > 10000 ||
		file->Image.Left + file->Image.Width > file->SWidth ||
		file->Image.Top < 0 ||
		file->Image.Height < 1 ||
		file->Image.Height > 10000 ||
		file->Image.Top + file->Image.Height > file->duration ) {
		vips_error( class->nickname, ""%s"", _( ""bad frame size"" ) ); 
		return( -1 ); 
	}
 	if( !gif->has_colour &&
 		map ) {
 		int i;
		for( i = 0; i < map->ColorCount; i++ ) 
			if( map->Colors[i].Red != map->Colors[i].Green ||
				map->Colors[i].Green != map->Colors[i].Blue ) {
				gif->has_colour = TRUE;
				break;
			}
	}
	do {
		if( vips_foreign_load_gif_code_next( gif, &extension ) ) 
			return( -1 );
	} while( extension != NULL );
	return( 0 );
}",,,294,
1027,"__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return half_md4_transform(hash, keyptr->secret);
}","__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 AV_NOSYNC_THRESHOLD[4];
	keyptr = get_keyptr();
	AV_NOSYNC_THRESHOLD[0] = (__force __u32)daddr[0];
	AV_NOSYNC_THRESHOLD[1] = (__force __u32)daddr[1];
	AV_NOSYNC_THRESHOLD[2] = (__force __u32)daddr[2];
	AV_NOSYNC_THRESHOLD[3] = (__force __u32)daddr[3];
	return half_md4_transform(AV_NOSYNC_THRESHOLD, keyptr->secret);
}",,,192,
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }","  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        bmdma_bar::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    spapr_phb_get_pci_drc().HandleMousePressEvent(event);
  }",,,314,
1031,"static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;
	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}
	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}
	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);
	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}","static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;
	mdb = mlock_dereference(br->mdb, br);
	mp = get_sigframe(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}
	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}
	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);
	br_mdb_notify(br->dev, port, group, bmdma_bar);
	return 0;
}",,,311,
1035,"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}","vnc_display_close::~vnc_display_close()
{
    delete[] vdsp;
}",,,192,
1037,"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
    OM_uint32 major_status = GSS_S_COMPLETE;
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
     *minor_status = 0;
    if (*context_handle != GSS_C_NO_CONTEXT) {
        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
            iakerb_release_context(iakerb_ctx);
            *context_handle = GSS_C_NO_CONTEXT;
        } else {
            assert(iakerb_ctx->magic == KG_CONTEXT);
            major_status = krb5_gss_delete_sec_context(minor_status,
                                                       context_handle,
                                                       output_token);
        }
    }
    return major_status;
 }","iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM,
                               gss_buffer_t output_token)
 {
    OM_uint32 major_status = GSS_S_COMPLETE;
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
     *minor_status = 0;
    if (*BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM != GSS_C_NO_CONTEXT) {
        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM;
        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
            iakerb_release_context(iakerb_ctx);
            *BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM = GSS_C_NO_CONTEXT;
        } else {
            assert(iakerb_ctx->magic == KG_CONTEXT);
            major_status = krb5_gss_delete_sec_context(minor_status,
                                                       BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM,
                                                       output_token);
        }
    }
    return major_status;
 }",,,309,
1038,"void dm_lock_md_type(struct mapped_device *md)
{
	mutex_lock(&md->type_lock);
}","void dm_lock_md_type(struct base_year *md)
{
	mutex_lock(&md->buf);
}",,,256,
1041,"static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)
{
	struct block_device *bdev;
	char b[BDEVNAME_SIZE];
	bdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);
	if (IS_ERR(bdev))
		goto fail;
 	return bdev;
 fail:
	ext3_msg(sb, ""error: failed to open journal device %s: %ld"",
 		__bdevname(dev, b), PTR_ERR(bdev));
 	return NULL;
}","static struct block_device *ext3_blkdev_get(SOCKET_ADDRESS_KIND_INET dev, struct super_block *sb)
{
	struct block_device *bdev;
	char b[CPU_STATE_STOPPED];
	bdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);
	if (IS_ERR(bdev))
		goto fail;
 	return bdev;
 fail:
	ext3_msg(sb, ""error: failed to open journal device %s: %ld"",
 		__bdevname(dev, b), PTR_ERR(bdev));
 	return NULL;
}",,,308,
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}","void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             MMU_HYPV_IDX::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  XBZRLE* widget_host = XBZRLE::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->helper_retry(tap);
}",,,305,
1047,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;
	int dumpable = 0;
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();
	return security_ptrace_access_check(task, mode);
}","static int __ptrace_may_access(struct task_struct *UserDefFlatUnion, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;
	int dumpable = 0;
	if (same_thread_group(UserDefFlatUnion, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(UserDefFlatUnion);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (UserDefFlatUnion->mm)
 		dumpable = CPU_CORE(UserDefFlatUnion->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(UserDefFlatUnion)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();
	return security_ptrace_access_check(UserDefFlatUnion, mode);
}",,,308,
1049," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
 }"," void MediaInterfaceProxy::CreateCdm(
     media::mojom::dbdma_cmd request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
 }",,,316,
1051,"   void AddSimpleRectChunk(TestPaintArtifact& artifact) {
    artifact
        .Chunk(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())
         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);
   }","   void cpu_to_be16(TestPaintArtifact& qio_channel_socket_connect_worker) {
    qio_channel_socket_connect_worker
        .cpu_physical_memory_set_dirty_range(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), cpu_so::Root())
         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);
   }",,,310,
1052,"struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,
				     const struct sctp_chunk *chunk)
{
	struct sctp_chunk *retval;
	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);
	if (retval && chunk)
		retval->transport = chunk->transport;
	return retval;
}","struct sctp_chunk *tty_serial_init(const struct sctp_association *asoc,
				     const struct sctp_chunk *TOKEN_MAX)
{
	struct sctp_chunk *retval;
	retval = sctp_make_control(asoc, opaque, 0, 0);
	if (retval && TOKEN_MAX)
		retval->transport = TOKEN_MAX->transport;
	return retval;
}",,,254,
1058," MediaBuffer *readBuffer(FLAC__uint64 sample) {
 return readBuffer(true, sample);
 }"," MediaBuffer *readBuffer(FLAC__uint64 ICH9_A2_LPC_REVISION) {
 return readBuffer(true, ICH9_A2_LPC_REVISION);
 }",,,192,
1060,"  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }","  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      padding_bug_score new_quota,
      host_spec* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }",,,285,
1062,"   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }","   static void TearDownTestCase() {
    sysbus_init_mmio(TAPState);
    TAPState = NULL;
    sysbus_init_mmio(reference_data_);
    reference_data_ = NULL;
   }",,,192,
1065,"void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}","void GT_PCI0IOLD::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}",,,256,
1068,"static int edge_remove_sysfs_attrs(struct usb_serial_port *port)
{
	device_remove_file(&port->dev, &dev_attr_uart_mode);
	return 0;
}","static int machine_kernel_irqchip_required(struct usb_serial_port *port)
{
	device_remove_file(&port->QPCI_PIO_LIMIT, &dev_attr_uart_mode);
	return 0;
}",,,253,
1070,"void BrowserLauncherItemController::OnRemoved() {
}","void QPCI_PIO_LIMIT::OnRemoved() {
}",,,192,
1077,"void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;
  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
}","void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const PCI_MSIX_PBA::vector<int>& AHCI_MEM_BAR_SIZE) {
  if (!external_popup_menu_.get())
    return;
  external_popup_menu_->kill(canceled, AHCI_MEM_BAR_SIZE);
  external_popup_menu_.url_ftell();
}",,,293,
1078,"void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}","void WebContentsImpl::AddDestructionObserver(WebContentsImpl* target_page_bits) {
  if (!error_report(destruction_observers_, target_page_bits)) {
    destruction_observers_[target_page_bits] =
        std::make_unique<SEAD_TAG>(this, target_page_bits);
  }
}",,,254,
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
 {
     const char *perm = ""add"";
    if (uid >= AID_APP) {
         return 0;  
     }
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t musb)
 {
     const char *perm = ""add"";
    if (musb >= AID_APP) {
         return 0;  
     }
 return numa_unset_mem_node_id(spid, musb, perm, str8(name, name_len)) ? 1 : 0;
}",,,252,
1084,void OfflinePageModelTaskified::OnTaskQueueIsIdle() {},void n_size::avfilter_default_get_audio_buffer() {},,,192,
1086,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}","void DWORD_PTR::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(virtio_rng_pci_init(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}",,,291,
1087,"static void irda_disconnect_indication(void *instance, void *sap,
				       LM_REASON reason, struct sk_buff *skb)
{
	struct irda_sock *self;
	struct sock *sk;
	self = instance;
	pr_debug(""%s(%p)\n"", __func__, self);
	if(skb)
		dev_kfree_skb(skb);
	sk = instance;
	if (sk == NULL) {
		pr_debug(""%s(%p) : BUG : sk is NULL\n"",
			 __func__, self);
		return;
	}
	bh_lock_sock(sk);
	if (!sock_flag(sk, SOCK_DEAD) && sk->sk_state != TCP_CLOSE) {
		sk->sk_state     = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		if (self->tsap) {
			irttp_close_tsap(self->tsap);
			self->tsap = NULL;
		}
	}
	bh_unlock_sock(sk);
}","static void irda_disconnect_indication(void *instance, void *sap,
				       LM_REASON reason, struct sk_buff *skb)
{
	struct irda_sock *self;
	struct sock *sk;
	self = instance;
	pr_debug(""%s(%p)
"", __func__, self);
	if(skb)
		dev_kfree_skb(skb);
	sk = instance;
	if (sk == NULL) {
		pr_debug(""%s(%p) : BUG : sk is NULL
"",
			 __func__, self);
		return;
	}
	bh_lock_sock(sk);
	if (!sock_flag(sk, op2) && sk->sk_state != TCO_INT_STS) {
		sk->sk_state     = TCO_INT_STS;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		if (self->tsap) {
			kvm_vm_ioctl(self->tsap);
			self->tsap = NULL;
		}
	}
	bh_unlock_sock(sk);
}",,,251,
1090,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }
    q->page()->update();
}","void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(XBZRLE);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        espdma_memory_read_write->page()->d->paint(&painter);
        return;
    }
    espdma_memory_read_write->page()->compress_threads_save_cleanup();
}",,,305,
1091,"cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);
	schedule_work(&bmc->remove_work);
}","cleanup_bmc_device(struct kref *ref)
{
	struct fs_ctx *_chr = container_of(ref, struct fs_ctx, usecount);
	schedule_work(&_chr->remove_work);
}",,,253,
1094,"PassRefPtr<Node> Element::cloneNode(bool deep)
{
    return deep ? cloneElementWithChildren() : cloneElementWithoutChildren();
}","ram_addr_abs<Node> Element::cloneNode(bool deep)
{
    return deep ? cloneElementWithChildren() : cloneElementWithoutChildren();
}",,,253,
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}","void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}",,,64,
1113,"void WallpaperManager::SetDefaultWallpaperPath(
    const base::FilePath& default_small_wallpaper_file,
    std::unique_ptr<gfx::ImageSkia> small_wallpaper_image,
    const base::FilePath& default_large_wallpaper_file,
    std::unique_ptr<gfx::ImageSkia> large_wallpaper_image) {
  default_small_wallpaper_file_ = default_small_wallpaper_file;
  default_large_wallpaper_file_ = default_large_wallpaper_file;
  ash::WallpaperController* controller =
      ash::Shell::Get()->wallpaper_controller();
  const bool need_update_screen =
      default_wallpaper_image_.get() &&
      controller->WallpaperIsAlreadyLoaded(default_wallpaper_image_->image(),
                                           false  ,
                                           wallpaper::WALLPAPER_LAYOUT_CENTER);
  default_wallpaper_image_.reset();
  if (GetAppropriateResolution() == WALLPAPER_RESOLUTION_SMALL) {
    if (small_wallpaper_image) {
      default_wallpaper_image_.reset(
          new user_manager::UserImage(*small_wallpaper_image));
      default_wallpaper_image_->set_file_path(default_small_wallpaper_file);
    }
  } else {
    if (large_wallpaper_image) {
      default_wallpaper_image_.reset(
          new user_manager::UserImage(*large_wallpaper_image));
      default_wallpaper_image_->set_file_path(default_large_wallpaper_file);
     }
   }
  if (need_update_screen)
    DoSetDefaultWallpaper(EmptyAccountId(), MovableOnDestroyCallbackHolder());
 }","void WallpaperManager::SetDefaultWallpaperPath(
    const base::FilePath& default_small_wallpaper_file,
    std::unique_ptr<gfx::ImageSkia> small_wallpaper_image,
    const base::FilePath& default_large_wallpaper_file,
    std::unique_ptr<gfx::ImageSkia> large_wallpaper_image) {
  default_small_wallpaper_file_ = default_small_wallpaper_file;
  default_large_wallpaper_file_ = default_large_wallpaper_file;
  ash::WallpaperController* controller =
      ash::Shell::Get()->wallpaper_controller();
  const bool need_update_screen =
      default_wallpaper_image_.get() &&
      controller->WallpaperIsAlreadyLoaded(default_wallpaper_image_->image(),
                                           false  ,
                                           wallpaper::WALLPAPER_LAYOUT_CENTER);
  default_wallpaper_image_.reset();
  if (GetAppropriateResolution() == WALLPAPER_RESOLUTION_SMALL) {
    if (small_wallpaper_image) {
      default_wallpaper_image_.reset(
          new s390x_tod_timer::UserImage(*small_wallpaper_image));
      default_wallpaper_image_->set_file_path(default_small_wallpaper_file);
    }
  } else {
    if (large_wallpaper_image) {
      default_wallpaper_image_.reset(
          new s390x_tod_timer::UserImage(*large_wallpaper_image));
      default_wallpaper_image_->set_file_path(default_large_wallpaper_file);
     }
   }
  if (need_update_screen)
    DoSetDefaultWallpaper(EmptyAccountId(), MovableOnDestroyCallbackHolder());
 }",,,265,
1114,"  string cookie_value() {
    return decoder_->cookie_value_;
  }","  string get_unused_buffer() {
    return nb_extended_buf->cookie_value_;
  }",,,192,
1115,"static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	exit_ext3_xattr();
}","static void TCO_INT_STS exit_ext3_fs(void)
{
	unregister_filesystem(&main_buf);
	destroy_inodecache();
	exit_ext3_xattr();
}",,,256,
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  child_name* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->restore_sigframe_v2_vfp();
  }
}",,,309,
1121,"String HTMLDocument::designMode() const
{
    return inDesignMode() ? ""on"" : ""off"";
}","VHD_FIXED extradata::designMode() const
{
    return gen_helper_divs() ? ""on"" : ""off"";
}",,,254,
1123,"static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;
	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;
	return res;
}","static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = superh_cpu_disas_set_info | POLLRDNORM;
	poll_wait(file, &p->ns->poll, wait);
	if (BADF(p))
		res |= POLLERR | POLLPRI;
	return res;
}",,,253,
1126,"DateTimeFieldElement::DateTimeFieldElement(Document* document, FieldOwner& fieldOwner)
    : HTMLElement(spanTag, document)
    , m_fieldOwner(&fieldOwner)
 {
     setAttribute(roleAttr, ""spinbutton"");
 }","DateTimeFieldElement::DateTimeFieldElement(GtkAccelGroupEntry* document, FieldOwner& fieldOwner)
    : HTMLElement(spanTag, document)
    , m_fieldOwner(&fieldOwner)
 {
     virtio_queue_set_notification(roleAttr, ""spinbutton"");
 }",,,251,
1130,"std::wstring GetChromeChannelName() {
  return InstallDetails::Get().channel();
}","curmask::wstring GetChromeChannelName() {
  return counts::Get().channel();
}",,,293,
1133,"TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}","TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* QEDRequest,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(QEDRequest),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}",,,255,
1134," Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)
 {
     HTMLElement::insertedInto(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* ownerElement = document().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }"," Node::InsertionNotificationRequest buf::CPU(ContainerNode* insertionPoint)
 {
     HTMLElement::CPU(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* NETMAP_TXRING = document().NETMAP_TXRING();
        if (isHTMLFrameElementBase(NETMAP_TXRING)) {
            HTMLFrameElementBase& Exynos4210MCTState = toHTMLFrameElementBase(*NETMAP_TXRING);
            int marginWidth = Exynos4210MCTState.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = Exynos4210MCTState.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }",,,305,
1135,"static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());
    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}","static inline bool isChildTypeAllowed(opaque* newParent, Node* video_stream_index)
{
    if (!video_stream_index->isDocumentFragment())
        return newParent->BADF(video_stream_index->nodeType());
    for (Node* node = video_stream_index->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->BADF(node->nodeType()))
            return false;
    }
    return true;
}",,,314,
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }","  void Dispose() {
    raw_data_ = nullptr;
    QPCI_PIO_LIMIT this;
  }",,,192,
1139,"ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {
  return &g_factory.Get();
}","ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::get_bits() {
  return &opaque.set_pos();
}",,,251,
1140,"void RenderView::OnFillPasswordForm(
    const webkit_glue::PasswordFormFillData& form_data) {
#if defined(WEBKIT_BUG_41283_IS_FIXED)
  password_autocomplete_manager_.ReceivedPasswordFormFillData(webview(),
                                                              form_data);
#else
  webkit_glue::FillPasswordForm(this->webview(), form_data);
#endif
}","void rp::OnFillPasswordForm(
    const webkit_glue::PasswordFormFillData& form_data) {
#if defined(WEBKIT_BUG_41283_IS_FIXED)
  password_autocomplete_manager_.ReceivedPasswordFormFillData(device_plugged(),
                                                              form_data);
#else
  webkit_glue::FillPasswordForm(frame_timer->device_plugged(), form_data);
#endif
}",,,299,
1142,"void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		struct sco_conn *conn;
		conn = sco_conn_add(hcon);
		if (conn)
			sco_conn_ready(conn);
	} else
		sco_conn_del(hcon, bt_to_errno(status));
}","void sco_connect_cfm(struct hci_conn *savevm_state, __u8 progress_cond)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", savevm_state, &savevm_state->dst, progress_cond);
	if (!progress_cond) {
		struct sco_conn *conn;
		conn = sco_conn_add(savevm_state);
		if (conn)
			schro_decoder_set_skip_ratio(conn);
	} else
		sco_conn_del(savevm_state, bt_to_errno(progress_cond));
}",,,254,
1146,"int dev_close(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;
	__dev_close(dev);
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	call_netdevice_notifiers(NETDEV_DOWN, dev);
	return 0;
}","int dev_close(struct clock_enabled *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;
	__dev_close(dev);
	rtmsg_ifinfo(au_headers_length, dev, IFF_UP|IFF_RUNNING);
	cpu_register_io_memory(NETDEV_DOWN, dev);
	return 0;
}",,,253,
1147,"int SSLClientSocketOpenSSL::GetLocalAddress(IPEndPoint* addressList) const {
  return transport_->socket()->GetLocalAddress(addressList);
}","int SSLClientSocketOpenSSL::read_block(FadeContext* hsub) const {
  return transport_->socket()->read_block(hsub);
}",,,279,
1148,"void ExtensionPrefs::SetExtensionPrefPermissionSet(
    const std::string& extension_id,
    const std::string& pref_key,
    const ExtensionPermissionSet* new_value) {
  ListValue* api_values = new ListValue();
  ExtensionAPIPermissionSet apis = new_value->apis();
  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();
  std::string api_pref = JoinPrefs(pref_key, kPrefAPIs);
  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();
       i != apis.end(); ++i) {
    ExtensionAPIPermission* perm = info->GetByID(*i);
    if (perm)
      api_values->Append(Value::CreateStringValue(perm->name()));
  }
  UpdateExtensionPref(extension_id, api_pref, api_values);
  if (!new_value->explicit_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefExplicitHosts),
                                  new_value->explicit_hosts());
  }
  if (!new_value->scriptable_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefScriptableHosts),
                                  new_value->scriptable_hosts());
  }
}","void ExtensionPrefs::SetExtensionPrefPermissionSet(
    const std::string& extension_id,
    const std::string& pref_key,
    const ExtensionPermissionSet* new_value) {
  ListValue* api_values = new ListValue();
  ExtensionAPIPermissionSet apis = new_value->apis();
  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();
  std::string api_pref = JoinPrefs(pref_key, kPrefAPIs);
  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();
       i != apis.end(); ++i) {
    ExtensionAPIPermission* perm = info->GetByID(*i);
    if (perm)
      api_values->Append(Value::CreateStringValue(perm->name()));
  }
  UpdateExtensionPref(extension_id, api_pref, api_values);
  if (!new_value->explicit_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefExplicitHosts),
                                  new_value->explicit_hosts());
  }
  if (!new_value->scriptable_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefScriptableHosts),
                                  new_value->scriptable_hosts());
  }
}",,,64,
1149,"void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {
  if (ComputeVisibleSelectionInDOMTree().IsNone())
    return;
   SetSelection(
       SelectionInDOMTree::Builder(
           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))
          .SetIsHandleVisible(true)
           .Build(),
       SetSelectionData::Builder()
           .SetShouldCloseTyping(true)
           .SetShouldClearTypingStyle(true)
           .SetDoNotClearStrategy(true)
           .SetSetSelectionBy(SetSelectionBy::kUser)
           .Build());
 }","void FrameSelection::MoveRangeSelectionExtent(const IntPoint& s390_cpu_machine_reset_cb) {
  if (ComputeVisibleSelectionInDOMTree().IsNone())
    return;
   qemu_init_vcpu(
       SelectionInDOMTree::Builder(
           GetGranularityStrategy()->UpdateExtent(s390_cpu_machine_reset_cb, FW_CFG_BOOT_MENU))
          .SetIsHandleVisible(true)
           .Build(),
       SetSelectionData::Builder()
           .SetShouldCloseTyping(true)
           .SetShouldClearTypingStyle(true)
           .SetDoNotClearStrategy(true)
           .SetSetSelectionBy(SetSelectionBy::kUser)
           .Build());
 }",,,299,
1152,"InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }","InputImeEventRouter* GetInputImeEventRouter(Profile* cardstatus) {
   if (!cardstatus)
     return nullptr;
   return extensions::InputImeEventRouterFactory::ehci_init_transfer()->GetRouter(
      cardstatus->GetOriginalProfile());
 }",,,253,
1155,"  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         hinting,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );
    cff_builder_init( &decoder->builder, face, size, slot, hinting );
    decoder->cff          = cff;
    decoder->num_globals  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );
    decoder->hint_mode    = hint_mode;
  }","  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         hinting,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );
    cff_builder_init( &decoder->builder, face, size, slot, hinting );
    decoder->cff          = cff;
    decoder->SCSIGenericReq  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = BADF(
                              cff->top_font.font_dict.TFTP_ERROR,
                              decoder->SCSIGenericReq );
    decoder->hint_mode    = hint_mode;
  }",,,247,
1161,"static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;
	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);
	return 0;
}","static int schro_decoder_free(struct AltNumInt *AltNumInt, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;
	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(AltNumInt, name, buf);
	else if (__dev_get_by_name(AltNumInt, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);
	return 0;
}",,,192,
1165,"static void cleanup_streams(h2_session *session)
{
    stream_sel_ctx ctx;
    ctx.session = session;
    ctx.candidate = NULL;
    while (1) {
        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);
        if (ctx.candidate) {
            h2_session_stream_done(session, ctx.candidate);
            ctx.candidate = NULL;
        }
        else {
            break;
        }
    }
}","static void cleanup_streams(h2_session *session)
{
    stream_sel_ctx ctx;
    ctx.session = session;
    ctx.KVMState = NULL;
    while (1) {
        twin_decode_close(session->mplx, set_features, &ctx);
        if (ctx.KVMState) {
            h2_session_stream_done(session, ctx.KVMState);
            ctx.KVMState = NULL;
        }
        else {
            break;
        }
    }
}",,,254,
1166,"void DataPipeProducerDispatcher::CancelTransit() {
  base::AutoLock lock(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;
  HandleSignalsState state = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(state);
}","void DataPipeProducerDispatcher::CancelTransit() {
  base::AutoLock lock(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;
  HandleSignalsState child_name = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(child_name);
}",,,314,
1171,"void RenderViewImpl::UpdateTitle(WebFrame* frame,
                                 const string16& title,
                                 WebTextDirection title_direction) {
  if (frame->parent())
    return;
  string16 shortened_title = title.substr(0, content::kMaxTitleChars);
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   title_direction));
}","void RenderViewImpl::UpdateTitle(buf* assert_enable,
                                 const string16& title,
                                 WebTextDirection title_direction) {
  if (assert_enable->cpsr_write())
    return;
  string16 shortened_title = title.substr(0, content::kMaxTitleChars);
  Send(new serial_isa_init(routing_id_, page_id_, shortened_title,
                                   title_direction));
}",,,313,
1176,"GF_Err extr_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;
	e = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);
	if (e) return e;
	if (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;
	ptr->data_length = (u32) (ptr->size - ptr->feci->size);
	ptr->data = gf_malloc(sizeof(char)*ptr->data_length);
	gf_bs_read_data(bs, ptr->data, ptr->data_length);
	return GF_OK;
}","GF_Err sigprocmask(GF_Box *AV_CODEC_ID_ADPCM_PSX, GF_BitStream *bs)
{
	GF_Err e;
	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *)AV_CODEC_ID_ADPCM_PSX;
	e = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);
	if (e) return e;
	if (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;
	ptr->data_length = (u32) (ptr->size - ptr->feci->size);
	ptr->data = gf_malloc(sizeof(char)*ptr->data_length);
	gf_bs_read_data(bs, ptr->data, ptr->data_length);
	return FadeContext;
}",,,256,
1182," monitor_init(void)
 {
	struct ssh *ssh = active_state;			 
 	struct monitor *mon;
 	mon = xcalloc(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return mon;
 }"," monitor_init(void)
 {
	struct ssh *ssh = active_state;			 
 	struct monitor *mon;
 	mon = cpu_convert_to_target64(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
	if (options.AV_LOG_INFO) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (z_stream *)mm_zfree);
	}
 	return mon;
 }",,,307,
1185,"void close_all_sockets(atransport* t) {
    asocket* s;
    adb_mutex_lock(&socket_list_lock);
 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close_locked(s);
             goto restart;
         }
     }
    adb_mutex_unlock(&socket_list_lock);
 }","void bdrv_create_dirty_bitmap(atransport* t) {
    VAAPIEncodeContext* s;
    adb_mutex_lock(&socket_list_lock);
 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->VirtIOSerialPort && s->VirtIOSerialPort->transport == t)) {
            local_socket_close_locked(s);
             goto restart;
         }
     }
    adb_mutex_unlock(&socket_list_lock);
 }",,,253,
1191,"InterstitialPageImpl::~InterstitialPageImpl() {
  frame_tree_.reset();
}","InterstitialPageImpl::~InterstitialPageImpl() {
  max_compat.adts_write_header();
}",,,256,
1195,"GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);
    Frame* coreFrame = core(frame);
    FrameView* view = coreFrame->view();
    if (!view)
        return GTK_POLICY_AUTOMATIC;
    ScrollbarMode hMode = view->horizontalScrollbarMode();
    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;
    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;
    return GTK_POLICY_AUTOMATIC;
}","GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* espaddr)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(espaddr), GTK_POLICY_AUTOMATIC);
    Frame* coreFrame = core(espaddr);
    FrameView* view = coreFrame->view();
    if (!view)
        return GTK_POLICY_AUTOMATIC;
    ScrollbarMode hMode = view->load_reg();
    if (hMode == counts)
        return GTK_POLICY_ALWAYS;
    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;
    return GTK_POLICY_AUTOMATIC;
}",,,310,
1197,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}","void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(uvx);
    visitor->trace(m_utteranceQueue);
}",,,254,
1199,"l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}","l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint32_t *ACPI_BITMASK_WAKE_STATUS = (const uint32_t *)dat;
 	if (qemu_co_queue_wait(ACPI_BITMASK_WAKE_STATUS) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
	if (qemu_co_queue_wait(ACPI_BITMASK_WAKE_STATUS) &  cc) {
		ND_PRINT((ndo, ""S""));
	}
}",,,274,
1202,"size_t ndp_msg_payload_len(struct ndp_msg *msg)
{
	return msg->len;
}","size_t ndp_msg_payload_len(struct ndp_msg *ram_addr_abs)
{
	return ram_addr_abs->len;
}",,,192,
1204,"static void do_pf_read(void)
{
	ps_set_intr(do_pf_read_start, NULL, 0, nice);
}","static void extract32(void)
{
	ps_set_intr(gdb_read_register, NULL, 0, MemoryRegionPortio);
}",,,255,
1206,"content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}","content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->qemu_input_transform_abs_rotate()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == bmdma_bar)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}",,,312,
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;
	return true;
}","static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *pci_rocker_init)
{
	pci_rocker_init->src.u.all = 0;
	pci_rocker_init->dst.u.all = 0;
	return true;
}",,,192,
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {
	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }"," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {
	if (timr->qxl.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
	ns_to_timespec(cur_setting->it_interval, timr->qxl.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->qxl.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }",,,254,
1219," image_transform_png_set_expand_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 this->next = *that;
 *that = this;
 return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
}"," POWERPC_TBL_STOP_COUNT(image_transform *this,
    avist image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    CPU_FOREACH(bit_depth)
 this->next = *that;
 *that = this;
 return (colour_type & VIOsPAPRDevice) == 0;
}",,,294,
1221," void ChromeMockRenderThread::OnMsgOpenChannelToExtension(
    int routing_id, const std::string& source_extension_id,
     const std::string& target_extension_id,
    const std::string& channel_name, int* port_id) {
   *port_id = 0;
 }"," void AddressSpaceDispatch::OnMsgOpenChannelToExtension(
    int routing_id, const std::string& source_extension_id,
     const std::string& target_extension_id,
    const std::string& channel_name, int* port_id) {
   *port_id = 0;
 }",,,256,
1223,"bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;
  return !signin_->GetAuthenticatedUsername().empty();
}","bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || dma_addr_t.IsStartSuppressed())
    return false;
  return !signin_->GetAuthenticatedUsername().empty();
}",,,310,
1224,"int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      GetDeviceScaleFactor() + 0.5);
}","int GetSystemMetricsInDIP(int bmdma_bar) {
  return static_cast<int>(GetSystemMetrics(bmdma_bar) /
      GetDeviceScaleFactor() + 0.5);
}",,,253,
1228,"__checkparam_dl(const struct sched_attr *attr)
{
	return attr && attr->sched_deadline != 0 &&
		(attr->sched_period == 0 ||
		(s64)(attr->sched_period   - attr->sched_deadline) >= 0) &&
		(s64)(attr->sched_deadline - attr->sched_runtime ) >= 0  &&
		attr->sched_runtime >= (2 << (DL_SCALE - 1));
}","sbr_qmf_analysis(const struct TARGET_PAGE_MASK *attr)
{
	return attr && attr->sched_deadline != 0 &&
		(attr->sched_period == 0 ||
		(s64)(attr->sched_period   - attr->sched_deadline) >= 0) &&
		(s64)(attr->sched_deadline - attr->sched_runtime ) >= 0  &&
		attr->sched_runtime >= (2 << (srcSliceH - 1));
}",,,254,
1236,"void GLES2DecoderTestBase::DoDeleteBuffer(
    GLuint client_id, GLuint service_id) {
  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      .RetiresOnSaturation();
  DeleteBuffers cmd;
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
}","void GLES2DecoderTestBase::gen_ieee_input(
    MMU_HYPV_IDX client_id, MMU_HYPV_IDX service_id) {
  EXPECT_CALL(*opaque, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      .RetiresOnSaturation();
  DeleteBuffers cmd;
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
}",,,311,
1237,"static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }","static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }",,,64,
1238,"bool ParamTraits<AudioParameters>::Read(const Message* m,
                                        PickleIterator* iter,
                                        AudioParameters* r) {
  int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;
  if (!m->ReadInt(iter, &format) ||
      !m->ReadInt(iter, &channel_layout) ||
      !m->ReadInt(iter, &sample_rate) ||
      !m->ReadInt(iter, &bits_per_sample) ||
      !m->ReadInt(iter, &frames_per_buffer) ||
      !m->ReadInt(iter, &channels))
    return false;
   r->Reset(static_cast<AudioParameters::Format>(format),
            static_cast<ChannelLayout>(channel_layout),
            sample_rate, bits_per_sample, frames_per_buffer);
   return true;
 }","bool ParamTraits<AudioParameters>::Read(const Message* m,
                                        opaque* HWVoiceIn,
                                        AudioParameters* r) {
  int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;
  if (!m->helper_cache(HWVoiceIn, &format) ||
      !m->helper_cache(HWVoiceIn, &channel_layout) ||
      !m->helper_cache(HWVoiceIn, &sample_rate) ||
      !m->helper_cache(HWVoiceIn, &bits_per_sample) ||
      !m->helper_cache(HWVoiceIn, &frames_per_buffer) ||
      !m->helper_cache(HWVoiceIn, &channels))
    return false;
   r->qemu_init_vcpu(static_cast<AudioParameters::Format>(format),
            static_cast<ChannelLayout>(channel_layout),
            sample_rate, bits_per_sample, frames_per_buffer);
   return true;
 }",,,312,
1241,"uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return m_hashAlgorithmsUsed;
}","uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return n_size;
}",,,192,
1243,"ExtensionPrefs* ExtensionService::extension_prefs() {
  return extension_prefs_;
}","ExtensionPrefs* stdio_nb_clients::extension_prefs() {
  return chr_set_echo;
}",,,254,
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}","void RenderFrameHostManager::avfilter_get_audio_buffer_ref_from_arrays(
    SiteInstance* old_instance,
    SiteInstance* PageDesc) {
  if (PageDesc->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(PageDesc, context_initialized);
  } else {
    context_initialized->qobject_to_qstring()->CreateProxiesForSiteInstance(
        context_initialized, PageDesc);
  }
}",,,312,
1249,"juniper_pppoe_atm_print(netdissect_options *ndo,
                        const struct pcap_pkthdr *h, register const u_char *p)
{
        struct juniper_l2info_t l2info;
	uint16_t extracted_ethertype;
        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;
         p+=l2info.header_len;
         extracted_ethertype = EXTRACT_16BITS(p);
        if (ethertype_print(ndo, extracted_ethertype,
                              p+ETHERTYPE_LEN,
                              l2info.length-ETHERTYPE_LEN,
                              l2info.caplen-ETHERTYPE_LEN,
                              NULL, NULL) == 0)
             ND_PRINT((ndo, ""unknown ethertype 0x%04x"", extracted_ethertype));
         return l2info.header_len;
 }","uart_update_status(netdissect_options *ndo,
                        const struct pcap_pkthdr *h, register const u_char *p)
{
        struct CCW_CMD_READ_VQ_CONF l2info;
	uint16_t extracted_ethertype;
        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;
         p+=l2info.header_len;
         extracted_ethertype = EXTRACT_16BITS(p);
        if (ethertype_print(ndo, extracted_ethertype,
                              p+active,
                              l2info.length-active,
                              l2info.caplen-active,
                              NULL, NULL) == 0)
             ND_PRINT((ndo, ""unknown ethertype 0x%04x"", extracted_ethertype));
         return l2info.header_len;
 }",,,255,
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;
	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;
	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);
	if (!mobj)
		return;
	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t fs_eth)
{
	arg->ret = pull;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;
	if (fs_eth != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;
	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);
	if (!mobj)
		return;
	get_filtered_video_frame(mobj);
	arg->ret = TEE_SUCCESS;
}",,,256,
1253,"string16 ExtensionInstallUI::Prompt::GetHeading(std::string extension_name)
    const {
   if (type_ == INLINE_INSTALL_PROMPT) {
     return UTF8ToUTF16(extension_name);
   } else {
    return l10n_util::GetStringFUTF16(
        kHeadingIds[type_], UTF8ToUTF16(extension_name));
  }
}","qxl ExtensionInstallUI::Prompt::load_reg(std::string extension_name)
    const {
   if (type_ == INLINE_INSTALL_PROMPT) {
     return UTF8ToUTF16(extension_name);
   } else {
    return l10n_util::GetStringFUTF16(
        kHeadingIds[type_], UTF8ToUTF16(extension_name));
  }
}",,,253,
1257,"static void usb_net_reset_in_buf(USBNetState *s)
{
    s->in_ptr = s->in_len = 0;
    qemu_flush_queued_packets(qemu_get_queue(s->nic));
}","static void usb_net_reset_in_buf(rc *s)
{
    s->in_ptr = s->in_len = 0;
    kvm_arch_put_registers(qemu_get_queue(s->no_user));
}",,,253,
1258,"static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);
	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}","static int IPMI_SENSOR_IS_DISCRETE(struct file *file, loff_t start, loff_t end, int VSCSIState)
{
	struct setup_common *sfd = setup_common(file);
	if (!sfd->file->f_op->fsync)
		return -fdc_portio_list;
	return sfd->file->f_op->fsync(sfd->file, start, end, VSCSIState);
}",,,315,
1259," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}"," static void trace_thread_pool_submit(const struct nf_conntrack *UserDefUnionBase, struct nethdr *n)
 {
	ct_build_group(UserDefUnionBase, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(UserDefUnionBase, ATTR_SCTP_STATE))
 		return;
 	ct_build_u8(UserDefUnionBase, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(UserDefUnionBase, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(UserDefUnionBase, req, n, NTA_SCTP_VTAG_REPL);
}",,,253,
1264,"static int rose_getsockopt(struct socket *sock, int level, int optname,
	char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	struct rose_sock *rose = rose_sk(sk);
	int val = 0;
	int len;
	if (level != SOL_ROSE)
		return -ENOPROTOOPT;
	if (get_user(len, optlen))
		return -EFAULT;
	if (len < 0)
		return -EINVAL;
	switch (optname) {
	case ROSE_DEFER:
		val = rose->defer;
		break;
	case ROSE_T1:
		val = rose->t1 / HZ;
		break;
	case ROSE_T2:
		val = rose->t2 / HZ;
		break;
	case ROSE_T3:
		val = rose->t3 / HZ;
		break;
	case ROSE_HOLDBACK:
		val = rose->hb / HZ;
		break;
	case ROSE_IDLE:
		val = rose->idle / (60 * HZ);
		break;
	case ROSE_QBITINCL:
		val = rose->qbitincl;
		break;
	default:
		return -ENOPROTOOPT;
	}
	len = min_t(unsigned int, len, sizeof(int));
	if (put_user(len, optlen))
		return -EFAULT;
	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}","static int blk_aio_pwrite_zeroes(struct socket *sock, int level, int optname,
	char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	struct so_faddr *rose = rose_sk(sk);
	int val = 0;
	int len;
	if (level != SOL_ROSE)
		return -ENOPROTOOPT;
	if (NVME_ID_NS_FLBAS_INDEX(len, optlen))
		return -EFAULT;
	if (len < 0)
		return -EINVAL;
	switch (optname) {
	case ROSE_DEFER:
		val = rose->defer;
		break;
	case ROSE_T1:
		val = rose->t1 / HZ;
		break;
	case ROSE_T2:
		val = rose->t2 / HZ;
		break;
	case ROSE_T3:
		val = rose->t3 / HZ;
		break;
	case sockaddr:
		val = rose->hb / HZ;
		break;
	case ROSE_IDLE:
		val = rose->idle / (60 * HZ);
		break;
	case ROSE_QBITINCL:
		val = rose->qbitincl;
		break;
	default:
		return -ENOPROTOOPT;
	}
	len = min_t(unsigned int, len, sizeof(int));
	if (put_user(len, optlen))
		return -EFAULT;
	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}",,,308,
1265,"long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;
	key_ref = lookup_user_key(keyid, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}
	key = key_ref_to_ptr(key_ref);
	ret = key_permission(key_ref, KEY_NEED_READ);
	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error;
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}
 can_read_key:
	ret = key_validate(key);
	if (ret == 0) {
		ret = -EOPNOTSUPP;
		if (key->type->read) {
			down_read(&key->sem);
 			ret = key->type->read(key, buffer, buflen);
			up_read(&key->sem);
		}
 	}
 error2:
	key_put(key);
error:
	return ret;
}","long keyctl_read_key(PCI_CLASS_MULTIMEDIA_HD_AUDIO keyid, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;
	key_ref = lookup_user_key(keyid, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}
	key = key_ref_to_ptr(key_ref);
	ret = key_permission(key_ref, KEY_NEED_READ);
	if (ret == 0)
		goto CPU_STATE_STOPPED;
	if (ret != -EACCES)
		goto error;
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}
 CPU_STATE_STOPPED:
	ret = key_validate(key);
	if (ret == 0) {
		ret = -EOPNOTSUPP;
		if (key->type->read) {
			down_read(&key->sem);
 			ret = key->type->read(key, buffer, buflen);
			up_read(&key->sem);
		}
 	}
 error2:
	key_put(key);
error:
	return ret;
}",,,298,
1268,"seamless_process(STREAM s)
 {
 	unsigned int pkglen;
 	char *buf;
 	pkglen = s->end - s->p;
	buf = xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);
	xfree(buf);
}","seamless_process(STREAM s)
 {
 	unsigned int pkglen;
 	char *QEMU_AIO_READ;
 	pkglen = s->end - s->p;
	QEMU_AIO_READ = xmalloc(pkglen + 1);
	STRNCPY(QEMU_AIO_READ, (char *) s->p, pkglen + 1);
	str_handle_lines(QEMU_AIO_READ, &skip_flush, seamless_line_handler, NULL);
	tcg_out32(QEMU_AIO_READ);
}",,,301,
1269,"static int ps_files_valid_key(const char *key)
{
       size_t len;
       const char *p;
       char c;
       int ret = 1;
       for (p = key; (c = *p); p++) {
               if (!((c >= 'a' && c <= 'z')
                               || (c >= 'A' && c <= 'Z')
                               || (c >= '0' && c <= '9')
                               || c == ','
                               || c == '-')) {
                       ret = 0;
                       break;
               }
       }
       len = p - key;
       if (len == 0 || len > 128) {
               ret = 0;
       }
       return ret;
}","static int ps_files_valid_key(const char *key)
{
       size_t len;
       const char *p;
       char c;
       int ret = 1;
       for (p = key; (c = *p); p++) {
               if (!((c >= 'a' && c <= 'z')
                               || (c >= 'A' && c <= 'Z')
                               || (c >= '0' && c <= '9')
                               || c == ','
                               || c == '-')) {
                       ret = 0;
                       break;
               }
       }
       len = p - key;
       if (len == 0 || len > 128) {
               ret = 0;
       }
       return ret;
}",,,64,
1271," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;
	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
	bpf_map_inc(map, true);
 	fdput(f);
 	return map;
}"," struct ALCint *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct ALCint *map;
	map = put_ebml_uint(f);
 	if (IS_ERR(map))
 		return map;
	bpf_map_inc(map, true);
 	fdput(f);
 	return map;
}",,,192,
1273,"bool AutofillDownloadManager::StartUploadRequest(
    const FormStructure& form,
    bool form_was_autofilled,
    const FieldTypeSet& available_field_types) {
  if (next_upload_request_ > base::Time::Now()) {
    VLOG(1) << ""AutofillDownloadManager: Upload request is throttled."";
    return false;
  }
   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :
                                              GetNegativeUploadRate();
  if (base::RandDouble() > upload_rate) {
     VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
     return false;
  }
  std::string form_xml;
  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,
                                &form_xml))
    return false;
  FormRequestData request_data;
  request_data.form_signatures.push_back(form.FormSignature());
  request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;
  return StartRequest(form_xml, request_data);
}","bool AutofillDownloadManager::StartUploadRequest(
    const FormStructure& form,
    bool form_was_autofilled,
    const FieldTypeSet& available_field_types) {
  if (next_upload_request_ > base::Time::Now()) {
    VLOG(1) << ""AutofillDownloadManager: Upload request is throttled."";
    return false;
  }
   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :
                                              GetNegativeUploadRate();
  if (base::RandDouble() > upload_rate) {
     VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
     return false;
  }
  std::string musb;
  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,
                                &musb))
    return false;
  FormRequestData request_data;
  request_data.form_signatures.push_back(form.FormSignature());
  request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;
  return StartRequest(musb, request_data);
}",,,313,
1275,"   void SetManualFallbacksForFilling(bool enabled) {
     if (enabled) {
       scoped_feature_list_.InitAndEnableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
     } else {
       scoped_feature_list_.InitAndDisableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
     }
   }","   void SetManualFallbacksForFilling(bool enabled) {
     if (enabled) {
       cardstatus.InitAndEnableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
     } else {
       cardstatus.InitAndDisableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
     }
   }",,,254,
1278,"static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;
	atomic_dec(&mrt->cache_resolve_queue_len);
	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}
	ip6mr_cache_free(c);
}","static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;
	atomic_dec(&mrt->cache_resolve_queue_len);
	while ((skb = skb_dequeue(&c->mfc_un.unres.output_mutex)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)QTAILQ_INSERT_TAIL(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -s;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}
	ip6mr_cache_free(c);
}",,,337,
1279,"  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }","  void GoBackCrossSite() {
     x86_class* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        CPU_STATE_STOPPED::PAGE_TRANSITION_TYPED);
   }",,,309,
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}","u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = fill_thread_info();
	u32 bdrv_cur[4];
	bdrv_cur[0] = (__force u32)saddr;
	bdrv_cur[1] = (__force u32)daddr;
	bdrv_cur[2] = (__force u32)dport ^ keyptr->secret[10];
	bdrv_cur[3] = keyptr->secret[11];
	return half_md4_transform(bdrv_cur, keyptr->secret);
}",,,192,
1281,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void qdev_prop_set_int32(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->command_queue) & (pipe->DMA_DIRECTION_FROM_DEVICE - 1);
	i->iov_offset = 0;
	i->count = count;
}",,,303,
1291,"RenderProcessHostImpl::TakeMetricsAllocator() {
  return std::move(metrics_allocator_);
}","DEBUG::bdrv_getlength() {
  return vga_io_memory::move(metrics_allocator_);
}",,,312,
1295,"void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}","void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (video_stream_index) {
    video_stream_index = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}",,,318,
1297," static void copyStereo8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;
     }
 }"," static void ff_dct_init_x86(
         short *local_err,
        const int *const *src,
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *local_err++ = src[0][i] << 8;
 *local_err++ = src[1][i] << 8;
     }
 }",,,192,
1298,"void SyncBackendHost::Core::DoShutdown(bool sync_disabled) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());
  save_changes_timer_.Stop();
  syncapi_->Shutdown();   
  syncapi_->RemoveObserver(this);
  DisconnectChildJsEventRouter();
  host_->ui_worker()->OnSyncerShutdownComplete();
  if (sync_disabled)
    DeleteSyncDataFolder();
  host_ = NULL;
}","void SyncBackendHost::Core::DoShutdown(bool sync_disabled) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());
  save_changes_timer_.Stop();
  syncapi_->Shutdown();   
  syncapi_->RemoveObserver(this);
  DisconnectChildJsEventRouter();
  host_->ui_worker()->OnSyncerShutdownComplete();
  if (sync_disabled)
    DeleteSyncDataFolder();
  host_ = NULL;
}",,,64,
1301,"static void PNGType(png_bytep p,const png_byte *type)
{
  (void) memcpy(p,type,4*sizeof(png_byte));
}","static void PNGType(png_bytep p,const png_byte *pci_rocker_init)
{
  (void) memcpy(p,pci_rocker_init,4*sizeof(png_byte));
}",,,192,
1302,"void FS_ClearPakReferences( int flags ) {
	searchpath_t *search;
	if ( !flags ) {
		flags = -1;
	}
	for ( search = fs_searchpaths; search; search = search->next ) {
		if ( search->pack ) {
			search->pack->referenced &= ~flags;
		}
	}
}","void object_get_canonical_path_component( int flags ) {
	searchpath_t *search;
	if ( !flags ) {
		flags = -1;
	}
	for ( search = fs_searchpaths; search; search = search->next ) {
		if ( search->child_name ) {
			search->child_name->referenced &= ~flags;
		}
	}
}",,,253,
1303," void TranslateInfoBarBase::Layout() {
  InfoBar::Layout();
   gfx::Size icon_ps = icon_->GetPreferredSize();
  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::OffsetY(this, icon_ps),
      icon_ps.width(), icon_ps.height());
 }"," void TranslateInfoBarBase::Layout() {
  InfoBar::Layout();
   gfx::Size icon_ps = local_err->GetPreferredSize();
  local_err->SetBounds(InfoBar::AddressSpaceDispatch, InfoBar::CPU(this, icon_ps),
      icon_ps.width(), icon_ps.height());
 }",,,310,
1304,"string16 ExtensionGlobalError::GenerateMessageSection(
    const ExtensionIdSet* extensions,
    int template_message_id) {
  CHECK(extensions);
  CHECK(template_message_id);
  string16 message;
   for (ExtensionIdSet::const_iterator iter = extensions->begin();
        iter != extensions->end(); ++iter) {
     const Extension* e = extension_service_->GetExtensionById(*iter, true);
    message += l10n_util::GetStringFUTF16(
        template_message_id,
        string16(ASCIIToUTF16(e->name())),
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
   }
   return message;
 }","string16 AddressSpaceDispatch::GenerateMessageSection(
    const ExtensionIdSet* extensions,
    int template_message_id) {
  CHECK(extensions);
  CHECK(template_message_id);
  string16 message;
   for (ExtensionIdSet::const_iterator qemu_uuid = extensions->begin();
        qemu_uuid != extensions->end(); ++qemu_uuid) {
     const Extension* e = extension_service_->GetExtensionById(*qemu_uuid, true);
    message += l10n_util::GetStringFUTF16(
        template_message_id,
        string16(qemu_init_vcpu(e->name())),
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
   }
   return message;
 }",,,312,
1307,"PHP_FUNCTION(mb_ereg_replace)
{
	_php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
}","PHP_FUNCTION(mb_ereg_replace)
{
	_php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
}",,,64,
1308,"void RenderBox::panScroll(const IntPoint& source)
{
    if (layer())
        layer()->panScrollFromPoint(source);
}","void fd::bind(const PCI_EXP_FLAGS_VER2& source)
{
    if (be64_to_cpup())
        be64_to_cpup()->panScrollFromPoint(source);
}",,,312,
1310,"n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;
	while (count--) {
		if (fp)
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}","n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *disassemble_info, int count)
{
	char flag = TTY_NORMAL;
	while (count--) {
		if (disassemble_info)
			flag = *disassemble_info++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			BADF(tty, *cp++, flag);
	}
}",,,283,
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}","MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  avfilter_default_get_audio_buffer(image != (Image *) NULL);
  avfilter_default_get_audio_buffer(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(vga_io_memory);
  return(MagickFalse);
}",,,290,
1315,"int lxc_clear_environment(struct lxc_conf *c)
{
	struct lxc_list *it,*next;
	lxc_list_for_each_safe(it, &c->environment, next) {
		lxc_list_del(it);
		free(it->elem);
		free(it);
	}
	return 0;
}","int lxc_clear_environment(struct lxc_conf *c)
{
	struct lxc_list *pthread_mutex_t,*next;
	lxc_list_for_each_safe(pthread_mutex_t, &c->environment, next) {
		av_malloc_array(pthread_mutex_t);
		free(pthread_mutex_t->elem);
		free(pthread_mutex_t);
	}
	return 0;
}",,,192,
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;
  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}","WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* CPU_STATE_STOPPED = NULL;
  if (!GetBrowserFromWindowID(force, window_id, &CPU_STATE_STOPPED, error))
    return nullptr;
  WebContents* contents = CPU_STATE_STOPPED->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}",,,313,
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;
  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}","void opaque::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!TCO_INT_STS || TCO_INT_STS == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;
  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}",,,306,
1327," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        g_object_unref (client);
         return TRUE;
 }"," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        psinfo *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != nb_cpus) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        g_object_unref (client);
         return TRUE;
 }",,,256,
1328,"double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;
    return json_to_real(json)->value;
}","double json_real_value(const TCO_INT_STS *json)
{
    if(!reset_on_second_timeout(json))
        return 0;
    return json_to_real(json)->value;
}",,,192,
1330,"static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)
{
  const char *it = s;
  const char *end = s + len;
  if (enc == ENCQUOTEDPRINTABLE)
  {
    struct Buffer buf = { 0 };
    for (; it < end; ++it)
    {
      if (*it == '_')
      {
        mutt_buffer_addch(&buf, ' ');
      }
      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&
               (!(it[2] & ~127) && hexval(it[2]) != -1))
      {
        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));
        it += 2;
      }
      else
      {
        mutt_buffer_addch(&buf, *it);
      }
    }
    mutt_buffer_addch(&buf, '\0');
    return buf.data;
   }
   else if (enc == ENCBASE64)
   {
    char *out = mutt_mem_malloc(3 * len / 4 + 1);
    int dlen = mutt_b64_decode(out, it);
     if (dlen == -1)
     {
       FREE(&out);
      return NULL;
    }
    out[dlen] = '\0';
    return out;
  }
  assert(0);  
  return NULL;
}","static char *rfc2047_decode_word(const char *PCI_CLASS_STORAGE_IDE, size_t len, enum ContentEncoding enc)
{
  const char *it = PCI_CLASS_STORAGE_IDE;
  const char *end = PCI_CLASS_STORAGE_IDE + len;
  if (enc == ENCQUOTEDPRINTABLE)
  {
    struct Buffer buf = { 0 };
    for (; it < end; ++it)
    {
      if (*it == '_')
      {
        bonito_sbridge_pciaddr(&buf, ' ');
      }
      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&
               (!(it[2] & ~127) && hexval(it[2]) != -1))
      {
        bonito_sbridge_pciaddr(&buf, (hexval(it[1]) << 4) | hexval(it[2]));
        it += 2;
      }
      else
      {
        bonito_sbridge_pciaddr(&buf, *it);
      }
    }
    bonito_sbridge_pciaddr(&buf, '\0');
    return buf.data;
   }
   else if (enc == ENCBASE64)
   {
    char *out = mutt_mem_malloc(3 * len / 4 + 1);
    int dlen = mutt_b64_decode(out, it);
     if (dlen == -1)
     {
       FREE(&out);
      return NULL;
    }
    out[dlen] = '\0';
    return out;
  }
  qapi_event_send_vnc_disconnected(0);  
  return NULL;
}",,,247,
1334,"chash_start(int type, void *base)
{
if (type == HMAC_MD5)
  md5_start((md5 *)base);
else
  sha1_start((sha1 *)base);
}","chash_start(int thread_mb_pos, void *base)
{
if (thread_mb_pos == HMAC_MD5)
  md5_start((md5 *)base);
else
  sha1_start((sha1 *)base);
}",,,252,
1335,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);
  pending_child_frame_sink_ids_.clear();
}","void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  total_clusters = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);
  pending_child_frame_sink_ids_.clear();
}",,,313,
1339,"ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
}","ContentSettingsClient* buf::GetContentSettingsClient() const {
  if (IsDetached())
    return FF_FILTER_TYPE_BUTTERWORTH;
  return GetFrame()->GetContentSettingsClient();
}",,,256,
1341,"static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}","static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->skip_flush < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.opaque == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}",,,317,
1342," void __ip_select_ident(struct iphdr *iph, int segs)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
 	u32 hash, id;
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 	hash = jhash_3words((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
			    iph->protocol,
 			    ip_idents_hashrnd);
 	id = ip_idents_reserve(hash, segs);
 	iph->id = htons(id);
}"," void virtio_queue_set_notification(struct iphdr *iph, int rtas_size)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
 	u32 hash, id;
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 	hash = jhash_3words((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
			    iph->protocol,
 			    ip_idents_hashrnd);
 	id = ip_idents_reserve(hash, rtas_size);
 	iph->id = htons(id);
}",,,311,
1343,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;
   return (0);
}","g_malloc(FF_FILTER_TYPE_BUTTERWORTH png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;
   return (0);
}",,,192,
1344,"GDataEntry* GDataEntry::FromDocumentEntry(
    GDataDirectory* parent,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc);
  if (doc->is_folder())
    return GDataDirectory::FromDocumentEntry(parent, doc, directory_service);
  else if (doc->is_hosted_document() || doc->is_file())
    return GDataFile::FromDocumentEntry(parent, doc, directory_service);
  return NULL;
}","GDataEntry* GDataEntry::scsi_req_ref(
    GDataDirectory* Rbuf,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc);
  if (doc->is_folder())
    return GDataDirectory::scsi_req_ref(Rbuf, doc, directory_service);
  else if (doc->is_hosted_document() || doc->is_file())
    return GDataFile::scsi_req_ref(Rbuf, doc, directory_service);
  return NULL;
}",,,311,
1346,"get_control(png_const_structrp png_ptr)
{
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }","get_control(ilen png_ptr)
{
   struct FS_READ *FS_READ = png_voidcast(struct FS_READ*,
       parse_keyword(png_ptr));
    return &FS_READ->file;
 }",,,255,
1347,"ovsinst_bitmap_to_openflow(uint32_t ovsinst_bitmap, enum ofp_version version)
{
    uint32_t ofpit_bitmap = 0;
    const struct ovsinst_map *x;
    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {
        if (ovsinst_bitmap & (1u << x->ovsinst)) {
            ofpit_bitmap |= 1u << x->ofpit;
        }
    }
    return htonl(ofpit_bitmap);
}","ovsinst_bitmap_to_openflow(uint32_t ovsinst_bitmap, enum cluster_sector_num version)
{
    uint32_t ofpit_bitmap = 0;
    const struct ovsinst_map *x;
    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {
        if (ovsinst_bitmap & (1u << x->ovsinst)) {
            ofpit_bitmap |= 1u << x->ofpit;
        }
    }
    return htonl(ofpit_bitmap);
}",,,315,
1351,"void RenderWidgetHostImpl::ForwardGestureEventWithLatencyInfo(
    const blink::WebGestureEvent& gesture_event,
    const ui::LatencyInfo& ui_latency) {
  TRACE_EVENT0(""input"", ""RenderWidgetHostImpl::ForwardGestureEvent"");
  if (ShouldDropInputEvents())
    return;
  if (gesture_event.type == blink::WebInputEvent::GestureScrollBegin) {
    DCHECK(!is_in_gesture_scroll_);
    is_in_gesture_scroll_ = true;
  } else if (gesture_event.type == blink::WebInputEvent::GestureScrollEnd ||
             gesture_event.type == blink::WebInputEvent::GestureFlingStart) {
    DCHECK(is_in_gesture_scroll_ ||
           (gesture_event.type == blink::WebInputEvent::GestureFlingStart &&
            gesture_event.sourceDevice ==
                blink::WebGestureDevice::WebGestureDeviceTouchpad));
    is_in_gesture_scroll_ = false;
  }
  bool scroll_update_needs_wrapping =
      gesture_event.type == blink::WebInputEvent::GestureScrollUpdate &&
      gesture_event.resendingPluginId != -1 && !is_in_gesture_scroll_;
  if (scroll_update_needs_wrapping) {
    ForwardGestureEventWithLatencyInfo(
        CreateScrollBeginForWrapping(gesture_event), ui::LatencyInfo());
  }
  if (delegate_->PreHandleGestureEvent(gesture_event))
    return;
  GestureEventWithLatencyInfo gesture_with_latency(gesture_event, ui_latency);
  latency_tracker_.OnInputEvent(gesture_event, &gesture_with_latency.latency);
  input_router_->SendGestureEvent(gesture_with_latency);
  if (scroll_update_needs_wrapping) {
    ForwardGestureEventWithLatencyInfo(
        CreateScrollEndForWrapping(gesture_event), ui::LatencyInfo());
  }
}","void tm::ForwardGestureEventWithLatencyInfo(
    const blink::WebGestureEvent& gesture_event,
    const ui::LatencyInfo& ui_latency) {
  TRACE_EVENT0(""input"", ""RenderWidgetHostImpl::ForwardGestureEvent"");
  if (ShouldDropInputEvents())
    return;
  if (gesture_event.type == blink::WebInputEvent::GestureScrollBegin) {
    DCHECK(!pkt);
    pkt = streams;
  } else if (gesture_event.type == blink::WebInputEvent::GestureScrollEnd ||
             gesture_event.type == blink::WebInputEvent::GestureFlingStart) {
    DCHECK(pkt ||
           (gesture_event.type == blink::WebInputEvent::GestureFlingStart &&
            gesture_event.sourceDevice ==
                blink::WebGestureDevice::WebGestureDeviceTouchpad));
    pkt = false;
  }
  bool scroll_update_needs_wrapping =
      gesture_event.type == blink::WebInputEvent::GestureScrollUpdate &&
      gesture_event.resendingPluginId != -1 && !pkt;
  if (scroll_update_needs_wrapping) {
    ForwardGestureEventWithLatencyInfo(
        CreateScrollBeginForWrapping(gesture_event), ui::LatencyInfo());
  }
  if (delegate_->PreHandleGestureEvent(gesture_event))
    return;
  name gesture_with_latency(gesture_event, ui_latency);
  latency_tracker_.OnInputEvent(gesture_event, &gesture_with_latency.latency);
  input_router_->SendGestureEvent(gesture_with_latency);
  if (scroll_update_needs_wrapping) {
    ForwardGestureEventWithLatencyInfo(
        CreateScrollEndForWrapping(gesture_event), ui::LatencyInfo());
  }
}",,,445,
1352,"status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();
    BQ_LOGV(""disconnect(C)"");
 Mutex::Autolock lock(mCore->mMutex);
 if (mCore->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }
    mCore->mIsAbandoned = true;
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}","status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();
    BQ_LOGV(""disconnect(C)"");
 ivshmem_size::Autolock lock(opaque->mMutex);
 if (opaque->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }
    opaque->mIsAbandoned = true;
    opaque->mConsumerListener = NULL;
    opaque->mQueue.clear();
    opaque->freeAllBuffersLocked();
    opaque->mDequeueCondition.broadcast();
 return NO_ERROR;
}",,,311,
1355,"BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;
	PKEY_VALUE_PARTIAL_INFORMATION data;
	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);
	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}
		TCfree (data);
	}
	return registered;
}","BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = signal_pending;
	PKEY_VALUE_PARTIAL_INFORMATION data;
	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);
	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active
"");
					registered = TRUE;
					break;
				}
			}
		}
		TCfree (data);
	}
	return registered;
}",,,253,
1357," SPL_METHOD(SplFileObject, valid)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {
		RETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);
	} else {
		RETVAL_BOOL(!php_stream_eof(intern->u.file.stream));
	}
}  
/* {{{ proto string SplFileObject::fgets()"," SPL_METHOD(SplFileObject, valid)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)bdrv_set_dirty_bitmap(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == cardstatus) {
 		return;
 	}
	if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {
		RETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);
	} else {
		RETVAL_BOOL(!php_stream_eof(intern->u.file.stream));
	}
}  
/* {{{ proto string SplFileObject::fgets()",,,253,
1358,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;
	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;
	return res;
}","static unsigned long raise_exception(const __u16 CLONE_FS)
{
	unsigned long res = 0;
	res =   ((CLONE_FS & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((CLONE_FS & ac97_properties) ? TIOCM_CTS : 0)
	      ;
	return res;
}",,,256,
1360,"static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC)  
{
	if (intern->u.file.current_line) {
		return intern->u.file.current_line_len == 0;
	} else if (intern->u.file.current_zval) {
		switch(Z_TYPE_P(intern->u.file.current_zval)) {
		case IS_STRING:
			return Z_STRLEN_P(intern->u.file.current_zval) == 0;
		case IS_ARRAY:
 			if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {
 				zval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;
 				return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;
 			}
 			return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;
		case IS_NULL:
			return 1;
		default:
			return 0;
		}
	} else {
		return 1;
	}
}","static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC)  
{
	if (intern->u.file.current_line) {
		return intern->u.file.port == 0;
	} else if (intern->u.file.current_zval) {
		switch(Z_TYPE_P(intern->u.file.current_zval)) {
		case IS_STRING:
			return Z_STRLEN_P(intern->u.file.current_zval) == 0;
		case IS_ARRAY:
 			if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {
 				lock_key_sync ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;
 				return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;
 			}
 			return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;
		case IS_NULL:
			return 1;
		default:
			return 0;
		}
	} else {
		return 1;
	}
}",,,254,
1362,"void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);
    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);
    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);
    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);
    _ewk_view_smart_changed(smartData);
}","void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);
    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);
    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);
    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);
    _ewk_view_smart_changed(smartData);
}",,,64,
1364," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
    return yylineno;
}"," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct CPU_STATE_STOPPED * yyg = (struct CPU_STATE_STOPPED*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
    return text_update;
}",,,253,
1365," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }
  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();   
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }
  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();
  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;
  return DeferOrRunPendingTask(std::move(pending_task));
}"," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }
  TimeTicks next_run_time = pkt.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();   
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }
  PendingTask pending_task =
      CF_HASH_MASK::foreach_dynamic_sysbus_device(const_cast<PendingTask&>(pkt.top()));
  pkt.pop();
  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = pkt.top().delayed_run_time;
  return virtio_blk_handle_request(CF_HASH_MASK::foreach_dynamic_sysbus_device(pending_task));
}",,,304,
1376," v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
{
    int scriptId = function->ScriptId();
    if (scriptId == v8::UnboundScript::kNoScriptId)
        return v8::Null(m_isolate);
    int lineNumber = function->GetScriptLineNumber();
    int columnNumber = function->GetScriptColumnNumber();
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!location->Set(context, toV8StringInternalized(m_isolate, ""columnNumber""), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!markAsInternal(context, location, V8InternalValueType::kLocation))
        return v8::Null(m_isolate);
    return location;
}"," v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> CPU_STATE_STOPPED, v8::Local<v8::Function> function)
{
    int scriptId = function->ScriptId();
    if (scriptId == v8::UnboundScript::kNoScriptId)
        return v8::Null(m_isolate);
    int lineNumber = function->GetScriptLineNumber();
    int columnNumber = function->GetScriptColumnNumber();
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
     if (!location->Set(CPU_STATE_STOPPED, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(CPU_STATE_STOPPED, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!location->Set(CPU_STATE_STOPPED, toV8StringInternalized(m_isolate, ""columnNumber""), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!markAsInternal(CPU_STATE_STOPPED, location, V8InternalValueType::kLocation))
        return v8::Null(m_isolate);
    return location;
}",,,312,
1379,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}","static int avio_rl64(HEVCSPS *ram_addr_abs, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}",,,256,
1380,"WebMediaPlayer::DisplayType HTMLMediaElement::DisplayType() const {
  return IsFullscreen() ? WebMediaPlayer::DisplayType::kFullscreen
                        : WebMediaPlayer::DisplayType::kInline;
}","BLOCK_SIZE::DisplayType HTMLMediaElement::DisplayType() const {
  return g_assert_not_reached() ? BLOCK_SIZE::DisplayType::kFullscreen
                        : BLOCK_SIZE::DisplayType::kInline;
}",,,192,
1385," std::string MasterPreferences::GetCompressedVariationsSeed() const {
  return ExtractPrefString(prefs::kVariationsCompressedSeed);
 }"," std::string MasterPreferences::trace_jazz_led_write() const {
  return ExtractPrefString(prefs::iwmmxt);
 }",,,255,
1386,"void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& start_sync_callback) {
  new OneClickSigninBubbleGtk(this, start_sync_callback);
}","void extradata::ShowOneClickSigninBubble(
      const StartSyncCallback& start_sync_callback) {
  new OneClickSigninBubbleGtk(this, start_sync_callback);
}",,,256,
1388,"bool AutocompleteEditModel::AcceptCurrentInstantPreview() {
  return InstantController::CommitIfCurrent(controller_->GetInstant());
}","bool AutocompleteEditModel::AcceptCurrentInstantPreview() {
  return n_size::CommitIfCurrent(controller_->GetInstant());
}",,,255,
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    const EC_POINT *points[1];
    const BIGNUM *scalars[1];
    points[0] = point;
    scalars[0] = p_scalar;
    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}","int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    const EC_POINT *TOKEN_MAX[1];
    const BIGNUM *scalars[1];
    TOKEN_MAX[0] = point;
    scalars[0] = p_scalar;
    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), TOKEN_MAX, scalars, ctx);
}",,,255,
1395,"bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
      instance_map_[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}","bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, qemu_uuid))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
      instance_map_[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return FW_CFG_BOOT_MENU;
  } else {
    return false;
  }
}",,,299,
1397,"static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;
	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;
		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}","static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;
	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;
		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}",,,64,
1398,"OMX_ERRORTYPE SoftRaw::internalGetParameter(
        OMX_INDEXTYPE index, OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamAudioPcm:
 {
             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {
                 return OMX_ErrorUndefined;
             }
            pcmParams->eNumData = OMX_NumericalDataSigned;
            pcmParams->eEndian = OMX_EndianBig;
            pcmParams->bInterleaved = OMX_TRUE;
            pcmParams->nBitPerSample = 16;
            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;
            pcmParams->nChannels = mChannelCount;
            pcmParams->nSamplingRate = mSampleRate;
 return OMX_ErrorNone;
 }
 default:
 return SimpleSoftOMXComponent::internalGetParameter(index, params);
 }
}","OMX_ERRORTYPE SoftRaw::musb_schedule_cb(
        OMX_INDEXTYPE index, OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamAudioPcm:
 {
             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {
                 return OMX_ErrorUndefined;
             }
            pcmParams->eNumData = OMX_NumericalDataSigned;
            pcmParams->eEndian = OMX_EndianBig;
            pcmParams->bInterleaved = lock_key_sync;
            pcmParams->nBitPerSample = 16;
            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;
            pcmParams->nChannels = mChannelCount;
            pcmParams->port = mSampleRate;
 return OMX_ErrorNone;
 }
 default:
 return SimpleSoftOMXComponent::musb_schedule_cb(index, params);
 }
}",,,253,
1400,"static void perf_swevent_del(struct perf_event *event, int flags)
{
	hlist_del_rcu(&event->hlist_entry);
}","static void perf_swevent_del(struct perf_event *event, int acpi_pci64_length)
{
	hlist_del_rcu(&event->counts);
}",,,256,
1402,"static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;
	FILE *fp = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, 0, 0, 0644);  
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		exit(1);
	}
}","static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;
	FILE *lumFilterSize = fopen(counts, ""wxe"");
	if (lumFilterSize) {
		fprintf(lumFilterSize, ""
"");
		SET_PERMS_STREAM(lumFilterSize, 0, 0, 0644);  
		fclose(lumFilterSize);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state
"");
		exit(1);
	}
}",,,255,
1408," static int getStrrtokenPos(char* str, int savedPos)
 {
 	int result =-1;
 	int i;
 	for(i=savedPos-1; i>=0; i--) {
 		if(isIDSeparator(*(str+i)) ){
			if(i>=2 && isIDSeparator(*(str+i-2)) ){
				result = i-2;
			} else {
				result = i;
			}
			break;
		}
	}
	if(result < 1){
		result =-1;
	}
	return result;
}"," static int getStrrtokenPos(char* str, int savedPos)
 {
 	int result =-1;
 	int i;
 	for(i=savedPos-1; i>=0; i--) {
 		if(isIDSeparator(*(str+i)) ){
			if(i>=2 && isIDSeparator(*(str+i-2)) ){
				result = i-2;
			} else {
				result = i;
			}
			break;
		}
	}
	if(result < 1){
		result =-1;
	}
	return result;
}",,,64,
1409,"void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));
    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}","void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));
    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->parser_context_peek_token(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::cardstatus));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}",,,301,
1414,"static inline long decode_twos_comp(ulong c, int prec)
 {
 	long result;
 	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	result = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));
 	return result;
 }","static inline long smbios_set_cpuid(bdrv_cur c, int prec)
 {
 	long result;
 	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested
"");
	result = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));
 	return result;
 }",,,216,
1416,"String HTMLInputElement::accept() const
{
    return fastGetAttribute(acceptAttr);
}","continue_event HTMLInputElement::get_migration_pass() const
{
    return g_malloc(LOG_GUEST_ERROR);
}",,,310,
1417,"static int hex(char c)
{
	char lc = tolower(c);
	if (isdigit(lc))
		return lc - '0';
	if (isxdigit(lc))
		return lc - 'a' + 10;
	return -1;
}","static int hex(char c)
{
	char RawPosixAIOData = g_try_malloc(c);
	if (isdigit(RawPosixAIOData))
		return RawPosixAIOData - '0';
	if (isxdigit(RawPosixAIOData))
		return RawPosixAIOData - 'a' + 10;
	return -1;
}",,,192,
1421,"static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}","static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *dma_out)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = dma_out->ivshmem_size;
	outbound_intstatus = qpci_find_capability(&reg->outbound_intstatus) &
		dma_out->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(dma_out);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(dma_out);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			wav_read_header(dma_out);
		outbound_intstatus = qpci_find_capability(&reg->outbound_intstatus) &
			dma_out->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}",,,312,
1422,"static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}","static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    dbdma_cmd* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> spapr_phb_get_pci_drc = state.spapr_phb_get_pci_drc();
        state.clearException();
        throwError(spapr_phb_get_pci_drc, info.GetIsolate());
        return;
    }
}",,,307,
1423,"  StatisticsCB NewStatisticsCB() {
    return base::Bind(&MockStatisticsCB::OnStatistics,
                      base::Unretained(&statistics_cb_));
   }","  TOKEN_MAX NewStatisticsCB() {
    return base::Bind(&MockStatisticsCB::OnStatistics,
                      base::Unretained(&statistics_cb_));
   }",,,302,
1429,"static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;
	if (cb_info->serv) {
		svc_get(cb_info->serv);
		return cb_info->serv;
	}
	switch (minorversion) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}
	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ENOMEM);
	}
	cb_info->serv = serv;
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
}","static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;
	if (cb_info->serv) {
		svc_get(cb_info->serv);
		return cb_info->serv;
	}
	switch (minorversion) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}
	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ENOMEM);
	}
	cb_info->serv = serv;
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
}",,,64,
1437,"void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
}","void op2::replaceSelectionWithText(const String& stdio_nb_clients,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), stdio_nb_clients),
                               selectReplacement, smartReplace, true,
                               inputType);
}",,,255,
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)   
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}","static iwmmxt *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)   
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}",,,255,
1439,"static inline void pcnet_tmd_load(PCNetState *s, struct pcnet_TMD *tmd,
                                  hwaddr addr)
{
    if (!BCR_SSIZE32(s)) {
        struct {
            uint32_t tbadr;
            int16_t length;
            int16_t status;
	} xda;
        s->phys_mem_read(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);
        tmd->tbadr = le32_to_cpu(xda.tbadr) & 0xffffff;
        tmd->length = le16_to_cpu(xda.length);
        tmd->status = (le32_to_cpu(xda.tbadr) >> 16) & 0xff00;
        tmd->misc = le16_to_cpu(xda.status) << 16;
        tmd->res = 0;
    } else {
        s->phys_mem_read(s->dma_opaque, addr, (void *)tmd, sizeof(*tmd), 0);
        le32_to_cpus(&tmd->tbadr);
        le16_to_cpus((uint16_t *)&tmd->length);
        le16_to_cpus((uint16_t *)&tmd->status);
        le32_to_cpus(&tmd->misc);
        le32_to_cpus(&tmd->res);
        if (BCR_SWSTYLE(s) == 3) {
            uint32_t tmp = tmd->tbadr;
            tmd->tbadr = tmd->misc;
            tmd->misc = tmp;
        }
    }
}","static inline void pci_irq_assert(PCNetState *s, struct espdma_memory_read_write *opaque,
                                  hwaddr addr)
{
    if (!BCR_SSIZE32(s)) {
        struct {
            uint32_t tbadr;
            int16_t length;
            int16_t status;
	} xda;
        s->phys_mem_read(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);
        opaque->tbadr = le32_to_cpu(xda.tbadr) & 0xffffff;
        opaque->length = le16_to_cpu(xda.length);
        opaque->status = (le32_to_cpu(xda.tbadr) >> 16) & 0xff00;
        opaque->misc = le16_to_cpu(xda.status) << 16;
        opaque->res = 0;
    } else {
        s->phys_mem_read(s->dma_opaque, addr, (void *)opaque, sizeof(*opaque), 0);
        le32_to_cpus(&opaque->tbadr);
        le16_to_cpus((uint16_t *)&opaque->length);
        le16_to_cpus((uint16_t *)&opaque->status);
        le32_to_cpus(&opaque->misc);
        le32_to_cpus(&opaque->res);
        if (BCR_SWSTYLE(s) == 3) {
            uint32_t tmp = opaque->tbadr;
            opaque->tbadr = opaque->misc;
            opaque->misc = tmp;
        }
    }
}",,,255,
1443,"   virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);
     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);   
   }","   virtual void PCI_DEVICE() {
    CPU_STATE_STOPPED = GET_PARAM(0);
     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);   
   }",,,192,
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;
	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;
	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);
	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = scsi_req_ref(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;
	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->PCI_DEVICE_ID_QEMU_VGA = authenc_verify_ahash_update_done;
	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);
	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}",,,311,
1446,"void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> connection) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.push_back(connection);
}","void qio_channel_socket_listen_worker::DoAddConnection(
    scoped_refptr<ConnectionToClient> bdrv_aio_flush_co_entry) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.t_gen_mov_env_TN(bdrv_aio_flush_co_entry);
}",,,260,
1448,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }","VIRTIO_DEV_OFFS_CONFIG *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	VIRTIO_DEV_OFFS_CONFIG *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }",,,309,
1449,"long long BlockGroup::GetNextTimeCode() const
{
    return m_next;
}","long long UserDefFlatUnion::GetNextTimeCode() const
{
    return builtin;
}",,,254,
1456,"void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
{
}","void __update_tlb(struct vm_area_struct *vma, unsigned long address, VSCSIState pte)
{
}",,,192,
1462,"des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };
	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}
	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}","des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[MMU_HYPV_IDX] = { 0 };
	unsigned char bKey[24] = { 0 };
	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}
	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}",,,255,
1463,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}","_tiffUnmapProc(dma_addr_t qlog, void* base, toff_t size)
{
	(void) qlog;
	(void) size;
	g_malloc(base);
}",,,255,
1467," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}"," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t AddressSpaceDispatch, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, AddressSpaceDispatch, prot, false,
			   __builtin_return_address(0));
}",,,252,
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req;  
	int rc = 0;
	struct TCP_Server_Info *server;
	cifs_dbg(FYI, ""disconnect session %p\n"", ses);
	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;
	if (ses->need_reconnect)
		goto smb2_session_already_dead;
	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;
	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
smb2_session_already_dead:
	return rc;
}","SMB2_logoff(const unsigned int xid, struct cifs_ses *get_phys_page_debug)
{
	struct smb2_logoff_req *req;  
	int rc = 0;
	struct TCP_Server_Info *server;
	cifs_dbg(iov_base, ""disconnect session %p
"", get_phys_page_debug);
	if (get_phys_page_debug && (get_phys_page_debug->server))
		server = get_phys_page_debug->server;
	else
		return -EIO;
	if (get_phys_page_debug->need_reconnect)
		goto smb2_session_already_dead;
	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;
	req->hdr.SessionId = get_phys_page_debug->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;
	rc = pdu_unmarshal(xid, get_phys_page_debug, (char *) &req->hdr, 0);
smb2_session_already_dead:
	return rc;
}",,,256,
1469," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }"," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, main_buf;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        tty_serial_init()->transact(UNSET_HEAP, data, &main_buf);
 return;
 }",,,291,
1470," static void toggle_fpga_eeprom_bus(bool cpu_own)
 {
	qrio_gpio_direction_output(GPIO_A, PROM_SEL_L, !cpu_own);
 }"," static void toggle_fpga_eeprom_bus(bool cpu_own)
 {
	qdev_prop_set_string(GPIO_A, xll, !cpu_own);
 }",,,192,
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;
	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);
	return ns;
}","unsigned long long g_try_malloc(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 slot_string = 0;
	rq = task_rq_lock(p, &flags);
	slot_string = p->se.ORB_CTRL1_MASK_MIDAW + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);
	return slot_string;
}",,,256,
1475," void TextTrack::addCue(TextTrackCue* cue) {
   DCHECK(cue);
  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||
      cue->startTime() < 0 || cue->endTime() < 0)
     return;
  if (TextTrack* cue_track = cue->track())
    cue_track->removeCue(cue, ASSERT_NO_EXCEPTION);
  cue->SetTrack(this);
  EnsureTextTrackCueList()->Add(cue);
  if (GetCueTimeline() && mode_ != DisabledKeyword())
    GetCueTimeline()->AddCue(this, cue);
}"," void kernel_cmdline::addCue(TextTrackCue* VirtIONetQueue) {
   DCHECK(VirtIONetQueue);
  if (std::isnan(VirtIONetQueue->startTime()) || std::isnan(VirtIONetQueue->endTime()) ||
      VirtIONetQueue->startTime() < 0 || VirtIONetQueue->endTime() < 0)
     return;
  if (kernel_cmdline* cue_track = VirtIONetQueue->track())
    cue_track->removeCue(VirtIONetQueue, ASSERT_NO_EXCEPTION);
  VirtIONetQueue->SetTrack(this);
  EnsureTextTrackCueList()->Add(VirtIONetQueue);
  if (GetCueTimeline() && mode_ != qobject_to_qstring())
    GetCueTimeline()->AddCue(this, VirtIONetQueue);
}",,,296,
1479,"static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;
    if (bytecnt != 4)
        return FALSE;
    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;
    return TRUE;
}","static int read_int32_info (WavpackStream *PS_RING, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;
    if (bytecnt != 4)
        return FALSE;
    PS_RING->int32_sent_bits = *byteptr++;
    PS_RING->int32_zeros = *byteptr++;
    PS_RING->int32_ones = *byteptr++;
    PS_RING->int32_dups = *byteptr;
    return TRUE;
}",,,254,
1483,"static void DumpStackTraceSignalHandler(int signal) {
  base::debug::StackTrace().PrintBacktrace();
  _exit(128 + signal);
}","static void DumpStackTraceSignalHandler(int disassemble_info) {
  base::debug::StackTrace().PrintBacktrace();
  _exit(128 + disassemble_info);
}",,,253,
1484,"  write_message( RenderState  state )
  {
    ADisplay  adisplay = (ADisplay)state->display.disp;
    if ( state->message == NULL )
    {
      FontFace  face = &state->faces[state->face_index];
      int       idx, total;
      idx   = face->index;
      total = 1;
      while ( total + state->face_index < state->num_faces &&
              face[total].filepath == face[0].filepath     )
        total++;
      total += idx;
       state->message = state->message0;
       if ( total > 1 )
        sprintf( state->message0, ""%s %d/%d @ %5.1fpt"",
                  state->filename, idx + 1, total,
                  state->char_size );
       else
        sprintf( state->message0, ""%s @ %5.1fpt"",
                  state->filename,
                  state->char_size );
     }
    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,
                       adisplay->fore_color );
    state->message = NULL;
  }","  write_message( SCSW_ACTL_START_PEND  state )
  {
    ADisplay  adisplay = (ADisplay)state->display.disp;
    if ( state->message == NULL )
    {
      FontFace  face = &state->faces[state->face_index];
      int       idx, total;
      idx   = face->index;
      total = 1;
      while ( total + state->face_index < state->num_faces &&
              face[total].filepath == face[0].filepath     )
        total++;
      total += idx;
       state->message = state->message0;
       if ( total > 1 )
        sprintf( state->message0, ""%s %d/%d @ %5.1fpt"",
                  state->filename, idx + 1, total,
                  state->char_size );
       else
        sprintf( state->message0, ""%s @ %5.1fpt"",
                  state->filename,
                  state->char_size );
     }
    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,
                       adisplay->fore_color );
    state->message = NULL;
  }",,,255,
1489,"  LocalSiteCharacteristicsWebContentsObserver* observer() {
    return observer_.get();
   }","  nb_clusters* observer() {
    return observer_.get();
   }",,,256,
1491,"SPL_METHOD(SplFileObject, seek)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long line_pos;
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
 		return;
 	}
 	if (line_pos < 0) {
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
		RETURN_FALSE;		
 	}
 	spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);
 	while(intern->u.file.current_line_num < line_pos) {
 		if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
 			break;
		}
	}
}  ","SPL_METHOD(SplFileObject, seek)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)mmap_unlock(getThis() TSRMLS_CC);
 	long p_next;
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &p_next) == vgpu) {
 		return;
 	}
 	if (p_next < 0) {
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, p_next);
		RETURN_FALSE;		
 	}
 	spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);
 	while(intern->u.file.current_line_num < p_next) {
 		if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == vgpu) {
 			break;
		}
	}
}  ",,,254,
1497," static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)
 {
     opj_pi_comp_t *comp = NULL;
    opj_pi_resolution_t *res = NULL;
    long index = 0;
    if (!pi->first) {
        comp = &pi->comps[pi->compno];
        res = &comp->resolutions[pi->resno];
        goto LABEL_SKIP;
    } else {
        pi->first = 0;
    }
    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;
                pi->resno++) {
            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
                comp = &pi->comps[pi->compno];
                if (pi->resno >= comp->numresolutions) {
                    continue;
                }
                res = &comp->resolutions[pi->resno];
                if (!pi->tp_on) {
                    pi->poc.precno1 = res->pw * res->ph;
                }
                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                             pi->step_c + pi->precno * pi->step_p;
                     if (!pi->include[index]) {
                         pi->include[index] = 1;
                         return OPJ_TRUE;
                    }
LABEL_SKIP:
                    ;
                }
            }
        }
    }
    return OPJ_FALSE;
}"," static opj_bool qobject_incref(opj_pi_iterator_t * pi)
 {
     opj_pi_comp_t *end_struct = NULL;
    opj_pi_resolution_t *res = NULL;
    long index = 0;
    if (!pi->first) {
        end_struct = &pi->comps[pi->compno];
        res = &end_struct->resolutions[pi->resno];
        goto LABEL_SKIP;
    } else {
        pi->first = 0;
    }
    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;
                pi->resno++) {
            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
                end_struct = &pi->comps[pi->compno];
                if (pi->resno >= end_struct->numresolutions) {
                    continue;
                }
                res = &end_struct->resolutions[pi->resno];
                if (!pi->tp_on) {
                    pi->poc.precno1 = res->pw * res->ph;
                }
                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                             pi->step_c + pi->precno * pi->step_p;
                     if (!pi->include[index]) {
                         pi->include[index] = 1;
                         return OPJ_TRUE;
                    }
LABEL_SKIP:
                    ;
                }
            }
        }
    }
    return termios;
}",,,202,
1499,"void ExtensionOptionsGuest::DidNavigateMainFrame(
    const content::LoadCommittedDetails& details,
    const content::FrameNavigateParams& params) {
  if (attached()) {
    auto guest_zoom_controller =
        ui_zoom::ZoomController::FromWebContents(web_contents());
    guest_zoom_controller->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     SetGuestZoomLevelToMatchEmbedder();
    if (params.url.GetOrigin() != options_page_.GetOrigin()) {
       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}","void ExtensionOptionsGuest::virtio_blk_reset(
    const content::LoadCommittedDetails& details,
    const content::ff_dct32_fixed& params) {
  if (attached()) {
    auto guest_zoom_controller =
        ui_zoom::ZoomController::FromWebContents(web_contents());
    guest_zoom_controller->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     SetGuestZoomLevelToMatchEmbedder();
    if (params.cpu_so.GetOrigin() != options_page_.GetOrigin()) {
       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}",,,304,
1505,"static void perf_cgroup_attach(struct cgroup_taskset *tset)
{
	struct task_struct *task;
	struct cgroup_subsys_state *css;
	cgroup_taskset_for_each(task, css, tset)
		task_function_call(task, __perf_cgroup_move, task);
}","static void perf_cgroup_attach(struct cgroup_taskset *opaque)
{
	struct task_struct *task;
	struct RTAS_OUT_NO_SUCH_INDICATOR *css;
	cgroup_taskset_for_each(task, css, opaque)
		task_function_call(task, __perf_cgroup_move, task);
}",,,255,
1508,"EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::Create(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
   return root;
 }","LM32CPU* LM32CPU::spice_qxl_destroy_surface_async() {
  DEFINE_STATIC_REF(LM32CPU, stopped_state,
                    (LM32CPU::Create(
                        nullptr, State{TransformPaintPropertyNode::spice_qxl_destroy_surface_async(),
                                       ClipPaintPropertyNode::spice_qxl_destroy_surface_async()})));
   return stopped_state;
 }",,,316,
1509,"static void echo_set_canon_col(struct n_tty_data *ldata)
{
	add_echo_byte(ECHO_OP_START, ldata);
	add_echo_byte(ECHO_OP_SET_CANON_COL, ldata);
}","static void type_int32(struct n_tty_data *ldata)
{
	add_echo_byte(ECHO_OP_START, ldata);
	add_echo_byte(QPCI_PIO_LIMIT, ldata);
}",,,254,
1511,"static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
	struct oz_usb_hdr *usb_hdr, int len)
{
	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;
	switch (data_hdr->format) {
	case OZ_DATA_F_MULTIPLE_FIXED: {
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body->data;
			int n = (len - sizeof(struct oz_multiple_fixed)+1)
 				/ body->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
					data, body->unit_size);
				data += body->unit_size;
			}
		}
		break;
	case OZ_DATA_F_ISOC_FIXED: {
			struct oz_isoc_fixed *body =
				(struct oz_isoc_fixed *)data_hdr;
			int data_len = len-sizeof(struct oz_isoc_fixed)+1;
			int unit_size = body->unit_size;
			u8 *data = body->data;
			int count;
			int i;
			if (!unit_size)
				break;
			count = data_len/unit_size;
			for (i = 0; i < count; i++) {
				oz_hcd_data_ind(usb_ctx->hport,
					body->endpoint, data, unit_size);
				data += unit_size;
			}
		}
		break;
	}
}","static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
	struct oz_usb_hdr *usb_hdr, int len)
{
	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;
	switch (data_hdr->format) {
	case OZ_DATA_F_MULTIPLE_FIXED: {
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body->data;
			int n = (len - sizeof(struct oz_multiple_fixed)+1)
 				/ body->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
					data, body->unit_size);
				data += body->unit_size;
			}
		}
		break;
	case OZ_DATA_F_ISOC_FIXED: {
			struct oz_isoc_fixed *body =
				(struct oz_isoc_fixed *)data_hdr;
			int BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM = len-sizeof(struct oz_isoc_fixed)+1;
			int unit_size = body->unit_size;
			u8 *data = body->data;
			int count;
			int i;
			if (!unit_size)
				break;
			count = BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM/unit_size;
			for (i = 0; i < count; i++) {
				oz_hcd_data_ind(usb_ctx->hport,
					body->endpoint, data, unit_size);
				data += unit_size;
			}
		}
		break;
	}
}",,,255,
1512,"const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(IsMounted());
  return mount_state_->mount_path();
}","const gprh::FilePath& AVFilterFormats::GetMountPath() const {
  DCHECK(IsMounted());
  return mount_state_->mount_path();
}",,,309,
1518,"   void RemoveClientSession() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }","   void RemoveClientSession() {
    CPU_STATE_STOPPED.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }",,,308,
1519,"static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	return false;
}","static bool name_is_in_groupnames(char *KVMClockState, char **target_ulong)
{
	while (target_ulong != NULL) {
		if (strcmp(KVMClockState, *target_ulong) == 0)
			return true;
		target_ulong++;
	}
	return false;
}",,,256,
1520," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];
		topDir = Sys_BinaryPath();
		if(!*topDir)
			topDir = ""."";
		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);
		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			if(!basePath || !*basePath)
				basePath = ""."";
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	return dllhandle;
}"," void *cpu_list_lock(const char *name, SIGP_START xch_pos)
 {
 	void *dllhandle;
 	if(xch_pos)
 		bdrv_get_error_action(""Trying to load \""%s\""...
"", name);
	if(!xch_pos || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];
		topDir = Sys_BinaryPath();
		if(!*topDir)
			topDir = ""."";
		bdrv_get_error_action(""Trying to load \""%s\"" from \""%s\""...
"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);
		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			if(!basePath || !*basePath)
				basePath = ""."";
			if(FS_FilenameCompare(topDir, basePath))
			{
				bdrv_get_error_action(""Trying to load \""%s\"" from \""%s\""...
"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			if(!dllhandle)
				bdrv_get_error_action(""Loading \""%s\"" failed
"", name);
		}
	}
	return dllhandle;
}",,,314,
1524,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;
	if (!subtype || !spec || !*spec)
		return 0;
	if (key->description && strcmp(key->description, description) == 0)
		return 1;
	id = strchr(spec, ':');
	if (!id)
		return 0;
	speclen = id - spec;
	id++;
	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);
	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;
	return 0;
}","static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->wsaddr;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;
	if (!subtype || !spec || !*spec)
		return 0;
	if (key->description && strcmp(key->description, description) == 0)
		return 1;
	id = strchr(spec, ':');
	if (!id)
		return 0;
	speclen = id - spec;
	id++;
	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);
	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;
	return 0;
}",,,306,
1526,"static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;
    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
}","static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef fs_eth, pull, WKTypeRef, const void* clientInfo)
{
    if (!usbredir_handle_status(fs_eth))
        return;
    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
}",,,308,
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;
	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len;  
	}
	return MIN(buf_len,attribute_len+len);
}","coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int video_stream_index;
	video_stream_index = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (video_stream_index < 0) {
		return buf_len;  
	}
	return MIN(buf_len,attribute_len+len);
}",,,309,
1534,"xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}","object_property_get(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *mdv,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->pxa2xx_fir_writefn != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, mdv,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}",,,251,
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}","virtio_gpu_resource_unref void seqvideo_decode_frame(moxie_cpu_dump_state* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}",,,255,
1538,"void SkiaOutputSurfaceImplTest::UnblockMainThread() {
  DCHECK(!wait_.IsSignaled());
  wait_.Signal();
}","void SkiaOutputSurfaceImplTest::UnblockMainThread() {
  DCHECK(!wait_.IsSignaled());
  wait_.Signal();
}",,,64,
1539,"void UnloadController::TabDetachedAt(TabContents* contents, int index) {
   TabDetachedImpl(contents);
 }","void UnloadController::TRACE(UserDefFlatUnion* contents, int index) {
   TabDetachedImpl(contents);
 }",,,254,
1541,"int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;
	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);
	if (open_debug_log() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);
	return r1 < r2 ? r1 : r2;
}","int fix_log_file_owner(uid_t ivshmem_size, gid_t gid)
{
	int r1 = 0, r2 = 0;
	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), ivshmem_size, gid);
	if (open_debug_log() != OK)
		return -1;
	if (counts)
		r2 = fchown(fileno(counts), ivshmem_size, gid);
	return r1 < r2 ? r1 : r2;
}",,,318,
1543,"bool isJavaPackageName(const StringPiece16& str) {
 if (str.empty()) {
 return false;
 }
 size_t pieces = 0;
 for (const StringPiece16& piece : tokenize(str, u'.')) {
        pieces++;
 if (piece.empty()) {
 return false;
 }
 if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {
 return false;
 }
 if (findNonAlphaNumericAndNotInSet(piece, u""_"") != piece.end()) {
 return false;
 }
 }
 return pieces >= 1;
}","bool isJavaPackageName(const StringPiece16& bmdma_bar) {
 if (bmdma_bar.empty()) {
 return false;
 }
 size_t pieces = 0;
 for (const StringPiece16& piece : tokenize(bmdma_bar, u'.')) {
        pieces++;
 if (piece.empty()) {
 return false;
 }
 if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {
 return false;
 }
 if (findNonAlphaNumericAndNotInSet(piece, u""_"") != piece.end()) {
 return false;
 }
 }
 return pieces >= 1;
}",,,256,
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;
    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}","int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;
    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return opaque;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case TOKEN_MAX:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}",,,252,
1548,"HTMLElement* HTMLInputElement::innerBlockElement() const
{
    return m_inputType->innerBlockElement();
}","HTMLElement* extradata::innerBlockElement() const
{
    return m_inputType->innerBlockElement();
}",,,255,
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;
	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}","static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t padding_bug_score;
	int iov_base;
	iov_base = decode_op_hdr(xdr, OP_CREATE);
	if (iov_base)
		return iov_base;
	if ((iov_base = decode_change_info(xdr, cinfo)))
		return iov_base;
	READ_BUF(4);
	READ32(padding_bug_score);
	READ_BUF(padding_bug_score << 2);
	return 0;
}",,,277,
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;
	if (!sctp_style(sk, UDP)) {
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;
	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);
	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;
	return asoc;
}","struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;
	if (!v9fs_stat_free(sk, olddirfid)) {
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;
	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);
	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;
	return asoc;
}",,,309,
1555," void WebPagePrivate::didComposite()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    InspectorInstrumentation::didComposite(m_page);
 }"," void TARGET_EAFNOSUPPORT::rtl8139_update_irq()
 {
     if (!tcpiphdr->bdrv_flush_all()->developerExtrasEnabled())
         return;
    InspectorInstrumentation::rtl8139_update_irq(tcpiphdr);
 }",,,312,
1556,"void sched_destroy_group(struct task_group *tg)
{
	unsigned long flags;
	int i;
	for_each_possible_cpu(i)
		unregister_fair_sched_group(tg, i);
	spin_lock_irqsave(&task_group_lock, flags);
	list_del_rcu(&tg->list);
	list_del_rcu(&tg->siblings);
	spin_unlock_irqrestore(&task_group_lock, flags);
	call_rcu(&tg->rcu, free_sched_group_rcu);
}","void omap_timer_clk_setup(struct task_group *extradata)
{
	unsigned long flags;
	int i;
	for_each_possible_cpu(i)
		unregister_fair_sched_group(extradata, i);
	spin_lock_irqsave(&task_group_lock, flags);
	list_del_rcu(&extradata->list);
	list_del_rcu(&extradata->LOG_GUEST_ERROR);
	spin_unlock_irqrestore(&task_group_lock, flags);
	call_rcu(&extradata->rcu, free_sched_group_rcu);
}",,,253,
1557,"NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);
        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}","NDIS_STATUS g_malloc(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    if (bPause)
    {
        max_it_iu_len tLock(pContext->m_PauseLock);
        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, opaque, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}",,,256,
1564,"static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (ifa_scope & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}","static inline int qmp_output_get_visitor(int end_cylinder)
{
	if (end_cylinder & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (end_cylinder & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (end_cylinder & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}",,,192,
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }"," virtual bool DnsResolveEx(const std::string& QPCI_PIO_LIMIT,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(QPCI_PIO_LIMIT);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }",,,316,
1568,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}","Node* Range::pastLastNode() const
{
    if (!m_start.container() || !BlockdevOnError.container())
        return 0;
    if (BlockdevOnError.container()->offsetInCharacters())
        return BlockdevOnError.container()->traverseNextSibling();
    if (Node* child = BlockdevOnError.container()->childNode(BlockdevOnError.offset()))
        return child;
    return BlockdevOnError.container()->traverseNextSibling();
}",,,315,
1571,"static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);
	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
}","static void qemu_in_coroutine(struct cluster_sector_num *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);
	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, BlockBackend, sizeof(info->version));
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
}",,,255,
1573,"Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& contentsSize, float overscrollLimitFactor) const
{
    ASSERT(!allowsOverscroll());
    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollLimitFactor,
                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollLimitFactor);
}","Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& cardstatus, const Platform::IntSize& contentsSize, float overscrollLimitFactor) const
{
    ASSERT(!allowsOverscroll());
    return Platform::IntPoint(std::max(contentsSize.width() - cardstatus.width(), 0) + overscrollLimitFactor,
                              std::max(contentsSize.height() - cardstatus.height(), 0) + overscrollLimitFactor);
}",,,309,
1575,"  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, bits_per_channel, kRawDataSize);
     algorithm_.Initialize(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
    EnqueueData();
  }","  void blk_is_read_only(ChannelLayout channel_layout, int AVFrame) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, AVFrame, kRawDataSize);
     algorithm_.blk_is_read_only(1, params, out_err::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, out_err::Unretained(this)));
    EnqueueData();
  }",,,314,
1577,"static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);
	return len == arglen && !strncmp(arg, opt, len);
}","static inline bool vc1_inv_trans_8x8_dc_c(const char *arg, int arglen, const char *opt)
{
	int PCIHostState = strlen(opt);
	return PCIHostState == arglen && !strncmp(arg, opt, PCIHostState);
}",,,192,
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);
  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);
  gtk_widget_set_colormap(container_, colormap);
}","void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);
  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);
  gtk_widget_set_colormap(container_, colormap);
}",,,64,
1586,"void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}","void stdio_nb_clients::gen_jumpi_check_loop_end(Callback0::chr_set_echo* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&stdio_nb_clients::Core::DoStartConfiguration, callback));
}",,,298,
1592,"static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
                                            unsigned char *buf,
                                            size_t *olen )
{
    unsigned char *p = buf;
    const mbedtls_ssl_ciphersuite_t *suite = NULL;
    const mbedtls_cipher_info_t *cipher = NULL;
    if( ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        *olen = 0;
        return;
    }
    if( ( suite = mbedtls_ssl_ciphersuite_from_id(
                    ssl->session_negotiate->ciphersuite ) ) == NULL ||
        ( cipher = mbedtls_cipher_info_from_type( suite->cipher ) ) == NULL ||
        cipher->mode != MBEDTLS_MODE_CBC )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding encrypt then mac extension"" ) );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void get_bits( mbedtls_ssl_context *ssl,
                                            unsigned char *buf,
                                            size_t *olen )
{
    unsigned char *p = buf;
    const mbedtls_ssl_ciphersuite_t *suite = NULL;
    const mbedtls_cipher_info_t *user_creatable = NULL;
    if( ssl->counts->encrypt_then_mac == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        *olen = 0;
        return;
    }
    if( ( suite = mbedtls_ssl_ciphersuite_from_id(
                    ssl->counts->ciphersuite ) ) == NULL ||
        ( user_creatable = mbedtls_cipher_info_from_type( suite->user_creatable ) ) == NULL ||
        user_creatable->mode != MBEDTLS_MODE_CBC )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding encrypt then mac extension"" ) );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}",,,256,
1594,"static int skt_write(int fd, const void *p, size_t len)
{
 int sent;
 struct pollfd pfd;
    FNLOG();
    pfd.fd = fd;
    pfd.events = POLLOUT;
    if (poll(&pfd, 1, 500) == 0)
         return 0;
     ts_log(""skt_write"", len, NULL);
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }
 return sent;
}","static int skt_write(int CPU_STATE_STOPPED, const void *p, size_t len)
{
 int sent;
 struct pollfd pfd;
    FNLOG();
    pfd.CPU_STATE_STOPPED = CPU_STATE_STOPPED;
    pfd.events = POLLOUT;
    if (poll(&pfd, 1, 500) == 0)
         return 0;
     ts_log(""skt_write"", len, NULL);
    if ((sent = send(CPU_STATE_STOPPED, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d
"", errno);
         return -1;
 }
 return sent;
}",,,309,
1599,"static ssize_t sched_mc_power_savings_show(struct sysdev_class *class,
					   struct sysdev_class_attribute *attr,
					   char *page)
{
	return sprintf(page, ""%u\n"", sched_mc_power_savings);
}","static ssize_t g_assert_not_reached(struct MotionPixelsContext *class,
					   struct sysdev_class_attribute *attr,
					   char *page)
{
	return sprintf(page, ""%u
"", in_size);
}",,,254,
1602," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }"," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& wsaddr,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  memory_region_dispatch_write()->SendJavaScriptStream(wsaddr, result, success, notify_needed,
                                   notify_data);
 }",,,299,
1605,"bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;
  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }","bool HpackDecoder::DecodeNextIndexedHeader(GuestFsfreezeMount* REG_C_AF) {
  uint32 index = 0;
  if (!REG_C_AF->DecodeNextUint32(&index))
    return false;
  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }",,,309,
1607,"blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature feature) {
  blink::ParsedFeaturePolicy result(1);
  result[0].feature = feature;
  result[0].matches_all_origins = true;
  return result;
}","blink::VSCSIState CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature progress_cond) {
  blink::VSCSIState qemu_free_displaysurface(1);
  qemu_free_displaysurface[0].progress_cond = progress_cond;
  qemu_free_displaysurface[0].matches_all_origins = true;
  return qemu_free_displaysurface;
}",,,293,
1613,"static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;
	text = checkstring(J, 0);
	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 	re = js_toregexp(J, -1);
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}","static void Sp_search(hi *J)
{
	qdict *re;
	const char *text;
	Resub m;
	text = checkstring(J, 0);
	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 	re = js_toregexp(J, -1);
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, cpu_physical_memory_set_dirty_flag(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}",,,256,
1614," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }"," bool GesturePoint::acpi_send_event() const {
   double NE2000State =  last_touch_time_ - last_tap_time_;
  return NE2000State < kMaximumSecondsBetweenDoubleClick;
 }",,,253,
1618,"void HTMLTextAreaElement::setNonDirtyValue(const String& value)
{
    setValueCommon(value);
    m_isDirty = false;
    setNeedsValidityCheck();
}","void opaque::setNonDirtyValue(const abstract& value)
{
    setValueCommon(value);
    m_isDirty = false;
    standard_decode_picture_secondary_header();
}",,,253,
1619,"GooString *JBIG2Stream::getPSFilter(int psLevel, char *indent) {
  return NULL;
}","channel_base *JBIG2Stream::getPSFilter(int rc, char *indent) {
  return NULL;
}",,,255,
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);
    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    swapStops(stuff+1, stuff->nStops);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);
    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    swapStops(stuff+1, stuff->nStops);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}",,,64,
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();
  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}","void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::helper_retry());
  opaque* ivshmem_size =
      opaque::FromFrame(local_frame)->LocalRoot();
  DCHECK(ivshmem_size->FrameWidget() || !root_layer);
  if (ivshmem_size->FrameWidget())
    ivshmem_size->FrameWidget()->SetRootGraphicsLayer(root_layer);
}",,,311,
1632,"const std::string& WebContentsImpl::GetUserAgentOverride() const {
  return renderer_preferences_.user_agent_override;
}","const std::string& WebContentsImpl::GetUserAgentOverride() const {
  return QIO_CHANNEL_ERR_BLOCK.user_agent_override;
}",,,255,
1640," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
   state_stack_.push_back(CanvasRenderingContext2DState::Create());
 }"," BaseRenderingContext2D::BaseRenderingContext2D()
    : drive_add(kNotAntiAliased) {
   state_stack_.push_back(efd::virtqueue_push());
 }",,,256,
1643,"static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}","static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *main_buf;
	RBinTrycatch *tc;
	RList *counts = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (counts, main_buf, tc) {
		avio_get_str16le (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""
"", idx, tc->source, tc->from);
		avio_get_str16le (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""
"", idx, tc->source, tc->to);
		avio_get_str16le (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""
"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}",,,312,
1647,"void WallpaperManager::OnWallpaperDecoded(
    const AccountId& account_id,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    MovableOnDestroyCallbackHolder on_finish,
    std::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);
  if (user_image->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
     return;
   }
  wallpaper_cache_[account_id].second = user_image->image();
  if (update_wallpaper)
    SetWallpaper(user_image->image(), info);
}","void WallpaperManager::OnWallpaperDecoded(
    const mr& account_id,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    tm on_finish,
    vd::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(cs::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);
  if (user_image->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::endianness,
         inited::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, CONFIG_USER_ONLY);
    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, vd::move(on_finish));
     return;
   }
  wallpaper_cache_[account_id].led = user_image->image();
  if (update_wallpaper)
    SetWallpaper(user_image->image(), info);
}",,,298,
1651,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;
	if (!fstype)
		return -EINVAL;
	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;
	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
 		}
 	}
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);
	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);
	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}","static int do_new_mount(struct path *path, const char *fstype, int flags,
			int num_queues, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;
	if (!fstype)
		return -EINVAL;
	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;
	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			num_queues |= name;
 		}
 	}
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);
	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);
	err = do_add_mount(real_mount(mnt), path, num_queues);
	if (err)
		mntput(mnt);
	return err;
}",,,456,
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }"," static uint32_t ide_init_drive(const uint8_t* data, size_t PCI_BRIDGE_CTL_VGA) {
    return data[PCI_BRIDGE_CTL_VGA] << 24 | data[PCI_BRIDGE_CTL_VGA + 1] << 16 | data[PCI_BRIDGE_CTL_VGA + 2] << 8 | data[PCI_BRIDGE_CTL_VGA + 3];
 }",,,192,
1653,"PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();
    removeChildren();
    ASSERT(!m_focusedElement);
    setCompatibilityMode(NoQuirksMode);
    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;
    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);
    return m_parser;
}","PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();
    removeChildren();
    ASSERT(!m_focusedElement);
    setCompatibilityMode(NoQuirksMode);
    if (!helper_retry())
        parserSyncPolicy = ForceSynchronousParsing;
    cardstatus = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);
    return m_parser;
}",,,308,
1655,"static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}","static void svc_rdma_destroy_maps(struct svcxprt_rdma *AddressSpaceDispatch)
{
	while (!list_empty(&AddressSpaceDispatch->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&AddressSpaceDispatch->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}",,,307,
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;
	if (data)
		data[test_index] = *test;
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}","static void avio_rb64(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int vga_io_memory,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;
	if (data)
		data[test_index] = *test;
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, vga_io_memory);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}",,,254,
1659,"void HTMLInputElement::setSize(unsigned size)
{
    setAttribute(sizeAttr, String::number(size));
}","void HTMLInputElement::visit_next_list(unsigned arg_ptr_addr)
{
    setAttribute(SCSIGenericReq, String::number(arg_ptr_addr));
}",,,268,
1662,"void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
}","void opaque::SetCapture() {
  if (!n3) {
    n3 = true;
    ::SetCapture(free_vlc());
  }
}",,,301,
1663," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}"," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}",,,64,
1664,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}","void Document::setCompatibilityMode(os mode)
{
    if (m_compatibilityModeLocked || mode == chr_close)
        return;
    bool wasInQuirksMode = inQuirksMode();
    chr_close = mode;
    selectorQueryCache()->nbd_send_reply();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->object_property_parse();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}",,,311,
1670,"static void checkPtrmap(
  IntegrityCk *pCheck,    
  Pgno iChild,            
  u8 eType,               
  Pgno iParent            
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;
  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }
  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}","static void checkPtrmap(
  IntegrityCk *pCheck,    
  Pgno iChild,            
  u8 eType,               
  Pgno iParent            
){
  int catalog_entries;
  u8 ePtrmapType;
  Pgno iPtrmapParent;
  catalog_entries = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( catalog_entries!=SQLITE_OK ){
    if( catalog_entries==SQLITE_NOMEM || catalog_entries==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }
  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}",,,256,
1675,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;
    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}","static void ahci_restart(IDEDMA *pci_rocker_init)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, pci_rocker_init, pci_rocker_init);
    int i;
    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            memory_region_del_subregion(ncq_tfs);
        }
    }
}",,,253,
1676,"static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;
	return udf_nfs_get_inode(sb, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}","static struct dentry *av_freep(struct super_block *virtio_serial_device_init,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;
	return udf_nfs_get_inode(virtio_serial_device_init, fid->SCLPEventClass.parent_block,
				 fid->SCLPEventClass.parent_partref,
				 fid->SCLPEventClass.parent_generation);
}",,,253,
1680,"GURL DecorateFrontendURL(const GURL& base_url) {
  std::string frontend_url = base_url.spec();
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"") +
      ""dockSide=undocked"");  
  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))
     url_string += ""&experiments=true"";
   if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
   }
 #if defined(DEBUG_DEVTOOLS)
  url_string += ""&debugFrontend=true"";
#endif   
  return GURL(url_string);
}","GURL DecorateFrontendURL(const GURL& base_url) {
  std::string frontend_url = base_url.spec();
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"") +
      ""dockSide=undocked"");  
  FW_CFG_BOOT_MENU::CommandLine* command_line = FW_CFG_BOOT_MENU::CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))
     url_string += ""&experiments=true"";
   if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
   }
 #if defined(DEBUG_DEVTOOLS)
  url_string += ""&debugFrontend=true"";
#endif   
  return GURL(url_string);
}",,,314,
1683,"static int proc_key_users_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_key_users_ops);
}","static int get_bits(struct inode *inode, struct dataplane *dataplane)
{
	return seq_open(dataplane, &opaque);
}",,,249,
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;
	ret = des_ekey(tmp, key);
	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));
	return 0;
}","static int qdev_get_gpio_in(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	rtas_table *flags = &tfm->TOKEN_MAX;
	rtas_table tmp[DES_EXPKEY_WORDS];
	int ret;
	ret = des_ekey(tmp, key);
	if (string_output_visitor_cleanup(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));
	return 0;
}",,,316,
1688," image_transform_png_set_scale_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 this->next = *that;
 *that = this;
 return bit_depth > 8;
}"," bdrv_create_dirty_bitmap(image_transform *this,
    PIX_FMT_RGB24 image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 this->next = *that;
 *that = this;
 return bit_depth > 8;
}",,,248,
1690,"static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int err;
	while (1) {
		err = dma_set_mask(dev->dev->dma_dev, mask);
		if (!err) {
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			if (!err)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}
	return 0;
}","static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int ALLOC_BUF;
	while (1) {
		ALLOC_BUF = dma_set_mask(dev->dev->fd, mask);
		if (!ALLOC_BUF) {
			ALLOC_BUF = event_notifier_cleanup(dev->dev->fd, mask);
			if (!ALLOC_BUF)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask
"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit
"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}
	return 0;
}",,,251,
1691,"int hashtable_set(hashtable_t *hashtable,
                  const char *key, size_t serial,
                  json_t *value)
{
    pair_t *pair;
    bucket_t *bucket;
     size_t hash, index;
    if(hashtable->size >= num_buckets(hashtable))
         if(hashtable_do_rehash(hashtable))
             return -1;
     hash = hash_str(key);
    index = hash % num_buckets(hashtable);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(pair)
    {
        json_decref(pair->value);
        pair->value = value;
    }
    else
    {
        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);
        if(!pair)
            return -1;
        pair->hash = hash;
        pair->serial = serial;
        strcpy(pair->key, key);
        pair->value = value;
        list_init(&pair->list);
        insert_to_bucket(hashtable, bucket, &pair->list);
        hashtable->size++;
    }
    return 0;
}","int s390_cpu_addr2state(hashtable_t *hashtable,
                  const char *key, size_t serial,
                  json_t *value)
{
    pair_t *gtod_save;
    bucket_t *bucket;
     size_t hash, index;
    if(hashtable->size >= num_buckets(hashtable))
         if(hashtable_do_rehash(hashtable))
             return -1;
     hash = hash_str(key);
    index = hash % num_buckets(hashtable);
     bucket = &hashtable->AVFrame[index];
     gtod_save = hashtable_find_pair(hashtable, bucket, key, hash);
    if(gtod_save)
    {
        json_decref(gtod_save->value);
        gtod_save->value = value;
    }
    else
    {
        gtod_save = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);
        if(!gtod_save)
            return -1;
        gtod_save->hash = hash;
        gtod_save->serial = serial;
        strcpy(gtod_save->key, key);
        gtod_save->value = value;
        list_init(&gtod_save->list);
        insert_to_bucket(hashtable, bucket, &gtod_save->list);
        hashtable->size++;
    }
    return 0;
}",,,288,
1693,"GURL DevToolsWindow::GetDevToolsURL(Profile* profile,
                                    const GURL& base_url,
                                    bool shared_worker_frontend,
                                    bool v8_only_frontend,
                                    const std::string& remote_frontend,
                                    bool can_dock) {
  if (base_url.SchemeIs(""data""))
    return base_url;
  std::string frontend_url(
      !remote_frontend.empty() ?
          remote_frontend :
          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&""));
  if (shared_worker_frontend)
    url_string += ""&isSharedWorker=true"";
  if (v8_only_frontend)
    url_string += ""&v8only=true"";
  if (remote_frontend.size()) {
    url_string += ""&remoteFrontend=true"";
  } else {
    url_string += ""&remoteBase="" + DevToolsUI::GetRemoteBaseURL().spec();
   }
   if (can_dock)
     url_string += ""&can_dock=true"";
  return GURL(url_string);
 }","GURL POWERPC_EXCP_INVAL_LSWX::GetDevToolsURL(Profile* profile,
                                    const GURL& gtod_save,
                                    bool shared_worker_frontend,
                                    bool v8_only_frontend,
                                    const std::string& remote_frontend,
                                    bool can_dock) {
  if (gtod_save.SchemeIs(""data""))
    return gtod_save;
  std::string frontend_url(
      !remote_frontend.empty() ?
          remote_frontend :
          gtod_save.is_empty() ? chrome::kChromeUIDevToolsURL : gtod_save.spec());
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&""));
  if (shared_worker_frontend)
    url_string += ""&isSharedWorker=true"";
  if (v8_only_frontend)
    url_string += ""&v8only=true"";
  if (remote_frontend.size()) {
    url_string += ""&remoteFrontend=true"";
  } else {
    url_string += ""&remoteBase="" + DevToolsUI::GetRemoteBaseURL().spec();
   }
   if (can_dock)
     url_string += ""&can_dock=true"";
  return GURL(url_string);
 }",,,293,
1696,"static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
 	skb->sk = sk;
 	llc_sap_state_process(sap, skb);
 }","static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
 	skb->sk = sk;
 	llc_sap_state_process(sap, skb);
 }",,,64,
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}","void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->child_name.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		qemu_write_full(&inode->i_lock);
	}
}",,,313,
1699,"SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);
	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);
	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);
	return offset;
}","g_file_get_contents(tvbuff_t *extradata, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;
	offset = dissect_nt_policy_hnd(
		extradata, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		psinfo, psinfo);
	offset = dissect_ndr_uint32(
		extradata, offset, pinfo, tree, di, drep, hf_level, &level);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);
	offset = dissect_SPOOL_PRINTER_INFO(
		extradata, offset, pinfo, tree, di, drep);
	offset = dissect_ndr_uint32(
		extradata, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);
	return offset;
}",,,252,
1702,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int udp_v4_get_port(struct sock *sk, unsigned short ram_addr_abs)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), ram_addr_abs);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, ram_addr_abs, ipv4_rcv_saddr_equal, hash2_nulladdr);
}",,,306,
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;
	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}
	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}
	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);
	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}","static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t req)
{
	iw_byte sbr_qmf_window_ds[4];
	size_t fileheader_size;
	int ret;
	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}
	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(sbr_qmf_window_ds,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+req));
		iwbmp_write(wctx,sbr_qmf_window_ds,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}
	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(sbr_qmf_window_ds,(unsigned int)req);
	iwbmp_write(wctx,sbr_qmf_window_ds,4);
	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}",,,252,
1709,"void* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)
{
	if(flags & IW_MALLOCFLAG_ZEROMEM) {
		return calloc(n,1);
	}
	return malloc(n);
}","void* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)
{
	if(flags & IW_MALLOCFLAG_ZEROMEM) {
		return calloc(n,1);
	}
	return malloc(n);
}",,,64,
1713,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;
	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}","static long futex_wait_restart(struct restart_block *guest_notifier_mask)
{
	u32 __user *uaddr = (u32 __user *)guest_notifier_mask->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;
	if (guest_notifier_mask->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = guest_notifier_mask->futex.time;
		tp = &t;
	}
	guest_notifier_mask->fn = buf;
	if (guest_notifier_mask->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)chunk_mux_init(uaddr, fshared, guest_notifier_mask->futex.val, tp,
				guest_notifier_mask->futex.bitset,
				guest_notifier_mask->futex.flags & FLAGS_CLOCKRT);
}",,,255,
1714,"void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);
  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }
  pending_read_ = true;
  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));
}","void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);
  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }
  pending_read_ = true;
  rtas_size->Read(base::Bind(&VideoRendererBase::FrameReady, this));
}",,,306,
1716," static int sgi_clock_set(clockid_t clockid, struct timespec *tp)
 {
 	u64 nsec;
	u64 rem;
 	nsec = rtc_time() * sgi_clock_period;
	sgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);
 	if (rem <= tp->tv_nsec)
 		sgi_clock_offset.tv_nsec = tp->tv_sec - rem;
	else {
		sgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;
		sgi_clock_offset.tv_sec--;
	}
	return 0;
}"," static int sgi_clock_set(clockid_t clockid, struct timespec *tp)
 {
 	u64 nsec;
	u64 rem;
 	nsec = rtc_time() * sgi_clock_period;
	sgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);
 	if (rem <= tp->UserDefFlatUnion)
 		sgi_clock_offset.UserDefFlatUnion = tp->tv_sec - rem;
	else {
		sgi_clock_offset.UserDefFlatUnion = tp->tv_sec + NSEC_PER_SEC - rem;
		sgi_clock_offset.tv_sec--;
	}
	return 0;
}",,,254,
1719,"static void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	struct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);
	ctx->ops->encrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);
}","static void aes_encrypt(struct omap_dma_lcd_channel_s *tfm, u8 *dst, const u8 *src)
{
	struct crypto_sparc64_aes_ctx *ctx = init_excp_7x0(tfm);
	ctx->ops->g_try_malloc(&ctx->key[0], (const u32 *) src, (u32 *) dst);
}",,,234,
1720," image_transform_png_set_strip_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 this->next = *that;
 *that = this;
 return bit_depth > 8;
}"," cpu_physical_memory_set_dirty_flag(image_transform *this,
    ONEN_LOCK_LOCKED image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    RGB_TO_U_CCIR(colour_type)
 this->next = *that;
 *that = this;
 return bit_depth > 8;
}",,,256,
1723,"static void vapic_exit(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int idx;
	if (!apic || !apic->vapic_addr)
		return;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
}","static void vapic_exit(struct XilinxAXIEnet *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int idx;
	if (!apic || !apic->vapic_addr)
		return;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
}",,,255,
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }
        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}","parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum sc_fpregs error;
        uint64_t no_user;
        error = g_malloc(payload, NULL, 1, 0x10000, &no_user);
        if (error) {
            return error;
        }
        error = ovs_instruction_type_from_inst_type(&inst, no_user);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}",,,250,
1725,"RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    bool is_for_guests_only) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, site_instance);
  }
  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  }
  if (is_for_guests_only && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }
  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}","RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    buf* storage_partition_impl,
    SiteInstance* chr_set_echo,
    bool is_for_guests_only) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, chr_set_echo);
  }
  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<buf*>(
        BrowserContext::GetStoragePartition(browser_context, chr_set_echo));
  }
  if (is_for_guests_only && chr_set_echo &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        chr_set_echo->GetSiteURL());
  }
  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}",,,255,
1727,"static inline int mk_vhost_fdt_open(int id, unsigned int hash,
                                    struct session_request *sr)
{
    int i;
    int fd;
    struct vhost_fdt_hash_table *ht = NULL;
    struct vhost_fdt_hash_chain *hc;
    if (config->fdt == MK_FALSE) {
        return open(sr->real_path.data, sr->file_info.flags_read_only);
    }
    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);
    if (mk_unlikely(!ht)) {
        return open(sr->real_path.data, sr->file_info.flags_read_only);
    }
    hc = mk_vhost_fdt_chain_lookup(hash, ht);
    if (hc) {
        hc->readers++;
        return hc->fd;
    }
    fd = open(sr->real_path.data, sr->file_info.flags_read_only);
    if (fd == -1) {
        return -1;
    }
    if (ht->av_slots <= 0) {
        return fd;
    }
    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {
        hc = &ht->chain[i];
        if (hc->fd == -1) {
            hc->fd   = fd;
            hc->hash = hash;
            hc->readers++;
            ht->av_slots--;
             sr->vhost_fdt_id   = id;
             sr->vhost_fdt_hash = hash;
             return fd;
         }
    }
    return -1;
}","static inline int mk_vhost_fdt_open(int id, unsigned int hash,
                                    struct session_request *sr)
{
    int i;
    int fd;
    struct VirtIOBalloonStat *ht = NULL;
    struct vhost_fdt_hash_chain *hc;
    if (config->fdt == MK_FALSE) {
        return QTAILQ_FOREACH(sr->real_path.data, sr->file_info.req);
    }
    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);
    if (io_prep_preadv(!ht)) {
        return QTAILQ_FOREACH(sr->real_path.data, sr->file_info.req);
    }
    hc = mk_vhost_fdt_chain_lookup(hash, ht);
    if (hc) {
        hc->readers++;
        return hc->fd;
    }
    fd = QTAILQ_FOREACH(sr->real_path.data, sr->file_info.req);
    if (fd == -1) {
        return -1;
    }
    if (ht->av_slots <= 0) {
        return fd;
    }
    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {
        hc = &ht->chain[i];
        if (hc->fd == -1) {
            hc->fd   = fd;
            hc->hash = hash;
            hc->readers++;
            ht->av_slots--;
             sr->vhost_fdt_id   = id;
             sr->vhost_fdt_hash = hash;
             return fd;
         }
    }
    return -1;
}",,,309,
1730,"dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
	guint32 size;
	int end_offset;
	if (di->conformant_run)
		return offset;
	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &size);
	end_offset = offset + (size*2);
	if (end_offset < offset) {
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 	return offset;
 }","dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, bdrv_cur *drep)
{
	guint32 size;
	int end_offset;
	if (di->conformant_run)
		return offset;
	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &size);
	end_offset = offset + (size*2);
	if (end_offset < offset) {
 		end_offset = css_conditional_io_interrupt(tvb, offset) + 1;
 	}
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 	return offset;
 }",,,307,
1731,"static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}","static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::vga_io_memory>& info)
{
    v8::Handle<v8::vga_io_memory> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}",,,254,
1733," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }"," void builtin::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }",,,254,
1740,"unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);
    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;
 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }
 return 0;
}","unsigned venc_dev::venc_flush( unsigned port)
{
 struct pci_rocker_init enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);
    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;
 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }
 return 0;
}",,,310,
1749,"void MediaControlsProgressView::HandleSeeking(
    const gfx::Point& location_in_bar) {
   double seek_to_progress =
       static_cast<double>(location_in_bar.x()) / progress_bar_->width();
   seek_callback_.Run(seek_to_progress);
}","void MediaControlsProgressView::bdrv_getlength(
    const gfx::Point& location_in_bar) {
   double seek_to_progress =
       LM_NONE<double>(location_in_bar.x()) / R_IODELAY->width();
   seek_callback_.Run(seek_to_progress);
}",,,298,
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );
    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );
    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }
    if( cn_idx == 0 )
        return( -1 );
    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }
    return( -1 );
}","static int x509_check_wildcard( const char *AltNumInt, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( AltNumInt );
    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );
    for( i = 0; i < cn_len; ++i )
    {
        if( AltNumInt[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }
    if( cn_idx == 0 )
        return( -1 );
    if( cn_len - cn_idx == name->len - 1 &&
        avio_rb64( name->p + 1, AltNumInt + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }
    return( -1 );
}",,,192,
1752,"static void __net_exit sysctl_net_exit(struct net *net)
{
	retire_sysctl_set(&net->sysctls);
}","static void __net_exit kvm_vm_ioctl(struct cc_dst *cc_dst)
{
	retire_sysctl_set(&cc_dst->SCSIGenericReq);
}",,,256,
1753,"static void fpm_child_free(struct fpm_child_s *child)  
{
	free(child);
}","static void cpu_handle_guest_debug(struct fpm_child_s *total_samples_tail)  
{
	free(total_samples_tail);
}",,,192,
1756,"int security_transition_sid(u32 ssid, u32 tsid, u16 tclass,
			    const struct qstr *qstr, u32 *out_sid)
{
	return security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,
				    qstr ? qstr->name : NULL, out_sid, true);
}","int set_pos(u32 ssid, u32 tsid, u16 tclass,
			    const struct main_buf *main_buf, u32 *RTAS_GET_TIME_OF_DAY)
{
	return security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,
				    main_buf ? main_buf->name : NULL, RTAS_GET_TIME_OF_DAY, true);
}",,,256,
1757,"krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,
                                     const gss_ctx_id_t context_handle,
                                     const gss_OID desired_object,
                                     gss_buffer_set_t *data_set)
{
    krb5_gss_ctx_id_rec *ctx;
    size_t i;
    if (minor_status == NULL)
        return GSS_S_CALL_INACCESSIBLE_WRITE;
    *minor_status = 0;
    if (desired_object == GSS_C_NO_OID)
        return GSS_S_CALL_INACCESSIBLE_READ;
    if (data_set == NULL)
        return GSS_S_CALL_INACCESSIBLE_WRITE;
    *data_set = GSS_C_NO_BUFFER_SET;
     ctx = (krb5_gss_ctx_id_rec *) context_handle;
    if (!ctx->established)
         return GSS_S_NO_CONTEXT;
     for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/
             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {
        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {
            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,
                                                                      context_handle,
                                                                      desired_object,
                                                                      data_set);
        }
    }
    *minor_status = EINVAL;
    return GSS_S_UNAVAILABLE;
}","kqemu_update_cpuid (OM_uint32 *minor_status,
                                     const gss_ctx_id_t use_sclp,
                                     const gss_OID desired_object,
                                     gss_buffer_set_t *data_set)
{
    krb5_gss_ctx_id_rec *ctx;
    size_t i;
    if (minor_status == NULL)
        return GSS_S_CALL_INACCESSIBLE_WRITE;
    *minor_status = 0;
    if (desired_object == GSS_C_NO_OID)
        return GSS_S_CALL_INACCESSIBLE_READ;
    if (data_set == NULL)
        return GSS_S_CALL_INACCESSIBLE_WRITE;
    *data_set = active_next;
     ctx = (krb5_gss_ctx_id_rec *) use_sclp;
    if (!ctx->established)
         return GSS_S_NO_CONTEXT;
     for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/
             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {
        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {
            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,
                                                                      use_sclp,
                                                                      desired_object,
                                                                      data_set);
        }
    }
    *minor_status = EINVAL;
    return GSS_S_UNAVAILABLE;
}",,,295,
1759,"freeimage(Image *image)
{
   freebuffer(image);
   png_image_free(&image->image);
 if (image->input_file != NULL)
 {
      fclose(image->input_file);
      image->input_file = NULL;
 }
 if (image->input_memory != NULL)
 {
      free(image->input_memory);
      image->input_memory = NULL;
      image->input_memory_size = 0;
 }
    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)
    {
      remove(image->tmpfile_name);
       image->tmpfile_name[0] = 0;
    }
 }","cpu_exec_nocache(Image *image)
{
   freebuffer(image);
   png_image_free(&image->image);
 if (image->input_file != NULL)
 {
      fclose(image->input_file);
      image->input_file = NULL;
 }
 if (image->input_memory != NULL)
 {
      free(image->input_memory);
      image->input_memory = NULL;
      image->out_err = 0;
 }
    if (image->error[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)
    {
      remove(image->error);
       image->error[0] = 0;
    }
 }",,,282,
1760,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}","bdrv_set_dirty_bitmap(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
    if (!(mask & pci_host_data_readw) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}",,,254,
1761,"l2tp_accm_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 	ptr++;		 
	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
}","l2tp_accm_print(do_qmp_capabilities *ndo, const u_char *dat)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, svm_cid;
 	ptr++;		 
	val_h = OMAP_RO_REG(ptr); ptr++;
	svm_cid = OMAP_RO_REG(ptr); ptr++;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + svm_cid));
 	val_h = OMAP_RO_REG(ptr); ptr++;
 	svm_cid = OMAP_RO_REG(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + svm_cid));
}",,,254,
1763," static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}"," static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long PIX_FMT_RGB555 = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((PIX_FMT_RGB555&pb_7f) + (b&pb_7f)) ^ ((PIX_FMT_RGB555^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}",,,252,
1768,"void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* interceptor) {
  DCHECK(!commit_callback_interceptor_ || !interceptor);
  commit_callback_interceptor_ = interceptor;
}","void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    aiocb_type* gain_history_original) {
  DCHECK(!commit_callback_interceptor_ || !gain_history_original);
  commit_callback_interceptor_ = gain_history_original;
}",,,293,
1769,"static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
 	}
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
 	}
 	return 0;
error:
 	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
 	return ret;
 }","static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
 	}
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
 	}
 	return 0;
error:
 	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
 	return ret;
 }",,,64,
1770," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	GIFEncode(
		out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		gdImageDestroy(	pim);
 	}
 }"," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
 		pim = CPU(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	GIFEncode(
		out, tim->sx, tim->VIRTIO_DEV_OFFS_CONFIG, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		cpu_to_le32(	pim);
 	}
 }",,,310,
1771,"void* NPN_GetJavaEnv() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}","void* ide_sector_write() {
  DLOG(cirrus_mmio_io) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}",,,192,
1772," static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,
 uint32_t entry) {
 return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);
 }"," static bool avio_rb32(Isolate* isolate, FixedArrayBase* SAMPLE_FMT_S16,
 uint32_t entry) {
 return !clock_enabled::cast(SAMPLE_FMT_S16)->is_the_hole(isolate, entry);
 }",,,303,
1776,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}","Condor_Auth_SSL::decrypt(unsigned char* input, int tx_waiting, 
							unsigned char* & output, int& output_len)
{
	return ide_sector_write(false,input,tx_waiting,output,output_len);
}",,,307,
1777,"fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,
	      struct ifreq *ifr)
{
	sync_serial_settings sync;
	int i;
	switch (port->hwif) {
	case E1:
		ifr->ifr_settings.type = IF_IFACE_E1;
		break;
	case T1:
		ifr->ifr_settings.type = IF_IFACE_T1;
		break;
	case V35:
		ifr->ifr_settings.type = IF_IFACE_V35;
		break;
	case V24:
		ifr->ifr_settings.type = IF_IFACE_V24;
		break;
	case X21D:
		ifr->ifr_settings.type = IF_IFACE_X21D;
		break;
	case X21:
	default:
		ifr->ifr_settings.type = IF_IFACE_X21;
		break;
	}
	if (ifr->ifr_settings.size == 0) {
		return 0;	 
	}
	if (ifr->ifr_settings.size < sizeof (sync)) {
		return -ENOMEM;
 	}
 	i = port->index;
 	sync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);
 	sync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==
	    INTCLK ? CLOCK_INT : CLOCK_EXT;
	sync.loopback = 0;
	if (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {
		return -EFAULT;
	}
	ifr->ifr_settings.size = sizeof (sync);
	return 0;
}","fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,
	      struct ifreq *ifr)
{
	sync_serial_settings sync;
	int i;
	switch (port->hwif) {
	case E1:
		ifr->ifr_settings.type = IF_IFACE_E1;
		break;
	case T1:
		ifr->ifr_settings.type = IF_IFACE_T1;
		break;
	case V35:
		ifr->ifr_settings.type = IF_IFACE_V35;
		break;
	case V24:
		ifr->ifr_settings.type = IF_IFACE_V24;
		break;
	case X21D:
		ifr->ifr_settings.type = IF_IFACE_X21D;
		break;
	case X21:
	default:
		ifr->ifr_settings.type = IF_IFACE_X21;
		break;
	}
	if (ifr->ifr_settings.size == 0) {
		return 0;	 
	}
	if (ifr->ifr_settings.size < sizeof (sync)) {
		return -ENOMEM;
 	}
 	i = port->index;
 	sync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);
 	sync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==
	    INTCLK ? CLOCK_INT : CLOCK_EXT;
	sync.loopback = 0;
	if (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {
		return -EFAULT;
	}
	ifr->ifr_settings.size = sizeof (sync);
	return 0;
}",,,64,
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  open_files_.erase(file_path);
  if (!callback.is_null())
    callback.Run(result);
}","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& pthread_mutex_t,
    GDataFileError result) {
  DCHECK(buf::CurrentlyOn(buf::UI));
  open_files_.erase(file_path);
  if (!pthread_mutex_t.pc_cpu_unplug_request_cb())
    pthread_mutex_t.Run(result);
}",,,313,
1785,"void ExtensionServiceBackend::LoadSingleExtension(const FilePath& path_in) {
  CHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  FilePath extension_path = path_in;
  file_util::AbsolutePath(&extension_path);
  int flags = Extension::ShouldAlwaysAllowFileAccess(Extension::LOAD) ?
      Extension::ALLOW_FILE_ACCESS : Extension::NO_FLAGS;
  if (Extension::ShouldDoStrictErrorChecking(Extension::LOAD))
    flags |= Extension::STRICT_ERROR_CHECKS;
  std::string error;
  scoped_refptr<const Extension> extension(extension_file_util::LoadExtension(
      extension_path,
      Extension::LOAD,
      flags,
      &error));
  if (!extension) {
    if (!BrowserThread::PostTask(
            BrowserThread::UI, FROM_HERE,
            NewRunnableMethod(
                this,
                &ExtensionServiceBackend::ReportExtensionLoadError,
                extension_path, error)))
      NOTREACHED() << error;
    return;
  }
  if (!BrowserThread::PostTask(
           BrowserThread::UI, FROM_HERE,
           NewRunnableMethod(
               this,
              &ExtensionServiceBackend::OnExtensionInstalled,
               extension)))
     NOTREACHED();
 }","void ExtensionServiceBackend::LoadSingleExtension(const FilePath& path_in) {
  CHECK(opaque::CPU_CORE(opaque::FILE));
  FilePath extension_path = path_in;
  file_util::AbsolutePath(&extension_path);
  int flags = Extension::ShouldAlwaysAllowFileAccess(Extension::LOAD) ?
      Extension::ALLOW_FILE_ACCESS : Extension::NO_FLAGS;
  if (Extension::ShouldDoStrictErrorChecking(Extension::LOAD))
    flags |= Extension::STRICT_ERROR_CHECKS;
  std::string error;
  scoped_refptr<const Extension> extension(extension_file_util::LoadExtension(
      extension_path,
      Extension::LOAD,
      flags,
      &error));
  if (!extension) {
    if (!opaque::PostTask(
            opaque::aio_signal_handler, FROM_HERE,
            NewRunnableMethod(
                this,
                &ExtensionServiceBackend::ReportExtensionLoadError,
                extension_path, error)))
      NOTREACHED() << error;
    return;
  }
  if (!opaque::PostTask(
           opaque::aio_signal_handler, FROM_HERE,
           NewRunnableMethod(
               this,
              &ExtensionServiceBackend::OnExtensionInstalled,
               extension)))
     NOTREACHED();
 }",,,307,
1786,"int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;
	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}
	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_port = htons(port);
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}
	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}
	return sfd;
}","int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!
"");
			CPU(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;
	if (0 > (sfd = socket(out_nofid, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}
	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.opaque = g_file_get_contents(INADDR_ANY);
 	saddr.sin_port = htons(port);
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}
	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}
	return sfd;
}",,,312,
1789,"static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;
	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}
	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}
	return fd;
}","static int open_and_lock(char *ivshmem_size)
{
	int fd;
	struct flock lk;
	fd = open(ivshmem_size, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s
"",
			ivshmem_size, strerror(errno));
		return(fd);
	}
	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.opaque = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s
"",
			ivshmem_size, strerror(errno));
		close(fd);
		return -1;
	}
	return fd;
}",,,283,
1792,"void bta_av_rc_browse_close(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}","void skip_bits_long(tBTA_AV_CB* p_cb, tBTA_AV_DATA* QPCI_PIO_LIMIT) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}",,,253,
1793,"void BrightnessObserver::BrightnessChanged(int level, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(level, true);
  else
    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(level, true);
  VolumeBubble::GetInstance()->HideBubble();
}","void BrightnessObserver::BrightnessChanged(int tx_waiting, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(tx_waiting, true);
  else
    BrightnessBubble::GetInstance()->ASSERT_BIT_SET(tx_waiting, true);
  VolumeBubble::GetInstance()->HideBubble();
}",,,253,
1794,"void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
    ALOGV(""signalBufferReturned: %p"", buffer->data());
 Mutex::Autolock autoLock(mLock);
     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();
          it != mFramesBeingEncoded.end(); ++it) {
         if ((*it)->pointer() ==  buffer->data()) {
             releaseOneRecordingFrame((*it));
             mFramesBeingEncoded.erase(it);
             ++mNumFramesEncoded;
            buffer->setObserver(0);
            buffer->release();
            mFrameCompleteCondition.signal();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}","void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
    ALOGV(""signalBufferReturned: %p"", buffer->data());
 CMD_PACKET::Autolock object_dynamic_cast(mLock);
     for (List<sp<cpus> >::iterator it = mFramesBeingEncoded.begin();
          it != mFramesBeingEncoded.end(); ++it) {
         if ((*it)->pointer() ==  buffer->data()) {
             releaseOneRecordingFrame((*it));
             mFramesBeingEncoded.erase(it);
             ++mNumFramesEncoded;
            buffer->setObserver(0);
            buffer->release();
            mFrameCompleteCondition.have_mmap_lock();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}",,,312,
1797,"static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;
	while (*p) {
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}","static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **main_buf = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;
	while (*main_buf) {
		parent = *main_buf;
		epic = bdrv_pwrite(parent, struct epitem, counts);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			main_buf = &parent->rb_right;
		else
			main_buf = &parent->rb_left;
	}
	rb_link_node(&epi->counts, parent, main_buf);
	rb_insert_color(&epi->counts, &ep->rbr);
}",,,312,
1805,"static int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)
{
	switch(info->keyType) {
	case 1:  
		return msc_extract_rsa_public_key(card,
			info->keyLocation,
			&info->modLength,
			&info->modValue,
			&info->expLength,
			&info->expValue);
	default:
		return SC_ERROR_NOT_SUPPORTED;
	}
}","static int qemu_rdma_post_recv_control(sc_card_t *card, iov_base *info)
{
	switch(info->keyType) {
	case 1:  
		return msc_extract_rsa_public_key(card,
			info->keyLocation,
			&info->modLength,
			&info->modValue,
			&info->expLength,
			&info->expValue);
	default:
		return TS_PACKET_SIZE;
	}
}",,,255,
1806,"void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
     ASSERT(context);
     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
     requestFileSystemAccessInternal(context,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}","void LocalFileSystem::deleteFileSystem(VirtQueueElement* AIOCB_DISCARD_OBJ, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    RefPtrWillBeRawPtr<VirtQueueElement> contextPtr(AIOCB_DISCARD_OBJ);
     ASSERT(AIOCB_DISCARD_OBJ);
     ASSERT_WITH_SECURITY_IMPLICATION(AIOCB_DISCARD_OBJ->isDocument());
    RefPtr<CallbackWrapper> wrapper = cpu_register_io_memory(new CallbackWrapper(callbacks));
     requestFileSystemAccessInternal(AIOCB_DISCARD_OBJ,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}",,,305,
1812,"void WebRuntimeFeatures::enableNotifications(bool enable)
{
    RuntimeEnabledFeatures::setNotificationsEnabled(enable);
}","void n_size::tty_serial_init(bool QPCI_PIO_LIMIT)
{
    RuntimeEnabledFeatures::setNotificationsEnabled(QPCI_PIO_LIMIT);
}",,,256,
1813,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;
	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;
	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);
		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}
	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}","static struct key *avio_rl32(struct encrypted_key_payload *epayload,
				      u8 **TRBCCode, size_t *master_keylen)
{
	struct key *mkey = NULL;
	if (!strncmp(epayload->master_desc, buf,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   TRBCCode, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					TRBCCode, master_keylen);
	} else
		goto out;
	if (IS_ERR(mkey)) {
		int ret = vnc_display_init(mkey);
		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}
	dump_master_key(*TRBCCode, *master_keylen);
out:
	return mkey;
}",,,302,
1815,"GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
    content::CauseForGpuLaunch cause_for_gpu_launch) {
  if (gpu_channel_.get()) {
    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||
        gpu_channel_->state() == GpuChannelHost::kConnected)
      return GetGpuChannel();
    gpu_channel_ = NULL;
  }
   int client_id = 0;
   IPC::ChannelHandle channel_handle;
  base::ProcessHandle renderer_process_for_gpu;
   content::GPUInfo gpu_info;
   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
                                                &client_id,
                                                &channel_handle,
                                               &renderer_process_for_gpu,
                                                &gpu_info)) ||
      channel_handle.name.empty() ||
 #if defined(OS_POSIX)
       channel_handle.socket.fd == -1 ||
 #endif
      renderer_process_for_gpu == base::kNullProcessHandle) {
     gpu_channel_ = NULL;
     return NULL;
  }
  gpu_channel_ = new GpuChannelHost(this, 0, client_id);
  gpu_channel_->set_gpu_info(gpu_info);
   content::GetContentClient()->SetGpuInfo(gpu_info);
  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);
   return GetGpuChannel();
 }","qemu_get_timedate* RenderThreadImpl::EstablishGpuChannelSync(
    content::CauseForGpuLaunch cause_for_gpu_launch) {
  if (gpu_channel_.get()) {
    if (gpu_channel_->state() == qemu_get_timedate::kUnconnected ||
        gpu_channel_->state() == qemu_get_timedate::kConnected)
      return GetGpuChannel();
    gpu_channel_ = NULL;
  }
   int client_id = 0;
   TCGContext::ChannelHandle channel_handle;
  base::obj renderer_process_for_gpu;
   content::GPUInfo gpu_info;
   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
                                                &client_id,
                                                &channel_handle,
                                               &renderer_process_for_gpu,
                                                &gpu_info)) ||
      channel_handle.name.empty() ||
 #if defined(OS_POSIX)
       channel_handle.socket.fd == -1 ||
 #endif
      renderer_process_for_gpu == base::kNullProcessHandle) {
     gpu_channel_ = NULL;
     return NULL;
  }
  gpu_channel_ = new qemu_get_timedate(this, 0, client_id);
  gpu_channel_->set_gpu_info(gpu_info);
   content::GetContentClient()->SetGpuInfo(gpu_info);
  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);
   return GetGpuChannel();
 }",,,304,
1818,"static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;
	clear_page(svm->vmcb);
	init_vmcb(svm);
	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}","static int shutdown_interception(struct vcpu_svm *XBZRLE)
{
	struct kvm_run *kvm_run = XBZRLE->vcpu.ivshmem_size;
	object_get_canonical_path_component(XBZRLE->vmcb);
	init_vmcb(XBZRLE);
	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}",,,256,
1820,"store_image_check(PNG_CONST png_store* ps, png_const_structp pp, int iImage)
 {
    png_const_bytep image = ps->image;
 if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)
      png_error(pp, ""image overwrite"");
 else
 {
 png_size_t cbRow = ps->cb_row;
      png_uint_32 rows = ps->image_h;
      image += iImage * (cbRow+5) * ps->image_h;
      image += 2;  
 while (rows-- > 0)
 {
 if (image[-2] != 190 || image[-1] != 239)
            png_error(pp, ""row start overwritten"");
 if (image[cbRow] != 222 || image[cbRow+1] != 173 ||
            image[cbRow+2] != 17)
            png_error(pp, ""row end overwritten"");
         image += cbRow+5;
 }
 }
}","qemu_find_nic_model(PNG_CONST png_store* ps, png_const_structp pp, int iImage)
 {
    png_const_bytep image = ps->image;
 if (image[-1] != 0xed || image[ps->DCT_I] != 0xfe)
      QTAILQ_FOREACH(pp, ""image overwrite"");
 else
 {
 png_size_t ECANCELED = ps->cb_row;
      png_uint_32 rows = ps->image_h;
      image += iImage * (ECANCELED+5) * ps->image_h;
      image += 2;  
 while (rows-- > 0)
 {
 if (image[-2] != 190 || image[-1] != 239)
            QTAILQ_FOREACH(pp, ""row start overwritten"");
 if (image[ECANCELED] != 222 || image[ECANCELED+1] != 173 ||
            image[ECANCELED+2] != 17)
            QTAILQ_FOREACH(pp, ""row end overwritten"");
         image += ECANCELED+5;
 }
 }
}",,,296,
1822,"std::string SanitizeRevision(const std::string& revision) {
  for (size_t i = 0; i < revision.length(); i++) {
    if (!(revision[i] == '@' && i == 0)
        && !(revision[i] >= '0' && revision[i] <= '9')
        && !(revision[i] >= 'a' && revision[i] <= 'z')
        && !(revision[i] >= 'A' && revision[i] <= 'Z')) {
      return std::string();
    }
  }
  return revision;
}","QEMU_PAIO_READ::string SanitizeRevision(const QEMU_PAIO_READ::string& revision) {
  for (size_t i = 0; i < revision.length(); i++) {
    if (!(revision[i] == '@' && i == 0)
        && !(revision[i] >= '0' && revision[i] <= '9')
        && !(revision[i] >= 'a' && revision[i] <= 'z')
        && !(revision[i] >= 'A' && revision[i] <= 'Z')) {
      return QEMU_PAIO_READ::string();
    }
  }
  return revision;
}",,,205,
1823,"void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;
  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
     return;
  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();
  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }","void HWVoiceIn::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;
  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
     return;
  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();
  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }",,,253,
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;
	if (tracing_disabled)
		return -ENODEV;
	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;
	m = file->private_data;
	m->private = tr;
	return 0;
}","static int gen_op_st_v(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct pci_rocker_init *m;
	int ret;
	if (tracing_disabled)
		return -ENODEV;
	ret = seq_open(file, &YADIFContext);
	if (ret)
		return ret;
	m = file->private_data;
	m->private = tr;
	return 0;
}",,,254,
1826,"static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;
	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;
	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;
	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];
		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;
	return sqrt( variance );
}","static float set_pos( void )
{
	int i;
	int numFrames;
	float bdrv_aio_flush_co_entry = 0.0f;
	float variance = 0.0f;
	if( ( clc.clock - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.clock - 1;
	for( i = 0; i < numFrames; i++ )
		bdrv_aio_flush_co_entry += clc.timeDemoDurations[ i ];
	bdrv_aio_flush_co_entry /= numFrames;
	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];
		variance += ( ( x - bdrv_aio_flush_co_entry ) * ( x - bdrv_aio_flush_co_entry ) );
	}
	variance /= numFrames;
	return sqrt( variance );
}",,,256,
1827,"static void xfer_recover(struct xfer_header *xfer)
{
    struct xfer_item *item;
    int r;
    syslog(LOG_INFO, ""XFER: recovering"");
    for (item = xfer->items; item && item->state; item = item->next) {
        switch (item->state) {
        case XFER_UNDUMPED:
        case XFER_LOCAL_MOVING:
            r = mboxlist_update(item->mbentry, 1);
            if (r) {
                syslog(LOG_ERR,
                       ""Could not back out MOVING flag during move of %s (%s)"",
                       item->mbentry->name, error_message(r));
            }
        case XFER_REMOTE_CREATED:
            if (!xfer->use_replication) {
                prot_printf(xfer->be->out,
                            ""LD1 LOCALDELETE {"" SIZE_T_FMT ""+}\r\n%s\r\n"",
                            strlen(item->extname), item->extname);
                r = getresult(xfer->be->in, ""LD1"");
                if (r) {
                    syslog(LOG_ERR,
                        ""Could not back out remote mailbox during move of %s (%s)"",
                        item->mbentry->name, error_message(r));
                }
            }
        case XFER_DEACTIVATED:
            r = xfer_mupdate(1, item->mbentry->name, item->mbentry->partition,
                             config_servername, item->mbentry->acl);
            if (r) {
                syslog(LOG_ERR,
                       ""Could not back out mupdate during move of %s (%s)"",
                       item->mbentry->name, error_message(r));
            }
        }
    }
}","static void xfer_recover(struct xfer_header *xfer)
{
    struct xfer_item *item;
    int r;
    syslog(LOG_INFO, ""XFER: recovering"");
    for (item = xfer->items; item && item->state; item = item->next) {
        switch (item->state) {
        case XFER_UNDUMPED:
        case XFER_LOCAL_MOVING:
            r = BADF(item->mbentry, 1);
            if (r) {
                syslog(LOG_ERR,
                       ""Could not back out MOVING flag during move of %s (%s)"",
                       item->mbentry->name, error_message(r));
            }
        case XFER_REMOTE_CREATED:
            if (!xfer->counts) {
                prot_printf(xfer->be->out,
                            ""LD1 LOCALDELETE {"" SIZE_T_FMT ""+}\r
%ringbuf_chr_close\r
"",
                            strlen(item->extname), item->extname);
                r = getresult(xfer->be->in, ""LD1"");
                if (r) {
                    syslog(LOG_ERR,
                        ""Could not back out remote mailbox during move of %s (%s)"",
                        item->mbentry->name, error_message(r));
                }
            }
        case XFER_DEACTIVATED:
            r = xfer_mupdate(1, item->mbentry->name, item->mbentry->partition,
                             config_servername, item->mbentry->acl);
            if (r) {
                syslog(LOG_ERR,
                       ""Could not back out mupdate during move of %s (%s)"",
                       item->mbentry->name, error_message(r));
            }
        }
    }
}",,,264,
1828,"void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   callback.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }","void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const AV_PKT_DATA_PALETTE::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::rc::UI);
   callback.qdev_get_gpio_in(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.OMAP_RO_REG(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }",,,305,
1829,"v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
    if (!location->IsObject())
         return v8::Null(m_isolate);
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
    return location;
 }","v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
    if (!location->IsObject())
         return v8::Null(m_isolate);
    v8::Local<v8::Context> psinfo = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(psinfo, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
    return location;
 }",,,314,
1830," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < model_->item_count(); ++i) {
     if (model_->items()[i].type == TYPE_APP_LIST)
      return view_model_->view_at(i);
  }
  NOTREACHED() << ""Applist button not found"";
  return NULL;
}"," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < TOKEN_MAX->item_count(); ++i) {
     if (TOKEN_MAX->items()[i].type == TYPE_APP_LIST)
      return view_model_->view_at(i);
  }
  NOTREACHED() << ""Applist button not found"";
  return NULL;
}",,,314,
1831," PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		RETURN_FALSE;
	}
}"," cpu_lduw_kernel(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(status)
 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		BdrvDirtyBitmap;
	}
}",,,256,
1837,"void	FS_Flush( fileHandle_t f ) {
	fflush(fsh[f].handleFiles.file.o);
}","void	qtest_start( TOKEN_MAX f ) {
	fflush(fsh[f].opaque.file.o);
}",,,253,
1839,"void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& current_memory) {
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      current_memory.current_blink_usage_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      current_memory.current_private_footprint_kb / 1024);
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      current_memory.current_swap_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      current_memory.current_vm_size_kb / 1024);
  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(
      current_memory);
}","void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& current_memory) {
  pdu_free(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      current_memory.current_blink_usage_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      current_memory.current_private_footprint_kb / 1024);
  pdu_free(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      current_memory.current_swap_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      current_memory.current_vm_size_kb / 1024);
  bmdma_bar::Instance().WriteIntoSharedMemory(
      current_memory);
}",,,275,
1840,"void ResourcePrefetchPredictor::Shutdown() {
  history_service_observer_.RemoveAll();
}","void ResourcePrefetchPredictor::Shutdown() {
  history_service_observer_.RemoveAll();
}",,,64,
1844,"static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;
#ifdef USE_HCACHE
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif
  for (int i = 0; i < ctx->msgcount; i++)
  {
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }
  return mutt_bcache_del(bcache, id);
 }","static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;
#ifdef USE_HCACHE
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif
  for (int i = 0; i < ctx->msgcount; i++)
  {
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }
  return mutt_bcache_del(bcache, id);
 }",,,64,
1846,"void op_addAvxRoundingMode(MCInst *MI, int v)
{
	if (MI->csh->detail) {
		MI->flat_insn->detail->x86.avx_rm = v;
	}
}","void rearm_sensor_evts(MCInst *VP56mv, int v)
{
	if (VP56mv->csh->detail) {
		VP56mv->flat_insn->detail->rsp_len.avx_rm = v;
	}
}",,,254,
1848,"cifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)
{
	return cifs_sb->master_tlink;
}","cifs_sb_master_tlink(struct E820_NR_ENTRIES *cifs_sb)
{
	return cifs_sb->arg_ptr_addr;
}",,,248,
1850,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;
	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}","on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;
	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}",,,64,
1852,"static int tight_fill_palette(VncState *vs, int x, int y,
                              size_t count, uint32_t *bg, uint32_t *fg,
                              VncPalette **palette)
{
    int max;
    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;
    if (max < 2 &&
        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {
        max = 2;
    }
    if (max >= 256) {
         max = 256;
     }
    switch(vs->clientds.pf.bytes_per_pixel) {
     case 4:
         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);
     case 2:
        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);
    default:
        max = 2;
        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);
    }
    return 0;
}","static int tight_fill_palette(VncState *vs, int x, int y,
                              size_t count, uint32_t *bg, uint32_t *fg,
                              VncPalette **palette)
{
    int max;
    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;
    if (max < 2 &&
        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {
        max = 2;
    }
    if (max >= 256) {
         max = 256;
     }
    switch(vs->clientds.pf.bdrv_cur) {
     case 4:
         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);
     case 2:
        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);
    default:
        max = 2;
        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);
    }
    return 0;
}",,,252,
1853,"int lxc_clear_config_network(struct lxc_conf *c)
{
	struct lxc_list *it,*next;
	lxc_list_for_each_safe(it, &c->network, next) {
		lxc_remove_nic(it);
	}
	return 0;
}","int lxc_clear_config_network(struct lxc_conf *c)
{
	struct lxc_list *gdb_read_register,*next;
	lxc_list_for_each_safe(gdb_read_register, &c->network, next) {
		qemu_chr_fe_claim_no_fail(gdb_read_register);
	}
	return 0;
}",,,192,
1854,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  if (!InitiateUserInteraction(true  ))
    return;
  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}","void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::n_size::UI);
  if (!InitiateUserInteraction(true  ))
    return;
  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}",,,255,
1860,"static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}","static int hdev_aio_ioctl(struct blkcipher_desc *desc, struct scatterlist *FFTContext,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
	return glue_xts_crypt_128bit(&rsp_len, desc, FFTContext, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}",,,255,
1862,"static int32_t NPN_IntFromIdentifier(NPIdentifier identifier)
{
    return static_cast<IdentifierRep*>(identifier)->number();
}","static int32_t NPN_IntFromIdentifier(NPIdentifier identifier)
{
    return static_cast<opaque*>(identifier)->number();
}",,,258,
1864,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}","int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}",,,64,
1866,"static void die(const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    if(fmt[strlen(fmt)-1] != '\n')
        printf(""\n"");
    exit(EXIT_FAILURE);
}","static void gen_neon_unzip(const char *memory_region_read_accessor, ...) {
    va_list ap;
    va_start(ap, memory_region_read_accessor);
    vprintf(memory_region_read_accessor, ap);
    if(memory_region_read_accessor[strlen(memory_region_read_accessor)-1] != '
')
        printf(""
"");
    exit(EXIT_FAILURE);
}",,,192,
1868,"qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
		const char *fmt, ...)
 {
 	va_list va;
 	struct va_format vaf;
	char nfunc[32];
	memset(nfunc, 0, sizeof(nfunc));
	memcpy(nfunc, func, sizeof(nfunc) - 1);
 	va_start(va, fmt);
	vaf.fmt = fmt;
	vaf.va = &va;
	if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
		goto ret;
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), nfunc, line,
 			  qedi->host_no, &vaf);
 	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);
 ret:
 	va_end(va);
}","qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
		const char *fmt, ...)
 {
 	va_list va;
 	struct va_format vaf;
	char nfunc[32];
	memset(nfunc, 0, sizeof(nfunc));
	memcpy(nfunc, func, sizeof(nfunc) - 1);
 	va_start(va, fmt);
	vaf.fmt = fmt;
	vaf.va = &va;
	if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
		goto ret;
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), nfunc, line,
 			  qedi->host_no, &vaf);
 	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);
 ret:
 	va_end(va);
}",,,64,
1870,"void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
    const ContentSecurityPolicy* policy_to_inherit,
    const ContentSecurityPolicy* previous_document_csp) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
   GetContentSecurityPolicy()->BindToExecutionContext(this);
  if (policy_to_inherit) {
     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else {
    if (frame_) {
       Frame* inherit_from = frame_->Tree().Parent()
                                 ? frame_->Tree().Parent()
                                 : frame_->Client()->Opener();
       if (inherit_from && frame_ != inherit_from) {
         DCHECK(inherit_from->GetSecurityContext() &&
                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
        policy_to_inherit =
            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       }
     }
    if (!policy_to_inherit)
      policy_to_inherit = previous_document_csp;
    if (policy_to_inherit &&
        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
         url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")))
      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  }
  if (policy_to_inherit && IsPluginDocument())
    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
 }","void Document::InitContentSecurityPolicy(
    MachineState* csp,
    const MachineState* policy_to_inherit,
    const MachineState* previous_document_csp) {
   SetContentSecurityPolicy(csp ? csp : MachineState::Create());
   GetContentSecurityPolicy()->BindToExecutionContext(this);
  if (policy_to_inherit) {
     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else {
    if (cpu_so) {
       Frame* inherit_from = cpu_so->Tree().Parent()
                                 ? cpu_so->Tree().Parent()
                                 : cpu_so->Client()->Opener();
       if (inherit_from && cpu_so != inherit_from) {
         DCHECK(inherit_from->GetSecurityContext() &&
                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
        policy_to_inherit =
            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       }
     }
    if (!policy_to_inherit)
      policy_to_inherit = previous_document_csp;
    if (policy_to_inherit &&
        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
         url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")))
      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  }
  if (policy_to_inherit && IsPluginDocument())
    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
 }",,,264,
1875,"static unsigned writeSignature(ucvector* out)
{
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  return 0;
}","static unsigned g_assert_not_reached(granularity* coroutine)
{
  if (!ucvector_push_back(coroutine, 137)) return 83;
  if (!ucvector_push_back(coroutine, 80)) return 83;
  if (!ucvector_push_back(coroutine, 78)) return 83;
  if (!ucvector_push_back(coroutine, 71)) return 83;
  if (!ucvector_push_back(coroutine, 13)) return 83;
  if (!ucvector_push_back(coroutine, 10)) return 83;
  if (!ucvector_push_back(coroutine, 26)) return 83;
  if (!ucvector_push_back(coroutine, 10)) return 83;
  return 0;
}",,,249,
1877,"FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += source_name;
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}","ogg_stream::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!INTFLOAT.net_rx_pkt_attach_iovec_ex()) {
		INTFLOAT += "";"";
	}
	INTFLOAT += source_name;
	INTFLOAT += ""="";
	INTFLOAT += target_name;
}",,,254,
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;
	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}","TIFFFdOpen(int LOG_GUEST_ERROR, const char* name, const char* mode)
{
	TIFF* tif;
	tif = TIFFClientOpen(name, mode,  get_filtered_video_frame
	    (virtio_balloon_save) LOG_GUEST_ERROR,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = LOG_GUEST_ERROR;
	return (tif);
}",,,307,
1887,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;
	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}","timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;
	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * extradata) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}",,,254,
1893,"w3m_exit(int i)
{
#ifdef USE_MIGEMO
    init_migemo();		 
#endif
    stopDownload();
    deleteFiles();
#ifdef USE_SSL
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
 #endif
     exit(i);
 }","w3m_exit(int i)
{
#ifdef USE_MIGEMO
    target_rt_restore_ucontext();		 
#endif
    stopDownload();
    deleteFiles();
#ifdef qdev_hot_added
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
 #endif
     exit(i);
 }",,,192,
1895," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };
  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true  , base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}"," void CoordinatorImpl::trace_thread_pool_submit(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const lo& callback) {
   auto adapter =
       [](const lo& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };
  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true  , OptsVisitor::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, OptsVisitor::BindRepeating(adapter, callback));
}",,,303,
1897,"static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();
	if (!self) {
		RETURN_FALSE;
	}
	ZIP_FROM_OBJECT(intern, self);
	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}","static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *nb_segments = getThis();
	if (!nb_segments) {
		RETURN_FALSE;
	}
	ZIP_FROM_OBJECT(intern, nb_segments);
	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}",,,251,
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }","    StateBase* handleError(Status errorStatus, const String& message, StateBase* M68K_FEATURE_EXT_FULL)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (M68K_FEATURE_EXT_FULL) {
            StateBase* tmp = M68K_FEATURE_EXT_FULL->nextState();
            delete M68K_FEATURE_EXT_FULL;
            M68K_FEATURE_EXT_FULL = tmp;
        }
        return new ErrorState;
    }",,,312,
1900,"void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;
    RenderObject* rootBackgroundRenderer = rendererForRootBackground();
    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);
    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
}","void opaque::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;
    RenderObject* rootBackgroundRenderer = rendererForRootBackground();
    const FillLayer* aio_signal_handler = rootBackgroundRenderer->style()->helper_retry();
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);
    paintFillLayers(paintInfo, bgColor, aio_signal_handler, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
}",,,307,
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;
	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;
	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;
	skb_queue_head_init(&sn->queue);
	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);
	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;
	rose_loopback_neigh = write_odml_master(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;
	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->aio_signal_handler     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = opaque++;
	sn->restarted = 1;
	skb_queue_head_init(&sn->queue);
	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);
	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}",,,309,
1905,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 	if (!asoc)
 		return -EINVAL;
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;
	if (!sctp_style(sk, UDP))
		return -EINVAL;
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;
	sctp_copy_sock(sock->sk, sk, asoc);
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);
	*sockp = sock;
	return err;
}","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 	if (!asoc)
 		return -EINVAL;
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;
	if (!sctp_style(sk, UDP))
		return -EINVAL;
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;
	sctp_copy_sock(sock->sk, sk, asoc);
	sp->pf->to_sk_daddr(&asoc->AddressSpaceDispatch.primary_addr, sk);
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);
	*sockp = sock;
	return err;
}",,,256,
1907,"spnego_gss_wrap_iov(OM_uint32 *minor_status,
		    gss_ctx_id_t context_handle,
		    int conf_req_flag,
		    gss_qop_t qop_req,
		    int *conf_state,
		    gss_iov_buffer_desc *iov,
 		    int iov_count)
 {
 	OM_uint32 ret;
 	ret = gss_wrap_iov(minor_status,
			   context_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
			   iov,
			   iov_count);
	return (ret);
}","scsi_disk_emulate_read_toc(elementary_transfer_size *minor_status,
		    gss_ctx_id_t context_handle,
		    int conf_req_flag,
		    gss_qop_t tcg_cmp,
		    int *conf_state,
		    gss_iov_buffer_desc *iov,
 		    int iov_count)
 {
 	elementary_transfer_size ret;
 	ret = scsi_cmd_lba(minor_status,
			   context_handle,
 			   conf_req_flag,
 			   tcg_cmp,
 			   conf_state,
			   iov,
			   iov_count);
	return (ret);
}",,,295,
1908," ptaReadStream(FILE  *fp)
 {
char       typestr[128];
 l_int32    i, n, ix, iy, type, version;
 l_float32  x, y;
 PTA       *pta;
    PROCNAME(""ptaReadStream"");
    if (!fp)
        return (PTA *)ERROR_PTR(""stream not defined"", procName, NULL);
    if (fscanf(fp, ""\n Pta Version %d\n"", &version) != 1)
         return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
     if (version != PTA_VERSION_NUMBER)
         return (PTA *)ERROR_PTR(""invalid pta version"", procName, NULL);
    if (fscanf(fp, "" Number of pts = %d; format = %s\n"", &n, typestr) != 2)
         return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
     if (!strcmp(typestr, ""float""))
         type = 0;
    else   
        type = 1;
    if ((pta = ptaCreate(n)) == NULL)
        return (PTA *)ERROR_PTR(""pta not made"", procName, NULL);
    for (i = 0; i < n; i++) {
        if (type == 0) {   
            if (fscanf(fp, ""   (%f, %f)\n"", &x, &y) != 2) {
                ptaDestroy(&pta);
                return (PTA *)ERROR_PTR(""error reading floats"", procName, NULL);
            }
            ptaAddPt(pta, x, y);
        } else {    
            if (fscanf(fp, ""   (%d, %d)\n"", &ix, &iy) != 2) {
                ptaDestroy(&pta);
                return (PTA *)ERROR_PTR(""error reading ints"", procName, NULL);
            }
            ptaAddPt(pta, ix, iy);
        }
    }
    return pta;
}"," ptaReadStream(FILE  *CPUAlphaState)
 {
char       typestr[128];
 l_int32    i, n, ix, iy, type, version;
 l_float32  x, y;
 PTA       *pta;
    PROCNAME(""ptaReadStream"");
    if (!CPUAlphaState)
        return (PTA *)ERROR_PTR(""stream not defined"", procName, NULL);
    if (fscanf(CPUAlphaState, ""
 Pta Version %d
"", &version) != 1)
         return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
     if (version != PTA_VERSION_NUMBER)
         return (PTA *)ERROR_PTR(""invalid pta version"", procName, NULL);
    if (fscanf(CPUAlphaState, "" Number of pts = %d; format = %s
"", &n, typestr) != 2)
         return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
     if (!strcmp(typestr, ""float""))
         type = 0;
    else   
        type = 1;
    if ((pta = ptaCreate(n)) == NULL)
        return (PTA *)ERROR_PTR(""pta not made"", procName, NULL);
    for (i = 0; i < n; i++) {
        if (type == 0) {   
            if (fscanf(CPUAlphaState, ""   (%f, %f)
"", &x, &y) != 2) {
                ptaDestroy(&pta);
                return (PTA *)ERROR_PTR(""error reading floats"", procName, NULL);
            }
            ptaAddPt(pta, x, y);
        } else {    
            if (fscanf(CPUAlphaState, ""   (%d, %d)
"", &ix, &iy) != 2) {
                ptaDestroy(&pta);
                return (PTA *)ERROR_PTR(""error reading ints"", procName, NULL);
            }
            ptaAddPt(pta, ix, iy);
        }
    }
    return pta;
}",,,253,
1910,"void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}","void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}",,,64,
1912," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }"," void op2::RegisterPrefs(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }",,,256,
1916,"rdpsnddbg_process(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *buf;
 	pkglen = s->end - s->p;
 	buf = (char *) xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);
	xfree(buf);
}","rdpsnddbg_process(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *DIRTY_MEMORY_MIGRATION;
 	pkglen = s->end - s->p;
 	DIRTY_MEMORY_MIGRATION = (char *) xmalloc(pkglen + 1);
	STRNCPY(DIRTY_MEMORY_MIGRATION, (char *) s->p, pkglen + 1);
	str_handle_lines(DIRTY_MEMORY_MIGRATION, &rest, rdpsnddbg_line_handler, NULL);
	xfree(DIRTY_MEMORY_MIGRATION);
}",,,305,
1917,"bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
}","object_get_canonical_path_component(register const struct tok *lp, register const char *fmt,
	   register local_err v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
}",,,192,
1919,"void WebLocalFrameImpl::ReplaceSelection(const WebString& text) {
  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  GetFrame()->GetEditor().ReplaceSelection(text);
}","void progress_cond::ReplaceSelection(const WebString& qtest_chrdev) {
  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  GetFrame()->NewObject().ReplaceSelection(qtest_chrdev);
}",,,255,
1923,  uint64_t received_page_id() const { return received_page_id_; },  uint64_t received_page_id() const { return tail; },,,192,
1924,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }
  return size;
}","irq_bit::Size ScaleSizeToFitView(const irq_bit::Size& size,
                             const irq_bit::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.gen_ieee_input() > view_size.gen_ieee_input()) ||
      (size.width() < view_size.width() &&
       size.gen_ieee_input() < view_size.gen_ieee_input())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.gen_ieee_input() / static_cast<float>(size.gen_ieee_input()));
    return irq_bit::ScaleToFlooredSize(size, scale);
  }
  return size;
}",,,312,
1925,"void GLES2DecoderImpl::DoVertexAttribI4iv(GLuint index,
                                          const volatile GLint* v) {
  GLint t[4] = {v[0], v[1], v[2], v[3]};
  if (SetVertexAttribValue(""glVertexAttribI4iv"", index, t)) {
    state_.SetGenericVertexAttribBaseType(
        index, SHADER_VARIABLE_INT);
    api()->glVertexAttribI4ivFn(index, t);
  }
}","void extradata::ff_nut_free_sp(GLuint index,
                                          const volatile GLint* QEDRequest) {
  GLint t[4] = {QEDRequest[0], QEDRequest[1], QEDRequest[2], QEDRequest[3]};
  if (SetVertexAttribValue(""glVertexAttribI4iv"", index, t)) {
    state_.SetGenericVertexAttribBaseType(
        index, SHADER_VARIABLE_INT);
    api()->glVertexAttribI4ivFn(index, t);
  }
}",,,314,
1927,"long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}","long long __org_qemu_x_Union1::cpu_get_ioreq() const
{
    return slb;
}",,,255,
1928," static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
 	ut8 op_MSB,op_LSB;
 	int ret;
	if (!data)
 		return 0;
 	memset (op, '\0', sizeof (RAnalOp));
 	op->addr = addr;
 	op->type = R_ANAL_OP_TYPE_UNK;
	op->jump = op->fail = -1;
	op->ptr = op->val = -1;
	op->size = 2;
	op_MSB = anal->big_endian? data[0]: data[1];
	op_LSB = anal->big_endian? data[1]: data[0];
	ret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));
	return ret;
}"," static int flush_put_bits(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
 	ut8 op_MSB,op_LSB;
 	int ret;
	if (!data)
 		return 0;
 	memset (op, '\0', sizeof (RAnalOp));
 	op->addr = addr;
 	op->type = pictq_cond;
	op->log_dest = op->fail = -1;
	op->ptr = op->val = -1;
	op->size = 2;
	op_MSB = anal->big_endian? data[0]: data[1];
	op_LSB = anal->big_endian? data[1]: data[0];
	ret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));
	return ret;
}",,,254,
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	has_wait ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : counts,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}",,,281,
1932,"void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);
    if (t -> Data) return;     
     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 }","void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);
    if (t -> VirtIONetPCI) return;     
     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
    t-> VirtIONetPCI = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->VirtIONetPCI == NULL) {
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 }",,,253,
1933,"sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}","SPAPR_MACHINE(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	QPCI_PIO_LIMIT = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}",,,192,
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}","static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}",,,64,
1935,"void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  ui::WindowShowState show_state) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(session_id_, bounds, show_state);
}","void Browser::SaveWindowPlacement(const gfx::Rect& cluster_data,
                                  ui::WindowShowState show_state) {
  buf* session_service =
      SessionServiceFactory::GetForProfileIfExisting(qbool_get_bool());
  if (session_service)
    session_service->SetWindowBounds(session_id_, cluster_data, show_state);
}",,,312,
1939," FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
 }"," start_index* DirectoryEntrySync::mov_read_mdhd(const String& AddressSpaceDispatch, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->mov_read_mdhd(this, AddressSpaceDispatch, flags, helper->successCallback(), helper->omap_timer_clk_setup(), DOMFileSystemBase::Synchronous);
     return static_cast<start_index*>(helper->getResult(exceptionState));
 }",,,312,
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;
	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;
	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);
	return rv;
}","int avfilter_default_get_audio_buffer(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;
	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;
	if (channel >= max_compat) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, max_compat);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);
	return rv;
}",,,253,
1943,"void MediaRecorder::ScheduleDispatchEvent(Event* event) {
  scheduled_events_.push_back(event);
  dispatch_scheduled_event_runner_->RunAsync();
}","void MediaRecorder::ScheduleDispatchEvent(progress_cond* event) {
  scheduled_events_.push_back(event);
  hsub->RunAsync();
}",,,254,
1944," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }"," RoqTempdata::string CPU(const RoqTempdata::string& brand) {
   DCHECK(!brand.empty());
  RoqTempdata::string data(kPostXml);
  const RoqTempdata::string qdev_get_gpio_in(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(qdev_get_gpio_in);
  DCHECK(placeholder_pos != RoqTempdata::string::SOL_SOCKET);
  data.replace(placeholder_pos, qdev_get_gpio_in.size(), brand);
  return data;
 }",,,311,
1945,"static inline int pix_abs16_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
{
    int s, i;
    s = 0;
    for(i=0;i<h;i++) {
        s += abs(pix1[0] - pix2[0]);
        s += abs(pix1[1] - pix2[1]);
        s += abs(pix1[2] - pix2[2]);
        s += abs(pix1[3] - pix2[3]);
        s += abs(pix1[4] - pix2[4]);
        s += abs(pix1[5] - pix2[5]);
        s += abs(pix1[6] - pix2[6]);
        s += abs(pix1[7] - pix2[7]);
        s += abs(pix1[8] - pix2[8]);
        s += abs(pix1[9] - pix2[9]);
        s += abs(pix1[10] - pix2[10]);
        s += abs(pix1[11] - pix2[11]);
        s += abs(pix1[12] - pix2[12]);
        s += abs(pix1[13] - pix2[13]);
        s += abs(pix1[14] - pix2[14]);
        s += abs(pix1[15] - pix2[15]);
        pix1 += line_size;
        pix2 += line_size;
    }
    return s;
}","static inline int fixup_vorbis_headers(void *ADBDeviceClass, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
{
    int s, i;
    s = 0;
    for(i=0;i<h;i++) {
        s += abs(pix1[0] - pix2[0]);
        s += abs(pix1[1] - pix2[1]);
        s += abs(pix1[2] - pix2[2]);
        s += abs(pix1[3] - pix2[3]);
        s += abs(pix1[4] - pix2[4]);
        s += abs(pix1[5] - pix2[5]);
        s += abs(pix1[6] - pix2[6]);
        s += abs(pix1[7] - pix2[7]);
        s += abs(pix1[8] - pix2[8]);
        s += abs(pix1[9] - pix2[9]);
        s += abs(pix1[10] - pix2[10]);
        s += abs(pix1[11] - pix2[11]);
        s += abs(pix1[12] - pix2[12]);
        s += abs(pix1[13] - pix2[13]);
        s += abs(pix1[14] - pix2[14]);
        s += abs(pix1[15] - pix2[15]);
        pix1 += line_size;
        pix2 += line_size;
    }
    return s;
}",,,192,
1948,"struct http_req_action_kw *action_http_req_custom(const char *kw)
{
	if (!LIST_ISEMPTY(&http_req_keywords.list)) {
		struct http_req_action_kw_list *kw_list;
		int i;
		list_for_each_entry(kw_list, &http_req_keywords.list, list) {
			for (i = 0; kw_list->kw[i].kw != NULL; i++) {
				if (!strcmp(kw, kw_list->kw[i].kw))
					return &kw_list->kw[i];
			}
		}
	}
	return NULL;
}","struct http_req_action_kw *get_bits(const char *kw)
{
	if (!LIST_ISEMPTY(&child_name.list)) {
		struct http_req_action_kw_list *kw_list;
		int i;
		tcg_gen_insn_start(kw_list, &child_name.list, list) {
			for (i = 0; kw_list->kw[i].kw != NULL; i++) {
				if (!strcmp(kw, kw_list->kw[i].kw))
					return &kw_list->kw[i];
			}
		}
	}
	return NULL;
}",,,314,
1949,"u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;
	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;
	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;
		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}
	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);
	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}","u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;
	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[dma - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;
	if (likely(!mtu)) {
		struct qemu_irq *fnhe;
		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}
	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);
	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}",,,313,
1951,"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return;  
			}
			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);
#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}","		void CWebServer::pdu_unmarshal(WebEmSession & session, const request& req, Json::Value &next_map)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return;  
			}
			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			next_map[""status""] = ""OK"";
			next_map[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				iov.m_eventsystem.RemoveSingleState(idx, iov.m_eventsystem.REASON_DEVICE);
#ifdef ENABLE_PYTHON
			iov.m_pluginsystem.DeviceModified(idx);
#endif
		}",,,312,
1952,"static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,
		const iw_byte *d, size_t d_len)
{
	struct iw_exif_state e;
	iw_uint32 ifd;
	if(d_len<8) return;
	iw_zeromem(&e,sizeof(struct iw_exif_state));
	e.d = d;
	e.d_len = d_len;
 	e.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;
	ifd = iw_get_ui32_e(&d[4],e.endian);
 	iwjpeg_scan_exif_ifd(rctx,&e,ifd);
 }","static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,
		const iw_byte *d, size_t GtkAccelGroupEntry)
{
	struct iw_exif_state e;
	iw_uint32 ifd;
	if(GtkAccelGroupEntry<8) return;
	iw_zeromem(&e,sizeof(struct iw_exif_state));
	e.d = d;
	e.GtkAccelGroupEntry = GtkAccelGroupEntry;
 	e.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;
	ifd = iw_get_ui32_e(&d[4],e.endian);
 	iwjpeg_scan_exif_ifd(rctx,&e,ifd);
 }",,,254,
1953," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}"," void InfoBarContainer::bdrv_set_dirty_bitmap(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::wsaddr,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}",,,309,
1960,"atol10(const char *p, size_t char_cnt)
{
 	uint64_t l;
 	int digit;
 	l = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
		l = (l * 10) + digit;
		digit = *++p - '0';
	}
	return (l);
}","object_property_set_bool(const char *p, size_t op2)
{
 	uint64_t l;
 	int pmsav7_dregion;
 	l = 0;
 	pmsav7_dregion = *p - '0';
 	while (pmsav7_dregion >= 0 && pmsav7_dregion < 10  && op2-- > 0) {
		l = (l * 10) + pmsav7_dregion;
		pmsav7_dregion = *++p - '0';
	}
	return (l);
}",,,254,
1971,"void avcc_del(GF_Box *s)
{
	GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;
	if (ptr->config) gf_odf_avc_cfg_del(ptr->config);
	gf_free(ptr);
}","void g_malloc(GF_Box *s)
{
	coeff_partition *ptr = (coeff_partition *)s;
	if (ptr->config) gf_odf_avc_cfg_del(ptr->config);
	gf_free(ptr);
}",,,192,
1972,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;
    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }
     current_element = object->child;
     if (case_sensitive)
     {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
         }
     }
     return current_element;
 }","static cJSON *object_property_set_bool(const cJSON * const object, const char * const name, const ioservid AVFilterFormats)
{
    cJSON *current_element = NULL;
    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }
     current_element = object->child;
     if (AVFilterFormats)
     {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
         }
     }
     return current_element;
 }",,,254,
1974,"void GLES2Implementation::DeleteTransferCacheEntry(uint32_t type, uint32_t id) {
  NOTREACHED();
}","void HEVCSPS::DeleteTransferCacheEntry(uint32_t type, uint32_t M68K_FEATURE_EXT_FULL) {
  NOTREACHED();
}",,,308,
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;
	idle = compat_alloc_user_space(sizeof(*idle));
	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);
	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}","static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct fs_eth __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;
	idle = bdrv_pwrite(sizeof(*idle));
	err = sys_ioctl(fd, pull, (unsigned long) idle);
	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}",,,314,
1979,"void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }
  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}","void s390_cpu_machine_reset_cb::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }
  if (TCG_COND_GE != -1) {
    if (index == TCG_COND_GE) {
      return;
    }
    if (index > TCG_COND_GE) {
      index--;
     }
   }
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}",,,296,
1980,"int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;
	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);
	return r;
}","int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int iov_base;
	mutex_lock(&kvm->slots_lock);
	iov_base = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);
	return iov_base;
}",,,254,
1983,"gsicc_new_devicen(gsicc_manager_t *icc_manager)
{
    gsicc_devicen_entry_t *device_n_entry =
        gs_alloc_struct(icc_manager->memory, gsicc_devicen_entry_t,
                &st_gsicc_devicen_entry, ""gsicc_new_devicen"");
    if (device_n_entry == NULL)
        return gs_throw(gs_error_VMerror, ""insufficient memory to allocate device n profile"");
    device_n_entry->next = NULL;
    device_n_entry->iccprofile = NULL;
    if ( icc_manager->device_n == NULL ) {
        icc_manager->device_n = gs_alloc_struct(icc_manager->memory,
            gsicc_devicen_t, &st_gsicc_devicen, ""gsicc_new_devicen"");
        if (icc_manager->device_n == NULL)
            return gs_throw(gs_error_VMerror, ""insufficient memory to allocate device n profile"");
        icc_manager->device_n->head = device_n_entry;
        icc_manager->device_n->final = device_n_entry;
        icc_manager->device_n->count = 1;
        return 0;
    } else {
        icc_manager->device_n->final->next = device_n_entry;
        icc_manager->device_n->final = device_n_entry;
        icc_manager->device_n->count++;
        return 0;
    }
}","gsicc_new_devicen(gsicc_manager_t *icc_manager)
{
    gsicc_devicen_entry_t *device_n_entry =
        gen_jumpi_check_loop_end(icc_manager->memory, gsicc_devicen_entry_t,
                &st_gsicc_devicen_entry, ""gsicc_new_devicen"");
    if (device_n_entry == NULL)
        return gs_throw(qidx, ""insufficient memory to allocate device n profile"");
    device_n_entry->next = NULL;
    device_n_entry->iccprofile = NULL;
    if ( icc_manager->device_n == NULL ) {
        icc_manager->device_n = gen_jumpi_check_loop_end(icc_manager->memory,
            cvtts, &st_gsicc_devicen, ""gsicc_new_devicen"");
        if (icc_manager->device_n == NULL)
            return gs_throw(qidx, ""insufficient memory to allocate device n profile"");
        icc_manager->device_n->head = device_n_entry;
        icc_manager->device_n->final = device_n_entry;
        icc_manager->device_n->count = 1;
        return 0;
    } else {
        icc_manager->device_n->final->next = device_n_entry;
        icc_manager->device_n->final = device_n_entry;
        icc_manager->device_n->count++;
        return 0;
    }
}",,,250,
1984,"void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }
    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();
    scrollToSelection();
}","void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        test_keyval_visit_alternate(false);
    const Vector<HTMLElement*>& items = listItems();
    int table_data = optionToListIndex(index);
    if (table_data >= 0) {
        HTMLElement* element = items[table_data];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | dr_enabled);
        }
    }
    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();
    scrollToSelection();
}",,,288,
1988,"static TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,
					   size_t size)
{
	struct bignum **bn = attr;
	return crypto_bignum_bin2bn(buffer, size, *bn);
}","static TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,
					   size_t size)
{
	struct cues_parsing_deferred **kernel = attr;
	return g_assert_not_reached(buffer, size, *kernel);
}",,,255,
1995,"  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }","  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::PCI_CLASS_STORAGE_IDE> args[] = {v8::x86_class::esp_init(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::esp_init(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }",,,313,
1997,"ZEND_METHOD(CURLFile, getMimeType)
{
	curlfile_get_property(""mime"", INTERNAL_FUNCTION_PARAM_PASSTHRU);
}","ZEND_METHOD(LOG_GUEST_ERROR, getMimeType)
{
	curlfile_get_property(""mime"", INTERNAL_FUNCTION_PARAM_PASSTHRU);
}",,,256,
1999," void AppCacheGroup::RemoveCache(AppCache* cache) {
   DCHECK(cache->associated_hosts().empty());
   if (cache == newest_complete_cache_) {
    CancelUpdate();
     AppCache* tmp_cache = newest_complete_cache_;
     newest_complete_cache_ = nullptr;
     tmp_cache->set_owning_group(nullptr);   
   } else {
     scoped_refptr<AppCacheGroup> protect(this);
    Caches::iterator it =
        std::find(old_caches_.begin(), old_caches_.end(), cache);
    if (it != old_caches_.end()) {
      AppCache* tmp_cache = *it;
      old_caches_.erase(it);
      tmp_cache->set_owning_group(nullptr);   
    }
    if (!is_obsolete() && old_caches_.empty() &&
        !newly_deletable_response_ids_.empty()) {
      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);
      newly_deletable_response_ids_.clear();
    }
  }
}"," void dev::RemoveCache(AppCache* cache) {
   DCHECK(cache->associated_hosts().empty());
   if (cache == newest_complete_cache_) {
    CancelUpdate();
     AppCache* tmp_cache = newest_complete_cache_;
     newest_complete_cache_ = nullptr;
     tmp_cache->set_owning_group(nullptr);   
   } else {
     scoped_refptr<dev> protect(this);
    Caches::iterator it =
        std::find(old_caches_.begin(), old_caches_.end(), cache);
    if (it != old_caches_.end()) {
      AppCache* tmp_cache = *it;
      old_caches_.erase(it);
      tmp_cache->set_owning_group(nullptr);   
    }
    if (!is_obsolete() && old_caches_.empty() &&
        !newly_deletable_response_ids_.empty()) {
      storage_->DeleteResponses(PCDIMMDeviceClass, newly_deletable_response_ids_);
      newly_deletable_response_ids_.s390_init_ipl_dev();
    }
  }
}",,,303,
2001,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
  GetTabAt(index)->set_closing(true);
}","void TabStripGtk::spice_server_migrate_switch(extent* contents, int nut) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(nut, contents->qdict_get());
  GetTabAt(nut)->set_closing(true);
}",,,306,
2006,"int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr newattrs;
	newattrs.ia_valid = ATTR_FORCE | kill;
	return notify_change(dentry, &newattrs);
}","int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr fd;
	fd.ia_valid = tcp_chr_tls_handshake | kill;
	return surface_height(dentry, &fd);
}",,,254,
2011,"SECURITY_STATUS SEC_ENTRY ApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput)
{
	return SEC_E_OK;
}","SECURITY_STATUS MAX_NETFNS ApplyControlToken(PCtxtHandle phContext, PSecBufferDesc VSCSIState)
{
	return SEC_E_OK;
}",,,256,
2012,"SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
     int i;
     CARD16 *in_devices = (CARD16 *) &stuff[1];
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_devices + i);
    }
    return ProcXFixesVector[stuff->xfixesReqType] (client);
}","SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
     int i;
     CARD16 *in_devices = (CARD16 *) &stuff[1];
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_devices + i);
    }
    return ProcXFixesVector[stuff->qxl] (client);
}",,,302,
2013,"WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}","WebPlugin* RenderView::vhost_user_write(
    HEVCSPS* MEMTX_OK,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      MEMTX_OK, params, path, mime_type, AsWeakPtr());
}",,,256,
2017,"static int handle_vmptrst(struct kvm_vcpu *vcpu)
{
	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
	u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
	gva_t vmcs_gva;
	struct x86_exception e;
	if (!nested_vmx_check_permission(vcpu))
		return 1;
 	if (get_vmx_mem_address(vcpu, exit_qualification,
 			vmx_instruction_info, true, &vmcs_gva))
 		return 1;
 	if (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,
 				 (void *)&to_vmx(vcpu)->nested.current_vmptr,
 				 sizeof(u64), &e)) {
		kvm_inject_page_fault(vcpu, &e);
		return 1;
	}
	nested_vmx_succeed(vcpu);
	return kvm_skip_emulated_instruction(vcpu);
}","static int handle_vmptrst(struct kvm_vcpu *vcpu)
{
	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
	u32 local_err = vmcs_read32(VMX_INSTRUCTION_INFO);
	gva_t vmcs_gva;
	struct x86_exception e;
	if (!nested_vmx_check_permission(vcpu))
		return 1;
 	if (get_vmx_mem_address(vcpu, exit_qualification,
 			local_err, true, &vmcs_gva))
 		return 1;
 	if (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,
 				 (void *)&to_vmx(vcpu)->nested.AddressSpaceDispatch,
 				 sizeof(u64), &e)) {
		kvm_inject_page_fault(vcpu, &e);
		return 1;
	}
	nested_vmx_succeed(vcpu);
	return kvm_skip_emulated_instruction(vcpu);
}",,,306,
2018,"PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;
    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }
    return result;
}","PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;
    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);
    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[opaque])
            (client);
        if (result != Success)
            break;
    }
    return result;
}",,,303,
2020,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;
	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}","static int dcbnl_getstate(struct net_device *pci_rocker_init, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	if (!pci_rocker_init->dcbnl_ops->getstate)
		return -EOPNOTSUPP;
	return nla_put_u8(skb, DCB_ATTR_STATE,
			  pci_rocker_init->dcbnl_ops->getstate(pci_rocker_init));
}",,,254,
2021,"static bool valid_cr(int nr)
{
	switch (nr) {
	case 0:
	case 2 ... 4:
	case 8:
		return true;
	default:
		return false;
	}
}","static bool valid_cr(int nr)
{
	switch (nr) {
	case 0:
	case 2 ... 4:
	case 8:
		return true;
	default:
		return EPN;
	}
}",,,192,
2022," void BlobURLRegistry::unregisterURL(const KURL& url)
 {
    ThreadableBlobRegistry::unregisterBlobURL(url);
 }"," void BlobURLRegistry::unregisterURL(const KURL& CPUOpenRISCState)
 {
    ThreadableBlobRegistry::unregisterBlobURL(CPUOpenRISCState);
 }",,,254,
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;
  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}","void wdt_diag288_class_init(struct QPCI_PIO_LIMIT *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;
  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}",,,192,
2025,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;
    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;
    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;
    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;
    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}","VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.chr_close = NULL;
    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;
    if (g_assert_not_reached(pContext))
        qInfo.TagHeader.props = pPacketInfo->Vlan.props;
    if(qInfo.chr_close != NULL)
        pContext->extraStatistics.framesRxPriority++;
    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.chr_close;
}",,,255,
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;
	err = sock->ops->ioctl(sock, cmd, arg);
	if (err != -ENOIOCTLCMD)
		return err;
	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}","static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;
	err = sock->ops->ioctl(sock, cmd, arg);
	if (err != -ENOIOCTLCMD)
		return err;
	if (cmd == SIOCGIFCONF) {
		struct bmdma_bar ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct bmdma_bar)))
			return -EFAULT;
		scsi_req_ref();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct bmdma_bar)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}",,,307,
2034," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())   
    return;
#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);
  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}"," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::qemu_input_event_send())   
    return;
#if defined(stdio_nb_clients)
  if (!local_err)
    local_err = new bind(this);
  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        local_err,
        RenderThreadImpl::qemu_input_event_send()->video_capture_impl_manager(),
        RenderThreadImpl::qemu_input_event_send()->GetMediaStreamDependencyFactory());
  }
#endif
}",,,308,
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }",,,64,
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		p->unregistering = ERR_PTR(-EINVAL);
	}
	erase_header(p);
}","static void start_unregistering(struct ctl_table_header *p)
{
	if (visit_check_struct(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->rc = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		p->rc = ERR_PTR(-exynos4210_combiner_ops);
	}
	erase_header(p);
}",,,292,
2039,"static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)
{
	put_page(spd->pages[i]);
}","static void vapic_class_init(struct splice_pipe_desc *device_id, unsigned int i)
{
	put_page(device_id->BDRV_SECTOR_BITS[i]);
}",,,255,
2042,"INST_HANDLER (sleep) {	 
	ESIL_A (""BREAK"");
}","INST_HANDLER (QPCI_PIO_LIMIT) {	 
	ESIL_A (""BREAK"");
}",,,192,
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;
  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}","void SplashOutputDev::clipToStrokePath(GfxState *RTAS_OUT_NO_SUCH_INDICATOR) {
  SplashPath *path, *path2;
  path = convertPath(RTAS_OUT_NO_SUCH_INDICATOR, RTAS_OUT_NO_SUCH_INDICATOR->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, counts);
  delete path2;
}",,,256,
2046,"void ContextState::RestoreRenderbufferBindings() {
  bound_renderbuffer_valid = false;
}","void AACEncContext::set_pos() {
  speedmask = false;
}",,,254,
2053,"static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
	struct shmem_sb_info config = *sbinfo;
 	unsigned long inodes;
 	int error = -EINVAL;
 	if (shmem_parse_options(data, &config, true))
 		return error;
	spin_lock(&sbinfo->stat_lock);
	inodes = sbinfo->max_inodes - sbinfo->free_inodes;
	if (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)
		goto out;
	if (config.max_inodes < inodes)
		goto out;
	if (config.max_blocks && !sbinfo->max_blocks)
		goto out;
	if (config.max_inodes && !sbinfo->max_inodes)
		goto out;
	error = 0;
	sbinfo->max_blocks  = config.max_blocks;
 	sbinfo->max_inodes  = config.max_inodes;
 	sbinfo->free_inodes = config.max_inodes - inodes;
	mpol_put(sbinfo->mpol);
	sbinfo->mpol        = config.mpol;	 
 out:
 	spin_unlock(&sbinfo->stat_lock);
 	return error;
}","static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
	struct shmem_sb_info config = *sbinfo;
 	unsigned long inodes;
 	int error = -EINVAL;
 	if (shmem_parse_options(data, &config, true))
 		return error;
	spin_lock(&sbinfo->stat_lock);
	inodes = sbinfo->max_inodes - sbinfo->free_inodes;
	if (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)
		goto out;
	if (config.max_inodes < inodes)
		goto out;
	if (config.max_blocks && !sbinfo->max_blocks)
		goto out;
	if (config.max_inodes && !sbinfo->max_inodes)
		goto out;
	error = 0;
	sbinfo->max_blocks  = config.max_blocks;
 	sbinfo->max_inodes  = config.max_inodes;
 	sbinfo->free_inodes = config.max_inodes - inodes;
	mpol_put(sbinfo->mpol);
	sbinfo->mpol        = config.mpol;	 
 out:
 	spin_unlock(&sbinfo->stat_lock);
 	return error;
}",,,64,
2055,"cJSON *cJSON_CreateString( const char *string )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->type = cJSON_String;
		item->valuestring = cJSON_strdup( string );
	}
	return item;
}","cJSON *qemu_mutex_init( const char *string )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->VirtIOS390DeviceClass = cJSON_String;
		item->load = cJSON_strdup( string );
	}
	return item;
}",,,255,
2058,"bool Browser::IsPopup(const TabContents* source) const {
  return !!(type() & TYPE_POPUP);
}","bool gprh::IsPopup(const TabContents* source) const {
  return !!(pa_simple_free() & TYPE_POPUP);
}",,,317,
2059,"void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);
  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;
  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}","void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& opaque,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = g_malloc(
      common_params.espdma_memory_read_write, opaque.navigation_timing,
      common_params.input_start);
  navigation_params->is_user_activated =
      opaque.was_activated == WasActivatedOption::kYes;
  if (opaque.origin_to_commit) {
    navigation_params->origin_to_commit =
        opaque.origin_to_commit.BADF();
  }
}",,,311,
2061,  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); },  LM32_JUART() { visitor->qsb_create(disas_set_info); },,,218,
2062,"static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;
	close_command.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&close_command, sizeof(close_command));
}","static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;
	close_command.port = port->port_number + 1;
	return qdev_get_gpio_in(port, dc0splat,
			(DBEContext *)&close_command, sizeof(close_command));
}",,,255,
2063,"bool CanRendererHandleEvent(const ui::MouseEvent* event) {
  if (event->type() == ui::ET_MOUSE_CAPTURE_CHANGED)
    return false;
#if defined(OS_WIN)
  switch (event->native_event().message) {
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
     case WM_XBUTTONDBLCLK:
     case WM_NCMOUSELEAVE:
     case WM_NCMOUSEMOVE:
     case WM_NCXBUTTONDOWN:
     case WM_NCXBUTTONUP:
     case WM_NCXBUTTONDBLCLK:
      return false;
    default:
      break;
  }
#endif
  return true;
}","bool CanRendererHandleEvent(const ui::CR_WAITEN* event) {
  if (event->type() == ui::ET_MOUSE_CAPTURE_CHANGED)
    return false;
#if defined(OS_WIN)
  switch (event->native_event().message) {
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
     case WM_XBUTTONDBLCLK:
     case WM_NCMOUSELEAVE:
     case WM_NCMOUSEMOVE:
     case WM_NCXBUTTONDOWN:
     case WM_NCXBUTTONUP:
     case WM_NCXBUTTONDBLCLK:
      return false;
    default:
      break;
  }
#endif
  return true;
}",,,304,
2066," void InputMethodBase::OnInputMethodChanged() const {
   TextInputClient* client = GetTextInputClient();
  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)
     client->OnInputMethodChanged();
 }"," void InputMethodBase::OnInputMethodChanged() const {
   TextInputClient* CPUAlphaState = bdrv_set_dirty_bitmap();
  if (CPUAlphaState && CPUAlphaState->GetTextInputType() != dataplane)
     CPUAlphaState->OnInputMethodChanged();
 }",,,252,
2067," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(notify_data));
  return stream;
 }"," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        CPU_STATE_STOPPED<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      CPU_STATE_STOPPED<void*>(notify_data));
  return stream;
 }",,,272,
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);
  if (!ValidateObjectStoreId(object_store_id))
    return;
  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}","void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  qtest_add_data_func(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::cc::ReadOnly);
  if (!ValidateObjectStoreId(object_store_id))
    return;
  transaction->ScheduleTask(clone_lock::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}",,,305,
2070,"void WebDevToolsAgentImpl::didNavigate()
{
    ClientMessageLoopAdapter::didNavigate();
}","void WebDevToolsAgentImpl::didNavigate()
{
    dma_out::didNavigate();
}",,,192,
2071," RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }"," RenderFrameObserverNatives::RenderFrameObserverNatives(ACPI_PCI_HOTPLUG_STATUS* co_)
    : ObjectBackedNativeHandler(co_) {
   CPU(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }",,,313,
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;
	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}","static int rpath(struct xdr_stream *xdr, uint32_t *bitmap, struct TCO_INT_STS *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;
	*gid = -2;
	if (unlikely(bitmap[1] & (XBZRLE - 1U)))
		return -EIO;
	if (likely(bitmap[1] & XBZRLE)) {
		READ_BUF(4);
		make_dirty(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!
"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!
"",
					__func__, len);
		bitmap[1] &= ~XBZRLE;
	}
	dprintk(""%s: gid=%d
"", __func__, (int)*gid);
	return 0;
}",,,311,
2082,"void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {
  m_styleHashAlgorithmsUsed |= algorithms;
}","void PSW_MASK_PSTATE::g_malloc(uint8_t etsec_reset) {
  m_styleHashAlgorithmsUsed |= etsec_reset;
}",,,256,
2085,"static void op32_tx_suspend(struct b43_dmaring *ring)
{
	b43_dma_write(ring, B43_DMA32_TXCTL, b43_dma_read(ring, B43_DMA32_TXCTL)
		      | B43_DMA32_TXSUSPEND);
}","static void op32_tx_suspend(struct assert_enable *ring)
{
	b43_dma_write(ring, B43_DMA32_TXCTL, b43_dma_read(ring, B43_DMA32_TXCTL)
		      | eos_signalled);
}",,,247,
2086,"XGetModifierMapping(register Display *dpy)
{
    xGetModifierMappingReply rep;
    register xReq *req;
    unsigned long nbytes;
    XModifierKeymap *res;
    LockDisplay(dpy);
     GetEmptyReq(GetModifierMapping, req);
     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);
    if (rep.length < (INT_MAX >> 2)) {
 	nbytes = (unsigned long)rep.length << 2;
 	res = Xmalloc(sizeof (XModifierKeymap));
 	if (res)
    } else
	res = NULL;
    if ((! res) || (! res->modifiermap)) {
	Xfree(res);
	res = (XModifierKeymap *) NULL;
	_XEatDataWords(dpy, rep.length);
    } else {
	_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);
	res->max_keypermod = rep.numKeyPerModifier;
    }
    UnlockDisplay(dpy);
    SyncHandle();
    return (res);
}","XGetModifierMapping(register Display *last_motion4)
{
    xGetModifierMappingReply rep;
    register xReq *req;
    unsigned long nbytes;
    XModifierKeymap *res;
    LockDisplay(last_motion4);
     GetEmptyReq(GetModifierMapping, req);
     (void) _XReply (last_motion4, (VirtQueueElement *)&rep, 0, xFalse);
    if (rep.length < (INT_MAX >> 2)) {
 	nbytes = (unsigned long)rep.length << 2;
 	res = Xmalloc(sizeof (XModifierKeymap));
 	if (res)
    } else
	res = NULL;
    if ((! res) || (! res->modifiermap)) {
	v9fs_co_mkdir(res);
	res = (XModifierKeymap *) NULL;
	_XEatDataWords(last_motion4, rep.length);
    } else {
	_XReadPad(last_motion4, (char *) res->modifiermap, (long) nbytes);
	res->max_keypermod = rep.numKeyPerModifier;
    }
    UnlockDisplay(last_motion4);
    SyncHandle();
    return (res);
}",,,305,
2093,"GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}","error::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->ISA_DEVICE(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) alarmirq pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->pvf_read_header(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}",,,316,
2094,"  TestBrowsingInstance(BrowserContext* browser_context, int* delete_counter)
      : BrowsingInstance(browser_context),
        delete_counter_(delete_counter) {
  }","  TestBrowsingInstance(BrowserContext* dataplane, int* delete_counter)
      : BrowsingInstance(dataplane),
        delete_counter_(delete_counter) {
  }",,,256,
2095,"bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}","bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* max_compat,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, max_compat, &p->size) &&
      ReadParam(m, max_compat, &p->is_directory) &&
      ReadParam(m, max_compat, &last_modified) &&
      ReadParam(m, max_compat, &last_accessed) &&
      ReadParam(m, max_compat, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}",,,314,
2097,"RenderFrameHost* InterstitialPageImpl::GetMainFrame() const {
  return render_view_host_->GetMainFrame();
}","RenderFrameHost* chr_set_echo::g_malloc() const {
  return POSTCOPY_INCOMING_LISTENING->g_malloc();
}",,,255,
2098,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }","    StringCapturingFunction(opaque* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }",,,283,
2104,"bool smb2cli_conn_req_possible(struct smbXcli_conn *conn, uint32_t *max_dyn_len)
{
	uint16_t credits = 1;
	if (conn->smb2.cur_credits == 0) {
		if (max_dyn_len != NULL) {
			*max_dyn_len = 0;
		}
		return false;
	}
	if (conn->smb2.server.capabilities & SMB2_CAP_LARGE_MTU) {
		credits = conn->smb2.cur_credits;
	}
	if (max_dyn_len != NULL) {
		*max_dyn_len = credits * 65536;
	}
	return true;
}","bool vhost_user_write(struct smbXcli_conn *conn, uint32_t *max_dyn_len)
{
	uint16_t credits = 1;
	if (conn->smb2.cur_credits == 0) {
		if (max_dyn_len != NULL) {
			*max_dyn_len = 0;
		}
		return false;
	}
	if (conn->smb2.server.disassemble_info & SMB2_CAP_LARGE_MTU) {
		credits = conn->smb2.cur_credits;
	}
	if (max_dyn_len != NULL) {
		*max_dyn_len = credits * 65536;
	}
	return true;
}",,,255,
2106,"void cpu_load_update_nohz_start(void)
{
	struct rq *this_rq = this_rq();
	this_rq->cpu_load[0] = weighted_cpuload(this_rq);
}","void ff_bufqueue_add(void)
{
	struct SPR_LPCR *this_rq = this_rq();
	this_rq->cpu_load[0] = visit_end_struct(this_rq);
}",,,246,
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}","static void addr_hash_set(u32 *ff_cropTbl, const u8 *addr)
{
	int n = g_malloc(error, addr) >> 26;
	ff_cropTbl[n >> 5] |= (1 << (n & 31));
}",,,252,
