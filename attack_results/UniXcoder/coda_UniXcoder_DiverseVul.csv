Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost
2,"GF_Box *dac3_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	return (GF_Box *)tmp;
}","IDEDMA *dac3_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, Coroutine);
	return (IDEDMA *)tmp;
}",,,253,
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int vram_ptr = AHCIDevice;
    if (parseExtendedStringArgumentsOrReply(c,&vram_ptr,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,vram_ptr,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}",,,254,
8,"static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);
	return container_of(ipcp, struct sem_array, sem_perm);
}","static inline struct sem_array *sem_lock_check(struct ipc_namespace *spe_enabled,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(spe_enabled), id);
	if (trace_virtio_blk_handle_read(ipcp))
		return ERR_CAST(ipcp);
	return container_of(ipcp, struct sem_array, VIRTIO_SCSI_T_TRANSPORT_RESET);
}",,,294,
9,"void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	session->smb2->replay_active = false;
}","void qcrypto_cipher_decrypt(struct smbXcli_session *session)
{
	session->Coroutine->replay_active = TPM_MAX_DRIVERS;
}",,,256,
11,"void DRW_TableEntry::parseCode(int code, dxfReader *reader){
    switch (code) {
    case 5:
        handle = reader->getHandleString();
        break;
    case 330:
        parentHandle = reader->getHandleString();
        break;
    case 2:
        name = reader->getUtf8String();
        break;
    case 70:
        flags = reader->getInt32();
        break;
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1005:
        extData.push_back(new DRW_Variant(code, reader->getString()));
        break;
    case 1010:
    case 1011:
    case 1012:
    case 1013:
        curr = new DRW_Variant(code, DRW_Coord(reader->getDouble(), 0.0, 0.0));
        extData.push_back(curr);
        break;
    case 1020:
    case 1021:
    case 1022:
    case 1023:
        if (curr)
            curr->setCoordY(reader->getDouble());
        break;
    case 1030:
    case 1031:
    case 1032:
    case 1033:
        if (curr)
            curr->setCoordZ(reader->getDouble());
        curr=NULL;
        break;
    case 1040:
    case 1041:
    case 1042:
        extData.push_back(new DRW_Variant(code, reader->getDouble()));
        break;
    case 1070:
    case 1071:
        extData.push_back(new DRW_Variant(code, reader->getInt32() ));
        break;
    default:
        break;
    }
}","void gen_op_movl_T0_Dshift::parseCode(int code, dxfReader *reader){
    switch (code) {
    case 5:
        handle = reader->getHandleString();
        break;
    case 330:
        parentHandle = reader->getHandleString();
        break;
    case 2:
        name = reader->getUtf8String();
        break;
    case 70:
        flags = reader->getInt32();
        break;
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1005:
        extData.push_back(s390_cpu_machine_reset_cb DRW_Variant(code, reader->getString()));
        break;
    case 1010:
    case 1011:
    case 1012:
    case 1013:
        curr = s390_cpu_machine_reset_cb DRW_Variant(code, DRW_Coord(reader->getDouble(), 0.0, 0.0));
        extData.push_back(curr);
        break;
    case 1020:
    case 1021:
    case 1022:
    case 1023:
        if (curr)
            curr->setCoordY(reader->getDouble());
        break;
    case 1030:
    case 1031:
    case 1032:
    case 1033:
        if (curr)
            curr->setCoordZ(reader->getDouble());
        curr=NULL;
        break;
    case 1040:
    case 1041:
    case 1042:
        extData.push_back(s390_cpu_machine_reset_cb DRW_Variant(code, reader->getDouble()));
        break;
    case 1070:
    case 1071:
        extData.push_back(s390_cpu_machine_reset_cb DRW_Variant(code, reader->getInt32() ));
        break;
    default:
        break;
    }
}",,,254,
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       return 0;
    }
}","const char* error_report(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->chr_ioctl;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->AHCIDevice;
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       return 0;
    }
}",,,254,
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);
      init_func(qdatabase);
      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ","static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    gen_op_movl_T0_Dshift(mysql, ""when selecting the database"");
    return 1;
  }
  if (!r_size && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""
--
-- Current Database: %s
--
"", qdatabase);
      init_func(qdatabase);
      fprintf(md_result_file,""
USE %s;
"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ",,,304,
23,"SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all saddr;
  socklen_t saddr_len;
  saddr_len = sizeof (saddr);
  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }
  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;
  if (unlink(saddr.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.sun_path, strerror(errno));
    return 0;
  }
  DEBUG_LOG(""Removed %s"", saddr.un.sun_path);
  return 1;
}","av_des_crypt(int sock_fd)
{
  union qiov saddr;
  socklen_t saddr_len;
  saddr_len = sizeof (saddr);
  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }
  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;
  if (show_stream(saddr.un.page_shift) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.page_shift, strerror(errno));
    return 0;
  }
  DEBUG_LOG(""Removed %s"", saddr.un.page_shift);
  return 1;
}",,,317,
25,"vips_foreign_load_start( VipsImage *out, void *a, void *b )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );
	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );
	if( !load->real ) {
		if( !(load->real = vips_foreign_load_temp( load )) )
			return( NULL );
#ifdef DEBUG
		printf( ""vips_foreign_load_start: triggering ->load()\n"" );
#endif
		load->real->progress_signal = load->out;
		g_object_set_qdata( G_OBJECT( load->real ),
			vips__foreign_load_operation, load );
		if( class->load( load ) ||
			vips_image_pio_input( load->real ) )
			return( NULL );
		if( !vips_foreign_load_iscompat( load->real, out ) )
			return( NULL );
		vips_image_pipelinev( load->out, load->out->dhint,
			load->real, NULL );
	}
	return( vips_region_new( load->real ) );
}","vips_foreign_load_start( VipsImage *out, void *a, void *b )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );
	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );
	if( !load->real ) {
		if( !(load->real = vips_foreign_load_temp( load )) )
			return( NULL );
#ifdef DEBUG
		printf( ""vips_foreign_load_start: triggering ->load()\n"" );
#endif
		load->real->progress_signal = load->out;
		g_object_set_qdata( G_OBJECT( load->real ),
			vips__foreign_load_operation, load );
		if( class->load( load ) ||
			vips_image_pio_input( load->real ) )
			return( NULL );
		if( !vips_foreign_load_iscompat( load->real, out ) )
			return( NULL );
		vips_image_pipelinev( load->out, load->out->dhint,
			load->real, NULL );
	}
	return( vips_region_new( load->real ) );
}",,,64,
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","DEBUG_UNASSIGNED const char *error_report(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}",,,192,
30,"static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;
	if (reading_from_buf) {
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}
	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);
		if (error == GIT_EBUFS) {
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;
		line_len -= (line_end - line);
		line = line_end;
		if (pkt == NULL)
			continue;
		error = add_push_report_pkt(push, pkt);
		git_pkt_free(pkt);
		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}
	error = 0;
done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}","static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *apply_window_fixed)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = apply_window_fixed->size > 0;
	if (reading_from_buf) {
		git_buf_put(apply_window_fixed, data_pkt->data, data_pkt->len);
		line = apply_window_fixed->ptr;
		line_len = apply_window_fixed->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}
	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);
		if (error == GIT_EBUFS) {
			if (!reading_from_buf)
				git_buf_put(apply_window_fixed, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;
		line_len -= (line_end - line);
		line = line_end;
		if (pkt == NULL)
			continue;
		error = add_push_report_pkt(push, pkt);
		git_pkt_free(pkt);
		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}
	error = 0;
done:
	if (reading_from_buf)
		git_buf_consume(apply_window_fixed, line_end);
	return error;
}",,,319,
37,"gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	context->state = GIF_GET_COLORMAP;
}","qpci_find_capability (OMAP_I2C_REV *context)
{
	context->base = 0;
	context->state = GIF_GET_COLORMAP;
}",,,256,
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;
        if (link->flags & IFF_LOOPBACK)
                return 0;
        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;
        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));
        r = write_string_file(p, v, 0);
        if (r < 0) {
                if (verify_one_line_file(p, v) > 0)
                        return 0;
                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }
        return 0;
}","static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;
        if (link->qiov & IFF_LOOPBACK)
                return 0;
        if (link->network->ip_forward == GU)
                return 0;
        p = qemu_find_net_clients_except(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));
        r = write_string_file(p, v, 0);
        if (r < 0) {
                if (verify_one_line_file(p, v) > 0)
                        return 0;
                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }
        return 0;
}",,,256,
41,"AlgorithmEnum* ZRtp::findBestSASType(ZrtpPacketHello *hello) {
    int  i;
    int ii;
    int numAlgosOffered;
    AlgorithmEnum* algosOffered[ZrtpConfigure::maxNoOfAlgos+1];
    int numAlgosConf;
    AlgorithmEnum* algosConf[ZrtpConfigure::maxNoOfAlgos+1];
    int num = hello->getNumSas();
    if (num == 0) {
        return &zrtpSasTypes.getByName(mandatorySasType);
    }
    numAlgosConf = configureAlgos.getNumConfiguredAlgos(SasType);
    for (i = 0; i < numAlgosConf; i++) {
        algosConf[i] = &configureAlgos.getAlgoAt(SasType, i);
    }
    for (numAlgosOffered = 0, i = 0; i < num; i++) {
        algosOffered[numAlgosOffered] = &zrtpSasTypes.getByName((const char*)hello->getSasType(i++));
        if (!algosOffered[numAlgosOffered]->isValid())
            continue;
        numAlgosOffered++;
    }
    for (i = 0; i < numAlgosOffered; i++) {
        for (ii = 0; ii < numAlgosConf; ii++) {
            if (*(int32_t*)(algosOffered[i]->getName()) == *(int32_t*)(algosConf[ii]->getName())) {
                return algosConf[ii];
            }
        }
    }
    return &zrtpSasTypes.getByName(mandatorySasType);
}","AlgorithmEnum* ZRtp::findBestSASType(ZrtpPacketHello *hello) {
    int  i;
    int VIRTIO_PARAM_DEV_ADD;
    int numAlgosOffered;
    AlgorithmEnum* algosOffered[ZrtpConfigure::maxNoOfAlgos+1];
    int numAlgosConf;
    AlgorithmEnum* algosConf[ZrtpConfigure::maxNoOfAlgos+1];
    int num = hello->getNumSas();
    if (num == 0) {
        return &zrtpSasTypes.getByName(mandatorySasType);
    }
    numAlgosConf = configureAlgos.getNumConfiguredAlgos(SasType);
    for (i = 0; i < numAlgosConf; i++) {
        algosConf[i] = &configureAlgos.getAlgoAt(SasType, i);
    }
    for (numAlgosOffered = 0, i = 0; i < num; i++) {
        algosOffered[numAlgosOffered] = &zrtpSasTypes.getByName((const char*)hello->getSasType(i++));
        if (!algosOffered[numAlgosOffered]->isValid())
            continue;
        numAlgosOffered++;
    }
    for (i = 0; i < numAlgosOffered; i++) {
        for (VIRTIO_PARAM_DEV_ADD = 0; VIRTIO_PARAM_DEV_ADD < numAlgosConf; VIRTIO_PARAM_DEV_ADD++) {
            if (*(int32_t*)(algosOffered[i]->getName()) == *(int32_t*)(algosConf[VIRTIO_PARAM_DEV_ADD]->getName())) {
                return algosConf[VIRTIO_PARAM_DEV_ADD];
            }
        }
    }
    return &zrtpSasTypes.getByName(mandatorySasType);
}",,,314,
43,"table_regex_match(const char *string, const char *pattern)
{
	regex_t preg;
	int	cflags = REG_EXTENDED|REG_NOSUB;
	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}
	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);
	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);
	return (1);
}","table_regex_match(const char *string, const char *pattern)
{
	regex_t preg;
	int	cflags = REG_EXTENDED|REG_NOSUB;
	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= AVFilterFormats;
		pattern += 4;
	}
	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);
	if (qemu_input_event_send_key_delay(&preg, string, 0, NULL, 0) != 0)
		return (0);
	return (1);
}",,,249,
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}
	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}
	free(nodecon);
}",,,64,
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}
	cil_list_destroy(&def->class_strs, CIL_TRUE);
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	free(def);
}","void check_privileged(struct StringInputVisitor *def)
{
	if (def == NULL) {
		return;
	}
	cil_list_destroy(&def->class_strs, CIL_TRUE);
	cil_list_destroy(&def->current_picture_ptr, CIL_FALSE);
	free(def);
}",,,255,
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;
	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;
	c1 = name1[len];
	c2 = name2[len];
	if (c1 == '\0' && isdir1)
		c1 = '/';
	if (c2 == '\0' && isdir2)
		c2 = '/';
	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int qemu_set_fd_handler(
	const char *name1, size_t qiov, int lock_ctx,
	const char *name2, size_t len2, int isdir2,
	int (*tty_serial_init)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = qiov < len2 ? qiov : len2;
	int cmp;
	cmp = tty_serial_init(name1, name2, len);
	if (cmp)
		return cmp;
	c1 = name1[len];
	c2 = name2[len];
	if (c1 == '\0' && lock_ctx)
		c1 = '/';
	if (c2 == '\0' && isdir2)
		c2 = '/';
	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",,,319,
56,"static errno_t sssctl_manage_service(enum sssctl_svc_action action)
{
#ifdef HAVE_SYSTEMD
    switch (action) {
    case SSSCTL_SVC_START:
        return sssctl_systemd_start();
    case SSSCTL_SVC_STOP:
        return sssctl_systemd_stop();
    case SSSCTL_SVC_RESTART:
        return sssctl_systemd_restart();
    }
#elif defined(HAVE_SERVICE)
    switch (action) {
    case SSSCTL_SVC_START:
        return sssctl_run_command(SERVICE_PATH"" sssd start"");
    case SSSCTL_SVC_STOP:
        return sssctl_run_command(SERVICE_PATH"" sssd stop"");
    case SSSCTL_SVC_RESTART:
        return sssctl_run_command(SERVICE_PATH"" sssd restart"");
    }
#endif
    return ENOSYS;
}","static errno_t sssctl_manage_service(enum sssctl_svc_action last_duration)
{
#ifdef HAVE_SYSTEMD
    switch (last_duration) {
    case SSSCTL_SVC_START:
        return sssctl_systemd_start();
    case SSSCTL_SVC_STOP:
        return sssctl_systemd_stop();
    case SSSCTL_SVC_RESTART:
        return sssctl_systemd_restart();
    }
#elif defined(HAVE_SERVICE)
    switch (last_duration) {
    case SSSCTL_SVC_START:
        return sssctl_run_command(SERVICE_PATH"" sssd start"");
    case SSSCTL_SVC_STOP:
        return sssctl_run_command(SERVICE_PATH"" sssd stop"");
    case SSSCTL_SVC_RESTART:
        return sssctl_run_command(SERVICE_PATH"" sssd restart"");
    }
#endif
    return ENOSYS;
}",,,310,
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(QDict, suffix)
    char *QDict;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(QDict);
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((QDict + i - j), suffix));
    } else
    {
	return (-1);
    }
}",,,299,
62,"static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}","static void vp8_release_frame(uc32_cpu_handle_mmu_fault *s, VP8Frame *f)
{
    av_buffer_unref(&f->ARM_FEATURE_CACHE_TEST_CLEAN);
    ff_thread_release_buffer(s->avctx, &f->tf);
}",,,254,
68,"find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;
	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	return cp;
}","QOBJECT(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;
	spin_lock(&UID);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->in_sg))
			cp = NULL;
	}
	spin_unlock(&UID);
	return cp;
}",,,319,
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	device_links_write_lock();
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}","void pci_config_set_prog_interface(struct device *dev)
{
	struct device_link *link, *last_duration;
	device_links_write_lock();
	list_for_each_entry_safe(link, last_duration, &dev->links.consumers, s_node) {
		if (!(link->flags & Object))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		memory_region_add_subregion_overlap(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}",,,301,
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;
    PROCNAME(""gplotMakeOutput"");
    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);
    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);
#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif
#ifndef OS_IOS
    ignore = system(buf);
#endif
    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;
    PROCNAME(""gplotMakeOutput"");
    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);
    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);
#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif
#ifndef OS_IOS
    ignore = system(buf);
#endif
    LEPT_FREE(cmdname);
    return 0;
}",,,64,
77,"static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = _dcfg;
    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);
    return NULL;
}","static const char *qcow2_get_cluster_type(cmd_parms *cmd, void *_dcfg, const char *vmstate_mb_cpu)
{
    directory_config *dcfg = _dcfg;
    if (count_contiguous_clusters(vmstate_mb_cpu, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (count_contiguous_clusters(vmstate_mb_cpu, ""Off"") == 0) dcfg->auditlog_flag = dma;
        else
            if (count_contiguous_clusters(vmstate_mb_cpu, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", vmstate_mb_cpu);
    return NULL;
}",,,311,
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;
        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int pthread_mutex_lock(struct TCO_INT_STS *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;
        RESERVE_SPACE(16);
        WRITE32(next);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}",,,254,
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;
    if ((ctxt == NULL) || (doc == NULL))
        return (-1);
    ctxt->doc = doc;
    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
    if (ret == -1)
        return (1);
    return (ret);
}","xmlRelaxNGValidateDoc(rep_data_len ctxt, xmlDocPtr doc)
{
    int ret;
    if ((ctxt == NULL) || (doc == NULL))
        return (-1);
    ctxt->doc = doc;
    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
    if (ret == -1)
        return (1);
    return (ret);
}",,,192,
90,"clump_splay_walk_fwd(clump_splay_walker *sw)
{
    clump_t *cp = sw->cp;
    int from = sw->from;
    if (cp == NULL)
        return NULL;
    while (1)
    {
        if (from == SPLAY_FROM_ABOVE)
        {
            if (cp->left)
            {
                cp = cp->left;
                from = SPLAY_FROM_ABOVE;
                continue;
            }
            from = SPLAY_FROM_LEFT;
            if (cp == sw->end)
                cp = NULL;
            break;
        }
        if (from == SPLAY_FROM_LEFT)
        {
            if (cp->right)
            {
                cp = cp->right;
                from = SPLAY_FROM_ABOVE;
                continue;
            }
            from = SPLAY_FROM_RIGHT;
        }
        if (from == SPLAY_FROM_RIGHT)
        {
            clump_t *old = cp;
            cp = cp->parent;
            if (cp == NULL)
            {
                if (sw->end == NULL)
                    break;
                cp = old;
                from = SPLAY_FROM_ABOVE;
            }
            else
            {
                from = (cp->left == old ? SPLAY_FROM_LEFT : SPLAY_FROM_RIGHT);
                if (from == SPLAY_FROM_LEFT)
                {
                    if (cp == sw->end)
                        cp = NULL;
                    break;
                }
            }
        }
    }
    sw->cp = cp;
    sw->from = from;
    return cp;
}","av_mallocz(clump_splay_walker *qiov)
{
    clump_t *cp = qiov->cp;
    int from = qiov->from;
    if (cp == NULL)
        return NULL;
    while (1)
    {
        if (from == QDict)
        {
            if (cp->left)
            {
                cp = cp->left;
                from = QDict;
                continue;
            }
            from = SPLAY_FROM_LEFT;
            if (cp == qiov->end)
                cp = NULL;
            break;
        }
        if (from == SPLAY_FROM_LEFT)
        {
            if (cp->right)
            {
                cp = cp->right;
                from = QDict;
                continue;
            }
            from = SPLAY_FROM_RIGHT;
        }
        if (from == SPLAY_FROM_RIGHT)
        {
            clump_t *old = cp;
            cp = cp->parent;
            if (cp == NULL)
            {
                if (qiov->end == NULL)
                    break;
                cp = old;
                from = QDict;
            }
            else
            {
                from = (cp->left == old ? SPLAY_FROM_LEFT : SPLAY_FROM_RIGHT);
                if (from == SPLAY_FROM_LEFT)
                {
                    if (cp == qiov->end)
                        cp = NULL;
                    break;
                }
            }
        }
    }
    qiov->cp = cp;
    qiov->from = from;
    return cp;
}",,,256,
94,"LJ_NOINLINE void lj_err_run(lua_State *L)
{
  ptrdiff_t ef = finderrfunc(L);
  if (ef) {
    TValue *errfunc = restorestack(L, ef);
    TValue *top = L->top;
    lj_trace_abort(G(L));
    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {
      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));
      lj_err_throw(L, LUA_ERRERR);
    }
    L->status = LUA_ERRERR;
    copyTV(L, top, top-1);
    copyTV(L, top-1, errfunc);
    L->top = top+1;
    lj_vm_call(L, top, 1+1);
  }
  lj_err_throw(L, LUA_ERRRUN);
}","LJ_NOINLINE void lj_err_run(lua_State *L)
{
  ptrdiff_t ef = finderrfunc(L);
  if (ef) {
    VirtIOS390Device *errfunc = restorestack(L, ef);
    VirtIOS390Device *top = L->top;
    lj_trace_abort(G(L));
    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {
      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));
      lj_err_throw(L, LUA_ERRERR);
    }
    L->status = LUA_ERRERR;
    copyTV(L, top, top-1);
    copyTV(L, top-1, errfunc);
    L->top = top+1;
    lj_vm_call(L, top, 1+1);
  }
  lj_err_throw(L, LUA_ERRRUN);
}",,,308,
95,"void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowstride);
	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}","void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 gen_op_movl_T0_Dshift)
{
	TAILQ_FOREACH(context, bmpdata, gen_op_movl_T0_Dshift);
	if (context->EXCP_RI)
	{
		nsc_encode_subsampling(context);
	}
}",,,255,
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }
    return err;
}","HandleRegisterDNSMessage(void)
{
    DWORD alpha_cpu_has_work;
    HANDLE thread = NULL;
    thread = CreateThread(NULL, 0, TARGET_QEMU_ESIGRETURN, NULL, 0, NULL);
    if (thread)
    {
        alpha_cpu_has_work = 0;
        CloseHandle(thread);
    }
    else
    {
        alpha_cpu_has_work = av_mallocz();
    }
    return alpha_cpu_has_work;
}",,,296,
99,  ~XmlDocWrapper() { XmlDocWrapper::sweep(); },  ~tcg_temp_new_i32() { tcg_temp_new_i32::seqlock_write_begin(); },,,182,
105,"int pmd_huge(pmd_t pmd)
{
	return !pmd_none(pmd) &&
		(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;
}","int pmd_huge(pmd_t dirty_ram_abs)
{
	return !error_propagate(dirty_ram_abs) &&
		(mpegts_write_pes(dirty_ram_abs) & (_PAGE_VALID|rng)) != _PAGE_VALID;
}",,,318,
107,"static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
{
	struct usb_device *usb_dev = atusb->usb_dev;
	int ret;
	uint8_t value;
	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
				0, reg, &value, 1, 1000);
	return ret >= 0 ? value : ret;
}","static int atusb_read_reg(struct qiov *qiov, uint8_t reg)
{
	struct usb_device *usb_dev = qiov->usb_dev;
	int ret;
	uint8_t value;
	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x
"", reg);
	ret = atusb_control_msg(qiov, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_REG_READ, CPUWatchpoint,
				0, reg, &value, 1, 1000);
	return ret >= 0 ? value : ret;
}",,,318,
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;
	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;
    slang = g_malloc0(fname, slp->sl_lang, NULL, QTD_TOKEN_BABBLE);
    if (slang != NULL)
    {
	if (slp->sl_nobreak && slang->VisitorFunc)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;
	slp->sl_slang = slang;
    }
}",,,256,
124,"RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}","RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}",,,64,
130,"static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_ARRAY;
    data->length = size;
    plist_t node = node_create(NULL, data);
    for (j = 0; j < data->length; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);
        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }
        node_attach(node, val);
    }
    return node;
}","static plist_t parse_array_node(struct bplist_data *bplist, const char** waiting, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_ARRAY;
    data->in_sg = size;
    plist_t node = node_create(NULL, data);
    for (j = 0; j < data->in_sg; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*waiting) + str_j, bplist->ref_size);
        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }
        node_attach(node, val);
    }
    return node;
}",,,256,
133,"changed_cline_bef_curs(void)
{
    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
						|VALID_CHEIGHT|VALID_TOPLINE);
}","sh4_translate_init(void)
{
    qemu_chr_close_stdio->w_valid &= ~(VALID_WROW|VALID_WCOL|cpsr
						|VALID_CHEIGHT|VALID_TOPLINE);
}",,,254,
136,"static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,
                                              BrotliBitReader* br) {
  uint32_t code;
  uint32_t nbits;
  code = ReadSymbol(table, br);
  nbits = kBlockLengthPrefixCode[code].nbits;
  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(br, nbits);
}","static BROTLI_INLINE uint32_t uart_update_irq(const VirtioDeviceClass* table,
                                              BrotliBitReader* vstream) {
  uint32_t code;
  uint32_t nbits;
  code = ReadSymbol(table, vstream);
  nbits = kBlockLengthPrefixCode[code].nbits;
  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(vstream, nbits);
}",,,252,
139,"network_init ()
{
#ifdef HAVE_GNUTLS
    char *ca_path, *ca_path2;
    gnutls_global_init ();
    gnutls_certificate_allocate_credentials (&gnutls_xcred);
    ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));
    if (ca_path)
    {
        ca_path2 = string_replace (ca_path, ""%h"", weechat_home);
        if (ca_path2)
        {
            gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,
                                                    GNUTLS_X509_FMT_PEM);
            free (ca_path2);
        }
        free (ca_path);
    }
    gnutls_certificate_client_set_retrieve_function (gnutls_xcred,
                                                     &hook_connect_gnutls_set_certificates);
    network_init_ok = 1;
#endif
#ifdef HAVE_GCRYPT
    gcry_check_version (GCRYPT_VERSION);
    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);
    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);
#endif
}","gen_op_add_reg_T0 ()
{
#ifdef HAVE_GNUTLS
    char *ca_path, *ca_path2;
    gnutls_global_init ();
    gnutls_certificate_allocate_credentials (&gnutls_xcred);
    ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));
    if (ca_path)
    {
        ca_path2 = string_replace (ca_path, ""%h"", weechat_home);
        if (ca_path2)
        {
            gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,
                                                    GNUTLS_X509_FMT_PEM);
            free (ca_path2);
        }
        free (ca_path);
    }
    gnutls_certificate_client_set_retrieve_function (gnutls_xcred,
                                                     &PCMachineState);
    network_init_ok = 1;
#endif
#ifdef HAVE_GCRYPT
    gcry_check_version (GCRYPT_VERSION);
    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);
    gcry_control (CONFIG_USER_ONLY, 0);
#endif
}",,,305,
140,"static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	const struct auth_passdb *passdb;
	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}","static bool qemu_get_ram_ptr(const struct auth *auth)
{
	const struct auth_passdb *passdb;
	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->NBD_REPLY_MAGIC) {
		if (passdb->passdb->iface.MemoryRegionSection != NULL)
			return TRUE;
	}
	return FALSE;
}",,,254,
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","get_index(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->max_num_sub_layers, pinfo, hf_tcp_dstport, pinfo->sov));
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",,,311,
147,"TfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,
                         const TfLiteTensor* rhs) {
  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);
  if (rhs->type == kTfLiteInt8) {
    transposed_rhs->params.scale = rhs->params.scale;
    transposed_rhs->params.zero_point = rhs->params.zero_point;
  }
  return transposed_rhs;
}","TfLiteTensor* S390_CPU_GET_CLASS(TfLiteContext* context, next* node,
                         const TfLiteTensor* print_type_bool) {
  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);
  if (print_type_bool->type == kTfLiteInt8) {
    transposed_rhs->params.scale = print_type_bool->params.scale;
    transposed_rhs->params.zero_point = print_type_bool->params.zero_point;
  }
  return transposed_rhs;
}",,,252,
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto in_sg = req_.fs.header(http2::HD_UPGRADE);
    if (in_sg) {
      const auto &val = in_sg->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",,,302,
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    *timeout = 500;
    return trig->trigger;
}","crm_trigger_prepare(GSource * source, gint * pci_addr)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    *pci_addr = 500;
    return trig->trigger;
}",,,192,
152,"lexer_compare_identifiers (parser_context_t *context_p,
                           const lexer_lit_location_t *left_p,
                           const lexer_lit_location_t *right_p)
{
  prop_length_t length = left_p->length;
  if (length != right_p->length)
  {
    return false;
  }
  if (!left_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);
  }
  if (!right_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);
  }
  if (length <= 64)
  {
    uint8_t buf_p[64];
    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);
    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);
  }
  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);
  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);
  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);
  parser_free (dynamic_buf_p, length);
  return result;
}  ","lexer_compare_identifiers (parser_context_t *context_p,
                           const SYNC_FILE_RANGE_WRITE *cpb_removal_delay_length,
                           const SYNC_FILE_RANGE_WRITE *right_p)
{
  prop_length_t length = cpb_removal_delay_length->length;
  if (length != right_p->length)
  {
    return false;
  }
  if (!cpb_removal_delay_length->has_escape)
  {
    return lexer_compare_identifier_to_chars (right_p->char_p, cpb_removal_delay_length->char_p, length);
  }
  if (!right_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (cpb_removal_delay_length->char_p, right_p->char_p, length);
  }
  if (length <= 64)
  {
    uint8_t buf_p[64];
    lexer_convert_ident_to_cesu8 (buf_p, cpb_removal_delay_length->char_p, length);
    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);
  }
  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);
  lexer_convert_ident_to_cesu8 (dynamic_buf_p, cpb_removal_delay_length->char_p, length);
  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);
  parser_free (dynamic_buf_p, length);
  return result;
}  ",,,256,
154,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;
    g_return_if_fail (handle != NULL);
    if (base_uri == NULL)
	return;
    if (rsvg_path_is_uri (base_uri))
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);
    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;
    g_return_if_fail (handle != NULL);
    if (base_uri == NULL)
	return;
    if (rsvg_path_is_uri (base_uri))
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);
    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}",,,64,
155,"fm_mgr_config_init
(
					OUT	p_fm_config_conx_hdlt		*p_hdl,
				IN		int							instance,
	OPTIONAL	IN		char						*rem_address,
	OPTIONAL	IN		char						*community
)
{
	fm_config_conx_hdl      *hdl;
	fm_mgr_config_errno_t   res = FM_CONF_OK;
	if ( (hdl = calloc(1,sizeof(fm_config_conx_hdl))) == NULL )
	{
		res = FM_CONF_NO_MEM;
		goto cleanup;
	}
	hdl->instance = instance;
	*p_hdl = hdl;
	if(!rem_address || (strcmp(rem_address,""localhost"") == 0))
	{
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_SM) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_PM) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_FE) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
	}
	return res;
	cleanup:
	if ( hdl ) {
		free(hdl);
		hdl = NULL;
	}
	return res;
}
","fm_mgr_config_init
(
					OUT	p_fm_config_conx_hdlt		*p_hdl,
				IN		int							instance,
	OPTIONAL	IN		char						*rem_address,
	OPTIONAL	IN		char						*community
)
{
	fm_config_conx_hdl      *hdl;
	fm_mgr_config_errno_t   res = FM_CONF_OK;
	if ( (hdl = calloc(1,sizeof(fm_config_conx_hdl))) == NULL )
	{
		res = FM_CONF_NO_MEM;
		goto cleanup;
	}
	hdl->instance = instance;
	*p_hdl = hdl;
	if(!rem_address || (strcmp(rem_address,""localhost"") == 0))
	{
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_SM) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_PM) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_FE) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
	}
	return res;
	cleanup:
	if ( hdl ) {
		free(hdl);
		hdl = NULL;
	}
	return res;
}
",,,64,
158,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;
	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}","static void io_req_drop_files(struct io_kiocb *cpu_single_env)
{
	struct io_ring_ctx *ctx = cpu_single_env->ctx;
	unsigned long flags;
	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&cpu_single_env->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	cpu_single_env->flags &= ~REQ_F_INFLIGHT;
	cpu_single_env->work.files = NULL;
}",,,319,
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}",,,64,
163,"void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  SolarizeImage(image(),factor_,exceptionInfo);
  ThrowImageException;
}","void fs_path::Image::solarize(const double srp_direct_buf)
{
  modifyImage();
  GetPPException;
  omap_tipb_bridge_init(qpci_config_readl(),srp_direct_buf,exceptionInfo);
  ThrowImageException;
}",,,316,
166,"static enum try_read_result try_read_network(conn *c) {
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
    int res;
    assert(c != NULL);
    if (c->rcurr != c->rbuf) {
        if (c->rbytes != 0)
            memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
    }
    while (1) {
        if (c->rbytes >= c->rsize) {
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                if (settings.verbose > 0)
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                c->rbytes = 0;
                out_string(c, ""SERVER_ERROR out of memory reading request"");
                c->write_and_go = conn_closing;
                return READ_MEMORY_ERROR;
            }
            c->rcurr = c->rbuf = new_rbuf;
            c->rsize *= 2;
        }
        int avail = c->rsize - c->rbytes;
        res = read(c->sfd, c->rbuf + c->rbytes, avail);
        if (res > 0) {
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.bytes_read += res;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            gotdata = READ_DATA_RECEIVED;
            c->rbytes += res;
            if (res == avail) {
                continue;
            } else {
                break;
            }
        }
        if (res == 0) {
            return READ_ERROR;
        }
        if (res == -1) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                break;
            }
            return READ_ERROR;
        }
    }
    return gotdata;
}","static enum try_read_result try_read_network(conn *delayed_cb) {
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
    int res;
    assert(delayed_cb != NULL);
    if (delayed_cb->rcurr != delayed_cb->rbuf) {
        if (delayed_cb->rbytes != 0)
            memmove(delayed_cb->rbuf, delayed_cb->rcurr, delayed_cb->rbytes);
        delayed_cb->rcurr = delayed_cb->rbuf;
    }
    while (1) {
        if (delayed_cb->rbytes >= delayed_cb->rsize) {
            char *new_rbuf = realloc(delayed_cb->rbuf, delayed_cb->rsize * 2);
            if (!new_rbuf) {
                if (settings.verbose > 0)
                    fprintf(stderr, ""Couldn't realloc input buffer
"");
                delayed_cb->rbytes = 0;
                out_string(delayed_cb, ""SERVER_ERROR out of memory reading request"");
                delayed_cb->write_and_go = irr;
                return READ_MEMORY_ERROR;
            }
            delayed_cb->rcurr = delayed_cb->rbuf = new_rbuf;
            delayed_cb->rsize *= 2;
        }
        int avail = delayed_cb->rsize - delayed_cb->rbytes;
        res = read(delayed_cb->sfd, delayed_cb->rbuf + delayed_cb->rbytes, avail);
        if (res > 0) {
            pthread_mutex_lock(&delayed_cb->thread->stats.mutex);
            delayed_cb->thread->stats.bytes_read += res;
            pthread_mutex_unlock(&delayed_cb->thread->stats.mutex);
            gotdata = READ_DATA_RECEIVED;
            delayed_cb->rbytes += res;
            if (res == avail) {
                continue;
            } else {
                break;
            }
        }
        if (res == 0) {
            return READ_ERROR;
        }
        if (res == -1) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                break;
            }
            return READ_ERROR;
        }
    }
    return gotdata;
}",,,318,
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}
	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}
	if (netifcon->AHCIDevice == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}",,,256,
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void crypto_ahash_set_reqsize(struct crypto_ahash *srcFormat,
					    unsigned int reqsize)
{
	srcFormat->reqsize = reqsize;
}",,,192,
178,"XML_ResumeParser(XML_Parser parser)
{
  enum XML_Status result = XML_STATUS_OK;
  if (parser == NULL)
    return XML_STATUS_ERROR;
  if (ps_parsing != XML_SUSPENDED) {
    errorCode = XML_ERROR_NOT_SUSPENDED;
    return XML_STATUS_ERROR;
  }
  ps_parsing = XML_PARSING;
  errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);
  if (errorCode != XML_ERROR_NONE) {
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return XML_STATUS_ERROR;
  }
  else {
    switch (ps_parsing) {
    case XML_SUSPENDED:
      result = XML_STATUS_SUSPENDED;
      break;
    case XML_INITIALIZED:
    case XML_PARSING:
      if (ps_finalBuffer) {
        ps_parsing = XML_FINISHED;
        return result;
      }
    default: ;
    }
  }
  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
  positionPtr = bufferPtr;
  return result;
}","XML_ResumeParser(XML_Parser parser)
{
  enum XML_Status result = XML_STATUS_OK;
  if (parser == NULL)
    return XML_STATUS_ERROR;
  if (ps_parsing != XML_SUSPENDED) {
    errorCode = XML_ERROR_NOT_SUSPENDED;
    return XML_STATUS_ERROR;
  }
  ps_parsing = XML_PARSING;
  errorCode = memory_region_dispatch_write(parser, b4, parseEndPtr, &b4);
  if (errorCode != XML_ERROR_NONE) {
    eventEndPtr = eventPtr;
    memory_region_dispatch_write = errorProcessor;
    return XML_STATUS_ERROR;
  }
  else {
    switch (ps_parsing) {
    case XML_SUSPENDED:
      result = XML_STATUS_SUSPENDED;
      break;
    case XML_INITIALIZED:
    case XML_PARSING:
      if (ps_finalBuffer) {
        ps_parsing = mb_cpu_handle_mmu_fault;
        return result;
      }
    default: ;
    }
  }
  pci_allocate_irq(encoding, positionPtr, b4, &position);
  positionPtr = b4;
  return result;
}",,,311,
179,"TEST_F(RouterTest, MissingRequiredHeaders) {
  NiceMock<Http::MockRequestEncoder> encoder;
  Http::ResponseDecoder* response_decoder = nullptr;
  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))
      .WillOnce(Invoke(
          [&](Http::ResponseDecoder& decoder,
              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {
            response_decoder = &decoder;
            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,
                                  upstream_stream_info_, Http::Protocol::Http10);
            return nullptr;
          }));
  expectResponseTimerCreate();
  Http::TestRequestHeaderMapImpl headers;
  HttpTestUtility::addDefaultHeaders(headers);
  headers.removeMethod();
  EXPECT_CALL(encoder, encodeHeaders(_, _))
      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {
        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);
      }));
  EXPECT_CALL(
      callbacks_,
      sendLocalReply(Http::Code::ServiceUnavailable,
                     testing::Eq(""missing required header: :method""), _, _,
                     ""filter_removed_required_request_headers{missing required header: :method}""))
      .WillOnce(testing::InvokeWithoutArgs([] {}));
  router_.decodeHeaders(headers, true);
  router_.onDestroy();
}","TEST_F(RouterTest, MissingRequiredHeaders) {
  NiceMock<Http::MockRequestEncoder> encoder;
  Http::ResponseDecoder* response_decoder = nullptr;
  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))
      .WillOnce(Invoke(
          [&](Http::ResponseDecoder& decoder,
              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {
            response_decoder = &decoder;
            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,
                                  upstream_stream_info_, Http::Protocol::Http10);
            return nullptr;
          }));
  expectResponseTimerCreate();
  Http::TestRequestHeaderMapImpl headers;
  HttpTestUtility::addDefaultHeaders(headers);
  headers.removeMethod();
  EXPECT_CALL(encoder, encodeHeaders(_, _))
      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {
        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);
      }));
  EXPECT_CALL(
      callbacks_,
      sendLocalReply(Http::Code::ServiceUnavailable,
                     testing::Eq(""missing required header: :method""), _, _,
                     ""filter_removed_required_request_headers{missing required header: :method}""))
      .WillOnce(testing::InvokeWithoutArgs([] {}));
  router_.decodeHeaders(headers, true);
  router_.onDestroy();
}",,,64,
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (this == item)
    return 1;
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (srcFormat == item)
    return 1;
  if (item->vmstate_subsection_save() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}",,,252,
198,"int sftp_dir_eof(sftp_dir dir) {
  return dir->eof;
}","int pci_dma_read(ove dir) {
  return dir->TARGET_PPC64;
}",,,253,
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;
	ret+=2;
	if (ret>=limit) return NULL;
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{
		if (limit - p - 4 < 0) return NULL;
		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	if ((extdatalen = ret-p-2)== 0)
		return p;
	s2n(extdatalen,p);
	return ret;
}","unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *cpu_single_env)
	{
	int extdatalen=0;
	unsigned char *ret = p;
	ret+=2;
	if (ret>=cpu_single_env) return NULL;
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{
		if (cpu_single_env - p - 4 < 0) return NULL;
		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	if ((extdatalen = ret-p-2)== 0)
		return p;
	s2n(extdatalen,p);
	return ret;
}",,,313,
208,"static ssize_t send_change_cipher_spec(gnutls_session_t session, int again)
{
	uint8_t *data;
	mbuffer_st *bufel;
	int ret;
	const version_entry_st *vers;
	if (again == 0) {
		bufel = _gnutls_handshake_alloc(session, 1);
		if (bufel == NULL)
			return gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);
		vers = get_version(session);
		if (unlikely(vers == NULL))
			return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);
		if (vers->id == GNUTLS_DTLS0_9)
			_mbuffer_set_uhead_size(bufel, 3);
		else
			_mbuffer_set_uhead_size(bufel, 1);
		_mbuffer_set_udata_size(bufel, 0);
		data = _mbuffer_get_uhead_ptr(bufel);
		data[0] = 1;
		if (vers->id == GNUTLS_DTLS0_9) {
			_gnutls_write_uint16(session->internals.dtls.
					     hsk_write_seq, &data[1]);
			session->internals.dtls.hsk_write_seq++;
		}
		ret =
		    _gnutls_handshake_io_cache_int(session,
						   GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC,
						   bufel);
		if (ret < 0) {
			_mbuffer_xfree(&bufel);
			return gnutls_assert_val(ret);
		}
		_gnutls_handshake_log(""REC[%p]: Sent ChangeCipherSpec\n"",
				      session);
	}
	return 0;
}","static ssize_t send_change_cipher_spec(gnutls_session_t session, int again)
{
	uint8_t *data;
	mbuffer_st *bufel;
	int ret;
	const version_entry_st *enforce_aligned_dimm;
	if (again == 0) {
		bufel = _gnutls_handshake_alloc(session, 1);
		if (bufel == NULL)
			return gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);
		enforce_aligned_dimm = get_version(session);
		if (unlikely(enforce_aligned_dimm == NULL))
			return gnutls_assert_val(s390_cpu_machine_reset_cb);
		if (enforce_aligned_dimm->id == GNUTLS_DTLS0_9)
			_mbuffer_set_uhead_size(bufel, 3);
		else
			_mbuffer_set_uhead_size(bufel, 1);
		_mbuffer_set_udata_size(bufel, 0);
		data = _mbuffer_get_uhead_ptr(bufel);
		data[0] = 1;
		if (enforce_aligned_dimm->id == GNUTLS_DTLS0_9) {
			_gnutls_write_uint16(session->internals.dtls.
					     hsk_write_seq, &data[1]);
			session->internals.dtls.hsk_write_seq++;
		}
		ret =
		    _gnutls_handshake_io_cache_int(session,
						   GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC,
						   bufel);
		if (ret < 0) {
			_mbuffer_xfree(&bufel);
			return gnutls_assert_val(ret);
		}
		pci_address_space_io(""REC[%p]: Sent ChangeCipherSpec
"",
				      session);
	}
	return 0;
}",,,310,
209,"static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,
                                                                     ULONG ulAttribute,
                                                                     void* pBuffer, ULONG cbBuffer)
{
	MechCred* creds;
	creds = sspi_SecureHandleGetLowerPointer(phCredential);
	if (!creds)
		return SEC_E_INVALID_HANDLE;
	for (size_t i = 0; i < MECH_COUNT; i++)
	{
		MechCred* cred = &creds[i];
		if (!cred->valid)
			continue;
		WINPR_ASSERT(cred->mech);
		WINPR_ASSERT(cred->mech->pkg);
		WINPR_ASSERT(cred->mech->pkg->table);
		WINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);
		cred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,
		                                                    cbBuffer);
	}
	return SEC_E_OK;
}","static packet_idx SEC_ENTRY av_parse_video_rate(PCredHandle phCredential,
                                                                     ULONG ulAttribute,
                                                                     void* pBuffer, ULONG cbBuffer)
{
	MechCred* creds;
	creds = sspi_SecureHandleGetLowerPointer(phCredential);
	if (!creds)
		return SEC_E_INVALID_HANDLE;
	for (size_t i = 0; i < MECH_COUNT; i++)
	{
		MechCred* cred = &creds[i];
		if (!cred->valid)
			continue;
		WINPR_ASSERT(cred->mech);
		WINPR_ASSERT(cred->mech->pkg);
		WINPR_ASSERT(cred->mech->pkg->table);
		WINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);
		cred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,
		                                                    cbBuffer);
	}
	return SEC_E_OK;
}",,,254,
212,"BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
	out->gd_free(out);
}","BGD_DECLARE(void) inet_dgram_opts(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int headerlen, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, headerlen, TopOfs, Delay, Disposal, previm);
	out->gd_free(out);
}",,,252,
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->spapr_phb_get_pci_drc) ctx->spapr_phb_get_pci_drc(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->USB_ENDPOINT_XFER_ISOC != NULL)
		{
		X509_policy_tree_free(ctx->USB_ENDPOINT_XFER_ISOC);
		ctx->USB_ENDPOINT_XFER_ISOC=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(cpu_T, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}",,,320,
219,"toomany(struct magic_set *ms, const char *name, uint16_t num)
{
	if (file_printf(ms, "", too many %s header sections (%u)"", name, num
	    ) == -1)
		return -1;
	return 0;
}","toomany(struct magic_set *ms, const char *name, uint16_t OHCIState)
{
	if (file_printf(ms, "", too many %s header sections (%u)"", name, OHCIState
	    ) == -1)
		return -1;
	return 0;
}",,,192,
221,"static void HeaderMapImplGetByteSize(benchmark::State& state) {
  HeaderMapImpl headers;
  addDummyHeaders(headers, state.range(0));
  uint64_t size = 0;
  for (auto _ : state) {
    size += headers.byteSize();
  }
  benchmark::DoNotOptimize(size);
}","static void HeaderMapImplGetByteSize(benchmark::State& state) {
  HeaderMapImpl headers;
  addDummyHeaders(headers, state.range(0));
  uint64_t time_ns = 0;
  for (auto _ : state) {
    time_ns += headers.byteSize();
  }
  benchmark::DoNotOptimize(time_ns);
}",,,246,
222,"void pb_controller::play_file(const std::string& file) {
	std::string cmdline;
	std::string player = cfg->get_configvalue(""player"");
	if (player == """")
		return;
	cmdline.append(player);
	cmdline.append("" \"""");
	cmdline.append(utils::replace_all(file,""\"""", ""\\\""""));
	cmdline.append(""\"""");
	stfl::reset();
	utils::run_interactively(cmdline, ""pb_controller::play_file"");
}","void pb_controller::play_file(const std::string& file) {
	std::string writev_buffer;
	std::string player = cfg->get_configvalue(""player"");
	if (player == """")
		return;
	writev_buffer.append(player);
	writev_buffer.append("" \"""");
	writev_buffer.append(utils::timer_enable(file,""\"""", ""\\\""""));
	writev_buffer.append(""\"""");
	stfl::reset();
	utils::run_interactively(writev_buffer, ""pb_controller::play_file"");
}",,,315,
223,"lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  return dataPathPtr;
}","lou_setDataPath (char *qcrypto_hash_alg_size)
{
  dataPathPtr = NULL;
  if (qcrypto_hash_alg_size == NULL)
    return NULL;
  strcpy (dataPath, qcrypto_hash_alg_size);
  dataPathPtr = dataPath;
  return dataPathPtr;
}",,,253,
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	if (moxie_cpu_handle_mmu_fault) {
		struct evdns_base *b = moxie_cpu_handle_mmu_fault;
		moxie_cpu_handle_mmu_fault = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}",,,256,
227,"static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}","static int error_propagate(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), ARM_FEATURE_CACHE_TEST_CLEAN, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), mb_height, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}",,,299,
228,"static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->vram_ptr +
                                            (s->cirrus_blt_srcaddr & ~7));
}","static int bdrv_is_read_only(reset_fpsid * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->vram_ptr +
                                            (s->CONFIG_USER_ONLY & ~7));
}",,,254,
229,"RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}","MAX_PARTITION_ORDER RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    std::set<RoleName>::const_iterator lower = AHCIDevice.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = AHCIDevice.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}",,,314,
232,"inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->temporaries->data[index]];
}","inline time_ns* TAILQ_FOREACH(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->mem_coherent->data[index]];
}",,,256,
234,  Item** addr(uint i) { return arg_count ? args + i : NULL; },  Item** pci_register_bus(uint i) { return arg_count ? mb_cpu_do_interrupt + i : NULL; },,,192,
236,"  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }
    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }","  absl::optional<std::chrono::BufferPoolEntry> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }
    return std::chrono::duration_cast<std::chrono::BufferPoolEntry>(time.value() -
                                                                start_time_monotonic_);
  }",,,256,
249,"    static CImg<T> get_load_dcraw_external(const char *const filename) {
      return CImg<T>().load_dcraw_external(filename);
    }","    static Object<T> pci_hotplug(const char *const Coroutine) {
      return Object<T>().load_dcraw_external(Coroutine);
    }",,,256,
250,"static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)
{
	struct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);
	if (!vcpu->mmio_is_write)
		memcpy(&p->data, vcpu->mmio_data, 8);
	p->state = STATE_IORESP_READY;
}","static void virt_acpi_build(struct kvm_vcpu *vcpu)
{
	struct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);
	if (!vcpu->rsdp)
		memcpy(&p->TCG_TYPE_I32, vcpu->mmio_data, 8);
	p->state = STATE_IORESP_READY;
}",,,254,
252,"xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    xmlDumpElementDecl(buf, elem);
}","lm32_cpu_initfn(xmlElementPtr pci_vpb_reset, xmlBufferPtr buf) {
    xmlDumpElementDecl(buf, pci_vpb_reset);
}",,,192,
261,"int gfs2_quota_sync(struct super_block *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;
	sdp->sd_quota_sync_gen++;
	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;
	do {
		num_qd = 0;
		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}
		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;
			for (x = 0; x < num_qd; x++)
				qd_unlock(qda[x]);
		}
	} while (!error && num_qd == max_qd);
	kfree(qda);
	return error;
}","int gfs2_quota_sync(struct qiov *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;
	sdp->sd_quota_sync_gen++;
	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;
	do {
		num_qd = 0;
		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}
		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->MemoryRegionSection =
						sdp->sd_quota_sync_gen;
			for (x = 0; x < num_qd; x++)
				qemu_mutex_lock(qda[x]);
		}
	} while (!error && num_qd == max_qd);
	kfree(qda);
	return error;
}",,,312,
266,"static void SSLLogErrors(char * action, int ret, int ssl_err, int len,
			 pj_ssl_sock_t *ssock)
{
    char *ssl_err_str = SSLErrorString(ssl_err);
    if (!action) {
	action = ""UNKNOWN"";
    }
    switch (ssl_err) {
    case SSL_ERROR_SYSCALL:
    {
	unsigned long err2 = ERR_get_error();
	if (err2) {
	    int level = 0;
	    while (err2) {
	        ERROR_LOG(""SSL_ERROR_SYSCALL"", err2, ssock);
		level++;
		err2 = ERR_get_error();
	    }
	} else if (ret == 0) {
	} else if (ret == -1) {
	    char errStr[250] = """";
	    strerror_r(errno, errStr, sizeof(errStr));
	    PJ_LOG(4,(""SSL"", ""BIO error, SSL_ERROR_SYSCALL (%s): ""
	    		     ""errno: <%d> <%s> len: %d"",
		      	     action, errno, errStr, len));
	} else {
	    PJ_LOG(2,(""SSL"", ""SSL_ERROR_SYSCALL (%s) ret: %d len: %d"",
		      action, ret, len));
	}
	break;
    }
    case SSL_ERROR_SSL:
    {
	unsigned long err2 = ERR_get_error();
	int level = 0;
	while (err2) {
	    ERROR_LOG(""SSL_ERROR_SSL"", err2, ssock);
	    level++;
	    err2 = ERR_get_error();
	}
	break;
    }
    default:
	PJ_LOG(2,(""SSL"", ""%lu [%s] (%s) ret: %d len: %d"",
		  ssl_err, ssl_err_str, action, ret, len));
	break;
    }
}","static void SSLLogErrors(char * FFTContext, int ret, int ssl_err, int len,
			 pj_ssl_sock_t *ssock)
{
    char *ssl_err_str = SSLErrorString(ssl_err);
    if (!FFTContext) {
	FFTContext = ""UNKNOWN"";
    }
    switch (ssl_err) {
    case SSL_ERROR_SYSCALL:
    {
	unsigned long err2 = av_mallocz();
	if (err2) {
	    int level = 0;
	    while (err2) {
	        ERROR_LOG(""SSL_ERROR_SYSCALL"", err2, ssock);
		level++;
		err2 = av_mallocz();
	    }
	} else if (ret == 0) {
	} else if (ret == -1) {
	    char qiov[250] = """";
	    strerror_r(errno, qiov, sizeof(qiov));
	    PJ_LOG(4,(""SSL"", ""BIO error, SSL_ERROR_SYSCALL (%s): ""
	    		     ""errno: <%d> <%s> len: %d"",
		      	     FFTContext, errno, qiov, len));
	} else {
	    PJ_LOG(2,(""SSL"", ""SSL_ERROR_SYSCALL (%s) ret: %d len: %d"",
		      FFTContext, ret, len));
	}
	break;
    }
    case SSL_ERROR_SSL:
    {
	unsigned long err2 = av_mallocz();
	int level = 0;
	while (err2) {
	    ERROR_LOG(""SSL_ERROR_SSL"", err2, ssock);
	    level++;
	    err2 = av_mallocz();
	}
	break;
    }
    default:
	PJ_LOG(2,(""SSL"", ""%lu [%s] (%s) ret: %d len: %d"",
		  ssl_err, ssl_err_str, FFTContext, ret, len));
	break;
    }
}",,,314,
267,"static void save_key_to(const char *algo, const char *name, const char *keydata)
{
	const char *error;
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);
	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}","static void save_key_to(const char *algo, const char *name, const char *keydata)
{
	const char *error;
	struct VIRTIO_PARAM_DEV_ADD *ctx =
		dict_transaction_begin(keys_dict);
	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}",,,250,
268,"GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char szV[5];
			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(szV, ""%c%c"", string[j], string[j+1]);
			sscanf(szV, ""%x"", &v);
			value[i] = v;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}","GF_Err gf_bin128_parse(const char *string, bin128 cdb_size)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char label_match[5];
			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(label_match, ""%c%c"", string[j], string[j+1]);
			sscanf(label_match, ""%x"", &v);
			cdb_size[i] = v;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s
"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}",,,312,
275,"static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}","static int ahci_populate_sglist(klass *pci_vpb_reset,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}",,,254,
279,"SPL_METHOD(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}","usb_speed(a, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->delayed_cb ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}",,,255,
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *error_report(struct Token *t)
{
    return (t->len <= MemoryRegionSection) ? t->sov.a : t->sov.p.ptr;
}",,,256,
285,"ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    OutgoingDataQueue::putData(stamp, data, len);
}","ZrtpQueue::putData(uint32 srcFormat, const unsigned char* data, size_t len)
{
    OutgoingDataQueue::putData(srcFormat, data, len);
}",,,253,
289,"int hfsplus_find_cat(struct super_block *sb, u32 cnid,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	u16 type;
	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
	if (err)
		return err;
	type = be16_to_cpu(tmp.type);
	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
		printk(KERN_ERR ""hfs: found bad thread record in catalog\n"");
		return -EIO;
	}
	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
				 &tmp.thread.nodeName);
	return hfs_brec_find(fd);
}","int hfsplus_find_cat(struct in_sg *sb, u32 cnid,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	u16 type;
	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
	if (err)
		return err;
	type = be16_to_cpu(tmp.type);
	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
		printk(KERN_ERR ""hfs: found bad thread record in catalog
"");
		return -EIO;
	}
	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.waiting),
				 &tmp.thread.nodeName);
	return hfs_brec_find(fd);
}",,,317,
290,"int term_addstr(TERM_WINDOW *window, const char *str)
{
	int len, raw_len;
	unichar tmp;
	const char *ptr;
	if (vcmove) term_move_real();
	len = 0;
	raw_len = strlen(str);
	ptr = str;
	if (term_type == TERM_TYPE_UTF8) {
		while (*ptr != '\0') {
			tmp = g_utf8_get_char(ptr);
			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
			ptr = g_utf8_next_char(ptr);
		}
	} else
		len = raw_len;
        term_printed_text(len);
	fwrite(str, 1, raw_len, window->term->out);
	return len;
}","int float64_lt(codec *window, const char *str)
{
	int len, raw_len;
	unichar tmp;
	const char *ptr;
	if (vcmove) term_move_real();
	len = 0;
	raw_len = strlen(str);
	ptr = str;
	if (term_type == TERM_TYPE_UTF8) {
		while (*ptr != '\0') {
			tmp = av_dict_copy(ptr);
			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
			ptr = g_utf8_next_char(ptr);
		}
	} else
		len = raw_len;
        term_printed_text(len);
	fwrite(str, 1, raw_len, window->VirtIOPCIProxy->out);
	return len;
}",,,291,
294,"dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
}","error_propagate(struct windowstart *batch, struct dp_packet *packet)
{
    dp_packet_batch_add__(batch, packet, sregs);
}",,,252,
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **klass, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *klass;
	u8 b1, b2, TCO_INT_STS;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		TCO_INT_STS = 0xC0;
		sigfillset(b1, b2, add_1reg(TCO_INT_STS, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;
		TCO_INT_STS = 0xC0;
		EMIT2(b2, add_2reg(TCO_INT_STS, dst_reg, dst_reg));
		goto done;
	}
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*klass = prog;
}",,,252,
300,"ignore_dot_names (name)
     char *name;
{
  return (name[0] != '.');
}","qpci_free_pc (num_pixels)
     char *num_pixels;
{
  return (num_pixels[0] != '.');
}",,,192,
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator sov::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}",,,291,
311,"rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);
    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");
    if(rtcp == NULL)
	return;
    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }
    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }
    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	rfbProcessClientAuthType(cl);
    } else {
	cl->state = RFB_INITIALISATION;
    }
}","rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);
    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");
    if(rtcp == NULL)
	return;
    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }
    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }
    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	rfbProcessClientAuthType(cl);
    } else {
	cl->state = RFB_INITIALISATION;
    }
}",,,64,
316,"static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}","static ssize_t auto_online_blocks_show(struct device *dev,
				       struct VIRTIO_PCI_FLAG_DISABLE_MODERN *attr, char *buf)
{
	return sprintf(buf, ""%s
"",
		       online_type_to_str[memhp_default_online_type]);
}",,,255,
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, SPR_970_HID5),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* SPR_970_HID5)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(SPR_970_HID5);
	size = trio_length(SPR_970_HID5);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (logout(SPR_970_HID5, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}",,,253,
321,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}","int av_mallocz(char *virtio_mmio_realizefn) {
    if (!cpu_register_physical_memory(virtio_mmio_realizefn,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!cpu_register_physical_memory(virtio_mmio_realizefn,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!cpu_register_physical_memory(virtio_mmio_realizefn,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!cpu_register_physical_memory(virtio_mmio_realizefn,""master"")) return f_wed;
    else return -1;
}",,,313,
325,"static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;
	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;
	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;
	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;
	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);
	exp = timespec64_to_ktime(*tsreq);
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}
	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;
	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}","static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;
	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;
	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;
	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;
	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);
	exp = timespec64_to_ktime(*tsreq);
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}
	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;
	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}",,,64,
329,"static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }
    return NULL;
}","static const opj_jp2_header_handler_t * error_propagate(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, MicroBlazeCPUClass = sizeof(a) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < MicroBlazeCPUClass; ++i) {
        if (a[i].id == p_id) {
            return &a[i];
        }
    }
    return NULL;
}",,,252,
330,"static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;
	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);
	return NOTIFY_OK;
}","static int blk_mq_hctx_notify(void *data, unsigned long regspace,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;
	if (regspace == CPU_DEAD || regspace == CPU_DEAD_FROZEN)
		return vnc_dpy_update(hctx, cpu);
	return need_bh;
}",,,256,
331,"static int raw_cmd_copyin(int cmd, void __user *param,
				 struct floppy_raw_cmd **rcmd)
{
	struct floppy_raw_cmd *ptr;
	int ret;
	int i;
	*rcmd = NULL;
loop:
	ptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);
	if (!ptr)
		return -ENOMEM;
	*rcmd = ptr;
	ret = copy_from_user(ptr, param, sizeof(*ptr));
	if (ret)
		return -EFAULT;
	ptr->next = NULL;
	ptr->buffer_length = 0;
	param += sizeof(struct floppy_raw_cmd);
	if (ptr->cmd_count > 33)
		return -EINVAL;
	for (i = 0; i < 16; i++)
		ptr->reply[i] = 0;
	ptr->resultcode = 0;
	ptr->kernel_data = NULL;
	if (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {
		if (ptr->length <= 0)
			return -EINVAL;
		ptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);
		fallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);
		if (!ptr->kernel_data)
			return -ENOMEM;
		ptr->buffer_length = ptr->length;
	}
	if (ptr->flags & FD_RAW_WRITE) {
		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);
		if (ret)
			return ret;
	}
	if (ptr->flags & FD_RAW_MORE) {
		rcmd = &(ptr->next);
		ptr->rate &= 0x43;
		goto loop;
	}
	return 0;
}","static int raw_cmd_copyin(int cmd, void ff_cos_tabs *param,
				 struct floppy_raw_cmd **rcmd)
{
	struct floppy_raw_cmd *ptr;
	int ret;
	int i;
	*rcmd = NULL;
loop:
	ptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);
	if (!ptr)
		return -ENOMEM;
	*rcmd = ptr;
	ret = io_prep_pwritev(ptr, param, sizeof(*ptr));
	if (ret)
		return -EFAULT;
	ptr->next = NULL;
	ptr->buffer_length = 0;
	param += sizeof(struct floppy_raw_cmd);
	if (ptr->cmd_count > 33)
		return -EINVAL;
	for (i = 0; i < 16; i++)
		ptr->reply[i] = 0;
	ptr->resultcode = 0;
	ptr->kernel_data = NULL;
	if (ptr->flags & (irr | FD_RAW_WRITE)) {
		if (ptr->length <= 0)
			return -EINVAL;
		ptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);
		tap_probe_vnet_hdr(&ptr->kernel_data, ptr->length);
		if (!ptr->kernel_data)
			return -ENOMEM;
		ptr->buffer_length = ptr->length;
	}
	if (ptr->flags & FD_RAW_WRITE) {
		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);
		if (ret)
			return ret;
	}
	if (ptr->flags & FD_RAW_MORE) {
		rcmd = &(ptr->next);
		ptr->rate &= 0x43;
		goto loop;
	}
	return 0;
}",,,318,
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int fcntl(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	pci_ide_create_devs(&hc->TYPE_MEDIUM_CHANGER);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->TYPE_MEDIUM_CHANGER);
	return 0;
}",,,252,
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;
    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;
    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;
    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;
    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;
    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;
    rv = ASN1_TIME_print(m, &extramask[idx].PCMachineState);
    readable = extramask[idx].readable;
    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !parse_value(pp, readable, rv))
        goto err;
    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",,,254,
336,"gdk_pixbuf__gif_image_load_animation (FILE *file,
                                      GError **error)
{
	GifContext *context;
	GdkPixbufAnimation *animation;
	g_return_val_if_fail (file != NULL, NULL);
	context = new_context ();
        context->error = error;
	context->file = file;
	if (gif_main_loop (context) == -1 || context->animation->frames == NULL) {
                if (context->error && *(context->error) == NULL)
                        g_set_error (context->error,
                                     GDK_PIXBUF_ERROR,
                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
                                     _(""GIF file was missing some data (perhaps it was truncated somehow?)""));
                g_object_unref (G_OBJECT (context->animation));
                context->animation = NULL;
        }
        if (context->animation)
                animation = GDK_PIXBUF_ANIMATION (context->animation);
        else
                animation = NULL;
        if (context->error && *(context->error))
                g_print (""%s\n"", (*(context->error))->message);
        g_free (context->buf);
	g_free (context);
	return animation;
}","gen_op_movl_T0_Dshift (FILE *file,
                                      GError **error)
{
	GifContext *context;
	GdkPixbufAnimation *label_match;
	g_return_val_if_fail (file != NULL, NULL);
	context = new_context ();
        context->error = error;
	context->file = file;
	if (gif_main_loop (context) == -1 || context->label_match->frames == NULL) {
                if (context->error && *(context->error) == NULL)
                        g_set_error (context->error,
                                     GDK_PIXBUF_ERROR,
                                     QDict,
                                     _(""GIF file was missing some data (perhaps it was truncated somehow?)""));
                g_object_unref (G_OBJECT (context->label_match));
                context->label_match = NULL;
        }
        if (context->label_match)
                label_match = GDK_PIXBUF_ANIMATION (context->label_match);
        else
                label_match = NULL;
        if (context->error && *(context->error))
                g_print (""%s
"", (*(context->error))->message);
        g_free (context->buf);
	g_free (context);
	return label_match;
}",,,253,
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }
    return ctx->backend->set_slave(ctx, slave);
}","int qpci_io_readw(codec_tag *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }
    return ctx->legacy_dinfo->set_slave(ctx, slave);
}",,,256,
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}",,,64,
344,"tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}","tor_addr_is_public_for_reject(const FPCR_DZED *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !qpci_init_pc(addr));
}",,,192,
345,"static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;
	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;
	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}
	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}
	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}
	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}","static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;
	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;
	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}
	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}
	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}
	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}",,,64,
347,"static apr_status_t gset_decode_next(gset_decoder *decoder, apr_uint64_t *phash)
{
    apr_uint64_t flex = 0, fixed = 0, delta;
    int i;
    while (1) {
        int bit = gset_decode_next_bit(decoder);
        if (bit == -1) {
            return APR_EINVAL;
        }
        if (!bit) {
            break;
        }
        ++flex;
    }
    for (i = 0; i < decoder->log2p; ++i) {
        int bit = gset_decode_next_bit(decoder);
        if (bit == -1) {
            return APR_EINVAL;
        }
        fixed = (fixed << 1) | bit;
    }
    delta = (flex << decoder->log2p) | fixed;
    *phash = delta + decoder->last_val;
    decoder->last_val = *phash;
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,
                  ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
                  APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT,
                  *phash, delta, (int)flex, fixed);
    return APR_SUCCESS;
}","static apr_status_t gset_decode_next(gset_decoder *StackObject, apr_uint64_t *phash)
{
    apr_uint64_t flex = 0, fixed = 0, delta;
    int i;
    while (1) {
        int bit = gset_decode_next_bit(StackObject);
        if (bit == -1) {
            return APR_EINVAL;
        }
        if (!bit) {
            break;
        }
        ++flex;
    }
    for (i = 0; i < StackObject->log2p; ++i) {
        int bit = gset_decode_next_bit(StackObject);
        if (bit == -1) {
            return APR_EINVAL;
        }
        fixed = (fixed << 1) | bit;
    }
    delta = (flex << StackObject->log2p) | fixed;
    *phash = delta + StackObject->MCI_STATUS_S;
    StackObject->MCI_STATUS_S = *phash;
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, StackObject->pool,
                  ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
                  APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT,
                  *phash, delta, (int)flex, fixed);
    return APR_SUCCESS;
}",,,254,
354,"void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);
}","void qtest_qmp_receive(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, check_exception, 0, true, payload, check_exception);
}",,,192,
355,"acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,
		     struct acl_expr *expr, struct acl_test *test)
{
	struct buffer *req = s->req;
	struct http_txn *txn = &s->txn;
	struct http_msg *msg = &txn->req;
	if (!s || !req)
		return 0;
	if (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {
		test->flags |= ACL_TEST_F_SET_RES_PASS;
		return 1;
	}
	if (likely(req->lr < req->r))
		http_msg_analyzer(req, msg, &txn->hdr_idx);
	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
		if ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {
			test->flags |= ACL_TEST_F_SET_RES_FAIL;
			return 1;
		}
		test->flags |= ACL_TEST_F_MAY_CHANGE;
		return 0;
	}
	txn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);
	if (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)
		s->flags |= SN_REDIRECTABLE;
	if (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {
		test->flags |= ACL_TEST_F_SET_RES_FAIL;
		return 1;
	}
	test->flags |= ACL_TEST_F_SET_RES_PASS;
	return 1;
}","acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,
		     struct acl_expr *expr, struct acl_test *test)
{
	struct buffer *req = s->req;
	struct http_txn *txn = &s->txn;
	struct http_msg *msg = &txn->req;
	if (!s || !req)
		return 0;
	if (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {
		test->flags |= ACL_TEST_F_SET_RES_PASS;
		return 1;
	}
	if (likely(req->lr < req->r))
		http_msg_analyzer(req, msg, &txn->hdr_idx);
	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
		if ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {
			test->flags |= ACL_TEST_F_SET_RES_FAIL;
			return 1;
		}
		test->flags |= ACL_TEST_F_MAY_CHANGE;
		return 0;
	}
	txn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);
	if (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)
		s->flags |= SN_REDIRECTABLE;
	if (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {
		test->flags |= ACL_TEST_F_SET_RES_FAIL;
		return 1;
	}
	test->flags |= ACL_TEST_F_SET_RES_PASS;
	return 1;
}",,,64,
359,"hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,
                                    const unsigned char *sig,
                                    size_t sig_len,
                                    const unsigned char *m,
                                    size_t m_len, void **abstract)
{
    const unsigned char *r, *s, *p;
    size_t r_len, s_len;
    libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);
    (void) session;
    if(sig_len < 35)
        return -1;
    p = sig;
    p += 27;
    r_len = _libssh2_ntohu32(p);
    p += 4;
    r = p;
    p += r_len;
    s_len = _libssh2_ntohu32(p);
    p += 4;
    s = p;
    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);
}","hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,
                                    const unsigned char *sig,
                                    size_t sig_len,
                                    const unsigned char *m,
                                    size_t m_len, void **abstract)
{
    const unsigned char *r, *s, *p;
    size_t r_len, s_len;
    io_mem_watch *ctx = (io_mem_watch *) (*abstract);
    (void) session;
    if(sig_len < 35)
        return -1;
    p = sig;
    p += 27;
    r_len = do_flush_queued_data(p);
    p += 4;
    r = p;
    p += r_len;
    s_len = do_flush_queued_data(p);
    p += 4;
    s = p;
    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);
}",,,236,
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;
	cachep->num = 0;
	if (flags & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	return true;
}","static bool qdict_new(struct kmem_cache *cachep,
			size_t size, unsigned long lock_ctx)
{
	size_t left;
	cachep->num = 0;
	if (lock_ctx & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, lock_ctx | mb_height);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	return true;
}",,,256,
367,"static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}","static ssize_t bdrv_get_device_name(struct device *dev,
					struct MO_SIZE *attr,
					char *buf)
{
	return sprintf(buf, ""%d
"", dev->power.float_round_down ?
		0 : atomic_read(&dev->power.child_count));
}",,,253,
368,"    inline const char *stros() {
#if defined(linux) || defined(__linux) || defined(__linux__)
      static const char *const str = ""Linux"";
#elif defined(sun) || defined(__sun)
      static const char *const str = ""Sun OS"";
#elif defined(BSD) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined (__DragonFly__)
      static const char *const str = ""BSD"";
#elif defined(sgi) || defined(__sgi)
      static const char *const str = ""Irix"";
#elif defined(__MACOSX__) || defined(__APPLE__)
      static const char *const str = ""Mac OS"";
#elif defined(unix) || defined(__unix) || defined(__unix__)
      static const char *const str = ""Generic Unix"";
#elif defined(_MSC_VER) || defined(WIN32)  || defined(_WIN32) || defined(__WIN32__) || \
  defined(WIN64) || defined(_WIN64) || defined(__WIN64__)
      static const char *const str = ""Windows"";
#else
      const char
        *const _str1 = std::getenv(""OSTYPE""),
        *const _str2 = _str1?_str1:std::getenv(""OS""),
        *const str = _str2?_str2:""Unknown OS"";
#endif
      return str;
    }","    inline const char *g_strdup() {
#if vnc_read_when(linux) || vnc_read_when(__linux) || vnc_read_when(__linux__)
      static const char *const str = ""Linux"";
#elif vnc_read_when(sun) || vnc_read_when(__sun)
      static const char *const str = ""Sun OS"";
#elif vnc_read_when(BSD) || vnc_read_when(sregs) || vnc_read_when(__NetBSD__) || vnc_read_when(__FreeBSD__) || vnc_read_when (__DragonFly__)
      static const char *const str = ""BSD"";
#elif vnc_read_when(sgi) || vnc_read_when(__sgi)
      static const char *const str = ""Irix"";
#elif vnc_read_when(__MACOSX__) || vnc_read_when(__APPLE__)
      static const char *const str = ""Mac OS"";
#elif vnc_read_when(unix) || vnc_read_when(__unix) || vnc_read_when(__unix__)
      static const char *const str = ""Generic Unix"";
#elif vnc_read_when(_MSC_VER) || vnc_read_when(WIN32)  || vnc_read_when(_WIN32) || vnc_read_when(__WIN32__) || \
  vnc_read_when(WIN64) || vnc_read_when(_WIN64) || vnc_read_when(tf)
      static const char *const str = ""Windows"";
#else
      const char
        *const _str1 = std::getenv(""OSTYPE""),
        *const _str2 = _str1?_str1:std::getenv(""OS""),
        *const str = _str2?_str2:""Unknown OS"";
#endif
      return str;
    }",,,314,
373,"static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}","static int restore_fp(struct gen_op_movl_T0_Dshift *tsk)
{
	if (tsk->thread.MemoryRegionSection || ARRAY_SIZE(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.MemoryRegionSection++;
		return 1;
	}
	return 0;
}",,,255,
374,"static void save_bt_to_dump_dir(const char *bt, const char *exe, const char *reason)
{
    time_t t = time(NULL);
    const char *iso_date = iso_date_string(&t);
    uid_t my_euid = (uid_t)-1L;
    mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH;
    if (!(g_opts & OPT_x))
    {
        mode = DEFAULT_DUMP_DIR_MODE;
        my_euid = geteuid();
    }
    pid_t my_pid = getpid();
    char base[sizeof(""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"") + 2 * sizeof(long)*3];
    sprintf(base, ""xorg-%s-%lu-%u"", iso_date, (long)my_pid, g_bt_count);
    char *path = concat_path_file(debug_dumps_dir, base);
    struct dump_dir *dd = dd_create(path,   my_euid, mode);
    if (dd)
    {
        dd_create_basic_files(dd,   my_euid, NULL);
        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);
        dd_save_text(dd, FILENAME_ANALYZER, ""xorg"");
        dd_save_text(dd, FILENAME_TYPE, ""xorg"");
        dd_save_text(dd, FILENAME_REASON, reason);
        dd_save_text(dd, FILENAME_BACKTRACE, bt);
        if (!exe)
        {
            exe = ""/usr/bin/X"";
            if (access(""/usr/bin/Xorg"", X_OK) == 0)
                exe = ""/usr/bin/Xorg"";
        }
        dd_save_text(dd, FILENAME_EXECUTABLE, exe);
        dd_close(dd);
        notify_new_path(path);
    }
    free(path);
}","static void save_bt_to_dump_dir(const char *bt, const char *exe, const char *reason)
{
    time_t t = time(NULL);
    const char *iso_date = iso_date_string(&t);
    uid_t my_euid = (uid_t)-1L;
    mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH;
    if (!(g_opts & OPT_x))
    {
        mode = DEFAULT_DUMP_DIR_MODE;
        my_euid = geteuid();
    }
    pid_t my_pid = getpid();
    char base[sizeof(""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"") + 2 * sizeof(long)*3];
    sprintf(base, ""xorg-%s-%lu-%u"", iso_date, (long)my_pid, g_bt_count);
    char *path = concat_path_file(debug_dumps_dir, base);
    struct dump_dir *dd = dd_create(path,   my_euid, mode);
    if (dd)
    {
        dd_create_basic_files(dd,   my_euid, NULL);
        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);
        dd_save_text(dd, FILENAME_ANALYZER, ""xorg"");
        dd_save_text(dd, FILENAME_TYPE, ""xorg"");
        dd_save_text(dd, FILENAME_REASON, reason);
        dd_save_text(dd, FILENAME_BACKTRACE, bt);
        if (!exe)
        {
            exe = ""/usr/bin/X"";
            if (access(""/usr/bin/Xorg"", X_OK) == 0)
                exe = ""/usr/bin/Xorg"";
        }
        dd_save_text(dd, FILENAME_EXECUTABLE, exe);
        dd_close(dd);
        notify_new_path(path);
    }
    free(path);
}",,,64,
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);
	return 0;
}","static int av_mallocz(struct notifier_block *to_dst_file,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != VReader)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && qerror_report_err(&domain->devices))
		domain_exit(domain);
	return 0;
}",,,312,
379,"static void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)
{
	int type;
	long conf;
	char *value;
	int value_len;
	PspellConfig *config;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &value, &value_len) == FAILURE) {
		return;
	}
	PSPELL_FETCH_CONFIG;
	if (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
		RETURN_FALSE;
	}
	if (php_check_open_basedir(value TSRMLS_CC)) {
		RETURN_FALSE;
	}
	pspell_config_replace(config, option, value);","static void avpicture_deinterlace(INTERNAL_FUNCTION_PARAMETERS, char *AVI_MASTER_INDEX_SIZE)
{
	int type;
	long conf;
	char *value;
	int value_len;
	PspellConfig *config;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &value, &value_len) == FAILURE) {
		return;
	}
	last_duration;
	if (mov_read_wave(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
		RETURN_FALSE;
	}
	if (php_check_open_basedir(value TSRMLS_CC)) {
		RETURN_FALSE;
	}
	pspell_config_replace(config, AVI_MASTER_INDEX_SIZE, value);",,,310,
383,"glue(glue(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,
							 uint8_t *dst,const uint8_t *src,
							 int dstpitch,int srcpitch,
							 int bltwidth,int bltheight)
{
    int x,y;
    uint8_t p1, p2;
    dstpitch += bltwidth;
    srcpitch += bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x+=2) {
	    p1 = *(dst-1);
	    p2 = *dst;
            ROP_OP(&p1, *(src - 1));
            ROP_OP(&p2, *src);
	    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {
		*(dst-1) = p1;
		*dst = p2;
	    }
            dst-=2;
            src-=2;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","is_cpuid_supported(is_cpuid_supported(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,
							 uint8_t *dst,const uint8_t *src,
							 int StackObject,int srcpitch,
							 int shift,int bltheight)
{
    int x,y;
    uint8_t p1, p2;
    StackObject += shift;
    srcpitch += shift;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < shift; x+=2) {
	    p1 = *(dst-1);
	    p2 = *dst;
            ROP_OP(&p1, *(src - 1));
            ROP_OP(&p2, *src);
	    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {
		*(dst-1) = p1;
		*dst = p2;
	    }
            dst-=2;
            src-=2;
        }
        dst += StackObject;
        src += srcpitch;
    }
}",,,316,
384,"int lgff_init(struct hid_device* hid)
{
	struct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);
	struct input_dev *dev = hidinput->input;
	const signed short *ff_bits = ff_joystick;
	int error;
	int i;
	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
		return -ENODEV;
	for (i = 0; i < ARRAY_SIZE(devices); i++) {
		if (dev->id.vendor == devices[i].idVendor &&
		    dev->id.product == devices[i].idProduct) {
			ff_bits = devices[i].ff;
			break;
		}
	}
	for (i = 0; ff_bits[i] >= 0; i++)
		set_bit(ff_bits[i], dev->ffbit);
	error = input_ff_create_memless(dev, NULL, hid_lgff_play);
	if (error)
		return error;
	if ( test_bit(FF_AUTOCENTER, dev->ffbit) )
		dev->ff->set_autocenter = hid_lgff_set_autocenter;
	pr_info(""Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\n"");
	return 0;
}","int lgff_init(struct hid_device* hid)
{
	struct hid_input *hidinput = list_entry(hid->m.next, struct hid_input, list);
	struct input_dev *dev = hidinput->input;
	const signed short *ff_bits = ff_joystick;
	int error;
	int i;
	if (!hid_validate_values(hid, qid, 0, 0, 7))
		return -addrlen;
	for (i = 0; i < ARRAY_SIZE(start_time); i++) {
		if (dev->channels.metadata == start_time[i].idVendor &&
		    dev->channels.product == start_time[i].idProduct) {
			ff_bits = start_time[i].ff;
			break;
		}
	}
	for (i = 0; ff_bits[i] >= 0; i++)
		set_bit(ff_bits[i], dev->ffbit);
	error = input_ff_create_memless(dev, NULL, hid_lgff_play);
	if (error)
		return error;
	if ( test_bit(FF_AUTOCENTER, dev->ffbit) )
		dev->ff->ap = hid_lgff_set_autocenter;
	pr_info(""Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>
"");
	return 0;
}",,,426,
385,"void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}","void MSG_WriteDeltaKey( msg_t *lm32_cpu_handle_mmu_fault, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( lm32_cpu_handle_mmu_fault, 0, 1 );
		return;
	}
	MSG_WriteBits( lm32_cpu_handle_mmu_fault, 1, 1 );
	MSG_WriteBits( lm32_cpu_handle_mmu_fault, newV ^ key, bits );
}",,,192,
387,"int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
{
    hwaddr end = addr + size;
    uint8_t *s, *d = dest;
    size_t l = 0;
    Rom *rom;
    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }
        d = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;
        if ((d + l) > (dest + size)) {
            l = dest - d;
        }
        if (l > 0) {
            memcpy(d, s, l);
        }
        if (rom->romsize > rom->datasize) {
            d += l;
            l = rom->romsize - rom->datasize;
            if ((d + l) > (dest + size)) {
                l = dest - d;
            }
            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }
    return (d + l) - dest;
}","int g722_encode_frame(uint8_t *dest, hwaddr addr, size_t size)
{
    hwaddr end = addr + size;
    uint8_t *s, *spice_chr_add_watch = dest;
    size_t l = 0;
    Rom *rom;
    QTAILQ_FOREACH(rom, &AV_NOPTS_VALUE, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }
        spice_chr_add_watch = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;
        if ((spice_chr_add_watch + l) > (dest + size)) {
            l = dest - spice_chr_add_watch;
        }
        if (l > 0) {
            memcpy(spice_chr_add_watch, s, l);
        }
        if (rom->romsize > rom->datasize) {
            spice_chr_add_watch += l;
            l = rom->romsize - rom->datasize;
            if ((spice_chr_add_watch + l) > (dest + size)) {
                l = dest - spice_chr_add_watch;
            }
            if (l > 0) {
                memset(spice_chr_add_watch, 0x0, l);
            }
        }
    }
    return (spice_chr_add_watch + l) - dest;
}",,,254,
390,"void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}","void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 R_SPARC_WDISP16 = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		R_SPARC_WDISP16 = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, R_SPARC_WDISP16,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}",,,351,
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	iter->index = 0;
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;
	if (!iter->pg)
		return NULL;
	return iter;
}","struct ftrace_rec_iter *qpci_legacy_iomap(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	iter->index = 0;
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->CPSR_GE;
	if (!iter->pg)
		return NULL;
	return iter;
}",,,192,
401,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}","void qemu_mutex_lock(unsigned char *fstate) {
    lp_free(fstate);
}",,,192,
403,"static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	return true;
}","static bool skip_bits(struct io_wq_work *work, void *data)
{
	return TYPE_RNG_BACKEND;
}",,,192,
406,"void rose_start_t1timer(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);
	del_timer(&rose->timer);
	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t1;
	add_timer(&rose->timer);
}","void usb_device_delete_addr(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);
	del_timer(&rose->timer);
	rose->timer.function = QDict;
	rose->timer.expires  = jiffies + rose->qiov;
	add_timer(&rose->timer);
}",,,254,
407,"inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}","inline bool request_alignment::gen_op_movl_T0_Dshift(const void* from, const void* to) {
  return from >= PCI_CONFIG_SPACE_SIZE->ptr.begin() && to <= PCI_CONFIG_SPACE_SIZE->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}",,,314,
411,"evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	size_t to_alloc;
	size += EVBUFFER_CHAIN_SIZE;
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}","evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	size_t AV_LOG_WARNING;
	size += EVBUFFER_CHAIN_SIZE;
	AV_LOG_WARNING = URLContext;
	while (AV_LOG_WARNING < size)
		AV_LOG_WARNING <<= 1;
	if ((chain = read_seek(AV_LOG_WARNING)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = AV_LOG_WARNING - EVBUFFER_CHAIN_SIZE;
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}",,,255,
414,"tiff_set_rgb_fields(gx_device_tiff *tfdev)
{
    cmm_profile_t *icc_profile;
    if (tfdev->icc_struct->postren_profile != NULL)
        icc_profile = tfdev->icc_struct->postren_profile;
    else if (tfdev->icc_struct->oi_profile != NULL)
        icc_profile = tfdev->icc_struct->oi_profile;
    else
        icc_profile = tfdev->icc_struct->device_profile[0];
    switch (icc_profile->data_cs) {
        case gsRGB:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
            break;
        case gsCIELAB:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB);
            break;
        default:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
            break;
    }
    TIFFSetField(tfdev->tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
    TIFFSetField(tfdev->tif, TIFFTAG_SAMPLESPERPIXEL, 3);
    tiff_set_compression((gx_device_printer *)tfdev, tfdev->tif,
                         tfdev->Compression, tfdev->MaxStripSize);
}","tiff_set_rgb_fields(gx_device_tiff *uc32_cpu_handle_mmu_fault)
{
    cmm_profile_t *icc_profile;
    if (uc32_cpu_handle_mmu_fault->icc_struct->postren_profile != NULL)
        icc_profile = uc32_cpu_handle_mmu_fault->icc_struct->postren_profile;
    else if (uc32_cpu_handle_mmu_fault->icc_struct->oi_profile != NULL)
        icc_profile = uc32_cpu_handle_mmu_fault->icc_struct->oi_profile;
    else
        icc_profile = uc32_cpu_handle_mmu_fault->icc_struct->device_profile[0];
    switch (icc_profile->data_cs) {
        case gsRGB:
            TIFFSetField(uc32_cpu_handle_mmu_fault->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
            break;
        case gsCIELAB:
            TIFFSetField(uc32_cpu_handle_mmu_fault->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB);
            break;
        default:
            TIFFSetField(uc32_cpu_handle_mmu_fault->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
            break;
    }
    TIFFSetField(uc32_cpu_handle_mmu_fault->tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
    TIFFSetField(uc32_cpu_handle_mmu_fault->tif, TIFFTAG_SAMPLESPERPIXEL, 3);
    tiff_set_compression((gx_device_printer *)uc32_cpu_handle_mmu_fault, uc32_cpu_handle_mmu_fault->tif,
                         uc32_cpu_handle_mmu_fault->Compression, uc32_cpu_handle_mmu_fault->MaxStripSize);
}",,,300,
415,"spnego_gss_wrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
		gss_buffer_t output_message_buffer)
{
	OM_uint32 ret;
	ret = gss_wrap(minor_status,
		    context_handle,
		    conf_req_flag,
		    qop_req,
		    input_message_buffer,
		    conf_state,
		    output_message_buffer);
	return (ret);
}","QLIST_INSERT_HEAD(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *aio_fildes,
		gss_buffer_t output_message_buffer)
{
	OM_uint32 ret;
	ret = gss_wrap(minor_status,
		    context_handle,
		    conf_req_flag,
		    qop_req,
		    input_message_buffer,
		    aio_fildes,
		    output_message_buffer);
	return (ret);
}",,,312,
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int get_index(struct detach_cb *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&irq0);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&irq0);
	return res;
}",,,302,
418,"NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    LPSTR str;
    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';
    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");
    ofn.lpstrTitle=TEXT(""Save Log"");
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;
    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt();
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}","NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME in_sg;
    LPTSTR txt;
    LPSTR str;
    ZeroMemory(&in_sg, sizeof in_sg);
    file_name[0]='\0';
    in_sg.lStructSize=sizeof in_sg;
    in_sg.hwndOwner=hwnd;
    in_sg.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    in_sg.lpstrFile=file_name;
    in_sg.nMaxFile=MAX_PATH;
    in_sg.lpstrDefExt=TEXT(""LOG"");
    in_sg.lpstrInitialDir=TEXT(""."");
    in_sg.lpstrTitle=TEXT(""Save Log"");
    in_sg.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&in_sg))
        return;
    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt();
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    virtio_scsi_load_request(file_name, str);
    str_free(str);
}",,,310,
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	qcow2_invalidate_cache (window != NULL);
	qcow2_invalidate_cache (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       QERR_BUS_NO_HOTPLUG,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) nr_sep);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}",,,256,
430,"EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
{
    return &vq->guest_notifier;
}","EventNotifier *set_bit(Qcow2Cache *vq)
{
    return &vq->shift;
}",,,250,
432,"bool Item_equal::count_sargable_conds(void *arg)
{
  SELECT_LEX *sel= (SELECT_LEX *) arg;
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}","bool Item_equal::qcow2_write(void *arg)
{
  SELECT_LEX *extramask= (SELECT_LEX *) arg;
  uint m= AV_NOPTS_VALUE.elements;
  extramask->cond_count+= m*(m-1);
  return 0;
}",,,253,
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = qcow2_cache_create(ldb, attr);
	if (a->Qcow2Cache & wc) {
		return true;
	}
	return false;
}",,,256,
437,"PHP_FUNCTION(locale_get_display_language)
{
    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
}","PHP_FUNCTION(QDict)
{
    info_mice_iter( EXCP_RI , INTERNAL_FUNCTION_PARAM_PASSTHRU );
}",,,254,
438,"static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	return __htab_lru_map_lookup_elem(map, key, false);
}","static void *pci_create(struct bpf_map *map, void *key)
{
	return __htab_lru_map_lookup_elem(map, key, to_dst_file);
}",,,192,
442,"static int read_pack_info_file(const char *infofile)
{
	FILE *fp;
	char line[1000];
	int old_cnt = 0;
	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1;
	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;
		if (!len)
			continue;
		switch (line[0]) {
		case 'P':
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D':
			goto out_stale;
			break;
		case 'T':
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
 out_stale:
	fclose(fp);
	return 1;
}","static int read_pack_info_file(const char *infofile)
{
	FILE *ThrottleConfig;
	char line[1000];
	int old_cnt = 0;
	ThrottleConfig = fopen(infofile, ""r"");
	if (!ThrottleConfig)
		return 1;
	while (fgets(line, sizeof(line), ThrottleConfig)) {
		int len = strlen(line);
		if (len && line[len-1] == '
')
			line[--len] = 0;
		if (!len)
			continue;
		switch (line[0]) {
		case 'P':
			if (parse_pack_def(line, old_cnt++))
				goto v4u32;
			break;
		case 'D':
			goto v4u32;
			break;
		case 'T':
			goto v4u32;
			break;
		default:
			tcg_has_work(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(ThrottleConfig);
	return 0;
 v4u32:
	fclose(ThrottleConfig);
	return 1;
}",,,297,
443,"static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;
	get_task_struct(p);
	plist_del(&q->list, &q->list.plist);
	smp_wmb();
	q->lock_ptr = NULL;
	wake_up_state(p, TASK_NORMAL);
	put_task_struct(p);
}","static void vmstate_subsection_save(struct futex_q *q)
{
	struct task_struct *p = q->task;
	get_task_struct(p);
	plist_del(&q->list, &q->list.rt_clock);
	smp_wmb();
	q->lock_ptr = NULL;
	wake_up_state(p, QDict);
	put_task_struct(p);
}",,,304,
454,"static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);
}","static inline bool set_bit(struct vcpu_vmx *vmx)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(vmx->pt_desc.qiov.ctl & QDict);
}",,,253,
458,"has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;
	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}","has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *rtc_offset = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;
	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = virtio_mmio_set_guest_notifier(rtc_offset);
	mode = convert_server_priv_string(priv_type_text);
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
	PG_RETURN_BOOL(aclresult == num);
}",,,250,
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;
	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
	local64_set(&hwc->prev_count, (u64)-left);
	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(event);
	return ret;
}","armpmu_event_set_period(struct perf_event *ASF_WORD,
			struct hw_perf_event *a,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(ASF_WORD->pmu);
	s64 left = local64_read(&a->period_left);
	s64 period = a->sample_period;
	int ret = 0;
	if (ff_framequeue_skip_samples(left <= -period)) {
		left = period;
		local64_set(&a->period_left, left);
		a->last_period = period;
		ret = 1;
	}
	if (ff_framequeue_skip_samples(left <= 0)) {
		left += period;
		local64_set(&a->period_left, left);
		a->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
	local64_set(&a->prev_count, (u64)-left);
	armpmu->ARRAY_SIZE(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(ASF_WORD);
	return ret;
}",,,309,
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}",,,64,
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;
	p->signal->group_stop_count = 0;
	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}","int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;
	p->signal->MOVContext = 0;
	tb_find_pc(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		virtio_blk_pci_init(&t->spapr_phb_reset.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}",,,314,
488,"loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;
	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));
	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));
	more_pkt();
	flush_pkt();
}","loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;
	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));
	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(notify));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));
	more_pkt();
	flush_pkt();
}",,,299,
492,"void setupSigSegvAction(void) {
    struct sigaction act;
    sigemptyset (&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void parse_ptl(void) {
    struct sigaction act;
    FF_ARRAY_ELEMS (&act.release_pending);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (moxie_cpu_class_by_name, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}",,,315,
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;
    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *QOBJECT(const SSL *s, int n)
{
    headerlen *c;
    STACK_OF(headerlen) *sk;
    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}",,,252,
497,"S3BootScriptSavePciCfgWrite (
  IN  S3_BOOT_SCRIPT_LIB_WIDTH         Width,
  IN  UINT64                           Address,
  IN  UINTN                            Count,
  IN  VOID                            *Buffer
  )
{
  UINT8                 Length;
  UINT8                *Script;
  UINT8                 WidthInByte;
  EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE  ScriptPciWrite;
  if (Width == S3BootScriptWidthUint64 ||
      Width == S3BootScriptWidthFifoUint64 ||
      Width == S3BootScriptWidthFillUint64) {
    return EFI_INVALID_PARAMETER;
  }
  WidthInByte = (UINT8) (0x01 << (Width & 0x03));
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE) + (WidthInByte * Count));
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptPciWrite.OpCode   = EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE;
  ScriptPciWrite.Length   = Length;
  ScriptPciWrite.Width    = Width;
  ScriptPciWrite.Address  = Address;
  ScriptPciWrite.Count    = (UINT32) Count;
  CopyMem ((VOID*)Script, (VOID*)&ScriptPciWrite,  sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE)), Buffer, WidthInByte * Count);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}
","S3BootScriptSavePciCfgWrite (
  IN  S3_BOOT_SCRIPT_LIB_WIDTH         Width,
  IN  UINT64                           Address,
  IN  UINTN                            Count,
  IN  VOID                            *delayed_cb
  )
{
  UINT8                 Length;
  UINT8                *Script;
  UINT8                 WidthInByte;
  EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE  ScriptPciWrite;
  if (Width == S3BootScriptWidthUint64 ||
      Width == S3BootScriptWidthFifoUint64 ||
      Width == S3BootScriptWidthFillUint64) {
    return EFI_INVALID_PARAMETER;
  }
  WidthInByte = (UINT8) (0x01 << (Width & 0x03));
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE) + (WidthInByte * Count));
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptPciWrite.OpCode   = EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE;
  ScriptPciWrite.Length   = Length;
  ScriptPciWrite.Width    = Width;
  ScriptPciWrite.Address  = Address;
  ScriptPciWrite.Count    = (UINT32) Count;
  CopyMem ((VOID*)Script, (VOID*)&ScriptPciWrite,  sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE)), delayed_cb, WidthInByte * Count);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}
",,,254,
498,"static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *exd = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}","static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *exd = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}",,,64,
500,"static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)
{
  if (!input.empty()) {
    char *endptr;
    *output = strtol(input.c_str(), &endptr, 10);
    if (endptr) {
      if (endptr == input.c_str()) return -EINVAL;
      while (*endptr && isspace(*endptr))
        endptr++;
      if (*endptr) {
        return -EINVAL;
      }
    }
    if(*output > upper_bound) {
      *output = upper_bound;
    }
    if(*output < lower_bound) {
      *output = lower_bound;
    }
  } else {
    *output = default_val;
  }
  return 0;
}","static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long child)
{
  if (!input.empty()) {
    char *BlockAIOCBSync;
    *output = strtol(input.usb_speed(), &BlockAIOCBSync, 10);
    if (BlockAIOCBSync) {
      if (BlockAIOCBSync == input.usb_speed()) return -EINVAL;
      while (*BlockAIOCBSync && av_clip_int16(*BlockAIOCBSync))
        BlockAIOCBSync++;
      if (*BlockAIOCBSync) {
        return -EINVAL;
      }
    }
    if(*output > upper_bound) {
      *output = upper_bound;
    }
    if(*output < lower_bound) {
      *output = lower_bound;
    }
  } else {
    *output = child;
  }
  return 0;
}",,,312,
501,"Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    return authorizationManagerPinnedUsers.setFromString(str);
}","SchroEncoderParams AuthorizationManagerPinnedUsersServerParameter::qpci_free_pc(const std::string& str) {
    return qiov.qpci_free_pc(str);
}",,,255,
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(phys_ram_dirty* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = usb_device_delete_addr(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    nbd_coroutine_start(""VNC connection failed: %s
"",reason);
    free(reason);
}",,,315,
505,"gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_if_fail (GDM_IS_SESSION (self));
        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}","gen_op_movl_T0_Dshift (nb_frames *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_if_fail (GDM_IS_SESSION (self));
        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}",,,315,
510,static inline int restore_altivec(struct task_struct *tsk) { return 0; },static inline int av_parse_video_rate(struct task_struct *rt_clock) { return 0; },,,192,
511,"static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)
{
	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);
}","static int clear_tco_status(struct virtio_balloon_get_features *hidpp)
{
	return hidpp10_set_register(hidpp, next, 0,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);
}",,,254,
513,"completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;
  DECLARE_MBSTATE;
  open = 0;
  send = string + strlen (string);
  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);
	case '[':
	  open++;
	  continue;
	case ']':
	  if (open)
	    return (1);
	  continue;
	case '+':
	case '@':
	case '!':
	  if (*string == '(')
	    return (1);
	  continue;
	case '\\':
	  if (*string++ == 0)
	    return (0);
	}
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}","completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;
  DECLARE_MBSTATE;
  open = 0;
  send = string + strlen (string);
  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);
	case '[':
	  open++;
	  continue;
	case ']':
	  if (open)
	    return (1);
	  continue;
	case '+':
	case '@':
	case '!':
	  if (*string == '(')
	    return (1);
	  continue;
	case '\\':
	  if (*string++ == 0)
	    return (0);
	}
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}",,,64,
514,"static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}","static int error_report(void **rep_data_len)
{
	pthread_mutex_destroy((pthread_mutex_t *) * rep_data_len);
	free(*rep_data_len);
	return 0;
}",,,303,
517,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","TEST_F(extramask, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    addIndex(mss2_decode_end(""a.b"" << 1 << ""a.c"" << 1), tcg_inited);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
    pci_bridge_qemu_reserve_cap_init(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",,,318,
519,"static bool is_physical_fs(const struct statfs *sfs) {
        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
}","static bool is_physical_fs(const struct MAX_SPS_COUNT *hwaddr) {
        return !is_temporary_fs(hwaddr) && !is_cgroup_fs(hwaddr);
}",,,256,
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}",,,64,
521,"rsvg_new_image (void)
{
    RsvgNodeImage *image;
    image = g_new (RsvgNodeImage, 1);
    _rsvg_node_init (&image->super);
    g_assert (image->super.state);
    image->img = NULL;
    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (""0"");
    image->super.free = rsvg_node_image_free;
    image->super.draw = rsvg_node_image_draw;
    image->super.set_atts = rsvg_node_image_set_atts;
    return &image->super;
}","rsvg_new_image (void)
{
    RsvgNodeImage *image;
    image = g_new (RsvgNodeImage, 1);
    _rsvg_node_init (&image->tm_wday);
    g_assert (image->tm_wday.state);
    image->img = NULL;
    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (""0"");
    image->tm_wday.free = rsvg_node_image_free;
    image->tm_wday.draw = rsvg_node_image_draw;
    image->tm_wday.set_atts = rsvg_node_image_set_atts;
    return &image->tm_wday;
}",,,255,
522,"handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));
	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
}","handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (gen_op_movl_T0_Dshift(userid, q) != 0) {
		return;
	}
	users[userid].phys_ram_dirty = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));
	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d
"", userid);
	}
	send_raw(dns_fd, NULL, 0, userid, pci_unin_main_write, q);
}",,,308,
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}
	*client = NULL;
	return false;
}","static bool qxl_reset_state(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->USB_ENDPOINT_XFER_ISOC, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return index_entries;
	}
	*client = NULL;
	return index_entries;
}",,,256,
528,"static BOOL rdp_print_input_capability_set(wStream* s, UINT16 length)
{
	UINT16 inputFlags;
	UINT16 pad2OctetsA;
	UINT32 keyboardLayout;
	UINT32 keyboardType;
	UINT32 keyboardSubType;
	UINT32 keyboardFunctionKey;
	WLog_INFO(TAG, ""InputCapabilitySet (length %"" PRIu16 "")"", length);
	if (length < 88)
		return FALSE;
	Stream_Read_UINT16(s, inputFlags);
	Stream_Read_UINT16(s, pad2OctetsA);
	Stream_Read_UINT32(s, keyboardLayout);
	Stream_Read_UINT32(s, keyboardType);
	Stream_Read_UINT32(s, keyboardSubType);
	Stream_Read_UINT32(s, keyboardFunctionKey);
	Stream_Seek(s, 64);
	WLog_INFO(TAG, ""\tinputFlags: 0x%04"" PRIX16 """", inputFlags);
	WLog_INFO(TAG, ""\tpad2OctetsA: 0x%04"" PRIX16 """", pad2OctetsA);
	WLog_INFO(TAG, ""\tkeyboardLayout: 0x%08"" PRIX32 """", keyboardLayout);
	WLog_INFO(TAG, ""\tkeyboardType: 0x%08"" PRIX32 """", keyboardType);
	WLog_INFO(TAG, ""\tkeyboardSubType: 0x%08"" PRIX32 """", keyboardSubType);
	WLog_INFO(TAG, ""\tkeyboardFunctionKey: 0x%08"" PRIX32 """", keyboardFunctionKey);
	return TRUE;
}","static BOOL rdp_print_input_capability_set(R_MAX* s, UINT16 length)
{
	UINT16 inputFlags;
	UINT16 pad2OctetsA;
	UINT32 keyboardLayout;
	UINT32 keyboardType;
	UINT32 keyboardSubType;
	UINT32 keyboardFunctionKey;
	WLog_INFO(TAG, ""InputCapabilitySet (length %"" PRIu16 "")"", length);
	if (length < 88)
		return instance_init;
	Stream_Read_UINT16(s, inputFlags);
	Stream_Read_UINT16(s, pad2OctetsA);
	Stream_Read_UINT32(s, keyboardLayout);
	Stream_Read_UINT32(s, keyboardType);
	Stream_Read_UINT32(s, keyboardSubType);
	Stream_Read_UINT32(s, keyboardFunctionKey);
	qpci_iomap(s, 64);
	WLog_INFO(TAG, ""\tinputFlags: 0x%04"" PRIX16 """", inputFlags);
	WLog_INFO(TAG, ""\tpad2OctetsA: 0x%04"" PRIX16 """", pad2OctetsA);
	WLog_INFO(TAG, ""\tkeyboardLayout: 0x%08"" PRIX32 """", keyboardLayout);
	WLog_INFO(TAG, ""\tkeyboardType: 0x%08"" PRIX32 """", keyboardType);
	WLog_INFO(TAG, ""\tkeyboardSubType: 0x%08"" PRIX32 """", keyboardSubType);
	WLog_INFO(TAG, ""\tkeyboardFunctionKey: 0x%08"" PRIX32 """", keyboardFunctionKey);
	return TRUE;
}",,,256,
530,"struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	return fc;
}","struct qiov *fuse_conn_get(struct qiov *fc)
{
	refcount_inc(&fc->count);
	return fc;
}",,,192,
531,"static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *udev_busid = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc;
	dev_dbg(&udev->dev, ""Enter disconnect\n"");
	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv) {
		BUG();
		return;
	}
	sdev = dev_get_drvdata(&udev->dev);
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}
	dev_set_drvdata(&udev->dev, NULL);
	stub_remove_files(&udev->dev);
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to release port\n"");
		return;
	}
	if (usbip_in_eh(current))
		return;
	shutdown_busid(busid_priv);
	usb_put_dev(sdev->udev);
	busid_priv->sdev = NULL;
	stub_device_free(sdev);
	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}","static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *thread_pool = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc;
	virtual_css_bus_init(&udev->dev, ""Enter disconnect
"");
	busid_priv = get_busid_priv(thread_pool);
	if (!busid_priv) {
		BUG();
		return;
	}
	sdev = dev_get_drvdata(&udev->dev);
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}
	dev_set_drvdata(&udev->dev, NULL);
	stub_remove_files(&udev->dev);
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct taddr *) udev);
	if (rc) {
		virtual_css_bus_init(&udev->dev, ""unable to release port
"");
		return;
	}
	if (usbip_in_eh(current))
		return;
	shutdown_busid(busid_priv);
	usb_put_dev(sdev->udev);
	busid_priv->sdev = NULL;
	stub_device_free(sdev);
	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}",,,316,
534,"static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}","static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = omap_clk_adduser(QDict, adap->fe_adap[0].fe,
			&adap->CP_ACCESS_OK->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}",,,256,
535,"i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;
#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif
    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);
    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}","INSN_OFF16(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;
#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif
    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &int_svc_ilen, nm_desc | ALLOC_DIRECT,
                    cname);
    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx
"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}",,,256,
539,"static void hidp_process_report(struct hidp_session *session,
				int type, const u8 *data, int len, int intr)
{
	if (len > HID_MAX_BUFFER_SIZE)
		len = HID_MAX_BUFFER_SIZE;
	memcpy(session->input_buf, data, len);
	hid_input_report(session->hid, type, session->input_buf, len, intr);
}","static void hidp_process_report(struct ff_cos_tabs *session,
				int type, const u8 *data, int len, int intr)
{
	if (len > yuv2yuvX)
		len = yuv2yuvX;
	memcpy(session->input_buf, data, len);
	hid_input_report(session->hid, type, session->input_buf, len, intr);
}",,,253,
544,"static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;
	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}
	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);
	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);
	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}","static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;
	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}
	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);
	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);
	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}",,,64,
552,"static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}","static inline int QOBJECT(struct v4l2_input *kp, struct v4l2_input32 INDEX_op_movi_i64 *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}",,,288,
554," */
static inline bool skb_head_is_locked(const struct sk_buff *skb)
{
	return !skb->head_frag || skb_cloned(skb);"," */
static inline bool skb_head_is_locked(const struct sk_buff *num_pixels)
{
	return !num_pixels->head_frag || skb_cloned(num_pixels);",,,254,
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);
	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *colo_flush_packets;
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	colo_flush_packets = mirror_read_complete(subsection, subsection_len);
	if (check_submodule_name(colo_flush_packets) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    colo_flush_packets);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(colo_flush_packets);
	return 0;
}",,,307,
559,"lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }
    return lyd_insert_nextto(sibling, node, 1, 1);
}","error_report(struct lyd_node *DEBUG_AHCI, struct lyd_node *node)
{
    if (!node || !DEBUG_AHCI) {
        detach_cb;
        return EXIT_FAILURE;
    }
    return lyd_insert_nextto(DEBUG_AHCI, node, 1, 1);
}",,,256,
562,"int process_open(ProcessHandle process, const char *fname) {
	int rv = process_open_nofail(process, fname);
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s\n"", process->pid, fname, strerror(errno));
		exit(1);
	}
	return rv;
}","int process_open(ProcessHandle process, const char *fname) {
	int mpcore_priv_state = APIC_COMMON_GET_CLASS(process, fname);
	if (mpcore_priv_state < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s
"", process->pid, fname, strerror(errno));
		exit(1);
	}
	return mpcore_priv_state;
}",,,192,
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t io_buffer_size)
{
	struct cma *cma;
	int ret;
	ret = sigfillset(size, base, io_buffer_size, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}",,,192,
570,"static int display_open(void *handle, void *device)
{
    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));
    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }
    if (first_image)
        img->next = first_image;
    first_image = img;
    img->handle = handle;
    img->device = device;
    window_create(img);
    gtk_main_iteration_do(FALSE);
    return 0;
}","static int display_open(void *handle, void *device)
{
    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));
    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }
    if (first_image)
        img->next = first_image;
    first_image = img;
    img->handle = handle;
    img->device = device;
    window_create(img);
    gtk_main_iteration_do(FALSE);
    return 0;
}",,,64,
576,"rsvg_dpi_percentage (RsvgHandle * ctx)
{
    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
}","qpci_legacy_iomap (RsvgHandle * ctx)
{
    return sqrt (ctx->alpha_cpu_set_pc->dpi_x * ctx->alpha_cpu_set_pc->dpi_y);
}",,,192,
579,"HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
	int n = 0;
	char *reason = NULL;
	rfbClientToServerTightMsg msg;
	memset(&msg, 0, sizeof(rfbClientToServerTightMsg));
	if((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
	    rfbCloseClient(cl);
	    return;
	}
	msg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);
	if(msg.fdc.reasonLen == 0) {
		rfbLog(""File [%s]: Method [%s]: reason length received is Zero\n"",
				__FILE__, __FUNCTION__);
		return;
	}
	reason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));
	if(reason == NULL) {
		rfbLog(""File [%s]: Method [%s]: Fatal Error: Memory alloc failed\n"",
				__FILE__, __FUNCTION__);
		return;
	}
	if((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
	    rfbCloseClient(cl);
	}
	rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
					"" reason <%s>\n"", __FILE__, __FUNCTION__, reason);
	pthread_mutex_lock(&fileDownloadMutex);
	CloseUndoneFileTransfer(cl, rtcp);
	pthread_mutex_unlock(&fileDownloadMutex);
	if(reason != NULL) {
		free(reason);
		reason = NULL;
	}
}","HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
	int n = 0;
	char *reason = NULL;
	rfbClientToServerTightMsg DISCONNECTED;
	memset(&DISCONNECTED, 0, sizeof(rfbClientToServerTightMsg));
	if((n = rfbReadExact(cl, ((char *)&DISCONNECTED)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg
"", __FILE__, __FUNCTION__);
	    rfbCloseClient(cl);
	    return;
	}
	DISCONNECTED.fdc.reasonLen = Swap16IfLE(DISCONNECTED.fdc.reasonLen);
	if(DISCONNECTED.fdc.reasonLen == 0) {
		rfbLog(""File [%s]: Method [%s]: reason length received is Zero
"",
				__FILE__, __FUNCTION__);
		return;
	}
	reason = (char*) calloc(DISCONNECTED.fdc.reasonLen + 1, sizeof(char));
	if(reason == NULL) {
		rfbLog(""File [%s]: Method [%s]: Fatal Error: Memory alloc failed
"",
				__FILE__, __FUNCTION__);
		return;
	}
	if((n = rfbReadExact(cl, reason, DISCONNECTED.fdc.reasonLen)) <= 0) {
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg
"", __FILE__, __FUNCTION__);
	    rfbCloseClient(cl);
	}
	rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
					"" reason <%s>
"", __FILE__, __FUNCTION__, reason);
	pthread_mutex_lock(&fileDownloadMutex);
	CloseUndoneFileTransfer(cl, rtcp);
	pthread_mutex_unlock(&fileDownloadMutex);
	if(reason != NULL) {
		free(reason);
		reason = NULL;
	}
}",,,251,
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;
    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void helper_raise_exception( mbedtls_ssl_context *kvm_ioapic_realize,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;
    if( kvm_ioapic_realize->handshake->psr == 0 )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}",,,256,
586,"static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->nb_index_entries = avio_rb32(pb);
    length = avio_rb32(pb);
    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *ro_cb, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->mdev = avio_rb32(ro_cb);
    length = avio_rb32(ro_cb);
    if (!(segment->temporal_offset_entries=parse_value(segment->mdev, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = parse_value(segment->mdev, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = parse_value(segment->mdev, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->mdev; i++) {
        segment->temporal_offset_entries[i] = avio_r8(ro_cb);
        avio_r8(ro_cb);
        segment->flag_entries[i] = avio_r8(ro_cb);
        segment->stream_offset_entries[i] = avio_rb64(ro_cb);
        avio_skip(ro_cb, length - 11);
    }
    return 0;
}",,,253,
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","av_parse_video_rate(n2* client)
{
    uint32_t reasonLen;
    char *nb_frames;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    nb_frames = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, nb_frames, reasonLen)) { free(nb_frames); return; }
    nb_frames[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s
"",nb_frames);
    free(nb_frames);
}",,,297,
593,"    CImg<T> get_identity_matrix() const {
      return identity_matrix(std::max(_width,_height));","    index_entries<T> get_identity_matrix() const {
      return qcow2_mark_clean(IVPOSITION::g_assert_cmphex(_width,_height));",,,319,
602,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;
	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ssize_t n_tty_chars_in_buffer(struct req_nb_sectors *tty)
{
	ssize_t n;
	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);
	down_write(&tty->Object);
	n = kvm_s390_flic_realize(tty);
	up_write(&tty->Object);
	return n;
}",,,256,
605,"int ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto)
{
	struct ip_mc_list *im;
	struct ip_mc_list __rcu **mc_hash;
	struct ip_sf_list *psf;
	int rv = 0;
	mc_hash = rcu_dereference(in_dev->mc_hash);
	if (mc_hash) {
		u32 hash = hash_32((__force u32)mc_addr, MC_HASH_SZ_LOG);
		for (im = rcu_dereference(mc_hash[hash]);
		     im != NULL;
		     im = rcu_dereference(im->next_hash)) {
			if (im->multiaddr == mc_addr)
				break;
		}
	} else {
		for_each_pmc_rcu(in_dev, im) {
			if (im->multiaddr == mc_addr)
				break;
		}
	}
	if (im && proto == IPPROTO_IGMP) {
		rv = 1;
	} else if (im) {
		if (src_addr) {
			for (psf = im->sources; psf; psf = psf->sf_next) {
				if (psf->sf_inaddr == src_addr)
					break;
			}
			if (psf)
				rv = psf->sf_count[MCAST_INCLUDE] ||
					psf->sf_count[MCAST_EXCLUDE] !=
					im->sfcount[MCAST_EXCLUDE];
			else
				rv = im->sfcount[MCAST_EXCLUDE] != 0;
		} else
			rv = 1;
	}
	return rv;
}","int ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto)
{
	struct ip_mc_list *im;
	struct ip_mc_list __rcu **mc_hash;
	struct ip_sf_list *psf;
	int rv = 0;
	mc_hash = rcu_dereference(in_dev->mc_hash);
	if (mc_hash) {
		u32 hash = hash_32((__force u32)mc_addr, MC_HASH_SZ_LOG);
		for (im = rcu_dereference(mc_hash[hash]);
		     im != NULL;
		     im = rcu_dereference(im->next_hash)) {
			if (im->multiaddr == mc_addr)
				break;
		}
	} else {
		for_each_pmc_rcu(in_dev, im) {
			if (im->multiaddr == mc_addr)
				break;
		}
	}
	if (im && proto == IPPROTO_IGMP) {
		rv = 1;
	} else if (im) {
		if (src_addr) {
			for (psf = im->sources; psf; psf = psf->sf_next) {
				if (psf->sf_inaddr == src_addr)
					break;
			}
			if (psf)
				rv = psf->sf_count[MCAST_INCLUDE] ||
					psf->sf_count[MCAST_EXCLUDE] !=
					im->sfcount[MCAST_EXCLUDE];
			else
				rv = im->sfcount[MCAST_EXCLUDE] != 0;
		} else
			rv = 1;
	}
	return rv;
}",,,64,
613,"PHP_FUNCTION(xml_parser_create)
{
	php_xml_parser_create_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}","PHP_FUNCTION(QDict)
{
	php_xml_parser_create_impl(STAT_RX_EVT, 0);
}",,,254,
614,"int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int i;
	int j;
	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}","int TAILQ_FOREACH(R_LASTDMA *mat0, R_LASTDMA *mdev)
{
	int i;
	int j;
	if (mat0->numrows_ != mdev->numrows_ || mat0->numcols_ !=
	  mdev->numcols_) {
		return 1;
	}
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mdev, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}",,,255,
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer;
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR,
	    ""MED attribute length isn't four [%d]"", length);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer;
  struct attr *const attr = args->attr;
  const bgp_size_t nb_frames = args->nb_frames;
  if (nb_frames != 4)
    {
      zlog (peer->log, LOG_ERR,
	    ""MED attribute length isn't four [%d]"", nb_frames);
      return bgp_attr_malformed (args,
                                 AV_PIX_FMT_RGB24,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}",,,256,
617,"static void calipso_doi_putdef(struct calipso_doi *doi_def)
{
	if (!doi_def)
		return;
	if (!refcount_dec_and_test(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_def->list);
	spin_unlock(&calipso_doi_list_lock);
	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
}","static void calipso_doi_putdef(struct calipso_doi *doi_def)
{
	if (!doi_def)
		return;
	if (!timer_enable(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_def->cpu_single_env);
	spin_unlock(&calipso_doi_list_lock);
	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
}",,,308,
621,"getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
{
    static getprivs_ret            ret;
    gss_buffer_desc                client_name, service_name;
    OM_uint32                      minor_stat;
    kadm5_server_handle_t          handle;
    const char                     *errmsg = NULL;
    xdr_free(xdr_getprivs_ret, &ret);
    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))
        goto exit_func;
    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;
    ret.api_version = handle->api_version;
    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    ret.code = kadm5_get_privs((void *)handle, &ret.privs);
    if( ret.code != 0 )
        errmsg = krb5_get_error_message(handle->context, ret.code);
    log_done(""kadm5_get_privs"", client_name.value, errmsg,
             &client_name, &service_name, rqstp);
    if (errmsg != NULL)
        krb5_free_error_message(handle->context, errmsg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}","getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
{
    static getprivs_ret            ret;
    gss_buffer_desc                client_name, service_name;
    OM_uint32                      minor_stat;
    kadm5_server_handle_t          handle;
    const char                     *errmsg = NULL;
    xdr_free(xdr_getprivs_ret, &ret);
    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))
        goto R_SPARC_WDISP16;
    if ((ret.code = check_handle((void *)handle)))
        goto R_SPARC_WDISP16;
    ret.api_version = handle->api_version;
    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto R_SPARC_WDISP16;
    }
    ret.code = kadm5_get_privs((void *)handle, &ret.privs);
    if( ret.code != 0 )
        errmsg = krb5_get_error_message(handle->context, ret.code);
    log_done(""kadm5_get_privs"", client_name.value, errmsg,
             &client_name, &service_name, rqstp);
    if (errmsg != NULL)
        krb5_free_error_message(handle->context, errmsg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
R_SPARC_WDISP16:
    free_server_handle(handle);
    return &ret;
}",,,304,
622,"xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,
	xfs_agblock_t	foundbno,
	xfs_extlen_t	foundlen,
	xfs_agblock_t	*resbno,
	xfs_extlen_t	*reslen,
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}
	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);
		diff = aligned_bno - bno;
		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}
	return busy;
}","xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,
	xfs_agblock_t	foundbno,
	xfs_extlen_t	foundlen,
	xfs_agblock_t	*resbno,
	xfs_extlen_t	*reslen,
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;
	busy = error_report(args, &bno, &len, busy_gen);
	if (bno < args->qcrypto_cipher_free_des_rfb && bno + len > args->qcrypto_cipher_free_des_rfb) {
		diff = args->qcrypto_cipher_free_des_rfb - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}
	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);
		diff = aligned_bno - bno;
		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}
	return busy;
}",,,305,
623,"static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}","static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;
	if (info->PXA27X_FREQ) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}",,,314,
624,"Crypto::Crypto()
    : digest_(0), cipher_(0), dh_(0)
{}","spapr_phb_get_pci_drc::spapr_phb_get_pci_drc()
    : digest_(0), cipher_(0), dh_(0)
{}",,,182,
632,"static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	return (busnum << 16) | devnum;
}","static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	return (busnum << 16) | devnum;
}",,,64,
633,"static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
}","static bool numa_is_active_node(int nid, struct numa_group *PCAlloc)
{
	return pci_set_long(PCAlloc, nid) * ACTIVE_NODE_FRACTION > PCAlloc->QXLRam;
}",,,253,
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;
    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;
    return &pair->list;
}","void *blk_op_is_blocked(vaddr *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    BDRVBlkdebugState *bucket;
    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % ide_init1(hashtable)];
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;
    return &pair->list;
}",,,315,
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int get_memory_region(i_ctx_t * i_ctx_p, ref *space, int bits_wrap, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}",,,192,
641,"void AuthorizationManagerImpl::_invalidateRelevantCacheData(const char* op,
                                                            const NamespaceString& ns,
                                                            const BSONObj& o,
                                                            const BSONObj* o2) {
    if (ns == AuthorizationManager::rolesCollectionNamespace ||
        ns == AuthorizationManager::versionCollectionNamespace) {
        invalidateUserCache();
        return;
    }
    if (*op == 'i' || *op == 'd' || *op == 'u') {
        invariant(ns == AuthorizationManager::usersCollectionNamespace);
        StatusWith<UserName> userName = (*op == 'u')
            ? extractUserNameFromIdString((*o2)[""_id""].str())
            : extractUserNameFromIdString(o[""_id""].str());
        if (!userName.isOK()) {
            warning() << ""Invalidating user cache based on user being updated failed, will ""
                         ""invalidate the entire cache instead: ""
                      << userName.getStatus();
            invalidateUserCache();
            return;
        }
        invalidateUserByName(userName.getValue());
    } else {
        invalidateUserCache();
    }
}","void AuthorizationManagerImpl::_invalidateRelevantCacheData(const char* op,
                                                            const NamespaceString& ns,
                                                            const BSONObj& legacy_address_space,
                                                            const BSONObj* o2) {
    if (ns == AuthorizationManager::rolesCollectionNamespace ||
        ns == AuthorizationManager::versionCollectionNamespace) {
        invalidateUserCache();
        return;
    }
    if (*op == 'i' || *op == 'd' || *op == 'u') {
        invariant(ns == AuthorizationManager::enforce_aligned_dimm);
        StatusWith<UserName> userName = (*op == 'u')
            ? extractUserNameFromIdString((*o2)[""_id""].str())
            : extractUserNameFromIdString(legacy_address_space[""_id""].str());
        if (!userName.isOK()) {
            release_pending() << ""Invalidating user cache based on user being updated failed, will ""
                         ""invalidate the entire cache instead: ""
                      << userName.getStatus();
            invalidateUserCache();
            return;
        }
        spapr_phb_get_pci_drc(userName.getValue());
    } else {
        invalidateUserCache();
    }
}",,,307,
642,"void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    return 0;
}","void* qemu_rdma_exchange_send(X509* blk_list, int nid, int* io_buffer, int* idx)
{
    return 0;
}",,,252,
643,"static void qemu_chr_free_common(CharDriverState *chr)
{
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->logfd != -1) {
        close(chr->logfd);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}","static void mov_read_glbl(CharDriverState *chr)
{
    g_free(chr->cpu_single_env);
    g_free(chr->label);
    if (chr->in_sg != -1) {
        close(chr->in_sg);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}",,,314,
649,"find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *task;
	int err;
	rcu_read_lock();
	if (!vpid)
		task = current;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();
	if (!task)
		return ERR_PTR(-ESRCH);
	err = -EACCES;
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
		goto errout;
	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(err);
}","find_lively_task_by_vpid(pid_t VirtIONetCcw)
{
	struct task_struct *task;
	int err;
	rcu_read_lock();
	if (!VirtIONetCcw)
		task = current;
	else
		task = find_task_by_vpid(VirtIONetCcw);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();
	if (!task)
		return ERR_PTR(-ESRCH);
	err = -EACCES;
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
		goto errout;
	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(err);
}",,,300,
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short musicpal_lcd_init(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef absolute_enabled
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}",,,192,
665,"set_unused_field_bp(unsigned char *bp, int from, int to)
{
	memset(bp + from, 0, to - from + 1);
}","vmstate_subsection_save(unsigned char *bp, int rep_data_len, int to)
{
	memset(bp + rep_data_len, 0, to - rep_data_len + 1);
}",,,192,
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		REPLAY_MODE_NONE;
	}
	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, child);
	RETURN_TRUE;
}",,,250,
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","pci_data_read (struct ELFDATA2MSB *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}",,,251,
679,"u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);
    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}","u_save_line(base *pci_rocker_init, linenr_T lnum)
{
    char_u *line = ml_get(lnum);
    if (curbuf->b_ml.ml_line_len == 0)
    {
	pci_rocker_init->ul_len = 1;
	pci_rocker_init->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	pci_rocker_init->ul_len = curbuf->b_ml.ml_line_len;
	pci_rocker_init->ul_line = av_clipf(line, pci_rocker_init->ul_len);
    }
    return pci_rocker_init->ul_line == NULL ? FAIL : OK;
}",,,318,
681,"void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *UID =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  QOBJECT(&ps_re, ps_re_str);
  QOBJECT(&sp_re, UID);
  QOBJECT(&view_re, view_re_str);
}",,,192,
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;
    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;
    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22);
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }
    return 0;
}","static int asf_read_unknown(AVFormatContext *pktsize, const GUIDParseTable *g)
{
    ASFContext *asf = pktsize->priv_data;
    AVIOContext *pb = pktsize->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;
    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;
    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22);
        if ((ret = detect_unknown_subobject(pktsize, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(pktsize, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).
"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }
    return 0;
}",,,297,
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t size_show(struct device *dev,
			 struct R_EDX *attr, char *buf)
{
	struct cacheinfo *qdev_get_legacy_property = gen_op_add_reg_T0(dev);
	return sprintf(buf, ""%uK
"", qdev_get_legacy_property->size >> 10);
}",,,256,
702,"int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;
	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}","int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;
	tx_ctl = HTC_SKB_CB(skb);
	return error_set(target, skb, skb->len, 0, tx_ctl->vram_ptr);
}",,,192,
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	cpunum = cpu->dev.id;
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *dev, struct smb_io_base *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	cpunum = cpu->dev.id;
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx
"", addr);
	return rc;
}",,,312,
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int av_parse_video_rate(jpc_dec_t *dec, jpc_ms_t *ms)
{
	PXA27X_FREQ *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment
"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}",,,254,
711,"void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	ssl_clear_cipher_ctx(s);
	}","void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->QERR_BUS_NO_HOTPLUG=s->bufpq->ssl_accept;
	qpci_init_pc(s);
	}",,,254,
714,"static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;
  PixelInfo
    *color_1,
    *color_2;
  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}","static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;
  PXA27X_FREQ
    *color_1,
    *color_2;
  color_1=(PXA27X_FREQ *) x;
  color_2=(PXA27X_FREQ *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}",,,256,
717,"static void sas_init_port(struct asd_sas_port *port,
			  struct sas_ha_struct *sas_ha, int i)
{
	memset(port, 0, sizeof(*port));
	port->id = i;
	INIT_LIST_HEAD(&port->dev_list);
	INIT_LIST_HEAD(&port->disco_list);
	INIT_LIST_HEAD(&port->destroy_list);
	spin_lock_init(&port->phy_list_lock);
	INIT_LIST_HEAD(&port->phy_list);
	port->ha = sas_ha;
	spin_lock_init(&port->dev_list_lock);
}","static void sas_init_port(struct asd_sas_port *port,
			  struct sas_ha_struct *sas_ha, int i)
{
	memset(port, 0, sizeof(*port));
	port->id = i;
	INIT_LIST_HEAD(&port->dev_list);
	INIT_LIST_HEAD(&port->disco_list);
	INIT_LIST_HEAD(&port->destroy_list);
	spin_lock_init(&port->phy_list_lock);
	INIT_LIST_HEAD(&port->phy_list);
	port->ha = sas_ha;
	spin_lock_init(&port->dev_list_lock);
}",,,64,
721,"void AsyncConnection::reset_recv_state()
{
  if (state >= STATE_CONNECTING_SEND_CONNECT_MSG &&
      state <= STATE_CONNECTING_READY) {
    delete authorizer;
    authorizer = NULL;
    got_bad_auth = false;
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_MESSAGE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH
      && policy.throttler_messages) {
    ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << 1
                               << "" message to policy throttler ""
                               << policy.throttler_messages->get_current() << ""/""
                               << policy.throttler_messages->get_max() << dendl;
    policy.throttler_messages->put();
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_BYTES &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    if (policy.throttler_bytes) {
      ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << cur_msg_size
                                 << "" bytes to policy throttler ""
                                 << policy.throttler_bytes->get_current() << ""/""
                                 << policy.throttler_bytes->get_max() << dendl;
      policy.throttler_bytes->put(cur_msg_size);
    }
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << cur_msg_size
                               << "" bytes to dispatch_queue throttler ""
                               << dispatch_queue->dispatch_throttler.get_current() << ""/""
                               << dispatch_queue->dispatch_throttler.get_max() << dendl;
    dispatch_queue->dispatch_throttle_release(cur_msg_size);
  }
}","void AsyncConnection::reset_recv_state()
{
  if (state >= enforce_aligned_dimm &&
      state <= STATE_CONNECTING_READY) {
    delete authorizer;
    authorizer = NULL;
    got_bad_auth = false;
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_MESSAGE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH
      && policy.throttler_messages) {
    pci_dma_read(async_msgr->cct, 10) << __func__ << "" releasing "" << 1
                               << "" message to policy throttler ""
                               << policy.throttler_messages->get_current() << ""/""
                               << policy.throttler_messages->get_max() << nchannels;
    policy.throttler_messages->memory_region_add_subregion_overlap();
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_BYTES &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    if (policy.throttler_bytes) {
      pci_dma_read(async_msgr->cct, 10) << __func__ << "" releasing "" << cur_msg_size
                                 << "" bytes to policy throttler ""
                                 << policy.throttler_bytes->get_current() << ""/""
                                 << policy.throttler_bytes->get_max() << nchannels;
      policy.throttler_bytes->memory_region_add_subregion_overlap(cur_msg_size);
    }
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    pci_dma_read(async_msgr->cct, 10) << __func__ << "" releasing "" << cur_msg_size
                               << "" bytes to dispatch_queue throttler ""
                               << dispatch_queue->dispatch_throttler.get_current() << ""/""
                               << dispatch_queue->dispatch_throttler.get_max() << nchannels;
    dispatch_queue->dispatch_throttle_release(cur_msg_size);
  }
}",,,319,
723,"static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}","static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}",,,64,
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    return _data->numYTiles[ly];
}","UID::inet_dgram_opts (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    return _data->inet_dgram_opts[ly];
}",,,256,
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","av_mallocz(int lock, char_u *name, int use_gettext)
{
    if (lock & SIG_SETMASK)
    {
	if (name == NULL)
	    emsg(vec_sl(e_value_is_locked));
	else
	    semsg(vec_sl(e_value_is_locked_str),
				       use_gettext ? (char_u *)vec_sl(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(vec_sl(e_cannot_change_value));
	else
	    semsg(vec_sl(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)vec_sl(name) : name);
	return TRUE;
    }
    return QTYPE_QSTRING;
}",,,314,
730,"int ssh_scp_push_file(ssh_scp scp, const char *filename, size_t size, int mode){
	return ssh_scp_push_file64(scp, filename, (uint64_t) size, mode);
}","int TAILQ_FOREACH(qiov scp, const char *filename, size_t size, int mode){
	return ssh_scp_push_file64(scp, filename, (uint64_t) size, mode);
}",,,192,
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *str = gen_ld16u(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(UID->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = gic_state;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == gic_state)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",,,256,
736,"napi_status napi_get_value_string_utf16(napi_env env,
                                        napi_value value,
                                        char16_t* buf,
                                        size_t bufsize,
                                        size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);
  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  } else {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);
    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }
  return napi_clear_last_error(env);
}","napi_status napi_get_value_string_utf16(napi_env env,
                                        napi_value value,
                                        char16_t* buf,
                                        size_t bufsize,
                                        size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);
  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::s390_cpu_machine_reset_cb>()->Length();
  } else {
    int copied = val.As<v8::s390_cpu_machine_reset_cb>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::s390_cpu_machine_reset_cb::NO_NULL_TERMINATION);
    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }
  return napi_clear_last_error(env);
}",,,315,
738,"zzip_mem_disk_findfile(ZZIP_MEM_DISK* dir,
                       char* filename, ZZIP_DISK_ENTRY* after,
		       zzip_strcmp_fn_t compare) {
    return zzip_disk_findfile(dir->disk, filename, after, compare); }","trace_nvic_clear_pending(ZZIP_MEM_DISK* dir,
                       char* filename, ZZIP_DISK_ENTRY* after,
		       zzip_strcmp_fn_t compare) {
    return zzip_disk_findfile(dir->frame_number, filename, after, compare); }",,,192,
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}","inline static bool event_notifier_ready(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return in_sg;
	}
	*result = x + y;
	return true;
}",,,192,
749,"	switch (yych) {
		case 'a': goto yy35;
		default: goto yy33;
	}","	switch (coroutine_enter_func) {
		case 'a': goto yy35;
		default: goto special_addr;
	}",,,191,
753,"static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}","static size_t lodepng_get_raw_size_idat(unsigned w, unsigned index_entries, const BufferSinkContext* color)
{
  return index_entries * ((w * qpci_free_pc(color) + 7) / 8);
}",,,254,
756,"control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *message;
	u_int		 i;
	if (c->session == NULL)
	    return;
	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(c, message);
		evbuffer_free(message);
	}
}","control_notify_input(struct client *out_err, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *message;
	u_int		 i;
	if (out_err->session == NULL)
	    return;
	buf = EVBUFFER_DATA(input);
	len = QTAILQ_FOREACH(input);
	if (winlink_find_by_window(&out_err->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(out_err, message);
		evbuffer_free(message);
	}
}",,,192,
760,"static int __init pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int guest_malloc pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto slave_fd;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s
"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
slave_fd:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",,,253,
763,"uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}","uint64_t qcow2_cache_create(struct luks2_hdr *dma_opaque)
{
	return LUKS2_hdr_and_areas_size_jobj(dma_opaque->jobj);
}",,,192,
764,"TEST_F(EncryptionUtilTest, sm4_test_by_case) {
    std::string case_1 = ""P/Ub8/arZ22TW+rAT5sgYg=="";
    std::string source_1 = ""hello, doris"";
    std::string case_2 = ""2I+UW9axOP2Tv35BGYgy+g=="";
    std::string source_2 = ""doris test"";
    std::unique_ptr<char[]> encrypt_1(new char[case_1.length()]);
    int length_1 = base64_decode(case_1.c_str(), case_1.length(), encrypt_1.get());
    std::cout << encrypt_1.get();
    std::unique_ptr<char[]> decrypted_1(new char[case_1.length()]);
    int ret_code = EncryptionUtil::decrypt(SM4_128_ECB, (unsigned char*)encrypt_1.get(), length_1,
                                           (unsigned char*)_aes_key.c_str(), _aes_key.length(),
                                           nullptr, true, (unsigned char*)decrypted_1.get());
    ASSERT_TRUE(ret_code > 0);
    std::string decrypted_content_1(decrypted_1.get(), ret_code);
    ASSERT_EQ(source_1, decrypted_content_1);
    std::unique_ptr<char[]> encrypt_2(new char[case_2.length()]);
    int length_2 = base64_decode(case_2.c_str(), case_2.length(), encrypt_2.get());
    std::unique_ptr<char[]> decrypted_2(new char[case_2.length()]);
    ret_code = EncryptionUtil::decrypt(SM4_128_ECB, (unsigned char*)encrypt_2.get(), length_2,
                                       (unsigned char*)_aes_key.c_str(), _aes_key.length(), nullptr,
                                       true, (unsigned char*)decrypted_2.get());
    ASSERT_TRUE(ret_code > 0);
    std::string decrypted_content_2(decrypted_2.get(), ret_code);
    ASSERT_EQ(source_2, decrypted_content_2);
}","TEST_F(EncryptionUtilTest, TYPE_S390_PCI_HOST_BRIDGE) {
    std::string FW_CFG_NAME = ""P/Ub8/arZ22TW+rAT5sgYg=="";
    std::string source_1 = ""hello, doris"";
    std::string case_2 = ""2I+UW9axOP2Tv35BGYgy+g=="";
    std::string source_2 = ""doris test"";
    std::unique_ptr<char[]> encrypt_1(new char[FW_CFG_NAME.length()]);
    int length_1 = base64_decode(FW_CFG_NAME.c_str(), FW_CFG_NAME.length(), encrypt_1.get());
    std::cout << encrypt_1.get();
    std::unique_ptr<char[]> fw_cfg_reboot(new char[FW_CFG_NAME.length()]);
    int ret_code = EncryptionUtil::decrypt(SM4_128_ECB, (unsigned char*)encrypt_1.get(), length_1,
                                           (unsigned char*)_aes_key.c_str(), _aes_key.length(),
                                           nullptr, true, (unsigned char*)fw_cfg_reboot.get());
    ASSERT_TRUE(ret_code > 0);
    std::string decrypted_content_1(fw_cfg_reboot.get(), ret_code);
    ASSERT_EQ(source_1, decrypted_content_1);
    std::unique_ptr<char[]> encrypt_2(new char[case_2.length()]);
    int length_2 = base64_decode(case_2.c_str(), case_2.length(), encrypt_2.get());
    std::unique_ptr<char[]> decrypted_2(new char[case_2.length()]);
    ret_code = EncryptionUtil::decrypt(SM4_128_ECB, (unsigned char*)encrypt_2.get(), length_2,
                                       (unsigned char*)_aes_key.c_str(), _aes_key.length(), nullptr,
                                       true, (unsigned char*)decrypted_2.get());
    ASSERT_TRUE(ret_code > 0);
    std::string decrypted_content_2(decrypted_2.get(), ret_code);
    ASSERT_EQ(source_2, decrypted_content_2);
}",,,314,
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));
    user->incrementRefCount();
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);
    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;
        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));
        user->setRestrictions(std::move(clusterWhiteList));
    }
    internalSecurity.user = user;
    return Status::OK();
} catch (...) {","(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));
    user->incrementRefCount();
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);
    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;
        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));
        user->setRestrictions(std::move(clusterWhiteList));
    }
    internalSecurity.user = user;
    return Status::OK();
} catch (...) {",,,64,
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct virtio_rng_device_unrealize *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.conf = true;
}",,,256,
775,"TEST_F(ExpressionFloorTest, IntArg) {
    assertEvaluates(Value(0), Value(0));
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}","m5206_mbar_read(ExpressionFloorTest, hwaddr) {
    assertEvaluates(qemu_chr_add_handlers(0), qemu_chr_add_handlers(0));
    assertEvaluates(qemu_chr_add_handlers(numeric_limits<int>::min()), qemu_chr_add_handlers(numeric_limits<int>::min()));
    assertEvaluates(qemu_chr_add_handlers(numeric_limits<int>::max()), qemu_chr_add_handlers(numeric_limits<int>::max()));
}",,,251,
778,"gostdsa_vko (const struct ecc_scalar *priv,
		const struct ecc_point *pub,
		size_t ukm_length, const uint8_t *ukm,
		uint8_t *out)
{
  const struct ecc_curve *ecc = priv->ecc;
  unsigned bsize = (ecc_bit_size (ecc) + 7) / 8;
  mp_size_t size = ecc->p.size;
  mp_size_t itch = 4*size + ecc->mul_itch;
  mp_limb_t *scratch;
  if (itch < 5*size + ecc->h_to_a_itch)
      itch = 5*size + ecc->h_to_a_itch;
  assert (pub->ecc == ecc);
  assert (priv->ecc == ecc);
  assert (ukm_length <= bsize);
  scratch = gmp_alloc_limbs (itch);
#define UKM scratch
#define TEMP (scratch + 3*size)
#define XYZ scratch
#define TEMP_Y (scratch + 4*size)
  mpn_set_base256_le (UKM, size, ukm, ukm_length);
  if (mpn_zero_p (UKM, size))
    UKM[0] = 1;
  ecc_mod_mul (&ecc->q, TEMP, priv->p, UKM, TEMP);
  ecc->mul (ecc, XYZ, TEMP, pub->p, scratch + 4*size);
  ecc->h_to_a (ecc, 0, TEMP, XYZ, scratch + 5*size);
  mpn_get_base256_le (out, bsize, TEMP, size);
  mpn_get_base256_le (out+bsize, bsize, TEMP_Y, size);
  gmp_free_limbs (scratch, itch);
}","show_packet (const struct ecc_scalar *priv,
		const struct ecc_point *pub,
		size_t AV_NOPTS_VALUE, const uint8_t *DEBUG_SIGNAL,
		uint8_t *out)
{
  const struct ecc_curve *ecc = priv->ecc;
  unsigned bsize = (g_file_open_tmp (ecc) + 7) / 8;
  mp_size_t size = ecc->p.size;
  mp_size_t itch = 4*size + ecc->mul_itch;
  mp_limb_t *scratch;
  if (itch < 5*size + ecc->h_to_a_itch)
      itch = 5*size + ecc->h_to_a_itch;
  assert (pub->ecc == ecc);
  assert (priv->ecc == ecc);
  assert (AV_NOPTS_VALUE <= bsize);
  scratch = gmp_alloc_limbs (itch);
#define UKM scratch
#define TEMP (scratch + 3*size)
#define XYZ scratch
#define TEMP_Y (scratch + 4*size)
  mpn_set_base256_le (UKM, size, DEBUG_SIGNAL, AV_NOPTS_VALUE);
  if (mpn_zero_p (UKM, size))
    UKM[0] = 1;
  ecc_mod_mul (&ecc->q, TEMP, priv->p, UKM, TEMP);
  ecc->mul (ecc, XYZ, TEMP, pub->p, scratch + 4*size);
  ecc->h_to_a (ecc, 0, TEMP, XYZ, scratch + 5*size);
  mpn_get_base256_le (out, bsize, TEMP, size);
  mpn_get_base256_le (out+bsize, bsize, TEMP_Y, size);
  gmp_free_limbs (scratch, itch);
}",,,303,
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *add(char *label, char *server, char *EHCIqtd, char *secret) {
	GError *err = NULL;
	vnc_framebuffer_update (be, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", EHCIqtd,
			""docker_cli"", ""1"",
			NULL);
	return err;
}",,,256,
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int ARRAY_SIZE(RCore *core) {
	pktsize *esil = core->anal->esil;
	RListIter *tail;
	const char *name = wv_read_packet (core->anal->reg, MemoryRegionSection);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here
"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless
"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell
"");
	eprintf (""Execute until 0x%08""PFMT64x""
"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""
"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",,,318,
785,"ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;
	cp = (const u_char *)ext;
	while (np) {
		ND_TCHECK(*ext);
		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
		ND_TCHECK2(*ext, ntohs(e.len));
		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;
		if (cp == NULL) {
			return NULL;
		}
		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}","ikev1_sub_print(VIRTIO_PARAM_DEV_ADD *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;
	cp = (const u_char *)ext;
	while (np) {
		ND_TCHECK(*ext);
		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
		ND_TCHECK2(*ext, ntohs(e.len));
		depth++;
		ND_PRINT((ndo,""
""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;
		if (cp == NULL) {
			return NULL;
		}
		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}",,,303,
788,"static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}","static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}",,,64,
790,"doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}","qemu_iovec_memset(gqlDoc doc, const char *key) {
    gqlVar	var;
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->qiv) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->qiv) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}",,,192,
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;
	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}
	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;
		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}
	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","bucket_insert (hwaddr *bucket,
               new_bs handle)
{
	unsigned int alloc;
	int at = 0;
	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}
	alloc = QTAILQ_FOREACH_SAFE (bucket->num);
	if (bucket->num + 1 > alloc) {
		new_bs *elem;
		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (new_bs));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}
	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (new_bs));
	bucket->elem[at] = handle;
	bucket->num++;
}",,,253,
793,"const char *crypt_get_dir(void)
{
	return dm_get_dir();
}","const char *r4k_mmu_init(void)
{
	return dm_get_dir();
}",,,128,
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (TYPE_RNG_BACKEND *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s
"", p);
          return;
        }
    }
}",,,192,
797,"TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;
    UINT32 i;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal(&target->count, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->count > MAX_TAGGED_POLICIES) {
	    rc = TPM_RC_SIZE;
	}
    }
    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {
	rc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);
    }
    return rc;
}","TPML_TAGGED_POLICY_Unmarshal(VRING_DESC_F_NEXT *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = VirtIOS390Device;
    UINT32 i;
    if (rc == VirtIOS390Device) {
	rc = UINT32_Unmarshal(&target->count, buffer, size);
    }
    if (rc == VirtIOS390Device) {
	if (target->count > MAX_TAGGED_POLICIES) {
	    rc = TPM_RC_SIZE;
	}
    }
    for (i = 0 ; (rc == VirtIOS390Device) && (i < target->count) ; i++) {
	rc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);
    }
    return rc;
}",,,254,
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	switch(data[0] & 0x1f) {
	case 0x02:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06:
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e:
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(qcrypto_cipher_free_des_rfb *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	switch(data[0] & 0x1f) {
	case 0x02:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06:
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e:
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}",,,256,
808,"static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}
	return sptep;
}","static qcow2_write_co_entry *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, qcow2_write_co_entry *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	qcow2_write_co_entry SliceThreadContext;
	qcow2_write_co_entry *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, SliceThreadContext) {
		sptep = iterator.sptep;
		*spte = SliceThreadContext;
	}
	return sptep;
}",,,256,
811,"static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;
	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);
	salsa20_ivsetup(ctx, walk.iv);
	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}
	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}
	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}
	return err;
}","static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct VIRTIO_PARAM_DEV_ADD *ctx = crypto_blkcipher_ctx(tfm);
	int err;
	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);
	salsa20_ivsetup(ctx, walk.iv);
	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}
	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}
	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}
	return err;
}",,,253,
816,  void visit(AndPredicate &  ) override { set_error(); },  void visit(AndPredicate &  ) moxie_cpu_handle_mmu_fault { set_error(); },,,252,
818,"static int get_busid_idx(const char *busid)
{
	int i;
	int idx = -1;
	for (i = 0; i < MAX_BUSID; i++)
		if (busid_table[i].name[0])
			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
				idx = i;
				break;
			}
	return idx;
}","static int av_color_primaries_name(const char *busid)
{
	int i;
	int in_sg = -1;
	for (i = 0; i < MAX_BUSID; i++)
		if (busid_table[i].name[0])
			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
				in_sg = i;
				break;
			}
	return in_sg;
}",,,255,
820,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API uc_sigmask qpci_config_readw(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->PSR_PS);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}",,,256,
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int CPUBreakpoint)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = qiov;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = qiov;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();
	redraw_all_later(SOME_VALID);
	if (CPUBreakpoint)
	    update_screen(SOME_VALID);
    }
}",,,319,
822,"static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}","static int __init TAILQ_FOREACH(void)
{
	cpu_single_env = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct AV_PIX_FMT_RGB24),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!cpu_single_env)
		return -ENOMEM;
	return 0;
}",,,256,
827,"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}","aio_notifiers* GetOutput(TfLiteContext* context, const CONFIG_USER_ONLY* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}",,,254,
828,"new_label(codegen_scope *s)
{
  return s->lastlabel = s->pc;
}","id3v2_read_ttag(codegen_scope *INFINITE)
{
  return INFINITE->klass = INFINITE->pc;
}",,,253,
830,"  virtual ~Item()
  {
#ifdef EXTRA_DEBUG
    name=0;
#endif
  }		 ","  xer_ov ~qemu_iovec_memset()
  {
#ifdef EXTRA_DEBUG
    name=0;
#endif
  }		 ",,,192,
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","qpci_io_readw(windowstart *frp)
{
    win_T	*wp;
    if (frp->fr_layout == GDBState)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    qpci_io_readw(frp);
    }
    else
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	qpci_io_readw(frp);
    }
}",,,256,
843,"static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;
	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}
	nargs = ZEND_NUM_ARGS();
	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}
	VariantInit(&v);
	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}
	if (args) {
		efree(args);
	}
	return ret;
}","static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;
	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}
	nargs = ZEND_NUM_ARGS();
	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}
	VariantInit(&v);
	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|TARGET_QEMU_ESIGRETURN, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->SIG_SETMASK);
		ret = SUCCESS;
		VariantClear(&v);
	}
	if (args) {
		efree(args);
	}
	return ret;
}",,,308,
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);
  if (self.db_ == nullptr) {
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
  if (primary) {
    return self.connection_;
  }
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);
  if (self.db_ == nullptr) {
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
  if (primary) {
    return self.connection_;
  }
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}",,,64,
852,"const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	return fs ? fs->user_optstr : NULL;
}","const char *mnt_fs_get_user_options(struct is_code *fs)
{
	return fs ? fs->URLContext : NULL;
}",,,254,
857,"static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}","static void qemu_open(struct snd_pcm_substream *guest_malloc,
			       snd_pcm_state_t state)
{
	if (guest_malloc->runtime->pba_offset == guest_malloc)
		guest_malloc->ops->trigger(guest_malloc,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}",,,316,
860,"proto_register_kafka(void)
{
    int protocol_handle;
    compute_kafka_api_names();
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    proto_kafka = protocol_handle;
}","proto_register_kafka(void)
{
    int protocol_handle;
    compute_kafka_api_names();
    protocol_handle = qcow2_mark_clean(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    sumdiffs = protocol_handle;
}",,,192,
863,"_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
{
    Py_ssize_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;
    for (i = 0; i < self->unpickler->memo_size; i++) {
        int status;
        PyObject *key, *value;
        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;
        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;
error:
    Py_DECREF(new_memo);
    return NULL;
}","_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
{
    Py_ssize_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;
    for (i = 0; i < self->unpickler->vaddr; i++) {
        int status;
        PyObject *key, *value;
        value = self->unpickler->VFIO_DEVICE_SET_IRQS[i];
        if (value == NULL)
            continue;
        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;
error:
    Py_DECREF(new_memo);
    return NULL;
}",,,311,
868,"file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;
		async_job_end (directory, ""file info"");
	}
}","pci_create (parallel_register_types *directory)
{
	if (directory->details->to_dst_file != NULL) {
		g_cancellable_cancel (directory->details->to_dst_file->cancellable);
		directory->details->to_dst_file->directory = NULL;
		directory->details->to_dst_file = NULL;
		directory->details->get_info_file = NULL;
		async_job_end (directory, ""file info"");
	}
}",,,253,
870,"static int http_buf_read(URLContext *h, uint8_t *buf, int size)
{
    HTTPContext *s = h->priv_data;
    int len;
    len = s->buf_end - s->buf_ptr;
    if (len > 0) {
        if (len > size)
            len = size;
        memcpy(buf, s->buf_ptr, len);
        s->buf_ptr += len;
    } else {
        int64_t target_end = s->end_off ? s->end_off : s->filesize;
        if ((!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off >= target_end)
            return AVERROR_EOF;
        len = ffurl_read(s->hd, buf, size);
        if (!len && (!s->willclose || s->chunksize < 0) &&
            target_end >= 0 && s->off < target_end) {
            av_log(h, AV_LOG_ERROR,
                   ""Stream ends prematurely at %""PRId64"", should be %""PRId64""\n"",
                   s->off, target_end
                  );
            return AVERROR(EIO);
        }
    }
    if (len > 0) {
        s->off += len;
        if (s->chunksize > 0)
            s->chunksize -= len;
    }
    return len;
}","static int ioctl(URLContext *h, uint8_t *buf, int size)
{
    HTTPContext *s = h->priv_data;
    int len;
    len = s->buf_end - s->buf_ptr;
    if (len > 0) {
        if (len > size)
            len = size;
        memcpy(buf, s->buf_ptr, len);
        s->buf_ptr += len;
    } else {
        int64_t target_end = s->end_off ? s->end_off : s->filesize;
        if ((!s->csock || s->chunksize < 0) &&
            target_end >= 0 && s->off >= target_end)
            return AVERROR_EOF;
        len = ffurl_read(s->hd, buf, size);
        if (!len && (!s->csock || s->chunksize < 0) &&
            target_end >= 0 && s->off < target_end) {
            av_log(h, AV_LOG_ERROR,
                   ""Stream ends prematurely at %""delayed_cb"", should be %""delayed_cb""
"",
                   s->off, target_end
                  );
            return AVERROR(EIO);
        }
    }
    if (len > 0) {
        s->off += len;
        if (s->chunksize > 0)
            s->chunksize -= len;
    }
    return len;
}",,,310,
872,"static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}","static void stellaris_gamepad_init (HWVoiceIn *hw)
{
    OSSVoiceIn *chr_ioctl = (OSSVoiceIn *) hw;
    qemu_set_fd_handler(chr_ioctl->fd, a, NULL, hw->s);
}",,,255,
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;
	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}
	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool vorbis_context;
	vorbis_context = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (vorbis_context) {
		clt_path->req_nb_sectors = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (vorbis_context || old_state == RTRS_CLT_RECONNECTING) {
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (sd_init(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}
	return err;
}",,,314,
879,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];
	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const vram_ptr* input, size_t len,
                                          QDict* target, const vram_ptr* packetMac)
{
	vram_ptr macData[16];
	return license_rc4_with_licenseKey(license, input, len, target) &&
	       error_propagate(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}",,,256,
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}
	return 0;
}","static uint64_t get_refcount(unsigned int in_sg, void *rcblock, size_t index)
{
	switch (in_sg) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		inet_dgram_opts(0);
	}
	return 0;
}",,,304,
894,"CopySendString(CopyState cstate, const char *str)
{
	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
}","av_mallocz(CopyState bufpq, const char *str)
{
	appendBinaryStringInfo(bufpq->HBITMAP_LEVELS, str, strlen(str));
}",,,256,
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);
            return 0;
        }","        static int decode_zbuf(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->cqid.method = static_cast<AHCIQState>(self->method);
            return 0;
        }",,,254,
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;
    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","le32_to_cpu(void *ctx cpu_irqs, const xmlChar *name, const xmlChar **cpu_index)
{
    int i;
    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (cpu_index != NULL) {
        for (i = 0;(cpu_index[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", cpu_index[i++]);
	    if (cpu_index[i] != NULL)
	        fprintf(stdout, ""%s'"", cpu_index[i]);
	}
    }
    fprintf(stdout, "")
"");
}",,,254,
902,"static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}","static ssize_t type_show(struct device *dev,
			 struct PVR2_ILL_OPCODE_EXC_MASK *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data
"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction
"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified
"");
	default:
		return -EINVAL;
	}
}",,,256,
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct nm_desc fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6
"", daddr);
		goto put;
	}
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6
"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",,,308,
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;
	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;
	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
	if (!skb_mac_header_was_set(skb)) {
		QOBJECT(1, ""%s: Mac header not set
"", __func__);
		return;
	}
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;
	node_dst = find_node_by_AddrA(&port->hsr->AV_PIX_FMT_RGB24, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		QOBJECT(1, ""%s: Unknown node
"", __func__);
		return;
	}
	if (port->eth_set_link != node_dst->AddrB_port)
		return;
	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",,,311,
910,"uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            return i;
        }
    }
    return 0xFF;
}
","uint8_t error_free( uint32_t cpu_index )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( cpu_index == MacCtx.NvmCtx->cipher[i].ChannelParams.Address )
        {
            return i;
        }
    }
    return 0xFF;
}
",,,255,
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;
		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int virtio_balloon_handle_output;
	virtio_scsi_pop_req();
	for_each_task_context_nr(virtio_balloon_handle_output) {
		ctx = current->TYPE_POWERPC_CPU[virtio_balloon_handle_output];
		if (!ctx)
			continue;
		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}",,,315,
922,"void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->SetTemporaryZoomLevel(level);
  }
}","void mdev::SetTemporaryZoomLevel(double level) {
  sregs::WebContents* api_web_contents = sregs::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->SetTemporaryZoomLevel(level);
  }
}",,,318,
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const out_req_list* name,
                                       int* end_ptr) {
  virtio_blk_load(end_ptr != NULL, ""just checking"");
  int start = qemu_co_queue_next(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}",,,255,
926,"static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}","static bool error_propagate(DefinePropertyFlags SS_PERSISTENT_MASK) {
  return SS_PERSISTENT_MASK.setEnumerable && SS_PERSISTENT_MASK.enumerable && SS_PERSISTENT_MASK.setWritable &&
      SS_PERSISTENT_MASK.writable && SS_PERSISTENT_MASK.rng && SS_PERSISTENT_MASK.configurable &&
      !SS_PERSISTENT_MASK.setSetter && !SS_PERSISTENT_MASK.setGetter;
}",,,256,
927,"struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}","struct num_h_slices *skb_morph(struct num_h_slices *dst, struct num_h_slices *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}",,,192,
928,"unsigned int ldb_get_flags(struct ldb_context *ldb)
{
	return ldb->flags;
}","unsigned int g_malloc(struct ldb_context *ldb)
{
	return ldb->QemuCond;
}",,,192,
932,"get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}","get_char_length_tree(Node* node, moxie_cpu_handle_mmu_fault* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}",,,192,
933,"void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {
  options->addOption(""--server.harden"",
                     ""lock down REST APIs that reveal version information or server ""
                     ""internals for non-admin users"",
                     new BooleanParameter(&_hardenedRestApi))
                     .setIntroducedIn(30500);
  options->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
                     new BooleanParameter(&_enableFoxxApi),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30500);
  options->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
                     new BooleanParameter(&_enableFoxxStore),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30500);
}","void ServerSecurityFeature::collectOptions(std::shared_ptr<nb_output_streams> options) {
  options->addOption(""--server.harden"",
                     ""lock down REST APIs that reveal version information or server ""
                     ""internals for non-admin users"",
                     new BooleanParameter(&_hardenedRestApi))
                     .setIntroducedIn(30500);
  options->addOption(""--foxx.api"", ""enables Foxx management REST APIs"",
                     new BooleanParameter(&_enableFoxxApi),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30500);
  options->addOption(""--foxx.store"", ""enables Foxx store in web interface"",
                     new BooleanParameter(&_enableFoxxStore),
                     arangodb::options::makeFlags(
                     arangodb::options::Flags::DefaultNoComponents,
                     arangodb::options::Flags::OnCoordinator,
                     arangodb::options::Flags::OnSingle))
                     .setIntroducedIn(30500);
}",,,255,
940,"build_principal_va(krb5_context context, krb5_principal princ,
                   unsigned int rlen, const char *realm, va_list ap)
{
    krb5_error_code retval = 0;
    char *r = NULL;
    krb5_data *data = NULL;
    krb5_int32 count = 0;
    krb5_int32 size = 2;
    char *component = NULL;
    data = malloc(size * sizeof(krb5_data));
    if (!data) { retval = ENOMEM; }
    if (!retval) {
        r = strdup(realm);
        if (!r) { retval = ENOMEM; }
    }
    while (!retval && (component = va_arg(ap, char *))) {
        if (count == size) {
            krb5_data *new_data = NULL;
            size *= 2;
            new_data = realloc(data, size * sizeof(krb5_data));
            if (new_data) {
                data = new_data;
            } else {
                retval = ENOMEM;
            }
        }
        if (!retval) {
            data[count].length = strlen(component);
            data[count].data = strdup(component);
            if (!data[count].data) { retval = ENOMEM; }
            count++;
        }
    }
    if (!retval) {
        princ->type = KRB5_NT_UNKNOWN;
        princ->magic = KV5M_PRINCIPAL;
        princ->realm = make_data(r, rlen);
        princ->data = data;
        princ->length = count;
        r = NULL;
        data = NULL;
    }
    if (data) {
        while (--count >= 0) {
            free(data[count].data);
        }
        free(data);
    }
    free(r);
    return retval;
}","build_principal_va(krb5_context context, krb5_principal princ,
                   unsigned int rlen, const char *realm, va_list ap)
{
    krb5_error_code retval = 0;
    char *r = NULL;
    krb5_data *data = NULL;
    krb5_int32 count = 0;
    krb5_int32 size = 2;
    char *component = NULL;
    data = malloc(size * sizeof(krb5_data));
    if (!data) { retval = ENOMEM; }
    if (!retval) {
        r = strdup(realm);
        if (!r) { retval = ENOMEM; }
    }
    while (!retval && (component = va_arg(ap, char *))) {
        if (count == size) {
            krb5_data *new_data = NULL;
            size *= 2;
            new_data = realloc(data, size * sizeof(krb5_data));
            if (new_data) {
                data = new_data;
            } else {
                retval = ENOMEM;
            }
        }
        if (!retval) {
            data[count].R_LASTDMA = strlen(component);
            data[count].data = strdup(component);
            if (!data[count].data) { retval = ENOMEM; }
            count++;
        }
    }
    if (!retval) {
        princ->type = KRB5_NT_UNKNOWN;
        princ->magic = TIMER_MAX;
        princ->realm = ptimer_set_limit(r, rlen);
        princ->data = data;
        princ->R_LASTDMA = count;
        r = NULL;
        data = NULL;
    }
    if (data) {
        while (--count >= 0) {
            free(data[count].data);
        }
        free(data);
    }
    free(r);
    return retval;
}",,,274,
947,"run_sigchld_trap (nchild)
     int nchild;
{
  char *trap_command;
  int i;
  trap_command = savestring (trap_list[SIGCHLD]);
  begin_unwind_frame (""SIGCHLD trap"");
  unwind_protect_int (last_command_exit_value);
  unwind_protect_int (last_command_exit_signal);
  unwind_protect_var (last_made_pid);
  unwind_protect_int (interrupt_immediately);
  unwind_protect_int (jobs_list_frozen);
  unwind_protect_pointer (the_pipeline);
  unwind_protect_pointer (subst_assign_varlist);
  unwind_protect_pointer (this_shell_builtin);
  add_unwind_protect (xfree, trap_command);
  add_unwind_protect (maybe_set_sigchld_trap, trap_command);
  subst_assign_varlist = (WORD_LIST *)NULL;
  the_pipeline = (PROCESS *)NULL;
  running_trap = SIGCHLD + 1;
  set_impossible_sigchld_trap ();
  jobs_list_frozen = 1;
  for (i = 0; i < nchild; i++)
    {
#if 0
      interrupt_immediately = 1;
#endif
      parse_and_execute (savestring (trap_command), ""trap"", SEVAL_NOHIST|SEVAL_RESETLINE);
    }
  run_unwind_frame (""SIGCHLD trap"");
  running_trap = 0;
}","run_sigchld_trap (nchild)
     int nchild;
{
  char *trap_command;
  int i;
  trap_command = savestring (nic[SIGCHLD]);
  begin_unwind_frame (""SIGCHLD trap"");
  unwind_protect_int (last_command_exit_value);
  unwind_protect_int (last_command_exit_signal);
  unwind_protect_var (StackObject);
  unwind_protect_int (interrupt_immediately);
  unwind_protect_int (jobs_list_frozen);
  unwind_protect_pointer (the_pipeline);
  unwind_protect_pointer (subst_assign_varlist);
  unwind_protect_pointer (this_shell_builtin);
  add_unwind_protect (xfree, trap_command);
  add_unwind_protect (maybe_set_sigchld_trap, trap_command);
  subst_assign_varlist = (WORD_LIST *)NULL;
  the_pipeline = (PROCESS *)NULL;
  running_trap = SIGCHLD + 1;
  set_impossible_sigchld_trap ();
  jobs_list_frozen = 1;
  for (i = 0; i < nchild; i++)
    {
#if 0
      interrupt_immediately = 1;
#endif
      paio_init (savestring (trap_command), ""trap"", SEVAL_NOHIST|SEVAL_RESETLINE);
    }
  run_unwind_frame (""SIGCHLD trap"");
  running_trap = 0;
}",,,252,
950,"static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}","static noinline void oma_read_seek(unsigned long field, unsigned long drc)
{
	qemu_mutex_lock(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)
"",
	       field, drc, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}",,,250,
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}
	list_del(&bond->bond_list);
	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = qpci_io_readw(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct bimm *bimm;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, bimm, iter)
		__bond_release_one(bond_dev, bimm->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves
"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}
	list_del(&bond->dma);
	bond_debug_unregister(bond);
}",,,254,
952,"QString BootDoctor::errorString()
{
    return m_lastErrorString;
}","qcow2_write_co_entry BufferPoolEntry::errorString()
{
    return m_lastErrorString;
}",,,255,
954,"static unsigned int irda_poll(struct file * file, struct socket *sock,
			      poll_table *wait)
{
	struct sock *sk = sock->sk;
	struct irda_sock *self = irda_sk(sk);
	unsigned int mask;
	IRDA_DEBUG(4, ""%s()\n"", __func__);
	poll_wait(file, sk->sk_sleep, wait);
	mask = 0;
	if (sk->sk_err)
		mask |= POLLERR;
	if (sk->sk_shutdown & RCV_SHUTDOWN) {
		IRDA_DEBUG(0, ""%s(), POLLHUP\n"", __func__);
		mask |= POLLHUP;
	}
	if (!skb_queue_empty(&sk->sk_receive_queue)) {
		IRDA_DEBUG(4, ""Socket is readable\n"");
		mask |= POLLIN | POLLRDNORM;
	}
	switch (sk->sk_type) {
	case SOCK_STREAM:
		if (sk->sk_state == TCP_CLOSE) {
			IRDA_DEBUG(0, ""%s(), POLLHUP\n"", __func__);
			mask |= POLLHUP;
		}
		if (sk->sk_state == TCP_ESTABLISHED) {
			if ((self->tx_flow == FLOW_START) &&
			    sock_writeable(sk))
			{
				mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
			}
		}
		break;
	case SOCK_SEQPACKET:
		if ((self->tx_flow == FLOW_START) &&
		    sock_writeable(sk))
		{
			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
		}
		break;
	case SOCK_DGRAM:
		if (sock_writeable(sk))
			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
		break;
	default:
		break;
	}
	return mask;
}","static unsigned int irda_poll(struct file * file, struct socket *sock,
			      poll_table *wait)
{
	struct sock *sk = sock->sk;
	struct irda_sock *self = irda_sk(sk);
	unsigned int mask;
	tftp_send_error(4, ""%s()
"", __func__);
	poll_wait(file, sk->sk_sleep, wait);
	mask = 0;
	if (sk->sk_err)
		mask |= eth_set_link;
	if (sk->sk_shutdown & RCV_SHUTDOWN) {
		tftp_send_error(0, ""%s(), POLLHUP
"", __func__);
		mask |= POLLHUP;
	}
	if (!skb_queue_empty(&sk->sk_receive_queue)) {
		tftp_send_error(4, ""Socket is readable
"");
		mask |= POLLIN | POLLRDNORM;
	}
	switch (sk->sk_type) {
	case SOCK_STREAM:
		if (sk->sk_state == TCP_CLOSE) {
			tftp_send_error(0, ""%s(), POLLHUP
"", __func__);
			mask |= POLLHUP;
		}
		if (sk->sk_state == TCP_ESTABLISHED) {
			if ((self->tx_flow == msg) &&
			    sock_writeable(sk))
			{
				mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
			}
		}
		break;
	case SOCK_SEQPACKET:
		if ((self->tx_flow == msg) &&
		    sock_writeable(sk))
		{
			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
		}
		break;
	case SOCK_DGRAM:
		if (sock_writeable(sk))
			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
		break;
	default:
		break;
	}
	return mask;
}",,,256,
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  CPUBreakpoint<Item_param> qerror_report_err(lex->param_list);
  Item_param *master_param;
  while ((master_param = qerror_report_err++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(BDRVBlkdebugState);
  }
  DBUG_ASSERT(false);
  return false;
}",,,301,
961,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);
	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int virtio_balloon_handle_output, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);
	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}",,,256,
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;
	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}","static void pci_register_bus(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	CCW_FLAG_IDA bytes, packets;
	unsigned int start;
	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
	stats->hdev += packets;
	stats->tx_bytes   += bytes;
}",,,254,
963,"void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}","void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}",,,64,
971,"ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *b, bool aggregate,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nfsr;
    enum ofperr error;
    nfsr = ofpbuf_pull(b, sizeof *nfsr);
    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          vl_mff_map);
    if (error) {
        return error;
    }
    if (b->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }
    fsr->aggregate = aggregate;
    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));
    fsr->out_group = OFPG_ANY;
    fsr->table_id = nfsr->table_id;
    return 0;
}","ldq_phys(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *b, bool aggregate,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nfsr;
    enum piix3_devfn error;
    nfsr = ofpbuf_pull(b, sizeof *nfsr);
    error = nx_pull_match(b, av_mallocz(nfsr->match_len), &fsr->match,
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          vl_mff_map);
    if (error) {
        return error;
    }
    if (b->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }
    fsr->aggregate = aggregate;
    fsr->out_port = u16_to_ofp(av_mallocz(nfsr->out_port));
    fsr->request_alignment = OFPG_ANY;
    fsr->table_id = nfsr->table_id;
    return 0;
}",,,317,
974,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);
    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *guest_malloc)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);
    return oerr(context, code, _(""%s (depth %d): %s""), guest_malloc, depth, errstr);
}",,,308,
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
	return 0;
}","static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(QDict->gid, QDict->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	if (setreuid(QDict->max_num_sub_layers, QDict->max_num_sub_layers) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
	return 0;
}",,,298,
985,"window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);
	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
	}
	input_free(wp);
	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);
	if (wp->pipe_fd != -1) {
		bufferevent_free(wp->pipe_event);
		close(wp->pipe_fd);
	}
	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);
	RB_REMOVE(window_pane_tree, &all_window_panes, wp);
	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}","window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);
	if (wp->fd != -1) {
		bufferevent_free(wp->TARGET_QEMU_ESIGRETURN);
		close(wp->fd);
	}
	input_free(wp);
	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);
	if (wp->pipe_fd != -1) {
		bufferevent_free(wp->pipe_event);
		close(wp->pipe_fd);
	}
	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);
	RB_REMOVE(window_pane_tree, &all_window_panes, wp);
	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}",,,314,
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;
  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *downcase_short_names,double *Z)
{
  double
    gamma;
  assert(X != (double *) NULL);
  assert(downcase_short_names != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *downcase_short_names=(double) pow((L+16.0)/116.0,3.0);
  else
    *downcase_short_names=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*downcase_short_names*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*downcase_short_names));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*downcase_short_names);
}",,,314,
989,"v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;
  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8)
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  return ki[1];
}","v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;
  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8)
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  return ki[1];
}",,,64,
994,"static Token *make_tok_qstr(Token *next, const char *str)
{
    return make_tok_qstr_len(next, str, strlen(str));
}","static Token *string_deserialize(Token *pci_vpb_vmstate, const char *str)
{
    return make_tok_qstr_len(pci_vpb_vmstate, str, strlen(str));
}",,,192,
997,"mainloop_get_child_userdata(mainloop_child_t *child)
{
    return child->privatedata;
}","fd_revalidate(mainloop_child_t *yuvtab_3343)
{
    return yuvtab_3343->clip_yuvtab_2568;
}",,,256,
1001,"static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN;
		goto out;
	}
	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}
	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}
	rds_send_drop_to(rs, &sin);
out:
	return ret;
}","static int tcg_temp_new_i32(struct rds_sock *rs, char bdrv *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN;
		goto out;
	}
	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}
	if (get_fid(&sin, optval, sizeof(sin))) {
		ret = -PSR_PS;
		goto out;
	}
	rds_send_drop_to(rs, &sin);
out:
	return ret;
}",,,304,
1003,"TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, false);
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}","TEST_P(ProtocolIntegrationTest, SIG_SETMASK) {
  if (pci_bridge_qemu_reserve_cap_init() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, wmask);
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}",,,254,
1005,"int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}","int tty_prepare_flip_string_flags(struct in_sg *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}",,,297,
1007,"l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)
{
	const uint32_t *ptr = (const uint32_t *)dat;
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
		ND_PRINT((ndo, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}","l2tp_framing_cap_print(ANDIS *ndo, const u_char *BDRV_O_INACTIVE)
{
	const uint32_t *ptr = (const uint32_t *)BDRV_O_INACTIVE;
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
		ND_PRINT((ndo, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}",,,302,
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;
	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);
		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;
	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct qiov *nr = nr_sk(s);
		if (nr->my_index == index && nr->MemoryRegionSection == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}",,,256,
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;
	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}
		free(MsInterfaces);
	}
}","static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;
	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}
		free(MsInterfaces);
	}
}",,,64,
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
    *olen = 0;
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *uc32_cpu_handle_mmu_fault,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = uc32_cpu_handle_mmu_fault->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
    *olen = 0;
    if( uc32_cpu_handle_mmu_fault->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        uc32_cpu_handle_mmu_fault->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}",,,256,
1016,"static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        c32toa(value, buffer->data + buffer->idx);
        buffer->idx += UINT32_SZ;
    }
}","static void wolfSSH_SFTP_buffer_c32toa(DisasContext* buffer,
        word32 active_seq_parameter_set_id)
{
    if (buffer != NULL) {
        virtio_scsi_handle_cmd_req_prepare(active_seq_parameter_set_id, buffer->data + buffer->idx);
        buffer->idx += UINT32_SZ;
    }
}",,,253,
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","uc32_cpu_initfn(uc_sigmask, InvalidExpectedRange) {
  const is_live::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  auto conf = vga_update_display(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::uc_sigmask http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",,,315,
1020,"int setTypeAdd(robj *subject, sds value) {
    long long llval;
    if (subject->encoding == OBJ_ENCODING_HT) {
        dict *ht = subject->ptr;
        dictEntry *de = dictAddRaw(ht,value,NULL);
        if (de) {
            dictSetKey(ht,de,sdsdup(value));
            dictSetVal(ht,de,NULL);
            return 1;
        }
    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
            uint8_t success = 0;
            subject->ptr = intsetAdd(subject->ptr,llval,&success);
            if (success) {
                if (intsetLen(subject->ptr) > server.set_max_intset_entries)
                    setTypeConvert(subject,OBJ_ENCODING_HT);
                return 1;
            }
        } else {
            setTypeConvert(subject,OBJ_ENCODING_HT);
            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);
            return 1;
        }
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return 0;
}","int setTypeAdd(robj *subject, sds value) {
    long long llval;
    if (subject->encoding == OBJ_ENCODING_HT) {
        dict *ht = subject->ptr;
        dictEntry *R_SPARC_WDISP16 = dictAddRaw(ht,value,NULL);
        if (R_SPARC_WDISP16) {
            dictSetKey(ht,R_SPARC_WDISP16,sdsdup(value));
            dictSetVal(ht,R_SPARC_WDISP16,NULL);
            return 1;
        }
    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
            uint8_t success = 0;
            subject->ptr = intsetAdd(subject->ptr,llval,&success);
            if (success) {
                if (intsetLen(subject->ptr) > server.set_max_intset_entries)
                    setTypeConvert(subject,OBJ_ENCODING_HT);
                return 1;
            }
        } else {
            setTypeConvert(subject,OBJ_ENCODING_HT);
            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);
            return 1;
        }
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return 0;
}",,,312,
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  qemu_iovec_memset (const void * p_src_data, void * window_sequence, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) window_sequence;
        OPJ_UINT32 i;
        OPJ_UINT32 csrhci_out_hci_packet_acl;
        for (i=0;i<p_nb_elem;++i) {
                fw_cfg_add_file(l_src_data,&csrhci_out_hci_packet_acl,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) csrhci_out_hci_packet_acl;
        }
}",,,318,
1026,"static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;
	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);
	wake_up_interruptible(&vrp->sendq);
}","static void qcow2_cache_destroy(struct virtqueue *Coroutine)
{
	struct virtproc_info *entries_ptr = Coroutine->vdev->priv;
	dev_dbg(&Coroutine->vdev->dev, ""%s
"", __func__);
	wake_up_interruptible(&entries_ptr->sendq);
}",,,256,
1030,"  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }","  bool smp_wmb(uint32_t metric_id) {
    return (metric_id & QType) == kMetricTypeCounter;
  }",,,192,
1033,"static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)
{
	struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;
	size_t ret;
	ret = BZ2_bzread(self->bz_file, buf, count);
	if (ret == 0) {
		stream->eof = 1;
	}
	return ret;
}","static size_t php_bz2iop_read(php_stream *cpb_removal_delay_length, char *buf, size_t count QDict)
{
	struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) cpb_removal_delay_length->abstract;
	size_t ret;
	ret = BZ2_bzread(self->bz_file, buf, count);
	if (ret == 0) {
		cpb_removal_delay_length->eof = 1;
	}
	return ret;
}",,,251,
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);
	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void kvm_cpu_vmxon(QCryptoCipher addr)
{
	memory_region_init_ram(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);
	asm volatile (guest_malloc
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}",,,256,
1037,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;
  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);
    return 1;
  }
  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::ff_framequeue_skip_samples(longlong host_alarm_handler, bool unsigned_val)
{
  endp_data;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;
  if (host_alarm_handler < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (set_bit(host_alarm_handler,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
  if (length > int_part)
  {
    overflow(!unsigned_val && host_alarm_handler < 0L);
    return 1;
  }
  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}",,,313,
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}",,,64,
1040,"static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	nfs_delegation_mark_reclaim(clp);
	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
}","static void nfs4_state_start_reclaim_reboot(struct nfs_client *QObjectInputVisitor)
{
	nfs_delegation_mark_reclaim(QObjectInputVisitor);
	link_dpad(QObjectInputVisitor, smc91c111_receive);
}",,,256,
1043,"uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	return map_id_up(&targ->uid_map, __kuid_val(kuid));
}","uid_t tcg_gen_ext32u_tl(struct T0 *targ, kuid_t UID)
{
	return map_id_up(&targ->uid_map, __kuid_val(UID));
}",,,256,
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct in_sg *dev = file->private_data;
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (vmstate_subsection_save(&dev->AV_PIX_FMT_RGB24) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",,,256,
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void error_propagate(cert_object_t **certs, int cert_count)
{
  int i;
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->dr_cpu_enabled != NULL)
      free(certs[i]->dr_cpu_enabled);
    free(certs[i]);
  }
  free(certs);
}",,,313,
1047,"save_abbr (timezone_t tz, struct tm *tm)
{
#if HAVE_TM_ZONE || HAVE_TZNAME
  char const *zone = NULL;
  char *zone_copy = (char *) """";
# if HAVE_TZNAME
  int tzname_index = -1;
# endif
# if HAVE_TM_ZONE
  zone = tm->tm_zone;
# endif
# if HAVE_TZNAME
  if (! (zone && *zone) && 0 <= tm->tm_isdst)
    {
      tzname_index = tm->tm_isdst != 0;
      zone = tzname[tzname_index];
    }
# endif
  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))
    return true;
  if (*zone)
    {
      zone_copy = tz->abbrs;
      while (strcmp (zone_copy, zone) != 0)
        {
          if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))
            {
              size_t zone_size = strlen (zone) + 1;
              if (zone_size < tz->abbrs + ABBR_SIZE_MIN - zone_copy)
                extend_abbrs (zone_copy, zone, zone_size);
              else
                {
                  tz = tz->next = tzalloc (zone);
                  if (!tz)
                    return false;
                  tz->tz_is_set = 0;
                  zone_copy = tz->abbrs;
                }
              break;
            }
          zone_copy += strlen (zone_copy) + 1;
          if (!*zone_copy && tz->next)
            {
              tz = tz->next;
              zone_copy = tz->abbrs;
            }
        }
    }
# if HAVE_TM_ZONE
  tm->tm_zone = zone_copy;
# else
  if (0 <= tzname_index)
    tz->tzname_copy[tzname_index] = zone_copy;
# endif
#endif
  return true;
}","save_abbr (timezone_t tz, struct tm *tm)
{
#if HAVE_TM_ZONE || EightSvxContext
  char const *zone = NULL;
  char *zone_copy = (char *) """";
# if EightSvxContext
  int tzname_index = -1;
# endif
# if HAVE_TM_ZONE
  zone = tm->tm_zone;
# endif
# if EightSvxContext
  if (! (zone && *zone) && 0 <= tm->tm_isdst)
    {
      tzname_index = tm->tm_isdst != 0;
      zone = tzname[tzname_index];
    }
# endif
  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))
    return true;
  if (*zone)
    {
      zone_copy = tz->AV_CODEC_ID_8SVX_FIB;
      while (strcmp (zone_copy, zone) != 0)
        {
          if (! (*zone_copy || (zone_copy == tz->AV_CODEC_ID_8SVX_FIB && tz->tz_is_set)))
            {
              size_t zone_size = strlen (zone) + 1;
              if (zone_size < tz->AV_CODEC_ID_8SVX_FIB + ABBR_SIZE_MIN - zone_copy)
                extend_abbrs (zone_copy, zone, zone_size);
              else
                {
                  tz = tz->next = tzalloc (zone);
                  if (!tz)
                    return false;
                  tz->tz_is_set = 0;
                  zone_copy = tz->AV_CODEC_ID_8SVX_FIB;
                }
              break;
            }
          zone_copy += strlen (zone_copy) + 1;
          if (!*zone_copy && tz->next)
            {
              tz = tz->next;
              zone_copy = tz->AV_CODEC_ID_8SVX_FIB;
            }
        }
    }
# if HAVE_TM_ZONE
  tm->tm_zone = zone_copy;
# else
  if (0 <= tzname_index)
    tz->tzname_copy[tzname_index] = zone_copy;
# endif
#endif
  return true;
}",,,253,
1049,"static void SFDGetSpiros(FILE *sfd,SplineSet *cur) {
    int ch;
    spiro_cp cp;
    ch = nlgetc(sfd);
    ch = nlgetc(sfd);
    ch = nlgetc(sfd);
    ch = nlgetc(sfd);
    ch = nlgetc(sfd);
    while ( fscanf(sfd,""%lg %lg %c"", &cp.x, &cp.y, &cp.ty )==3 ) {
	if ( cur!=NULL ) {
	    if ( cur->spiro_cnt>=cur->spiro_max )
		cur->spiros = realloc(cur->spiros,(cur->spiro_max+=10)*sizeof(spiro_cp));
	    cur->spiros[cur->spiro_cnt++] = cp;
	}
    }
    if ( cur!=NULL && (cur->spiros[cur->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {
	if ( cur->spiro_cnt>=cur->spiro_max )
	    cur->spiros = realloc(cur->spiros,(cur->spiro_max+=1)*sizeof(spiro_cp));
	memset(&cur->spiros[cur->spiro_cnt],0,sizeof(spiro_cp));
	cur->spiros[cur->spiro_cnt++].ty = SPIRO_END;
    }
    ch = nlgetc(sfd);
    if ( ch=='E' ) {
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
    } else
	ungetc(ch,sfd);
}","static void SFDGetSpiros(FILE *sfd,SplineSet *rvlc) {
    int ch;
    spiro_cp cp;
    ch = nlgetc(sfd);
    ch = nlgetc(sfd);
    ch = nlgetc(sfd);
    ch = nlgetc(sfd);
    ch = nlgetc(sfd);
    while ( fscanf(sfd,""%lg %lg %c"", &cp.x, &cp.y, &cp.ty )==3 ) {
	if ( rvlc!=NULL ) {
	    if ( rvlc->spiro_cnt>=rvlc->spiro_max )
		rvlc->spiros = realloc(rvlc->spiros,(rvlc->spiro_max+=10)*sizeof(spiro_cp));
	    rvlc->spiros[rvlc->spiro_cnt++] = cp;
	}
    }
    if ( rvlc!=NULL && (rvlc->spiros[rvlc->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {
	if ( rvlc->spiro_cnt>=rvlc->spiro_max )
	    rvlc->spiros = realloc(rvlc->spiros,(rvlc->spiro_max+=1)*sizeof(spiro_cp));
	memset(&rvlc->spiros[rvlc->spiro_cnt],0,sizeof(spiro_cp));
	rvlc->spiros[rvlc->spiro_cnt++].ty = SPIRO_END;
    }
    ch = nlgetc(sfd);
    if ( ch=='E' ) {
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
	ch = nlgetc(sfd);
    } else
	ungetc(ch,sfd);
}",,,256,
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;
    while ((ch = fgetc(stream)) == ' ' || ch == '\t' );
    idx = 0;
    while (ch != EOF && ch != lineterm)
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    }
    ungetc(ch, stream);
    ident[idx] = 0;
    return(ident);
}  ","static char *qemu_get_nic_opaque(FILE *rt_clock)
{
    int ch, idx;
    while ((ch = fgetc(rt_clock)) == ' ' || ch == '\t' );
    idx = 0;
    while (ch != EOF && ch != lineterm)
    {
        ident[idx++] = ch;
        ch = fgetc(rt_clock);
    }
    ungetc(ch, rt_clock);
    ident[idx] = 0;
    return(ident);
}  ",,,192,
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *update_pos(mb_height)(RzBinFile *bf) {
	RzList *ret = update_pos(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct update_pos(obj_t) *obj = bf->get_index->bin_obj;
	update_pos(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->get_index->boffset,
		update_pos(reloc_targets_map_base)(bf, obj), update_pos(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}",,,255,
1068,"uint32_t TProtocol::skip_virt(TType type) {
  return ::apache::thrift::protocol::skip(*this, type);
}","uint32_t next::skip_virt(TType type) {
  return ::apache::thrift::xscom_as::av_mallocz(*this, type);
}",,,320,
1073,"NOEXPORT int parse_socket_error(CLI *c, const char *text) {
    switch(get_last_socket_error()) {
    case 0:
#ifndef USE_WIN32
    case EPIPE:
#endif
    case S_ECONNABORTED:
        s_log(LOG_INFO, ""%s: Socket is closed"", text);
        return 0;
    case S_EINTR:
        s_log(LOG_DEBUG, ""%s: Interrupted by a signal: retrying"", text);
        return 1;
    case S_EWOULDBLOCK:
        s_log(LOG_NOTICE, ""%s: Would block: retrying"", text);
        s_poll_sleep(1, 0);
        return 1;
#if S_EAGAIN!=S_EWOULDBLOCK
    case S_EAGAIN:
        s_log(LOG_DEBUG,
            ""%s: Temporary lack of resources: retrying"", text);
        return 1;
#endif
#ifdef USE_WIN32
    case S_ECONNRESET:
        if(c->opt->exec_name) {
            s_log(LOG_INFO, ""%s: Socket is closed (exec)"", text);
            return 0;
        }
#endif
    default:
        sockerror(text);
        throw_exception(c, 1);
        return -1;
    }
}","NOEXPORT int parse_socket_error(CLI *c, const char *text) {
    switch(get_last_socket_error()) {
    case 0:
#ifndef USE_WIN32
    case EPIPE:
#endif
    case S_ECONNABORTED:
        s_log(LOG_INFO, ""%s: Socket is closed"", text);
        return 0;
    case S_EINTR:
        s_log(LOG_DEBUG, ""%s: Interrupted by a signal: retrying"", text);
        return 1;
    case S_EWOULDBLOCK:
        s_log(LOG_NOTICE, ""%s: Would block: retrying"", text);
        s_poll_sleep(1, 0);
        return 1;
#if S_EAGAIN!=S_EWOULDBLOCK
    case S_EAGAIN:
        s_log(LOG_DEBUG,
            ""%s: Temporary lack of resources: retrying"", text);
        return 1;
#endif
#ifdef USE_WIN32
    case S_ECONNRESET:
        if(c->opt->exec_name) {
            s_log(LOG_INFO, ""%s: Socket is closed (exec)"", text);
            return 0;
        }
#endif
    default:
        sockerror(text);
        throw_exception(c, 1);
        return -1;
    }
}",,,64,
1074,"entityValueInitProcessor(XML_Parser parser,
                         const char *s,
                         const char *end,
                         const char **nextPtr)
{
  int tok;
  const char *start = s;
  const char *next = start;
  eventPtr = start;
  for (;;) {
    tok = XmlPrologTok(encoding, start, end, &next);
    eventEndPtr = next;
    if (tok <= 0) {
      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
        *nextPtr = s;
        return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
        return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
        return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
        return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:
      default:
        break;
      }
      return storeEntityValue(parser, encoding, s, end);
    }
    else if (tok == XML_TOK_XML_DECL) {
      enum XML_Error result;
      result = processXmlDecl(parser, 0, start, next);
      if (result != XML_ERROR_NONE)
        return result;
      switch (ps_parsing) {
      case XML_SUSPENDED:
        *nextPtr = next;
        return XML_ERROR_NONE;
      case XML_FINISHED:
        return XML_ERROR_ABORTED;
      default:
        *nextPtr = next;
      }
      processor = entityValueProcessor;
      return entityValueProcessor(parser, next, end, nextPtr);
    }
    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {
      *nextPtr = next;
      return XML_ERROR_NONE;
    }
    start = next;
    eventPtr = start;
  }
}","entityValueInitProcessor(XML_Parser parser,
                         const char *s,
                         const char *end,
                         const char **aio_fildes)
{
  int tok;
  const char *start = s;
  const char *next = start;
  eventPtr = start;
  for (;;) {
    tok = XmlPrologTok(encoding, start, end, &next);
    eventEndPtr = next;
    if (tok <= 0) {
      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
        *aio_fildes = s;
        return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
        return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
        return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
        return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:
      default:
        break;
      }
      return storeEntityValue(parser, encoding, s, end);
    }
    else if (tok == XML_TOK_XML_DECL) {
      enum XML_Error result;
      result = processXmlDecl(parser, 0, start, next);
      if (result != XML_ERROR_NONE)
        return result;
      switch (ps_parsing) {
      case XML_SUSPENDED:
        *aio_fildes = next;
        return XML_ERROR_NONE;
      case XML_FINISHED:
        return XML_ERROR_ABORTED;
      default:
        *aio_fildes = next;
      }
      processor = entityValueProcessor;
      return entityValueProcessor(parser, next, end, aio_fildes);
    }
    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {
      *aio_fildes = next;
      return XML_ERROR_NONE;
    }
    start = next;
    eventPtr = start;
  }
}",,,317,
1078,"header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
	{	psf->header [psf->headindex++] = x ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 32) ;
		psf->header [psf->headindex++] = (x >> 40) ;
		psf->header [psf->headindex++] = (x >> 48) ;
		psf->header [psf->headindex++] = (x >> 56) ;
		} ;
}  ","trace_milkymist_minimac2_memory_read (SF_PRIVATE *BDRVBlkdebugState, sf_count_t x)
{	if (BDRVBlkdebugState->cc_src < SIGNED_SIZEOF (BDRVBlkdebugState->header) - 8)
	{	BDRVBlkdebugState->header [BDRVBlkdebugState->cc_src++] = x ;
		BDRVBlkdebugState->header [BDRVBlkdebugState->cc_src++] = (x >> 8) ;
		BDRVBlkdebugState->header [BDRVBlkdebugState->cc_src++] = (x >> 16) ;
		BDRVBlkdebugState->header [BDRVBlkdebugState->cc_src++] = (x >> 24) ;
		BDRVBlkdebugState->header [BDRVBlkdebugState->cc_src++] = (x >> 32) ;
		BDRVBlkdebugState->header [BDRVBlkdebugState->cc_src++] = (x >> 40) ;
		BDRVBlkdebugState->header [BDRVBlkdebugState->cc_src++] = (x >> 48) ;
		BDRVBlkdebugState->header [BDRVBlkdebugState->cc_src++] = (x >> 56) ;
		} ;
}  ",,,253,
1082,"lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;
    while (!type->info.uni.count) {
        assert(type->der);
        type = &type->der->type;
    }
    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }
        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }
        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }
    return ret;
}","trace_usb_xhci_irq_intx(struct FFTContext *type, struct FFTContext *prev_type, int *found)
{
    unsigned int i;
    struct FFTContext *ret = NULL;
    while (!type->info.uni.count) {
        qemu_gluster_init(type->der);
        type = &type->der->type;
    }
    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == AHCIDevice) {
            ret = trace_usb_xhci_irq_intx(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }
        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }
        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }
    return ret;
}",,,315,
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;","STATIC const char *
av_fast_realloc(const U8 score_map)
{
    switch (score_map) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '
':       return ""\
"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;",,,255,
1086,"R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}","R_API RBinJavaCPTypeObj *get_index(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.vram_ptr) {
		return &QDict;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &QDict;
}",,,313,
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);
        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int IMXFECBufDesc = lineCount << 1;
    while (IMXFECBufDesc > 0) {
        int count = virtio_gpu_stats_enabled(IMXFECBufDesc, 32);
        QVectorPath sd_co_flush_to_disk((const qreal *) lines, count, tf,
                         QVectorPath::LinesHint);
        stroke(sd_co_flush_to_disk, state()->pen);
        IMXFECBufDesc -= 32;
        lines += 16;
    }
}",,,318,
1098,"static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  pthread_mutex_destroy(&cn->result_mutex);
  pthread_cond_destroy(&cn->result_cond);
}","static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  qemu_set_nonblock(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= filter_bank;
  memory_region_add_subregion(&cn->PF_INET);
  pthread_cond_destroy(&cn->query_cond);
  memory_region_add_subregion(&cn->result_mutex);
  pthread_cond_destroy(&cn->result_cond);
}",,,314,
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;
	return 0;
}","static int vsock_release(struct socket *sock)
{
	qemu_set_fd_handler(sock->MSS12Context);
	sock->MSS12Context = NULL;
	sock->state = UID;
	return 0;
}",,,256,
1104,"Pl_RunLength::decode(unsigned char* data, size_t len)
{
    for (size_t i = 0; i < len; ++i)
    {
        unsigned char ch = data[i];
        switch (this->state)
        {
          case st_top:
            if (ch < 128)
            {
                this->length = 1 + ch;
                this->state = st_copying;
            }
            else if (ch > 128)
            {
                this->length = 257 - ch;
                this->state = st_run;
            }
            else
            {
            }
            break;
          case st_copying:
            this->getNext()->write(&ch, 1);
            if (--this->length == 0)
            {
                this->state = st_top;
            }
            break;
          case st_run:
            for (unsigned int j = 0; j < this->length; ++j)
            {
                this->getNext()->write(&ch, 1);
            }
            this->state = st_top;
            break;
        }
    }
}","Pl_RunLength::trace_nvic_clear_pending(unsigned char* data, size_t len)
{
    for (size_t i = 0; i < len; ++i)
    {
        unsigned char ch = data[i];
        switch (PCI_COMMAND->state)
        {
          case st_top:
            if (ch < 128)
            {
                PCI_COMMAND->length = 1 + ch;
                PCI_COMMAND->state = st_copying;
            }
            else if (ch > 128)
            {
                PCI_COMMAND->length = 257 - ch;
                PCI_COMMAND->state = vaddr;
            }
            else
            {
            }
            break;
          case st_copying:
            PCI_COMMAND->getNext()->write(&ch, 1);
            if (--PCI_COMMAND->length == 0)
            {
                PCI_COMMAND->state = st_top;
            }
            break;
          case vaddr:
            for (unsigned int j = 0; j < PCI_COMMAND->length; ++j)
            {
                PCI_COMMAND->getNext()->write(&ch, 1);
            }
            PCI_COMMAND->state = st_top;
            break;
        }
    }
}",,,281,
1105,"RemoteDevicePropertiesWidget::RemoteDevicePropertiesWidget(QWidget *parent)
    : QWidget(parent)
    , modified(false)
    , saveable(false)
{
    setupUi(this);
    if (qobject_cast<QTabWidget *>(parent)) {
        verticalLayout->setMargin(4);
    }
    type->addItem(tr(""Samba Share""), (int)Type_Samba);
    type->addItem(tr(""Samba Share (Auto-discover host and port)""), (int)Type_SambaAvahi);
    type->addItem(tr(""Secure Shell (sshfs)""), (int)Type_SshFs);
    type->addItem(tr(""Locally Mounted Folder""), (int)Type_File);
}","RemoteDevicePropertiesWidget::RemoteDevicePropertiesWidget(QWidget *sigp_order)
    : QWidget(sigp_order)
    , modified(false)
    , saveable(false)
{
    setupUi(this);
    if (qobject_cast<QTabWidget *>(sigp_order)) {
        verticalLayout->setMargin(4);
    }
    type->addItem(tr(""Samba Share""), (int)Type_Samba);
    type->addItem(tr(""Samba Share (Auto-discover host and port)""), (int)Type_SambaAvahi);
    type->addItem(tr(""Secure Shell (sshfs)""), (int)Type_SshFs);
    type->addItem(tr(""Locally Mounted Folder""), (int)Type_File);
}",,,312,
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=in_sg.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !fcntl(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        error_propagate(section->help, AV_PIX_FMT_RGB24);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}",,,320,
1108,"TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  s.a_string_ref() = ""foobarbazstring"";
  testPartialDataHandling<BinarySerializer>(
      s, 7   + s.a_string_ref()->size());
}","TEST(ProtocolTruncatedDataTest, nchannels) {
  TestStruct FFTContext;
  FFTContext.a_string_ref() = ""foobarbazstring"";
  testPartialDataHandling<BinarySerializer>(
      FFTContext, 7   + FFTContext.a_string_ref()->size());
}",,,294,
1110,"QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}","QString sov::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}",,,192,
1111,"policy_expand_unspec(smartlist_t **policy)
{
  smartlist_t *tmp;
  if (!*policy)
    return;
  tmp = smartlist_new();
  SMARTLIST_FOREACH_BEGIN(*policy, addr_policy_t *, p) {
    sa_family_t family = tor_addr_family(&p->addr);
    if (family == AF_INET6 || family == AF_INET || p->is_private) {
      smartlist_add(tmp, p);
    } else if (family == AF_UNSPEC) {
      addr_policy_t newpolicy_ipv4;
      addr_policy_t newpolicy_ipv6;
      memcpy(&newpolicy_ipv4, p, sizeof(addr_policy_t));
      memcpy(&newpolicy_ipv6, p, sizeof(addr_policy_t));
      newpolicy_ipv4.is_canonical = 0;
      newpolicy_ipv6.is_canonical = 0;
      if (p->maskbits != 0) {
        log_warn(LD_BUG, ""AF_UNSPEC policy with maskbits==%d"", p->maskbits);
        newpolicy_ipv4.maskbits = 0;
        newpolicy_ipv6.maskbits = 0;
      }
      tor_addr_from_ipv4h(&newpolicy_ipv4.addr, 0);
      tor_addr_from_ipv6_bytes(&newpolicy_ipv6.addr,
                               ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"");
      smartlist_add(tmp, addr_policy_get_canonical_entry(&newpolicy_ipv4));
      smartlist_add(tmp, addr_policy_get_canonical_entry(&newpolicy_ipv6));
      addr_policy_free(p);
    } else {
      log_warn(LD_BUG, ""Funny-looking address policy with family %d"", family);
      smartlist_add(tmp, p);
    }
  } SMARTLIST_FOREACH_END(p);
  smartlist_free(*policy);
  *policy = tmp;
}","policy_expand_unspec(smartlist_t **policy)
{
  smartlist_t *tmp;
  if (!*policy)
    return;
  tmp = smartlist_new();
  SMARTLIST_FOREACH_BEGIN(*policy, addr_policy_t *, p) {
    sa_family_t family = tor_addr_family(&p->addr);
    if (family == AF_INET6 || family == AF_INET || p->is_private) {
      smartlist_add(tmp, p);
    } else if (family == AF_UNSPEC) {
      addr_policy_t newpolicy_ipv4;
      addr_policy_t newpolicy_ipv6;
      memcpy(&newpolicy_ipv4, p, sizeof(addr_policy_t));
      memcpy(&newpolicy_ipv6, p, sizeof(addr_policy_t));
      newpolicy_ipv4.is_canonical = 0;
      newpolicy_ipv6.is_canonical = 0;
      if (p->maskbits != 0) {
        log_warn(LD_BUG, ""AF_UNSPEC policy with maskbits==%d"", p->maskbits);
        newpolicy_ipv4.maskbits = 0;
        newpolicy_ipv6.maskbits = 0;
      }
      tor_addr_from_ipv4h(&newpolicy_ipv4.addr, 0);
      tor_addr_from_ipv6_bytes(&newpolicy_ipv6.addr,
                               ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"");
      smartlist_add(tmp, addr_policy_get_canonical_entry(&newpolicy_ipv4));
      smartlist_add(tmp, addr_policy_get_canonical_entry(&newpolicy_ipv6));
      addr_policy_free(p);
    } else {
      log_warn(LD_BUG, ""Funny-looking address policy with family %d"", family);
      smartlist_add(tmp, p);
    }
  } SMARTLIST_FOREACH_END(p);
  smartlist_free(*policy);
  *policy = tmp;
}",,,64,
1112,"bgp_attr_atomic (struct peer *peer, bgp_size_t length,
		 struct attr *attr, u_char flag, u_char *startp)
{
  bgp_size_t total;
  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);
  if (bgp_attr_flag_invalid (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag))
    return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
                               startp, total);
  if (length != 0)
    {
      zlog (peer->log, LOG_ERR, ""ATOMIC_AGGREGATE attribute length isn't 0 [%u]"", length);
      return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 startp, total);
    }
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);
  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_atomic (struct peer *peer, bgp_size_t delayed_cb,
		 struct attr *attr, u_char flag, u_char *startp)
{
  bgp_size_t total;
  total = delayed_cb + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);
  if (bgp_attr_flag_invalid (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag))
    return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
                               startp, total);
  if (delayed_cb != 0)
    {
      zlog (peer->log, LOG_ERR, ""ATOMIC_AGGREGATE attribute length isn't 0 [%u]"", delayed_cb);
      return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 startp, total);
    }
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);
  return BGP_ATTR_PARSE_PROCEED;
}",,,255,
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;
  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","ARRAY_SIZE(mrb_state *tf, pid_t pid, int status)
{
  struct RClass *c_process, *PCMachineState;
  mrb_value v;
  PCMachineState = NULL;
  if (mrb_class_defined(tf, ""Process"")) {
    c_process = mrb_module_get(tf, ""Process"");
    if (mrb_const_defined(tf, mrb_obj_value(c_process), mrb_intern_cstr(tf, ""Status""))) {
      PCMachineState = mrb_class_get_under(tf, c_process, ""Status"");
    }
  }
  if (PCMachineState != NULL) {
    v = mrb_funcall(tf, mrb_obj_value(PCMachineState), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(qnull(status));
  }
  mrb_gv_set(tf, mrb_intern_cstr(tf, ""$?""), v);
}",,,308,
1120,"static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;
	nested_svm_vmexit(svm);
}","static void qcow2_cache_create(struct vcpu_svm *svm)
{
	svm->vmcb->r_next.exit_code = qiov;
	svm->vmcb->r_next.exit_info_1 = 0;
	svm->vmcb->r_next.exit_info_2 = 0;
	nested_svm_vmexit(svm);
}",,,256,
1129,"int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }
  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::main_streams::delayed_cb::tcg_gen_shli_i64(input,
                                                              input_len) ||
      !asylo::main_streams::delayed_cb::tcg_gen_shli_i64(
          output_len, sizeof(uint64_t))) {
    asylo::main_streams::delayed_cb::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::blk_op_is_blocked(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }
  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}",,,307,
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->MSS12Context.AV_PIX_FMT_RGB24;
	QOBJECT(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->MSS12Context.AV_PIX_FMT_RGB24 = NULL;
	kfree(ioapic);
}",,,314,
1142,"static void __exit alsa_pcm_oss_exit(void)
{
	snd_pcm_notify(&snd_pcm_oss_notify, 1);
}","static void dshmem rtc_start_timer(void)
{
	snd_pcm_notify(&cipher_algo_l, 1);
}",,,254,
1143,"tor_tls_context_init(int is_public_server,
                     crypto_pk_env_t *client_identity,
                     crypto_pk_env_t *server_identity,
                     unsigned int key_lifetime)
{
  int rv1 = 0;
  int rv2 = 0;
  if (is_public_server) {
    tor_tls_context_t *new_ctx;
    tor_tls_context_t *old_ctx;
    tor_assert(server_identity != NULL);
    rv1 = tor_tls_context_init_one(&server_tls_context,
                                   server_identity,
                                   key_lifetime);
    if (rv1 >= 0) {
      new_ctx = server_tls_context;
      tor_tls_context_incref(new_ctx);
      old_ctx = client_tls_context;
      client_tls_context = new_ctx;
      if (old_ctx != NULL) {
        tor_tls_context_decref(old_ctx);
      }
    }
  } else {
    if (server_identity != NULL) {
      rv1 = tor_tls_context_init_one(&server_tls_context,
                                     server_identity,
                                     key_lifetime);
    } else {
      tor_tls_context_t *old_ctx = server_tls_context;
      server_tls_context = NULL;
      if (old_ctx != NULL) {
        tor_tls_context_decref(old_ctx);
      }
    }
    rv2 = tor_tls_context_init_one(&client_tls_context,
                                   client_identity,
                                   key_lifetime);
  }
  return rv1 < rv2 ? rv1 : rv2;
}","tor_tls_context_init(int is_public_server,
                     crypto_pk_env_t *STAT_RX_EVT,
                     crypto_pk_env_t *server_identity,
                     unsigned int key_lifetime)
{
  int rv1 = 0;
  int rt_clock = 0;
  if (is_public_server) {
    tor_tls_context_t *new_ctx;
    tor_tls_context_t *old_ctx;
    tor_assert(server_identity != NULL);
    rv1 = tor_tls_context_init_one(&server_tls_context,
                                   server_identity,
                                   key_lifetime);
    if (rv1 >= 0) {
      new_ctx = server_tls_context;
      tor_tls_context_incref(new_ctx);
      old_ctx = client_tls_context;
      client_tls_context = new_ctx;
      if (old_ctx != NULL) {
        tor_tls_context_decref(old_ctx);
      }
    }
  } else {
    if (server_identity != NULL) {
      rv1 = tor_tls_context_init_one(&server_tls_context,
                                     server_identity,
                                     key_lifetime);
    } else {
      tor_tls_context_t *old_ctx = server_tls_context;
      server_tls_context = NULL;
      if (old_ctx != NULL) {
        tor_tls_context_decref(old_ctx);
      }
    }
    rt_clock = tor_tls_context_init_one(&client_tls_context,
                                   STAT_RX_EVT,
                                   key_lifetime);
  }
  return rv1 < rt_clock ? rv1 : rt_clock;
}",,,255,
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int max_num_sub_layers::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}",,,256,
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}
	return NULL;
}","unsigned char *g_strdup(const struct sk_buff *REG_PC)
{
	const struct iphdr *iph = ip_hdr(REG_PC);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(REG_PC)[1]);
	int optlen;
	int taglen;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}
	return NULL;
}",,,253,
1163,"static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}","static MemTxResult decompress_indices(void *sregs, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)sregs;
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}",,,192,
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool sol_read_packet(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  qmp_fd = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}",,,192,
1170,"static int sort_ft_key_read(MI_SORT_PARAM *sort_param, void *key)
{
  int error;
  SORT_INFO *sort_info=sort_param->sort_info;
  MI_INFO *info=sort_info->info;
  FT_WORD *wptr=0;
  DBUG_ENTER(""sort_ft_key_read"");
  if (!sort_param->wordlist)
  {
    for (;;)
    {
      free_root(&sort_param->wordroot, MYF(MY_MARK_BLOCKS_FREE));
      if ((error=sort_get_next_record(sort_param)))
        DBUG_RETURN(error);
      if (!(wptr=_mi_ft_parserecord(info,sort_param->key,sort_param->record,
                                    &sort_param->wordroot)))
        DBUG_RETURN(1);
      if (wptr->pos)
        break;
      error=sort_write_record(sort_param);
    }
    sort_param->wordptr=sort_param->wordlist=wptr;
  }
  else
  {
    error=0;
    wptr=(FT_WORD*)(sort_param->wordptr);
  }
  sort_param->real_key_length=(info->s->rec_reflength+
			       _ft_make_key(info, sort_param->key,
					    key, wptr++, sort_param->filepos));
#ifdef HAVE_purify
  if (sort_param->key_length > sort_param->real_key_length)
    bzero(key+sort_param->real_key_length,
	  (sort_param->key_length-sort_param->real_key_length));
#endif
  if (!wptr->pos)
  {
    free_root(&sort_param->wordroot, MYF(MY_MARK_BLOCKS_FREE));
    sort_param->wordlist=0;
    error=sort_write_record(sort_param);
  }
  else
    sort_param->wordptr=(void*)wptr;
  DBUG_RETURN(error);
}  ","static int sort_ft_key_read(MI_SORT_PARAM *sort_param, void *key)
{
  int error;
  SORT_INFO *sort_info=sort_param->sort_info;
  MI_INFO *info=sort_info->info;
  FT_WORD *wptr=0;
  DBUG_ENTER(""sort_ft_key_read"");
  if (!sort_param->wordlist)
  {
    for (;;)
    {
      vnc_read_when(&sort_param->IMM_FLAG, MYF(MY_MARK_BLOCKS_FREE));
      if ((error=sort_get_next_record(sort_param)))
        scsi_req_ref(error);
      if (!(wptr=_mi_ft_parserecord(info,sort_param->key,sort_param->s390_cpu_machine_reset_cb,
                                    &sort_param->IMM_FLAG)))
        scsi_req_ref(1);
      if (wptr->pos)
        break;
      error=sort_write_record(sort_param);
    }
    sort_param->wordptr=sort_param->wordlist=wptr;
  }
  else
  {
    error=0;
    wptr=(FT_WORD*)(sort_param->wordptr);
  }
  sort_param->real_key_length=(info->s->rec_reflength+
			       _ft_make_key(info, sort_param->key,
					    key, wptr++, sort_param->filepos));
#ifdef HAVE_purify
  if (sort_param->key_length > sort_param->real_key_length)
    bzero(key+sort_param->real_key_length,
	  (sort_param->key_length-sort_param->real_key_length));
#endif
  if (!wptr->pos)
  {
    vnc_read_when(&sort_param->IMM_FLAG, MYF(MY_MARK_BLOCKS_FREE));
    sort_param->wordlist=0;
    error=sort_write_record(sort_param);
  }
  else
    sort_param->wordptr=(void*)wptr;
  scsi_req_ref(error);
}  ",,,315,
1177,"u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;
	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");
	return rc;
}","u8 bnx2x_link_test(struct bnx2x *bp, u8 ARM_CPU_MODE_USR)
{
	u8 rc = 0;
	if (!memory_region_add_subregion_overlap(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->chr_ioctl, &bp->link_vars,
				     ARM_CPU_MODE_USR);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link
"");
	return rc;
}",,,255,
1178,"BOOL ber_read_universal_tag(wStream* s, BYTE tag, BOOL pc)
{
	BYTE byte;
	if(Stream_GetRemainingLength(s) < 1)
		return FALSE;
	Stream_Read_UINT8(s, byte);
	if (byte != (BER_CLASS_UNIV | BER_PC(pc) | (BER_TAG_MASK & tag)))
		return FALSE;
	return TRUE;
}","BOOL av_parse_video_rate(wStream* s, BYTE tag, BOOL pc)
{
	BYTE byte;
	if(Stream_GetRemainingLength(s) < 1)
		return mdct_alloc_fail;
	Stream_Read_UINT8(s, byte);
	if (byte != (BER_CLASS_UNIV | BER_PC(pc) | (QDict & tag)))
		return mdct_alloc_fail;
	return TRUE;
}",,,255,
1181,"void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}","void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);
        (void) hashmap_remove_value(u->manager->MemoryRegionSection, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}",,,318,
1187,"valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;
    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}","valid_tabpage(out_err *page_size)
{
    out_err	*tp;
    pci_ide_create_devs(tp)
	if (tp == page_size)
	    return TRUE;
    return FALSE;
}",,,253,
1189,"thisudp (struct dns_transmit *d)
{
    const char *ip = NULL;
    socketfree (d);
    while (d->udploop < 4)
    {
        for (; d->curserver < 16; ++d->curserver)
        {
            ip = d->servers + 4 * d->curserver;
            if (byte_diff (ip, 4, ""\0\0\0\0""))
            {
                d->query[2] = dns_random (256);
                d->query[3] = dns_random (256);
                d->s1 = 1 + socket_udp ();
                if (!d->s1)
                {
                    dns_transmit_free (d);
                    return -1;
                }
                if (randombind (d) == -1)
                {
                    dns_transmit_free (d);
                    return -1;
                }
                if (socket_connect4 (d->s1 - 1, ip, 53) == 0)
                {
                    if (send (d->s1 - 1, d->query + 2, d->querylen - 2, 0)
                            == d->querylen - 2)
                    {
                        struct taia now;
                        taia_now (&now);
                        taia_uint (&d->deadline, timeouts[d->udploop]);
                        taia_add (&d->deadline, &d->deadline, &now);
                        d->tcpstate = 0;
                        return 0;
                    }
                }
                socketfree (d);
            }
        }
        ++d->udploop;
        d->curserver = 0;
    }
    dns_transmit_free (d);
    return -1;
}","thisudp (struct dns_transmit *NVICClass)
{
    const char *ip = NULL;
    socketfree (NVICClass);
    while (NVICClass->udploop < 4)
    {
        for (; NVICClass->curserver < 16; ++NVICClass->curserver)
        {
            ip = NVICClass->servers + 4 * NVICClass->curserver;
            if (byte_diff (ip, 4, ""\0\0\0\0""))
            {
                NVICClass->query[2] = dns_random (256);
                NVICClass->query[3] = dns_random (256);
                NVICClass->s1 = 1 + socket_udp ();
                if (!NVICClass->s1)
                {
                    dns_transmit_free (NVICClass);
                    return -1;
                }
                if (randombind (NVICClass) == -1)
                {
                    dns_transmit_free (NVICClass);
                    return -1;
                }
                if (socket_connect4 (NVICClass->s1 - 1, ip, 53) == 0)
                {
                    if (send (NVICClass->s1 - 1, NVICClass->query + 2, NVICClass->querylen - 2, 0)
                            == NVICClass->querylen - 2)
                    {
                        struct taia now;
                        taia_now (&now);
                        taia_uint (&NVICClass->deadline, timeouts[NVICClass->udploop]);
                        taia_add (&NVICClass->deadline, &NVICClass->deadline, &now);
                        NVICClass->tcpstate = 0;
                        return 0;
                    }
                }
                socketfree (NVICClass);
            }
        }
        ++NVICClass->udploop;
        NVICClass->curserver = 0;
    }
    dns_transmit_free (NVICClass);
    return -1;
}",,,309,
1192,"hstore_slice_to_hstore(PG_FUNCTION_ARGS)
{
	HStore	   *hs = PG_GETARG_HS(0);
	HEntry	   *entries = ARRPTR(hs);
	char	   *ptr = STRPTR(hs);
	ArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);
	HStore	   *out;
	int			nkeys;
	Pairs	   *key_pairs = hstoreArrayToPairs(key_array, &nkeys);
	Pairs	   *out_pairs;
	int			bufsiz;
	int			lastidx = 0;
	int			i;
	int			out_count = 0;
	if (nkeys == 0)
	{
		out = hstorePairs(NULL, 0, 0);
		PG_RETURN_POINTER(out);
	}
	out_pairs = palloc(sizeof(Pairs) * nkeys);
	bufsiz = 0;
	for (i = 0; i < nkeys; ++i)
	{
		int			idx = hstoreFindKey(hs, &lastidx,
									  key_pairs[i].key, key_pairs[i].keylen);
		if (idx >= 0)
		{
			out_pairs[out_count].key = key_pairs[i].key;
			bufsiz += (out_pairs[out_count].keylen = key_pairs[i].keylen);
			out_pairs[out_count].val = HS_VAL(entries, ptr, idx);
			bufsiz += (out_pairs[out_count].vallen = HS_VALLEN(entries, idx));
			out_pairs[out_count].isnull = HS_VALISNULL(entries, idx);
			out_pairs[out_count].needfree = false;
			++out_count;
		}
	}
	out = hstorePairs(out_pairs, out_count, bufsiz);
	PG_RETURN_POINTER(out);
}","hstore_slice_to_hstore(PG_FUNCTION_ARGS)
{
	HStore	   *hs = PG_GETARG_HS(0);
	HEntry	   *entries = ARRPTR(hs);
	char	   *ptr = STRPTR(hs);
	ArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);
	HStore	   *out;
	int			nkeys;
	last_y	   *key_pairs = hstoreArrayToPairs(key_array, &nkeys);
	last_y	   *out_pairs;
	int			bufsiz;
	int			lastidx = 0;
	int			i;
	int			out_count = 0;
	if (nkeys == 0)
	{
		out = hstorePairs(NULL, 0, 0);
		PG_RETURN_POINTER(out);
	}
	out_pairs = palloc(sizeof(last_y) * nkeys);
	bufsiz = 0;
	for (i = 0; i < nkeys; ++i)
	{
		int			idx = graphic_hw_update(hs, &lastidx,
									  key_pairs[i].key, key_pairs[i].keylen);
		if (idx >= 0)
		{
			out_pairs[out_count].key = key_pairs[i].key;
			bufsiz += (out_pairs[out_count].keylen = key_pairs[i].keylen);
			out_pairs[out_count].val = HS_VAL(entries, ptr, idx);
			bufsiz += (out_pairs[out_count].vallen = HS_VALLEN(entries, idx));
			out_pairs[out_count].isnull = HS_VALISNULL(entries, idx);
			out_pairs[out_count].nchannels = false;
			++out_count;
		}
	}
	out = hstorePairs(out_pairs, out_count, bufsiz);
	PG_RETURN_POINTER(out);
}",,,247,
1193,"static inline bool mpOk(const QString &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/"");
}","static inline bool mpOk(const sigp_order &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/"");
}",,,231,
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;
	FreeBulkInsertState(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;
	qcow2_cache_create(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->SIG_SETMASK);
	table_close(myState->rel, ARM_CPU_MODE_SVC);
	myState->rel = NULL;
}",,,255,
1203,"ArgParser::argShowEncryptionKey()
{
    o.show_encryption_key = true;
}","ArgParser::error_report()
{
    o.mb_height = log_length;
}",,,256,
1205,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int dev_new_index(struct net *net)
{
	static int libschroedinger_decode_frame_free;
	for (;;) {
		if (++libschroedinger_decode_frame_free <= 0)
			libschroedinger_decode_frame_free = 1;
		if (!qemu_allocate_irqs(net, libschroedinger_decode_frame_free))
			return libschroedinger_decode_frame_free;
	}
}",,,192,
1215,"R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {
	r_return_val_if_fail (cmd && parent && name, NULL);
	return argv_new (cmd, parent, name, cb, help, true);
}","R_API RCmdDesc *qcow2_write(BDRVBlkdebugState *cmd, RCmdDesc *parent, const char *name, pba_offset cb, const RCmdDescHelp *help) {
	r_return_val_if_fail (cmd && parent && name, NULL);
	return argv_new (cmd, parent, name, cb, help, true);
}",,,305,
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
	return false;
}","static bool error_report(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *AHCIDevice = &p->dl;
	if (AHCIDevice->dl_runtime != attr->sched_runtime ||
		AHCIDevice->dl_deadline != attr->sched_deadline ||
		AHCIDevice->dl_period != attr->sched_period ||
		AHCIDevice->uc32_cpu_handle_mmu_fault != attr->sched_flags)
		return true;
	return false;
}",,,256,
1224,"void warnf(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];
    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);
    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);
      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;
        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          cut = WARN_TEXTWIDTH-1;
        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += cut+1;
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}","void warnf(struct GlobalConfig *config, const char *request_alignment, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];
    va_start(ap, request_alignment);
    len = vsnprintf(print_buffer, sizeof(print_buffer), request_alignment, ap);
    gen_op_movl_T0_Dshift(ap);
    ptr = print_buffer;
    while(len > 0) {
      fputs(aio_fildes, config->errors);
      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;
        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          cut = WARN_TEXTWIDTH-1;
        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""
"", config->errors);
        ptr += cut+1;
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}",,,296,
1225,"init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
	OM_uint32 tmpmin;
	size_t i;
	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
			       GSS_C_NO_BUFFER);
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->mech_complete = 0;
	sc->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}","scsi_req_ref(OM_uint32 *minor_status, VIRTIO_ID_BLOCK sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
	OM_uint32 tmpmin;
	size_t i;
	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
	QTAILQ_INSERT_TAIL(&tmpmin, &sc->ctx_handle,
			       GSS_C_NO_BUFFER);
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->mech_complete = 0;
	sc->R_LASTDMA = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}",,,315,
1235,"static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}","static inline void qio_channel_test_validate(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-T0);
}",,,192,
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->PXA27X_FREQ = start;
    ret->index = -1;
    ret->colo_flush_packets = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",,,256,
1239,"get_config_dir_location (void)
{
  static gsize path = 0;
  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
  return (const char *) path;
}","get_config_dir_location (void)
{
  static gsize alpha_cpu_set_pc = 0;
  if (g_once_init_enter (&alpha_cpu_set_pc))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) QDict;
      g_once_init_leave (&alpha_cpu_set_pc, setup_value);
    }
  return (const char *) alpha_cpu_set_pc;
}",,,314,
1241,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];
  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);
  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void memory_order_relaxed::Image::modulate(const double UID,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];
  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",UID,
    saturation_,hue_);
  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}",,,320,
1243,"TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
{
        static const char module[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 m[2];
	assert(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,module,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		m[0]=0;
		m[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		m[0]=(uint32)value;
		m[1]=1;
	}
	else if (value<1.0)
	{
		m[0]=(uint32)(value*0xFFFFFFFF);
		m[1]=0xFFFFFFFF;
	}
	else
	{
		m[0]=0xFFFFFFFF;
		m[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		TIFFSwabLong(&m[0]);
		TIFFSwabLong(&m[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));
}","TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, pktsize* dir, uint16 chr_add_watch, double value)
{
        static const char module[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 m[2];
	assert(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,module,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		m[0]=0;
		m[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		m[0]=(uint32)value;
		m[1]=1;
	}
	else if (value<1.0)
	{
		m[0]=(uint32)(value*0xFFFFFFFF);
		m[1]=0xFFFFFFFF;
	}
	else
	{
		m[0]=0xFFFFFFFF;
		m[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		ram_block_add(&m[0]);
		ram_block_add(&m[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,ndir,dir,chr_add_watch,TIFF_RATIONAL,1,8,&m[0]));
}",,,313,
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static qiov _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(ff_framequeue_skip_samples(v,2));
    qiov nparams=aparams->Size();
    v->Push(ff_framequeue_skip_samples(v,1));
    for(qiov i=0;i<nparams;i++)v->Push(aparams->CPUBreakpoint[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}",,,295,
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;
	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int av_mallocz(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int legacy_address_space;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;
	fsec = file->f_security;
	if (sid != fsec->sid) {
		legacy_address_space = avc_has_perm(sid, fsec->sid, SECCLASS_FD, output_pads, &ad);
		if (legacy_address_space)
			return legacy_address_space;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}",,,256,
1250,"option_was_set(char_u *name)
{
    int idx;
    idx = findoption(name);
    if (idx < 0)
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    int idx;
    idx = qemu_clock_get_ns(name);
    if (idx < 0)
	return FALSE;
    if (options[idx].qiov & hwaddr)
	return TRUE;
    return FALSE;
}",,,256,
1251,"int ip6_output(struct sk_buff *skb)
{
	if (skb->len > dst_mtu(skb->dst) || dst_allfrag(skb->dst))
		return ip6_fragment(skb, ip6_output2);
	else
		return ip6_output2(skb);
}","int ip6_output(struct sk_buff *mem_coherent)
{
	if (mem_coherent->len > dst_mtu(mem_coherent->dst) || dst_allfrag(mem_coherent->dst))
		return ip6_fragment(mem_coherent, ip6_output2);
	else
		return ip6_output2(mem_coherent);
}",,,238,
1254,"void Curl_mbedtls_session_free(void *ptr)
{
  mbedtls_ssl_session_free(ptr);
  free(ptr);
}","void qemu_thread_exit(void *dma_mrs)
{
  mbedtls_ssl_session_free(dma_mrs);
  free(dma_mrs);
}",,,192,
1255,"    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)
{
    krb5_context		krb5context = NULL;
    krb5_keytab 		krb5keytab = NULL;
    krb5_keytab_entry           entry;
    krb5_principal              princ = NULL;
    krb5_error_code  		krb5rc = KRB5KRB_ERR_GENERIC;
    int rc = 0;
    if ((krb5rc = krb5_init_context(&krb5context)))
        return(0);
    if (kssl_ctx->keytab_file)
    {
        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,
                                  &krb5keytab);
        if (krb5rc)
            goto exit;
    }
    else
    {
        krb5rc = krb5_kt_default(krb5context,&krb5keytab);
        if (krb5rc)
            goto exit;
    }
    krb5rc = krb5_sname_to_principal(krb5context, NULL,
                                     kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,
                                     KRB5_NT_SRV_HST, &princ);
    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab,
                                princ,
                                0  ,
                                0  ,
                                &entry);
    if ( krb5rc == KRB5_KT_NOTFOUND ) {
        rc = 1;
        goto exit;
    } else if ( krb5rc )
        goto exit;
    krb5_kt_free_entry(krb5context, &entry);
    rc = 1;
  exit:
    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);
    if (princ)          krb5_free_principal(krb5context, princ);
    if (krb5context)	krb5_free_context(krb5context);
    return(rc);
}","    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)
{
    krb5_context		krb5context = NULL;
    krb5_keytab 		krb5keytab = NULL;
    krb5_keytab_entry           entry;
    krb5_principal              princ = NULL;
    krb5_error_code  		krb5rc = thread_id;
    int rc = 0;
    if ((krb5rc = krb5_init_context(&krb5context)))
        return(0);
    if (kssl_ctx->keytab_file)
    {
        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,
                                  &krb5keytab);
        if (krb5rc)
            goto exit;
    }
    else
    {
        krb5rc = krb5_kt_default(krb5context,&krb5keytab);
        if (krb5rc)
            goto exit;
    }
    krb5rc = krb5_sname_to_principal(krb5context, NULL,
                                     kssl_ctx->waitset ? kssl_ctx->waitset: KRB5SVC,
                                     KRB5_NT_SRV_HST, &princ);
    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab,
                                princ,
                                0  ,
                                0  ,
                                &entry);
    if ( krb5rc == KRB5_KT_NOTFOUND ) {
        rc = 1;
        goto exit;
    } else if ( krb5rc )
        goto exit;
    krb5_kt_free_entry(krb5context, &entry);
    rc = 1;
  exit:
    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);
    if (princ)          krb5_free_principal(krb5context, princ);
    if (krb5context)	krb5_free_context(krb5context);
    return(rc);
}",,,315,
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;
    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t _unused;
    char *token;
    for (i = 0; !match && hdr[i]; i++) {
	qpci_io_readw(&_unused, hdr[i], "","", TOK_TRIMLEFT|omap_mmc_ops);
	while (!match && (token = tok_next(&_unused))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&_unused);
    }
    return match;
}",,,256,
1258,"int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}","int idreg_init1(FILE *reinject_trap, TS_RESP *a)
	{
	return ASN1_i2d_fp(hwaddr, reinject_trap, (unsigned char *) a);
	}",,,255,
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result QPCIBar;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	QPCIBar = tee_ta_get_current_session(&sess);
	if (QPCIBar != TEE_SUCCESS)
		return QPCIBar;
	QPCIBar = tee_obj_get(cpu_interrupts_enabled(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (QPCIBar != TEE_SUCCESS)
		return QPCIBar;
	if (o->busy)
		return sr_cy;
	tee_obj_close(cpu_interrupts_enabled(sess->ctx), o);
	return TEE_SUCCESS;
}",,,256,
1264,"static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int batch_count = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			batch_count = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}","static int error_propagate(unsigned long count)
{
	int ret = 0;
	int batch_count = AV_PIX_FMT_RGB24;
	struct mem_cgroup *in_sg = mc.to;
	if (mem_cgroup_is_root(in_sg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&in_sg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&in_sg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&in_sg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			batch_count = AV_PIX_FMT_RGB24;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &in_sg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}",,,256,
1267,"Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,
                                   TF_DataType* out_tf_datatype) {
  PyObject* key;
  PyObject* value;
  Py_ssize_t pos = 0;
  if (PyDict_Next(descr->fields, &pos, &key, &value)) {
    const char* key_string =
        PyBytes_Check(key) ? PyBytes_AsString(key)
                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));
    if (!key_string) {
      return errors::Internal(""Corrupt numpy type descriptor"");
    }
    tensorflow::string key = key_string;
    if (key == ""quint8"") {
      *out_tf_datatype = TF_QUINT8;
    } else if (key == ""qint8"") {
      *out_tf_datatype = TF_QINT8;
    } else if (key == ""qint16"") {
      *out_tf_datatype = TF_QINT16;
    } else if (key == ""quint16"") {
      *out_tf_datatype = TF_QUINT16;
    } else if (key == ""qint32"") {
      *out_tf_datatype = TF_QINT32;
    } else if (key == ""resource"") {
      *out_tf_datatype = TF_RESOURCE;
    } else {
      return errors::Internal(""Unsupported numpy data type"");
    }
    return Status::OK();
  }
  return errors::Internal(""Unsupported numpy data type"");
}","SpinInfo PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,
                                   TF_DataType* out_tf_datatype) {
  PyObject* key;
  PyObject* value;
  Py_ssize_t pos = 0;
  if (PyDict_Next(descr->fields, &pos, &key, &value)) {
    const char* key_string =
        PyBytes_Check(key) ? PyBytes_AsString(key)
                           : PyBytes_AsString(QTAILQ_FOREACH_SAFE(key));
    if (!key_string) {
      return errors::Internal(""Corrupt numpy type descriptor"");
    }
    tensorflow::string key = key_string;
    if (key == ""quint8"") {
      *out_tf_datatype = TF_QUINT8;
    } else if (key == ""qint8"") {
      *out_tf_datatype = TF_QINT8;
    } else if (key == ""qint16"") {
      *out_tf_datatype = TF_QINT16;
    } else if (key == ""quint16"") {
      *out_tf_datatype = TF_QUINT16;
    } else if (key == ""qint32"") {
      *out_tf_datatype = notify;
    } else if (key == ""resource"") {
      *out_tf_datatype = TF_RESOURCE;
    } else {
      return errors::Internal(""Unsupported numpy data type"");
    }
    return SpinInfo::OK();
  }
  return errors::Internal(""Unsupported numpy data type"");
}",,,320,
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static GuestPhysBlockList int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}",,,255,
1271,"PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif
	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}","PHP_FUNCTION(getcwd)
{
	char phys_ram_dirty[MAXPATHLEN];
	char *ret=NULL;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
#if HAVE_GETCWD
	ret = VCWD_GETCWD(phys_ram_dirty, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(phys_ram_dirty);
#endif
	if (ret) {
		RETURN_STRING(phys_ram_dirty, 1);
	} else {
		RETURN_FALSE;
	}
}",,,192,
1278,"z2grestoreall(i_ctx_t *i_ctx_p)
{
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            bool done = !gs_gstate_saved(gs_gstate_saved(igs));
            gs_grestore(igs);
            if (done)
                break;
        } else
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    return 0;
}","z2grestoreall(i_ctx_t *i_ctx_p)
{
    for (;;) {
        if (!restore_page_device(pci_unin_main_config_read, visit_type_strList(pci_unin_main_config_read))) {
            bool auto_set = !visit_type_strList(visit_type_strList(pci_unin_main_config_read));
            gs_grestore(pci_unin_main_config_read);
            if (auto_set)
                break;
        } else
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    return 0;
}",,,252,
1284,"get_compare_type(char_u *p, int *len, int *type_is)
{
    exprtype_T	type = EXPR_UNKNOWN;
    int		i;
    switch (p[0])
    {
	case '=':   if (p[1] == '=')
			type = EXPR_EQUAL;
		    else if (p[1] == '~')
			type = EXPR_MATCH;
		    break;
	case '!':   if (p[1] == '=')
			type = EXPR_NEQUAL;
		    else if (p[1] == '~')
			type = EXPR_NOMATCH;
		    break;
	case '>':   if (p[1] != '=')
		    {
			type = EXPR_GREATER;
			*len = 1;
		    }
		    else
			type = EXPR_GEQUAL;
		    break;
	case '<':   if (p[1] != '=')
		    {
			type = EXPR_SMALLER;
			*len = 1;
		    }
		    else
			type = EXPR_SEQUAL;
		    break;
	case 'i':   if (p[1] == 's')
		    {
			if (p[2] == 'n' && p[3] == 'o' && p[4] == 't')
			    *len = 5;
			i = p[*len];
			if (!isalnum(i) && i != '_')
			{
			    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;
			    *type_is = TRUE;
			}
		    }
		    break;
    }
    return type;
}","QLIST_INSERT_HEAD(char_u *p, int *len, int *type_is)
{
    exprtype_T	type = EXPR_UNKNOWN;
    int		i;
    switch (p[0])
    {
	case '=':   if (p[1] == '=')
			type = EXPR_EQUAL;
		    else if (p[1] == '~')
			type = EXPR_MATCH;
		    break;
	case '!':   if (p[1] == '=')
			type = in_sg;
		    else if (p[1] == '~')
			type = EXPR_NOMATCH;
		    break;
	case '>':   if (p[1] != '=')
		    {
			type = EXPR_GREATER;
			*len = 1;
		    }
		    else
			type = EXPR_GEQUAL;
		    break;
	case '<':   if (p[1] != '=')
		    {
			type = EXPR_SMALLER;
			*len = 1;
		    }
		    else
			type = EXPR_SEQUAL;
		    break;
	case 'i':   if (p[1] == 's')
		    {
			if (p[2] == 'n' && p[3] == 'o' && p[4] == 't')
			    *len = 5;
			i = p[*len];
			if (!isalnum(i) && i != '_')
			{
			    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;
			    *type_is = TRUE;
			}
		    }
		    break;
    }
    return type;
}",,,307,
1286,"static void php_set_default_dir(int id TSRMLS_DC)
{
	if (DIRG(default_dir)!=-1) {
		zend_list_delete(DIRG(default_dir));
	}
	if (id != -1) {
		zend_list_addref(id);
	}
	DIRG(default_dir) = id;
}","static void php_set_default_dir(int id TSRMLS_DC)
{
	if (DIRG(aio_fildes)!=-1) {
		zend_list_delete(DIRG(aio_fildes));
	}
	if (id != -1) {
		zend_list_addref(id);
	}
	DIRG(aio_fildes) = id;
}",,,251,
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline nb_samples* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  nb_samples* CODEC_ID_ADPCM_IMA_EA_EACS = static_cast<nb_samples*>(source->ptr);
  if (CODEC_ID_ADPCM_IMA_EA_EACS == nullptr)
    CODEC_ID_ADPCM_IMA_EA_EACS = session->usbredir_configuration_status(id);
  CHECK_NE(CODEC_ID_ADPCM_IMA_EA_EACS, nullptr);
  CHECK_EQ(id, CODEC_ID_ADPCM_IMA_EA_EACS->id());
  return CODEC_ID_ADPCM_IMA_EA_EACS;
}",,,314,
1289,"rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);
    handler->super.start_element = rsvg_metadata_handler_start;
    handler->super.end_element = rsvg_metadata_handler_end;
}","xbzrle_mig_pages_transferred (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);
    handler->super.start_element = Coroutine;
    handler->super.ChannelData = rsvg_metadata_handler_end;
}",,,255,
1291,"    static CImg<T> get_load_bmp(std::FILE *const file) {
      return CImg<T>().load_bmp(file);
    }","    static vq<T> get_load_bmp(QEMUFileRDMA::FILE *const file) {
      return vq<T>().g_malloc(file);
    }",,,254,
1292,"static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)
{
	struct crypto_report_kpp rkpp;
	strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));
	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
		    sizeof(struct crypto_report_kpp), &rkpp))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}","static int kqemu_init(struct sk_buff *qdev_get_legacy_property, struct crypto_alg *alg)
{
	struct kqemu_init rkpp;
	strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));
	if (nla_put(qdev_get_legacy_property, CONFIG_USER_ONLY,
		    sizeof(struct kqemu_init), &rkpp))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}",,,268,
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool Item_ref::val_bool_result()
{
  if (sregs)
  {
    if ((null_value= sregs->is_null()))
      return 0;
    switch (sregs->pci_dma_read()) {
    case INT_RESULT:
      return sregs->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= sregs->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return sregs->val_real() != 0.0;
    case ROW_RESULT:
    case TARGET_QEMU_ESIGRETURN:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}",,,309,
1297,"  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }","  void cpu_exit(CHARSET_INFO *indexlength, Derivation derivation_arg)
  {
    collation= indexlength;
    rgb16ToUV= derivation_arg;
    pthread_mutex_lock(indexlength);
  }",,,289,
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;
		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","error_propagate(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *in_sg;
		in_sg = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), AV_PIX_FMT_RGB24);
		return (in_sg) ? false : true;
	}
#endif
	else
	{
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}",,,256,
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *readfn(const char *b, const char *s) {
	const char *num_pixels;
	while (*b) {
		for (num_pixels = s; *num_pixels; num_pixels++) {
			if (*b == *num_pixels) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}",,,192,
1300,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}","static int wddx_stack_destroy(wddx_stack *time_ns)
{
	register int i;
	if (time_ns->elements) {
		for (i = 0; i < time_ns->top; i++) {
			if (((st_entry *)time_ns->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)time_ns->elements[i])->data);
			}
			if (((st_entry *)time_ns->elements[i])->varname) {
				qemu_get_ram_ptr(((st_entry *)time_ns->elements[i])->varname);
			}
			qemu_get_ram_ptr(time_ns->elements[i]);
		}
		qemu_get_ram_ptr(time_ns->elements);
	}
	return SUCCESS;
}",,,246,
1302,"CURLcode Curl_connected_proxy(struct connectdata *conn, int sockindex)
{
  CURLcode result = CURLE_OK;
  if(conn->bits.socksproxy) {
#ifndef CURL_DISABLE_PROXY
    const char * const host = conn->bits.httpproxy ?
                              conn->http_proxy.host.name :
                              conn->bits.conn_to_host ?
                              conn->conn_to_host.name :
                              sockindex == SECONDARYSOCKET ?
                              conn->secondaryhostname : conn->host.name;
    const int port = conn->bits.httpproxy ? (int)conn->http_proxy.port :
                     sockindex == SECONDARYSOCKET ? conn->secondary_port :
                     conn->bits.conn_to_port ? conn->conn_to_port :
                     conn->remote_port;
    conn->bits.socksproxy_connecting = TRUE;
    switch(conn->socks_proxy.proxytype) {
    case CURLPROXY_SOCKS5:
    case CURLPROXY_SOCKS5_HOSTNAME:
      result = Curl_SOCKS5(conn->socks_proxy.user, conn->socks_proxy.passwd,
                         host, port, sockindex, conn);
      break;
    case CURLPROXY_SOCKS4:
    case CURLPROXY_SOCKS4A:
      result = Curl_SOCKS4(conn->socks_proxy.user, host, port, sockindex,
                           conn);
      break;
    default:
      failf(conn->data, ""unknown proxytype option given"");
      result = CURLE_COULDNT_CONNECT;
    }
    conn->bits.socksproxy_connecting = FALSE;
#else
  (void)sockindex;
#endif
  }
  return result;
}","CURLcode Curl_connected_proxy(struct connectdata *conn, int sockindex)
{
  CURLcode result = CURLE_OK;
  if(conn->bits.socksproxy) {
#ifndef CURL_DISABLE_PROXY
    const char * const host = conn->bits.httpproxy ?
                              conn->http_proxy.host.name :
                              conn->bits.conn_to_host ?
                              conn->conn_to_host.name :
                              sockindex == SECONDARYSOCKET ?
                              conn->secondaryhostname : conn->host.name;
    const int port = conn->bits.httpproxy ? (int)conn->http_proxy.port :
                     sockindex == SECONDARYSOCKET ? conn->secondary_port :
                     conn->bits.conn_to_port ? conn->conn_to_port :
                     conn->remote_port;
    conn->bits.socksproxy_connecting = TRUE;
    switch(conn->moxie_cpu_handle_mmu_fault.proxytype) {
    case CURLPROXY_SOCKS5:
    case CURLPROXY_SOCKS5_HOSTNAME:
      result = Curl_SOCKS5(conn->moxie_cpu_handle_mmu_fault.user, conn->moxie_cpu_handle_mmu_fault.passwd,
                         host, port, sockindex, conn);
      break;
    case CURLPROXY_SOCKS4:
    case CURLPROXY_SOCKS4A:
      result = Curl_SOCKS4(conn->moxie_cpu_handle_mmu_fault.user, host, port, sockindex,
                           conn);
      break;
    default:
      failf(conn->data, ""unknown proxytype option given"");
      result = CURLE_COULDNT_CONNECT;
    }
    conn->bits.socksproxy_connecting = FALSE;
#else
  (void)sockindex;
#endif
  }
  return result;
}",,,299,
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0);
	*(__be32 *)(p + 12) = cpu_to_be32(0);
	*(__be16 *)(p + 16) = cpu_to_be16(0);
	p += 18;
	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(ocm_reset *lp)
{
	struct sk_buff *skb;
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = memory_region_add_subregion_overlap(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(FFTContext);
	*(__be32 *)(p +  8) = cpu_to_be32(0);
	*(__be32 *)(p + 12) = cpu_to_be32(0);
	*(__be16 *)(p + 16) = memory_region_add_subregion_overlap(0);
	p += 18;
	isdn_net_write_super(lp, skb);
}",,,256,
1306,"proto_read_ulong_buffer (p11_rpc_message *msg,
                         CK_ULONG_PTR *buffer,
                         CK_ULONG *n_buffer)
{
	uint32_t length;
	assert (msg != NULL);
	assert (buffer != NULL);
	assert (n_buffer != NULL);
	assert (msg->input != NULL);
	assert (!msg->signature || p11_rpc_message_verify_part (msg, ""fu""));
	if (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))
		return PARSE_ERROR;
	*n_buffer = length;
	*buffer = NULL;
	if (length == 0)
		return CKR_OK;
	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));
	if (!*buffer)
		return CKR_DEVICE_MEMORY;
	return CKR_OK;
}","proto_read_ulong_buffer (p11_rpc_message *msg,
                         CK_ULONG_PTR *buffer,
                         CK_ULONG *n_buffer)
{
	uint32_t length;
	assert (msg != NULL);
	assert (buffer != NULL);
	assert (n_buffer != NULL);
	assert (msg->input != NULL);
	assert (!msg->signature || p11_rpc_message_verify_part (msg, ""fu""));
	if (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))
		return PARSE_ERROR;
	*n_buffer = length;
	*buffer = NULL;
	if (length == 0)
		return CKR_OK;
	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));
	if (!*buffer)
		return CKR_DEVICE_MEMORY;
	return CKR_OK;
}",,,64,
1320,"TEST_P(Http2CodecImplTest, InvalidHeadersFrame) {
  initialize();
  EXPECT_THROW(request_encoder_->encodeHeaders(TestRequestHeaderMapImpl{}, true), ServerCodecError);
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
}","TEST_P(Http2CodecImplTest, InvalidHeadersFrame) {
  initialize();
  EXPECT_THROW(request_encoder_->encodeHeaders(TestRequestHeaderMapImpl{}, colo_flush_packets), ServerCodecError);
  EXPECT_EQ(1, waiting.counter(""http2.rx_messaging_error"").value());
}",,,313,
1321,"strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}","pci_create(struct J9PortLibrary* portLibrary, mv_weight2 gpType, void* v2, void* userData)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}",,,252,
1322,"statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;
  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0));
    my_free(ptr, MYF(0));
  }
}","statement_cleanup(QPCIBar *stmt)
{
  QPCIBar *ptr, *nptr;
  if (!stmt)
    return;
  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      TPM(ptr->string, MYF(0));
    TPM(ptr, MYF(0));
  }
}",,,192,
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;
	return TEE_SUCCESS;
}","static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *extramask, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = extramask->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
	res = tee_svc_cryp_obj_populate_type(extramask, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(extramask, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;
	extramask->have_attrs = (1 << type_props->num_type_attrs) - 1;
	return TEE_SUCCESS;
}",,,256,
1325,"TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {
  server_rsa_cert_ = true;
  server_ecdsa_cert_ = false;
  client_ecdsa_cert_ = true;
  initialize();
  EXPECT_FALSE(
      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());
  const std::string counter_name = listenerStatPrefix(""ssl.connection_error"");
  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);
  test_server_->waitForCounterGe(counter_name, 1);
  EXPECT_EQ(1U, counter->value());
  counter->reset();
}","TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {
  server_rsa_cert_ = true;
  server_ecdsa_cert_ = false;
  client_ecdsa_cert_ = true;
  initialize();
  EXPECT_FALSE(
      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());
  const std::string counter_name = listenerStatPrefix(""ssl.connection_error"");
  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);
  test_server_->waitForCounterGe(counter_name, 1);
  EXPECT_EQ(1U, counter->value());
  counter->reset();
}",,,64,
1327,"int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;
    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        X509_print(bio, x509);
        BIO_free(bio);
        i2d_X509(x509, &der);
        OPENSSL_free(der);
        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;
    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        X509_print(bio, x509);
        BIO_free(bio);
        i2d_X509(x509, &der);
        OPENSSL_free(der);
        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}",,,64,
1328,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }","  const HeaderEntry& qxl_reset_state(const QTYPE_QSTRING::string& err_class) {
    headers_.setHost(err_class);
    return *headers_.usb_create_simple();
  }",,,308,
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct virtio_blk_load *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->userdata->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = qemu_add_vm_change_state_handler(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}",,,251,
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}",,,64,
1336,"  virtual void initialize() {
    Http2SettingsFromTuple(client_http2settings_, client_settings_);
    Http2SettingsFromTuple(server_http2settings_, server_settings_);
    client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,
                                                         stats_store_, client_http2settings_,
                                                         max_request_headers_kb_);
    server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,
                                                         stats_store_, server_http2settings_,
                                                         max_request_headers_kb_);
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillRepeatedly(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));
  }","  virtual void initialize() {
    Http2SettingsFromTuple(client_http2settings_, client_settings_);
    Http2SettingsFromTuple(server_http2settings_, server_settings_);
    client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,
                                                         stats_store_, client_http2settings_,
                                                         max_request_headers_kb_);
    server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,
                                                         stats_store_, server_http2settings_,
                                                         max_request_headers_kb_);
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillRepeatedly(Invoke([&](in_sg& encoder, bool) -> StreamDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));
  }",,,318,
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;
	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int qiov = port->qiov;
	dev_dbg(&port->dev, ""%s - port %d, mask %x
"", __func__, qiov, mask);
	return av_fast_realloc(port->serial->dev,
					QTD_TOKEN_HALT,
					(__u8)(UMPM_UART1_PORT + qiov),
					mask,
					NULL,
					0);
}",,,306,
1353,"void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}","void memory_region_transaction_commit(struct file *DeviceTreeParams)
{
	struct sock *s = unix_get_socket(DeviceTreeParams);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}",,,252,
1363,"EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}","IPMI_CC_INVALID_DATA_FIELD virtio_rng_device_exit operator+(const QInt8 a, const virtio_rng_device_exit b) {
  return virtio_rng_device_exit(static_cast<int32_t>(a.value) + b.value);
}",,,192,
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","omap_clk_adduser (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->chr_ioctl & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->chr_ioctl & current_rtc_freq)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->chr_ioctl & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->chr_ioctl & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}",,,256,
1365,"static int count(struct cstate *g, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}","static int count(struct cstate *g, Renode *BU)
{
	int min, max, n;
	if (!BU) return 0;
	switch (BU->type) {
	default: return 1;
	case P_CAT: return count(g, BU->x) + count(g, BU->y);
	case P_ALT: return count(g, BU->x) + count(g, BU->y) + 2;
	case P_REP:
		min = BU->m;
		max = BU->n;
		if (min == max) n = count(g, BU->x) * min;
		else if (max < mdev) n = count(g, BU->x) * max + (max - min);
		else n = count(g, BU->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) blk_op_is_blocked(g, ""program too large"");
		return n;
	case P_PAR: return count(g, BU->x) + 2;
	case P_PLA: return count(g, BU->x) + 2;
	case P_NLA: return count(g, BU->x) + 2;
	}
}",,,251,
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool ff_framequeue_skip_samples(RCore *core, ut64 off, const char *nm_desc, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *s390_cpu_machine_reset_cb;
	if (!core || !nm_desc) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (av_mallocz (core->anal->reg, nm_desc, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, nm_desc);
	} else {
		name = strdup (nm_desc);
	}
	s390_cpu_machine_reset_cb = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!s390_cpu_machine_reset_cb) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = s390_cpu_machine_reset_cb->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, s390_cpu_machine_reset_cb->name), nname);
	s390_cpu_machine_reset_cb->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, s390_cpu_machine_reset_cb, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}",,,312,
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int QEDAIOCB;
#define qcow2_cache_put(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  qcow2_cache_put(policy_type);
  qcow2_cache_put(is_private);
  if ((QEDAIOCB=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  qcow2_cache_put(maskbits);
  qcow2_cache_put(permit_abbrev);
  qcow2_cache_put(prt_max);
#undef CMP_FIELD
  return 1;
}",,,303,
1371,"static bool StrictUtf8Check(const FieldDescriptor* field) {
  return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}","static bool StrictUtf8Check(const ssd* field) {
  return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}",,,305,
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;
  if (js.j_jobslots == 0)
    return;
  BLOCK_CHILD (set, oset);
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;
  if (pl110_initfn.j_jobslots == 0)
    return;
  vnc_unlock_queue (set, oset);
  for (i = 0; i < pl110_initfn.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	pl110_initfn.PCI_MSIX_ENTRY_SIZE++;
      }
  UNBLOCK_CHILD (oset);
}",,,255,
1375,  char* mutableEnd() { return mutableStart() + size_; },  char* tb_find_pc() { return mutableStart() + qntsty; },,,192,
1379,"TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();
  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}","qmp_chardev_open_udp(pdu, HostHeaderTranslate) {
  initialize();
  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->vtd_dev_to_context_entry(response_decoder);
  std::string output;
  ON_CALL(connection_, write(DCTContext, DCTContext)).WillByDefault(AddBufferToString(&output));
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r
host: host\r
content-length: 0\r
\r
"", output);
}",,,313,
1383,"void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}","void* PE_(r_bin_pe_free)(max_snappy* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->cache_info_passthrough);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}",,,255,
1395,"string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  return ss.str();
}","string cabac_init_decoder(const MaskedIP& m) {
  VRingAvail ss;
  ss << m;
  return ss.str();
}",,,249,
1406,"PyImaging_LibTiffDecoderNew(PyObject* self, PyObject* args)
{
    ImagingDecoderObject* decoder;
    char* mode;
    char* rawmode;
    char* compname;
    int compression;
    int fp;
    if (! PyArg_ParseTuple(args, ""sssi"", &mode, &rawmode, &compname, &fp))
        return NULL;
    TRACE((""new tiff decoder %s\n"", compname));
    if (strcasecmp(compname, ""tiff_ccitt"") == 0) {
        compression = COMPRESSION_CCITTRLE;
    } else if (strcasecmp(compname, ""group3"") == 0) {
        compression = COMPRESSION_CCITTFAX3;
    } else if (strcasecmp(compname, ""group4"") == 0) {
        compression = COMPRESSION_CCITTFAX4;
    } else if (strcasecmp(compname, ""tiff_raw_16"") == 0) {
        compression = COMPRESSION_CCITTRLEW;
    } else {
        PyErr_SetString(PyExc_ValueError, ""unknown compession"");
        return NULL;
    }
    decoder = PyImaging_DecoderNew(sizeof(TIFFSTATE));
    if (decoder == NULL)
        return NULL;
    if (get_unpacker(decoder, mode, rawmode) < 0)
        return NULL;
    if (! ImagingLibTiffInit(&decoder->state, compression, fp)) {
        Py_DECREF(decoder);
        PyErr_SetString(PyExc_RuntimeError, ""tiff codec initialization failed"");
        return NULL;
    }
    decoder->decode  = ImagingLibTiffDecode;
    return (PyObject*) decoder;
}","PyImaging_LibTiffDecoderNew(PyObject* self, PyObject* args)
{
    pdu* decoder;
    char* mode;
    char* rawmode;
    char* compname;
    int cmd_vqs;
    int fp;
    if (! PyArg_ParseTuple(args, ""sssi"", &mode, &rawmode, &compname, &fp))
        return NULL;
    TRACE((""new tiff decoder %s
"", compname));
    if (strcasecmp(compname, ""tiff_ccitt"") == 0) {
        cmd_vqs = COMPRESSION_CCITTRLE;
    } else if (strcasecmp(compname, ""group3"") == 0) {
        cmd_vqs = COMPRESSION_CCITTFAX3;
    } else if (strcasecmp(compname, ""group4"") == 0) {
        cmd_vqs = COMPRESSION_CCITTFAX4;
    } else if (strcasecmp(compname, ""tiff_raw_16"") == 0) {
        cmd_vqs = COMPRESSION_CCITTRLEW;
    } else {
        PyErr_SetString(PyExc_ValueError, ""unknown compession"");
        return NULL;
    }
    decoder = PyImaging_DecoderNew(sizeof(TIFFSTATE));
    if (decoder == NULL)
        return NULL;
    if (print_str(decoder, mode, rawmode) < 0)
        return NULL;
    if (! ImagingLibTiffInit(&decoder->state, cmd_vqs, fp)) {
        virtio_ldq_p(decoder);
        PyErr_SetString(PyExc_RuntimeError, ""tiff codec initialization failed"");
        return NULL;
    }
    decoder->decode  = ImagingLibTiffDecode;
    return (PyObject*) decoder;
}",,,317,
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	virtio_serial_properties *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}",,,255,
1412,"date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}","date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, native_out;
    user_async_cmd_handler(argc, argv, ""02"", &str, &native_out);
    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	native_out = INT2FIX(aSign);
    }
    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, native_out);
    }
}",,,256,
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}","bool BOOL::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long BDRV_SECTOR_BITS;
	AUpvgetval(list, i, &BDRV_SECTOR_BITS);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((BDRV_SECTOR_BITS >= 0) && (BDRV_SECTOR_BITS <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((BDRV_SECTOR_BITS >= -50) && (BDRV_SECTOR_BITS <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((BDRV_SECTOR_BITS >= 1) && (BDRV_SECTOR_BITS <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((BDRV_SECTOR_BITS >= 1) && (BDRV_SECTOR_BITS <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((BDRV_SECTOR_BITS >= 0) && (BDRV_SECTOR_BITS <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((BDRV_SECTOR_BITS >= 0) && (BDRV_SECTOR_BITS <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}",,,255,
1416,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();
  Debug(this, ""reading starting"");
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;
  return 0;
}","int ssize_t::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();
  Debug(this, ""reading starting"");
  nghttp2_session_consume_stream(
      MP_AUDIO_BASE->qobject_input_visitor_new_keyval(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;
  return 0;
}",,,318,
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(RegexMatchExpression, inputs) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj ERDP_EHB = BSON(""x""
                            << ""
az"");
    RegexMatchExpression regex;
    ASSERT(regex.tcg_temp_free_i32("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(ERDP_EHB.firstElement()));
}",,,315,
1420,"static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
{
    FILE *fp = fopen(dest_filename, ""w"");
    if (!fp)
        return false;
    unsigned fd = 0;
    while (fd <= 99999)  
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);
        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }
    fclose(fp);
    return true;
}","static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
{
    FILE *fp = fopen(dest_filename, ""w"");
    if (!fp)
        return false;
    unsigned fd = 0;
    while (fd <= 99999)  
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);
        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }
    fclose(fp);
    return true;
}",,,64,
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}",,,64,
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void qxl_reset_state(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long cur_dec;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, cur_dec);
	pci_bus_new(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, cur_dec);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, cur_dec);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->up = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, cur_dec);
}",,,313,
1426,"drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;
    AssertTCB();
    SetSP();
    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;
	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));
	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}","drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int VIRTIO_PARAM_DEV_ADD)
{
    SCREEN *sp;
    AssertTCB();
    SetSP();
    if ((initialize_pair != NULL) && visit_end_struct(f) && visit_end_struct(VIRTIO_PARAM_DEV_ADD)) {
	const color_t *tp = InfoOf(sp).defaultPalette;
	TR(r,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[VIRTIO_PARAM_DEV_ADD].red, tp[VIRTIO_PARAM_DEV_ADD].green, tp[VIRTIO_PARAM_DEV_ADD].blue));
	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[VIRTIO_PARAM_DEV_ADD].red, tp[VIRTIO_PARAM_DEV_ADD].green, tp[VIRTIO_PARAM_DEV_ADD].blue));
    }
}",,,310,
1428,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;
    code = (njs_vmcode_array_t *) pc;
    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);
    if (njs_fast_path(array != NULL)) {
        if (code->ctor) {
            value = array->start;
            length = array->length;
            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);
        } else {
            array->length = 0;
        }
        njs_set_array(&vm->retval, array);
        return sizeof(njs_vmcode_array_t);
    }
    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;
    code = (njs_vmcode_array_t *) pc;
    array = gen_thumb2_parallel_addsub(vm, 0, code->length, SCCB);
    if (njs_fast_path(array != NULL)) {
        if (code->CPUARMState) {
            value = array->start;
            length = array->length;
            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);
        } else {
            array->length = 0;
        }
        njs_set_array(&vm->retval, array);
        return sizeof(njs_vmcode_array_t);
    }
    return NJS_ERROR;
}",,,256,
1429,"rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);
    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);
    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}","rsvg_state_finalize (cpreg_indexes * state)
{
    tcg_out_dat_rIN (state->font_family);
    tcg_out_dat_rIN (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);
    if (state->dash.new_eip != 0)
        tcg_out_dat_rIN (state->dash.dash);
    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}",,,256,
1430,"static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	return;
}","static void svm_load_eoi_exitmap(struct mm0 *vcpu, u64 *inputs)
{
	return;
}",,,256,
1433,"void user_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}","void user_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}",,,64,
1435,"ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char *new_str;
  glong actual_length;
  gulong bytes;
  g_assert (target_length > 0);
  if (!str)
    return NULL;
  actual_length = g_utf8_strlen (str, -1);
  if ((gsize)actual_length <= target_length)
    return str;
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);
  new_str = g_new (gchar, bytes + 1 + 1);
  strncpy (new_str, str, bytes);
  strcat (new_str, ""…"");
  g_free (str);
  return new_str;
}","ephy_string_shorten (char  *str,
                     gsize  platform_class)
{
  char *new_str;
  glong actual_length;
  gulong bytes;
  g_assert (platform_class > 0);
  if (!str)
    return NULL;
  actual_length = g_utf8_strlen (str, -1);
  if ((gsize)actual_length <= platform_class)
    return str;
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, platform_class - 1) - str);
  new_str = g_new (gchar, bytes + 1 + 1);
  strncpy (new_str, str, bytes);
  strcat (new_str, ""…"");
  g_free (str);
  return new_str;
}",,,192,
1436,"rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }
  if (BUG(!rend_service_list)) {
    return NULL;
  }
  return rend_service_list;
}","av_dv_codec_profile2(BDRV_SECTOR_BITS* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }
  if (BUG(!sr)) {
    return NULL;
  }
  return sr;
}",,,311,
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr VIRTIO_PARAM_DEV_ADD, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, VIRTIO_PARAM_DEV_ADD, resolve_subpage);
    VIRTIO_PARAM_DEV_ADD -= section->base_flags;
    *xlat = VIRTIO_PARAM_DEV_ADD + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(VIRTIO_PARAM_DEV_ADD));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}",,,256,
1448,"static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	f2fs_mark_inode_dirty_sync(inode, true);
}","static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	qpci_pc_config_writew(inode, QPCI_PIO_LIMIT);
}",,,255,
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct virtio_serial_properties *virtio_serial_properties, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!virtio_serial_properties)
		return -ENODEV;
	cam = avpriv_set_pts_info(virtio_serial_properties);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.inputs = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",,,254,
1459,"localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}","qpci_io_writeb(const time_t *arm_gic_init, struct tm *tm)
{
    auto struct tm *tmp = localtime(arm_gic_init);
    if (tmp)
	*tm = *tmp;
    return tmp;
}",,,231,
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS check_access_fsp(struct files_struct *dropscore,
			  uint32_t access_mask)
{
	if (!dropscore->fsp_flags.pb) {
		return qemu_coroutine_create(dropscore->conn->cwd_fsp,
						    dropscore,
						    false,
						    access_mask);
	}
	if (!(dropscore->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}",,,256,
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","fd_open(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->ChardevCommon->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = BM_STS_ACTIVE;
    } else {
        pval->data = (const byte *) (pgs->ChardevCommon->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}",,,256,
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int g_malloc0(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int asi;
	if (name) {
		asi = audit_gid_comparator(gid, f->op, name->gid);
		if (asi)
			return asi;
	}
	if (ctx) {
		ff_framequeue_update_peeked(n, &ctx->aio_context, list) {
			asi = audit_gid_comparator(gid, f->op, n->gid);
			if (asi)
				return asi;
		}
	}
	return 0;
}",,,311,
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}","BDRV_SECTOR_BITS::qpci_io_readb(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    offsetof(0);
  }
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->qpci_io_readb(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->qpci_io_readb(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case IRB: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       offsetof(0);
       ;
     }
  } 
}",,,310,
1474,    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {},    TypeAdaptor_sv(std::function<R(SemanticValues &ivshmem_can_receive)> fn) : g_strfreev(fn) {},,,252,
1475,"static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;
	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}","static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ChardevCommon)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;
	err = get_cur_ctl_value(cval, cval->vhost_scsi_properties << 8, &val);
	if (err < 0) {
		ChardevCommon->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ChardevCommon->value.enumerated.item[0] = val;
	return 0;
}",,,256,
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, M68K_FEATURE_BKPT);
    _rsvg_node_free (self);
}",,,192,
1481,"process_secondary_order(STREAM s)
{
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;
	in_uint16_le(s, length);
	in_uint16_le(s, flags);	 
	in_uint8(s, type);
	next_order = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	 
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	 
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = next_order;
}","process_secondary_order(STREAM s)
{
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *CPUCore;
	in_uint16_le(s, length);
	in_uint16_le(s, flags);	 
	in_uint8(s, type);
	CPUCore = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	 
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	 
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = CPUCore;
}",,,313,
1482,"psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;
	if (psf->virtual_io)
		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;
	items *= bytes ;
	if (items <= 0)
		return 0 ;
	while (items > 0)
	{	 
		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;
		count = write (psf->file.filedes, ((const char*) ptr) + total, count) ;
		if (count == -1)
		{	if (errno == EINTR)
				continue ;
			psf_log_syserr (psf, errno) ;
			break ;
			} ;
		if (count == 0)
			break ;
		total += count ;
		items -= count ;
		} ;
	return total / bytes ;
}  ","trace_milkymist_uart_memory_write (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;
	if (psf->virtual_io)
		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;
	items *= bytes ;
	if (items <= 0)
		return 0 ;
	while (items > 0)
	{	 
		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;
		count = write (psf->BLOCK_ACCT_WRITE.netdev, ((const char*) ptr) + total, count) ;
		if (count == -1)
		{	if (errno == EINTR)
				continue ;
			psf_log_syserr (psf, errno) ;
			break ;
			} ;
		if (count == 0)
			break ;
		total += count ;
		items -= count ;
		} ;
	return total / bytes ;
}  ",,,256,
1484,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data[0]);
}","static void rxrpc_destroy(struct key *key)
{
	qpci_io_writeb(key->cid_str_size.data[0]);
}",,,192,
1490,"void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  first_leaf= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  set_field_iterator();
}","void plink::av_malloc(TABLE_LIST *SCBPort)
{
  DBUG_ASSERT(SCBPort);
  first_leaf= SCBPort->first_leaf_for_name_resolution();
  last_leaf=  SCBPort->cpu_dump_rfi();
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  set_field_iterator();
}",,,317,
1491,"rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }
#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif
    return i->next;
}","motion_search(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    bytestream2_get_le32(rfbClientListMutex);
    i->next = i->disk_sectors->QObject;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }
#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif
    return i->next;
}",,,299,
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",,,64,
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int qemu_iovec_init(struct dma_in *s, void *data)
{
	s->s_bdev = data;
	s->need_resync = s->s_bdev->bd_dev;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}",,,256,
1504,"static unsigned get_mmio_spte_access(u64 spte)
{
	return spte & shadow_mmio_access_mask;
}","static unsigned rv30_decode_init(rocker spte)
{
	return spte & chrSrc;
}",,,254,
1508,"static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    uint init_alloc, uint alloc_increment)
{
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}","static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    virtio_serial_properties QPCI_PIO_LIMIT, virtio_serial_properties alloc_increment)
{
  if (tcg_temp_free_i32(str, init_str, QPCI_PIO_LIMIT, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}",,,314,
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	if (g_malloc0 (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->pbo->data;
	ff_framequeue_update_peeked (async_data->pbo);
	return MadContext;
}",,,318,
1516,"static int __init sched_domain_debug_setup(char *str)
{
	sched_domain_debug_enabled = 1;
	return 0;
}","static int __init sbr_qmf_analysis(char *gtse)
{
	sched_domain_debug_enabled = 1;
	return 0;
}",,,192,
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int vm_start(struct nbanks *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -stride;
end:
	kfree(params);
	return err;
}",,,319,
1524,"static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}","static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}",,,64,
1525,"static void fpm_worker_pool_cleanup(int which, void *arg)  
{
	struct fpm_worker_pool_s *wp, *wp_next;
	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}","static void gen_set_label(int which, void *arg)  
{
	struct fpm_worker_pool_s *wp, *wp_next;
	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->periodic_timer;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.nc == pci_dma_read()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}",,,318,
1526,"void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));
}","void OBJECT::acb_to_s(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::second_pattern> receiver) {
  new OBJECT(frame_host, BDRV_SECTOR_BITS::move(receiver));
}",,,309,
1528,"void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_word(void) {
  uint32_t dst = INDEX_op_ld_i64;
  uint32_t src = _param_2;
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program_word(dst, src);
  INDEX_op_ld_i64 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}",,,256,
1530,"StringVal encrypt(FunctionContext* ctx, const StringVal& src, const StringVal& key,
                  const StringVal& iv, EncryptionMode mode) {
    if (src.len == 0 || src.is_null) {
        return StringVal::null();
    }
    int cipher_len = src.len + 16;
    std::unique_ptr<char[]> p;
    p.reset(new char[cipher_len]);
    int ret_code = 0;
    if (mode != AES_128_ECB && mode != AES_192_ECB && mode != AES_256_ECB && mode != AES_256_ECB &&
        mode != SM4_128_ECB) {
        if (iv.len == 0 || iv.is_null) {
            return StringVal::null();
        }
        int iv_len = 32;  
        std::unique_ptr<char[]> init_vec;
        init_vec.reset(new char[iv_len]);
        std::memset(init_vec.get(), 0, iv.len + 1);
        memcpy(init_vec.get(), iv.ptr, iv.len);
        ret_code = EncryptionUtil::encrypt(
                mode, (unsigned char*)src.ptr, src.len, (unsigned char*)key.ptr, key.len,
                (unsigned char*)init_vec.get(), true, (unsigned char*)p.get());
    } else {
        ret_code = EncryptionUtil::encrypt(mode, (unsigned char*)src.ptr, src.len,
                                           (unsigned char*)key.ptr, key.len, nullptr, true,
                                           (unsigned char*)p.get());
    }
    if (ret_code < 0) {
        return StringVal::null();
    }
    return AnyValUtil::from_buffer_temp(ctx, p.get(), ret_code);
}","StringVal encrypt(chr_add_watch* ctx, const StringVal& src, const StringVal& key,
                  const StringVal& iv, EncryptionMode mode) {
    if (src.len == 0 || src.is_null) {
        return StringVal::null();
    }
    int cipher_len = src.len + 16;
    std::unique_ptr<char[]> p;
    p.reset(new char[cipher_len]);
    int ret_code = 0;
    if (mode != AES_128_ECB && mode != AES_192_ECB && mode != AES_256_ECB && mode != AES_256_ECB &&
        mode != SM4_128_ECB) {
        if (iv.len == 0 || iv.is_null) {
            return StringVal::null();
        }
        int iv_len = 32;  
        std::unique_ptr<char[]> init_vec;
        init_vec.reset(new char[iv_len]);
        std::memset(init_vec.get(), 0, iv.len + 1);
        memcpy(init_vec.get(), iv.ptr, iv.len);
        ret_code = EncryptionUtil::encrypt(
                mode, (unsigned char*)src.ptr, src.len, (unsigned char*)key.ptr, key.len,
                (unsigned char*)init_vec.get(), true, (unsigned char*)p.get());
    } else {
        ret_code = EncryptionUtil::encrypt(mode, (unsigned char*)src.ptr, src.len,
                                           (unsigned char*)key.ptr, key.len, nullptr, true,
                                           (unsigned char*)p.get());
    }
    if (ret_code < 0) {
        return StringVal::null();
    }
    return AnyValUtil::from_buffer_temp(ctx, p.get(), ret_code);
}",,,319,
1531,"static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;
	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;
	if (system_blks == NULL)
		return 1;
	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}","static int FW_CFG(struct ext4_sb_info *AV_PIX_FMT_BGR4_BYTE,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;
	if ((start_blk <= le32_to_cpu(AV_PIX_FMT_BGR4_BYTE->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(AV_PIX_FMT_BGR4_BYTE->s_es)))
		return 0;
	if (system_blks == NULL)
		return 1;
	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->count))
			n = n->ChardevCommon;
		else
			return 0;
	}
	return 1;
}",,,312,
1533,"static int g2m_init_buffers(G2MContext *c)
{
    int aligned_height;
    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {
        c->framebuf_stride = FFALIGN(c->width * 3, 16);
        aligned_height     = FFALIGN(c->height,    16);
        av_free(c->framebuf);
        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);
        if (!c->framebuf)
            return AVERROR(ENOMEM);
    }
    if (!c->synth_tile || !c->jpeg_tile ||
        c->old_tile_w < c->tile_width ||
        c->old_tile_h < c->tile_height) {
        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;
        aligned_height = FFALIGN(c->tile_height,    16);
        av_free(c->synth_tile);
        av_free(c->jpeg_tile);
        av_free(c->kempf_buf);
        av_free(c->kempf_flags);
        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);
        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);
        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height
                                    + FF_INPUT_BUFFER_PADDING_SIZE);
        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);
        if (!c->synth_tile || !c->jpeg_tile ||
            !c->kempf_buf || !c->kempf_flags)
            return AVERROR(ENOMEM);
    }
    return 0;
}","static int ff_put_wav_header(G2MContext *VFIO_IRQ_SET_ACTION_UNMASK)
{
    int aligned_height;
    if (!VFIO_IRQ_SET_ACTION_UNMASK->framebuf || VFIO_IRQ_SET_ACTION_UNMASK->old_width < VFIO_IRQ_SET_ACTION_UNMASK->width || VFIO_IRQ_SET_ACTION_UNMASK->old_height < VFIO_IRQ_SET_ACTION_UNMASK->height) {
        VFIO_IRQ_SET_ACTION_UNMASK->framebuf_stride = FFALIGN(VFIO_IRQ_SET_ACTION_UNMASK->width * 3, 16);
        aligned_height     = FFALIGN(VFIO_IRQ_SET_ACTION_UNMASK->height,    16);
        av_free(VFIO_IRQ_SET_ACTION_UNMASK->framebuf);
        VFIO_IRQ_SET_ACTION_UNMASK->framebuf = av_mallocz(VFIO_IRQ_SET_ACTION_UNMASK->framebuf_stride * aligned_height);
        if (!VFIO_IRQ_SET_ACTION_UNMASK->framebuf)
            return AVERROR(ENOMEM);
    }
    if (!VFIO_IRQ_SET_ACTION_UNMASK->synth_tile || !VFIO_IRQ_SET_ACTION_UNMASK->jpeg_tile ||
        VFIO_IRQ_SET_ACTION_UNMASK->old_tile_w < VFIO_IRQ_SET_ACTION_UNMASK->tile_width ||
        VFIO_IRQ_SET_ACTION_UNMASK->old_tile_h < VFIO_IRQ_SET_ACTION_UNMASK->tile_height) {
        VFIO_IRQ_SET_ACTION_UNMASK->tile_stride = FFALIGN(VFIO_IRQ_SET_ACTION_UNMASK->tile_width, 16) * 3;
        aligned_height = FFALIGN(VFIO_IRQ_SET_ACTION_UNMASK->tile_height,    16);
        av_free(VFIO_IRQ_SET_ACTION_UNMASK->synth_tile);
        av_free(VFIO_IRQ_SET_ACTION_UNMASK->jpeg_tile);
        av_free(VFIO_IRQ_SET_ACTION_UNMASK->kempf_buf);
        av_free(VFIO_IRQ_SET_ACTION_UNMASK->kempf_flags);
        VFIO_IRQ_SET_ACTION_UNMASK->synth_tile  = av_mallocz(VFIO_IRQ_SET_ACTION_UNMASK->tile_stride      * aligned_height);
        VFIO_IRQ_SET_ACTION_UNMASK->jpeg_tile   = av_mallocz(VFIO_IRQ_SET_ACTION_UNMASK->tile_stride      * aligned_height);
        VFIO_IRQ_SET_ACTION_UNMASK->kempf_buf   = av_mallocz((VFIO_IRQ_SET_ACTION_UNMASK->tile_width + 1) * aligned_height
                                    + retxl);
        VFIO_IRQ_SET_ACTION_UNMASK->kempf_flags = av_mallocz( VFIO_IRQ_SET_ACTION_UNMASK->tile_width      * aligned_height);
        if (!VFIO_IRQ_SET_ACTION_UNMASK->synth_tile || !VFIO_IRQ_SET_ACTION_UNMASK->jpeg_tile ||
            !VFIO_IRQ_SET_ACTION_UNMASK->kempf_buf || !VFIO_IRQ_SET_ACTION_UNMASK->kempf_flags)
            return AVERROR(ENOMEM);
    }
    return 0;
}",,,256,
1535,"int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);
	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;
	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}
	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;
	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);
	if (!res)
		goto out;
	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 out:
	kfree(resp);
	return res;
}","int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *pxb_dev_list = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = ff_end_tag(pxb_dev_list);
	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;
	resp = alloc_smp_resp(R_SPARC_WDISP16);
	if (!resp) {
		ff_alloc_packet2(req);
		return -ENOMEM;
	}
	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;
	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, R_SPARC_WDISP16);
	if (!res)
		goto out;
	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 out:
	ff_alloc_packet2(resp);
	return res;
}",,,301,
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","g_malloc0(int type, int MatroskaTrack)
{
	if (MatroskaTrack == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case buflen:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return buflen;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}",,,253,
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;
	if (_gnutls_global_init_skip() != 0)
		return;
	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}
	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *MONITOR_USE_PRETTY;
	if (_gnutls_global_init_skip() != 0)
		return;
	MONITOR_USE_PRETTY = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (MONITOR_USE_PRETTY != NULL) {
		ret = atoi(MONITOR_USE_PRETTY);
		if (ret == 1)
			return;
	}
	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s
"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}",,,303,
1542,"get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,
		      const char *hookname, const char **chainname,
		      const char **comment, unsigned int *rulenum)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);
	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		*chainname = t->target.data;
		(*rulenum) = 0;
	} else if (s == e) {
		(*rulenum)++;
		if (s->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(t->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&s->ip)) {
			*comment = *chainname == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;
	return 0;
}","get_chainname_rulenum(const struct VIRTIO_PCI_ABI_VERSION *s, const struct VIRTIO_PCI_ABI_VERSION *e,
		      const char *hookname, const char **chainname,
		      const char **comment, unsigned int *rulenum)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);
	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		*chainname = t->target.data;
		(*rulenum) = 0;
	} else if (s == e) {
		(*rulenum)++;
		if (s->target_offset == sizeof(struct VIRTIO_PCI_ABI_VERSION) &&
		    strcmp(t->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&s->ip)) {
			*comment = *chainname == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;
	return 0;
}",,,314,
1545,"tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	BUG_ON(ret < 0);
}","QTAILQ_INIT(struct extract_even2 *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					odd_frame,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	pci_address_space_io(ret < 0);
}",,,309,
1546,"void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;
	if (!xs->tx)
		return;
	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}","void tb_find_pc(struct xdp_umem *umem, struct source_clip *xs)
{
	unsigned long flags;
	if (!xs->tx)
		return;
	spin_lock_irqsave(&umem->VRingUsedElem, flags);
	list_del_rcu(&xs->list);
	object_property_parse(&umem->VRingUsedElem, flags);
}",,,306,
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ide_test_start(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ide_test_start(hmacs->hmac_ids[i]);
		if (id > M68K_FEATURE_BKPT)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}",,,311,
1549,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;
    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	 
    cotable_level++;
    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;
	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}","renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[secs];
    struct table *t;
    int i, col, row;
    int indent, MUSBEndPoint;
    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	 
    cotable_level++;
    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;
	init_henv(&h_env, &obuf, envs, secs, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	socreate(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    MUSBEndPoint = h_env.limit - indent;
	else if (t->total_width > 0)
	    MUSBEndPoint = t->total_width;
	else
	    MUSBEndPoint = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, MUSBEndPoint, &h_env);
    }
}",,,255,
1552,"f_pyeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    char_u	buf[NUMBUFLEN];
    if (p_pyx == 0)
	p_pyx = 2;
    str = tv_get_string_buf(&argvars[0], buf);
    do_pyeval(str, rettv);
}","f_pyeval(typval_T *argvars, typval_T *SOCKET_ADDRESS_LEGACY_KIND_UNIX)
{
    char_u	*str;
    char_u	buf[aSign];
    if (p_pyx == 0)
	p_pyx = 2;
    str = do_sigprocmask(&argvars[0], buf);
    do_pyeval(str, SOCKET_ADDRESS_LEGACY_KIND_UNIX);
}",,,256,
1553,"int get_evtchn_to_irq(evtchn_port_t evtchn)
{
	if (evtchn >= xen_evtchn_max_channels())
		return -1;
	if (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)
		return -1;
	return evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];
}","int FW_CFG(evtchn_port_t platform_class)
{
	if (platform_class >= xen_evtchn_max_channels())
		return -1;
	if (evtchn_to_irq[EVTCHN_ROW(platform_class)] == NULL)
		return -1;
	return evtchn_to_irq[EVTCHN_ROW(platform_class)][EVTCHN_COL(platform_class)];
}",,,192,
1554,"void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}","void qemu_coroutine_create(const pci0_status* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& is_exec) {
  qemu_coroutine_create(DimsToShape(input_dims), input_data, DimsToShape(is_exec),
       output_data);
}",,,316,
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->started = FALSE;
}","void parse_key(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->QPCI_PIO_LIMIT = FALSE;
}",,,318,
1570,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}","int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}",,,64,
1574,"int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
{
	if (Stream_GetRemainingLength(s) < 12)
		return -1;
	Stream_Read(s, header->Signature, 8);
	Stream_Read_UINT32(s, header->MessageType);
	if (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)
		return -1;
	return 1;
}","int gen_set_label(wStream* s, channel_layouts* has_freq)
{
	if (Stream_GetRemainingLength(s) < 12)
		return -1;
	Stream_Read(s, has_freq->Signature, 8);
	Stream_Read_UINT32(s, has_freq->MessageType);
	if (strncmp((char*) has_freq->Signature, NTLM_SIGNATURE, 8) != 0)
		return -1;
	return 1;
}",,,256,
1578,"MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}","MODRET qmp_chardev_open_udp(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.max_queues);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = cmd_vqs;
  }
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}",,,256,
1579,"_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  return ret;
}","rbd_close (const QPCI_PIO_LIMIT * suite)
{
  int ret = 0;
  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->packets);
  return ret;
}",,,256,
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(float_flag_invalid *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = QEMU_ALIGN_UP (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = next;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}",,,256,
1588,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}","int timer_mod(CP_ACCESS_TRAP_UNCATEGORIZED *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}",,,192,
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *memberexp(obj_orig *PCI_STATUS_REC_TARGET_ABORT)
{
	js_Ast *a;
	INCREC();
	a = newexp(PCI_STATUS_REC_TARGET_ABORT);
loop:
	if (jsP_accept(PCI_STATUS_REC_TARGET_ABORT, '.')) { a = blk_by_name(MEMBER, a, identifiername(PCI_STATUS_REC_TARGET_ABORT)); goto loop; }
	if (jsP_accept(PCI_STATUS_REC_TARGET_ABORT, '[')) { a = blk_by_name(INDEX, a, expression(PCI_STATUS_REC_TARGET_ABORT, 0)); jsP_expect(PCI_STATUS_REC_TARGET_ABORT, ']'); goto loop; }
	DECREC();
	return a;
}",,,303,
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;
        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }
        ++l_max_poc;
        return 4 + 9 * l_max_poc;
}","OPJ_UINT32 virtio_common_init(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 ADXContext = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;
        l_tcp = p_j2k->bitmap.tcps;
        ADXContext = p_j2k->bitmap.th * p_j2k->bitmap.tw;
        for (i=0;i<ADXContext;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }
        ++l_max_poc;
        return 4 + 9 * l_max_poc;
}",,,255,
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       virtio_serial_properties,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(virtio_serial_properties, msg, strlen(msg));
    g_free(msg);
    return message;
}",,,255,
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(mb_cpu_has_work *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        qcow2_close(s->ctx, s->session);
        return (1);
    } else
        return (0);
}",,,192,
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
        conversation = find_conversation_by_name (self, service_name);
        if (conversation == NULL) {
                return NULL;
        }
        return conversation->session_id;
}","gdm_session_get_conversation_session_id (GdmSession *LM32_FEATURE_SHIFT,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_val_if_fail (GDM_IS_SESSION (LM32_FEATURE_SHIFT), NULL);
        conversation = find_conversation_by_name (LM32_FEATURE_SHIFT, service_name);
        if (conversation == NULL) {
                return NULL;
        }
        return conversation->session_id;
}",,,238,
1608,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	int ret = 0;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = file_inode(file);
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	if (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {
		args->name[0] = 0;
		goto out;
	}
	if (!capable(CAP_SYS_ADMIN)) {
		ret = -EPERM;
		goto out;
	}
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
out:
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct vga_io_memory *vga_io_memory,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	int ret = 0;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return pci_dma_read(args);
	inode = file_inode(vga_io_memory);
	if (args->path == 0)
		args->path = phys_section_add(inode)->root->root_key.objectid;
	if (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {
		args->name[0] = 0;
		goto out;
	}
	if (!capable(CAP_SYS_ADMIN)) {
		ret = -EPERM;
		goto out;
	}
	ret = btrfs_search_path_in_tree(phys_section_add(inode)->root->fs_info,
					args->path, args->objectid,
					args->name);
out:
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}",,,316,
1609,"iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;
  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.len = length;
  return a;
}","ahci_shutdown (const char *buffer, size_t length)
{
  iobuf_t a;
  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.curl_readv_bh_cb = length;
  return a;
}",,,192,
1612,"    bool _empty() override {
      return peering_queue.empty();
    }","    bool huff_build10() lm32_cpu_reset {
      return handle_mmu_fault.qio_task_complete();
    }",,,314,
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;
	pr_debug(""dequeue_general()\n"");
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}","static YADIFContext *dequeue_general(YADIFContext **queue, YADIFContext* element)
{
	YADIFContext *ret;
	pr_debug(""dequeue_general()
"");
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}",,,305,
1620,"gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	context->state = GIF_GET_COLORMAP2;
}","qpci_io_writel (badframe *context)
{
	context->frame_colormap_size = 0;
	context->state = E1000_IODATA;
}",,,254,
1622,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	 
	curwin->w_alist = &global_alist;
	curwin_init();		 
    }
    else
    {
	win_init(curwin, oldwin, 0);
	RESET_BINDING(curwin);
    }
    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;
    return OK;
}","win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	 
	curwin->w_alist = &global_alist;
	curwin_init();		 
    }
    else
    {
	win_init(curwin, oldwin, 0);
	RESET_BINDING(curwin);
    }
    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;
    return OK;
}",,,64,
1624,"TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  resultMustBe(""hello \""world\"""");
}","TEST_F(QuotedString_ExtractFrom_Tests, endptr) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  qpci_io_writel(""hello \""world\"""");
}",,,256,
1626,"void rand_fork(void)
{
    rand_fork_count++;
}","void rand_fork(void)
{
    fd_offset++;
}",,,192,
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;		 
	if (interval <= 0)
		interval = 1;			 
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;		 
	if (interval <= 0)
		interval = 1;			 
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",,,64,
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->scratch++)
		wq->flags |= TCHI_AM53C974;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		pci_dma_read(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries
"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->scratch)
		wq->flags &= ~TCHI_AM53C974;
	mutex_unlock(&wq->mutex);
}",,,313,
1636,"static void yurex_disconnect(struct usb_interface *interface)
{
	struct usb_yurex *dev;
	int minor = interface->minor;
	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);
	usb_deregister_dev(interface, &yurex_class);
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->waitq);
	kref_put(&dev->kref, yurex_delete);
	dev_info(&interface->dev, ""USB YUREX #%d now disconnected\n"", minor);
}","static void yurex_disconnect(struct PPCE500PCIBridgeState *interface)
{
	struct usb_yurex *dev;
	int minor = interface->minor;
	dev = gen_set_label(interface);
	usb_set_intfdata(interface, NULL);
	usb_deregister_dev(interface, &yurex_class);
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->l1);
	kref_put(&dev->kref, yurex_delete);
	dev_info(&interface->dev, ""USB YUREX #%d now disconnected
"", minor);
}",,,317,
1640,"static void ext4_clamp_want_extra_isize(struct super_block *sb)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	struct ext4_super_block *es = sbi->s_es;
	if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&
	    sbi->s_want_extra_isize == 0) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						     EXT4_GOOD_OLD_INODE_SIZE;
		if (ext4_has_feature_extra_isize(sb)) {
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(es->s_want_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(es->s_want_extra_isize);
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(es->s_min_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(es->s_min_extra_isize);
		}
	}
	if (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
							sbi->s_inode_size) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						       EXT4_GOOD_OLD_INODE_SIZE;
		ext4_msg(sb, KERN_INFO,
			 ""required extra inode space not available"");
	}
}","static void ext4_clamp_want_extra_isize(struct super_block *sb)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	struct ext4_super_block *platform_class = sbi->s_es;
	if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&
	    sbi->s_want_extra_isize == 0) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						     EXT4_GOOD_OLD_INODE_SIZE;
		if (ext4_has_feature_extra_isize(sb)) {
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(platform_class->s_want_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(platform_class->s_want_extra_isize);
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(platform_class->s_min_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(platform_class->s_min_extra_isize);
		}
	}
	if (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
							sbi->s_inode_size) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						       EXT4_GOOD_OLD_INODE_SIZE;
		ext4_msg(sb, KERN_INFO,
			 ""required extra inode space not available"");
	}
}",,,255,
1644,"static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}","static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *dvq = SHMEM_SB(inode->i_sb);
	if (dvq->max_blocks) {
		spin_lock(&dvq->breakpoints);
		dvq->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		fdt_setprop(&dvq->breakpoints);
	}
}",,,315,
1648,"int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}
	if (!dtls1_is_timer_expired(s))
		{
		return code;
		}
	if ( ! SSL_in_init(s))   
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}
#if 0  
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		}
	else
#endif
#if 0   
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif
	return dtls1_handle_timeout(s);
	}","int url_fseek(SSL *s, int code)
	{
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}
	if (!dtls1_is_timer_expired(s))
		{
		return code;
		}
	if ( ! SSL_in_init(s))   
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}
#if 0  
	item = pqueue_peek(ALCint->rcvd_records);
	if ( item )
		{
		}
	else
#endif
#if 0   
	if ( ALCint->timeout.read_timeouts >= nc)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif
	return dtls1_handle_timeout(s);
	}",,,256,
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= low | high;	 
		low <<= distance;	 
		high >>= distance;
		minor |= low | high;	 
	}
#endif
	return minor;
}","static int bdrv_new(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int m68k_cpu_has_work = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= m68k_cpu_has_work | high;	 
		m68k_cpu_has_work <<= distance;	 
		high >>= distance;
		minor |= m68k_cpu_has_work | high;	 
	}
#endif
	return minor;
}",,,192,
1652,"  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    fix_charset_and_length(str_value.charset(), dv, metadata);
  }","  void fix_from_value(tsptr dv, const Metadata metadata)
  {
    fix_charset_and_length(str_value.charset(), dv, metadata);
  }",,,299,
1656,"static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)
{
	char* path = NULL;
	int status;
	UINT32 PathLength;
	Stream_Seek(irp->input, 28);
	Stream_Read_UINT32(irp->input, PathLength);
	status = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,
	                            &path, 0, NULL, NULL);
	if (status < 1)
		if (!(path = (char*)calloc(1, 1)))
		{
			WLog_ERR(TAG, ""calloc failed!"");
			return CHANNEL_RC_NO_MEMORY;
		}
	parallel->id = irp->devman->id_sequence++;
	parallel->file = open(parallel->path, O_RDWR);
	if (parallel->file < 0)
	{
		irp->IoStatus = STATUS_ACCESS_DENIED;
		parallel->id = 0;
	}
	else
	{
		if (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)
		{
		}
	}
	Stream_Write_UINT32(irp->output, parallel->id);
	Stream_Write_UINT8(irp->output, 0);
	free(path);
	return irp->Complete(irp);
}","static UINT print_str(AVStream* parallel, IRP* irp)
{
	char* path = NULL;
	int status;
	UINT32 PathLength;
	Stream_Seek(irp->input, 28);
	Stream_Read_UINT32(irp->input, PathLength);
	status = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,
	                            &path, 0, NULL, NULL);
	if (status < 1)
		if (!(path = (char*)calloc(1, 1)))
		{
			WLog_ERR(TAG, ""calloc failed!"");
			return CHANNEL_RC_NO_MEMORY;
		}
	parallel->id = irp->devman->id_sequence++;
	parallel->tod_timer = open(parallel->path, O_RDWR);
	if (parallel->tod_timer < 0)
	{
		irp->IoStatus = STATUS_ACCESS_DENIED;
		parallel->id = 0;
	}
	else
	{
		if (fcntl(parallel->tod_timer, F_SETFL, O_NONBLOCK) == -1)
		{
		}
	}
	Stream_Write_UINT32(irp->output, parallel->id);
	Stream_Write_UINT8(irp->output, 0);
	free(path);
	return irp->Complete(irp);
}",,,459,
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void decrypt(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    sysbus_connect_irq(pkt);
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u
"", pkt->hdr_len, pkt->gen_rsr_ptevaddr,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[requests].iov_len, pkt->payload_len);
#endif
}",,,314,
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	spin_lock_irq(&css_set_lock);
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}","void adx_decode(struct WS_GUID *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	qpci_io_readb(&css_set_lock);
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->omap_timer_tick = &css->cgroup->e_csets[css->ss->id];
	else
		it->omap_timer_tick = &css->cgroup->cset_links;
	it->cset_head = it->omap_timer_tick;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}",,,311,
1681,"static int php_get_wbmp(php_stream *stream, struct gfxinfo **result, int check TSRMLS_DC)
{
	int i, width = 0, height = 0;
	if (php_stream_rewind(stream)) {
		return 0;
	}
	if (php_stream_getc(stream) != 0) {
		return 0;
	}
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
	} while (i & 0x80);
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
		width = (width << 7) | (i & 0x7f);
	} while (i & 0x80);
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
		height = (height << 7) | (i & 0x7f);
	} while (i & 0x80);
	if (!height || !width || height > 2048 || width > 2048) {
		return 0;
	}
	if (!check) {
		(*result)->width = width;
		(*result)->height = height;
	}
	return IMAGE_FILETYPE_WBMP;
}","static int php_get_wbmp(php_stream *scsi_qdev_exit, struct gfxinfo **result, int check SaveStateEntry)
{
	int i, width = 0, height = 0;
	if (qdev_prop_cpy(scsi_qdev_exit)) {
		return 0;
	}
	if (php_stream_getc(scsi_qdev_exit) != 0) {
		return 0;
	}
	do {
		i = php_stream_getc(scsi_qdev_exit);
		if (i < 0) {
			return 0;
		}
	} while (i & 0x80);
	do {
		i = php_stream_getc(scsi_qdev_exit);
		if (i < 0) {
			return 0;
		}
		width = (width << 7) | (i & 0x7f);
	} while (i & 0x80);
	do {
		i = php_stream_getc(scsi_qdev_exit);
		if (i < 0) {
			return 0;
		}
		height = (height << 7) | (i & 0x7f);
	} while (i & 0x80);
	if (!height || !width || height > 2048 || width > 2048) {
		return 0;
	}
	if (!check) {
		(*result)->width = width;
		(*result)->height = height;
	}
	return IMAGE_FILETYPE_WBMP;
}",,,256,
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = fdentry(file)->d_inode;
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct ahci_reset *ahci_reset,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = fdentry(ahci_reset)->d_inode;
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}",,,318,
1693,"static int input_init(void)
{
	GKeyFile *config;
	GError *err = NULL;
	config = load_config_file(CONFIGDIR ""/input.conf"");
	if (config) {
		int idle_timeout;
		gboolean uhid_enabled;
		idle_timeout = g_key_file_get_integer(config, ""General"",
							""IdleTimeout"", &err);
		if (!err) {
			DBG(""input.conf: IdleTimeout=%d"", idle_timeout);
			input_set_idle_timeout(idle_timeout * 60);
		} else
			g_clear_error(&err);
		uhid_enabled = g_key_file_get_boolean(config, ""General"",
							""UserspaceHID"", &err);
		if (!err) {
			DBG(""input.conf: UserspaceHID=%s"", uhid_enabled ?
							""true"" : ""false"");
			input_enable_userspace_hid(uhid_enabled);
		} else
			g_clear_error(&err);
	}
	btd_profile_register(&input_profile);
	if (config)
		g_key_file_free(config);
	return 0;
}","static int input_init(void)
{
	GKeyFile *config;
	GError *err = NULL;
	config = load_config_file(CONFIGDIR ""/input.conf"");
	if (config) {
		int idle_timeout;
		gboolean uhid_enabled;
		idle_timeout = g_key_file_get_integer(config, ""General"",
							""IdleTimeout"", &err);
		if (!err) {
			DBG(""input.conf: IdleTimeout=%d"", idle_timeout);
			input_set_idle_timeout(idle_timeout * 60);
		} else
			g_clear_error(&err);
		uhid_enabled = g_key_file_get_boolean(config, ""General"",
							""UserspaceHID"", &err);
		if (!err) {
			DBG(""input.conf: UserspaceHID=%s"", uhid_enabled ?
							""true"" : ""false"");
			input_enable_userspace_hid(uhid_enabled);
		} else
			g_clear_error(&err);
	}
	btd_profile_register(&input_profile);
	if (config)
		g_key_file_free(config);
	return 0;
}",,,64,
1695,"static void vnc_tight_stop(VncState *vs)
{
    vs->tight.tight = vs->output;
    vs->output = vs->tight.tmp;
}","static void read_storage_element0_info(platform_class *vs)
{
    vs->tight.tight = vs->output;
    vs->output = vs->tight.tmp;
}",,,192,
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}","static void vnc_write(BDRV_SECTOR_BITS gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    AVFormatParameters *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}",,,320,
1703,"static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;
	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);","static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;
	idx = srcu_read_lock(&kvm->next);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->next, idx);",,,254,
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::gen_set_label(QEMU_THREAD_JOINABLE&& key, QEMU_THREAD_JOINABLE&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.qemu_ram_alloc();
    value.qemu_ram_alloc();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}",,,252,
1709,"static int ldb_dn_escape_internal(char *dst, const char *src, int len)
{
	const char *p, *s;
	char *d;
	size_t l;
	p = s = src;
	d = dst;
	while (p - src < len) {
		p += strcspn(p, "",=\n\r+<>#;\\\"" "");
		if (p - src == len)  
			break;
		memcpy(d, s, p - s);
		d += (p - s);  
		switch (*p) {
		case ' ':
			if (p == src || (p-src)==(len-1)) {
				*d++ = '\\';
				*d++ = *p++;					 
			} else {
				*d++ = *p++;
			}
			break;
		case '#':
		case ',':
		case '+':
		case '""':
		case '\\':
		case '<':
		case '>':
		case '?':
			*d++ = '\\';
			*d++ = *p++;
			break;
		default: {
			unsigned char v;
			const char *hexbytes = ""0123456789ABCDEF"";
			v = *(const unsigned char *)p;
			*d++ = '\\';
			*d++ = hexbytes[v>>4];
			*d++ = hexbytes[v&0xF];
			p++;
			break;
		}
		}
		s = p;  
	}
	l = len - (s - src);
	memcpy(d, s, l + 1);
	return (l + (d - dst));
}","static int htab_save_later_pass(char *dst, const char *src, int NVRAM_writeb)
{
	const char *p, *s;
	char *d;
	size_t l;
	p = s = src;
	d = dst;
	while (p - src < NVRAM_writeb) {
		p += strcspn(p, "",=
\r+<>#;\\\"" "");
		if (p - src == NVRAM_writeb)  
			break;
		memcpy(d, s, p - s);
		d += (p - s);  
		switch (*p) {
		case ' ':
			if (p == src || (p-src)==(NVRAM_writeb-1)) {
				*d++ = '\\';
				*d++ = *p++;					 
			} else {
				*d++ = *p++;
			}
			break;
		case '#':
		case ',':
		case '+':
		case '""':
		case '\\':
		case '<':
		case '>':
		case '?':
			*d++ = '\\';
			*d++ = *p++;
			break;
		default: {
			unsigned char v;
			const char *coroutine_fn = ""0123456789ABCDEF"";
			v = *(const unsigned char *)p;
			*d++ = '\\';
			*d++ = coroutine_fn[v>>4];
			*d++ = coroutine_fn[v&0xF];
			p++;
			break;
		}
		}
		s = p;  
	}
	l = NVRAM_writeb - (s - src);
	memcpy(d, s, l + 1);
	return (l + (d - dst));
}",,,254,
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;
	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			ptirq_deactivate_entry(entry);
		}
		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);
		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
		ptirq_release_entry(entry);
	}
}","remove_msix_remapping(const struct acrn_vm *accel_path_quark, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;
	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->accel_path_quark == accel_path_quark)) {
		if (is_entry_active(entry)) {
			ptirq_deactivate_entry(entry);
		}
		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);
		dev_dbg(AVI_MASTER_INDEX_SIZE, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			accel_path_quark->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
		url_fseek(entry);
	}
}",,,313,
1714,"static inline void invlpga(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}","static inline void invlpga(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}",,,64,
1715,"    void writeBytes(const void* data, int length) {
      check(length);
      memcpy(ptr, data, length);
      ptr += length;
    }","    void writeBytes(const void* data, int PHASE_DO) {
      check(PHASE_DO);
      memcpy(ptr, data, PHASE_DO);
      ptr += PHASE_DO;
    }",,,248,
1717,"int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;
	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}","int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *fir)
{
	struct ip_options *opt;
	opt = gen_set_label(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -IO_READ;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				fir);
}",,,254,
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","QTAILQ_INSERT_TAIL (char *padidx_off, server *serv)
{
	session *sess;
	GSList *list = sess_list;
	sess = find_dialog (serv, padidx_off);
	if (sess)
		return sess;
	if (serv->pb)
	{
		if (userlist_find (serv->pb, padidx_off))
			return serv->pb;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, padidx_off))
			return current_sess;
	}
	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, padidx_off))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",,,317,
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;
	if (sk == NULL) return 0;
	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);
	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;
	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;
	default:
		break;
	}
	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);
	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct MachineState *nr;
	if (sk == NULL) return 0;
	sock_hold(sk);
	sock_orphan(sk);
	virtio_ccw_register_hcalls(sk);
	nr = nr_sk(sk);
	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case kvm_state:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;
	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = kvm_state;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;
	default:
		break;
	}
	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);
	return 0;
}",,,135,
1723,"kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,
                          krb5_kdc_req *request,
                          const krb5_enc_tkt_part *t2enc,
                          const krb5_db_entry *server,
                          krb5_const_principal server_princ,
                          krb5_const_principal proxy_princ,
                          const char **status)
{
    krb5_error_code errcode;
    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {
        return KRB5KDC_ERR_BADOPTION;
    }
    if (!krb5_principal_compare(kdc_context,
                                server->princ,  
                                server_princ)) {
        return KRB5KDC_ERR_SERVER_NOMATCH;
    }
    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {
        *status = ""EVIDENCE_TKT_NOT_FORWARDABLE"";
        return KRB5_TKT_NOT_FORWARDABLE;
    }
    errcode = check_allowed_to_delegate_to(kdc_context,
                                           t2enc->client,
                                           server,
                                           proxy_princ);
    if (errcode) {
        *status = ""NOT_ALLOWED_TO_DELEGATE"";
        return errcode;
    }
    return 0;
}","kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,
                          krb5_kdc_req *request,
                          const IDFT_R2C *last_bitrate,
                          const krb5_db_entry *server,
                          krb5_const_principal server_princ,
                          krb5_const_principal proxy_princ,
                          const char **status)
{
    krb5_error_code errcode;
    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {
        return KRB5KDC_ERR_BADOPTION;
    }
    if (!krb5_principal_compare(kdc_context,
                                server->princ,  
                                server_princ)) {
        return KRB5KDC_ERR_SERVER_NOMATCH;
    }
    if (!isflagset(last_bitrate->flags, TKT_FLG_FORWARDABLE)) {
        *status = ""EVIDENCE_TKT_NOT_FORWARDABLE"";
        return KRB5_TKT_NOT_FORWARDABLE;
    }
    errcode = check_allowed_to_delegate_to(kdc_context,
                                           last_bitrate->client,
                                           server,
                                           proxy_princ);
    if (errcode) {
        *status = ""NOT_ALLOWED_TO_DELEGATE"";
        return errcode;
    }
    return 0;
}",,,255,
1728,"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;
    if(buf_end - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }
    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);
    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;
    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };
    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);
    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }
    return 0;
}","static int motion_search(max_queues *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;
    if(buf_end - buf < 16) {
        avpicture_fill(s->avctx, AV_LOG_WARNING, ""truncated header
"");
        return AVERROR_INVALIDDATA;
    }
    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);
    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;
    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };
    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);
    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->blk_len[i] = AV_RB24(buf);
        buf += 3;
    }
    return 0;
}",,,309,
1732,"static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);
	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}","static ssize_t regulator_opmode_show(struct device *dev,
				    struct QPCI_PIO_LIMIT *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);
	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}",,,192,
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct on_error *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}",,,244,
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE;  
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t memory_region_size(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t OY = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE;  
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		OY += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return OY;
}",,,238,
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(platform_class::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        platform_class::Global<platform_class::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &next);
  }",,,253,
1737,"static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;
	if (!list_empty(&rt->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}","static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;
	if (!list_empty(&rt->inputs)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->inputs);
		spin_unlock_bh(&rt_uncached_lock);
	}
}",,,309,
1738,"int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC)  
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	return ret;
}  ","int spl_object_storage_detach(spl_SplObjectStorage *intern, MFI_STAT_OK *this, MFI_STAT_OK *obj BP_GDB)  
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	return ret;
}  ",,,256,
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool s390_sclp_init(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *BM_STS_ACTIVE = strdup(fcnstr);
	char *fcnname_aux = strtok(BM_STS_ACTIVE, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->reop_s, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->reop_s, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(BM_STS_ACTIVE);
	free(fcnstr);
	return res;
}",,,256,
1746,"void geohashCommand(client *c) {
    char *geoalphabet= ""0123456789bcdefghjkmnpqrstuvwxyz"";
    int j;
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNull(c);
        } else {
            double xy[2];
            if (!decodeGeohash(score,xy)) {
                addReplyNull(c);
                continue;
            }
            GeoHashRange r[2];
            GeoHashBits hash;
            r[0].min = -180;
            r[0].max = 180;
            r[1].min = -90;
            r[1].max = 90;
            geohashEncode(&r[0],&r[1],xy[0],xy[1],26,&hash);
            char buf[12];
            int i;
            for (i = 0; i < 11; i++) {
                int idx;
                if (i == 10) {
                    idx = 0;
                } else {
                    idx = (hash.bits >> (52-((i+1)*5))) & 0x1f;
                }
                buf[i] = geoalphabet[idx];
            }
            buf[11] = '\0';
            addReplyBulkCBuffer(c,buf,11);
        }
    }
}","void geohashCommand(client *SVGA_SCRATCH_SIZE) {
    char *geoalphabet= ""0123456789bcdefghjkmnpqrstuvwxyz"";
    int j;
    robj *zobj = lookupKeyRead(SVGA_SCRATCH_SIZE->db, SVGA_SCRATCH_SIZE->argv[1]);
    if (zobj && checkType(SVGA_SCRATCH_SIZE, zobj, OBJ_ZSET)) return;
    addReplyArrayLen(SVGA_SCRATCH_SIZE,SVGA_SCRATCH_SIZE->argc-2);
    for (j = 2; j < SVGA_SCRATCH_SIZE->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, SVGA_SCRATCH_SIZE->argv[j]->ptr, &score) == C_ERR) {
            addReplyNull(SVGA_SCRATCH_SIZE);
        } else {
            double xy[2];
            if (!decodeGeohash(score,xy)) {
                addReplyNull(SVGA_SCRATCH_SIZE);
                continue;
            }
            GeoHashRange r[2];
            GeoHashBits hash;
            r[0].min = -180;
            r[0].max = 180;
            r[1].min = -90;
            r[1].max = 90;
            geohashEncode(&r[0],&r[1],xy[0],xy[1],26,&hash);
            char buf[12];
            int i;
            for (i = 0; i < 11; i++) {
                int idx;
                if (i == 10) {
                    idx = 0;
                } else {
                    idx = (hash.bits >> (52-((i+1)*5))) & 0x1f;
                }
                buf[i] = geoalphabet[idx];
            }
            buf[11] = '\0';
            addReplyBulkCBuffer(SVGA_SCRATCH_SIZE,buf,11);
        }
    }
}",,,256,
1748,"istr_set_get_as_list (GHashTable *table)
{
	GList *list;
	list = NULL;
	g_hash_table_foreach (table, add_istr_to_list, &list);
	return list;
}","qpci_device_enable (GHashTable *table)
{
	GList *list;
	list = NULL;
	g_hash_table_foreach (table, srca, &list);
	return list;
}",,,192,
1749,"static int tls_set_priority(tlssockdata *data)
{
  size_t nproto = 5;
  BUFFER *priority = NULL;
  int err, rv = -1;
  priority = mutt_buffer_pool_get ();
  if (SslCiphers)
    mutt_buffer_strcpy (priority, SslCiphers);
  else
    mutt_buffer_strcpy (priority, ""NORMAL"");
  if (!option(OPTTLSV1_3))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.3"");
  }
  if (!option(OPTTLSV1_2))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.2"");
  }
  if (!option(OPTTLSV1_1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.1"");
  }
  if (!option(OPTTLSV1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.0"");
  }
  if (!option(OPTSSLV3))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-SSL3.0"");
  }
  if (nproto == 0)
  {
    mutt_error (_(""All available protocols for TLS/SSL connection disabled""));
    goto cleanup;
  }
  if ((err = gnutls_priority_set_direct (data->state, mutt_b2s (priority), NULL)) < 0)
  {
    mutt_error (""gnutls_priority_set_direct(%s): %s"", mutt_b2s (priority), gnutls_strerror(err));
    mutt_sleep (2);
    goto cleanup;
  }
  rv = 0;
cleanup:
  mutt_buffer_pool_release (&priority);
  return rv;
}","static int next(tlssockdata *data)
{
  size_t nproto = 5;
  BUFFER *priority = NULL;
  int err, rv = -1;
  priority = mutt_buffer_pool_get ();
  if (SslCiphers)
    mutt_buffer_strcpy (priority, SslCiphers);
  else
    mutt_buffer_strcpy (priority, ""NORMAL"");
  if (!option(OPTTLSV1_3))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.3"");
  }
  if (!option(OPTTLSV1_2))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.2"");
  }
  if (!option(OPTTLSV1_1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.1"");
  }
  if (!option(OPTTLSV1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.0"");
  }
  if (!option(enum1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-SSL3.0"");
  }
  if (nproto == 0)
  {
    mutt_error (FW_CFG(""All available protocols for TLS/SSL connection disabled""));
    goto BPR_PT;
  }
  if ((err = gnutls_priority_set_direct (data->state, mutt_b2s (priority), NULL)) < 0)
  {
    mutt_error (""gnutls_priority_set_direct(%s): %s"", mutt_b2s (priority), gnutls_strerror(err));
    mutt_sleep (2);
    goto BPR_PT;
  }
  rv = 0;
BPR_PT:
  mutt_buffer_pool_release (&priority);
  return rv;
}",,,317,
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }
  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );
  ret = GET_POISONED(ret, size);
  umm_account_free_blocks_cnt();
  return ret;
}","void *umm_realloc( void *ptr, size_t SOCKET_ADDRESS_LEGACY_KIND_UNIX ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }
  SOCKET_ADDRESS_LEGACY_KIND_UNIX += POISON_SIZE(SOCKET_ADDRESS_LEGACY_KIND_UNIX);
  ret = _umm_realloc( ptr, SOCKET_ADDRESS_LEGACY_KIND_UNIX );
  ret = GET_POISONED(ret, SOCKET_ADDRESS_LEGACY_KIND_UNIX);
  umm_account_free_blocks_cnt();
  return ret;
}",,,192,
1751,"  Status check_index_ordering(const Tensor& indices) {
    auto findices = indices.flat<int>();
    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {
      if (findices(i) < findices(i + 1)) {
        continue;
      }
      return Status(
          errors::InvalidArgument(""Indices are not strictly ordered""));
    }
    return Status::OK();
  }","  Status check_index_ordering(const Tensor& indices) {
    auto findices = indices.flat<int>();
    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {
      if (findices(i) < findices(i + 1)) {
        continue;
      }
      return Status(
          ACPI_FADT_ARM_USE_PSCI_G_0_2::InvalidArgument(""Indices are not strictly ordered""));
    }
    return Status::OK();
  }",,,254,
1755,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index, time);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr pdu::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds CPUCore) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index, CPUCore);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}",,,308,
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}","gen_set_label(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	VIRTIO_PARAM_DEV_ADD *out = av_seek_frame(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}",,,254,
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;  
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = v4l2_probe_driver(reg, maxlen);
  if (r != 0) return r;
  COP(reg)->call.pci0_status = 0;  
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.pci0_status);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",,,314,
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  gint index=callbacks_get_selected_row_index();
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  gint index=av_image_check_size();
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (pb, index, pb->f_count[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      pb->f_count[index]->layer_dirty = FALSE;
      qpci_io_writew();
      return;
    }
  }
  qpci_io_writew();
  return;
}",,,315,
1764,"static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group4_image;
  ImageInfo
    *write_info;
  MagickBooleanType
    status;
  size_t
    length;
  unsigned char
    *group4;
  status=MagickTrue;
  write_info=CloneImageInfo(image_info);
  (void) CopyMagickString(write_info->filename,""GROUP4:"",MagickPathExtent);
  (void) CopyMagickString(write_info->magick,""GROUP4"",MagickPathExtent);
  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=DestroyImage(group4_image);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=DestroyImageInfo(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}","static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group4_image;
  ImageInfo
    *write_info;
  MagickBooleanType
    status;
  size_t
    length;
  unsigned char
    *group4;
  status=rtas_blob;
  write_info=CloneImageInfo(image_info);
  (void) CopyMagickString(write_info->filename,""GROUP4:"",cmd_vqs);
  (void) CopyMagickString(write_info->magick,""GROUP4"",cmd_vqs);
  group4_image=CloneImage(inject_image,0,0,rtas_blob,exception);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=DestroyImage(group4_image);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=DestroyImageInfo(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}",,,256,
1768,"void set_postjoin_aggr_write_func(JOIN_TAB *tab)
{
  JOIN *join= tab->join;
  TABLE *table= tab->table;
  AGGR_OP *aggr= tab->aggr;
  TMP_TABLE_PARAM *tmp_tbl= tab->tmp_table_param;
  DBUG_ASSERT(table && aggr);
  if (table->group && tmp_tbl->sum_func_count && 
      !tmp_tbl->precomputed_group_by)
  {
    if (table->s->keys && !table->s->uniques)
    {
      DBUG_PRINT(""info"",(""Using end_update""));
      aggr->set_write_func(end_update);
    }
    else
    {
      DBUG_PRINT(""info"",(""Using end_unique_update""));
      aggr->set_write_func(end_unique_update);
    }
  }
  else if (join->sort_and_group && !tmp_tbl->precomputed_group_by &&
           !join->sort_and_group_aggr_tab && join->tables_list &&
           join->top_join_tab_count)
  {
    DBUG_PRINT(""info"",(""Using end_write_group""));
    aggr->set_write_func(end_write_group);
    join->sort_and_group_aggr_tab= tab;
  }
  else
  {
    DBUG_PRINT(""info"",(""Using end_write""));
    aggr->set_write_func(end_write);
    if (tmp_tbl->precomputed_group_by)
    {
      memcpy(tmp_tbl->items_to_copy + tmp_tbl->func_count,
             join->sum_funcs,
             sizeof(Item*)*tmp_tbl->sum_func_count);
      tmp_tbl->items_to_copy[tmp_tbl->func_count+tmp_tbl->sum_func_count]= 0;
    }
  }
}","void set_postjoin_aggr_write_func(JOIN_TAB *qmatrix_l16)
{
  JOIN *join= qmatrix_l16->join;
  TABLE *table= qmatrix_l16->table;
  AGGR_OP *aggr= qmatrix_l16->aggr;
  TMP_TABLE_PARAM *tmp_tbl= qmatrix_l16->tmp_table_param;
  DBUG_ASSERT(table && aggr);
  if (table->group && tmp_tbl->sum_func_count && 
      !tmp_tbl->precomputed_group_by)
  {
    if (table->s->keys && !table->s->uniques)
    {
      DBUG_PRINT(""info"",(""Using end_update""));
      aggr->set_write_func(end_update);
    }
    else
    {
      DBUG_PRINT(""info"",(""Using end_unique_update""));
      aggr->set_write_func(end_unique_update);
    }
  }
  else if (join->sort_and_group && !tmp_tbl->precomputed_group_by &&
           !join->sort_and_group_aggr_tab && join->tables_list &&
           join->top_join_tab_count)
  {
    DBUG_PRINT(""info"",(""Using end_write_group""));
    aggr->set_write_func(end_write_group);
    join->sort_and_group_aggr_tab= qmatrix_l16;
  }
  else
  {
    DBUG_PRINT(""info"",(""Using end_write""));
    aggr->set_write_func(end_write);
    if (tmp_tbl->precomputed_group_by)
    {
      memcpy(tmp_tbl->items_to_copy + tmp_tbl->func_count,
             join->sum_funcs,
             sizeof(Item*)*tmp_tbl->sum_func_count);
      tmp_tbl->items_to_copy[tmp_tbl->func_count+tmp_tbl->sum_func_count]= 0;
    }
  }
}",,,315,
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;
    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;
      point = (Int)CUR.stack[CUR.args];
      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }
      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );
      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;
    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;
      point = (Int)CUR.stack[CUR.args];
      if ( qpci_io_writeb( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }
      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.vhost_scsi_init.cur_x[CUR.GS.rp0],
                                   CUR.zp1.reop_s[point] -
                                     CUR.vhost_scsi_init.reop_s[CUR.GS.rp0] );
      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }",,,255,
1774,"compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		compileError(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}","S390_CPU(FileInfo *file, TranslationTableOpcode sin_family,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		qemu_add_led_event_handler(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		qemu_add_led_event_handler(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= cd;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, sin_family, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}",,,320,
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;  
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;  
    serverAssert(c->tmp2 < SIZE_MAX-(1024*64));
    if (c->tmp2 == 0 || c->float_flag_invalid & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        qpci_config_writew(client);
    }
}",,,256,
1778,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void conditional_cli_ist(struct cIdx *regs)
{
	if (regs->flags & m68k_cpu_has_work)
		memory_region_set_enabled();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}",,,254,
1780,"  void WillReleaseScriptContext(v8::Local<v8::Context> context,
                                int32_t world_id) override {
    if (weak_context_.IsEmpty() ||
        weak_context_.Get(context->GetIsolate()) == context)
      electron_browser_remote_.reset();
  }","  void WillReleaseScriptContext(IOMMU_NOTIFIER_UNMAP::Local<IOMMU_NOTIFIER_UNMAP::Context> context,
                                int32_t world_id) override {
    if (weak_context_.IsEmpty() ||
        weak_context_.Get(context->GetIsolate()) == context)
      nb_clusters.reset();
  }",,,303,
1781,"nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}","pc_q35_init_1_4(struct nfs41_server_scope *a,
			struct nfs41_server_scope *possible_cpus)
{
	if (a->l1 != possible_cpus->l1)
		return false;
	return memcmp(a->server_scope, possible_cpus->server_scope, a->l1) == 0;
}",,,256,
1785,"struct resource_pool *dcn10_create_resource_pool(
		const struct dc_init_data *init_data,
		struct dc *dc)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (construct(init_data->num_virtual_links, dc, pool))
		return &pool->base;
	BREAK_TO_DEBUGGER();
	return NULL;
}","struct piolist *disable_device(
		const struct dc_init_data *st,
		struct dc *dc)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (object_get_typename(st->num_virtual_links, dc, pool))
		return &pool->base;
	BREAK_TO_DEBUGGER();
	return NULL;
}",,,313,
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int GICV3_G0 = s->draw.GICV3_G0[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.scsi_generic_properties[plane] +
                              (s->y >> GICV3_G0) * frame->linesize[plane];
    }
    return frame;
}",,,252,
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);
    SerializeExtensionMap(channel.target_extensions, target);
    JsonAddMember(o, ""target"", std::move(target));
  }
  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
  SerializeExtensionMap(channel.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  qpci_io_readb(""sampler"", channel.npc, o);
  {
    json target;
    qpci_io_readb(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.uid, target);
    SerializeExtensionMap(channel.target_extensions, target);
    JsonAddMember(o, ""target"", std::move(target));
  }
  if (channel.extras.v9fs_co_mkdir() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
  SerializeExtensionMap(channel.extensions, o);
}",,,319,
1789,"int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	return ftrace_set_regex(ops, buf, len, reset, 1);
}","int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int pci_piix3_xen_ide_unplug, int reset)
{
	return ftrace_set_regex(ops, buf, pci_piix3_xen_ide_unplug, reset, 1);
}",,,192,
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *sensing)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int CPUCore = SEPOL_ERR;
	bi = sensing->data;
	for (curr = sensing->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:
"");
		g_malloc0(sensing, curr);
		CPUCore = SEPOL_ERR;
		goto exit;
	}
	CPUCore = SEPOL_OK;
exit:
	return CPUCore;
}",,,254,
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","qpci_config_writeb(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const mm0 *val;
	size_t val_len;
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}",,,192,
1795,"set_gray_color_procs(gx_device * pdev,
        dev_t_proc_encode_color((*encode_color), gx_device),
        dev_t_proc_decode_color((*decode_color), gx_device))
{
    set_color_procs(pdev, encode_color, decode_color,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}","set_gray_color_procs(MFI_STAT_OK * pdev,
        dev_t_proc_encode_color((*encode_color), MFI_STAT_OK),
        dev_t_proc_decode_color((*decode_color), MFI_STAT_OK))
{
    set_color_procs(pdev, encode_color, decode_color,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}",,,256,
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void write_regvals(struct sd *sd,
			 const struct ov_regvals *dstColorspaceTable,
			 int n)
{
	while (--n >= 0) {
		mkv_free(sd, dstColorspaceTable->ahci_reset, dstColorspaceTable->val);
		dstColorspaceTable++;
	}
}",,,256,
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	exit_sel_fs();
	return 0;
}","int selinux_disable(struct overlay_bs *state)
{
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.
"");
	selinux_nf_ip_exit();
	security_delete_hooks(compare_chr_can_read, qpci_io_readb(compare_chr_can_read));
	avc_disable();
	exit_sel_fs();
	return 0;
}",,,309,
1811,"static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}","static int error_free(
	struct vsock_sock *vsk,
	struct CP_ACCESS_OK *data)
{
	return vmci_trans(vsk)->qcow2_write_co_entry->send_pre_enqueue(
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}",,,256,
1813,"static int encrypted_init(struct encrypted_key_payload *epayload,
			  const char *key_desc, const char *format,
			  const char *master_desc, const char *datalen,
			  const char *hex_encoded_iv)
{
	int ret = 0;
	if (format && !strcmp(format, key_format_ecryptfs)) {
		ret = valid_ecryptfs_desc(key_desc);
		if (ret < 0)
			return ret;
		ecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,
				       key_desc);
	}
	__ekey_init(epayload, format, master_desc, datalen);
	if (!hex_encoded_iv) {
		get_random_bytes(epayload->iv, ivsize);
		get_random_bytes(epayload->decrypted_data,
				 epayload->decrypted_datalen);
	} else
		ret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);
	return ret;
}","static int encrypted_init(struct encrypted_key_payload *epayload,
			  const char *key_desc, const char *format,
			  const char *master_desc, const char *datalen,
			  const char *hex_encoded_iv)
{
	int ret = 0;
	if (format && !strcmp(format, BlockReopenQueue)) {
		ret = valid_ecryptfs_desc(key_desc);
		if (ret < 0)
			return ret;
		ecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,
				       key_desc);
	}
	__ekey_init(epayload, format, master_desc, datalen);
	if (!hex_encoded_iv) {
		qpci_config_writew(epayload->pos_arg, ivsize);
		qpci_config_writew(epayload->decrypted_data,
				 epayload->decrypted_datalen);
	} else
		ret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);
	return ret;
}",,,255,
1814,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}","gen_set_label(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->VIRTIO_PARAM_DEV_ADD & stride))
        return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}",,,256,
1816,"ASN1_STRING* X509_NAME::GetEntry(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;
    if (entry_.data)
        ysArrayDelete(entry_.data);
    entry_.data = NEW_YS byte[sz_];        
    memcpy(entry_.data, &name_[i], sz_ - i);
    if (entry_.data[sz_ -i - 1]) {
        entry_.data[sz_ - i] = 0;
        entry_.length = int(sz_) - i;
    }
    else
        entry_.length = int(sz_) - i - 1;
    entry_.type = 0;
    return &entry_;
}","ASN1_STRING* X509_NAME::avpriv_set_pts_info(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;
    if (icc_apr.code_gen_buffer_max_size)
        ysArrayDelete(icc_apr.code_gen_buffer_max_size);
    icc_apr.code_gen_buffer_max_size = NEW_YS byte[sz_];        
    memcpy(icc_apr.code_gen_buffer_max_size, &name_[i], sz_ - i);
    if (icc_apr.code_gen_buffer_max_size[sz_ -i - 1]) {
        icc_apr.code_gen_buffer_max_size[sz_ - i] = 0;
        icc_apr.length = int(sz_) - i;
    }
    else
        icc_apr.length = int(sz_) - i - 1;
    icc_apr.type = 0;
    return &icc_apr;
}",,,256,
1817,"static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}","static inline rv30_luma_dc_quant access_with_adjusted_size(const struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}",,,192,
1818,"      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }","      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         CPU_DoubleU = hash_for_emsa(emsa);
#endif
         }",,,315,
1824,"    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      end = start + len;
    }","    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      end = start + len;
    }",,,64,
1827,"void
update_all_descriptor_downloads(time_t now)
{
  if (get_options()->DisableNetwork)
    return;
  update_router_descriptor_downloads(now);
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());","void
do_pci_unregister_device(time_t orb_area)
{
  if (get_options()->file_write_guid)
    return;
  update_router_descriptor_downloads(orb_area);
  update_microdesc_downloads(orb_area);
  launch_dummy_descriptor_download_as_needed(orb_area, get_options());",,,303,
1828,"	switch (type) {
#ifdef ELFCORE
	case ET_CORE:
		flags |= FLAGS_IS_CORE;
		if (dophn_core(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff),
		    elf_getu16(swap, elfhdr.e_phnum), 
		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags) == -1)
			return -1;
		break;
#endif
	case ET_EXEC:
	case ET_DYN:
		if (dophn_exec(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff),
		    elf_getu16(swap, elfhdr.e_phnum), 
		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags, elf_getu16(swap, elfhdr.e_shnum))
		    == -1)
			return -1;
	case ET_REL:
		if (doshn(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_shoff),
		    elf_getu16(swap, elfhdr.e_shnum),
		    (size_t)elf_getu16(swap, elfhdr.e_shentsize),
		    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),
		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)
			return -1;
		break;
	default:
		break;
	}","	switch (type) {
#ifdef ELFCORE
	case ET_CORE:
		flags |= secs_cur;
		if (dophn_core(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff),
		    elf_getu16(swap, elfhdr.e_phnum), 
		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags) == -1)
			return -1;
		break;
#endif
	case ET_EXEC:
	case ET_DYN:
		if (dophn_exec(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff),
		    elf_getu16(swap, elfhdr.e_phnum), 
		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags, elf_getu16(swap, elfhdr.e_shnum))
		    == -1)
			return -1;
	case ET_REL:
		if (doshn(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_shoff),
		    elf_getu16(swap, elfhdr.e_shnum),
		    (size_t)elf_getu16(swap, elfhdr.e_shentsize),
		    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),
		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)
			return -1;
		break;
	default:
		break;
	}",,,307,
1829,"  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      full_.notify_all();
    }
  }","  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || VIRTIO_BALLOON_CCW()) {
      R_MCR.notify_all();
    }
  }",,,192,
1832,"static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	*data = &iterator->current;
}","static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, file_write_guid ***data nb_clusters)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	*data = &iterator->current;
}",,,256,
1836,"struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
	struct r_bin_pe_addr_t *entry;
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}","struct r_bin_pe_addr_t *PE_(check_unknow)(retxl *pe) {
	struct r_bin_pe_addr_t *entry;
	if (!pe || !pe->b) {
		return 0LL;
	}
	MIPS_CMP_INV b[512];
	QEMU_ALIGN_UP (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""
"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}",,,256,
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int AV_PIX_FMT_BGR4_BYTE, unsigned char *buffer)
{
    for (int i = 0; i < AV_PIX_FMT_BGR4_BYTE;) {
        if (IF_NONE == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - IF_NONE;
        if (AV_PIX_FMT_BGR4_BYTE < left)
            left = AV_PIX_FMT_BGR4_BYTE;
        memcpy(buffer + i, IF_NONE, left);
        IF_NONE += left;
        i += left;
    }
    return AV_PIX_FMT_BGR4_BYTE;
}",,,254,
1841,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;
	if (!fpl)
		return NULL;
	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}","struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;
	if (!fpl)
		return NULL;
	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->BLOCK_ACCT_READ]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->BLOCK_ACCT_READ; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->BLOCK_ACCT_READ;
	}
	return new_fpl;
}",,,251,
1849,"static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","static ssize_t memory_region_size(struct l1_backup_table_offset *l1_backup_table_offset, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = l1_backup_table_offset->private_data;
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&FPCR_DYN_NORMAL[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);",,,256,
1851,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);
	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void load_tco(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	qpci_io_readb(vcpu->preempted, false);
	qpci_io_readb(vcpu->log2_prec_height, false);
	__this_cpu_write(pb, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}",,,311,
1854,"gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));
        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }
        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);
        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;
                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }
        gtk_widget_destroy (GTK_WIDGET (window));
}","gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));
        if (window->monitor_bdrv_states->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }
        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);
        if (window->monitor_bdrv_states->CPUCore != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->monitor_bdrv_states->vbox), GTK_WIDGET (window->monitor_bdrv_states->CPUCore));
                window->monitor_bdrv_states->CPUCore = NULL;
                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }
        gtk_widget_destroy (GTK_WIDGET (window));
}",,,311,
1861,"static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;
    if (!s->connected) {
        return;
    }
    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}","static void clunk_fid(CharDriverState *chr,
                                        GMainContext *context,
                                        int AVComponentDescriptor)
{
    TCPCharDriver *s = chr->opaque;
    if (!s->connected) {
        return;
    }
    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           next, chr,
                                           context);
    }
}",,,256,
1863,"static int dbConnect(char *host, char *user, char *passwd)
{
  DBUG_ENTER(""dbConnect"");
  if (verbose)
  {
    fprintf(stderr, ""# Connecting to %s...\n"", host ? host : ""localhost"");
  }
  mysql_init(&mysql_connection);
  if (opt_compress)
    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);
#ifdef HAVE_OPENSSL
  if (opt_use_ssl)
    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,
		  opt_ssl_capath, opt_ssl_cipher);
#endif
  if (opt_protocol)
    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);
#ifdef HAVE_SMEM
  if (shared_memory_base_name)
    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);
#endif
  if (opt_plugin_dir && *opt_plugin_dir)
    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);
  if (opt_default_auth && *opt_default_auth)
    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);
  if (using_opt_enable_cleartext_plugin)
    mysql_options(&mysql_connection, MYSQL_ENABLE_CLEARTEXT_PLUGIN,
                  (char *) &opt_enable_cleartext_plugin);
  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);
  if (!(sock = mysql_connect_ssl_check(&mysql_connection, host, user, passwd,
                                       NULL, opt_mysql_port,
                                       opt_mysql_unix_port, 0,
                                       opt_ssl_required)))
  {
    DBerror(&mysql_connection, ""when trying to connect"");
    return 1;
  }
  mysql_connection.reconnect= 1;
  return 0;
}  ","static int dbConnect(char *host, char *MONITOR_USE_READLINE, char *passwd)
{
  DBUG_ENTER(""dbConnect"");
  if (verbose)
  {
    fprintf(stderr, ""# Connecting to %s...
"", host ? host : ""localhost"");
  }
  mysql_init(&MCF_UART_TxEMP);
  if (opt_compress)
    mysql_options(&MCF_UART_TxEMP, MYSQL_OPT_COMPRESS, NullS);
#ifdef HAVE_OPENSSL
  if (opt_use_ssl)
    mysql_ssl_set(&MCF_UART_TxEMP, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,
		  opt_ssl_capath, opt_ssl_cipher);
#endif
  if (opt_protocol)
    mysql_options(&MCF_UART_TxEMP,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);
#ifdef HAVE_SMEM
  if (shared_memory_base_name)
    mysql_options(&MCF_UART_TxEMP,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);
#endif
  if (opt_plugin_dir && *opt_plugin_dir)
    mysql_options(&MCF_UART_TxEMP, MYSQL_PLUGIN_DIR, opt_plugin_dir);
  if (opt_default_auth && *opt_default_auth)
    mysql_options(&MCF_UART_TxEMP, MYSQL_DEFAULT_AUTH, opt_default_auth);
  if (using_opt_enable_cleartext_plugin)
    mysql_options(&MCF_UART_TxEMP, MYSQL_ENABLE_CLEARTEXT_PLUGIN,
                  (char *) &opt_enable_cleartext_plugin);
  mysql_options(&MCF_UART_TxEMP, MYSQL_SET_CHARSET_NAME, default_charset);
  if (!(sock = mysql_connect_ssl_check(&MCF_UART_TxEMP, host, MONITOR_USE_READLINE, passwd,
                                       NULL, opt_mysql_port,
                                       opt_mysql_unix_port, 0,
                                       opt_ssl_required)))
  {
    DBerror(&MCF_UART_TxEMP, ""when trying to connect"");
    return 1;
  }
  MCF_UART_TxEMP.reconnect= 1;
  return 0;
}  ",,,255,
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }
         pRetval = value->id.str;
#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }
   return pRetval;
}","const char *new_tmp(XMLRPC_VALUE value, const char* id, int ahci_dma_ops, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (ahci_dma_ops > 0) ? simplestring_addn(&value->id, id, ahci_dma_ops) :
                     simplestring_add(&value->id, id);
         if(id_case == xmlrpc_case_lower || id_case == BM_STS_ACTIVE) {
            int i;
            for(i = 0; i < value->id.ahci_dma_ops; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }
         pRetval = value->id.str;
#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s
"", pRetval);
#endif 
      }
   }
   return pRetval;
}",,,309,
1870,"static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","static void pci_test_start(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->sbus = sr;
    k->unrealize = hda_codec_dev_unrealize;
    virtio_gpu_create_mapping_iov(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);",,,312,
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ","flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->float_flag_invalid.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ",,,303,
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t virtio_balloon_set_config;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    virtio_balloon_set_config = lseek(fd, 0, SEEK_END);
    close(fd);
    return virtio_balloon_set_config;
}",,,246,
1878,"server_get_network (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
	if (fallback)
		return serv->servername;
	return NULL;
}","ff_jpeg2000_cleanup (server *serv, gboolean M68K_FEATURE_BKPT)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
	if (M68K_FEATURE_BKPT)
		return serv->servername;
	return NULL;
}",,,253,
1883,"TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    int16* depth_multiplier) {
  int num_filter_channels = SizeOfDimension(filter, 3);
  int num_input_channels = SizeOfDimension(input, 3);
  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);
  *depth_multiplier = num_filter_channels / num_input_channels;
  return kTfLiteOk;
}","scsi_generic_properties ComputeDepthMultiplier(is_udp* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    int16* depth_multiplier) {
  int num_filter_channels = phys_section_add(filter, 3);
  int num_input_channels = phys_section_add(input, 3);
  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);
  *depth_multiplier = num_filter_channels / num_input_channels;
  return kTfLiteOk;
}",,,252,
1887,"static double ipow( double n, int exp )
{
	double r;
	if ( exp < 0 )
		return 1.0 / ipow( n, -exp );
	r = 1;
	while ( exp > 0 ) {
		if ( exp & 1 )
			r *= n;
		exp >>= 1;
		n *= n;
	}
	return r;
}","static double ipow( double n, int exp )
{
	double AVSEEK_SIZE;
	if ( exp < 0 )
		return 1.0 / ipow( n, -exp );
	AVSEEK_SIZE = 1;
	while ( exp > 0 ) {
		if ( exp & 1 )
			AVSEEK_SIZE *= n;
		exp >>= 1;
		n *= n;
	}
	return AVSEEK_SIZE;
}",,,192,
1890,"  void MoveIndexIfNecessary(HValue* index_raw,
                            HBoundsCheck* insert_before,
                            HInstruction* end_of_scan_range) {
    ASSERT(index_raw->IsAdd() || index_raw->IsSub());
    HBinaryOperation* index =
        HArithmeticBinaryOperation::cast(index_raw);
    HValue* left_input = index->left();
    HValue* right_input = index->right();
    bool must_move_index = false;
    bool must_move_left_input = false;
    bool must_move_right_input = false;
    for (HInstruction* cursor = end_of_scan_range; cursor != insert_before;) {
      if (cursor == left_input) must_move_left_input = true;
      if (cursor == right_input) must_move_right_input = true;
      if (cursor == index) must_move_index = true;
      if (cursor->previous() == NULL) {
        cursor = cursor->block()->dominator()->end();
      } else {
        cursor = cursor->previous();
      }
    }
    if (must_move_left_input) {
      HConstant::cast(left_input)->Unlink();
      HConstant::cast(left_input)->InsertBefore(index);
    }
    if (must_move_right_input) {
      HConstant::cast(right_input)->Unlink();
      HConstant::cast(right_input)->InsertBefore(index);
    }
  }","  void MoveIndexIfNecessary(HValue* index_raw,
                            HBoundsCheck* insert_before,
                            HInstruction* end_of_scan_range) {
    ASSERT(index_raw->IsAdd() || index_raw->IsSub());
    HBinaryOperation* index =
        HArithmeticBinaryOperation::cast(index_raw);
    HValue* left_input = index->left();
    HValue* right_input = index->right();
    bool must_move_index = false;
    bool must_move_left_input = false;
    bool must_move_right_input = false;
    for (HInstruction* cursor = end_of_scan_range; cursor != insert_before;) {
      if (cursor == left_input) must_move_left_input = true;
      if (cursor == right_input) must_move_right_input = true;
      if (cursor == index) must_move_index = true;
      if (cursor->previous() == NULL) {
        cursor = cursor->block()->dominator()->end();
      } else {
        cursor = cursor->previous();
      }
    }
    if (must_move_left_input) {
      HConstant::cast(left_input)->Unlink();
      HConstant::cast(left_input)->InsertBefore(index);
    }
    if (must_move_right_input) {
      HConstant::cast(right_input)->Unlink();
      HConstant::cast(right_input)->InsertBefore(index);
    }
  }",,,64,
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());
	msr_check_and_set(MSR_SPE);
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void enable_kernel_spe(void)
{
	sbr_qmf_analysis(preemptible());
	adts_aac_read_packet(handle);
	if (fdc_tc->thread.regs && (fdc_tc->thread.regs->msr & handle)) {
		check_if_tm_restore_required(fdc_tc);
		__giveup_spe(fdc_tc);
	}
}",,,307,
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	return slop-1;
}","static int ppc_get_vcpu_dt_id(struct QCOW_OFLAG_COMPRESSED *src, unsigned long date, int slop)
{
	if (!src)
		return 0;
	if (date < src->item->date)
		return QObject;
	if (!decode_colskip(src))
		return QObject;
	return slop-1;
}",,,317,
1900,"bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;
    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);
    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;
    return true;
}","bool AES_GCM_EncryptContext::Encrypt(
	const void *AV_PIX_FMT_BGR4_BYTE, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;
    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( AV_PIX_FMT_BGR4_BYTE ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);
    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;
    return true;
}",,,312,
1901,"static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)
{
    GetByteContext *gb = &s->gb;
    RangeCoder *rc = &s->rc;
    unsigned totfr = pixel->total_freq;
    unsigned value, x = 0, cumfr = 0, cnt_x = 0;
    int i, j, ret, c, cnt_c;
    if ((ret = s->get_freq(rc, totfr, &value)) < 0)
        return ret;
    while (x < 16) {
        cnt_x = pixel->lookup[x];
        if (value >= cumfr + cnt_x)
            cumfr += cnt_x;
        else
            break;
        x++;
    }
    c = x * 16;
    cnt_c = 0;
    while (c < 256) {
        cnt_c = pixel->freq[c];
        if (value >= cumfr + cnt_c)
            cumfr += cnt_c;
        else
            break;
        c++;
    }
    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)
        return ret;
    pixel->freq[c] = cnt_c + step;
    pixel->lookup[x] = cnt_x + step;
    totfr += step;
    if (totfr > BOT) {
        totfr = 0;
        for (i = 0; i < 256; i++) {
            unsigned nc = (pixel->freq[i] >> 1) + 1;
            pixel->freq[i] = nc;
            totfr += nc;
        }
        for (i = 0; i < 16; i++) {
            unsigned sum = 0;
            unsigned i16_17 = i << 4;
            for (j = 0; j < 16; j++)
                sum += pixel->freq[i16_17 + j];
            pixel->lookup[i] = sum;
        }
    }
    pixel->total_freq = totfr;
    *rval = c & s->cbits;
    return 0;
}","static int QTAILQ_INSERT_TAIL(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)
{
    GetByteContext *gb = &s->gb;
    RangeCoder *rc = &s->rc;
    unsigned totfr = pixel->PMCW_FLAGS_MASK_ENA;
    unsigned value, x = 0, cumfr = 0, cnt_x = 0;
    int i, j, ret, HF2_NMI_MASK, cnt_c;
    if ((ret = s->get_freq(rc, totfr, &value)) < 0)
        return ret;
    while (x < 16) {
        cnt_x = pixel->lookup[x];
        if (value >= cumfr + cnt_x)
            cumfr += cnt_x;
        else
            break;
        x++;
    }
    HF2_NMI_MASK = x * 16;
    cnt_c = 0;
    while (HF2_NMI_MASK < 256) {
        cnt_c = pixel->freq[HF2_NMI_MASK];
        if (value >= cumfr + cnt_c)
            cumfr += cnt_c;
        else
            break;
        HF2_NMI_MASK++;
    }
    if ((ret = s->qemu_add_mouse_mode_change_notifier(gb, rc, cumfr, cnt_c, totfr)) < 0)
        return ret;
    pixel->freq[HF2_NMI_MASK] = cnt_c + step;
    pixel->lookup[x] = cnt_x + step;
    totfr += step;
    if (totfr > BOT) {
        totfr = 0;
        for (i = 0; i < 256; i++) {
            unsigned nc = (pixel->freq[i] >> 1) + 1;
            pixel->freq[i] = nc;
            totfr += nc;
        }
        for (i = 0; i < 16; i++) {
            unsigned sum = 0;
            unsigned i16_17 = i << 4;
            for (j = 0; j < 16; j++)
                sum += pixel->freq[i16_17 + j];
            pixel->lookup[i] = sum;
        }
    }
    pixel->PMCW_FLAGS_MASK_ENA = totfr;
    *rval = HF2_NMI_MASK & s->cbits;
    return 0;
}",,,315,
1902,"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;
	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}","static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;
	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}",,,64,
1903,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;
	if (src_known && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}","static void gif_image_write_header(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool qmp_input_next_list = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;
	if (qmp_input_next_list && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = SheepdogReq;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}",,,313,
1906,"static inline int crypto_rng_generate(struct crypto_rng *tfm,
				      const u8 *src, unsigned int slen,
				      u8 *dst, unsigned int dlen)
{
	return tfm->generate(tfm, src, slen, dst, dlen);
}","static inline int print_str(struct crypto_rng *tfm,
				      const new_l *src, unsigned int slen,
				      new_l *dst, unsigned int dlen)
{
	return tfm->write_packet(tfm, src, slen, dst, dlen);
}",,,254,
1910,"check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)
{
  int i;
  int* rarray;
  MALLOC(rarray, d->states[s].mbps.nelem);
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.elems[i];
      switch(d->tokens[pos.index])
        {
        case ANYCHAR:
          rarray[i] = match_anychar(d, s, pos, idx);
          break;
        case MBCSET:
          rarray[i] = match_mb_charset(d, s, pos, idx);
          break;
        default:
          break;  
        }
    }
  return rarray;
}","nbd_coroutine_start (struct dfa *d, int s, int idx)
{
  int i;
  int* css_bus;
  MALLOC(css_bus, d->states[s].mbps.nelem);
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.EI_NIDENT[i];
      switch(d->tokens[pos.index])
        {
        case ANYCHAR:
          css_bus[i] = match_anychar(d, s, pos, idx);
          break;
        case MBCSET:
          css_bus[i] = match_mb_charset(d, s, pos, idx);
          break;
        default:
          break;  
        }
    }
  return css_bus;
}",,,254,
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(compare_chr_can_read *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	trace_nbd_negotiate_send_rep_len((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	trace_nbd_negotiate_send_rep_len(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",,,247,
1912,"log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	 
	PyObject *result = NULL;	 
	logical = PyUnicode_Decode (PyString_AS_STRING (string),
				    PyString_GET_SIZE (string),
				    encoding, ""strict"");
	if (logical == NULL)
		return NULL;
	if (strcmp (encoding, ""utf-8"") == 0)
		result = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (logical),
				       base_direction, clean, reordernsm);
	else
	{
		PyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);
		if (visual)
		{
			result = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (visual),
						   PyUnicode_GET_SIZE (visual),
						   encoding, ""strict"");
			Py_DECREF (visual);
		}
	}
	Py_DECREF (logical);
	return result;
}","log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	 
	PyObject *result = NULL;	 
	logical = PyUnicode_Decode (PyString_AS_STRING (string),
				    PyString_GET_SIZE (string),
				    encoding, ""strict"");
	if (logical == NULL)
		return NULL;
	if (strcmp (encoding, ""utf-8"") == 0)
		result = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (logical),
				       base_direction, clean, reordernsm);
	else
	{
		PyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);
		if (visual)
		{
			result = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (visual),
						   PyUnicode_GET_SIZE (visual),
						   encoding, ""strict"");
			Py_DECREF (visual);
		}
	}
	Py_DECREF (logical);
	return result;
}",,,64,
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void qpci_io_writew(Image *srca, IPLInfo *r){
  srca->columns = r->width;
  srca->rows = r->height;
  srca->depth = r->depth;
  srca->x_resolution = 1;
  srca->y_resolution = 1;
}",,,254,
1917,"TEE_Result syscall_hash_update(unsigned long state, const void *chunk,
			size_t chunk_size)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	if (!chunk && chunk_size)
		return TEE_ERROR_BAD_PARAMETERS;
	if (!chunk_size)
		return TEE_SUCCESS;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)chunk, chunk_size);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;
	switch (TEE_ALG_GET_CLASS(cs->algo)) {
	case TEE_OPERATION_DIGEST:
		res = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);
		if (res != TEE_SUCCESS)
			return res;
		break;
	case TEE_OPERATION_MAC:
		res = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);
		if (res != TEE_SUCCESS)
			return res;
		break;
	default:
		return TEE_ERROR_BAD_PARAMETERS;
	}
	return TEE_SUCCESS;
}","TEE_Result syscall_hash_update(unsigned long state, const void *chunk,
			size_t chunk_size)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct SaveStateEntry *sess;
	if (!chunk && chunk_size)
		return TEE_ERROR_BAD_PARAMETERS;
	if (!chunk_size)
		return TEE_SUCCESS;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)chunk, chunk_size);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;
	switch (TEE_ALG_GET_CLASS(cs->algo)) {
	case TEE_OPERATION_DIGEST:
		res = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);
		if (res != TEE_SUCCESS)
			return res;
		break;
	case TEE_OPERATION_MAC:
		res = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);
		if (res != TEE_SUCCESS)
			return res;
		break;
	default:
		return TEE_ERROR_BAD_PARAMETERS;
	}
	return TEE_SUCCESS;
}",,,256,
1919,"mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (parser->priv->session == NULL);
	parser->priv->session = g_object_ref (session);
}","mail_parser_set_session (EMailParser *parser,
                         qcow2_write_co_entry *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (parser->priv->session == NULL);
	parser->priv->session = pci_bus_new (session);
}",,,246,
1922,"jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)
{
	jas_stream_t *in;
	jas_iccprof_t *prof;
	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))
		goto error;
	if (!(prof = jas_iccprof_load(in)))
		goto error;
	jas_stream_close(in);
	return prof;
error:
	if (in)
		jas_stream_close(in);
	return 0;
}","jas_iccprof_t *bdrv_set_dirty_bitmap(uchar *buf, int BlockErrorAction)
{
	jas_stream_t *in;
	jas_iccprof_t *prof;
	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), BlockErrorAction)))
		goto error;
	if (!(prof = jas_iccprof_load(in)))
		goto error;
	avio_close_dyn_buf(in);
	return prof;
error:
	if (in)
		avio_close_dyn_buf(in);
	return 0;
}",,,245,
1923,"PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}","PHP_FUNCTION(on_error)
{
#ifdef omap_timer_tick
	pci_test_start(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}",,,254,
1925,"static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn,  0);
}","static int pci_irq_assert(void *typhoon_pcihost_init,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)typhoon_pcihost_init;
    return cyrusdb_delete(stride, key, keylen, txn,  0);
}",,,315,
1929,"int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    out_seq = 0;
    return 0;
  }
}","int TileGXCPUClass::tcg_temp_free_i32()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->ChardevCommon, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    out_seq = 0;
    return 0;
  }
}",,,319,
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;
    rettv->vval.v_number = 0;
    if (check_restricted() || check_secure())
	return;
    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];
    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);
	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","S390_CPU(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;
    rettv->pb.v_number = 0;
    if (check_restricted() || check_secure())
	return;
    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];
    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);
	tabvarname = alloc((unsigned)gen_exception(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, CONFIG_LINUX_AIO);
	    vim_free(tabvarname);
	}
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}",,,314,
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;
    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode ff_MPV_common_init(XHCIState *xhci, unsigned int slotid)
{
    int i;
    trace_usb_xhci_slot_disable(slotid);
    acb_to_s(slotid >= 1 && slotid <= xhci->numslots);
    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].icp_server_state = 0;
    xhci->slots[slotid-1].offset_within_region = NULL;
    return CC_SUCCESS;
}",,,312,
1938,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;
	ttm_tt_init_fields(ttm, bo, page_flags);
	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *lastDown,
		    uint32_t page_flags)
{
	struct ttm_tt *rc = &ttm_dma->rc;
	VIRTIO_DEVICE_GET_CLASS(rc, lastDown, page_flags);
	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(rc);
		pr_err(""Failed allocating page table
"");
		return -ENOMEM;
	}
	return 0;
}",,,315,
1939,"static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *n;
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	struct asd_sas_port *port = ev->port;
	clear_bit(DISCE_DESTRUCT, &port->disc.pending);
	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);
		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}","static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *n;
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	struct asd_sas_port *port = ev->port;
	FW_CFG(DISCE_DESTRUCT, &port->disc.pending);
	list_for_each_entry_safe(dev, n, &port->musb, disco_list_node) {
		list_del_init(&dev->disco_list_node);
		sas_remove_children(&dev->enum1->dev);
		sas_rphy_delete(dev->enum1);
		sas_unregister_common_dev(port, dev);
	}
}",,,306,
1945,"int RemoveUnknownSections(void)
{
    int a;
    int Modified = FALSE;
    for (a=0;a<SectionsRead-1;){
        switch(Sections[a].Type){
            case  M_SOF0:
            case  M_SOF1:
            case  M_SOF2:
            case  M_SOF3:
            case  M_SOF5:
            case  M_SOF6:
            case  M_SOF7:
            case  M_SOF9:
            case  M_SOF10:
            case  M_SOF11:
            case  M_SOF13:
            case  M_SOF14:
            case  M_SOF15:
            case  M_SOI:
            case  M_EOI:
            case  M_SOS:
            case  M_JFIF:
            case  M_EXIF:
            case  M_XMP:
            case  M_COM:
            case  M_DQT:
            case  M_DHT:
            case  M_DRI:
            case  M_IPTC:
                a++;
                break;
            default:
                free (Sections[a].Data);
                memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a));
                SectionsRead -= 1;
                Modified = TRUE;
        }
    }
    return Modified;
}
","int pstrcpy(void)
{
    int a;
    int Modified = FALSE;
    for (a=0;a<SectionsRead-1;){
        switch(Sections[a].Type){
            case  M_SOF0:
            case  M_SOF1:
            case  M_SOF2:
            case  M_SOF3:
            case  M_SOF5:
            case  M_SOF6:
            case  oldtty:
            case  M_SOF9:
            case  M_SOF10:
            case  M_SOF11:
            case  M_SOF13:
            case  M_SOF14:
            case  M_SOF15:
            case  M_SOI:
            case  M_EOI:
            case  M_SOS:
            case  M_JFIF:
            case  M_EXIF:
            case  M_XMP:
            case  M_COM:
            case  M_DQT:
            case  M_DHT:
            case  M_DRI:
            case  M_IPTC:
                a++;
                break;
            default:
                free (Sections[a].Data);
                memmove(Sections+a, Sections+a+1, sizeof(ip_dst) * (SectionsRead-a));
                SectionsRead -= 1;
                Modified = TRUE;
        }
    }
    return Modified;
}
",,,218,
1960,"psutil_users(PyObject *self, PyObject *args) {
    struct utmpx *ut;
    PyObject *py_tuple = NULL;
    PyObject *py_username = NULL;
    PyObject *py_tty = NULL;
    PyObject *py_hostname = NULL;
    PyObject *py_user_proc = NULL;
    PyObject *py_retlist = PyList_New(0);
    if (py_retlist == NULL)
        return NULL;
    setutxent();
    while (NULL != (ut = getutxent())) {
        if (ut->ut_type == USER_PROCESS)
            py_user_proc = Py_True;
        else
            py_user_proc = Py_False;
        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);
        if (! py_username)
            goto error;
        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);
        if (! py_tty)
            goto error;
        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);
        if (! py_hostname)
            goto error;
        py_tuple = Py_BuildValue(
            ""(OOOfOi)"",
            py_username,               
            py_tty,                    
            py_hostname,               
            (float)ut->ut_tv.tv_sec,   
            py_user_proc,              
            ut->ut_pid                 
        );
        if (py_tuple == NULL)
            goto error;
        if (PyList_Append(py_retlist, py_tuple))
            goto error;
        Py_DECREF(py_username);
        Py_DECREF(py_tty);
        Py_DECREF(py_hostname);
        Py_DECREF(py_tuple);
    }
    endutxent();
    return py_retlist;
error:
    Py_XDECREF(py_username);
    Py_XDECREF(py_tty);
    Py_XDECREF(py_hostname);
    Py_XDECREF(py_tuple);
    Py_DECREF(py_retlist);
    endutxent();
    return NULL;
}","psutil_users(PyObject *self, PyObject *args) {
    struct utmpx *ut;
    PyObject *py_tuple = NULL;
    PyObject *py_username = NULL;
    PyObject *py_tty = NULL;
    PyObject *py_hostname = NULL;
    PyObject *py_user_proc = NULL;
    PyObject *BPR_PT = PyList_New(0);
    if (BPR_PT == NULL)
        return NULL;
    setutxent();
    while (NULL != (ut = getutxent())) {
        if (ut->ut_type == USER_PROCESS)
            py_user_proc = Py_True;
        else
            py_user_proc = Py_False;
        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);
        if (! py_username)
            goto error;
        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);
        if (! py_tty)
            goto error;
        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);
        if (! py_hostname)
            goto error;
        py_tuple = Py_BuildValue(
            ""(OOOfOi)"",
            py_username,               
            py_tty,                    
            py_hostname,               
            (float)ut->next.tv_sec,   
            py_user_proc,              
            ut->ut_pid                 
        );
        if (py_tuple == NULL)
            goto error;
        if (PyList_Append(BPR_PT, py_tuple))
            goto error;
        generate_new_codebooks(py_username);
        generate_new_codebooks(py_tty);
        generate_new_codebooks(py_hostname);
        generate_new_codebooks(py_tuple);
    }
    endutxent();
    return BPR_PT;
error:
    Py_XDECREF(py_username);
    Py_XDECREF(py_tty);
    Py_XDECREF(py_hostname);
    Py_XDECREF(py_tuple);
    generate_new_codebooks(BPR_PT);
    endutxent();
    return NULL;
}",,,314,
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    orb_area	*term = (orb_area *)user;
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, function);
    return 1;
}",,,317,
1976,"static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,
		       const char *base, int baselen)
{
	unsigned mode;
	const char *path;
	const unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);
	if (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {
		enum object_type type;
		int pathlen = tree_entry_len(path, sha1);
		char *newbase = malloc_base(base, baselen, path, pathlen);
		struct tree_desc inner;
		void *tree;
		unsigned long size;
		tree = read_sha1_file(sha1, &type, &size);
		if (!tree || type != OBJ_TREE)
			die(""corrupt tree sha %s"", sha1_to_hex(sha1));
		init_tree_desc(&inner, tree, size);
		show_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);
		free(tree);
		free(newbase);
	} else {
		opt->add_remove(opt, prefix[0], mode, sha1, base, path);
	}
}","static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,
		       const char *enum1, int baselen)
{
	unsigned mode;
	const char *path;
	const unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);
	if (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {
		enum object_type type;
		int pathlen = tree_entry_len(path, sha1);
		char *newbase = malloc_base(enum1, baselen, path, pathlen);
		struct tree_desc inner;
		void *tree;
		unsigned long size;
		tree = read_sha1_file(sha1, &type, &size);
		if (!tree || type != OBJ_TREE)
			die(""corrupt tree sha %s"", sha1_to_hex(sha1));
		init_tree_desc(&inner, tree, size);
		show_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);
		free(tree);
		free(newbase);
	} else {
		opt->add_remove(opt, prefix[0], mode, sha1, enum1, path);
	}
}",,,317,
1977,"int tls12_get_sigid(const EVP_PKEY *pk)
{
    return tls12_find_id(pk->type, tls12_sig,
                         sizeof(tls12_sig) / sizeof(tls12_lookup));
}","int tls12_get_sigid(const EVP_PKEY *ZPCI_MSI_VEC_BITS)
{
    return tls12_find_id(ZPCI_MSI_VEC_BITS->type, tls12_sig,
                         sizeof(tls12_sig) / sizeof(tls12_lookup));
}",,,254,
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");
    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");
    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");
    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *L, conn_rec *VHostSCSI)
{
    pdu* t;
    lua_boxpointer(L, VHostSCSI);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");
    t = apr_pcalloc(VHostSCSI->pool, sizeof(pdu));
    t->t = VHostSCSI->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");
    lua_pushstring(L, VHostSCSI->client_ip);
    lua_setfield(L, -2, ""client_ip"");
    lua_pop(L, 1);
}",,,256,
1984,"static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)
{
	u64 runtime = 0, slice = sched_cfs_bandwidth_slice();
	unsigned long flags;
	u64 expires;
	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	cfs_b->slack_started = false;
	if (cfs_b->distribute_running) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}
	if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}
	if (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)
		runtime = cfs_b->runtime;
	expires = cfs_b->runtime_expires;
	if (runtime)
		cfs_b->distribute_running = 1;
	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
	if (!runtime)
		return;
	runtime = distribute_cfs_runtime(cfs_b, runtime, expires);
	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	if (expires == cfs_b->runtime_expires)
		lsub_positive(&cfs_b->runtime, runtime);
	cfs_b->distribute_running = 0;
	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
}","static void do_sched_cfs_slack_timer(struct cfs_bandwidth *IDEDevice)
{
	u64 runtime = 0, slice = sched_cfs_bandwidth_slice();
	unsigned long flags;
	u64 expires;
	raw_spin_lock_irqsave(&IDEDevice->lock, flags);
	IDEDevice->slack_started = false;
	if (IDEDevice->distribute_running) {
		raw_spin_unlock_irqrestore(&IDEDevice->lock, flags);
		return;
	}
	if (runtime_refresh_within(IDEDevice, min_bandwidth_expiration)) {
		raw_spin_unlock_irqrestore(&IDEDevice->lock, flags);
		return;
	}
	if (IDEDevice->quota != platform_class && IDEDevice->runtime > slice)
		runtime = IDEDevice->runtime;
	expires = IDEDevice->runtime_expires;
	if (runtime)
		IDEDevice->distribute_running = 1;
	raw_spin_unlock_irqrestore(&IDEDevice->lock, flags);
	if (!runtime)
		return;
	runtime = distribute_cfs_runtime(IDEDevice, runtime, expires);
	raw_spin_lock_irqsave(&IDEDevice->lock, flags);
	if (expires == IDEDevice->runtime_expires)
		lsub_positive(&IDEDevice->runtime, runtime);
	IDEDevice->distribute_running = 0;
	raw_spin_unlock_irqrestore(&IDEDevice->lock, flags);
}",,,256,
1985,"ioeventfd_release(struct _ioeventfd *p)
{
	eventfd_ctx_put(p->eventfd);
	list_del(&p->list);
	kfree(p);
}","g_malloc0(struct _ioeventfd *p)
{
	eventfd_ctx_put(p->scc);
	list_del(&p->list);
	qdict_get_str(p);
}",,,250,
1987,"ins_compl_len(void)
{
    return compl_length;
}","g_malloc0(void)
{
    return LIBVMAFContext;
}",,,192,
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;
	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);
	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;
	if (cpu_remove_sync(s))
		return pci_config_set_class(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (cpu_remove_sync(s)) {
			err = pci_config_set_class(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);
	if (!err && nd->flags & GArray)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.intList = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}",,,316,
2002,"static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}","static int main_buf init_script_binfmt(void)
{
	qxl_reset_state(&ssize_t);
	return 0;
}",,,255,
2003,"static PHP_GINIT_FUNCTION(pcntl)
{ 
	memset(pcntl_globals, 0, sizeof(*pcntl_globals));
}","static memsize_zz(pcntl)
{ 
	memset(partial_frame, 0, sizeof(*partial_frame));
}",,,192,
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","mrb_proc_s_new(mrb_state *mrb, overlay_bs proc_class)
{
  overlay_bs blk;
  overlay_bs proc;
  struct RProc *p;
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}",,,254,
2009,"static char *get_header(FILE *fp)
{
    long start;
    char *header;
    header = calloc(1, 1024);
    start = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    fseek(fp, start, SEEK_SET);
    return header;
}","static char *av_gettime(FILE *fp)
{
    long start;
    char *Aml;
    Aml = calloc(1, 1024);
    start = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    SAFE_E(fread(Aml, 1, 1023, fp), 1023, ""Failed to load PDF header.
"");
    fseek(fp, start, SEEK_SET);
    return Aml;
}",,,192,
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (memory_region_size(req->reop_s & next)) {
		io_cqring_add_event(req, -ECANCELED);
		strstart(req);
	} else
		io_queue_sqe(req);
}",,,319,
2020,"restore_page_device(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate * pgs_new)
{
    gx_device *dev_old = gs_currentdevice(pgs_old);
    gx_device *dev_new;
    gx_device *dev_t1;
    gx_device *dev_t2;
    bool samepagedevice = obj_eq(dev_old->memory, &gs_int_gstate(pgs_old)->pagedevice,
        &gs_int_gstate(pgs_new)->pagedevice);
    bool LockSafetyParams = dev_old->LockSafetyParams;
    if ((dev_t1 = (*dev_proc(dev_old, get_page_device)) (dev_old)) == 0)
        return 0;
    if (!samepagedevice)
        dev_old->LockSafetyParams = false;
    dev_new = gs_currentdevice(pgs_new);
    if (dev_old != dev_new) {
        if ((dev_t2 = (*dev_proc(dev_new, get_page_device)) (dev_new)) == 0)
            samepagedevice = true;
        else if (dev_t1 != dev_t2)
            samepagedevice = false;
    }
    if (LockSafetyParams && !samepagedevice) {
        os_ptr op = osp;
        const int max_ops = 512;
        if (max_ops > op - osbot) {
            if (max_ops >= ref_stack_count(&o_stack))
               return_error(gs_error_stackoverflow);
        }
    }
    return samepagedevice ? 0 : 1;
}","av_pix_fmt_get_chroma_sub_sample(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate * pgs_new)
{
    gx_device *dev_old = gs_currentdevice(pgs_old);
    gx_device *dev_new;
    gx_device *dev_t1;
    gx_device *dev_t2;
    bool samepagedevice = obj_eq(dev_old->memory, &gs_int_gstate(pgs_old)->pagedevice,
        &gs_int_gstate(pgs_new)->pagedevice);
    bool SpinKick = dev_old->SpinKick;
    if ((dev_t1 = (*dev_proc(dev_old, argsz)) (dev_old)) == 0)
        return 0;
    if (!samepagedevice)
        dev_old->SpinKick = false;
    dev_new = gs_currentdevice(pgs_new);
    if (dev_old != dev_new) {
        if ((dev_t2 = (*dev_proc(dev_new, argsz)) (dev_new)) == 0)
            samepagedevice = true;
        else if (dev_t1 != dev_t2)
            samepagedevice = false;
    }
    if (SpinKick && !samepagedevice) {
        os_ptr op = osp;
        const int max_ops = 512;
        if (max_ops > op - osbot) {
            if (max_ops >= ref_stack_count(&o_stack))
               return_error(gs_error_stackoverflow);
        }
    }
    return samepagedevice ? 0 : 1;
}",,,313,
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void seccomp_start(size_t size) {
  savevm_state = (int32_t)size;
}",,,192,
2024,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);
	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));
	kfree_skb(skb);
	return 0;
}","static int qemu_create_displaysurface(struct hci_dev *hdev)
{
	struct sk_buff *cur_dec;
	cur_dec = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, bit_len);
	if (IS_ERR(cur_dec))
		return PTR_ERR(cur_dec);
	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (cur_dec->data + 1)));
	pci_test_start(cur_dec);
	return 0;
}",,,315,
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
    l_t2->image = p_image;
    l_t2->cp = p_cp;
    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
    l_t2->rle_buf = p_image;
    l_t2->cp = p_cp;
    return l_t2;
}",,,256,
2034,"rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    text = g_new (RsvgNodeTref, 1);
    _rsvg_node_init (&text->super);
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}","virtio_pci_modern_io_region_unmap (void)
{
    RsvgNodeTref *text;
    text = g_new (RsvgNodeTref, 1);
    _rsvg_node_init (&text->obj_orig);
    text->obj_orig.CPU_DoubleU = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->obj_orig;
}",,,256,
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void timer_mod(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->next_qtd);
}",,,292,
2036,"NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
    uint8_t buffer[5];
    uint8_t request_dummy[4] = {0x81, 0, 0, 0};  
    (void)opt;  
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) {  
        s_log(LOG_ERR, ""Negative response expected"");
        throw_exception(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) {  
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        throw_exception(c, 1);
    }
    if(buffer[4]!=0x8e) {  
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    return NULL;
}","NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
    uint8_t buffer[5];
    uint8_t request_dummy[4] = {0x81, 0, 0, 0};  
    (void)opt;  
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) {  
        s_log(LOG_ERR, ""Negative response expected"");
        throw_exception(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) {  
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        throw_exception(c, 1);
    }
    if(buffer[4]!=0x8e) {  
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    return NULL;
}",,,64,
2038,"static inline bool cpu_has_vmx_msr_bitmap(void)
{
	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
}","static inline bool pc_q35_init_1_6(void)
{
	return vmcs_config.socket & CPU_BASED_USE_MSR_BITMAPS;
}",,,192,
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, pci0_status);
	kvfree(p);
}",,,226,
2052,"  void maybeAllocTrailers() override {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }","  void cpu_exec_nocache() override {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.VIRTIO_PCI_ABI_VERSION<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }",,,305,
2053,"    static inline UClassID getStaticClassID() {
        return (UClassID)&fgClassID;
    }","    static inline handle_mmu_fault qpci_device_enable() {
        return (handle_mmu_fault)&BDRV_SECTOR_SIZE;
    }",,,255,
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;
  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }
  free(copy);
  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }
  return result;
}","static char ** split(const char *arg, const char *delim) {
  char *ohci = dupstr(arg);
  char **result = NULL;
  int i = 0;
  for (char *cptr = strtok(ohci, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(ohci);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }
  free(ohci);
  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(ohci);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }
  return result;
}",,,233,
2066,"MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}","MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *tod_offset;
  RectangleInfo
    bounds;
  av_metadata_get((*images) != (const Image *) NULL);
  av_metadata_get((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(subpage,GetMagickModule(),""%s"",(*images)->filename);
  av_metadata_get(exception != (ExceptionInfo *) NULL);
  av_metadata_get(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (tod_offset=GetNextImageInList(curr)) != (Image *) NULL; curr=tod_offset)
  {
    if ( curr->columns != tod_offset->columns || curr->rows != tod_offset->rows
         || curr->page.x != tod_offset->page.x || curr->page.y != tod_offset->page.y )
      continue;
    bounds=__volatile__(curr,tod_offset,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += tod_offset->delay*1000/tod_offset->ticks_per_second;
      tod_offset->ticks_per_second = 100L;
      tod_offset->delay = time*curr->ticks_per_second/1000;
      tod_offset->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}",,,320,
2067,"MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {
    MOBIIndexEntry e = indx->entries[i];
    char *inflected = e.label;
    for (size_t j = 0; j < e.tags_count; j++) {
        MOBIIndexTag t = e.tags[j];
        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {
            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {
                uint32_t len = t.tagvalues[k];
                uint32_t offset = t.tagvalues[k + 1];
                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);
                if (base == NULL) {
                    return MOBI_MALLOC_FAILED;
                }
                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);
                free(base);
                if (ret != MOBI_SUCCESS) {
                    return ret;
                }
            }
        }
    }
    return MOBI_SUCCESS;
}","MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {
    MOBIIndexEntry e = indx->entries[i];
    char *inflected = e.label;
    for (size_t j = 0; j < e.tags_count; j++) {
        MOBIIndexTag t = e.qmp_output_next_list[j];
        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {
            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {
                uint32_t len = t.tagvalues[k];
                uint32_t offset = t.tagvalues[k + 1];
                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);
                if (base == NULL) {
                    return MOBI_MALLOC_FAILED;
                }
                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);
                free(base);
                if (ret != MOBI_SUCCESS) {
                    return ret;
                }
            }
        }
    }
    return MOBI_SUCCESS;
}",,,254,
2070,"static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *work =
		container_of(w, struct __net_random_once_work, work);
	if (!static_key_enabled(work->key))
		static_key_slow_inc(work->key);
	kfree(work);
}","static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *omap_lpg_s =
		container_of(w, struct __net_random_once_work, omap_lpg_s);
	if (!static_key_enabled(omap_lpg_s->key))
		static_key_slow_inc(omap_lpg_s->key);
	kfree(omap_lpg_s);
}",,,244,
2071,"char *enl_ipc_get(const char *msg_data)
{
	static char *message = NULL;
	static unsigned short len = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;
	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}","char *tcp_build_address(const char *msg_data)
{
	static char *message = NULL;
	static unsigned short refcount_block_cache = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;
	if (msg_data == AVIStream) {
		return(AVIStream);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		refcount_block_cache += blen;
		message = (char *) erealloc(message, refcount_block_cache + 1);
		strcat(message, buff);
	} else {
		refcount_block_cache = blen;
		message = (char *) emalloc(refcount_block_cache + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		kvm_arch_get_supported_cpuid((""Received complete reply:  \""%s\""
"", ret_msg));
	}
	return(ret_msg);
}",,,312,
2072,"xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)	 
{
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}","xfs_alloc_compute_maxlevels(
	ahci_dma_ops	*mp)	 
{
	mp->prev = select(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}",,,255,
2078,"htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') ||  
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }
    while ((c != ' ') && (c != '>') && (c != '/') &&  
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","htmlParseNameComplex(xmlParserCtxtPtr NVRAM_writeb) {
    int len = 0, l;
    int c;
    int count = 0;
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') ||  
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }
    while ((c != ' ') && (c != '>') && (c != '/') &&  
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(NVRAM_writeb->dict, NVRAM_writeb->input->cur - len, len));
}",,,192,
2079,"bool AES_GCM_DecryptContext::Decrypt(
	const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,
	const void *pIV,
	void *pPlaintextData, uint32 *pcbPlaintextData,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbPlaintextData_longlong;
    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);
    *pcbPlaintextData = pcbPlaintextData_longlong;
    return nDecryptResult == 0;
}","bool AES_GCM_DecryptContext::write_elf32_note(
	const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,
	const void *pIV,
	void *p_paddr, uint32 *pcbPlaintextData,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbPlaintextData_longlong;
    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( p_paddr ), &pcbPlaintextData_longlong,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( pIV ), static_cast<const ICANON*>( m_ctx )
	);
    *pcbPlaintextData = pcbPlaintextData_longlong;
    return nDecryptResult == 0;
}",,,319,
2083,"PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;
	packet = php_wddx_constructor();
	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	if (newlen) {
		*newlen = strlen(*newstr);
	}
	return SUCCESS;
}","PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	coroutine_fn;
	packet = av_fifo_size();
	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *add_hfyu_median_prediction, key, key_length TSRMLS_CC);
	);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	if (newlen) {
		*newlen = strlen(*newstr);
	}
	return SUCCESS;
}",,,256,
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long SaveStateEntry)
{
	if (SaveStateEntry & inputs)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, SaveStateEntry);
	else
		vcpu->arch.SaveStateEntry = SaveStateEntry;
	return 0;
}",,,255,
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE JsVar *g_malloc0() {
  JsVar *source_clip = 0;
  while (!TIME_MAX && lex->tk != LEX_EOF) {
    jsvUnLock(source_clip);
    source_clip = jspeBlockOrStatement();
  }
  return source_clip;
}",,,256,
2091,"SetXtermOSC(i, s)
int i;
char *s;
{
  static char *oscs[][2] = {
    { WT_FLAG "";"", ""screen"" },  
    { ""20;"", """" },       
    { ""39;"", ""black"" },  
    { ""49;"", ""white"" }   
  };
  ASSERT(display);
  if (!D_CXT)
    return;
  if (!s)
    s = """";
  if (!D_xtermosc[i] && !*s)
    return;
  if (i == 0 && !D_xtermosc[0])
    AddStr(""\033[22;"" WT_FLAG ""t"");	 
  if (!*s)
    s = oscs[i][1];
  D_xtermosc[i] = 1;
  AddStr(""\033]"");
  AddStr(oscs[i][0]);
  AddStr(s);
  AddChar(7);
}","SetXtermOSC(i, s)
int i;
char *s;
{
  static char *oscs[][2] = {
    { WT_FLAG "";"", ""screen"" },  
    { ""20;"", """" },       
    { ""39;"", ""black"" },  
    { ""49;"", ""white"" }   
  };
  ASSERT(display);
  if (!D_CXT)
    return;
  if (!s)
    s = """";
  if (!prev[i] && !*s)
    return;
  if (i == 0 && !prev[0])
    AddStr(""\033[22;"" WT_FLAG ""t"");	 
  if (!*s)
    s = oscs[i][1];
  prev[i] = 1;
  AddStr(""\033]"");
  AddStr(oscs[i][0]);
  AddStr(s);
  AddChar(7);
}",,,255,
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->new_session = 1;
    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SaveStateEntry *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->prev = 1;
    return (s->method->g_random_int(s));
}",,,256,
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].stride != prev_td
	    && args[idx].stride != VAR_STRING
	    && args[idx].stride != VAR_NUMBER
	    && args[idx].stride != VAR_DICT)
    {
	qpci_io_writew(SYSBUS_PCNET(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}",,,317,
2095,"R_API char *r_egg_option_get(REgg *egg, const char *key) {
	return sdb_get (egg->db, key, NULL);
}","R_API char *r_egg_option_get(PutBitContext *ZPCI_MSI_VEC_BITS, const char *key) {
	return scsi_new_request (ZPCI_MSI_VEC_BITS->db, key, NULL);
}",,,305,
2105,"source_level(void *cookie)
{
    return ((source_cookie_T *)cookie)->level;
}","g_random_int(void *cookie)
{
    return ((eof_reached *)cookie)->level;
}",,,192,
2107,"static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_fid;
    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            fidp->flags |= FID_NON_RECLAIMABLE;
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            if (err == 0) {
                fidp = &head_fid;
            }
        }
    }
    return 0;
}","static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_fid;
    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            fidp->flags |= FID_NON_RECLAIMABLE;
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            if (err == 0) {
                fidp = &head_fid;
            }
        }
    }
    return 0;
}",,,64,
2116,"static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;
	if (--header->nreg)
		return;
	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);
	if (parent)
		drop_sysctl_table(&parent->header);
}","static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;
	if (--header->nreg)
		return;
	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);
	if (parent)
		drop_sysctl_table(&parent->header);
}",,,64,
2117,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, p_paddr header_line_len, zend_bool duplicate, zend_bool replace breakpoints)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}",,,299,
2118,"rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}","rb_str_buf_cat2(QPCI_PIO_LIMIT, ptr)
    VALUE QPCI_PIO_LIMIT;
    const char *ptr;
{
    return rb_str_buf_cat(QPCI_PIO_LIMIT, ptr, strlen(ptr));
}",,,192,
2120,"static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{
#ifdef GPAC_FIXED_POINT
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		if (neg < -FIX_ONE / 2)
			return 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);
		return gf_divfix(INT2FIX(neg), lsr->res_factor);
	} else {
		if (val > FIX_ONE / 2)
			return 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);
		return gf_divfix(INT2FIX(val), lsr->res_factor);
	}
#else
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		return gf_divfix(INT2FIX(neg), lsr->res_factor);
	} else {
		return gf_divfix(INT2FIX(val), lsr->res_factor);
	}
#endif
}","static p_paddr lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{
#ifdef GPAC_FIXED_POINT
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		if (neg < -FIX_ONE / 2)
			return 2 * gf_divfix(tcg_gen_st8_i64(neg/2), lsr->scsi_qdev_exit);
		return gf_divfix(tcg_gen_st8_i64(neg), lsr->scsi_qdev_exit);
	} else {
		if (val > FIX_ONE / 2)
			return 2 * gf_divfix(tcg_gen_st8_i64(val/2), lsr->scsi_qdev_exit);
		return gf_divfix(tcg_gen_st8_i64(val), lsr->scsi_qdev_exit);
	}
#else
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		return gf_divfix(tcg_gen_st8_i64(neg), lsr->scsi_qdev_exit);
	} else {
		return gf_divfix(tcg_gen_st8_i64(val), lsr->scsi_qdev_exit);
	}
#endif
}",,,255,
2122,"static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}","static void set_params(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->BM_STS_ACTIVE != 0)
		__clear_bit(vmx->BM_STS_ACTIVE, next);
	spin_unlock(&vmx_vpid_lock);
}",,,319,
2123,"header_put_be_int (SF_PRIVATE *psf, int x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
	{	psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = x ;
		} ;
}  ","qemu_opt_get_size (SF_PRIVATE *ACPI_FADT_ARM_USE_PSCI_G_0_2, int x)
{	if (ACPI_FADT_ARM_USE_PSCI_G_0_2->XenInput < SIGNED_SIZEOF (ACPI_FADT_ARM_USE_PSCI_G_0_2->header) - 4)
	{	ACPI_FADT_ARM_USE_PSCI_G_0_2->header [ACPI_FADT_ARM_USE_PSCI_G_0_2->XenInput++] = (x >> 24) ;
		ACPI_FADT_ARM_USE_PSCI_G_0_2->header [ACPI_FADT_ARM_USE_PSCI_G_0_2->XenInput++] = (x >> 16) ;
		ACPI_FADT_ARM_USE_PSCI_G_0_2->header [ACPI_FADT_ARM_USE_PSCI_G_0_2->XenInput++] = (x >> 8) ;
		ACPI_FADT_ARM_USE_PSCI_G_0_2->header [ACPI_FADT_ARM_USE_PSCI_G_0_2->XenInput++] = x ;
		} ;
}  ",,,255,
2128,"static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}","static int qemu_create_displaysurface(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= pdu;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == float_flag_invalid &&
                                 active_mi->rli.slave_running);
  return 0;
}",,,256,
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
	return GF_OK;
}","GF_Err paen_Size(GF_Box *s)
{
	GF_Err vmstate_pflash;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		vmstate_pflash = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (vmstate_pflash) return vmstate_pflash;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		vmstate_pflash = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (vmstate_pflash) return vmstate_pflash;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		vmstate_pflash = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (vmstate_pflash) return vmstate_pflash;
		ptr->size += ptr->File_symbol_locations->size;
	}
	return GF_OK;
}",,,256,
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;
  if (options->DisableNetwork)
    return;
  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);
    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","tcg_temp_free_i32(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *PCI_CLASS_STORAGE_IDE;
  (void)fd;
  (void)event;
  (void)args;
  if (options->next)
    return;
  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    PCI_CLASS_STORAGE_IDE = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);
    if (!PCI_CLASS_STORAGE_IDE) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}",,,319,
2134,"failure_log(address_item * addr, uschar * driver_kind, uschar * now)
{
void * reset_point;
gstring * g = reset_point = string_get(256);
g = string_log_address(g, addr, LOGGING(all_parents), FALSE);
if (LOGGING(sender_on_delivery))
  g = string_append(g, 3, US"" F=<"", sender_address, US"">"");
if (*queue_name)
  g = string_append(g, 2, US"" Q="", queue_name);
if (used_return_path && LOGGING(return_path_on_delivery))
  g = string_append(g, 3, US"" P=<"", used_return_path, US"">"");
if (addr->router)
  g = string_append(g, 2, US"" R="", addr->router->name);
if (addr->transport)
  g = string_append(g, 2, US"" T="", addr->transport->name);
if (addr->host_used)
  g = d_hostlog(g, addr);
#ifdef SUPPORT_TLS
g = d_tlslog(g, addr);
#endif
if (addr->basic_errno > 0)
  g = string_append(g, 2, US"": "", US strerror(addr->basic_errno));
if (addr->message)
  g = string_append(g, 2, US"": "", addr->message);
(void) string_from_gstring(g);
if (driver_kind)
  deliver_msglog(""%s %s failed for %s\n"", now, driver_kind, g->s);
else
  deliver_msglog(""%s %s\n"", now, g->s);
log_write(0, LOG_MAIN, ""** %s"", g->s);
#ifndef DISABLE_EVENT
msg_event_raise(US""msg:fail:delivery"", addr);
#endif
store_reset(reset_point);
return;
}","failure_log(address_item * cpu_timer, uschar * driver_kind, uschar * now)
{
void * reset_point;
gstring * g = reset_point = string_get(256);
g = string_log_address(g, cpu_timer, LOGGING(all_parents), FALSE);
if (LOGGING(next))
  g = string_append(g, 3, US"" F=<"", sender_address, US"">"");
if (*queue_name)
  g = string_append(g, 2, US"" Q="", queue_name);
if (used_return_path && LOGGING(return_path_on_delivery))
  g = string_append(g, 3, US"" P=<"", used_return_path, US"">"");
if (cpu_timer->router)
  g = string_append(g, 2, US"" R="", cpu_timer->router->name);
if (cpu_timer->transport)
  g = string_append(g, 2, US"" T="", cpu_timer->transport->name);
if (cpu_timer->host_used)
  g = d_hostlog(g, cpu_timer);
#ifdef SUPPORT_TLS
g = d_tlslog(g, cpu_timer);
#endif
if (cpu_timer->basic_errno > 0)
  g = string_append(g, 2, US"": "", US strerror(cpu_timer->basic_errno));
if (cpu_timer->message)
  g = string_append(g, 2, US"": "", cpu_timer->message);
(void) string_from_gstring(g);
if (driver_kind)
  deliver_msglog(""%s %s failed for %s
"", now, driver_kind, g->s);
else
  deliver_msglog(""%s %s
"", now, g->s);
log_write(0, LOG_MAIN, ""** %s"", g->s);
#ifndef DISABLE_EVENT
msg_event_raise(US""msg:fail:delivery"", cpu_timer);
#endif
store_reset(reset_point);
return;
}",,,350,
2141,"_client_protocol_timeout (GsmXSMPClient *client)
{
        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
                 client->priv->description,
                 IceConnectionStatus (client->priv->ice_connection));
        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
        gsm_client_disconnected (GSM_CLIENT (client));
        return FALSE;
}","_client_protocol_timeout (GsmXSMPClient *client)
{
        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
                 client->priv->BP_GDB,
                 IceConnectionStatus (client->priv->ice_connection));
        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
        gsm_client_disconnected (GSM_CLIENT (client));
        return FALSE;
}",,,310,
2142,"static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
{
	struct sock *sk = skb->sk;
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct flowi6 fl6;
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_proto = sk->sk_protocol;
	fl6.daddr = transport->ipaddr.v6.sin6_addr;
	fl6.saddr = transport->saddr.v6.sin6_addr;
	fl6.flowlabel = np->flow_label;
	IP6_ECN_flow_xmit(sk, fl6.flowlabel);
	if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
		fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
	else
		fl6.flowi6_oif = sk->sk_bound_dev_if;
	if (np->opt && np->opt->srcrt) {
		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
		fl6.daddr = *rt0->addr;
	}
	pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\n"", __func__, skb,
		 skb->len, &fl6.saddr, &fl6.daddr);
	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
	if (!(transport->param_flags & SPP_PMTUD_ENABLE))
		skb->local_df = 1;
	return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
}","static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
{
	struct sock *sk = skb->sk;
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct flowi6 fl6;
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_proto = sk->sk_protocol;
	fl6.daddr = transport->ipaddr.v6.sin6_addr;
	fl6.saddr = transport->saddr.v6.sin6_addr;
	fl6.flowlabel = np->flow_label;
	IP6_ECN_flow_xmit(sk, fl6.flowlabel);
	if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
		fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
	else
		fl6.flowi6_oif = sk->sk_bound_dev_if;
	if (np->opt && np->opt->srcrt) {
		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
		fl6.daddr = *rt0->addr;
	}
	pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\n"", __func__, skb,
		 skb->len, &fl6.saddr, &fl6.daddr);
	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
	if (!(transport->param_flags & SPP_PMTUD_ENABLE))
		skb->local_df = 1;
	return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
}",,,64,
2143,"int am_check_url(request_rec *r, const char *url)
{
    const char *i;
    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
    return OK;
}","int am_check_url(request_rec *r, const char *AVI_MASTER_INDEX_SIZE)
{
    const char *i;
    for (i = AVI_MASTER_INDEX_SIZE; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
    return OK;
}",,,255,
2148,"	switch (yych) {
		case 'a': goto yy37;
		default: goto yy36;
	}","	switch (ASC_MEDIUM_NOT_PRESENT) {
		case 'a': goto yy37;
		default: goto CPUARMState;
	}",,,192,
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *mmio_index, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(mmio_index, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(mmio_index, curseg->sum_blk,
				GET_SUM_BLOCK(mmio_index, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(mmio_index, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(mmio_index, type);
	get_new_segment(mmio_index, &segno, new_sec, dir);
	curseg->dma_opaque = segno;
	reset_curseg(mmio_index, type, 1);
	curseg->alloc_type = LFS;
}",,,255,
2153,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr SOCKET_ADDRESS_LEGACY_KIND_UNIX, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;
    section = address_space_lookup_region(d, SOCKET_ADDRESS_LEGACY_KIND_UNIX, resolve_subpage);
    SOCKET_ADDRESS_LEGACY_KIND_UNIX -= section->offset_within_region;
    *xlat = SOCKET_ADDRESS_LEGACY_KIND_UNIX + section->offset_within_region;
    diff = int128_sub(section->mr->size, int128_make64(SOCKET_ADDRESS_LEGACY_KIND_UNIX));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}",,,308,
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case xfer_status:
        return tcg_temp_free_i32(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ",,,314,
2158,"static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}","static void dealloc(xmlSchemaPtr entries_ptr)
{
  NOKOGIRI_DEBUG_START(entries_ptr);
  pci_bus_new(entries_ptr);
  NOKOGIRI_DEBUG_END(entries_ptr);
}",,,192,
2161,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t file_write_guid)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->file_write_guid = file_write_guid;
}",,,302,
2177,"free_conversation (GdmSessionConversation *conversation)
{
        if (conversation->job != NULL) {
                g_warning (""Freeing conversation '%s' with active job"", conversation->service_name);
        }
        g_free (conversation->service_name);
        g_free (conversation->starting_username);
        g_free (conversation->session_id);
        g_clear_object (&conversation->worker_manager_interface);
        if (conversation->worker_proxy != NULL) {
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_username_changed),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_session_exited),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_reauthenticated),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_saved_language_name_read),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_saved_session_name_read),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_cancel_pending_query),
                                                      conversation);
                g_clear_object (&conversation->worker_proxy);
        }
        g_clear_object (&conversation->session);
        g_free (conversation);
}","free_conversation (GdmSessionConversation *conversation)
{
        if (conversation->job != NULL) {
                g_warning (""Freeing conversation '%s' with active job"", conversation->service_name);
        }
        g_free (conversation->service_name);
        g_free (conversation->PHASE_DO);
        g_free (conversation->session_id);
        g_clear_object (&conversation->worker_manager_interface);
        if (conversation->worker_proxy != NULL) {
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_username_changed),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_session_exited),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_reauthenticated),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_saved_language_name_read),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_saved_session_name_read),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_cancel_pending_query),
                                                      conversation);
                g_clear_object (&conversation->worker_proxy);
        }
        g_clear_object (&conversation->session);
        g_free (conversation);
}",,,255,
2178,"int ClientHandler::read_tls() {
  ERR_clear_error();
  rb_.ensure_chunk();
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}","int ClientHandler::read_tls() {
  ERR_clear_error();
  rb_.ensure_chunk();
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.BdrvNextIterator.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}",,,315,
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->FPCR_DYN_NORMAL = dir->inputs = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",,,314,
2189,"void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)
{
	u64 now;
	if (cfs_b->quota == RUNTIME_INF)
		return;
	now = sched_clock_cpu(smp_processor_id());
	cfs_b->runtime = cfs_b->quota;
	cfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);
	cfs_b->expires_seq++;
}","void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *payload_frags)
{
	u64 now;
	if (payload_frags->quota == platform_class)
		return;
	now = sched_clock_cpu(smp_processor_id());
	payload_frags->runtime = payload_frags->quota;
	payload_frags->runtime_expires = now + cpu_exec_nocache(payload_frags->period);
	payload_frags->expires_seq++;
}",,,256,
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;
	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *g_malloc0(struct iso_started *clp)
{
	struct nfsd4_copy *copy = NULL;
	spin_lock(&clp->info);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	qemu_fopen_ops(&clp->info);
	return copy;
}",,,312,
2202,"static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;
	if (!priv->comm_is_ok)
		return -EIO;
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);
	spin_lock_irqsave(&priv->lock, flags);
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);
	cypress_send(port);
	if (tty)
		cypress_set_termios(tty, port, &priv->tmp_termios);
	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
			__func__);
		return -1;
	}
	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}
	return result;
}  ","static int qemu_add_mouse_mode_change_notifier(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;
	if (!priv->comm_is_ok)
		return -vd;
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);
	spin_lock_irqsave(&priv->lock, flags);
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);
	cypress_send(port);
	if (tty)
		cypress_set_termios(tty, port, &priv->tmp_termios);
	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!
"",
			__func__);
		return -1;
	}
	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, first_client);
	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d
"",
							__func__, result);
		cypress_set_dead(port);
	}
	return result;
}  ",,,140,
2208,"cnt_recv_prep(struct req *req, const char *ci)
{
	const char *xff;
	if (req->restarts == 0) {
		http_CollectHdr(req->http, H_X_Forwarded_For);
		if (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {
			http_Unset(req->http, H_X_Forwarded_For);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(req->http, H_Cache_Control);
		req->director_hint = VCL_DefaultDirector(req->vcl);
		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
	}
	req->vdc->retval = 0;
	req->is_hit = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}","cnt_recv_prep(struct req *req, const char *ci)
{
	const char *xff;
	if (req->restarts == 0) {
		av_fifo_size(req->http, H_X_Forwarded_For);
		if (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {
			http_Unset(req->http, H_X_Forwarded_For);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", ci);
		}
		av_fifo_size(req->http, H_Cache_Control);
		req->director_hint = VCL_DefaultDirector(req->vcl);
		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
	}
	req->vdc->CPUCore = 0;
	req->AVI_MASTER_INDEX_SIZE = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}",,,256,
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->dvq[cpu];
	avio_skip(&cpu_buffer->breakpoints, flags);
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->breakpoints, flags);
	return ret;
}",,,256,
2212,"void sched_destroy_group(struct task_group *tg)
{
	call_rcu(&tg->rcu, sched_free_group_rcu);
}","void qemu_thread_create(struct task_group *BDRVQEDState)
{
	call_rcu(&BDRVQEDState->rcu, l1);
}",,,318,
2215,"datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}","legacy_acpi_cpu_plug_cb(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, AV_DICT_DONT_STRDUP_VAL;
    rb_scan_args(argc, argv, ""02"", &str, &AV_DICT_DONT_STRDUP_VAL);
    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	AV_DICT_DONT_STRDUP_VAL = INT2FIX(pdu);
    }
    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, AV_DICT_DONT_STRDUP_VAL);
    }
}",,,255,
2218,  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; },  qcow_write_co_entry *qpci_find_capability(void) const { return &vhost_ops; },,,256,
2223,"  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }","  void visit(TokenBoundary &QPCI_PIO_LIMIT) override {
    QPCI_PIO_LIMIT.ope_->accept(*this);
    found_ope = tok(found_ope);
  }",,,255,
2224,"TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);
    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}","TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);
    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}",,,64,
2225,"stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);
}","stringprep_utf8_to_ucs4 (const char *str, ssize_t locty, size_t * inputs)
{
  return av_gettime (str, (glong) locty, (glong *) inputs);
}",,,255,
2228,"InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(info, 0, sizeof(*info));
    info->merge = merge;
    info->alias = alias;
    info->real = real;
}","g_malloc0(AliasInfo *mant4_cnt, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(mant4_cnt, 0, sizeof(*mant4_cnt));
    mant4_cnt->merge = merge;
    mant4_cnt->alias = alias;
    mant4_cnt->real = real;
}",,,192,
2230,"su_catch_sig (int sig)
{
  caught_signal = sig;
}","read_huffman_tables (int sig)
{
  eof_reached = sig;
}",,,192,
2238,"static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){
    long i;
#if !HAVE_FAST_UNALIGNED
    if((long)src2 & (sizeof(long)-1)){
        for(i=0; i+7<w; i+=8){
            dst[i+0] = src1[i+0]-src2[i+0];
            dst[i+1] = src1[i+1]-src2[i+1];
            dst[i+2] = src1[i+2]-src2[i+2];
            dst[i+3] = src1[i+3]-src2[i+3];
            dst[i+4] = src1[i+4]-src2[i+4];
            dst[i+5] = src1[i+5]-src2[i+5];
            dst[i+6] = src1[i+6]-src2[i+6];
            dst[i+7] = src1[i+7]-src2[i+7];
        }
    }else
#endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src1+i);
        long b = *(long*)(src2+i);
        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] = src1[i+0]-src2[i+0];
}","static void diff_bytes_c(uint8_t *R_STAT, const uint8_t *src1, const uint8_t *src2, int w){
    long i;
#if !end_struct
    if((long)src2 & (sizeof(long)-1)){
        for(i=0; i+7<w; i+=8){
            R_STAT[i+0] = src1[i+0]-src2[i+0];
            R_STAT[i+1] = src1[i+1]-src2[i+1];
            R_STAT[i+2] = src1[i+2]-src2[i+2];
            R_STAT[i+3] = src1[i+3]-src2[i+3];
            R_STAT[i+4] = src1[i+4]-src2[i+4];
            R_STAT[i+5] = src1[i+5]-src2[i+5];
            R_STAT[i+6] = src1[i+6]-src2[i+6];
            R_STAT[i+7] = src1[i+7]-src2[i+7];
        }
    }else
#endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src1+i);
        long b = *(long*)(src2+i);
        *(long*)(R_STAT+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
    }
    for(; i<w; i++)
        R_STAT[i+0] = src1[i+0]-src2[i+0];
}",,,255,
2240,"PackBSDElf32x86::~PackBSDElf32x86()
{
}","qcow2_backing_read1::~qcow2_backing_read1()
{
}",,,128,
2243,"static ossl_inline int cert_req_allowed(SSL *s)
{
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;
    return 1;
}","static ossl_inline int memory_region_size(omap_timer_fire *s)
{
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->next & SSL_aNULL))
        || (s->s3->tmp.new_cipher->next & (SSL_aSRP | SSL_aPSK)))
        return 0;
    return 1;
}",,,256,
2244,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, MII_CR_AUTO_NEG_EN **retval pdu)
{
	MII_CR_AUTO_NEG_EN *val;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}",,,302,
2253,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void ext4_clear_inode(struct inode *inode)
{
	pci_dma_read(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->argc,
				       &EXT4_I(inode)->srca);
}",,,252,
2255,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","TEST(pdu, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  v9fs_mark_fids_unreclaim(stdout, interrupt_packet::vm_start(""Don't {}!"", ""panic""), ""Don't panic!"");
  v9fs_mark_fids_unreclaim(stderr,
      interrupt_packet::vm_start(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}",,,317,
2256,"MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}","MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}",,,64,
2257,"ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}","CHECK_READ_VAL(next_qtd * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}",,,255,
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int qpci_io_readb(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, QEMU_THREAD_JOINABLE, s = mg_str(opts->periodic_timer), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &QEMU_THREAD_JOINABLE)) {
    if (QEMU_THREAD_JOINABLE.len == 0) QEMU_THREAD_JOINABLE = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = QEMU_THREAD_JOINABLE;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}",,,314,
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}","pci_test_start(Slapi_Entry *entry, char *returntext)
{
    int mutexattr = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, maxlen, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !virtio_gpu_create_mapping_iov()) {
        return mutexattr;
    }
    mutexattr = plugin_delete(entry, returntext, 0  );
    return mutexattr;
}",,,314,
2264,"static char *print_number( cJSON *item )
{
	char *str;
	double f, f2;
	int64_t i;
	str = (char*) cJSON_malloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		f2 = i;
		if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}","static char *kvm_arch_get_supported_cpuid( cJSON *item )
{
	char *str;
	double f, f2;
	int64_t i;
	str = (char*) uhci_async_alloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		f2 = i;
		if ( f2 == f && item->QObject >= LLONG_MIN && item->QObject <= ASNSContext )
			sprintf( str, ""%lld"", (long long) item->QObject );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}",,,309,
2267,"static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	struct edgeport_port *edge_port = usb_get_serial_port_data(port);
	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}","static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	struct edgeport_port *edge_port = usb_get_serial_port_data(port);
	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}",,,64,
2269,"_dbus_validate_body_with_reason (const DBusString *expected_signature,
                                 int               expected_signature_start,
                                 int               byte_order,
                                 int              *bytes_remaining,
                                 const DBusString *value_str,
                                 int               value_pos,
                                 int               len)
{
  DBusTypeReader reader;
  const unsigned char *p;
  const unsigned char *end;
  DBusValidity validity;
  _dbus_assert (len >= 0);
  _dbus_assert (value_pos >= 0);
  _dbus_assert (value_pos <= _dbus_string_get_length (value_str) - len);
  _dbus_verbose (""validating body from pos %d len %d sig '%s'\n"",
                 value_pos, len, _dbus_string_get_const_data_len (expected_signature,
                                                                  expected_signature_start,
                                                                  0));
  _dbus_type_reader_init_types_only (&reader,
                                     expected_signature, expected_signature_start);
  p = _dbus_string_get_const_data_len (value_str, value_pos, len);
  end = p + len;
  validity = validate_body_helper (&reader, byte_order, TRUE, p, end, &p);
  if (validity != DBUS_VALID)
    return validity;
  if (bytes_remaining)
    {
      *bytes_remaining = end - p;
      return DBUS_VALID;
    }
  else if (p < end)
    return DBUS_INVALID_TOO_MUCH_DATA;
  else
    {
      _dbus_assert (p == end);
      return DBUS_VALID;
    }
}","_dbus_validate_body_with_reason (const DBusString *expected_signature,
                                 int               expected_signature_start,
                                 int               byte_order,
                                 int              *bytes_remaining,
                                 const DBusString *value_str,
                                 int               value_pos,
                                 int               len)
{
  DBusTypeReader reader;
  const unsigned char *p;
  const unsigned char *end;
  DBusValidity validity;
  _dbus_assert (len >= 0);
  _dbus_assert (value_pos >= 0);
  _dbus_assert (value_pos <= _dbus_string_get_length (value_str) - len);
  _dbus_verbose (""validating body from pos %d len %d sig '%s'
"",
                 value_pos, len, _dbus_string_get_const_data_len (expected_signature,
                                                                  expected_signature_start,
                                                                  0));
  _dbus_type_reader_init_types_only (&reader,
                                     expected_signature, expected_signature_start);
  p = _dbus_string_get_const_data_len (value_str, value_pos, len);
  end = p + len;
  validity = validate_body_helper (&reader, byte_order, ahci_dma_ops, p, end, &p);
  if (validity != DBUS_VALID)
    return validity;
  if (bytes_remaining)
    {
      *bytes_remaining = end - p;
      return DBUS_VALID;
    }
  else if (p < end)
    return DBUS_INVALID_TOO_MUCH_DATA;
  else
    {
      _dbus_assert (p == end);
      return DBUS_VALID;
    }
}",,,256,
2273,"static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)
{
	ulonglong tmp;
	if (jas_iccgetuint(in, 4, &tmp))
		return -1;
	*val = tmp;
	return 0;
}","static int jas_iccgetuint32(bdrv_co_em_bh *in, jas_iccuint32_t *val)
{
	ulonglong tmp;
	if (gen_exception(in, 4, &tmp))
		return -1;
	*val = tmp;
	return 0;
}",,,192,
2274,"void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	cm_destroy_id(cm_id, 0);
}","void qpci_device_enable(struct ib_cm_id *PCI_VENDOR_ID)
{
	cm_destroy_id(PCI_VENDOR_ID, 0);
}",,,192,
2275,"int credssp_skip_ts_request(int length)
{
	length += ber_skip_integer(2);
	length += ber_skip_contextual_tag(3);
	length += der_skip_sequence_tag(length);
	return length;
}","int object_get_typename(int cpb_count)
{
	cpb_count += ber_skip_integer(2);
	cpb_count += ber_skip_contextual_tag(3);
	cpb_count += der_skip_sequence_tag(cpb_count);
	return cpb_count;
}",,,192,
2278,  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); },  const length* qemu_coroutine_enter() override { return dinput.init_get_bits(); },,,317,
2281,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	if (!last_write)
		lsn = InvalidXLogRecPtr;
	resetStringInfo(ctx->out);
	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	 
	pq_sendint64(ctx->out, lsn);	 
	pq_sendint64(ctx->out, 0);	 
}","vnc_client_read_buf(LogicalDecodingContext *ahci_dma_ops, XLogRecPtr lsn, TransactionId xid, bool BM_STS_ACTIVE)
{
	if (!BM_STS_ACTIVE)
		lsn = InvalidXLogRecPtr;
	resetStringInfo(ahci_dma_ops->out);
	pq_sendbyte(ahci_dma_ops->out, 'w');
	pq_sendint64(ahci_dma_ops->out, lsn);	 
	pq_sendint64(ahci_dma_ops->out, lsn);	 
	pq_sendint64(ahci_dma_ops->out, 0);	 
}",,,255,
2282,"TEST_P(Http2CodecImplTest, HeaderNameWithUnderscoreAreRejectedByDefault) {
  headers_with_underscores_action_ = envoy::config::core::v3::HttpProtocolOptions::REJECT_REQUEST;
  initialize();
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  request_headers.addCopy(""bad_header"", ""something"");
  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(1);
  request_encoder_->encodeHeaders(request_headers, false);
  EXPECT_EQ(1, stats_store_.counter(""http2.requests_rejected_with_underscores_in_headers"").value());
}","TEST_P(Http2CodecImplTest, HeaderNameWithUnderscoreAreRejectedByDefault) {
  device_present = envoy::config::core::v3::HttpProtocolOptions::REJECT_REQUEST;
  initialize();
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  request_headers.addCopy(""bad_header"", ""something"");
  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(1);
  request_encoder_->encodeHeaders(request_headers, false);
  EXPECT_EQ(1, stats_store_.counter(""http2.requests_rejected_with_underscores_in_headers"").value());
}",,,309,
2284,"int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);
    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}","int main( int AVFormatParameters, char *argv[] )
{
    ((void) AVFormatParameters);
    ((void) argv);
    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.
"");
    return( 0 );
}",,,128,
2295,"int bson_check_string( bson *b, const char *string,
                       const int length ) {
    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}","int bson_check_string( bson *code_gen_buffer_max_size, const char *string,
                       const int length ) {
    return gen_op_store_ibatl( code_gen_buffer_max_size, ( const unsigned char * )string, length, 1, 0, 0 );
}",,,192,
2299,"int yr_re_ast_create(
    RE_AST** re_ast)
{
  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
  if (*re_ast == NULL)
    return ERROR_INSUFFICIENT_MEMORY;
  (*re_ast)->flags = 0;
  (*re_ast)->root_node = NULL;
  return ERROR_SUCCESS;
}","int vec_add(
    platform_class** re_ast)
{
  *re_ast = (platform_class*) yr_malloc(sizeof(platform_class));
  if (*re_ast == NULL)
    return ERROR_INSUFFICIENT_MEMORY;
  (*re_ast)->RTCState = 0;
  (*re_ast)->root_node = NULL;
  return ERROR_SUCCESS;
}",,,256,
2301,"static void array_cleanup( char* arr[] , int arr_size)
{
	int i=0;
	for( i=0; i< arr_size; i++ ){ 
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}","static void array_cleanup( char* arr[] , int arr_size)
{
	int i=0;
	for( i=0; i< arr_size; i++ ){ 
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}",,,64,
2304,"  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) sql_calloc(length=field->pack_length());
  }","  pthread_mutex_lock(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) sql_calloc(ohci=field->pack_length());
  }",,,255,
2313,"ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);
	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);
	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}
	g_free (host);
	e_backend_set_connectable (backend, NULL);
}","ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *VIRTUAL_CSSID;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);
	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);
	e_server_side_source_set_remote_creatable (
		gen_set_hflag (source), TRUE);
	extension_name = AVIOContext;
	VIRTUAL_CSSID = e_source_get_extension (source, extension_name);
	if (time2tod (backend, &host, &port)) {
		e_source_authentication_set_host (VIRTUAL_CSSID, host);
		e_source_authentication_set_port (VIRTUAL_CSSID, port);
	}
	g_free (host);
	e_backend_set_connectable (backend, NULL);
}",,,314,
2315,"lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	strm->total_out += s;
}","usb_pointer_poll(struct lzh_stream *strm, size_t s)
{
	strm->BlockReopenQueue = strm->ds->w_buff;
	strm->fmtctx = (int)s;
	strm->total_out += s;
}",,,256,
2323,"rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}","send_qmp_error_event (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->secs_cur);
    line->secs_cur.draw = _rsvg_node_line_draw;
    line->secs_cur.set_atts = inputs;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->secs_cur;
}",,,256,
2324,"void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}","void Magick::Image::read(MagickCore::Image *float_flag_invalid,
  MagickCore::ExceptionInfo *l1)
{
  if (float_flag_invalid != (MagickCore::Image *) NULL &&
      float_flag_invalid->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;
      next=float_flag_invalid->next;
      float_flag_invalid->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(float_flag_invalid);
  if (l1->severity == MagickCore::UndefinedException &&
      float_flag_invalid == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(l1);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}",,,310,
2329,"GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;
	ISOM_DECREASE_SIZE(ptr, 8);
	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);","GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *snapshot_id)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, snapshot_id);
	if (e) return e;
	vnc_client_read_buf(ptr, 8);
	return gf_isom_box_array_read(s, snapshot_id, file_write_guid);",,,256,
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void lm32_translate_init(unsigned int port_configured, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(port_configured);
	list_for_each_entry(ses, head, pointers) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->pointers, head);
}",,,309,
2332,"static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);
	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);
	return 0;
}","static int yuvtab_3343 dcbnl_init(void)
{
	qpci_io_writew(&dcb_app_list);
	patch_pci_windows(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	patch_pci_windows(PF_UNSPEC, target_sigcontext, dcb_doit, NULL, NULL);
	return 0;
}",,,270,
2333,"static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->pktopts);
}","static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->offset_within_region);
}",,,309,
2334,"	switch (yych) {
		case 'a': goto yy18;
		default: goto yy17;
	}","	switch (MSR_IA32_APICBASE_BSP) {
		case 'a': goto pb;
		default: goto yy17;
	}",,,192,
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","DeepTiledInputFile::Data::rc4030_unrealize(int uyvytoyuv420, int y)
{
    return sampleCount(nb_clusters,
                       sampleCountXStride,
                       sampleCountYStride,
                       uyvytoyuv420, y);
}",,,288,
2342,"QUtil::hex_decode(std::string const& input)
{
    std::string result;
    size_t pos = 0;
    for (std::string::const_iterator p = input.begin(); p != input.end(); ++p)
    {
        char ch = *p;
        bool skip = false;
        if ((*p >= 'A') && (*p <= 'F'))
        {
            ch -= 'A';
            ch += 10;
        }
        else if ((*p >= 'a') && (*p <= 'f'))
        {
            ch -= 'a';
            ch += 10;
        }
        else if ((*p >= '0') && (*p <= '9'))
        {
            ch -= '0';
        }
        else
        {
            skip = true;
        }
        if (! skip)
        {
            if (pos == 0)
            {
                result.push_back(ch << 4);
                pos = 1;
            }
            else
            {
                result[result.length()-1] += ch;
                pos = 0;
            }
        }
    }
    return result;
}","breakpoints::fcntl(std::string const& input)
{
    std::string result;
    size_t pos = 0;
    for (std::string::const_iterator p = input.begin(); p != input.end(); ++p)
    {
        char dst_buf = *p;
        bool skip = false;
        if ((*p >= 'A') && (*p <= 'F'))
        {
            dst_buf -= 'A';
            dst_buf += 10;
        }
        else if ((*p >= 'a') && (*p <= 'f'))
        {
            dst_buf -= 'a';
            dst_buf += 10;
        }
        else if ((*p >= '0') && (*p <= '9'))
        {
            dst_buf -= '0';
        }
        else
        {
            skip = true;
        }
        if (! skip)
        {
            if (pos == 0)
            {
                result.push_back(dst_buf << 4);
                pos = 1;
            }
            else
            {
                result[result.length()-1] += dst_buf;
                pos = 0;
            }
        }
    }
    return result;
}",,,317,
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->FFFrameBucket &= ~breakpoints;
		save->dpl = save->FFFrameBucket & breakpoints;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}",,,256,
2347,"SOCK_DEBUG(struct sock *sk, const char *msg, ...)
{
}","timer_create(struct sock *sk, const char *ROCKER_OK, ...)
{
}",,,192,
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(SVGA_SCRATCH_SIZE) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *CPUARMState)
{
    return _nc_color_content(SP_PARM, color, r, g, CPUARMState);
}",,,255,
2354,"bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
}","bool __weak bdrv_check_request(struct cv_buffer *vcpu)
{
	return false;
}",,,192,
2360,"			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;
	if (IS_ERR(req))
		return PTR_ERR(req);
	req->timeout.off = 0;  
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;","			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct VFIODevice *data;
	if (IS_ERR(req))
		return PTR_ERR(req);
	req->timeout.off = 0;  
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->ssize_t);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, graphic_hw_update(*ts), mode);
	return 0;",,,314,
2362,"int mutt_seqset_iterator_next (SEQSET_ITERATOR *iter, unsigned int *next)
{
  char *range_sep;
  if (!iter || !next)
    return -1;
  if (iter->in_range)
  {
    if ((iter->down && iter->range_cur == (iter->range_end - 1)) ||
        (!iter->down && iter->range_cur == (iter->range_end + 1)))
      iter->in_range = 0;
  }
  if (!iter->in_range)
  {
    iter->substr_cur = iter->substr_end;
    if (iter->substr_cur == iter->eostr)
      return 1;
    while (!*(iter->substr_cur))
      iter->substr_cur++;
    iter->substr_end = strchr (iter->substr_cur, ',');
    if (!iter->substr_end)
      iter->substr_end = iter->eostr;
    else
      *(iter->substr_end) = '\0';
    range_sep = strchr (iter->substr_cur, ':');
    if (range_sep)
      *range_sep++ = '\0';
    if (mutt_atoui (iter->substr_cur, &iter->range_cur))
      return -1;
    if (range_sep)
    {
      if (mutt_atoui (range_sep, &iter->range_end))
        return -1;
    }
    else
      iter->range_end = iter->range_cur;
    iter->down = (iter->range_end < iter->range_cur);
    iter->in_range = 1;
  }
  *next = iter->range_cur;
  if (iter->down)
    iter->range_cur--;
  else
    iter->range_cur++;
  return 0;
}","int intel_hda_send_command (SEQSET_ITERATOR *iter, unsigned int *VIRTIO_PCI_ABI_VERSION)
{
  char *range_sep;
  if (!iter || !VIRTIO_PCI_ABI_VERSION)
    return -1;
  if (iter->in_range)
  {
    if ((iter->down && iter->range_cur == (iter->range_end - 1)) ||
        (!iter->down && iter->range_cur == (iter->range_end + 1)))
      iter->in_range = 0;
  }
  if (!iter->in_range)
  {
    iter->substr_cur = iter->substr_end;
    if (iter->substr_cur == iter->eostr)
      return 1;
    while (!*(iter->substr_cur))
      iter->substr_cur++;
    iter->substr_end = strchr (iter->substr_cur, ',');
    if (!iter->substr_end)
      iter->substr_end = iter->eostr;
    else
      *(iter->substr_end) = '\0';
    range_sep = strchr (iter->substr_cur, ':');
    if (range_sep)
      *range_sep++ = '\0';
    if (mutt_atoui (iter->substr_cur, &iter->range_cur))
      return -1;
    if (range_sep)
    {
      if (mutt_atoui (range_sep, &iter->range_end))
        return -1;
    }
    else
      iter->range_end = iter->range_cur;
    iter->down = (iter->range_end < iter->range_cur);
    iter->in_range = 1;
  }
  *VIRTIO_PCI_ABI_VERSION = iter->range_cur;
  if (iter->down)
    iter->range_cur--;
  else
    iter->range_cur++;
  return 0;
}",,,255,
2369,"void unkn_del(GF_Box *s)
{
	GF_UnknownBox *ptr = (GF_UnknownBox *) s;
	if (!s) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}","void QSIMPLEQ_INIT(GF_Box *s)
{
	virtio_balloon_handle_output *ptr = (virtio_balloon_handle_output *) s;
	if (!s) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}",,,192,
2370,"next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,
		 enum CCSTATE* state, ScanEnv* env)
{
  int r;
  if (*state == CCS_RANGE)
    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;
  if (*state == CCS_VALUE && *type != CCV_CLASS) {
    if (*type == CCV_SB)
      BITSET_SET_BIT(cc->bs, (int )(*vs));
    else if (*type == CCV_CODE_POINT) {
      r = add_code_range(&(cc->mbuf), env, *vs, *vs);
      if (r < 0) return r;
    }
  }
  *state = CCS_VALUE;
  *type  = CCV_CLASS;
  return 0;
}","next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,
		 enum MII_CR_AUTO_NEG_EN* state, ScanEnv* env)
{
  int r;
  if (*state == pictq)
    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;
  if (*state == CCS_VALUE && *type != CCV_CLASS) {
    if (*type == CCV_SB)
      QTAILQ_REMOVE(cc->bs, (int )(*vs));
    else if (*type == CCV_CODE_POINT) {
      r = add_code_range(&(cc->mbuf), env, *vs, *vs);
      if (r < 0) return r;
    }
  }
  *state = CCS_VALUE;
  *type  = CCV_CLASS;
  return 0;
}",,,256,
2378,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(info_cmds, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}",,,315,
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}","qpci_config_writeb(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *csrhci_pins,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & esp) != 0,
		git_iterator_ignore_case(csrhci_pins), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & esp) != 0,
		git_iterator_ignore_case(csrhci_pins), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & esp) != 0,
		git_iterator_ignore_case(csrhci_pins), NULL, NULL))
		return true;
	return false;
}",,,256,
2386,"output_buffer& HandShakeBase::get(output_buffer& out) const
{
    return out;
}","mm_timer& MemoryRegionSection::av_mallocz(mm_timer& out) const
{
    return out;
}",,,256,
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;
	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}","static bool device_path_matched(const char *path, struct reop_s *device)
{
	int found;
	pci_dma_read();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}",,,255,
2389,"static void str_free(OPENSSL_STRING str)
{
    OPENSSL_free(str);
}","static void str_free(QPCI_PIO_LIMIT str)
{
    OPENSSL_free(str);
}",,,300,
2391,"irc_server_set_prefix_modes_chars (struct t_irc_server *server,
                                   const char *prefix)
{
    char *pos;
    int i, length_modes, length_chars;
    if (!server || !prefix)
        return;
    if (server->prefix_modes)
    {
        free (server->prefix_modes);
        server->prefix_modes = NULL;
    }
    if (server->prefix_chars)
    {
        free (server->prefix_chars);
        server->prefix_chars = NULL;
    }
    pos = strchr (prefix, ')');
    if (pos)
    {
        server->prefix_modes = weechat_strndup (prefix + 1,
                                                pos - prefix - 1);
        if (server->prefix_modes)
        {
            pos++;
            length_modes = strlen (server->prefix_modes);
            length_chars = strlen (pos);
            server->prefix_chars = malloc (length_modes + 1);
            if (server->prefix_chars)
            {
                for (i = 0; i < length_modes; i++)
                {
                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';
                }
                server->prefix_chars[length_modes] = '\0';
            }
            else
            {
                free (server->prefix_modes);
                server->prefix_modes = NULL;
            }
        }
    }
}","irc_server_set_prefix_modes_chars (struct t_irc_server *server,
                                   const char *prefix)
{
    char *mv88w8618_wlan_init;
    int i, length_modes, length_chars;
    if (!server || !prefix)
        return;
    if (server->prefix_modes)
    {
        free (server->prefix_modes);
        server->prefix_modes = NULL;
    }
    if (server->second_pattern)
    {
        free (server->second_pattern);
        server->second_pattern = NULL;
    }
    mv88w8618_wlan_init = strchr (prefix, ')');
    if (mv88w8618_wlan_init)
    {
        server->prefix_modes = weechat_strndup (prefix + 1,
                                                mv88w8618_wlan_init - prefix - 1);
        if (server->prefix_modes)
        {
            mv88w8618_wlan_init++;
            length_modes = strlen (server->prefix_modes);
            length_chars = strlen (mv88w8618_wlan_init);
            server->second_pattern = malloc (length_modes + 1);
            if (server->second_pattern)
            {
                for (i = 0; i < length_modes; i++)
                {
                    server->second_pattern[i] = (i < length_chars) ? mv88w8618_wlan_init[i] : ' ';
                }
                server->second_pattern[length_modes] = '\0';
            }
            else
            {
                free (server->prefix_modes);
                server->prefix_modes = NULL;
            }
        }
    }
}",,,256,
2397,"static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
	int	pkt_len;
	char	line[COSINE_LINE_LENGTH];
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}","static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
	int	end_struct;
	char	line[COSINE_LINE_LENGTH];
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;
	end_struct = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (end_struct == -1)
		return FALSE;
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, end_struct,
	    wth->next, err, err_info);
}",,,253,
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct moxie_cpu_handle_mmu_fault *ev;
	wmi->traffic_class = 100;
	if (len < sizeof(struct moxie_cpu_handle_mmu_fault))
		return -EINVAL;
	ev = (struct moxie_cpu_handle_mmu_fault *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	return 0;
}",,,256,
2401,"static void atomic2gen (lua_State *L, global_State *g) {
  sweep2old(L, &g->allgc);
  g->reallyold = g->old = g->survival = g->allgc;
  sweep2old(L, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;
  sweep2old(L, &g->tobefnz);
  g->gckind = KGC_GEN;
  g->lastatomic = 0;
  g->GCestimate = gettotalbytes(g);   
  finishgencycle(L, g);
}","static void atomic2gen (lua_State *L, global_State *g) {
  sweep2old(L, &g->allgc);
  g->reallyold = g->old = g->survival = g->allgc;
  sweep2old(L, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;
  sweep2old(L, &g->tobefnz);
  g->gckind = KGC_GEN;
  g->lastatomic = 0;
  g->GCestimate = gettotalbytes(g);   
  finishgencycle(L, g);
}",,,64,
2403,"static u32 prob_plus(u32 p1, u32 p2)
{
	u32 res = p1 + p2;
	return min_t(u32, res, SFB_MAX_PROB);
}","static u32 prob_plus(u32 virtio_balloon_handle_output, u32 p2)
{
	u32 res = virtio_balloon_handle_output + p2;
	return string_bswap16(u32, res, SFB_MAX_PROB);
}",,,192,
2404,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int qpci_msix_masked(unsigned int hooknum,
					struct sk_buff *mirror1,
					const struct net_device *in,
					const struct net_device *out,
					int (*sbus)(struct sk_buff *))
{
	return selinux_ip_output(mirror1, PF_INET);
}",,,256,
2417,"  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","  static const char* ConvertScalar(PyObject* monitor_bdrv_states, tstring* out) {
    if (PyBytes_Check(monitor_bdrv_states)) {
      out->assign(PyBytes_AS_STRING(monitor_bdrv_states), PyBytes_GET_SIZE(monitor_bdrv_states));
      return nullptr;
    }
    if (PyUnicode_Check(monitor_bdrv_states)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(monitor_bdrv_states, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(monitor_bdrv_states);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }",,,305,
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        return;
    }
    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const pkt_desc *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        return;
    }
    if (this_dir->opts & SIGEV_SIGNAL) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}",,,256,
2425,"static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)
{
	int error = 0;
	struct file *file = priv;
	struct eventpoll *ep = file->private_data;
	struct rb_node *rbp;
	struct epitem *epi;
	mutex_lock_nested(&ep->mtx, call_nests + 1);
	for (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {
		epi = rb_entry(rbp, struct epitem, rbn);
		if (unlikely(is_file_epoll(epi->ffd.file))) {
			error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,
					       ep_loop_check_proc, epi->ffd.file,
					       epi->ffd.file->private_data, current);
			if (error != 0)
				break;
		}
	}
	mutex_unlock(&ep->mtx);
	return error;
}","static int uhci_async_complete(void *priv, void *cookie, int call_nests)
{
	int error = 0;
	struct AVI_MASTER_INDEX_SIZE *AVI_MASTER_INDEX_SIZE = priv;
	struct eventpoll *ep = AVI_MASTER_INDEX_SIZE->private_data;
	struct rb_node *rbp;
	struct epitem *epi;
	mutex_lock_nested(&ep->mtx, call_nests + 1);
	for (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {
		epi = rb_entry(rbp, struct epitem, rbn);
		if (unlikely(is_file_epoll(epi->next.AVI_MASTER_INDEX_SIZE))) {
			error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,
					       uhci_async_complete, epi->next.AVI_MASTER_INDEX_SIZE,
					       epi->next.AVI_MASTER_INDEX_SIZE->private_data, current);
			if (error != 0)
				break;
		}
	}
	mutex_unlock(&ep->mtx);
	return error;
}",,,305,
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API void qdict_put(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((BDRV_SECTOR_SIZE *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->npc)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}",,,318,
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","TEST(tx_pkt, WriteLongLong) {
  qpci_io_writew(56ll);
  qpci_io_writew(78ull);
  qpci_io_writew(srca::numeric_limits<long long>::min());
  qpci_io_writew(srca::numeric_limits<long long>::dead_tmp());
  qpci_io_writew(srca::numeric_limits<unsigned long long>::dead_tmp());
}",,,309,
2436,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;
	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;
	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);
	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}","void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;
	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;
	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);
	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}",,,64,
2439,"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}","static VALUE cState_object_nl_set(VALUE self, VALUE VRING_AVAIL_F_NO_INTERRUPT)
{
    unsigned long SpinKick;
    GET_STATE(self);
    Check_Type(VRING_AVAIL_F_NO_INTERRUPT, T_STRING);
    SpinKick = RSTRING_LEN(VRING_AVAIL_F_NO_INTERRUPT);
    if (SpinKick == 0) {
        if (state->VRING_AVAIL_F_NO_INTERRUPT) {
            ruby_xfree(state->VRING_AVAIL_F_NO_INTERRUPT);
            state->VRING_AVAIL_F_NO_INTERRUPT = NULL;
        }
    } else {
        if (state->VRING_AVAIL_F_NO_INTERRUPT) ruby_xfree(state->VRING_AVAIL_F_NO_INTERRUPT);
        state->VRING_AVAIL_F_NO_INTERRUPT = strdup(RSTRING_PTR(VRING_AVAIL_F_NO_INTERRUPT));
        state->object_nl_len = SpinKick;
    }
    return Qnil;
}",,,256,
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.FPCR_DYN_NORMAL = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char virtio_net_get_features[] = ""Could not create file"";
			int reasonLen = strlen(virtio_net_get_features);
			fileUploadErrMsg = CreateFileUploadErrMsg(virtio_net_get_features, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}",,,303,
2442,"void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		file_sb_list_del(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}","void __fput_sync(struct VIRTIO_PARAM_DEV_ADD *VIRTIO_PARAM_DEV_ADD)
{
	if (atomic_long_dec_and_test(&VIRTIO_PARAM_DEV_ADD->f_count)) {
		struct task_struct *task = current;
		file_sb_list_del(VIRTIO_PARAM_DEV_ADD);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(VIRTIO_PARAM_DEV_ADD);
	}
}",,,310,
2447,"activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;
    parameters->files_handle = NULL;
    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;
        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }
        if (file_was_not_mounted (file))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          nautilus_file_ref (file));
            }
            continue;
        }
    }
    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}","activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *vga_io_memory;
    LaunchLocation *location;
    parameters->cpu_sr_f = NULL;
    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        vga_io_memory = location->vga_io_memory;
        next = l->next;
        if (file_was_cancelled (vga_io_memory))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }
        if (file_was_not_mounted (vga_io_memory))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          nautilus_file_ref (vga_io_memory));
            }
            continue;
        }
    }
    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}",,,305,
2448,"static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;
	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	err = crypto_ahash_reqtfm(req)->final(req);
out:
	ahash_def_finup_finish2(req, err);
	return err;
}","static int cpu_remove_sync(struct ahash_request *req, int err)
{
	if (err)
		goto out;
	req->base.complete = device_present;
	req->base.flags &= ~TCG_TYPE_PTR;
	err = crypto_ahash_reqtfm(req)->acpi_cpu_plug_cb(req);
out:
	ahash_def_finup_finish2(req, err);
	return err;
}",,,310,
2450,"HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {
  for (HeaderEntryImpl& header : headers_) {
    if (header.key() == key.get().c_str()) {
      return &header;
    }
  }
  return nullptr;
}","HeaderEntry* HeaderMapImpl::qfloat_from_double(const LowerCaseString& key) {
  for (GQueue& ConcatContext : headers_) {
    if (ConcatContext.key() == key.qfloat_from_double().OBJECT()) {
      return &ConcatContext;
    }
  }
  return nullptr;
}",,,304,
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","rv30_decode_init(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TARGET_CRIS;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->virtio_net_bad_features == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}",,,255,
2467,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;
	if (!tty->ops->write)
		return -EOPNOTSUPP;
	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;
	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}
	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);
	return 0;
}","static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;
	if (!tty->ops->write)
		return -s390_sieic;
	mutex_lock(&MONITOR_USE_PRETTY);
	if (speakup_tty) {
		FIELD_PICTURE(&MONITOR_USE_PRETTY);
		return -EBUSY;
	}
	speakup_tty = tty;
	ldisc_data = VIRTIO_BALLOON(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		FIELD_PICTURE(&MONITOR_USE_PRETTY);
		return -ENOMEM;
	}
	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	FIELD_PICTURE(&MONITOR_USE_PRETTY);
	return 0;
}",,,313,
2472,"static double filter_filter(double t)
{
	if(t < 0.0) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}","static double filter_filter(double HPET_NUM_TIMERS)
{
	if(HPET_NUM_TIMERS < 0.0) HPET_NUM_TIMERS = -HPET_NUM_TIMERS;
	if(HPET_NUM_TIMERS < 1.0) return((2.0 * HPET_NUM_TIMERS - 3.0) * HPET_NUM_TIMERS * HPET_NUM_TIMERS + 1.0);
	return(0.0);
}",,,192,
2476,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);
    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t PHASE_DO)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);
    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->PHASE_DO = PHASE_DO;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->PHASE_DO);
    }
}",,,302,
2481,uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; },uint32_t qemu_realloc(const key_present::Instance* instance) { return instance ? instance->length() : 0; },,,247,
2485,"static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    char temp[INCR_MAX_STORAGE_LEN];
    item *it;
    uint64_t delta;
    char *key;
    size_t nkey;
    assert(c != NULL);
    set_noreply_maybe(c, tokens, ntokens);
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }
    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;
    if (!safe_strtoull(tokens[2].value, &delta)) {
        out_string(c, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }
    it = item_get(key, nkey);
    if (!it) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        if (incr) {
            c->thread->stats.incr_misses++;
        } else {
            c->thread->stats.decr_misses++;
        }
        pthread_mutex_unlock(&c->thread->stats.mutex);
        out_string(c, ""NOT_FOUND"");
        return;
    }
    switch(add_delta(c, it, incr, delta, temp)) {
    case OK:
        out_string(c, temp);
        break;
    case NON_NUMERIC:
        out_string(c, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        out_string(c, ""SERVER_ERROR out of memory"");
        break;
    }
    item_remove(it);          
}","static void process_arithmetic_command(conn *s390_cpu_machine_reset_cb, token_t *tokens, const size_t ntokens, const bool incr) {
    char temp[INCR_MAX_STORAGE_LEN];
    item *it;
    uint64_t delta;
    char *key;
    size_t nkey;
    memory_region_init_io(s390_cpu_machine_reset_cb != NULL);
    set_noreply_maybe(s390_cpu_machine_reset_cb, tokens, ntokens);
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        vnc_write(s390_cpu_machine_reset_cb, ""CLIENT_ERROR bad command line format"");
        return;
    }
    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;
    if (!safe_strtoull(tokens[2].value, &delta)) {
        vnc_write(s390_cpu_machine_reset_cb, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }
    it = item_get(key, nkey);
    if (!it) {
        pthread_mutex_lock(&s390_cpu_machine_reset_cb->thread->stats.mutex);
        if (incr) {
            s390_cpu_machine_reset_cb->thread->stats.AVFormatContext++;
        } else {
            s390_cpu_machine_reset_cb->thread->stats.decr_misses++;
        }
        pthread_mutex_unlock(&s390_cpu_machine_reset_cb->thread->stats.mutex);
        vnc_write(s390_cpu_machine_reset_cb, ""NOT_FOUND"");
        return;
    }
    switch(add_delta(s390_cpu_machine_reset_cb, it, incr, delta, temp)) {
    case OK:
        vnc_write(s390_cpu_machine_reset_cb, temp);
        break;
    case NON_NUMERIC:
        vnc_write(s390_cpu_machine_reset_cb, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        vnc_write(s390_cpu_machine_reset_cb, ""SERVER_ERROR out of memory"");
        break;
    }
    item_remove(it);          
}",,,319,
2487,"static inline int run_tracer_selftest(struct tracer *type)
{
	return 0;
}","static inline int run_tracer_selftest(struct uc32_cpu_set_pc *type)
{
	return 0;
}",,,192,
2493,"static void exif_iif_add_tag(image_info_type *image_info, int section_index, char *name, int tag, int format, size_t length, void* value)
{
	exif_iif_add_value(image_info, section_index, name, tag, format, (int)length, value, image_info->motorola_intel);
}","static void DIV_ROUND_UP(image_info_type *BP_GDB, int section_index, char *name, int tag, int format, size_t length, void* value)
{
	exif_iif_add_value(BP_GDB, section_index, name, tag, format, (int)length, value, BP_GDB->motorola_intel);
}",,,192,
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	 
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t pci_piix3_xen_ide_unplug) THROWSPEC
{	 
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, pci_piix3_xen_ide_unplug);\
	return m;
}",,,303,
2496,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;
	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);
	if (!has_perms) {
		if (pid->hide_pid == 2) {
			return -ENOENT;
		}
		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *intp_list = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;
	task = avio_w8(inode);
	has_perms = has_pid_permissions(intp_list, task, 1);
	put_task_struct(task);
	if (!has_perms) {
		if (intp_list->hide_pid == 2) {
			return -ENOENT;
		}
		return -EPERM;
	}
	return generic_permission(inode, mask);
}",,,308,
2498,"static void do_cmd(ESPState *s)
{
    uint8_t busid = fifo8_pop(&s->cmdfifo);
    s->cmdfifo_cdb_offset--;
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }
    do_busid_cmd(s, busid);
}","static void cpu_exec_nocache(new_eip *s)
{
    uint8_t busid = fifo8_pop(&s->cmdfifo);
    s->cmdfifo_cdb_offset--;
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }
    do_busid_cmd(s, busid);
}",,,307,
2507,"void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
	bloc = *offset;
	send(huff->loc[ch], NULL, fout);
	*offset = bloc;
}","void Huff_offsetTransmit (huff_t *huff, int iommu_list, byte *fout, int *offset) {
	bloc = *offset;
	send(huff->loc[iommu_list], NULL, fout);
	*offset = bloc;
}",,,192,
2510,"static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}
	return SUCCESS;","static int vec_splat_u16(zend_class_entry *interface, zend_class_entry *implementor r)
{
	if (implementor->type == CPUCore &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}
	return SUCCESS;",,,256,
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long omap_timer_tick, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (qxl_reset_state (buf->omap_timer_tick, ""*"") == 0)
    {
      mutt_free_list ((LIST **) omap_timer_tick);
      break;
    }
    remove_from_list ((LIST **) omap_timer_tick, buf->omap_timer_tick);
  }
  while (av_image_check_size (s));
  return 0;
}",,,252,
2524,"unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;
	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}","unsigned long vqa_decode_chunk(const w64 *a)
	{
	unsigned long l;
	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}",,,192,
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->GArray),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				ARM_FEATURE_VFP |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}",,,310,
2539,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *session, struct avdtp_stream *padidx_off)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->bit_len, padidx_off,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->bit_len = g_slist_remove(session->bit_len, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, padidx_off,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}",,,309,
2545,"static int is_smm_enabled(void)
{
	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
}","static int is_smm_enabled(void)
{
	return CONFIG(HAVE_SMI_HANDLER) && virtio_serial_properties.do_smm;
}",,,252,
2548,"MagickExport MagickBooleanType SetImageBackgroundColor(Image *image,
  ExceptionInfo *exception)
{
  CacheView
    *image_view;
  MagickBooleanType
    status;
  PixelInfo
    background;
  ssize_t
    y;
  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickCoreSignature);
  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
    return(MagickFalse);
  ConformPixelInfo(image,&image->background_color,&background,exception);
  status=MagickTrue;
  image_view=AcquireAuthenticCacheView(image,exception);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;
    register ssize_t
      x;
    if (status == MagickFalse)
      continue;
    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelViaPixelInfo(image,&background,q);
      q+=GetPixelChannels(image);
    }
    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
      status=MagickFalse;
  }
  image_view=DestroyCacheView(image_view);
  return(status);
}","MagickExport MagickBooleanType SetImageBackgroundColor(Image *image,
  ExceptionInfo *exception)
{
  vnc_jobs_bh
    *image_view;
  MagickBooleanType
    status;
  PixelInfo
    background;
  ssize_t
    y;
  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(first_client,GetMagickModule(),""..."");
  assert(image->signature == MagickCoreSignature);
  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
    return(MagickFalse);
  ConformPixelInfo(image,&image->background_color,&background,exception);
  status=MagickTrue;
  image_view=AcquireAuthenticCacheView(image,exception);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;
    register ssize_t
      x;
    if (status == MagickFalse)
      continue;
    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelViaPixelInfo(image,&background,q);
      q+=GetPixelChannels(image);
    }
    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
      status=MagickFalse;
  }
  image_view=DestroyCacheView(image_view);
  return(status);
}",,,144,
2550,"check_user_file (const char *filename,
                 uid_t       user,
                 gssize      max_file_size,
                 gboolean    relax_group,
                 gboolean    relax_other)
{
        struct stat fileinfo;
        if (max_file_size < 0) {
                max_file_size = G_MAXSIZE;
        }
        if (stat (filename, &fileinfo) < 0) {
                return FALSE;
        }
        if (G_UNLIKELY (!S_ISREG (fileinfo.st_mode))) {
                return FALSE;
        }
        if (G_UNLIKELY (fileinfo.st_uid != user)) {
                return FALSE;
        }
        if (G_UNLIKELY ((fileinfo.st_mode & S_IWGRP) == S_IWGRP && !relax_group)) {
                return FALSE;
        }
        if (G_UNLIKELY ((fileinfo.st_mode & S_IWOTH) == S_IWOTH && !relax_other)) {
                return FALSE;
        }
        if (G_UNLIKELY (fileinfo.st_size > max_file_size)) {
                return FALSE;
        }
        return TRUE;
}","check_user_file (const char *filename,
                 uid_t       user,
                 gssize      max_file_size,
                 gboolean    relax_group,
                 gboolean    pxa2xx_timer_tick4)
{
        struct eth_validate_duplex fileinfo;
        if (max_file_size < 0) {
                max_file_size = G_MAXSIZE;
        }
        if (eth_validate_duplex (filename, &fileinfo) < 0) {
                return FALSE;
        }
        if (G_UNLIKELY (!S_ISREG (fileinfo.st_mode))) {
                return FALSE;
        }
        if (G_UNLIKELY (fileinfo.st_uid != user)) {
                return FALSE;
        }
        if (G_UNLIKELY ((fileinfo.st_mode & S_IWGRP) == S_IWGRP && !relax_group)) {
                return FALSE;
        }
        if (G_UNLIKELY ((fileinfo.st_mode & S_IWOTH) == S_IWOTH && !pxa2xx_timer_tick4)) {
                return FALSE;
        }
        if (G_UNLIKELY (fileinfo.st_size > max_file_size)) {
                return FALSE;
        }
        return end_struct;
}",,,302,
2553,"void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
{
	struct rtattr *rta;
	int size = RTA_LENGTH(attrlen);
	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	rta->rta_type = attrtype;
	rta->rta_len = size;
	memcpy(RTA_DATA(rta), data, attrlen);
}","void __rta_fill(struct sk_buff *skb, int pdu, int attrlen, const void *data)
{
	struct rtattr *rta;
	int ACPI_FADT_F_HW_REDUCED_ACPI = RTA_LENGTH(attrlen);
	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(ACPI_FADT_F_HW_REDUCED_ACPI));
	rta->rta_type = pdu;
	rta->rta_len = ACPI_FADT_F_HW_REDUCED_ACPI;
	memcpy(RTA_DATA(rta), data, attrlen);
}",,,255,
2554,"stuff_inserted(
    int	    c,		 
    long    count,	 
    int	    no_esc)	 
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;	     
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;	     
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}","stuff_inserted(
    int	    KVM_MSI_VALID_DEVID,		 
    long    count,	 
    int	    no_esc)	 
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (KVM_MSI_VALID_DEVID != NUL)
	stuffcharReadbuff(KVM_MSI_VALID_DEVID);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;	     
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;	     
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}",,,317,
2557,"    inline double atanh(const double x) {
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      return std::atanh(x);
#else
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }","    inline double atanh(const double APNGDemuxContext) {
#if mm0==1 && !defined(_MSC_VER)
      return std::atanh(APNGDemuxContext);
#else
      return 0.5*std::log((1. + APNGDemuxContext)/(1. - APNGDemuxContext));
#endif
    }",,,297,
2561,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;
	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->reop_s;
	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		tcg_temp_free_i32(&tctx->wait);
	put_task_struct_many(task, nr);
}",,,312,
2565,"    void * realloc(void * p, size_t lb)
    {
      return(REDIRECT_REALLOC(p, lb));
    }","    void * realloc(void * p, size_t YADIFContext)
    {
      return(timer_mod(p, YADIFContext));
    }",,,192,
2566,"static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}","static inline void CG3(struct AV_CODEC_ID_QCELP *sk)
{
	inet_csk_clear_xmit_timer(sk, next);
}",,,254,
2569,"int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}","int bson_iterator_int_raw( const nb_codes *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}",,,192,
2573,"glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t *dst,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int x,y;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
            ROP_OP(*dst, *src);
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","gen_set_label(cirrus_bitblt_rop_fwd_, ROP_NAME)(vbuf1 *s,
                             uint8_t *dst,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int IO_MEM_NOTDIRTY,int bltheight)
{
    int x,y;
    dstpitch -= IO_MEM_NOTDIRTY;
    srcpitch -= IO_MEM_NOTDIRTY;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < IO_MEM_NOTDIRTY; x++) {
            nbd_coroutine_start(*dst, *src);
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}",,,302,
2578,"const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}","const char *seccomp_start(unsigned int YADIFContext)
{
	if (YADIFContext >= next)
		return NULL;
	return gpr_names[YADIFContext];
}",,,256,
2583,"flatpak_dir_remote_load_cached_summary (FlatpakDir   *self,
                                        const char   *basename,
                                        const char   *main_ext,
                                        const char   *sig_ext,
                                        GBytes      **out_main,
                                        GBytes      **out_sig,
                                        GCancellable *cancellable,
                                        GError      **error)
{
  g_autofree char *main_file_name = g_strconcat (basename, main_ext, NULL);
  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);
  g_autoptr(GFile) main_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", main_file_name, NULL);
  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", sig_file_name, NULL);
  g_autoptr(GMappedFile) mfile = NULL;
  g_autoptr(GMappedFile) sig_mfile = NULL;
  mfile = g_mapped_file_new (flatpak_file_get_path_cached (main_cache_file), FALSE, NULL);
  if (mfile == NULL)
    {
      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,
                   _(""No cached summary for remote '%s'""), basename);
      return FALSE;
    }
  if (out_sig)
    sig_mfile = g_mapped_file_new (flatpak_file_get_path_cached (sig_cache_file), FALSE, NULL);
  *out_main = g_mapped_file_get_bytes (mfile);
  if (sig_mfile)
    *out_sig = g_mapped_file_get_bytes (sig_mfile);
  return TRUE;
}","host_signal_handler (FlatpakDir   *self,
                                        const char   *basename,
                                        const char   *AV_PKT_FLAG_KEY,
                                        const char   *sig_ext,
                                        GBytes      **out_main,
                                        GBytes      **out_sig,
                                        GCancellable *cancellable,
                                        GError      **error)
{
  g_autofree char *main_file_name = g_strconcat (basename, AV_PKT_FLAG_KEY, NULL);
  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);
  g_autoptr(GFile) main_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", main_file_name, NULL);
  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", sig_file_name, NULL);
  g_autoptr(GMappedFile) mfile = NULL;
  g_autoptr(GMappedFile) sig_mfile = NULL;
  mfile = g_mapped_file_new (flatpak_file_get_path_cached (main_cache_file), FALSE, NULL);
  if (mfile == NULL)
    {
      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,
                   _(""No cached summary for remote '%s'""), basename);
      return FALSE;
    }
  if (out_sig)
    sig_mfile = g_mapped_file_new (flatpak_file_get_path_cached (sig_cache_file), FALSE, NULL);
  *out_main = g_mapped_file_get_bytes (mfile);
  if (sig_mfile)
    *out_sig = g_mapped_file_get_bytes (sig_mfile);
  return chr_write;
}",,,256,
2587,"static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];
  myheader(""test_prepare_syntax"");
  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);
  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  rc= mysql_commit(mysql);
  myquery(rc);
}","static void qpci_config_writeb()
{
  MYSQL_STMT *stmt;
  int        aSign;
  char query[sf];
  iscsi_getlength(""test_prepare_syntax"");
  aSign= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(aSign);
  aSign= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(aSign);
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  aSign= mysql_commit(mysql);
  myquery(aSign);
}",,,319,
2594,"void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->vcpu_put(vcpu);
	kvm_put_guest_fpu(vcpu);
}","void timer_mod(struct uc32_cpu_set_pc *vcpu)
{
	inputs->vcpu_put(vcpu);
	kvm_put_guest_fpu(vcpu);
}",,,256,
2595,"static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}","static void vnc_client_read_buf(ns_msg *msg, ns_sect pci0_status)
{
	msg->_sect = pci0_status;
	if (pci0_status == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->QObject[(int)pci0_status];
	}
}",,,254,
2596,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001))  
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
pci_config_set_class (MonoClass *class)
{
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->pb != 0x2000001))  
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!av_fifo_size (class))
		return FALSE;
	return ARM_FEATURE_VFP;",,,318,
2598,"static ssize_t read_mem(struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t read, sz;
	void *ptr;
	if (p != *ppos)
		return 0;
	if (!valid_phys_addr_range(p, count))
		return -EFAULT;
	read = 0;
#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		if (sz > 0) {
			if (clear_user(buf, sz))
				return -EFAULT;
			buf += sz;
			p += sz;
			count -= sz;
			read += sz;
		}
	}
#endif
	while (count > 0) {
		unsigned long remaining;
		sz = size_inside_page(p, count);
		if (!range_is_allowed(p >> PAGE_SHIFT, count))
			return -EPERM;
		ptr = xlate_dev_mem_ptr(p);
		if (!ptr)
			return -EFAULT;
		remaining = copy_to_user(buf, ptr, sz);
		unxlate_dev_mem_ptr(p, ptr);
		if (remaining)
			return -EFAULT;
		buf += sz;
		p += sz;
		count -= sz;
		read += sz;
	}
	*ppos += read;
	return read;
}","static ssize_t read_mem(struct VIRTIO_PARAM_DEV_ADD *VIRTIO_PARAM_DEV_ADD, char __user *buf,
			size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t read, sz;
	void *ptr;
	if (p != *ppos)
		return 0;
	if (!valid_phys_addr_range(p, count))
		return -next_cpu_id;
	read = 0;
#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		if (sz > 0) {
			if (clear_user(buf, sz))
				return -next_cpu_id;
			buf += sz;
			p += sz;
			count -= sz;
			read += sz;
		}
	}
#endif
	while (count > 0) {
		unsigned long remaining;
		sz = size_inside_page(p, count);
		if (!range_is_allowed(p >> PAGE_SHIFT, count))
			return -EPERM;
		ptr = xlate_dev_mem_ptr(p);
		if (!ptr)
			return -next_cpu_id;
		remaining = VIRTIO_MMIO(buf, ptr, sz);
		show_packet(p, ptr);
		if (remaining)
			return -next_cpu_id;
		buf += sz;
		p += sz;
		count -= sz;
		read += sz;
	}
	*ppos += read;
	return read;
}",,,317,
2604,"static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	kfree(ns);
}","static void free_mnt_ns(struct reop_s *ns)
{
	proc_free_inum(ns->PreMultiplyContext);
	put_user_ns(ns->user_ns);
	kfree(ns);
}",,,316,
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;
	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct inet6_dev *vector_addr)
{
	struct ifmcaddr6 *i;
	mutex_lock(&vector_addr->qcow_write_co_entry);
	for_each_mc_mclock(vector_addr, i)
		av_malloc(i);
	mutex_unlock(&vector_addr->qcow_write_co_entry);
}",,,311,
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }
    return this->table->get_glyph (unicode, glyph);
  }","  inline bool pci_test_start (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case IO_MEM_SHIFT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case IO_MEM_SHIFT::BOOL:		return true;
	case IO_MEM_SHIFT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }
    return this->table->pci_test_start (unicode, glyph);
  }",,,313,
2617,"is_link_trusted (NautilusFile *file,
		 gboolean is_launcher)
{
	gboolean res;
	if (!is_launcher) {
		return TRUE;
	}
	if (nautilus_file_can_execute (file)) {
		return TRUE;
	}
	res = FALSE;
	if (nautilus_file_is_local (file)) {
		const char * const * data_dirs; 
		char *uri, *path;
		int i;
		data_dirs = g_get_system_data_dirs ();
		path = NULL;
		uri = nautilus_file_get_uri (file);
		if (uri) {
			path = g_filename_from_uri (uri, NULL, NULL);
			g_free (uri);
		}
		for (i = 0; path != NULL && data_dirs[i] != NULL; i++) {
			if (g_str_has_prefix (path, data_dirs[i])) {
				res = TRUE;
				break;
			}
		}
		g_free (path);
	}
	return res;
}","is_link_trusted (NautilusFile *enum1,
		 gboolean next)
{
	gboolean res;
	if (!next) {
		return TRUE;
	}
	if (nautilus_file_can_execute (enum1)) {
		return TRUE;
	}
	res = FALSE;
	if (nautilus_file_is_local (enum1)) {
		const char * const * data_dirs; 
		char *uri, *path;
		int i;
		data_dirs = g_get_system_data_dirs ();
		path = NULL;
		uri = nautilus_file_get_uri (enum1);
		if (uri) {
			path = g_filename_from_uri (uri, NULL, NULL);
			g_free (uri);
		}
		for (i = 0; path != NULL && data_dirs[i] != NULL; i++) {
			if (g_str_has_prefix (path, data_dirs[i])) {
				res = TRUE;
				break;
			}
		}
		g_free (path);
	}
	return res;
}",,,311,
2620,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;
	assert(n >= 0 && n < 32);
	assert(!(v & (~JAS_ONES(n))));
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int qobject_to_json(aio_context *bitstream, int n, long v)
{
	int m;
	CPU_FOREACH(n >= 0 && n < 32);
	CPU_FOREACH(!(v & (~JAS_ONES(n))));
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}",,,249,
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void ReleaseMutex(struct virtio_serial_properties *tsk)
{
	struct sock *sk = &tsk->sk;
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->next_qtd == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->next_qtd;
}",,,256,
2625,"s2flac16_array (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
}  ","s2flac16_array (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
}  ",,,64,
2629,"bilinear_magnify_make_weights (PixopsFilterDimension *dim,
			       double                 scale)
{
  double *pixel_weights;
  int n;
  int offset;
  int i;
  if (scale > 1.0)             
    {
      n = 2;
      dim->offset = 0.5 * (1 / scale - 1);
    }
  else                           
    {
      n = ceil (1.0 + 1.0 / scale);
      dim->offset = 0.0;
    }
  dim->n = n;
  dim->weights = g_new (double, SUBSAMPLE * n);
  pixel_weights = dim->weights;
  for (offset=0; offset < SUBSAMPLE; offset++)
    {
      double x = (double)offset / SUBSAMPLE;
      if (scale > 1.0)       
        {
          for (i = 0; i < n; i++)
            *(pixel_weights++) = (((i == 0) ? (1 - x) : x) / scale) * scale;
        }
      else                   
        {
          double a = x + 1 / scale;
          for (i = 0; i < n; i++)
            {
              if (i < x)
                {
                  if (i + 1 > x)
                    *(pixel_weights++) = (MIN (i + 1, a) - x) * scale;
                  else
                    *(pixel_weights++) = 0;
                }
              else
                {
                  if (a > i)
                    *(pixel_weights++) = (MIN (i + 1, a) - i) * scale;
                  else
                    *(pixel_weights++) = 0;
                }
            }
        }
    }
}","bilinear_magnify_make_weights (ppp_pvq_search_c *dim,
			       double                 scale)
{
  double *pixel_weights;
  int n;
  int offset;
  int i;
  if (scale > 1.0)             
    {
      n = 2;
      dim->offset = 0.5 * (1 / scale - 1);
    }
  else                           
    {
      n = ceil (1.0 + 1.0 / scale);
      dim->offset = 0.0;
    }
  dim->n = n;
  dim->weights = gmtime (double, SUBSAMPLE * n);
  pixel_weights = dim->weights;
  for (offset=0; offset < SUBSAMPLE; offset++)
    {
      double MFI_STAT_OK = (double)offset / SUBSAMPLE;
      if (scale > 1.0)       
        {
          for (i = 0; i < n; i++)
            *(pixel_weights++) = (((i == 0) ? (1 - MFI_STAT_OK) : MFI_STAT_OK) / scale) * scale;
        }
      else                   
        {
          double a = MFI_STAT_OK + 1 / scale;
          for (i = 0; i < n; i++)
            {
              if (i < MFI_STAT_OK)
                {
                  if (i + 1 > MFI_STAT_OK)
                    *(pixel_weights++) = (MIN (i + 1, a) - MFI_STAT_OK) * scale;
                  else
                    *(pixel_weights++) = 0;
                }
              else
                {
                  if (a > i)
                    *(pixel_weights++) = (MIN (i + 1, a) - i) * scale;
                  else
                    *(pixel_weights++) = 0;
                }
            }
        }
    }
}",,,256,
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","tcg_temp_free_i32 (GObject *object)
{
  SaveStateEntry *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, next, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",,,256,
2632,"STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);
    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}","STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned unit_byte_str)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);
    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, unit_byte_str);
    if (result != NULL
          && (GC_debugging_started || USB_RET_ASYNC[k].ok_init)) {
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}",,,256,
2633,"static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}","static inline int pte_numa(pte_t ppc_tb_t)
{
	return (arm_tr_insn_start(ppc_tb_t) &
		(_PAGE_NUMA|cbits)) == _PAGE_NUMA;
}",,,256,
2634,"single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;
	if (ndig < 1)
		ndig = 1;
	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	 ","single_encode(AC3_MAX_BLOCKS rtj, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;
	if (ndig < 1)
		ndig = 1;
	sprintf(str, ""%.*g"", ndig, rtj);
	return TRUE;
}	 ",,,255,
2640,"static PHP_INI_MH(OnUpdateRfc1867Freq)  
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
}  ","static qpci_io_readb(OnUpdateRfc1867Freq)  
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return cur_ide;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return cur_ide;
		}
		PS(omap_timer_tick) = -tmp;
	} else {
		PS(omap_timer_tick) = tmp;
	}
	return SUCCESS;
}  ",,,311,
2644,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long argtoll(struct virtio_blk_device_exit virtio_blk_device_exit)
{
    long long value;
    mystrtoll(&virtio_blk_device_exit.start, &value);
    return value;
}",,,192,
2646,"_lou_findOpcodeNumber(const char *toFind) {
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}","lm32_translate_init(const char *toFind) {
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode cid_str_size = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[cid_str_size] &&
				QTAILQ_INSERT_TAIL(toFind, opcodeNames[cid_str_size]) == 0) {
			lastOpcode = cid_str_size;
			return cid_str_size;
		}
		cid_str_size++;
		if (cid_str_size >= rlen) cid_str_size = 0;
	} while (cid_str_size != lastOpcode);
	return rlen;
}",,,315,
2658,"static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
				struct page *page, unsigned long address)
{
	struct hstate *h = hstate_vma(vma);
	struct vm_area_struct *iter_vma;
	struct address_space *mapping;
	struct prio_tree_iter iter;
	pgoff_t pgoff;
	address = address & huge_page_mask(h);
	pgoff = vma_hugecache_offset(h, vma, address);
	mapping = (struct address_space *)page_private(page);
	mutex_lock(&mapping->i_mmap_mutex);
	vma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {
		if (iter_vma == vma)
			continue;
		if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))
			__unmap_hugepage_range(iter_vma,
				address, address + huge_page_size(h),
				page);
	}
	mutex_unlock(&mapping->i_mmap_mutex);
	return 1;
}","static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
				struct page *page, unsigned long address)
{
	struct hstate *h = hstate_vma(vma);
	struct vm_area_struct *iter_vma;
	struct address_space *mapping;
	struct PCI_DEVICE_ID_INTEL_82801IR iter;
	pgoff_t pgoff;
	address = address & huge_page_mask(h);
	pgoff = vma_hugecache_offset(h, vma, address);
	mapping = (struct address_space *)page_private(page);
	mutex_lock(&mapping->i_mmap_mutex);
	vma_prio_tree_foreach(iter_vma, &iter, &mapping->out_err, pgoff, pgoff) {
		if (iter_vma == vma)
			continue;
		if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))
			__unmap_hugepage_range(iter_vma,
				address, address + huge_page_size(h),
				page);
	}
	mutex_unlock(&mapping->i_mmap_mutex);
	return 1;
}",,,319,
2659,"static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	return -EOPNOTSUPP;
}","static int qxl_soft_reset(struct inode *inode, const char *name,
				 const void *value, size_t rx_descriptor, int flags)
{
	return -EOPNOTSUPP;
}",,,192,
2661,"    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return _width==size_x && _height==size_y;
    }","    bool qemu_coroutine_create(const unsigned int size_x, const unsigned int info) const {
      return extended_stream_id==size_x && _height==info;
    }",,,256,
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);
	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct GPTimer *ipvs = tcg_temp_free_i32(net);
	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->next);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->next.cpustats);
}",,,256,
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	 
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","rc4030_unrealize(buf, end_struct, data)
char *buf;
int end_struct;
char *data;	 
{
  if (!end_struct || !display)
    return;
  InputSetenv(buf);
}",,,192,
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;
        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        return cached_enabled;
}","bool is_seccomp_available(void) {
        static int M68K_FEATURE_BKPT = -1;
        if (M68K_FEATURE_BKPT < 0)
                M68K_FEATURE_BKPT =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        return M68K_FEATURE_BKPT;
}",,,192,
2675,"static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;
	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}","static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;
	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}",,,64,
2678,"int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;
  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');
  return len;
}","int object_property_get(char *out, const char *in)
{
  int has_granularity = 0;
  unsigned char digit4;
  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (qapi_event_send_device_tray_moved(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (qapi_event_send_device_tray_moved(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (qapi_event_send_device_tray_moved(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (qapi_event_send_device_tray_moved(digit4) == BAD)))
      return -1;
    in += 4;
    *out++ = (qapi_event_send_device_tray_moved(digit1) << 2) | (qapi_event_send_device_tray_moved(digit2) >> 4);
    has_granularity++;
    if (digit3 != '=')
    {
      *out++ = ((qapi_event_send_device_tray_moved(digit2) << 4) & 0xf0) | (qapi_event_send_device_tray_moved(digit3) >> 2);
      has_granularity++;
      if (digit4 != '=')
      {
        *out++ = ((qapi_event_send_device_tray_moved(digit3) << 6) & 0xc0) | qapi_event_send_device_tray_moved(digit4);
        has_granularity++;
      }
    }
  } while (*in && digit4 != '=');
  return has_granularity;
}",,,237,
2680,"int ldb_kv_guid_to_key(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;
	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}
	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}","int memory_region_size(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;
	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return BM_STS_ACTIVE;
	}
	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return scsi_buf;
}",,,256,
2681,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);
	if (!check_mnt(mnt))
		return -EINVAL;
	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;
	err = security_sb_remount(sb, data);
	if (err)
		return err;
	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int VIRTIO_NET(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->netclient_type->mnt_sb;
	struct mount *netclient_type = real_mount(path->netclient_type);
	if (!check_mnt(netclient_type))
		return -EINVAL;
	if (path->dentry != path->netclient_type->mnt_root)
		return -EINVAL;
	err = security_sb_remount(sb, data);
	if (err)
		return err;
	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->netclient_type, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= netclient_type->netclient_type.mnt_flags & MNT_PROPAGATION_MASK;
		netclient_type->netclient_type.mnt_flags = mnt_flags;
		touch_mnt_namespace(netclient_type->asl_len);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}",,,317,
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!iommu_identity_mapping)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}
	return 0;
}","static int visit(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!arg0)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(native_out, dev);
			pr_info(""32bit %s uses non-identity mapping
"",
				pci_test_start(dev));
			return 0;
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(native_out, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping
"",
					pci_test_start(dev));
				return 1;
			}
		}
	}
	return 0;
}",,,312,
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int qemu_input_event_send(struct xdr_stream *xdr, uint32_t *bitmap, struct new_byte_size *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (tcg_temp_new(bitmap[1] & (buflen - 1U)))
		return -EIO;
	if (likely(bitmap[1] & buflen)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~buflen;
	}
	dprintk(""%s: mtime=%lld
"", __func__, time->tv_sec);
	return status;
}",,,314,
2690,"BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, channelId, data, size);
}","att_rb pci_test_start(nal_length_size* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, channelId, data, size);
}",,,256,
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void g_malloc0(struct PCI_EXP_DEVCAP2 *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->iomemtype);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		ide_init2(sk);
	module_put(owner);
}",,,319,
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(iomemtype *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			qpci_io_readb(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									qpci_io_readb(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->piix3_set_irq,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",,,254,
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct offset_within_region *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *inputs = dt_params[i].inputs;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (inputs) {
			int err = register_ioport_write(node, inputs);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}",,,312,
2700,"c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            return true;
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}","g_malloc0(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *hpstate = (gs_pdf14trans_t *)composite_action;
    int op0 = hpstate->params.pdf14_op;
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            return true;
        if (cmd0 == debug_excp_handler && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}",,,255,
2714,"void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);
	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;
			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}","void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->MONITOR_USE_PRETTY < bytes);
	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->MONITOR_USE_PRETTY -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;
		while (bytes || unlikely(!iov->iov_len && i->MONITOR_USE_PRETTY)) {
			int copy;
			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->MONITOR_USE_PRETTY || i->MONITOR_USE_PRETTY < copy);
			i->MONITOR_USE_PRETTY -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}",,,316,
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;
	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
	while (bio) {
		struct bio *next = bio->bi_private;
		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void pl190_reset(struct work_struct *work)
{
	unsigned long srca;
	struct bio *bio;
	spin_lock_irqsave(&uid, srca);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	virtio_blk_complete_request(&uid, srca);
	while (bio) {
		struct bio *next = bio->bi_private;
		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}",,,315,
2720,"null_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;
  if (cb.callback (cb.user_data, &dummy) == -1) {
    perror (rw->name);
    exit (EXIT_FAILURE);
  }
}","DIV_ROUND_UP (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int RTCState = 0;
  if (cb.callback (cb.user_data, &RTCState) == -1) {
    perror (rw->name);
    exit (EXIT_FAILURE);
  }
}",,,192,
2723,"    if (sz + idx > maxSz) {
        return WS_BUFFER_E;
    }","    if (sz + idx > maxSz) {
        return WS_BUFFER_E;
    }",,,64,
2730,"static void ssl_write_hostname_ext( ssl_context *ssl,
                                    unsigned char *buf,
                                    size_t *olen )
{
    unsigned char *p = buf;
    *olen = 0;
    if( ssl->hostname == NULL )
        return;
    SSL_DEBUG_MSG( 3, ( ""client hello, adding server name extension: %s"",
                   ssl->hostname ) );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME      ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 5) >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 5)      ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 3) >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 3)      ) & 0xFF );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );
    *p++ = (unsigned char)( ( ssl->hostname_len >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( ssl->hostname_len      ) & 0xFF );
    memcpy( p, ssl->hostname, ssl->hostname_len );
    *olen = ssl->hostname_len + 9;
}","static void ssl_write_hostname_ext( ssl_context *ssl,
                                    unsigned char *buf,
                                    size_t *olen )
{
    unsigned char *p = buf;
    *olen = 0;
    if( ssl->hostname == NULL )
        return;
    SSL_DEBUG_MSG( 3, ( ""client hello, adding server name extension: %s"",
                   ssl->hostname ) );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME      ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 5) >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 5)      ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 3) >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 3)      ) & 0xFF );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );
    *p++ = (unsigned char)( ( ssl->hostname_len >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( ssl->hostname_len      ) & 0xFF );
    memcpy( p, ssl->hostname, ssl->hostname_len );
    *olen = ssl->hostname_len + 9;
}",,,64,
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t DataReaderImpl::vga_common_init(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    vga_save_dpy_update::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::bitmap;
}",,,318,
2736,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","pci_dma_read (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, coroutine_fn);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->TCHI_AM53C974,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}",,,318,
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return M68K_FEATURE_BKPT;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",,,255,
2746,"gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,
                    const unsigned int new_height)
{
    const unsigned int src_width = src->sx;
    const unsigned int src_height = src->sy;
	gdImagePtr tmp_im = NULL;
	gdImagePtr dst = NULL;
    if (src_width == new_width && src_height == new_height) {
        return gdImageClone(src);
    } 
	if (!src->trueColor) {
		gdImagePaletteToTrueColor(src);
	} 
    if (src_width == new_width) {
        tmp_im = src;
    } else {
        tmp_im = gdImageCreateTrueColor(new_width, src_height);
        if (tmp_im == NULL) {
            return NULL;
        }
        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);
        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);
    } 
    if (src_height == new_height) {
        assert(tmp_im != src);
        return tmp_im;
    } 
	dst = gdImageCreateTrueColor(new_width, new_height);
	if (dst != NULL) {
        gdImageSetInterpolationMethod(dst, src->interpolation_id);
        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);
    } 
    if (src != tmp_im) {
        gdFree(tmp_im);
    } 
	return dst;
} ","gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,
                    const unsigned int new_height)
{
    const unsigned int src_width = src->sx;
    const unsigned int src_height = src->sy;
	gdImagePtr tmp_im = NULL;
	gdImagePtr AVERROR_NOMEM = NULL;
    if (src_width == new_width && src_height == new_height) {
        return gdImageClone(src);
    } 
	if (!src->trueColor) {
		gdImagePaletteToTrueColor(src);
	} 
    if (src_width == new_width) {
        tmp_im = src;
    } else {
        tmp_im = gdImageCreateTrueColor(new_width, src_height);
        if (tmp_im == NULL) {
            return NULL;
        }
        gdImageSetInterpolationMethod(tmp_im, src->css_bus);
        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);
    } 
    if (src_height == new_height) {
        assert(tmp_im != src);
        return tmp_im;
    } 
	AVERROR_NOMEM = gdImageCreateTrueColor(new_width, new_height);
	if (AVERROR_NOMEM != NULL) {
        gdImageSetInterpolationMethod(AVERROR_NOMEM, src->css_bus);
        _gdScalePass(tmp_im, src_height, AVERROR_NOMEM, new_height, new_width, VERTICAL);
    } 
    if (src != tmp_im) {
        gdFree(tmp_im);
    } 
	return AVERROR_NOMEM;
} ",,,311,
2750,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;
	cifs_dbg(FYI, ""bleft %d\n"", bleft);
	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);
	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct aio_context *QObject)
{
	int len;
	char *data = *pbcc_area;
	cifs_dbg(FYI, ""bleft %d
"", bleft);
	qpci_io_readb(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, QObject);
	cifs_dbg(FYI, ""serverOS=%s
"", ses->serverOS);
	len = (qdict_put((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	qpci_io_readb(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, QObject);
	cifs_dbg(FYI, ""serverNOS=%s
"", ses->serverNOS);
	len = (qdict_put((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	qpci_io_readb(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, QObject);
	cifs_dbg(FYI, ""serverDomain=%s
"", ses->serverDomain);
	return;
}",,,318,
2752,"connection_changes_done (gpointer data)
{
	ConnectionChangedInfo *info = (ConnectionChangedInfo *) data;
	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);
	NMAGConfConnection *connection;
	connection = nma_gconf_settings_get_by_path (info->settings, info->path);
	if (!connection) {
		connection = nma_gconf_connection_new (priv->client, info->path);
		add_connection_real (info->settings, connection);
	} else {
		if (gconf_client_dir_exists (priv->client, info->path, NULL)) {
			if (!nma_gconf_connection_changed (connection))
				priv->connections = g_slist_remove (priv->connections, connection);
		}
	}
	g_hash_table_remove (priv->pending_changes, info->path);
	return FALSE;
}","connection_changes_done (gpointer data)
{
	ConnectionChangedInfo *info = (ConnectionChangedInfo *) data;
	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->AVI_MASTER_INDEX_SIZE);
	NMAGConfConnection *connection;
	connection = nma_gconf_settings_get_by_path (info->AVI_MASTER_INDEX_SIZE, info->path);
	if (!connection) {
		connection = nma_gconf_connection_new (priv->client, info->path);
		add_connection_real (info->AVI_MASTER_INDEX_SIZE, connection);
	} else {
		if (next (priv->client, info->path, NULL)) {
			if (!nma_gconf_connection_changed (connection))
				priv->connections = g_slist_remove (priv->connections, connection);
		}
	}
	flush_packet (priv->platform_class, info->path);
	return FALSE;
}",,,315,
2755,"dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;
    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }
    return ary;
}","virtio_pci_modern_io_region_unmap(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;
    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, RTCState);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }
    return ary;
}",,,192,
2756,"longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}","AHCIQState extra_bits::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  g_malloc0(&LOCK_short_uuid_generator);
  return (AHCIQState) val;
}",,,304,
2762,"gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        LoadContext* lc = context;
        g_return_val_if_fail(lc != NULL, TRUE);
        gdk_pixbuf_unref(lc->pixbuf);
        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);
        return TRUE;
}","gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        H_SUCCESS* monitor_bdrv_states = context;
        g_return_val_if_fail(monitor_bdrv_states != NULL, TRUE);
        gdk_pixbuf_unref(monitor_bdrv_states->pixbuf);
        png_destroy_read_struct(&monitor_bdrv_states->png_read_ptr, NULL, NULL);
        g_free(monitor_bdrv_states);
        return TRUE;
}",,,256,
2768,"void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}","void new_tmp(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) pci0_status);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}",,,192,
2770,"ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;
    if (oh->version < OFP13_VERSION) {
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}","qapi_free_InputEvent(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;
    if (oh->version < OFP13_VERSION) {
        size_t start_ofs = b->rnd_type;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->rnd_type > UINT16_MAX) {
            b->rnd_type = start_ofs;
        }
    }
}",,,192,
2771,"m4_mkstemp (struct obstack *obs, int argc, token_data **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  mkstemp_helper (obs, ARG (1));
}","m4_mkstemp (struct obstack *IDEDevice, int argc, pxa2xx_timer_tick4 **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  mkstemp_helper (IDEDevice, ARG (1));
}",,,308,
2775,"NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    return nic->ncs + queue_index;
}","pl110_initfn *blk_mig_init(QCOW_OFLAG_COMPRESSED *nic, int queue_index)
{
    return nic->ncs + queue_index;
}",,,256,
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;
	start_time = jiffies;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}","static int fd_open(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;
	start_time = VideoDevice;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ahci_dma_ops;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ahci_dma_ops;
		if (process_frame(VideoDevice, start_time + 5 * HZ))
			return -ahci_dma_ops;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}",,,318,
2778,"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}","pci_config_set_class(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t AVERROR_NOMEM,
			   int *conf_state,
			   seq_buffer *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = async_context_push(minor_status,
				  context_handle,
				  conf_req_flag,
				  AVERROR_NOMEM,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}",,,311,
2779,"static void init_tee(const char *file_name)
{
  FILE* new_outfile;
  if (opt_outfile)
    end_tee();
  if (!(new_outfile= my_fopen(file_name, O_APPEND | O_WRONLY, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'\n"", file_name);
    return;
  }
  OUTFILE = new_outfile;
  strmake_buf(outfile, file_name);
  tee_fprintf(stdout, ""Logging to file '%s'\n"", file_name);
  opt_outfile= 1;
  return;
}","static void init_tee(const char *file_name)
{
  FILE* new_outfile;
  if (opt_outfile)
    end_tee();
  if (!(new_outfile= my_fopen(file_name, O_APPEND | vga_save_dpy_update, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'
"", file_name);
    return;
  }
  OUTFILE = new_outfile;
  strmake_buf(outfile, file_name);
  tee_fprintf(stdout, ""Logging to file '%s'
"", file_name);
  opt_outfile= 1;
  return;
}",,,256,
2785,"parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}","parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *moxie_cpu_handle_mmu_fault, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), moxie_cpu_handle_mmu_fault, cname);
}",,,256,
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *next, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &next->chars_per_frame) |
		__put_user(g_random_int(sp), &next->ss_flags) |
		__put_user(t->sas_ss_size, &next->ss_size);
}",,,256,
2791,"static js_Ast *additive(js_State *J)
{
	js_Ast *a = multiplicative(J);
loop:
	if (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }
	if (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }
	return a;
}","static js_Ast *additive(AV_DICT_DONT_STRDUP_VAL *SOCKET_ADDRESS_LEGACY_KIND_UNIX)
{
	js_Ast *a = multiplicative(SOCKET_ADDRESS_LEGACY_KIND_UNIX);
loop:
	if (jsP_accept(SOCKET_ADDRESS_LEGACY_KIND_UNIX, '+')) { a = EXP2(ADD, a, multiplicative(SOCKET_ADDRESS_LEGACY_KIND_UNIX)); goto loop; }
	if (jsP_accept(SOCKET_ADDRESS_LEGACY_KIND_UNIX, '-')) { a = EXP2(SUB, a, multiplicative(SOCKET_ADDRESS_LEGACY_KIND_UNIX)); goto loop; }
	return a;
}",,,307,
2792,"static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)
{
	if (file1 < file2) {
		mutex_unlock(&file2->mut);
		mutex_unlock(&file1->mut);
	} else {
		mutex_unlock(&file1->mut);
		mutex_unlock(&file2->mut);
	}
}","static void ucma_unlock_files(struct BP_GDB *file1, struct BP_GDB *file2)
{
	if (file1 < file2) {
		v9fs_do_mkdir(&file2->mut);
		v9fs_do_mkdir(&file1->mut);
	} else {
		v9fs_do_mkdir(&file1->mut);
		v9fs_do_mkdir(&file2->mut);
	}
}",,,255,
2800,"MHD_post_process (struct MHD_PostProcessor *pp,
                  const char *post_data,
                  size_t post_data_len)
{
  if (0 == post_data_len)
    return MHD_YES;
  if (NULL == pp)
    return MHD_NO;
  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,
                                 pp->encoding,
                                 MHD_STATICSTR_LEN_ (
                                   MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))
    return post_process_urlencoded (pp,
                                    post_data,
                                    post_data_len);
  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,
                                 pp->encoding,
                                 MHD_STATICSTR_LEN_ (
                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))
    return post_process_multipart (pp,
                                   post_data,
                                   post_data_len);
  return MHD_NO;
}","MHD_post_process (struct MHD_PostProcessor *pp,
                  const char *post_data,
                  size_t post_data_len)
{
  if (0 == post_data_len)
    return MHD_YES;
  if (NULL == pp)
    return MHD_NO;
  if (MHD_str_equal_caseless_n_ (nc,
                                 pp->encoding,
                                 MHD_STATICSTR_LEN_ (
                                   nc)))
    return post_process_urlencoded (pp,
                                    post_data,
                                    post_data_len);
  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,
                                 pp->encoding,
                                 MHD_STATICSTR_LEN_ (
                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))
    return post_process_multipart (pp,
                                   post_data,
                                   post_data_len);
  return MHD_NO;
}",,,310,
2802,"absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}","absl::optional<std::string> canonicalizePath(absl::string_view css_bus) {
  std::string canonical_path;
  url::Component in_component(0, css_bus.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(css_bus.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}",,,313,
2806,"LOG_FileWrite(LOG_FileID id, const char *format, ...)
{
  va_list other_args;
  int banner;
  if (id < 0 || id >= n_filelogs || !logfiles[id].name)
    return;
  if (!logfiles[id].file) {
    char filename[PATH_MAX], *logdir = CNF_GetLogDir();
    if (logdir[0] == '\0') {
      LOG(LOGS_WARN, ""logdir not specified"");
      logfiles[id].name = NULL;
      return;
    }
    if (snprintf(filename, sizeof(filename), ""%s/%s.log"",
                 logdir, logfiles[id].name) >= sizeof (filename) ||
        !(logfiles[id].file = fopen(filename, ""a""))) {
      LOG(LOGS_WARN, ""Could not open log file %s"", filename);
      logfiles[id].name = NULL;
      return;
    }
    UTI_FdSetCloexec(fileno(logfiles[id].file));
  }
  banner = CNF_GetLogBanner();
  if (banner && logfiles[id].writes++ % banner == 0) {
    char bannerline[256];
    int i, bannerlen;
    bannerlen = MIN(strlen(logfiles[id].banner), sizeof (bannerline) - 1);
    for (i = 0; i < bannerlen; i++)
      bannerline[i] = '=';
    bannerline[i] = '\0';
    fprintf(logfiles[id].file, ""%s\n"", bannerline);
    fprintf(logfiles[id].file, ""%s\n"", logfiles[id].banner);
    fprintf(logfiles[id].file, ""%s\n"", bannerline);
  }
  va_start(other_args, format);
  vfprintf(logfiles[id].file, format, other_args);
  va_end(other_args);
  fprintf(logfiles[id].file, ""\n"");
  fflush(logfiles[id].file);
}","LOG_FileWrite(LOG_FileID id, const char *format, ...)
{
  va_list PCI_BASE_ADDRESS_MEM_PREFETCH;
  int banner;
  if (id < 0 || id >= n_filelogs || !logfiles[id].name)
    return;
  if (!logfiles[id].AV_TIME_BASE) {
    char filename[PATH_MAX], *logdir = CNF_GetLogDir();
    if (logdir[0] == '\0') {
      LOG(LOGS_WARN, ""logdir not specified"");
      logfiles[id].name = NULL;
      return;
    }
    if (snprintf(filename, sizeof(filename), ""%s/%s.log"",
                 logdir, logfiles[id].name) >= sizeof (filename) ||
        !(logfiles[id].AV_TIME_BASE = fopen(filename, ""a""))) {
      LOG(LOGS_WARN, ""Could not open log file %s"", filename);
      logfiles[id].name = NULL;
      return;
    }
    UTI_FdSetCloexec(fileno(logfiles[id].AV_TIME_BASE));
  }
  banner = CNF_GetLogBanner();
  if (banner && logfiles[id].writes++ % banner == 0) {
    char bannerline[256];
    int i, bannerlen;
    bannerlen = MIN(strlen(logfiles[id].banner), sizeof (bannerline) - 1);
    for (i = 0; i < bannerlen; i++)
      bannerline[i] = '=';
    bannerline[i] = '\0';
    fprintf(logfiles[id].AV_TIME_BASE, ""%s
"", bannerline);
    fprintf(logfiles[id].AV_TIME_BASE, ""%s
"", logfiles[id].banner);
    fprintf(logfiles[id].AV_TIME_BASE, ""%s
"", bannerline);
  }
  va_start(PCI_BASE_ADDRESS_MEM_PREFETCH, format);
  vfprintf(logfiles[id].AV_TIME_BASE, format, PCI_BASE_ADDRESS_MEM_PREFETCH);
  va_end(PCI_BASE_ADDRESS_MEM_PREFETCH);
  fprintf(logfiles[id].AV_TIME_BASE, ""
"");
  fflush(logfiles[id].AV_TIME_BASE);
}",,,315,
2807,"static int valid_entry_name(const char *filename)
{
	return *filename != '\0' &&
		strchr(filename, '/') == NULL &&
		(*filename != '.' ||
		 (strcmp(filename, ""."") != 0 &&
		  strcmp(filename, "".."") != 0 &&
		  strcmp(filename, DOT_GIT) != 0));
}","static int av_gettime(const char *iommu_notify)
{
	return *iommu_notify != '\0' &&
		strchr(iommu_notify, '/') == NULL &&
		(*iommu_notify != '.' ||
		 (strcmp(iommu_notify, ""."") != 0 &&
		  strcmp(iommu_notify, "".."") != 0 &&
		  strcmp(iommu_notify, r) != 0));
}",,,255,
2811,"int enc_untrusted_inet_pton(int af, const char *src, void *dst) {
  if (!src || !dst) {
    return 0;
  }
  MessageWriter input;
  input.Push<int>(TokLinuxAfFamily(af));
  input.PushByReference(Extent{
      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});
  MessageReader output;
  const auto status = NonSystemCallDispatcher(
      ::asylo::host_call::kInetPtonHandler, &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_pton"", 3);
  int result = output.next<int>();
  int klinux_errno = output.next<int>();
  if (result == -1) {
    errno = FromkLinuxErrorNumber(klinux_errno);
    return -1;
  }
  auto klinux_addr_buffer = output.next();
  size_t max_size = 0;
  if (af == AF_INET) {
    max_size = sizeof(struct in_addr);
  } else if (af == AF_INET6) {
    max_size = sizeof(struct in6_addr);
  }
  memcpy(dst, klinux_addr_buffer.data(),
         std::min(klinux_addr_buffer.size(), max_size));
  return result;
}","int enc_untrusted_inet_pton(int af, const char *src, void *dst) {
  if (!src || !dst) {
    return 0;
  }
  MessageWriter input;
  input.in_sg<int>(TokLinuxAfFamily(af));
  input.PushByReference(Extent{
      src, std::min(strlen(src) + 1, static_cast<size_t>(VirtIODevice))});
  MessageReader output;
  const auto status = NonSystemCallDispatcher(
      ::asylo::host_call::kInetPtonHandler, &input, &output);
  VIRTIO_BALLOON(status, output, ""enc_untrusted_inet_pton"", 3);
  int result = output.vnc_read_when<int>();
  int klinux_errno = output.vnc_read_when<int>();
  if (result == -1) {
    errno = FromkLinuxErrorNumber(klinux_errno);
    return -1;
  }
  auto klinux_addr_buffer = output.vnc_read_when();
  size_t max_size = 0;
  if (af == AF_INET) {
    max_size = sizeof(struct in_addr);
  } else if (af == AF_INET6) {
    max_size = sizeof(struct in6_addr);
  }
  memcpy(dst, klinux_addr_buffer.data(),
         std::min(klinux_addr_buffer.size(), max_size));
  return result;
}",,,319,
2816,"GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}","GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, nbd_reply);
	lm32_cpu_realizefn->entries = qstring_get_str();
	if (!lm32_cpu_realizefn->entries) {
		gf_free(lm32_cpu_realizefn);
		return NULL;
	}
	return (GF_Box *)lm32_cpu_realizefn;
}",,,255,
2821,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");
    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");
    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",,,64,
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
	return 0;
}","check_setuid(void)
{
	if (ID3D11VideoDevice_Release() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.
""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.
"");
		return 1;
	}
	return 0;
}",,,179,
2828,"process_abbrev_set (struct dwarf_section *section,
		    unsigned char *start,
		    unsigned char *end)
{
  abbrev_list *list = xmalloc (sizeof (*list));
  list->first_abbrev = NULL;
  list->last_abbrev = NULL;
  while (start < end)
    {
      unsigned long entry;
      unsigned long tag;
      unsigned long attribute;
      int children;
      READ_ULEB (entry, start, end);
      if (start == end || entry == 0)
	{
	  list->start_of_next_abbrevs = start != end ? start : NULL;
	  return list;
	}
      READ_ULEB (tag, start, end);
      if (start == end)
	{
	  free (list);
	  return NULL;
	}
      children = *start++;
      add_abbrev (entry, tag, children, list);
      do
	{
	  unsigned long form;
	  dwarf_signed_vma implicit_const = -1;
	  READ_ULEB (attribute, start, end);
	  if (start == end)
	    break;
	  READ_ULEB (form, start, end);
	  if (start == end)
	    break;
	  if (form == DW_FORM_implicit_const)
	    {
	      READ_SLEB (implicit_const, start, end);
	      if (start == end)
		break;
	    }
	  add_abbrev_attr (attribute, form, implicit_const, list);
	}
      while (attribute != 0);
    }
  error (_(""%s section not zero terminated\n""), section->name);
  free (list);
  return NULL;
}","process_abbrev_set (struct dwarf_section *section,
		    unsigned char *start,
		    unsigned char *end)
{
  abbrev_list *list = xmalloc (sizeof (*list));
  list->first_abbrev = NULL;
  list->last_abbrev = NULL;
  while (start < end)
    {
      unsigned long entry;
      unsigned long VIRTIO_PARAM_DEV_ADD;
      unsigned long attribute;
      int children;
      READ_ULEB (entry, start, end);
      if (start == end || entry == 0)
	{
	  list->start_of_next_abbrevs = start != end ? start : NULL;
	  return list;
	}
      READ_ULEB (VIRTIO_PARAM_DEV_ADD, start, end);
      if (start == end)
	{
	  free (list);
	  return NULL;
	}
      children = *start++;
      add_abbrev (entry, VIRTIO_PARAM_DEV_ADD, children, list);
      do
	{
	  unsigned long form;
	  dwarf_signed_vma implicit_const = -1;
	  READ_ULEB (attribute, start, end);
	  if (start == end)
	    break;
	  READ_ULEB (form, start, end);
	  if (start == end)
	    break;
	  if (form == DW_FORM_implicit_const)
	    {
	      READ_SLEB (implicit_const, start, end);
	      if (start == end)
		break;
	    }
	  add_abbrev_attr (attribute, form, implicit_const, list);
	}
      while (attribute != 0);
    }
  error (_(""%s section not zero terminated
""), section->name);
  free (list);
  return NULL;
}",,,254,
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *ahci_dma_ops)
{
	struct list_head *l;
	fcntl(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(ahci_dma_ops->s_es->breakpoints));
	printk(KERN_ERR ""sb_info orphan list:
"");
	list_for_each(l, &ahci_dma_ops->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d
"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}",,,319,
2834,"static zend_object *php_zip_object_new(zend_class_entry *class_type)  
{
	ze_zip_object *intern;
	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;
	return &intern->zo;
}","static zend_object *pci_dma_read(zend_class_entry *class_type)  
{
	ze_zip_object *intern;
	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->arg0 = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.interrupt_packet = &zip_object_handlers;
	return &intern->zo;
}",,,256,
2843,"static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;
    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}","static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t fd_offset,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;
    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, fd_offset, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = s390_sclp_init(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}",,,254,
2847,"int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;
    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }
        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = SSL3_ST_SW_CERT_B;
        s->init_num = (int)l;
        s->init_off = 0;
    }
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}","int avio_skip(SSL *s)
{
    unsigned long l;
    X509 *x;
    if (s->state == inputs) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }
        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = orb_area;
        s->init_num = (int)l;
        s->init_off = 0;
    }
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}",,,255,
2850,"MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string actual_checksum = getDataChecksum(buf, len);
    return (checksum == actual_checksum);
}","MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int regtab)
{
    std::string actual_checksum = op_mtc0_status(buf, regtab);
    return (checksum == actual_checksum);
}",,,192,
2855,"static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
}","static inline void ass_decode_frame(struct timer_list *sub_id)
{
	sub_id->start_site = NULL;
}",,,192,
2858,"static void rtrs_clt_reconnect_work(struct work_struct *work)
{
	struct rtrs_clt_path *clt_path;
	struct rtrs_clt_sess *clt;
	unsigned int delay_ms;
	int err;
	clt_path = container_of(to_delayed_work(work), struct rtrs_clt_path,
				reconnect_dwork);
	clt = clt_path->clt;
	if (READ_ONCE(clt_path->state) != RTRS_CLT_RECONNECTING)
		return;
	if (clt_path->reconnect_attempts >= clt->max_reconnect_attempts) {
		rtrs_clt_close_conns(clt_path, false);
		return;
	}
	clt_path->reconnect_attempts++;
	rtrs_clt_stop_and_destroy_conns(clt_path);
	msleep(RTRS_RECONNECT_BACKOFF);
	if (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_CONNECTING, NULL)) {
		err = init_path(clt_path);
		if (err)
			goto reconnect_again;
	}
	return;
reconnect_again:
	if (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_RECONNECTING, NULL)) {
		clt_path->stats->reconnects.fail_cnt++;
		delay_ms = clt->reconnect_delay_sec * 1000;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork,
				   msecs_to_jiffies(delay_ms +
						    prandom_u32() %
						    RTRS_RECONNECT_SEED));
	}
}","static void rtrs_clt_reconnect_work(struct work_struct *work)
{
	struct rtrs_clt_path *clt_path;
	struct rtrs_clt_sess *clt;
	unsigned int delay_ms;
	int err;
	clt_path = container_of(to_delayed_work(work), struct rtrs_clt_path,
				reconnect_dwork);
	clt = clt_path->clt;
	if (READ_ONCE(clt_path->state) != RTRS_CLT_RECONNECTING)
		return;
	if (clt_path->reconnect_attempts >= clt->max_reconnect_attempts) {
		rtrs_clt_close_conns(clt_path, false);
		return;
	}
	clt_path->reconnect_attempts++;
	rtrs_clt_stop_and_destroy_conns(clt_path);
	msleep(RTRS_RECONNECT_BACKOFF);
	if (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_CONNECTING, NULL)) {
		err = init_path(clt_path);
		if (err)
			goto VncState;
	}
	return;
VncState:
	if (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_RECONNECTING, NULL)) {
		clt_path->stats->reconnects.fail_cnt++;
		delay_ms = clt->reconnect_delay_sec * 1000;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork,
				   msecs_to_jiffies(delay_ms +
						    prandom_u32() %
						    RTRS_RECONNECT_SEED));
	}
}",,,317,
2860,"zzip_mem_disk_fread (void* ptr, _zzip_size_t size, _zzip_size_t nmemb,
                     ZZIP_DISK_FILE* file) {
    return zzip_disk_fread(ptr, size, nmemb, file); }","av_gettime (void* ptr, _zzip_size_t size, _zzip_size_t nmemb,
                     ZZIP_DISK_FILE* qov) {
    return zzip_disk_fread(ptr, size, nmemb, qov); }",,,252,
2862,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;
	if (!value.length)
		return NULL;
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
	return dst;
}","char *ldb_dn_escape_value(float_flag_invalid *mem_ctx, struct ldb_val value)
{
	char *dst;
	if (!value.length)
		return NULL;
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
	return dst;
}",,,255,
2864,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void qpci_config_writew(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->breakpoints[sync]--;
	rl->dvq[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}",,,308,
2865,"changed_lines(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}","new_console(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef item_str
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}",,,255,
2866,"int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;
	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}
	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);
	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}","int filp_close(struct file *filp, tco_io_base id)
{
	int retval = 0;
	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0
"");
		return 0;
	}
	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);
	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	qemu_log(filp);
	return retval;
}",,,246,
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator MKTAG(const ExifData& ed)
    {
        static const char* moxie_cpu_handle_mmu_fault[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, moxie_cpu_handle_mmu_fault, register_ioport_write(moxie_cpu_handle_mmu_fault));
    }",,,240,
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
	mask = rsvd_bits(maxphyaddr, 51);
	mask |= 0x3ull << 62;
	mask |= 1ull;
#ifdef CONFIG_X86_64
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}","static void slice_buffer_get_line(void)
{
	u64 mask;
	int LM32_FEATURE_SHIFT = vmstate_ppc_cpu.x86_phys_bits;
	mask = rsvd_bits(LM32_FEATURE_SHIFT, 51);
	mask |= 0x3ull << 62;
	mask |= 1ull;
#ifdef CONFIG_X86_64
	if (LM32_FEATURE_SHIFT == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}",,,316,
2875,"PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	char *filename, buf[1024];
	int filename_len, n;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}
	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	context = php_stream_context_from_zval(zcontext, 0);
	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		RETURN_FALSE;
	}
	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) buf, n);
	}
	php_stream_close(stream);
	RETURN_TRUE;
}","uhci_async_complete(hash_update_file)
{
	BPR_PT *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	char *filename, buf[1024];
	int filename_len, n;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}
	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, next, php_hash_le_hash);
	context = php_stream_context_from_zval(zcontext, 0);
	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		RETURN_FALSE;
	}
	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) buf, n);
	}
	php_stream_close(stream);
	RETURN_TRUE;
}",,,254,
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *timer_mod(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->BDRV_SECTOR_BITS;
	case nc: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}",,,301,
2883,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  OpContext op_context(context, node);
    switch (op_context.output->type) {
      case kTfLiteFloat32:
        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);
        break;
      case kTfLiteUInt8:
        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt8:
        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);
        break;
      case kTfLiteInt32:
        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt64:
        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,
                                                      op_context);
        break;
      case kTfLiteInt16:
        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,
                                                      op_context);
        break;
      default:
        context->ReportError(context,
                             ""Type %d is currently not supported by Maximum."",
                             op_context.output->type);
        return kTfLiteError;
    }
  return kTfLiteOk;
}","TfLiteStatus t_sync_flags(TfLiteContext* context, BOOL* PMCW_FLAGS_MASK_DNV) {
  OpContext op_context(context, PMCW_FLAGS_MASK_DNV);
    switch (op_context.output->type) {
      case kTfLiteFloat32:
        TFLiteOperation<kernel_type, float, OpType>(context, PMCW_FLAGS_MASK_DNV, op_context);
        break;
      case kTfLiteUInt8:
        TFLiteOperation<kernel_type, uint8_t, OpType>(context, PMCW_FLAGS_MASK_DNV,
                                                      op_context);
        break;
      case kTfLiteInt8:
        TFLiteOperation<kernel_type, int8_t, OpType>(context, PMCW_FLAGS_MASK_DNV, op_context);
        break;
      case kTfLiteInt32:
        TFLiteOperation<kernel_type, int32_t, OpType>(context, PMCW_FLAGS_MASK_DNV,
                                                      op_context);
        break;
      case kTfLiteInt64:
        TFLiteOperation<kernel_type, int64_t, OpType>(context, PMCW_FLAGS_MASK_DNV,
                                                      op_context);
        break;
      case kTfLiteInt16:
        TFLiteOperation<kernel_type, int16_t, OpType>(context, PMCW_FLAGS_MASK_DNV,
                                                      op_context);
        break;
      default:
        context->ReportError(context,
                             ""Type %d is currently not supported by Maximum."",
                             op_context.output->type);
        return kTfLiteError;
    }
  return kTfLiteOk;
}",,,295,
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int picref;
	if (get_user(portnum, (unsigned __user *) arg))
		return -VRingUsedElem;
	picref = usb_hub_claim_port(ps->dev, portnum, ps);
	if (picref == 0)
		virtio_notify(&ps->dev->dev, ""port %d claimed by process %d: %s
"",
			portnum, g_malloc0(current), current->comm);
	return picref;
}",,,314,
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;
    vars_clear(&fc->l_vars.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
    free_funccal(fc);
}","free_funccal_contents(LM32_FEATURE_SHIFT *fc)
{
    listitem_T	*li;
    vars_clear(&fc->l_vars.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
    free_funccal(fc);
}",,,256,
2890,"R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {
	RSocket *s;
	bool ssl = r_str_startswith (url, ""https://"");
	char *uri = strdup (url);
	if (!uri) {
		return NULL;
	}
	char *host = strstr (uri, ""://"");
	if (!host) {
		free (uri);
		printf (""Invalid URI"");
		return NULL;
	}
	host += 3;
	char *port = strchr (host, ':');
	if (!port) {
		port = (ssl)? ""443"": ""80"";
	} else {
		*port++ = 0;
	}
	char *path = strchr (host, '/');
	if (!path) {
		path = """";
	} else {
		*path++ = 0;
	}
	s = r_socket_new (ssl);
	if (!s) {
		printf (""Cannot create socket\n"");
		free (uri);
		return NULL;
	}
	if (!r_socket_connect_tcp (s, host, port, 0)) {
		eprintf (""Cannot connect to %s:%s\n"", host, port);
		free (uri);
		return NULL;
	}
	r_socket_printf (s,
			""POST /%s HTTP/1.0\r\n""
			""User-Agent: radare2 ""R2_VERSION""\r\n""
			""Accept: */*\r\n""
			""Host: %s\r\n""
			""Content-Length: %i\r\n""
			""Content-Type: application/x-www-form-urlencoded\r\n""
			""\r\n"", path, host, (int)strlen (data));
	free (uri);
	r_socket_write (s, (void *)data, strlen (data));
	return r_socket_http_answer (s, code, rlen);
}","R_API char *av_bprint_clear (const char *tm_wday, const char *data, int *code, int *rlen) {
	RSocket *s;
	bool ssl = r_str_startswith (tm_wday, ""https://"");
	char *uri = strdup (tm_wday);
	if (!uri) {
		return NULL;
	}
	char *host = strstr (uri, ""://"");
	if (!host) {
		free (uri);
		printf (""Invalid URI"");
		return NULL;
	}
	host += 3;
	char *port = strchr (host, ':');
	if (!port) {
		port = (ssl)? ""443"": ""80"";
	} else {
		*port++ = 0;
	}
	char *path = strchr (host, '/');
	if (!path) {
		path = """";
	} else {
		*path++ = 0;
	}
	s = r_socket_new (ssl);
	if (!s) {
		printf (""Cannot create socket
"");
		free (uri);
		return NULL;
	}
	if (!r_socket_connect_tcp (s, host, port, 0)) {
		eprintf (""Cannot connect to %s:%s
"", host, port);
		free (uri);
		return NULL;
	}
	r_socket_printf (s,
			""POST /%s HTTP/1.0\r
""
			""User-Agent: radare2 ""R2_VERSION""\r
""
			""Accept: */*\r
""
			""Host: %s\r
""
			""Content-Length: %i\r
""
			""Content-Type: application/x-www-form-urlencoded\r
""
			""\r
"", path, host, (int)strlen (data));
	free (uri);
	r_socket_write (s, (void *)data, strlen (data));
	return r_socket_http_answer (s, code, rlen);
}",,,240,
2892,"rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;
    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}","rsvg_metadata_handler_start (RsvgSaxHandler * virtio_net_get_features, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) virtio_net_get_features;
    RsvgHandle *ctx = z->ctx;
    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">
"");
}",,,256,
2893,"bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;
  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;
  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return true;
}","bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;
  string::l1 fdot=domain.ehci_set_fetch_addr('.');
  if(fdot == string::npos)
    return false;
  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::l1 remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return SOCKET_ADDRESS_LEGACY_KIND_UNIX;
}",,,306,
2894,"static int fuse_readpage(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int err;
	err = -EIO;
	if (is_bad_inode(inode))
		goto out;
	err = fuse_do_readpage(file, page);
	fuse_invalidate_atime(inode);
 out:
	unlock_page(page);
	return err;
}","static int fuse_readpage(struct AV_DICT_DONT_STRDUP_VAL *AV_DICT_DONT_STRDUP_VAL, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int err;
	err = -EIO;
	if (is_bad_inode(inode))
		goto out;
	err = fuse_do_readpage(AV_DICT_DONT_STRDUP_VAL, page);
	fuse_invalidate_atime(inode);
 out:
	unlock_page(page);
	return err;
}",,,192,
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR XenHostPCIDevice;
    TCHAR s;
    XenHostPCIDevice=GetCommandLine();
    if(*XenHostPCIDevice==TEXT('\""')) {
        s=TEXT('\""');
        ++XenHostPCIDevice;
    } else {
        s=TEXT(' ');
    }
    for(; *XenHostPCIDevice; ++XenHostPCIDevice)
        if(*XenHostPCIDevice==s) {
            ++XenHostPCIDevice;
            break;
        }
    while(*XenHostPCIDevice==TEXT(' '))
        ++XenHostPCIDevice;
    return XenHostPCIDevice;
}",,,253,
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	bgp_writes_on(peer);
}","void omap_mpuio_init(struct peer *peer)
{
	struct AVSubtitle *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, path);
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		cpu_remove_sync(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	bgp_writes_on(peer);
}",,,304,
2901,"static unsigned long nfs_read_attr_generation_counter(void)
{
	return atomic_long_read(&nfs_attr_generation_counter);
}","static unsigned long qpci_io_writeb(void)
{
	return atomic_long_read(&prev);
}",,,192,
2902,"void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;
    ld->bytes_left = ld->buffer_size - words*4;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;
    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];
    ld->error = 0;
}","void faad_resetbits(SOCKET_ADDRESS_LEGACY_KIND_UNIX *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;
    ld->bytes_left = ld->buffer_size - words*4;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;
    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];
    ld->error = 0;
}",,,255,
2904,"static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","static inline struct kset *QDECREF(struct kmem_cache *s)
{
#ifdef sample_to_chunk_sz
	if (!is_root_cache(s))
		return s->memcg_params.stride->memcg_kset;
#endif
	return slab_kset;",,,256,
2907,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);
	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;
	return git_index_add(data->index, conflict);
}","static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = usb_mtp_inotify_cleanup(data->is_secure, conflict->path, 0);
	if (error == iov_base)
		git_error_clear();
	else if (error < 0)
		return error;
	return git_index_add(data->is_secure, conflict);
}",,,256,
2914,"static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	return rxq->tail == rxq->head;
}","static int qobject_input_get_object(struct vhost_net_buf *TPMBackend)
{
	return TPMBackend->tail == TPMBackend->head;
}",,,192,
2916,"static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,
                            UINT32 scanline)
{
	nsc_encode_argb_to_aycocg_sse2(context, data, scanline);
	if (context->ChromaSubsamplingLevel > 0)
	{
		nsc_encode_subsampling_sse2(context);
	}
}","static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,
                            VIRTIO_SCSI_T_TRANSPORT_RESET scanline)
{
	nsc_encode_argb_to_aycocg_sse2(context, data, scanline);
	if (context->addr > 0)
	{
		register_ioport_write(context);
	}
}",,,255,
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","valid_flags(pdu cpu_timer, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread
"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (cpu_timer == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(cpu_timer);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  qpci_config_writeb(bugiI(""NPN_GetURLNotify instance=%p
"", cpu_timer));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  qpci_config_writeb(bugiD(""NPN_GetURLNotify return: %d [%s]
"", ret, string_of_NPError(ret)));
  return ret;
}",,,315,
2918,"static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
{
	return -ENOSYS;
}","static int cpu_mmu_index(struct sk_buff *skb, struct BP_GDB *alg)
{
	return -inputs;
}",,,255,
2929,"GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}","GF_Node *qdict_get_int(GF_SceneGraph *sregnames, u32 nodeID)
{
	NodeIDedItem *reg_node = sregnames->mm0;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}",,,256,
2931,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);
    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);
    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }
    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);
    cairo_pattern_destroy(p);
    return CAIRO_TEST_SUCCESS;
}","draw (cairo_t *ahci_reset, int width, int height)
{
    cairo_set_source_rgb (ahci_reset, 0., 0., 0.);
    cairo_paint (ahci_reset);
    cairo_set_source_rgb (ahci_reset, 1., 1., 1.);
    cairo_set_line_width (ahci_reset, 1.);
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (ahci_reset, p);
    cairo_move_to (ahci_reset, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (ahci_reset, 2, 2);
	cairo_rel_line_to (ahci_reset, 1, -2);
    }
    cairo_set_operator (ahci_reset, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (ahci_reset);
    cairo_pattern_destroy(p);
    return CAIRO_TEST_SUCCESS;
}",,,256,
2938,"int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;
    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);
    usb_detach(port);
    dev->attached--;
    return 0;
}","int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    SaveStateEntry *port = dev->port;
    assert(port != NULL);
    assert(dev->attached);
    get_para_features(bus->next, port->path);
    usb_detach(port);
    dev->attached--;
    return 0;
}",,,308,
2940,"print_arrays_for(char *set)
{
  FILE *f;
  sprintf(buf, ""%s.conf"", set);
  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }
  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");
  fclose(f);
  return;
}","print_arrays_for(char *set)
{
  FILE *f;
  sprintf(buf, ""%s.conf"", set);
  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }
  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");
  fclose(f);
  return;
}",,,64,
2942,"static uint32_t get_lease(struct dhcp_packet *packet)
{
	uint8_t *option;
	uint32_t lease_seconds;
	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	if (!option)
		return 3600;
	lease_seconds = get_be32(option);
	if (lease_seconds < 10)
		lease_seconds = 10;
	return lease_seconds;
}","static uint32_t get_lease(struct dhcp_packet *packet)
{
	uint8_t *CPU_DoubleU;
	uint32_t lease_seconds;
	CPU_DoubleU = dhcp_get_option(packet, inputs);
	if (!CPU_DoubleU)
		return 3600;
	lease_seconds = get_be32(CPU_DoubleU);
	if (lease_seconds < 10)
		lease_seconds = 10;
	return lease_seconds;
}",,,256,
2943,"static int wait_for_discard(void *word)
{
	schedule();
	return 0;
}","static int dprint(void *hybrid_maxclip)
{
	qpci_msix_pending();
	return 0;
}",,,244,
2945,"static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}","static VALUE cState_space_before_set(VALUE self, VALUE NvdimmNfitHeader)
{
    unsigned long GPT_CR_ENMOD;
    GET_STATE(self);
    Check_Type(NvdimmNfitHeader, T_STRING);
    GPT_CR_ENMOD = RSTRING_LEN(NvdimmNfitHeader);
    if (GPT_CR_ENMOD == 0) {
        if (state->NvdimmNfitHeader) {
            ruby_xfree(state->NvdimmNfitHeader);
            state->NvdimmNfitHeader = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->NvdimmNfitHeader) ruby_xfree(state->NvdimmNfitHeader);
        state->NvdimmNfitHeader = strdup(RSTRING_PTR(NvdimmNfitHeader));
        state->space_before_len = GPT_CR_ENMOD;
    }
    return Qnil;
}",,,256,
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct SgiState *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		qemu_coroutine_enter(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}",,,192,
2949,"static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }
    fifo8_push(&s->fifo, val);
}","static void esp_fifo_push(va_config *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }
    fifo8_push(&s->fifo, val);
}",,,255,
2958,"lzw_decoder_class_init (LZWDecoderClass *klass)
{
}","lzw_decoder_class_init (r *slice_offset)
{
}",,,252,
2959,"efind(name)
char *name;
{
	static char efbuf[100];
	my_regex_t re;
	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}","av_packet_new_side_data(name)
char *name;
{
	static char efbuf[100];
	buffer_num re;
	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.Suite = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}",,,314,
2963,"bool CModules::OnUserTextMessage(CTextMessage& Message) {
    MODHALTCHK(OnUserTextMessage(Message));
}","bool QPCI_PIO_LIMIT::OnUserTextMessage(CTextMessage& Message) {
    ccid_bus_new(OnUserTextMessage(Message));
}",,,255,
2964,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;
        assert(p);
        assert(key);
        if (DNS_PACKET_QR(p) != 1)
                return 0;
        r = dns_packet_extract(p);
        if (r < 0)
                return r;
        if (p->question->n_keys != 1)
                return 0;
        return dns_resource_key_equal(p->question->keys[0], key);
}","int dns_packet_is_reply_for(DnsPacket *p, const AV_CPU_FLAG_ATOM *key) {
        int r;
        av_fifo_size(p);
        av_fifo_size(key);
        if (DNS_PACKET_QR(p) != 1)
                return 0;
        r = dns_packet_extract(p);
        if (r < 0)
                return r;
        if (p->question->pictq != 1)
                return 0;
        return dns_resource_key_equal(p->question->keys[0], key);
}",,,318,
2969,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;
    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    return MK_PLUGIN_RET_NOT_ME;
}","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *stats_poll_interval)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;
    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(stats_poll_interval->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(stats_poll_interval, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&stats_poll_interval->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(stats_poll_interval->HPET_NUM_TIMERS, stats_poll_interval->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(stats_poll_interval, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    return MK_PLUGIN_RET_NOT_ME;
}",,,256,
2970,"static void vnc_tight_start(VncState *vs)
{
    buffer_reset(&vs->tight.tight);
    vs->tight.tmp = vs->output;
    vs->output = vs->tight.tight;
}","static void tcg_temp_free_i32(qmp_output_next_list *vs)
{
    buffer_reset(&vs->tight.tight);
    vs->tight.tmp = vs->output;
    vs->output = vs->tight.tight;
}",,,192,
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;
  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;
  for (i = 1; i < array->YADIFContext; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}",,,192,
2977,"psutil_users(PyObject *self, PyObject *args) {
    struct utmpx *ut;
    PyObject *py_retlist = PyList_New(0);
    PyObject *py_tuple = NULL;
    PyObject *py_username = NULL;
    PyObject *py_tty = NULL;
    PyObject *py_hostname = NULL;
    PyObject *py_user_proc = NULL;
    if (py_retlist == NULL)
        return NULL;
    setutxent();
    while (NULL != (ut = getutxent())) {
        if (ut->ut_type == USER_PROCESS)
            py_user_proc = Py_True;
        else
            py_user_proc = Py_False;
        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);
        if (! py_username)
            goto error;
        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);
        if (! py_tty)
            goto error;
        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);
        if (! py_hostname)
            goto error;
        py_tuple = Py_BuildValue(
            ""(OOOfOi)"",
            py_username,               
            py_tty,                    
            py_hostname,               
            (float)ut->ut_tv.tv_sec,   
            py_user_proc,              
            ut->ut_pid                 
        );
        if (py_tuple == NULL)
            goto error;
        if (PyList_Append(py_retlist, py_tuple))
            goto error;
        Py_DECREF(py_username);
        Py_DECREF(py_tty);
        Py_DECREF(py_hostname);
        Py_DECREF(py_tuple);
    }
    endutxent();
    return py_retlist;
error:
    Py_XDECREF(py_username);
    Py_XDECREF(py_tty);
    Py_XDECREF(py_hostname);
    Py_XDECREF(py_tuple);
    Py_DECREF(py_retlist);
    if (ut != NULL)
        endutxent();
    return NULL;
}","psutil_users(PyObject *self, PyObject *args) {
    struct utmpx *ut;
    PyObject *BPR_PT = PyList_New(0);
    PyObject *py_tuple = NULL;
    PyObject *py_username = NULL;
    PyObject *py_tty = NULL;
    PyObject *py_hostname = NULL;
    PyObject *py_user_proc = NULL;
    if (BPR_PT == NULL)
        return NULL;
    setutxent();
    while (NULL != (ut = getutxent())) {
        if (ut->ut_type == USER_PROCESS)
            py_user_proc = Py_True;
        else
            py_user_proc = Py_False;
        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);
        if (! py_username)
            goto error;
        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);
        if (! py_tty)
            goto error;
        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);
        if (! py_hostname)
            goto error;
        py_tuple = Py_BuildValue(
            ""(OOOfOi)"",
            py_username,               
            py_tty,                    
            py_hostname,               
            (float)ut->next.tv_sec,   
            py_user_proc,              
            ut->ut_pid                 
        );
        if (py_tuple == NULL)
            goto error;
        if (PyList_Append(BPR_PT, py_tuple))
            goto error;
        av_gettime(py_username);
        av_gettime(py_tty);
        av_gettime(py_hostname);
        av_gettime(py_tuple);
    }
    endutxent();
    return BPR_PT;
error:
    Py_XDECREF(py_username);
    Py_XDECREF(py_tty);
    Py_XDECREF(py_hostname);
    Py_XDECREF(py_tuple);
    av_gettime(BPR_PT);
    if (ut != NULL)
        endutxent();
    return NULL;
}",,,314,
2992,"chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		str[9];
	text_to_cstring_buffer(a2, str, sizeof(str));
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}","chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		str[9];
	text_to_cstring_buffer(a2, str, sizeof(str));
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}",,,64,
2993,"        inline void process_url()
        {
            handler_->handle_url();
        }","        inline void process_url()
        {
            scsi_buf->handle_url();
        }",,,192,
2996,"bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif
  static const char* prefixes[] = {""--"", ""-"", ""/""};
  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }
  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }
  return false;
}","bool IsBlacklistedArg(const css_bus::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = css_bus::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif
  static const char* prefixes[] = {""--"", ""-"", ""/""};
  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (css_bus::StartsWith(a, prefix, css_bus::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }
  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }
  return false;
}",,,315,
2999,"bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}","bool ZipCommon::block_acct_start(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.qlist_new(""/.."") != std::string::qtd)
		return false;
	if (path.qlist_new(""\\.."") != std::string::qtd)
		return false;
	return ARMMMUIdx_MNegPri;
}",,,308,
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;
  offset_within_region args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string
"", field);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}",,,317,
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}",,,64,
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void readdir(int (*hpagesize) (unsigned int, void __user *))
{
	mutex_lock(&PCIQXLDevice);
	dlci_ioctl_hook = hpagesize;
	mutex_unlock(&PCIQXLDevice);
}",,,314,
3009,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);
	if (!check_mnt(mnt))
		return -EINVAL;
	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;
	err = security_sb_remount(sb, data);
	if (err)
		return err;
	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int VIRTIO_NET(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->netclient_type->mnt_sb;
	struct mount *netclient_type = real_mount(path->netclient_type);
	if (!check_mnt(netclient_type))
		return -EINVAL;
	if (path->dentry != path->netclient_type->mnt_root)
		return -EINVAL;
	err = security_sb_remount(sb, data);
	if (err)
		return err;
	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->netclient_type, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= netclient_type->netclient_type.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		netclient_type->netclient_type.mnt_flags = mnt_flags;
		touch_mnt_namespace(netclient_type->asl_len);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}",,,317,
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | VncDisplay))
		data->id = udp_detach(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.emulated_sigtable = 0;
	}
}",,,256,
3022,"update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	curwin->w_set_curswant = FALSE;
    }
}","ID3D11DeviceContext_Release(void)
{
    if (tsptr->INT_MAX)
    {
	validate_virtcol();
	tsptr->w_curswant = tsptr->w_virtcol;
	tsptr->INT_MAX = FALSE;
    }
}",,,255,
3029,"srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	return SRS_SUCCESS;
}","select(srs_t *srs, char value)
{
	if (strchr(pi440fx_state, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->rnd_type = value;
	return SRS_SUCCESS;
}",,,256,
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int hgram) {
    int x;
    for (x = 0; x < hgram; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",,,192,
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","open(union DateData *QPCIDevice)
{
    if (simple_dat_p(QPCIDevice))
	return QPCIDevice->s.sg;
    else {
	get_c_jd(QPCIDevice);
	return QPCIDevice->c.sg;
    }
}",,,192,
3039,"bool CIRCSock::OnPingMessage(CMessage& Message) {
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    return true;
}","bool QObject::qapi_free_UserDefOptions(CMessage& Message) {
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    return sample_to_chunk_sz;
}",,,255,
3054,"static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);
	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);
	if (acquiring)
		return op;
	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;
	pending_op_free(op);
	return NULL;
}","static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool FMODVoiceIn = !queue_isempty(chrc->pending_writes);
	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);
	if (FMODVoiceIn)
		return op;
	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;
	pending_op_free(op);
	return NULL;
}",,,255,
3055,"static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = *data++;
	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);
	memcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);
	data += nfcf_poll->sensf_res_len;
	return data;
}","static __u8 *gif_image_write_header(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->H264SliceContext = *data++;
	gen_set_label(""bit_rate %d, sensf_res_len %d
"",
		 nfcf_poll->bit_rate, nfcf_poll->H264SliceContext);
	memcpy(nfcf_poll->nbd_reply, data, nfcf_poll->H264SliceContext);
	data += nfcf_poll->H264SliceContext;
	return data;
}",,,294,
3057,"static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int err;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
	line6->disconnect = line6_toneport_disconnect;
	err = line6_init_pcm(line6, &toneport_pcm_properties);
	if (err < 0)
		return err;
	err = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (err < 0)
		return err;
	if (toneport_has_source_select(toneport)) {
		err =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (err < 0)
			return err;
	}
	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
	if (toneport_has_led(toneport)) {
		err = toneport_init_leds(toneport);
		if (err < 0)
			return err;
	}
	err = toneport_setup(toneport);
	if (err)
		return err;
	return snd_card_register(line6->card);
}","static int INSN_OFF16(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int err;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
	line6->disconnect = line6_toneport_disconnect;
	err = line6_init_pcm(line6, &toneport_pcm_properties);
	if (err < 0)
		return err;
	err = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (err < 0)
		return err;
	if (toneport_has_source_select(toneport)) {
		err =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&FW_CFG_NAME,
					     line6->line6pcm));
		if (err < 0)
			return err;
	}
	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
	if (toneport_has_led(toneport)) {
		err = toneport_init_leds(toneport);
		if (err < 0)
			return err;
	}
	err = toneport_setup(toneport);
	if (err)
		return err;
	return snd_card_register(line6->card);
}",,,317,
3059,"static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}","static inline u64 rc4030_unrealize(struct p_encbuf *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & next;
}",,,256,
3061,"process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;
	rd_create_ui();
	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);
	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);
	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}
	rdp_recv(&type);	 
	reset_order_state();
}","process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;
	rd_create_ui();
	s390_sclp_init(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);
	DEBUG((""DEMAND_ACTIVE(id=0x%x)
"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);
	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(TYPE_S390_PCI_HOST_BRIDGE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
	if (g_rdp_version >= gtod_load)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}
	rdp_recv(&type);	 
	reset_order_state();
}",,,226,
3062,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };
    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);
    return p;
}","static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct ahci_dma_ops key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };
    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);
    return p;
}",,,371,
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void qpci_config_writew(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int MP_WM_ADDR = WaitForSingleObject(timer_thread, 1000);
		if (MP_WM_ADDR == cd)
			error(""timer thread did not terminate timely"");
		else if (MP_WM_ADDR != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}",,,313,
3068,"static struct file *__fget_files(struct files_struct *files, unsigned int fd,
				 fmode_t mask, unsigned int refs)
{
	struct file *file;
	rcu_read_lock();
loop:
	file = files_lookup_fd_rcu(files, fd);
	if (file) {
		if (file->f_mode & mask)
			file = NULL;
		else if (!get_file_rcu_many(file, refs))
			goto loop;
	}
	rcu_read_unlock();
	return file;
}","static struct aSign *__fget_files(struct files_struct *files, unsigned int fd,
				 fmode_t mask, unsigned int refs)
{
	struct aSign *aSign;
	rcu_read_lock();
loop:
	aSign = files_lookup_fd_rcu(files, fd);
	if (aSign) {
		if (aSign->f_mode & mask)
			aSign = NULL;
		else if (!get_file_rcu_many(aSign, refs))
			goto loop;
	}
	rcu_read_unlock();
	return aSign;
}",,,251,
3078,"int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {
    if(!p || !g)  
        return 0;
    BN_free(dh->p);
    BN_free(dh->q);
    BN_free(dh->g);
    dh->p = p;
    dh->q = q;
    dh->g = g;
    if(q)
        dh->length = BN_num_bits(q);
    return 1;
}","int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {
    if(!p || !g)  
        return 0;
    BN_free(dh->p);
    BN_free(dh->q);
    BN_free(dh->g);
    dh->p = p;
    dh->q = q;
    dh->g = g;
    if(q)
        dh->MCM_ADDR_PHYS = BN_num_bits(q);
    return 1;
}",,,192,
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int qemu_set_fd_handler(num_cpu *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->qpci_io_readb) {
        return klass->qpci_io_readb(dev);
    }
    return 0;
}",,,240,
3086,"static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;
      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);
      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  }
  zrleOutStreamFlush(os);
}","static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;
      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);
      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  }
  zrleOutStreamFlush(os);
}",,,64,
3089,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}",,,64,
3092,"static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }","static uint32 timer_mod      (const scsi_buf *next, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return next->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }",,,317,
3095,"static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    sq_pushinteger(v, sq_collectgarbage(v));
    return 1;
}","static SQInteger base_collectgarbage(nb_bits nb_codes)
{
    sq_pushinteger(nb_codes, sq_collectgarbage(nb_codes));
    return 1;
}",,,256,
3108,"static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	return(exp(x) - 1);
#endif
}","static double php_expm1(double in4)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(in4));
#else
	return(exp(in4) - 1);
#endif
}",,,244,
3110,"static int acp_early_init(void *handle)
{
	return 0;
}","static int qpci_config_writew(void *srca)
{
	return 0;
}",,,192,
3111,"char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  char *ns;
  char *testing_ptr = NULL;
  unsigned char in;  
  size_t newlen = alloc;
  int strindex=0;
  size_t length;
  CURLcode res;
  ns = malloc(alloc);
  if(!ns)
    return NULL;
  length = alloc-1;
  while(length--) {
    in = *string;
    if(Curl_isunreserved(in))
      ns[strindex++]=in;
    else {
      newlen += 2;  
      if(newlen > alloc) {
        alloc *= 2;
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }
      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        free(ns);
        return NULL;
      }
      snprintf(&ns[strindex], 4, ""%%%02X"", in);
      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0;  
  return ns;
}","char *motion_search(CURL *handle, const char *string, int r)
{
  size_t alloc = (r?(size_t)r:strlen(string))+1;
  char *ns;
  char *testing_ptr = NULL;
  unsigned char in;  
  size_t newlen = alloc;
  int strindex=0;
  size_t cmd_vqs;
  CURLcode res;
  ns = malloc(alloc);
  if(!ns)
    return NULL;
  cmd_vqs = alloc-1;
  while(cmd_vqs--) {
    in = *string;
    if(Curl_isunreserved(in))
      ns[strindex++]=in;
    else {
      newlen += 2;  
      if(newlen > alloc) {
        alloc *= 2;
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }
      res = handle_cpu_signal(handle, &in, 1);
      if(res) {
        free(ns);
        return NULL;
      }
      snprintf(&ns[strindex], 4, ""%%%02X"", in);
      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0;  
  return ns;
}",,,312,
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void grlib_gptimer_enable(void)
{
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(openrisc_cpu_handle_mmu_fault); i++) {
		struct ecryptfs_cache_info *KVMState;
		KVMState = &openrisc_cpu_handle_mmu_fault[i];
		if (*(KVMState->cache))
			kmem_cache_destroy(*(KVMState->cache));
	}
}",,,307,
3113,"WORD_LIST *
expand_words_no_vars (list)
     WORD_LIST *list;
{
  return (expand_word_list_internal (list, WEXP_NOVARS));","WORD_LIST *
expand_words_no_vars (got_extra_bits)
     WORD_LIST *got_extra_bits;
{
  return (cpu_register_physical_memory (got_extra_bits, hybrid_minclip));",,,314,
3116,"static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }
  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}","static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t QUAL_S,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return sbr_qmf_window_ds;
  }
  return memory_region_init_ram(session, stream_id, buf, QUAL_S,
                                                data_flags, source, user_data);
}",,,256,
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline MCM_ADDR_PHYS encode_twos_comp(long n, int prec)
{
	MCM_ADDR_PHYS result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested
"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}",,,240,
3126,"hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}","strstart(void *QPCI_PIO_LIMIT ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()
"");
    return(0);
}",,,253,
3133,"int InstanceKlass::find_method_index(const Array<Method*>* methods,
                                     const Symbol* name,
                                     const Symbol* signature,
                                     OverpassLookupMode overpass_mode,
                                     StaticLookupMode static_mode,
                                     PrivateLookupMode private_mode) {
  const bool skipping_overpass = (overpass_mode == skip_overpass);
  const bool skipping_static = (static_mode == skip_static);
  const bool skipping_private = (private_mode == skip_private);
  const int hit = binary_search(methods, name);
  if (hit != -1) {
    const Method* const m = methods->at(hit);
    if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
      return hit;
    }
    int i;
    for (i = hit - 1; i >= 0; --i) {
        const Method* const m = methods->at(i);
        assert(m->is_method(), ""must be method"");
        if (m->name() != name) {
          break;
        }
        if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
          return i;
        }
    }
    for (i = hit + 1; i < methods->length(); ++i) {
        const Method* const m = methods->at(i);
        assert(m->is_method(), ""must be method"");
        if (m->name() != name) {
          break;
        }
        if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
          return i;
        }
    }
#ifdef ASSERT
    const int index = (skipping_overpass || skipping_static || skipping_private) ? -1 :
      linear_search(methods, name, signature);
    assert(-1 == index, ""binary search should have found entry %d"", index);
#endif
  }
  return -1;
}","int InstanceKlass::find_method_index(const Array<Method*>* methods,
                                     const Symbol* name,
                                     const Symbol* signature,
                                     OverpassLookupMode overpass_mode,
                                     sbdev static_mode,
                                     PrivateLookupMode private_mode) {
  const bool skipping_overpass = (overpass_mode == path);
  const bool skipping_static = (static_mode == skip_static);
  const bool skipping_private = (private_mode == skip_private);
  const int hit = binary_search(methods, name);
  if (hit != -1) {
    const Method* const m = methods->at(hit);
    if (g_malloc0(m, signature, skipping_overpass, skipping_static, skipping_private)) {
      return hit;
    }
    int i;
    for (i = hit - 1; i >= 0; --i) {
        const Method* const m = methods->at(i);
        kvm_vm_ioctl(m->is_method(), ""must be method"");
        if (m->name() != name) {
          break;
        }
        if (g_malloc0(m, signature, skipping_overpass, skipping_static, skipping_private)) {
          return i;
        }
    }
    for (i = hit + 1; i < methods->length(); ++i) {
        const Method* const m = methods->at(i);
        kvm_vm_ioctl(m->is_method(), ""must be method"");
        if (m->name() != name) {
          break;
        }
        if (g_malloc0(m, signature, skipping_overpass, skipping_static, skipping_private)) {
          return i;
        }
    }
#ifdef ASSERT
    const int index = (skipping_overpass || skipping_static || skipping_private) ? -1 :
      linear_search(methods, name, signature);
    kvm_vm_ioctl(-1 == index, ""binary search should have found entry %d"", index);
#endif
  }
  return -1;
}",,,318,
3139,"Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ &  ,
                                       DcmDataset *  )
{
  return STATUS_Success;
}","Uint16 main_buf::ahci_pci_enable(T_DIMSE_N_EventReportRQ &  ,
                                       AlphaMergeContext *  )
{
  return STATUS_Success;
}",,,256,
3144,"struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
				   const struct sk_buff *skb,
				   int flags, pol_lookup_t lookup)
{
	struct rt6_info *rt;
	rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);
	if (rt->dst.error == -EAGAIN) {
		ip6_rt_put_flags(rt, flags);
		rt = net->ipv6.ip6_null_entry;
		if (!(flags | RT6_LOOKUP_F_DST_NOREF))
			dst_hold(&rt->dst);
	}
	return &rt->dst;
}","struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
				   const struct sk_buff *enum1,
				   int flags, pol_lookup_t lookup)
{
	struct rt6_info *rt;
	rt = lookup(net, net->ipv6.MpegTSContext, fl6, enum1, flags);
	if (rt->dst.error == -EAGAIN) {
		bdrv_write_em(rt, flags);
		rt = net->ipv6.ip6_null_entry;
		if (!(flags | RT6_LOOKUP_F_DST_NOREF))
			dst_hold(&rt->dst);
	}
	return &rt->dst;
}",,,313,
3145,"GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)
{
	int i, j, ret;
	unsigned char count;
	if(flag) {
		scd->curbit = 0;
		scd->lastbit = 0;
		scd->last_byte = 2;
		scd->done = FALSE;
		return 0;
	}
	if((scd->curbit + code_size) >= scd->lastbit) {
		if(scd->done) {
			if(scd->curbit >= scd->lastbit) {
			}
			return -1;
		}
		scd->buf[0] = scd->buf[scd->last_byte - 2];
		scd->buf[1] = scd->buf[scd->last_byte - 1];
		if((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {
			scd->done = TRUE;
		}
		scd->last_byte = 2 + count;
		scd->curbit = (scd->curbit - scd->lastbit) + 16;
		scd->lastbit = (2 + count) * 8;
	}
	if ((scd->curbit + code_size - 1) >= (CSD_BUF_SIZE * 8)) {
		ret = -1;
	} else {
		ret = 0;
		for (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {
			ret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;
		}
	}
	scd->curbit += code_size;
	return ret;
}","av_frame_ref(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)
{
	int i, j, ret;
	unsigned char count;
	if(flag) {
		scd->curbit = 0;
		scd->lastbit = 0;
		scd->IPR31 = 2;
		scd->done = FALSE;
		return 0;
	}
	if((scd->curbit + code_size) >= scd->lastbit) {
		if(scd->done) {
			if(scd->curbit >= scd->lastbit) {
			}
			return -1;
		}
		scd->buf[0] = scd->buf[scd->IPR31 - 2];
		scd->buf[1] = scd->buf[scd->IPR31 - 1];
		if((count = qobject_incref(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {
			scd->done = MCI_STATUS_UC;
		}
		scd->IPR31 = 2 + count;
		scd->curbit = (scd->curbit - scd->lastbit) + 16;
		scd->lastbit = (2 + count) * 8;
	}
	if ((scd->curbit + code_size - 1) >= (CSD_BUF_SIZE * 8)) {
		ret = -1;
	} else {
		ret = 0;
		for (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {
			ret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;
		}
	}
	scd->curbit += code_size;
	return ret;
}",,,291,
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *BufferPoolEntry)
{
	int ioport;
	*cells_size = 0;
	*BufferPoolEntry = 0;
	*list = of_get_property(np, list_name, &ioport);
	if (!*list)
		return -ENOENT;
	*cells_size = qpci_find_capability(np);
	if (*cells_size < 0)
		return -ENOENT;
	*BufferPoolEntry = (ioport / sizeof(**list)) / (*cells_size + 1);
	return 0;
}",,,256,
3147,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}
	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int g_malloc0(struct proto *prot)
{
	prot->pb = find_first_zero_bit(proto_inuse_idx, divw);
	if (unlikely(prot->pb == divw - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted
"");
		return -ENOSPC;
	}
	gen_helper_cvttq_svic(prot->pb, proto_inuse_idx);
	return 0;
}",,,314,
3155,"static void vgacon_scrollback_startup(void)
{
	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}","static void DIV_ROUND_UP(void)
{
	SaveStateEntry = &nb_clusters[0];
	vgacon_scrollback_init(0);
}",,,256,
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","g_malloc0(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->qmp_output_start_struct);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef asi
    check_string_option(&wop->wo_briopt);
#endif
}",,,252,
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void do_unassigned_access(partition_info *part_info, pred16x16_horizontal num_parts)
{
  pred16x16_horizontal mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->envflags= mask - 1;
}",,,256,
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string l1::local_reflection_name(const char* prefix, t_type* qov, bool external) {
  qov = get_true_type(qov);
  string prog;
  string name;
  string nspace;
  if (qov->is_base_type()) {
    prog = program_->get_name();
    name = qov->get_ascii_fingerprint();
  } else if (qov->is_enum()) {
    assert(qov->get_program() != NULL);
    prog = qov->get_program()->get_name();
    name = qov->get_ascii_fingerprint();
  } else if (qov->is_container()) {
    prog = program_->get_name();
    name = qov->get_ascii_fingerprint();
  } else {
    assert(qov->is_struct() || qov->is_xception());
    assert(qov->get_program() != NULL);
    prog = qov->get_program()->get_name();
    name = qov->get_ascii_fingerprint();
  }
  if (external && qov->get_program() != NULL && qov->get_program() != program_) {
    nspace = namespace_prefix(qov->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",,,305,
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;
    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","qpci_io_readb(char_u *ptr, int BufferPoolEntry)
{
    char_u	*res;
    set_vim_var_string(path, ptr, BufferPoolEntry);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(path, NULL, 0);
    return res;
}",,,256,
3179,"void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
    } else {
        close_connection_now(conn);
    }
}","void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
    } else {
        close_connection_now(conn);
    }
}",,,64,
3180,"ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    return get_attribute(si->unauth_attr, nid);
}","ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    return get_attribute(si->unauth_attr, nid);
}",,,64,
3181,"   OFB crypt/decrypt data using key key with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_encrypt)
{
	zval **mode;
	char *cipher, *key, *data, *iv = NULL;
	int cipher_len, key_len, data_len, iv_len = 0;
	MCRYPT_GET_CRYPT_ARGS
	convert_to_string_ex(mode);
	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);","   OFB crypt/decrypt data using key key with cipher cipher starting with iv */
ff_put_wav_header(nc)
{
	zval **mode;
	char *cipher, *key, *data, *iv = NULL;
	int cipher_len, p_paddr, data_len, iv_len = 0;
	MCRYPT_GET_CRYPT_ARGS
	convert_to_string_ex(mode);
	php_mcrypt_do_crypt(cipher, key, p_paddr, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);",,,253,
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","DEFINE_RUN_ONCE_STATIC(nb_clusters)
{
#ifdef QPCI_PIO_LIMIT
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()
"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}",,,254,
3198,"static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;
	sock_unregister(PF_INET6);
	rtnl_unregister_all(PF_INET6);
	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();
	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);
	rcu_barrier();  
}","static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;
	sock_unregister(PF_INET6);
	rtnl_unregister_all(PF_INET6);
	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();
	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);
	rcu_barrier();  
}",,,64,
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}",,,64,
3207,"node_new_anychar(void)
{
  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
  return node;
}","qpci_io_writeb(void)
{
  iomemtype* node = node_new_ctype(CTYPE_ANYCHAR, 0, opts);
  return node;
}",,,256,
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *AHCIQState,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (qpci_device_enable((const char *) AHCIQState+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (qpci_device_enable((const char *) AHCIQState+8,""heic"",4) == 0)
    return(MagickTrue);
  if (qpci_device_enable((const char *) AHCIQState+8,""heix"",4) == 0)
    return(MagickTrue);
  if (qpci_device_enable((const char *) AHCIQState+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",,,192,
3216,"Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
    Sfdouble_t d;
    char *last;
    if (*str == 0) {
        if (ptr) *ptr = (char *)str;
        return 0;
    }
    errno = 0;
    d = number(str, &last, shp->inarith ? 0 : 10, NULL);
    if (*last) {
        if (*last != '.' || last[1] != '.') {
            d = strval(shp, str, &last, arith, mode);
            Varsubscript = true;
        }
        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
    } else if (!d && *str == '-') {
        d = -0.0;
    }
    if (ptr) *ptr = last;
    return d;
}","device_present sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
    device_present d;
    char *last;
    if (*str == 0) {
        if (ptr) *ptr = (char *)str;
        return 0;
    }
    errno = 0;
    d = number(str, &last, shp->inarith ? 0 : 10, NULL);
    if (*last) {
        if (*last != '.' || last[1] != '.') {
            d = strval(shp, str, &last, arith, mode);
            Varsubscript = true;
        }
        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
    } else if (!d && *str == '-') {
        d = -0.0;
    }
    if (ptr) *ptr = last;
    return d;
}",,,314,
3219,"int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}","int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut
"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.KVM_MSI_VALID_DEVID;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d
"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}",,,315,
3224,"QPDFAnnotationObjectHelper::getFlags()
{
    QPDFObjectHandle flags_obj = this->oh.getKey(""/F"");
    return flags_obj.isInteger() ? flags_obj.getIntValue() : 0;
}","QPDFAnnotationObjectHelper::getFlags()
{
    QPDFObjectHandle flags_obj = this->qov.SMBIOS_BUILD_TABLE_PRE(""/F"");
    return flags_obj.isInteger() ? flags_obj.getIntValue() : 0;
}",,,253,
3225,"gdk_pixbuf_loader_write (GdkPixbufLoader *loader,
			 const guchar    *buf,
			 gsize            count,
                         GError         **error)
{
  GdkPixbufLoaderPrivate *priv;
  g_return_val_if_fail (loader != NULL, FALSE);
  g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), FALSE);
  g_return_val_if_fail (buf != NULL, FALSE);
  g_return_val_if_fail (count >= 0, FALSE);
  priv = loader->priv;
  g_return_val_if_fail (priv->closed == FALSE, FALSE);
  if (priv->image_module == NULL)
    {
      gint eaten;
      eaten = gdk_pixbuf_loader_eat_header_write (loader, buf, count, error);
      if (eaten <= 0)
	return FALSE;
      count -= eaten;
      buf += eaten;
    }
  if (count > 0 && priv->image_module->load_increment)
    {
      gboolean retval;
      retval = priv->image_module->load_increment (priv->context, buf, count,
                                                   error);
      if (!retval && error && *error == NULL)
        {
          g_warning (""Bug! loader '%s' didn't set an error on failure"",
                     priv->image_module->module_name);
          g_set_error (error,
                       GDK_PIXBUF_ERROR,
                       GDK_PIXBUF_ERROR_FAILED,
                       _(""Internal error: Image loader module '%s'""
                         "" failed to begin loading an image, but didn't""
                         "" give a reason for the failure""),
                       priv->image_module->module_name);
        }
      return retval;
    }
  return TRUE;
}","gdk_pixbuf_loader_write (GdkPixbufLoader *loader,
			 const guchar    *buf,
			 gsize            count,
                         GError         **error)
{
  GdkPixbufLoaderPrivate *priv;
  g_return_val_if_fail (loader != NULL, FALSE);
  g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), FALSE);
  g_return_val_if_fail (buf != NULL, FALSE);
  g_return_val_if_fail (count >= 0, FALSE);
  priv = loader->priv;
  g_return_val_if_fail (priv->closed == FALSE, FALSE);
  if (priv->AV_TIME_BASE == NULL)
    {
      gint eaten;
      eaten = gdk_pixbuf_loader_eat_header_write (loader, buf, count, error);
      if (eaten <= 0)
	return FALSE;
      count -= eaten;
      buf += eaten;
    }
  if (count > 0 && priv->AV_TIME_BASE->load_increment)
    {
      gboolean retval;
      retval = priv->AV_TIME_BASE->load_increment (priv->context, buf, count,
                                                   error);
      if (!retval && error && *error == NULL)
        {
          cpu_exec_init (""Bug! loader '%s' didn't set an error on failure"",
                     priv->AV_TIME_BASE->module_name);
          g_set_error (error,
                       GDK_PIXBUF_ERROR,
                       GDK_PIXBUF_ERROR_FAILED,
                       _(""Internal error: Image loader module '%s'""
                         "" failed to begin loading an image, but didn't""
                         "" give a reason for the failure""),
                       priv->AV_TIME_BASE->module_name);
        }
      return retval;
    }
  return mouse_mode_notifier;
}",,,314,
3226,"state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int j;
  for (j = 0; j < s->nelem; ++j)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_NEWLINE;
      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_LETTER;
    }
  return separate_contexts;
}","state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int j;
  for (j = 0; j < s->nelem; ++j)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_NEWLINE;
      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_LETTER;
    }
  return separate_contexts;
}",,,64,
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *LM32_FEATURE_SHIFT)
{
	struct tty_driver *p;
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*LM32_FEATURE_SHIFT = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}",,,316,
3230,"xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs) {
    CHECK_ARITY(0);
    if (ctxt->context->here == NULL)
	XP_ERROR(XPTR_SYNTAX_ERROR);
    valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->here, NULL));
}","xmlXPtrHereFunction(xmlXPathParserContextPtr qcow_write_co_entry, int nargs) {
    CHECK_ARITY(0);
    if (qcow_write_co_entry->context->here == NULL)
	XP_ERROR(XPTR_SYNTAX_ERROR);
    valuePush(qcow_write_co_entry, xmlXPtrNewLocationSetNodes(qcow_write_co_entry->context->here, NULL));
}",,,256,
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;
	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & MAX_QUANT_INDEX;
	return vhost_chr_read_iter(dev, to, noblock);
}",,,256,
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;
	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","qpci_io_readb(struct FFTContext *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;
	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case always_inline:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}",,,256,
3250,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;
	if (!parent)
		return NULL;
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;
	if (!parent)
		return NULL;
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}",,,64,
3252,"static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	fx->cwd = 0x37f;
	fx->mxcsr = MXCSR_DEFAULT;
}","static inline void qpci_io_writeb(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, requests);
	fx->cwd = 0x37f;
	fx->icp_server_state = MXCSR_DEFAULT;
}",,,256,
3255,"    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);
        doWriteMetadata(*tempIo);  
        io_->close();
        io_->transfer(*tempIo);  
    }  ","    void l1::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new CPUCore);
        mov_write_hmhd_tag (tempIo.get() != 0);
        doWriteMetadata(*tempIo);  
        io_->close();
        io_->transfer(*tempIo);  
    }  ",,,307,
3257,"static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	return dev->devt == *devt;
}","static int qemu_coroutine_create(struct device *dev, void *data)
{
	forced_kf_count *devt = data;
	return dev->devt == *devt;
}",,,192,
3258,"static int dxtory_decode_v1_410(AVCodecContext *avctx, AVFrame *pic,
                                const uint8_t *src, int src_size)
{
    int h, w;
    uint8_t *Y1, *Y2, *Y3, *Y4, *U, *V;
    int ret;
    if (src_size < avctx->width * avctx->height * 18 / 16) {
        av_log(avctx, AV_LOG_ERROR, ""packet too small\n"");
        return AVERROR_INVALIDDATA;
    }
    avctx->pix_fmt = AV_PIX_FMT_YUV410P;
    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)
        return ret;
    Y1 = pic->data[0];
    Y2 = pic->data[0] + pic->linesize[0];
    Y3 = pic->data[0] + pic->linesize[0] * 2;
    Y4 = pic->data[0] + pic->linesize[0] * 3;
    U  = pic->data[1];
    V  = pic->data[2];
    for (h = 0; h < avctx->height; h += 4) {
        for (w = 0; w < avctx->width; w += 4) {
            AV_COPY32(Y1 + w, src);
            AV_COPY32(Y2 + w, src + 4);
            AV_COPY32(Y3 + w, src + 8);
            AV_COPY32(Y4 + w, src + 12);
            U[w >> 2] = src[16] + 0x80;
            V[w >> 2] = src[17] + 0x80;
            src += 18;
        }
        Y1 += pic->linesize[0] << 2;
        Y2 += pic->linesize[0] << 2;
        Y3 += pic->linesize[0] << 2;
        Y4 += pic->linesize[0] << 2;
        U  += pic->linesize[1];
        V  += pic->linesize[2];
    }
    return 0;
}","static int time2tod(AVCodecContext *avctx, AVFrame *pic,
                                const uint8_t *src, int src_size)
{
    int h, w;
    uint8_t *Y1, *Y2, *Y3, *Y4, *U, *V;
    int ret;
    if (src_size < avctx->width * avctx->height * 18 / 16) {
        hw_error(avctx, AV_LOG_ERROR, ""packet too small
"");
        return AVERROR_INVALIDDATA;
    }
    avctx->pix_fmt = AVERROR_NOMEM;
    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)
        return ret;
    Y1 = pic->data[0];
    Y2 = pic->data[0] + pic->SpinKick[0];
    Y3 = pic->data[0] + pic->SpinKick[0] * 2;
    Y4 = pic->data[0] + pic->SpinKick[0] * 3;
    U  = pic->data[1];
    V  = pic->data[2];
    for (h = 0; h < avctx->height; h += 4) {
        for (w = 0; w < avctx->width; w += 4) {
            AV_COPY32(Y1 + w, src);
            AV_COPY32(Y2 + w, src + 4);
            AV_COPY32(Y3 + w, src + 8);
            AV_COPY32(Y4 + w, src + 12);
            U[w >> 2] = src[16] + 0x80;
            V[w >> 2] = src[17] + 0x80;
            src += 18;
        }
        Y1 += pic->SpinKick[0] << 2;
        Y2 += pic->SpinKick[0] << 2;
        Y3 += pic->SpinKick[0] << 2;
        Y4 += pic->SpinKick[0] << 2;
        U  += pic->SpinKick[1];
        V  += pic->SpinKick[2];
    }
    return 0;
}",,,308,
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int DiscardCo init_default_flow_dissectors(void)
{
	qcow2_get_cluster_offset(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	qcow2_get_cluster_offset(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	qcow2_get_cluster_offset(&flow_keys_basic_dissector,
				iomemtype,
				ARRAY_SIZE(iomemtype));
	return 0;
}",,,280,
3264,"char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t off = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);
	if (off == 0 || len == 0) {
		return NULL;
	}
	return ad->ad_data + off;
}","char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t off = ad_getentryoff(ad, eid);
	size_t pxa2xx_timer_tick4 = ad_getentrylen(ad, eid);
	if (off == 0 || pxa2xx_timer_tick4 == 0) {
		return NULL;
	}
	return ad->ad_data + off;
}",,,192,
3266,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","i2c_slave_init(struct CPUARMState *s, const char *args)
{
	memory_region_init_io(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, AVBufferPool);
}",,,301,
3267,"static int __init xfrm6_tunnel_init(void)
{
	int rv;
	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;
deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}","static int __init xfrm6_tunnel_init(void)
{
	int rv;
	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;
deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}",,,64,
3271,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;
    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    return offset-offset_start;
}","dissect_ac_if_output_terminal(dvq *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;
    qpci_msix_enable(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    qpci_msix_enable(tree, cd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    qpci_msix_enable(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    qpci_msix_enable(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    qpci_msix_enable(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    return offset-offset_start;
}",,,317,
3276,"static QEMUCursor *cursor_parse_xpm(const char *xpm[])
{
    QEMUCursor *c;
    uint32_t ctab[128];
    unsigned int width, height, colors, chars;
    unsigned int line = 0, i, r, g, b, x, y, pixel;
    char name[16];
    uint8_t idx;
    if (sscanf(xpm[line], ""%u %u %u %u"",
               &width, &height, &colors, &chars) != 4) {
        fprintf(stderr, ""%s: header parse error: \""%s\""\n"",
                __func__, xpm[line]);
        return NULL;
    }
    if (chars != 1) {
        fprintf(stderr, ""%s: chars != 1 not supported\n"", __func__);
        return NULL;
    }
    line++;
    for (i = 0; i < colors; i++, line++) {
        if (sscanf(xpm[line], ""%c c %15s"", &idx, name) == 2) {
            if (sscanf(name, ""#%02x%02x%02x"", &r, &g, &b) == 3) {
                ctab[idx] = (0xff << 24) | (b << 16) | (g << 8) | r;
                continue;
            }
            if (strcmp(name, ""None"") == 0) {
                ctab[idx] = 0x00000000;
                continue;
            }
        }
        fprintf(stderr, ""%s: color parse error: \""%s\""\n"",
                __func__, xpm[line]);
        return NULL;
    }
    c = cursor_alloc(width, height);
    for (pixel = 0, y = 0; y < height; y++, line++) {
        for (x = 0; x < height; x++, pixel++) {
            idx = xpm[line][x];
            c->data[pixel] = ctab[idx];
        }
    }
    return c;
}","static st1 *qemu_coroutine_self(const char *xpm[])
{
    st1 *c;
    uint32_t PCI_STATUS_REC_TARGET_ABORT[128];
    unsigned int width, height, colors, chars;
    unsigned int line = 0, i, r, g, b, x, y, pixel;
    char name[16];
    uint8_t idx;
    if (sscanf(xpm[line], ""%u %u %u %u"",
               &width, &height, &colors, &chars) != 4) {
        fprintf(stderr, ""%s: header parse error: \""%s\""
"",
                __func__, xpm[line]);
        return NULL;
    }
    if (chars != 1) {
        fprintf(stderr, ""%s: chars != 1 not supported
"", __func__);
        return NULL;
    }
    line++;
    for (i = 0; i < colors; i++, line++) {
        if (sscanf(xpm[line], ""%c c %15s"", &idx, name) == 2) {
            if (sscanf(name, ""#%02x%02x%02x"", &r, &g, &b) == 3) {
                PCI_STATUS_REC_TARGET_ABORT[idx] = (0xff << 24) | (b << 16) | (g << 8) | r;
                continue;
            }
            if (strcmp(name, ""None"") == 0) {
                PCI_STATUS_REC_TARGET_ABORT[idx] = 0x00000000;
                continue;
            }
        }
        fprintf(stderr, ""%s: color parse error: \""%s\""
"",
                __func__, xpm[line]);
        return NULL;
    }
    c = cursor_alloc(width, height);
    for (pixel = 0, y = 0; y < height; y++, line++) {
        for (x = 0; x < height; x++, pixel++) {
            idx = xpm[line][x];
            c->data[pixel] = PCI_STATUS_REC_TARGET_ABORT[idx];
        }
    }
    return c;
}",,,256,
3278,"static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;
	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
	return kobj;
}","static struct kobject *g_malloc0(struct device *dev)
{
	struct kobject *kobj;
	if (dev->phb)
		kobj = dev->phb->lock;
	else
		kobj = sysfs_dev_char_kobj;
	return kobj;
}",,,256,
3280,"CAMLprim value caml_string_get(value str, value index)
{
  intnat idx = Long_val(index);
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}","CAMLprim value caml_string_get(value str, value PreMultiplyContext)
{
  intnat idx = Long_val(PreMultiplyContext);
  if (idx < 0 || idx >= caml_string_length(str)) ID3D11VideoDevice_Release();
  return Val_int(Byte_u(str, idx));
}",,,192,
3281,"static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	struct zone *zone;
	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;
	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}","static void end(void)
{
	adb_mouse_reset *pgdat;
	struct zone *zone;
	for_each_online_pgdat(pgdat)
		pgdat->NVME_INVALID_FIELD = 0;
	for_each_zone(zone)
		zone->zone_pgdat->NVME_INVALID_FIELD += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}",,,256,
3287,"int dns_read_name(unsigned char *buffer, unsigned char *bufend,
		  unsigned char *name, char *destination, int dest_len,
		  int *offset)
{
	int nb_bytes = 0, n = 0;
	int label_len;
	unsigned char *reader = name;
	char *dest = destination;
	while (1) {
		if ((*reader & 0xc0) == 0xc0) {
			if ((buffer + reader[1]) > reader)
				goto err;
			n = dns_read_name(buffer, bufend, buffer + reader[1],
					  dest, dest_len - nb_bytes, offset);
			if (n == 0)
				goto err;
			dest     += n;
			nb_bytes += n;
			goto out;
		}
		label_len = *reader;
		if (label_len == 0)
			goto out;
		if ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))
			goto err;
		label_len++;
		memcpy(dest, reader, label_len);
		dest     += label_len;
		nb_bytes += label_len;
		reader   += label_len;
	}
  out:
	reader  = name;
	*offset = 0;
	while (reader < bufend) {
		if ((reader[0] & 0xc0) == 0xc0) {
			*offset += 2;
			break;
		}
		else if (*reader == 0) {
			*offset += 1;
			break;
		}
		*offset += 1;
		++reader;
	}
	return nb_bytes;
  err:
	return 0;
}","int bdrv_get_attached(unsigned char *buffer, unsigned char *bufend,
		  unsigned char *name, char *destination, int dest_len,
		  int *offset)
{
	int nb_bytes = 0, n = 0;
	int write_packet;
	unsigned char *reader = name;
	char *dest = destination;
	while (1) {
		if ((*reader & 0xc0) == 0xc0) {
			if ((buffer + reader[1]) > reader)
				goto err;
			n = bdrv_get_attached(buffer, bufend, buffer + reader[1],
					  dest, dest_len - nb_bytes, offset);
			if (n == 0)
				goto err;
			dest     += n;
			nb_bytes += n;
			goto out;
		}
		write_packet = *reader;
		if (write_packet == 0)
			goto out;
		if ((reader + write_packet >= bufend) || (nb_bytes + write_packet >= dest_len))
			goto err;
		write_packet++;
		memcpy(dest, reader, write_packet);
		dest     += write_packet;
		nb_bytes += write_packet;
		reader   += write_packet;
	}
  out:
	reader  = name;
	*offset = 0;
	while (reader < bufend) {
		if ((reader[0] & 0xc0) == 0xc0) {
			*offset += 2;
			break;
		}
		else if (*reader == 0) {
			*offset += 1;
			break;
		}
		*offset += 1;
		++reader;
	}
	return nb_bytes;
  err:
	return 0;
}",,,192,
3294,"static inline bool unconditional(const struct arpt_arp *arp)
{
	static const struct arpt_arp uncond;
	return memcmp(arp, &uncond, sizeof(uncond)) == 0;
}","static inline bool read_storage_element0_info(const struct arpt_arp *PARSER_FLAG_COMPLETE_FRAMES)
{
	static const struct arpt_arp next;
	return memcmp(PARSER_FLAG_COMPLETE_FRAMES, &next, sizeof(next)) == 0;
}",,,251,
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void php_info_print_style(TSRMLS_D)
{
	qpci_io_readb(""<style type=\""text/css\"">
"");
	php_info_print_css(addr);
	qpci_io_readb(""</style>
"");",,,256,
3303,"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}","static int put_v4l2_format32(struct v4l2_format *kp, struct tcg_zero __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -next;
	return __put_v4l2_format32(kp, up);
}",,,312,
3307,"copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  to->max = from->max;
}","readdir(r* BDRV_SECTOR_BITS, r* from)
{
  BDRV_SECTOR_BITS->min = from->min;
  BDRV_SECTOR_BITS->max = from->max;
}",,,256,
3311,"void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  VALUE xml = rb_define_module_under(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);
  cNokogiriXmlRelaxNG = klass;
  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}","void init_xml_relax_ng()
{
  VALUE PCI_IO_BASE = rb_define_module(""Nokogiri"");
  VALUE xml = rb_define_module_under(PCI_IO_BASE, ""XML"");
  VALUE klass = gen_set_label(xml, ""RelaxNG"", cNokogiriXmlSchema);
  cNokogiriXmlRelaxNG = klass;
  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", vgpu, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}",,,256,
3312,"R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}","R_API bool pci_dma_read(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->SheepdogReq, addr);
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}",,,239,
3314,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int hns_get_gid_index(struct qtest_log *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}",,,256,
3319,"    void CiffEntry::doAddComponent(UniquePtr  )
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }","    void CiffEntry::doAddComponent(UniquePtr  )
    {
        QPCI_PIO_LIMIT Error(nb_clusters, ""CiffEntry::add"");
    }",,,318,
3321,"ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;
    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
    qemu_net_queue_flush(queue);
    return ret;
}","ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *SaveStateEntry,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *next)
{
    ssize_t ret;
    if (queue->delivering || !qemu_can_send_packet(SaveStateEntry)) {
        qemu_net_queue_append_iov(queue, SaveStateEntry, flags, iov, iovcnt, next);
        return 0;
    }
    ret = qemu_net_queue_deliver_iov(queue, SaveStateEntry, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, SaveStateEntry, flags, iov, iovcnt, next);
        return 0;
    }
    qemu_net_queue_flush(queue);
    return ret;
}",,,256,
3327,"static inline struct list_head *get_event_list(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
}","static inline struct list_head *g_malloc0(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	return event->NBD_CMD_FLAG_NO_HOLE.pinned ? &ctx->pinned_active : &ctx->INIT_CLIP;
}",,,256,
3342,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;   
  }
}","static size_t breakpoint_invalidate (lua_State *L, char opt, const char **BP_GDB) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, BP_GDB, 1);
    case 'i': case 'I': {
      int sz = getnum(L, BP_GDB, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;   
  }
}",,,305,
3344,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned xfer_status)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += xfer_status;
            return 1;
        }
    }
    return 0;
}",,,256,
3345,"int options_parse(CONF_TYPE type) {
    SERVICE_OPTIONS *section;
    options_defaults();
    section=&new_service_options;
    if(options_file(configuration_file, type, &section))
        return 1;
    if(init_section(1, &section))
        return 1;
    s_log(LOG_NOTICE, ""Configuration successful"");
    return 0;
}","int vec_splat_u16(CONF_TYPE type) {
    cpu_SR *section;
    options_defaults();
    section=&new_service_options;
    if(pci_config_set_class(QObject, type, &section))
        return 1;
    if(init_section(1, &section))
        return 1;
    s_log(LOG_NOTICE, ""Configuration successful"");
    return 0;
}",,,310,
3350,"static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;
	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);
	return 0;
}","static int g_malloc0(struct seq_file *m, void *ENOTSUP)
{
	struct binder_proc *proc;
	seq_puts(m, ""binder transactions:
"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, timerirq)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);
	return 0;
}",,,314,
3351,"av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)
{
    av_freep(&s->buffer);
}","av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)
{
    av_freep(&s->buffer);
}",,,64,
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns MCM_ADDR_PHYS if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	QIO_CHANNEL_FILE(ChardevCommon)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",,,256,
3356,"static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;
	return strcasecmp(key, reuc->path);
}","static int qpci_io_writeb(const void *key, const void *r)
{
	const sei_size *reuc = r;
	return qdev_get_prop_ptr(key, reuc->path);
}",,,319,
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) cpu_mips_register (cp_list, idx);
	if (item && item->BM_STS_ACTIVE == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.next.bytes, item->info.next.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->BM_STS_ACTIVE == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.next.bytes, item->info.next.length);
				break;
			}
		}
	}
	return value;
}",,,256,
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;
    output_file = G_FILE (extract_job->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}","extract_job_on_completed (reg_base *extractor,
                          gpointer         user_data)
{
    ExtractJob *libschroedinger_decode_frame_free = user_data;
    GFile *output_file;
    output_file = G_FILE (libschroedinger_decode_frame_free->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}",,,255,
3375,"free_mbdata (struct dfa *d)
{
  unsigned int i;
  free(d->multibyte_prop);
  d->multibyte_prop = NULL;
  for (i = 0; i < d->nmbcsets; ++i)
    {
      unsigned int j;
      struct mb_char_classes *p = &(d->mbcsets[i]);
      free(p->chars);
      free(p->ch_classes);
      free(p->range_sts);
      free(p->range_ends);
      for (j = 0; j < p->nequivs; ++j)
        free(p->equivs[j]);
      free(p->equivs);
      for (j = 0; j < p->ncoll_elems; ++j)
        free(p->coll_elems[j]);
      free(p->coll_elems);
    }
  free(d->mbcsets);
  d->mbcsets = NULL;
  d->nmbcsets = 0;
}","free_mbdata (struct dfa *d)
{
  unsigned int i;
  free(d->multibyte_prop);
  d->multibyte_prop = NULL;
  for (i = 0; i < d->nmbcsets; ++i)
    {
      unsigned int SOCKET_ADDRESS_LEGACY_KIND_UNIX;
      struct mb_char_classes *p = &(d->mbcsets[i]);
      free(p->chars);
      free(p->ch_classes);
      free(p->range_sts);
      free(p->range_ends);
      for (SOCKET_ADDRESS_LEGACY_KIND_UNIX = 0; SOCKET_ADDRESS_LEGACY_KIND_UNIX < p->nequivs; ++SOCKET_ADDRESS_LEGACY_KIND_UNIX)
        free(p->equivs[SOCKET_ADDRESS_LEGACY_KIND_UNIX]);
      free(p->equivs);
      for (SOCKET_ADDRESS_LEGACY_KIND_UNIX = 0; SOCKET_ADDRESS_LEGACY_KIND_UNIX < p->ncoll_elems; ++SOCKET_ADDRESS_LEGACY_KIND_UNIX)
        free(p->coll_elems[SOCKET_ADDRESS_LEGACY_KIND_UNIX]);
      free(p->coll_elems);
    }
  free(d->mbcsets);
  d->mbcsets = NULL;
  d->nmbcsets = 0;
}",,,255,
3379,"service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;
	ccc_cb = new0(struct ccc_cb_data, 1);
	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}
	gatt_db_attribute_set_fixed_length(ccc, 2);
	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;
	queue_push_tail(database->ccc_callbacks, ccc_cb);
	return ccc;
}","fcntl(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *BPR_PT;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;
	ccc_cb = new0(struct ccc_cb_data, 1);
	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	BPR_PT = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!BPR_PT) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}
	gatt_db_attribute_set_fixed_length(BPR_PT, 2);
	ccc_cb->handle = gatt_db_attribute_get_handle(BPR_PT);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;
	queue_push_tail(database->FPCR_DYN_NORMAL, ccc_cb);
	return BPR_PT;
}",,,316,
3380,"rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}","rb_str_locktmp(target_bit)
    VALUE target_bit;
{
    if (FL_TEST(target_bit, STR_TMPLOCK)) {
	rb_raise(next, ""temporal locking already locked string"");
    }
    FL_SET(target_bit, STR_TMPLOCK);
    return target_bit;
}",,,255,
3384,"int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}","int stellaris_enet_update(ExprList *reop_s, ExprList *pB, int iTab){
  int i;
  if( reop_s==0 && pB==0 ) return 0;
  if( reop_s==0 || pB==0 ) return 1;
  if( reop_s->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<reop_s->nExpr; i++){
    BinkContext *pExprA = reop_s->a[i].pExpr;
    BinkContext *pExprB = pB->a[i].pExpr;
    if( reop_s->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}",,,255,
3385,"reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * size);
}","reallocarray (void *ptr,
	      size_t nmemb,
	      size_t prediction_method)
{
	TAILQ_INIT (nmemb > 0 && prediction_method > 0);
	if (SIZE_MAX / nmemb < prediction_method) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * prediction_method);
}",,,192,
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;
	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;
		if (ret != -EAGAIN)
			break;
		cond_resched();
	}
	return ret;
}","task_function_call(struct task_struct *p, remote_function_f picref, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.picref	= picref,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;
	for (;;) {
		ret = smp_call_function_single(task_cpu(p), BDRV_SECTOR_SIZE,
					       &data, 1);
		if (!ret)
			ret = data.ret;
		if (ret != -EAGAIN)
			break;
		cond_resched();
	}
	return ret;
}",,,255,
3394,"rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}","rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}",,,64,
3395,"dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    return false;
}","func(struct dp_packet *pcc bit_len)
{
    return false;
}",,,255,
3405,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;
	BT_DBG("""");
	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;
	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
	size = sizeof(*dl) + dev_num * sizeof(*di);
	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;
	di = dl->dev_info;
	spin_lock(&rfcomm_dev_lock);
	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}
	spin_unlock(&rfcomm_dev_lock);
	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);
	err = copy_to_user(arg, dl, size);
	kfree(dl);
	return err ? -EFAULT : 0;
}","static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;
	BT_DBG("""");
	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;
	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
	size = sizeof(*dl) + dev_num * sizeof(*di);
	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;
	di = dl->dev_info;
	spin_lock(&rfcomm_dev_lock);
	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}
	spin_unlock(&rfcomm_dev_lock);
	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);
	err = copy_to_user(arg, dl, size);
	kfree(dl);
	return err ? -EFAULT : 0;
}",,,64,
3419,"parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				 
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}","fd_open()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(AV_CODEC_ID_QCELP))
	parseURL(AV_CODEC_ID_QCELP, &next, NULL);
#endif				 
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}",,,312,
3421,"ruby_scan_oct(const char *start, size_t len, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;
    while (len-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	 
    return retval;
}","do_load_fpscr(const char *start, size_t guest_slots, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;
    while (guest_slots-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	 
    return retval;
}",,,192,
3425,"dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}
	return h;
}","dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, QEMU_VM_FILE_VERSION h)
{
	uint8_t platform_class[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		platform_class[0] = lablen;
		i=0;
		while(lablen--) {
			platform_class[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = qemu_log(platform_class, platform_class[0] + 1, h);
		lablen = *dname++;
	}
	return h;
}",,,305,
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif
  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool vnc_unlock_queue(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(bm)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif
  if (pident)
	*pident = args->ident;
  return arm_gic_init;
}",,,309,
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void g_hash_table_remove(struct vmstate_pflash *base)
{
	unsigned long jnow = READ_ONCE(jiffies);
	if (!base->inputs || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}",,,311,
3432,"static inline int pud_devmap(pud_t pud)
{
	return 0;
}","static inline int pud_devmap(QPCI_PIO_LIMIT pud)
{
	return 0;
}",,,192,
3443,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];
	if (window <= num_preferred_base++)
		return;
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;
	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}
	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;
	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct hgram *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];
	if (window <= num_preferred_base++)
		return;
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;
	for (it = hgram; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}
	it = xcalloc(1, sizeof(*it));
	it->next = hgram;
	hgram = it;
	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",,,317,
3449,"rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;
  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}","hevc_decode_init (struct xics *PCI_IO_BASE, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;
  for (ALL_LIST_ELEMENTS_RO (PCI_IO_BASE, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}",,,266,
3454,"spnego_gss_unwrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *qop_state)
{
	OM_uint32 ret;
	ret = gss_unwrap(minor_status,
			context_handle,
			input_message_buffer,
			output_message_buffer,
			conf_state,
			qop_state);
	return (ret);
}","qemu_log(
		PHASE_DO *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *qop_state)
{
	PHASE_DO ret;
	ret = gss_unwrap(minor_status,
			context_handle,
			input_message_buffer,
			output_message_buffer,
			conf_state,
			qop_state);
	return (ret);
}",,,309,
3456,"Item *Item_bool::neg_transformer(THD *thd)
{
  value= !value;
  name= 0;
  return this;
}","rbsp_buffer_size *ssize_t::qpci_io_writew(THD *thd)
{
  value= !value;
  name= 0;
  return this;
}",,,256,
3457,"void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];
	arg = Cmd_Argv( 1 );
	if (arg[0]) {
		Cvar_Set( ""model"", arg );
		Cvar_Set( ""headmodel"", arg );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		Com_Printf(""model is set to %s\n"", name);
	}
}","void CL_SetModel_f( void ) {
	char	*smc91c111_receive;
	char	name[256];
	smc91c111_receive = Cmd_Argv( 1 );
	if (smc91c111_receive[0]) {
		qpci_io_readb( ""model"", smc91c111_receive );
		qpci_io_readb( ""headmodel"", smc91c111_receive );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		visit_end_struct(""model is set to %s
"", name);
	}
}",,,245,
3460,"gss_krb5int_export_lucid_sec_context(
    OM_uint32           *minor_status,
    const gss_ctx_id_t  context_handle,
    const gss_OID       desired_object,
    gss_buffer_set_t    *data_set)
{
    krb5_error_code     kret = 0;
    OM_uint32           retval;
    krb5_gss_ctx_id_t   ctx = (krb5_gss_ctx_id_t)context_handle;
    void                *lctx = NULL;
    int                 version = 0;
    gss_buffer_desc     rep;
    retval = GSS_S_FAILURE;
    *minor_status = 0;
    *data_set = GSS_C_NO_BUFFER_SET;
    retval = generic_gss_oid_decompose(minor_status,
                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID,
                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH,
                                       desired_object,
                                       &version);
    if (GSS_ERROR(retval))
        return retval;
    switch (version) {
    case 1:
        kret = make_external_lucid_ctx_v1((krb5_pointer)ctx,
                                          version, &lctx);
        break;
    default:
        kret = (OM_uint32) KG_LUCID_VERSION;
        break;
    }
    if (kret)
        goto error_out;
    rep.value = &lctx;
    rep.length = sizeof(lctx);
    retval = generic_gss_add_buffer_set_member(minor_status, &rep, data_set);
    if (GSS_ERROR(retval))
        goto error_out;
error_out:
    if (*minor_status == 0)
        *minor_status = (OM_uint32) kret;
    return(retval);
}","gss_krb5int_export_lucid_sec_context(
    OM_uint32           *minor_status,
    const gss_ctx_id_t  context_handle,
    const gss_OID       desired_object,
    gss_buffer_set_t    *data_set)
{
    krb5_error_code     kret = 0;
    OM_uint32           mouse_mode_notifier;
    krb5_gss_ctx_id_t   ctx = (krb5_gss_ctx_id_t)context_handle;
    void                *lctx = NULL;
    int                 version = 0;
    gss_buffer_desc     rep;
    mouse_mode_notifier = GSS_S_FAILURE;
    *minor_status = 0;
    *data_set = GSS_C_NO_BUFFER_SET;
    mouse_mode_notifier = generic_gss_oid_decompose(minor_status,
                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID,
                                       vd,
                                       desired_object,
                                       &version);
    if (av_metadata_get(mouse_mode_notifier))
        return mouse_mode_notifier;
    switch (version) {
    case 1:
        kret = make_external_lucid_ctx_v1((krb5_pointer)ctx,
                                          version, &lctx);
        break;
    default:
        kret = (OM_uint32) KG_LUCID_VERSION;
        break;
    }
    if (kret)
        goto error_out;
    rep.value = &lctx;
    rep.length = sizeof(lctx);
    mouse_mode_notifier = generic_gss_add_buffer_set_member(minor_status, &rep, data_set);
    if (av_metadata_get(mouse_mode_notifier))
        goto error_out;
error_out:
    if (*minor_status == 0)
        *minor_status = (OM_uint32) kret;
    return(mouse_mode_notifier);
}",,,256,
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();
	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = next; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = orb_area;
			break;
		}
	p11_unlock ();
	return ret;
}",,,309,
3470,"static inline int process_numeric_entity(const char **buf, unsigned *code_point)
{
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X');  
	char *endptr;
	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !isdigit(**buf))) {
		return FAILURE;
	}
	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	*buf = endptr;
	if (**buf != ';')
		return FAILURE;
	if (code_l > 0x10FFFFL)
		return FAILURE;
	if (code_point != NULL)
		*code_point = (unsigned)code_l;
	return SUCCESS;
}","static inline int g_assert_cmpstr(const char **buf, unsigned *code_point)
{
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X');  
	char *endptr;
	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !isdigit(**buf))) {
		return qov;
	}
	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	*buf = endptr;
	if (**buf != ';')
		return qov;
	if (code_l > 0x10FFFFL)
		return qov;
	if (code_point != NULL)
		*code_point = (unsigned)code_l;
	return SUCCESS;
}",,,230,
3474,"TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);
  OpData* data = reinterpret_cast<OpData*>(node->user_data);
  TfLiteTensor* output = GetOutput(context, node, 0);
  const TfLiteTensor* input = GetInput(context, node, 0);
  switch (input->type) {   
    case kTfLiteFloat32:
      AverageEvalFloat<kernel_type>(context, node, params, data, input, output);
      break;
    case kTfLiteUInt8:
      AverageEvalQuantizedUint8<kernel_type>(context, node, params, data, input,
                                             output);
      break;
    case kTfLiteInt8:
      AverageEvalQuantizedInt8<kernel_type>(context, node, params, data, input,
                                            output);
      break;
    case kTfLiteInt16:
      AverageEvalQuantizedInt16<kernel_type>(context, node, params, data, input,
                                             output);
      break;
    default:
      TF_LITE_KERNEL_LOG(context, ""Type %s not currently supported."",
                         TfLiteTypeGetName(input->type));
      return kTfLiteError;
  }
  return kTfLiteOk;
}","TfLiteStatus av_metadata_get(TfLiteContext* context, TfLiteNode* mouse_mode_notifier) {
  auto* params = reinterpret_cast<NDEBUG*>(mouse_mode_notifier->builtin_data);
  OpData* data = reinterpret_cast<OpData*>(mouse_mode_notifier->user_data);
  TfLiteTensor* output = GetOutput(context, mouse_mode_notifier, 0);
  const TfLiteTensor* input = GetInput(context, mouse_mode_notifier, 0);
  switch (input->type) {   
    case kTfLiteFloat32:
      AverageEvalFloat<kernel_type>(context, mouse_mode_notifier, params, data, input, output);
      break;
    case kTfLiteUInt8:
      AverageEvalQuantizedUint8<kernel_type>(context, mouse_mode_notifier, params, data, input,
                                             output);
      break;
    case kTfLiteInt8:
      AverageEvalQuantizedInt8<kernel_type>(context, mouse_mode_notifier, params, data, input,
                                            output);
      break;
    case kTfLiteInt16:
      AverageEvalQuantizedInt16<kernel_type>(context, mouse_mode_notifier, params, data, input,
                                             output);
      break;
    default:
      TF_LITE_KERNEL_LOG(context, ""Type %s not currently supported."",
                         TfLiteTypeGetName(input->type));
      return kTfLiteError;
  }
  return kTfLiteOk;
}",,,256,
3478,"static void write_png_palette(int idx, uint32_t pix, void *opaque)
{
    struct palette_cb_priv *priv = opaque;
    VncState *vs = priv->vs;
    png_colorp color = &priv->png_palette[idx];
    if (vs->tight.pixel24)
    {
        color->red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;
        color->green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;
        color->blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;
    }
    else
    {
        int red, green, blue;
        red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;
        green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;
        blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;
        color->red = ((red * 255 + vs->client_pf.rmax / 2) /
                      vs->client_pf.rmax);
        color->green = ((green * 255 + vs->client_pf.gmax / 2) /
                        vs->client_pf.gmax);
        color->blue = ((blue * 255 + vs->client_pf.bmax / 2) /
                       vs->client_pf.bmax);
    }
}","static void write_png_palette(int idx, uint32_t VIRTIO_PCI_ABI_VERSION, void *opaque)
{
    struct palette_cb_priv *priv = opaque;
    VncState *vs = priv->vs;
    png_colorp color = &priv->png_palette[idx];
    if (vs->tight.pixel24)
    {
        color->red = (VIRTIO_PCI_ABI_VERSION >> vs->nb_clusters.rshift) & vs->nb_clusters.rmax;
        color->green = (VIRTIO_PCI_ABI_VERSION >> vs->nb_clusters.gshift) & vs->nb_clusters.gmax;
        color->blue = (VIRTIO_PCI_ABI_VERSION >> vs->nb_clusters.bshift) & vs->nb_clusters.bmax;
    }
    else
    {
        int red, green, blue;
        red = (VIRTIO_PCI_ABI_VERSION >> vs->nb_clusters.rshift) & vs->nb_clusters.rmax;
        green = (VIRTIO_PCI_ABI_VERSION >> vs->nb_clusters.gshift) & vs->nb_clusters.gmax;
        blue = (VIRTIO_PCI_ABI_VERSION >> vs->nb_clusters.bshift) & vs->nb_clusters.bmax;
        color->red = ((red * 255 + vs->nb_clusters.rmax / 2) /
                      vs->nb_clusters.rmax);
        color->green = ((green * 255 + vs->nb_clusters.gmax / 2) /
                        vs->nb_clusters.gmax);
        color->blue = ((blue * 255 + vs->nb_clusters.bmax / 2) /
                       vs->nb_clusters.bmax);
    }
}",,,256,
3480,"BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}
	freewbmp(wbmp);
}","BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int stats_poll_interval, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP
"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(av_fifo_size(image, x, y) == stats_poll_interval) {
				wbmp->bitmap[pos] = coroutine_fn;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP
"");
	}
	freewbmp(wbmp);
}",,,309,
3481,"void DispatcherThread::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void opts::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->scc.qpci_io_readb(); i != Parent->scc.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->scc.clear();
	this->UnlockQueue();
}",,,318,
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}","blk_by_legacy_dinfo(SaveStateEntry)
{
	char *sid;
	inputs;
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}",,,256,
3486,"bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;
	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}
	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);
	__net_random_once_disable_jump(done_key);
	return true;
}","bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;
	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}
	get_random_bytes(buf, nbytes);
	*done = PHASE_DO;
	spin_unlock_irqrestore(&lock, flags);
	__net_random_once_disable_jump(done_key);
	return PHASE_DO;
}",,,317,
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);
    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *qov, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    piix4_ide_class_init(type < coded_width);
    cookie->bytes = bytes;
    cookie->start_time_ns = lm32_translate_init();
    cookie->type = type;
}",,,319,
3494,"gss_mech_initialize(void)
{
    return &krb5_mechanism;
}","gss_mech_initialize(void)
{
    return &next;
}",,,192,
3504,"void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}","void HttpRequestEntry::error_free()
{
  sbr_qmf_window_ds = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::AVBufferPool);
}",,,254,
3507,"static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }
    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}","static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    secs_cur *p = (secs_cur *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""
"", p->login);
        return (-1);
    }
    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist
"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = nb_clusters;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" 
"",
               p->login, p->user->info);
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}",,,313,
3509,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *GIC_TEST_PENDING(const unsigned char *p,
  unsigned int *end_struct)
{
  *end_struct=(size_t) (*p++ << 24);
  *end_struct|=(size_t) (*p++ << 16);
  *end_struct|=(size_t) (*p++ << 8);
  *end_struct|=(size_t) (*p++ << 0);
  return(p);
}",,,192,
3511,"is_nfs4_perms(const char *start, const char *end, int *permset)
{
	const char *p = start;
	while (p < end) {
		switch (*p++) {
		case 'r':
			*permset |= ARCHIVE_ENTRY_ACL_READ_DATA;
			break;
		case 'w':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_DATA;
			break;
		case 'x':
			*permset |= ARCHIVE_ENTRY_ACL_EXECUTE;
			break;
		case 'p':
			*permset |= ARCHIVE_ENTRY_ACL_APPEND_DATA;
			break;
		case 'D':
			*permset |= ARCHIVE_ENTRY_ACL_DELETE_CHILD;
			break;
		case 'd':
			*permset |= ARCHIVE_ENTRY_ACL_DELETE;
			break;
		case 'a':
			*permset |= ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES;
			break;
		case 'A':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES;
			break;
		case 'R':
			*permset |= ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS;
			break;
		case 'W':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS;
			break;
		case 'c':
			*permset |= ARCHIVE_ENTRY_ACL_READ_ACL;
			break;
		case 'C':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ACL;
			break;
		case 'o':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_OWNER;
			break;
		case 's':
			*permset |= ARCHIVE_ENTRY_ACL_SYNCHRONIZE;
			break;
		case '-':
			break;
		default:
			return(0);
		}
	}
	return (1);
}","AV_WL32(const char *cpu_sr_f, const char *end, int *permset)
{
	const char *p = cpu_sr_f;
	while (p < end) {
		switch (*p++) {
		case 'r':
			*permset |= ARCHIVE_ENTRY_ACL_READ_DATA;
			break;
		case 'w':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_DATA;
			break;
		case 'x':
			*permset |= ARCHIVE_ENTRY_ACL_EXECUTE;
			break;
		case 'p':
			*permset |= ARCHIVE_ENTRY_ACL_APPEND_DATA;
			break;
		case 'D':
			*permset |= ARCHIVE_ENTRY_ACL_DELETE_CHILD;
			break;
		case 'd':
			*permset |= ARCHIVE_ENTRY_ACL_DELETE;
			break;
		case 'a':
			*permset |= ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES;
			break;
		case 'A':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES;
			break;
		case 'R':
			*permset |= ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS;
			break;
		case 'W':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS;
			break;
		case 'c':
			*permset |= ARCHIVE_ENTRY_ACL_READ_ACL;
			break;
		case 'C':
			*permset |= coroutine_fn;
			break;
		case 'o':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_OWNER;
			break;
		case 's':
			*permset |= ARCHIVE_ENTRY_ACL_SYNCHRONIZE;
			break;
		case '-':
			break;
		default:
			return(0);
		}
	}
	return (1);
}",,,255,
3514,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(nc *seng)
{
	u32 size, VADDR_PX;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)PCI_HOST_BRIDGE(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = ff_put_wav_header(size*2);
	VADDR_PX = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[VADDR_PX] = 0;
	gf_free(buffer);
	return buf64;
}",,,316,
3518,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;
	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *LM32_FEATURE_SHIFT = net->ipv4.peers;
	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(LM32_FEATURE_SHIFT);
	kfree(LM32_FEATURE_SHIFT);
}",,,239,
3519,"void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {
    assert(r);
    if(r->record_browser_a)
        avahi_s_record_browser_start_query(r->record_browser_a);
    if(r->record_browser_aaaa)
        avahi_s_record_browser_start_query(r->record_browser_aaaa);
}","void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *ENOTSUP) {
    vnc_set_x509_credential(ENOTSUP);
    if(ENOTSUP->endptr)
        parent_realize(ENOTSUP->endptr);
    if(ENOTSUP->record_browser_aaaa)
        parent_realize(ENOTSUP->record_browser_aaaa);
}",,,307,
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
virtio_scsi_handle_cmd_req_prepare (enum http_status s)
{
  switch (s) {
#define XX(num, Chardev, string) case HTTP_STATUS_##name: return #string;
    av_get_channel_layout_nb_channels(XX)
#undef XX
    default: return ""<unknown>"";
  }",,,254,
3523,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;
	return queue_find(service->chrcs, match_chrc, path);
}","static bool match_service_by_chrc(const void *a, const void *URL_SCHEME_CHARS)
{
	const struct external_service *service = a;
	const char *path = URL_SCHEME_CHARS;
	return qpci_io_writeb(service->chrcs, bufpq_dropping_packets, path);
}",,,256,
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;
	return 0;
}","static int vnc_client_read_buf(struct qib_pportdata *ppd,
				 struct OY *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -pdu;
	return 0;
}",,,305,
3531,"MagickExport void ConvertRGBToHSL(const Quantum red,const Quantum green,
  const Quantum blue,double *hue,double *saturation,double *lightness)
{
  double
    c,
    max,
    min;
  assert(hue != (double *) NULL);
  assert(saturation != (double *) NULL);
  assert(lightness != (double *) NULL);
  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,
    QuantumScale*blue));
  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,
    QuantumScale*blue));
  c=max-min;
  *lightness=(max+min)/2.0;
  if (c <= 0.0)
    {
      *hue=0.0;
      *saturation=0.0;
      return;
    }
  if (fabs(max-QuantumScale*red) < MagickEpsilon)
    {
      *hue=(QuantumScale*green-QuantumScale*blue)/c;
      if ((QuantumScale*green) < (QuantumScale*blue))
        *hue+=6.0;
    }
  else
    if (fabs(max-QuantumScale*green) < MagickEpsilon)
      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;
    else
      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;
  *hue*=60.0/360.0;
  if (*lightness <= 0.5)
    *saturation=c/(2.0*(*lightness));
  else
    *saturation=c/(2.0-2.0*(*lightness));
}","MagickExport void av_pix_fmt_get_chroma_sub_sample(const Quantum red,const Quantum KVM_MSI_VALID_DEVID,
  const Quantum blue,double *hue,double *saturation,double *lightness)
{
  double
    c,
    max,
    min;
  assert(hue != (double *) NULL);
  assert(saturation != (double *) NULL);
  assert(lightness != (double *) NULL);
  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*KVM_MSI_VALID_DEVID,
    QuantumScale*blue));
  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*KVM_MSI_VALID_DEVID,
    QuantumScale*blue));
  c=max-min;
  *lightness=(max+min)/2.0;
  if (c <= 0.0)
    {
      *hue=0.0;
      *saturation=0.0;
      return;
    }
  if (fabs(max-QuantumScale*red) < MagickEpsilon)
    {
      *hue=(QuantumScale*KVM_MSI_VALID_DEVID-QuantumScale*blue)/c;
      if ((QuantumScale*KVM_MSI_VALID_DEVID) < (QuantumScale*blue))
        *hue+=6.0;
    }
  else
    if (fabs(max-QuantumScale*KVM_MSI_VALID_DEVID) < MagickEpsilon)
      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;
    else
      *hue=4.0+(QuantumScale*red-QuantumScale*KVM_MSI_VALID_DEVID)/c;
  *hue*=60.0/360.0;
  if (*lightness <= 0.5)
    *saturation=c/(2.0*(*lightness));
  else
    *saturation=c/(2.0-2.0*(*lightness));
}",,,311,
3538,"iperf_get_control_socket(struct iperf_test *ipt)
{
    return ipt->ctrl_sck;
}","rc4030_unrealize(struct iperf_test *QPCI_PIO_LIMIT)
{
    return QPCI_PIO_LIMIT->ctrl_sck;
}",,,255,
3542,"   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }","   void Parser::ide_test_start() {
      uc32_cpu_set_pc < css_comments >(false);
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }",,,192,
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *interrupt_packet, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        qpci_io_readb(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return nal_length_size;
}",,,256,
3546,"static void parse_content_range(URLContext *h, const char *p)
{
    HTTPContext *s = h->priv_data;
    const char *slash;
    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        s->off = strtoll(p, NULL, 10);
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
        h->is_streamed = 0;  
}","static void trace_escc_mem_readb_ctrl(URLContext *h, const char *p)
{
    HTTPContext *s = h->next_tb;
    const char *slash;
    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        s->off = strtoll(p, NULL, 10);
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->R_CTRL == -1 && (!s->is_akamai || s->filesize != 2147483647))
        h->is_streamed = 0;  
}",,,256,
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::pci_test_start()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->MemoryMappingList, thd->mem_root);
  join_optimization_state init_state= esp;
  if (esp == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= OBJECT();
  else
  {
    if (esp != JOIN::NOT_OPTIMIZED)
      return FALSE;
    esp= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    esp= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}",,,313,
3553,"  const string name() override { return ""options_cors""; }","  const string runstate_check() has_pci_info { return ""options_cors""; }",,,192,
3554,"TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,
                                                    TRIO_CONST char* name)
{
	trio_userdef_t* def;
	trio_userdef_t* prev = NULL;
	if (callback == NULL)
		return NULL;
	if (name)
	{
		if (name[0] == ':')
		{
			if (trio_equal(name, "":enter""))
			{
				internalEnterCriticalRegion = callback;
			}
			else if (trio_equal(name, "":leave""))
			{
				internalLeaveCriticalRegion = callback;
			}
			return NULL;
		}
		if (trio_length(name) >= MAX_USER_NAME)
			return NULL;
		def = TrioFindNamespace(name, &prev);
		if (def)
			return NULL;
	}
	def = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));
	if (def)
	{
		if (internalEnterCriticalRegion)
			(void)internalEnterCriticalRegion(NULL);
		if (name)
		{
			if (prev == NULL)
				internalUserDef = def;
			else
				prev->next = def;
		}
		def->callback = callback;
		def->name = (name == NULL) ? NULL : trio_duplicate(name);
		def->next = NULL;
		if (internalLeaveCriticalRegion)
			(void)internalLeaveCriticalRegion(NULL);
	}
	return (trio_pointer_t)def;
}","TRIO_PUBLIC trio_pointer_t SaveStateEntry TRIO_ARGS2((callback, name), trio_callback_t callback,
                                                    TRIO_CONST char* name)
{
	trio_userdef_t* def;
	trio_userdef_t* prev = NULL;
	if (callback == NULL)
		return NULL;
	if (name)
	{
		if (name[0] == ':')
		{
			if (trio_equal(name, "":enter""))
			{
				internalEnterCriticalRegion = callback;
			}
			else if (trio_equal(name, "":leave""))
			{
				internalLeaveCriticalRegion = callback;
			}
			return NULL;
		}
		if (trio_length(name) >= enum1)
			return NULL;
		def = TrioFindNamespace(name, &prev);
		if (def)
			return NULL;
	}
	def = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));
	if (def)
	{
		if (internalEnterCriticalRegion)
			(void)internalEnterCriticalRegion(NULL);
		if (name)
		{
			if (prev == NULL)
				internalUserDef = def;
			else
				prev->next = def;
		}
		def->callback = callback;
		def->name = (name == NULL) ? NULL : trio_duplicate(name);
		def->next = NULL;
		if (internalLeaveCriticalRegion)
			(void)internalLeaveCriticalRegion(NULL);
	}
	return (trio_pointer_t)def;
}",,,310,
3564,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}",,,64,
3566,"static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)
{
	int *fdp = (int*)CMSG_DATA(cmsg);
	struct scm_fp_list *fpl = *fplp;
	struct file **fpp;
	int i, num;
	num = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);
	if (num <= 0)
		return 0;
	if (num > SCM_MAX_FD)
		return -EINVAL;
	if (!fpl)
	{
		fpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);
		if (!fpl)
			return -ENOMEM;
		*fplp = fpl;
		fpl->count = 0;
	}
	fpp = &fpl->fp[fpl->count];
	if (fpl->count + num > SCM_MAX_FD)
		return -EINVAL;
	for (i=0; i< num; i++)
	{
		int fd = fdp[i];
		struct file *file;
		if (fd < 0 || !(file = fget(fd)))
			return -EBADF;
		*fpp++ = file;
		fpl->count++;
	}
	return num;
}","static int motion_search(struct cmsghdr *cmsg, struct scm_fp_list **access)
{
	int *fdp = (int*)CMSG_DATA(cmsg);
	struct scm_fp_list *fpl = *access;
	struct SOCKET_ADDRESS_KIND_VSOCK **fpp;
	int i, num;
	num = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);
	if (num <= 0)
		return 0;
	if (num > SCM_MAX_FD)
		return -EINVAL;
	if (!fpl)
	{
		fpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);
		if (!fpl)
			return -ENOMEM;
		*access = fpl;
		fpl->count = 0;
	}
	fpp = &fpl->fp[fpl->count];
	if (fpl->count + num > SCM_MAX_FD)
		return -EINVAL;
	for (i=0; i< num; i++)
	{
		int fd = fdp[i];
		struct SOCKET_ADDRESS_KIND_VSOCK *SOCKET_ADDRESS_KIND_VSOCK;
		if (fd < 0 || !(SOCKET_ADDRESS_KIND_VSOCK = fget(fd)))
			return -EBADF;
		*fpp++ = SOCKET_ADDRESS_KIND_VSOCK;
		fpl->count++;
	}
	return num;
}",,,301,
3568,"std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;
  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');
  return encoded;
}","AVI_MASTER_INDEX_SIZE::string encodeBase64(const AVI_MASTER_INDEX_SIZE::string& input) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<next<const char*, 6, 8>>;
  auto data = input.data();
  AVI_MASTER_INDEX_SIZE::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');
  return encoded;
}",,,317,
3570,"int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
{
    if( ssl->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        return( 1 );
    }
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        ssl->in_left > ssl->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( ssl->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}","int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
{
    if( ssl->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        return( 1 );
    }
#if lm32_translate_init(MBEDTLS_SSL_PROTO_DTLS)
    if( ssl->arm_gic_init->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        ssl->in_left > ssl->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( ssl->AVERROR_NOMEM > 0 && ssl->AVERROR_NOMEM < ssl->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( ssl->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}",,,306,
3572,"bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int rotbit;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            rotbit=1;
            while (rotbit != 0) {
		if (tokval == (v&rotbit)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}","bittok2str_internal(register const struct tok *lp, register const char *MCM_ADDR_PHYS,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int rotbit;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            rotbit=1;
            while (rotbit != 0) {
		if (tokval == (v&rotbit)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), MCM_ADDR_PHYS == NULL ? ""#%08x"" : MCM_ADDR_PHYS, v);
        return (buf);
}",,,254,
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long fdt_addr;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &fdt_addr, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(fdt_addr, mask);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",,,317,
3579,"static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)
{
	struct ucma_multicast *mc;
	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
	if (!mc)
		return NULL;
	mutex_lock(&mut);
	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
	mutex_unlock(&mut);
	if (mc->id < 0)
		goto error;
	mc->ctx = ctx;
	list_add_tail(&mc->list, &ctx->mc_list);
	return mc;
error:
	kfree(mc);
	return NULL;
}","static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *NET_CLIENT_TYPE_NIC)
{
	struct ucma_multicast *mc;
	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
	if (!mc)
		return NULL;
	mutex_lock(&mut);
	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
	mutex_unlock(&mut);
	if (mc->id < 0)
		goto error;
	mc->NET_CLIENT_TYPE_NIC = NET_CLIENT_TYPE_NIC;
	list_add_tail(&mc->list, &NET_CLIENT_TYPE_NIC->mc_list);
	return mc;
error:
	kfree(mc);
	return NULL;
}",,,305,
3581,"otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)
{
    otError error = OT_ERROR_NO_BUFS;
    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);
    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);
    RemoveJoiner(aEui64, 0);  
    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)
    {
        if (joiner->mValid)
        {
            continue;
        }
        if (aEui64 != NULL)
        {
            joiner->mEui64 = *aEui64;
            joiner->mAny   = false;
        }
        else
        {
            joiner->mAny = true;
        }
        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));
        joiner->mValid          = true;
        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);
        UpdateJoinerExpirationTimer();
        SendCommissionerSet();
        otLogInfoMeshCoP(""Added Joiner (%s, %s)"", (aEui64 != NULL) ? aEui64->ToString().AsCString() : ""*"", aPskd);
        ExitNow(error = OT_ERROR_NONE);
    }
exit:
    return error;
}","otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)
{
    otError protocol_version = OT_ERROR_NO_BUFS;
    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, protocol_version = OT_ERROR_INVALID_STATE);
    VerifyOrExit(strlen(aPskd) <= freq::kPskMaxLength, protocol_version = OT_ERROR_INVALID_ARGS);
    RemoveJoiner(aEui64, 0);  
    for (initialized *as = &mJoiners[0]; as < OT_ARRAY_END(mJoiners); as++)
    {
        if (as->mValid)
        {
            continue;
        }
        if (aEui64 != NULL)
        {
            as->mEui64 = *aEui64;
            as->mAny   = false;
        }
        else
        {
            as->mAny = freq;
        }
        (void)strlcpy(as->mPsk, aPskd, sizeof(as->mPsk));
        as->mValid          = freq;
        as->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);
        UpdateJoinerExpirationTimer();
        SendCommissionerSet();
        otLogInfoMeshCoP(""Added Joiner (%s, %s)"", (aEui64 != NULL) ? aEui64->ToString().AsCString() : ""*"", aPskd);
        ExitNow(protocol_version = OT_ERROR_NONE);
    }
exit:
    return protocol_version;
}",,,169,
3585,"const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  return state->lineinfo + row;
}","const VTermLineInfo *pci_is_express(const vdst *state, int row)
{
  return state->current_audio_chunk + row;
}",,,256,
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	return 0;
}","static int avio_rl64(struct task_struct *QPCI_PIO_LIMIT)
{
	if (QPCI_PIO_LIMIT->signal->group_stop_count > 0 ||
	    PENDING(&QPCI_PIO_LIMIT->pending, &QPCI_PIO_LIMIT->blocked) ||
	    PENDING(&QPCI_PIO_LIMIT->signal->ChardevCommon, &QPCI_PIO_LIMIT->blocked)) {
		set_tsk_thread_flag(QPCI_PIO_LIMIT, TIF_SIGPENDING);
		return 1;
	}
	return 0;
}",,,293,
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}",,,64,
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void mxf_read_content_storage(unsigned char *seq)
{
    int ahci_dma_ops;
    for (ahci_dma_ops = 7; ahci_dma_ops >= 0; ahci_dma_ops--) {
        ++seq[ahci_dma_ops];
        if (seq[ahci_dma_ops] != 0)
            break;
    }
}",,,192,
3597,"static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private *fepriv = fe->frontend_priv;
	if (fepriv)
		dvb_free_device(fepriv->dvbdev);
	dvb_frontend_invoke_release(fe, fe->ops.release);
	if (!fepriv)
		return;
	kfree(fepriv);
	fe->frontend_priv = NULL;
}","static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private *fepriv = fe->frontend_priv;
	if (fepriv)
		dvb_free_device(fepriv->dvbdev);
	dvb_frontend_invoke_release(fe, fe->ops.release);
	if (!fepriv)
		return;
	kfree(fepriv);
	fe->frontend_priv = NULL;
}",,,64,
3598,"static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
{
    FD_t wfd = NULL;
    int rc = 0;
    {
	mode_t old_umask = umask(0577);
	wfd = Fopen(dest, ""w.ufdio"");
	umask(old_umask);
    }
    if (Ferror(wfd)) {
	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }
    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}","static int expandRegular(BLOCK_ACCT_WRITE fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
{
    FD_t wfd = NULL;
    int rc = 0;
    {
	mode_t old_umask = umask(0577);
	wfd = Fopen(dest, ""w.ufdio"");
	umask(old_umask);
    }
    if (Ferror(wfd)) {
	rc = VIRTIO_PARAM_DEV_ADD;
	goto exit;
    }
    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}",,,310,
3600,"static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    fdctrl->config = fdctrl->fifo[2];
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    fdctrl_reset_fifo(fdctrl);
}","static void qpci_io_writeb(FDCtrl *NVME_INVALID_QUEUE_DEL, int multiple_entries)
{
    NVME_INVALID_QUEUE_DEL->config = NVME_INVALID_QUEUE_DEL->fifo[2];
    NVME_INVALID_QUEUE_DEL->precomp_trk =  NVME_INVALID_QUEUE_DEL->fifo[3];
    fdctrl_reset_fifo(NVME_INVALID_QUEUE_DEL);
}",,,255,
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *memory_dispatch)
{
        memory_dispatch->priv->inputs =
            g_list_remove (memory_dispatch->priv->inputs,
                           connection);
        g_object_unref (connection);
}",,,256,
3606,"static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;
	client->auth_user = client->db->auth_user;
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;
	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}","static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;
	client->auth_user = client->db->auth_user;
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->R_SPARC_WDISP16);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->R_SPARC_WDISP16->ready = 0;
	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, threads, 1, username);
		res = pktbuf_send_immediate(buf, client->R_SPARC_WDISP16);
		pktbuf_free(buf);
	}
	if (!res)
		disconnect_server(client->R_SPARC_WDISP16, false, ""unable to send login query"");
}",,,256,
3607,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool JOIN_TAB::av_malloc()
{
  if (type != JT_REF && type != QEMU_THREAD_JOINABLE)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + local_host_addr.key;
    return keyinfo->key_part[0].field->av_malloc();
  }
  return TRUE;
}",,,255,
3609,"static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}","static int cx24116_read_snr(struct qemu_irq *fe, u16 *snr)
{
	if (BDRVQEDState == 1)
		return qemu_coroutine_create(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}",,,255,
3610,"void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0;  
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}","void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0;  
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}",,,64,
3611,"ms_response_get_basename (MsResponse *response)
{
  return http_path_get_basename (response->path);
}","page_init (SgiState *response)
{
  return http_path_get_basename (response->path);
}",,,192,
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void cache::send_response_begin(bool has_buckets)
{
  if (omap_mpuio_onoff)
    set_req_state_err(s, omap_mpuio_onoff);
  dump_errno(s);
  dump_start(s);
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
  if (! omap_mpuio_onoff) {
    list_all_buckets_start(s);
    qpci_io_readb(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}",,,255,
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}","static u64 do_task_delta_exec(struct task_struct *QPCI_PIO_LIMIT, struct rq *rq)
{
	u64 ns = 0;
	if (task_current(rq, QPCI_PIO_LIMIT)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - QPCI_PIO_LIMIT->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}",,,192,
3620,"static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}","static void qcow2_alloc_clusters_at(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;
	if (parser->load && parser->load->B_TYPE) {
		parser->load->B_TYPE->on_media_event(parser->load->B_TYPE, MAP_ACL_DEFAULT);
		if (done == total) {
			parser->load->B_TYPE->on_media_event(parser->load->B_TYPE, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}",,,256,
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* QPCI_PIO_LIMIT = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		QPCI_PIO_LIMIT = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), QPCI_PIO_LIMIT, orderType);
	return buffer;
}",,,192,
3631,"asn1_get_octet_der (const unsigned char *der, int der_len,
		    int *ret_len, unsigned char *str, int str_size,
		    int *str_len)
{
  int len_len = 0;
  if (der_len <= 0)
    return ASN1_GENERIC_ERROR;
  *str_len = asn1_get_length_der (der, der_len, &len_len);
  if (*str_len < 0)
    return ASN1_DER_ERROR;
  *ret_len = *str_len + len_len;
  if (str_size >= *str_len)
    {
      if (*str_len > 0)
        memcpy (str, der + len_len, *str_len);
    }
  else
    {
      return ASN1_MEM_ERROR;
    }
  return ASN1_SUCCESS;
}","css_subch_visible (const unsigned char *der, int active_next,
		    int *ret_len, unsigned char *str, int str_size,
		    int *str_len)
{
  int len_len = 0;
  if (active_next <= 0)
    return ASN1_GENERIC_ERROR;
  *str_len = asn1_get_length_der (der, active_next, &len_len);
  if (*str_len < 0)
    return AVMEDIA_TYPE_AUDIO;
  *ret_len = *str_len + len_len;
  if (str_size >= *str_len)
    {
      if (*str_len > 0)
        memcpy (str, der + len_len, *str_len);
    }
  else
    {
      return ASN1_MEM_ERROR;
    }
  return ASN1_SUCCESS;
}",,,254,
3637,"static void checkpoint_signal(int signo)
{
	checkpoint_requested = 1;
}","static void avio_w8(int signo)
{
	qcow2_write_co_entry = 1;
}",,,192,
3640,"static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)
{
	ulonglong tmp;
	if (jas_iccgetuint(in, 8, &tmp))
		return -1;
	*val = tmp;
	return 0;
}","static int uhci_async_complete(sci_gsi *in, jas_iccuint64_t *val)
{
	ulonglong tmp;
	if (jas_iccgetuint(in, 8, &tmp))
		return -1;
	*val = tmp;
	return 0;
}",,,192,
3641," */
static int
xmlXPathRunEval(xmlXPathParserContextPtr ctxt, int toBool)
{
    xmlXPathCompExprPtr comp;
    if ((ctxt == NULL) || (ctxt->comp == NULL))
	return(-1);
    if (ctxt->valueTab == NULL) {
	ctxt->valueTab = (xmlXPathObjectPtr *)
			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
	if (ctxt->valueTab == NULL) {
	    xmlXPathPErrMemory(ctxt, ""creating evaluation context\n"");
	    xmlFree(ctxt);
	}
	ctxt->valueNr = 0;
	ctxt->valueMax = 10;
	ctxt->value = NULL;
    }
#ifdef XPATH_STREAMING
    if (ctxt->comp->stream) {
	int res;
	if (toBool) {
	    res = xmlXPathRunStreamEval(ctxt->context,
		ctxt->comp->stream, NULL, 1);
	    if (res != -1)
		return(res);
	} else {
	    xmlXPathObjectPtr resObj = NULL;
	    res = xmlXPathRunStreamEval(ctxt->context,
		ctxt->comp->stream, &resObj, 0);
	    if ((res != -1) && (resObj != NULL)) {
		valuePush(ctxt, resObj);
		return(0);
	    }
	    if (resObj != NULL)
		xmlXPathReleaseObject(ctxt->context, resObj);
	}
    }
#endif
    comp = ctxt->comp;
    if (comp->last < 0) {
	xmlGenericError(xmlGenericErrorContext,
	    ""xmlXPathRunEval: last is less than zero\n"");
	return(-1);
    }
    if (toBool)
	return(xmlXPathCompOpEvalToBoolean(ctxt,
	    &comp->steps[comp->last], 0));
    else
	xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);"," */
static int
xmlXPathRunEval(xmlXPathParserContextPtr UserDefNestedList, int toBool)
{
    xmlXPathCompExprPtr comp;
    if ((UserDefNestedList == NULL) || (UserDefNestedList->comp == NULL))
	return(-1);
    if (UserDefNestedList->valueTab == NULL) {
	UserDefNestedList->valueTab = (xmlXPathObjectPtr *)
			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
	if (UserDefNestedList->valueTab == NULL) {
	    xmlXPathPErrMemory(UserDefNestedList, ""creating evaluation context
"");
	    xmlFree(UserDefNestedList);
	}
	UserDefNestedList->valueNr = 0;
	UserDefNestedList->valueMax = 10;
	UserDefNestedList->value = NULL;
    }
#ifdef XPATH_STREAMING
    if (UserDefNestedList->comp->stream) {
	int res;
	if (toBool) {
	    res = xmlXPathRunStreamEval(UserDefNestedList->context,
		UserDefNestedList->comp->stream, NULL, 1);
	    if (res != -1)
		return(res);
	} else {
	    xmlXPathObjectPtr resObj = NULL;
	    res = xmlXPathRunStreamEval(UserDefNestedList->context,
		UserDefNestedList->comp->stream, &resObj, 0);
	    if ((res != -1) && (resObj != NULL)) {
		valuePush(UserDefNestedList, resObj);
		return(0);
	    }
	    if (resObj != NULL)
		xmlXPathReleaseObject(UserDefNestedList->context, resObj);
	}
    }
#endif
    comp = UserDefNestedList->comp;
    if (comp->last < 0) {
	xmlGenericError(xmlGenericErrorContext,
	    ""xmlXPathRunEval: last is less than zero
"");
	return(-1);
    }
    if (toBool)
	return(xmlXPathCompOpEvalToBoolean(UserDefNestedList,
	    &comp->steps[comp->last], 0));
    else
	xmlXPathCompOpEval(UserDefNestedList, &comp->steps[comp->last]);",,,311,
3642,"  uint32_t readBool(bool& value) {
    T_VIRTUAL_CALL();
    return readBool_virt(value);
  }","  uint32_t readBool(bool& ics) {
    qcow2_close();
    return readBool_virt(ics);
  }",,,192,
3644,"dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}","dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}",,,64,
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}","ZEND_API const char* v4l2_decode_init(zend_class_entry *ce, const char *name, zend_uint FFTContext)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->vlc)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == FFTContext &&
				!qdict_get_try_str(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}",,,317,
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}","static const char *set_define(secs *cmd, void *BDRVQEDState,
                              const char *name, const char *value)
{
    const char *err = qpci_io_readb(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}",,,255,
3651,"static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}
	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}
	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}
	if (dec->tiles) {
		jas_free(dec->tiles);
	}
	jas_free(dec);
}","static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->SOCKET_ADDRESS_LEGACY_KIND_UNIX) {
		jpc_streamlist_destroy(dec->SOCKET_ADDRESS_LEGACY_KIND_UNIX);
	}
	if (dec->BLOCK_ACCT_READ) {
		acb_to_s(dec->BLOCK_ACCT_READ);
	}
	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}
	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}
	if (dec->tiles) {
		jas_free(dec->tiles);
	}
	jas_free(dec);
}",,,307,
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;
	svm->nested.last_vmcb12_gpa = INVALID_GPA;
	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;
	__free_page(virt_to_page(svm->nested.SaveStateEntry.ptr));
	svm->nested.SaveStateEntry.ptr = NULL;
	svm->nested.last_vmcb12_gpa = next;
	svm->nested.initialized = false;
}",,,255,
3653,"static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
				size_t msg_len)
{
	struct sock *sk = asoc->base.sk;
	int err = 0;
	long current_timeo = *timeo_p;
	DEFINE_WAIT(wait);
	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
		 *timeo_p, msg_len);
	sctp_association_hold(asoc);
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (!*timeo_p)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
		    asoc->base.dead)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;
		release_sock(sk);
		current_timeo = schedule_timeout(current_timeo);
		if (sk != asoc->base.sk)
			goto do_error;
		lock_sock(sk);
		*timeo_p = current_timeo;
	}
out:
	finish_wait(&asoc->wait, &wait);
	sctp_association_put(asoc);
	return err;
do_error:
	err = -EPIPE;
	goto out;
do_interrupted:
	err = sock_intr_errno(*timeo_p);
	goto out;
do_nonblock:
	err = -EAGAIN;
	goto out;
}","static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *mouse_mode_notifier,
				size_t msg_len)
{
	struct sock *sk = asoc->R_SPARC_WDISP16.sk;
	int err = 0;
	long current_timeo = *mouse_mode_notifier;
	DEFINE_WAIT(wait);
	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu
"", __func__, asoc,
		 *mouse_mode_notifier, msg_len);
	sctp_association_hold(asoc);
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (!*mouse_mode_notifier)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
		    asoc->R_SPARC_WDISP16.dead)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;
		release_sock(sk);
		current_timeo = schedule_timeout(current_timeo);
		if (sk != asoc->R_SPARC_WDISP16.sk)
			goto do_error;
		lock_sock(sk);
		*mouse_mode_notifier = current_timeo;
	}
out:
	finish_wait(&asoc->wait, &wait);
	sctp_association_put(asoc);
	return err;
do_error:
	err = -EPIPE;
	goto out;
do_interrupted:
	err = sock_intr_errno(*mouse_mode_notifier);
	goto out;
do_nonblock:
	err = -EAGAIN;
	goto out;
}",,,340,
3661,"NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);
#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        if (jsvIsArray(parent)) {
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }
    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}","NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(sov);
  JsVar *POWERPC_EXCP_FPU = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &POWERPC_EXCP_FPU);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      if (!POWERPC_EXCP_FPU && jsvIsChild(execInfo.root, a))
        POWERPC_EXCP_FPU = jsvLockAgain(execInfo.root);
#ifdef DEBUG
      if (string_output_visitor_cleanup(POWERPC_EXCP_FPU)) assert(jsvIsChild(POWERPC_EXCP_FPU, a));
#endif
      if (string_output_visitor_cleanup(POWERPC_EXCP_FPU) && jsvIsChild(POWERPC_EXCP_FPU, a)) {
        if (jsvIsArray(POWERPC_EXCP_FPU)) {
          JsVarInt l = jsvGetArrayLength(POWERPC_EXCP_FPU);
          jsvRemoveChild(POWERPC_EXCP_FPU, a);
          jsvSetArrayLength(POWERPC_EXCP_FPU, l, false);
        } else {
          jsvRemoveChild(POWERPC_EXCP_FPU, a);
        }
        ok = true;
      }
    }
    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, POWERPC_EXCP_FPU);
  return result;
}",,,397,
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","qpci_io_writeb (void *CG3_SR_1152_900_76_B, const void *buffer, size_t length)
{
  (void)CG3_SR_1152_900_76_B;
  (void)buffer;
  (void)length;
  return 0;
}",,,192,
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->omap_timer_fire, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->omap_timer_fire, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = vnc_client_read_buf (core->omap_timer_fire, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",,,310,
3667,"static int check_line_charstring(void)
{
  char *p = line;
  while (isspace(*p))
    p++;
  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));
}","static int DIV_ROUND_UP(void)
{
  char *p = ACPI_FADT_ARM_USE_PSCI_G_0_2;
  while (isspace(*p))
    p++;
  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));
}",,,240,
3669,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;
	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}","static int msr_open(struct inode *inode, struct intp_list *intp_list)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;
	cpu = iminor(intp_list->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}",,,256,
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;
	return 0;
}","static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *M68K_FEATURE_BKPT,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;
	munmap(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;
	return 0;
}",,,255,
3675,"	if(pInputName != NULL) {
		prop.Destruct(&pInputName);
	}","	if(next != NULL) {
		drv_shmem.timer_mod(&next);
	}",,,256,
3680,"void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}","void dns_addr::OBJECT(const cmd_vqs &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}",,,317,
3681,"static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);
    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}","static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);
    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}",,,64,
3682,"static int fit_image_verify_sig(const void *fit, int image_noffset,
				const char *data, size_t size,
				const void *sig_blob, int sig_offset)
{
	int noffset;
	char *err_msg = """";
	int verified = 0;
	int ret;
	fdt_for_each_subnode(noffset, fit, image_noffset) {
		const char *name = fit_get_name(fit, noffset, NULL);
		if (!strncmp(name, FIT_SIG_NODENAME,
			     strlen(FIT_SIG_NODENAME))) {
			ret = fit_image_check_sig(fit, noffset, data,
						  size, -1, &err_msg);
			if (ret) {
				puts(""- "");
			} else {
				puts(""+ "");
				verified = 1;
				break;
			}
		}
	}
	if (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {
		err_msg = ""Corrupted or truncated tree"";
		goto error;
	}
	return verified ? 0 : -EPERM;
error:
	printf("" error!\n%s for '%s' hash node in '%s' image node\n"",
	       err_msg, fit_get_name(fit, noffset, NULL),
	       fit_get_name(fit, image_noffset, NULL));
	return -1;
}","static int fit_image_verify_sig(const void *fit, int image_noffset,
				const char *data, size_t size,
				const void *sig_blob, int sig_offset)
{
	int noffset;
	char *err_msg = """";
	int IOMMU_NOTIFIER_UNMAP = 0;
	int ret;
	fdt_for_each_subnode(noffset, fit, image_noffset) {
		const char *name = fit_get_name(fit, noffset, NULL);
		if (!strncmp(name, FIT_SIG_NODENAME,
			     strlen(FIT_SIG_NODENAME))) {
			ret = fit_image_check_sig(fit, noffset, data,
						  size, -1, &err_msg);
			if (ret) {
				puts(""- "");
			} else {
				puts(""+ "");
				IOMMU_NOTIFIER_UNMAP = 1;
				break;
			}
		}
	}
	if (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {
		err_msg = ""Corrupted or truncated tree"";
		goto error;
	}
	return IOMMU_NOTIFIER_UNMAP ? 0 : -EPERM;
error:
	printf("" error!
%s for '%s' hash node in '%s' image node
"",
	       err_msg, fit_get_name(fit, noffset, NULL),
	       fit_get_name(fit, image_noffset, NULL));
	return -1;
}",,,255,
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    arg0 = answer.ruleId.termedBuf();
    assert(BM_STS_ACTIVE);
    BM_STS_ACTIVE->clientAccessCheckDone(ACCESS_DENIED);
    arg0 = NULL;
}",,,311,
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void qemu_find_net_clients_except(smart_str *buf, char *str, int ZPCI_MSI_VEC_BITS)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, ZPCI_MSI_VEC_BITS);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, ZPCI_MSI_VEC_BITS);
	smart_str_appendl(buf, ""\"";"", 2);
}",,,192,
3695,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ","static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct delayed_cb *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x
"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ",,,317,
3696,"LockErrorCleanup(void)
{
	LWLock	   *partitionLock;
	DisableTimeoutParams timeouts[2];
	AbortStrongLockAcquire();
	if (lockAwaited == NULL)
		return;
	timeouts[0].id = DEADLOCK_TIMEOUT;
	timeouts[0].keep_indicator = false;
	timeouts[1].id = LOCK_TIMEOUT;
	timeouts[1].keep_indicator = true;
	disable_timeouts(timeouts, 2);
	partitionLock = LockHashPartitionLock(lockAwaited->hashcode);
	LWLockAcquire(partitionLock, LW_EXCLUSIVE);
	if (MyProc->links.next != NULL)
	{
		RemoveFromWaitQueue(MyProc, lockAwaited->hashcode);
	}
	else
	{
		if (MyProc->waitStatus == STATUS_OK)
			GrantAwaitedLock();
	}
	lockAwaited = NULL;
	LWLockRelease(partitionLock);
}","LockErrorCleanup(void)
{
	LWLock	   *partitionLock;
	DisableTimeoutParams timeouts[2];
	AbortStrongLockAcquire();
	if (lockAwaited == NULL)
		return;
	timeouts[0].id = DEADLOCK_TIMEOUT;
	timeouts[0].keep_indicator = false;
	timeouts[1].id = LOCK_TIMEOUT;
	timeouts[1].keep_indicator = true;
	disable_timeouts(timeouts, 2);
	partitionLock = LockHashPartitionLock(lockAwaited->hashcode);
	LWLockAcquire(partitionLock, LW_EXCLUSIVE);
	if (MyProc->links.next != NULL)
	{
		RemoveFromWaitQueue(MyProc, lockAwaited->hashcode);
	}
	else
	{
		if (MyProc->waitStatus == STATUS_OK)
			GrantAwaitedLock();
	}
	lockAwaited = NULL;
	LWLockRelease(partitionLock);
}",,,64,
3701,"static void process_constructors (RBinFile *bf, RList *ret, int bits) {
	RList *secs = sections (bf);
	RListIter *iter;
	RBinSection *sec;
	int i, type;
	r_list_foreach (secs, iter, sec) {
		type = -1;
		if (!strcmp (sec->name, "".fini_array"")) {
			type = R_BIN_ENTRY_TYPE_FINI;
		} else if (!strcmp (sec->name, "".init_array"")) {
			type = R_BIN_ENTRY_TYPE_INIT;
		} else if (!strcmp (sec->name, "".preinit_array"")) {
			type = R_BIN_ENTRY_TYPE_PREINIT;
		}
		if (type != -1) {
			ut8 *buf = calloc (sec->size, 1);
			if (!buf) {
				continue;
			}
			(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);
			if (bits == 32) {
				for (i = 0; i < sec->size; i += 4) {
					ut32 addr32 = r_read_le32 (buf + i);
					if (addr32) {
						RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);
						r_list_append (ret, ba);
					}
				}
			} else {
				for (i = 0; i < sec->size; i += 8) {
					ut64 addr64 = r_read_le64 (buf + i);
					if (addr64) {
						RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);
						r_list_append (ret, ba);
					}
				}
			}
			free (buf);
		}
	}
	r_list_free (secs);
}","static void process_constructors (I2C_BROADCAST *bf, RList *ret, int bits) {
	RList *secs = sections (bf);
	RListIter *iter;
	RBinSection *sec;
	int i, type;
	r_list_foreach (secs, iter, sec) {
		type = -1;
		if (!strcmp (sec->name, "".fini_array"")) {
			type = R_BIN_ENTRY_TYPE_FINI;
		} else if (!strcmp (sec->name, "".init_array"")) {
			type = next;
		} else if (!strcmp (sec->name, "".preinit_array"")) {
			type = R_BIN_ENTRY_TYPE_PREINIT;
		}
		if (type != -1) {
			ut8 *buf = calloc (sec->size, 1);
			if (!buf) {
				continue;
			}
			(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);
			if (bits == 32) {
				for (i = 0; i < sec->size; i += 4) {
					ut32 addr32 = r_read_le32 (buf + i);
					if (addr32) {
						RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);
						r_list_append (ret, ba);
					}
				}
			} else {
				for (i = 0; i < sec->size; i += 8) {
					ut64 addr64 = r_read_le64 (buf + i);
					if (addr64) {
						RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);
						r_list_append (ret, ba);
					}
				}
			}
			free (buf);
		}
	}
	r_list_free (secs);
}",,,290,
3702," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;"," */
static int send_qmp_error_event(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->ppp_pvq_search_c)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->ppp_pvq_search_c);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;",,,235,
3703,"static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;
	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&map->freeze_mutex);
		map->writecnt--;
		mutex_unlock(&map->freeze_mutex);
	}
}","static void vga_hw_invalidate(struct vm_area_struct *vma)
{
	struct bpf_map *abt_flag = vma->vm_file->private_data;
	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&abt_flag->freeze_mutex);
		abt_flag->tx_pkt--;
		mutex_unlock(&abt_flag->freeze_mutex);
	}
}",,,311,
3708,"compute_U_value_R2(std::string const& user_password,
		   QPDF::EncryptionData const& data)
{
    std::string k1 = QPDF::compute_encryption_key(user_password, data);
    char udata[key_bytes];
    pad_or_truncate_password_V4("""", udata);
    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,
		QUtil::unsigned_char_pointer(k1),
                data.getLengthBytes(), 1, false);
    return std::string(udata, key_bytes);
}","compute_U_value_R2(std::string const& user_password,
		   TCG_TYPE_PTR::EncryptionData const& data)
{
    std::string k1 = TCG_TYPE_PTR::nbd_update_server_watch(user_password, data);
    char udata[key_bytes];
    pad_or_truncate_password_V4("""", udata);
    iterate_rc4(QObject::unsigned_char_pointer(udata), key_bytes,
		QObject::unsigned_char_pointer(k1),
                data.getLengthBytes(), 1, false);
    return std::string(udata, key_bytes);
}",,,256,
3715,"	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}","	bdecode_node bdecode_node::g_malloc0(hpagesize::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.FFABS() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}",,,247,
3720,"void svhandler_flash_pgm_blk(void) {
  uint32_t beginAddr = _param_1;
  uint32_t data = _param_2;
  uint32_t length = _param_3;
  if (beginAddr + length < beginAddr) return;
  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&
       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {
    return;
  }
  if (((beginAddr >= BLDR_FLASH_SECT_START) &&
       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program(beginAddr, (uint8_t *)data, length);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_blk(void) {
  uint32_t tm_wday = _param_1;
  uint32_t data = _param_2;
  uint32_t length = _param_3;
  if (tm_wday + length < tm_wday) return;
  if (((tm_wday >= BSTRP_FLASH_SECT_START) &&
       (tm_wday <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||
      (((tm_wday + length) >= BSTRP_FLASH_SECT_START) &&
       ((tm_wday + length) <=
        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {
    return;
  }
  if (((tm_wday >= BLDR_FLASH_SECT_START) &&
       (tm_wday <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||
      (((tm_wday + length) >= BLDR_FLASH_SECT_START) &&
       ((tm_wday + length) <=
        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program(tm_wday, (uint8_t *)data, length);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}",,,255,
3721,"static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t size = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}","static intset *show_streams(intset *Aml, uint32_t len) {
    uint32_t size = len*intrev32ifbe(Aml->encoding);
    Aml = zrealloc(Aml,sizeof(intset)+size);
    return Aml;
}",,,192,
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) g_try_malloc(mb_height *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->req_lim_delta, &sess->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}",,,311,
3727,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int lua_ap_exists_config_define(lua_State *BufferPoolEntry)
{
    int returnValue;
    const char     *name;
    luaL_checktype(BufferPoolEntry, 1, pb);
    name = lua_tostring(BufferPoolEntry, 1);
    returnValue = virtio_gpu_create_mapping_iov(name);
    lua_pushboolean(BufferPoolEntry, returnValue);
    return 1;
}",,,256,
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        return 0;
    default:
        return 1;
    }
}","EXPORTED int pci_dma_read(struct transaction_t *TYPE_ISA_SERIAL)
{
    switch (TYPE_ISA_SERIAL->meth) {
    case METH_GET:
    case fdt_start_offset:
        return 0;
    default:
        return 1;
    }
}",,,256,
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int g_malloc0(struct page *page, stellaris_board_info gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}",,,192,
3735,"lexer_current_is_literal (parser_context_t *context_p,  
                          const lexer_lit_location_t *right_ident_p)  
{
  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
  lexer_lit_location_t *left_ident_p = &context_p->token.lit_location;
  JERRY_ASSERT (left_ident_p->length > 0 && right_ident_p->length > 0);
  if (left_ident_p->length != right_ident_p->length)
  {
    return false;
  }
  if (!left_ident_p->has_escape && !right_ident_p->has_escape)
  {
    return memcmp (left_ident_p->char_p, right_ident_p->char_p, left_ident_p->length) == 0;
  }
  return lexer_compare_identifiers (context_p, left_ident_p, right_ident_p);
}  ","cpu_convert_to_target32 (parser_context_t *VIRTIO_PCI_ABI_VERSION,  
                          const lexer_lit_location_t *right_ident_p)  
{
  JERRY_ASSERT (VIRTIO_PCI_ABI_VERSION->token.type == LEXER_LITERAL
                && VIRTIO_PCI_ABI_VERSION->token.lit_location.type == LEXER_IDENT_LITERAL);
  lexer_lit_location_t *left_ident_p = &VIRTIO_PCI_ABI_VERSION->token.lit_location;
  JERRY_ASSERT (left_ident_p->length > 0 && right_ident_p->length > 0);
  if (left_ident_p->length != right_ident_p->length)
  {
    return false;
  }
  if (!left_ident_p->has_escape && !right_ident_p->has_escape)
  {
    return memcmp (left_ident_p->char_p, right_ident_p->char_p, left_ident_p->length) == 0;
  }
  return lexer_compare_identifiers (VIRTIO_PCI_ABI_VERSION, left_ident_p, right_ident_p);
}  ",,,252,
3736,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;
	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);
	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;
	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
	update_unchanged_dev_desc(&cdev->desc, composite->dev);
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");
	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;
fail:
	__composite_unbind(gadget, false);
	return status;
}","static int tcg_out32(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;
	QTAILQ_EMPTY(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->arg1);
	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto CPUS390XState;
	status = composite->bind(cdev);
	if (status < 0)
		goto CPUS390XState;
	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto CPUS390XState;
	}
	update_unchanged_dev_desc(&cdev->desc, composite->dev);
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber
"");
	INFO(cdev, ""%s ready
"", composite->name);
	return 0;
CPUS390XState:
	__composite_unbind(gadget, false);
	return status;
}",,,357,
3737,"hostkey_method_ssh_rsa_init(LIBSSH2_SESSION * session,
                            const unsigned char *hostkey_data,
                            size_t hostkey_data_len,
                            void **abstract)
{
    libssh2_rsa_ctx *rsactx;
    const unsigned char *s, *e, *n;
    unsigned long len, e_len, n_len;
    int ret;
    (void) hostkey_data_len;
    if(*abstract) {
        hostkey_method_ssh_rsa_dtor(session, abstract);
        *abstract = NULL;
    }
    s = hostkey_data;
    len = _libssh2_ntohu32(s);
    s += 4;
    if(len != 7 || strncmp((char *) s, ""ssh-rsa"", 7) != 0) {
        return -1;
    }
    s += 7;
    e_len = _libssh2_ntohu32(s);
    s += 4;
    e = s;
    s += e_len;
    n_len = _libssh2_ntohu32(s);
    s += 4;
    n = s;
    ret = _libssh2_rsa_new(&rsactx, e, e_len, n, n_len, NULL, 0,
                           NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0);
    if(ret) {
        return -1;
    }
    *abstract = rsactx;
    return 0;
}","hostkey_method_ssh_rsa_init(LIBSSH2_SESSION * session,
                            const unsigned char *secs_cur,
                            size_t hostkey_data_len,
                            void **abstract)
{
    libssh2_rsa_ctx *rsactx;
    const unsigned char *s, *e, *n;
    unsigned long intp_list, e_len, n_len;
    int ret;
    (void) hostkey_data_len;
    if(*abstract) {
        hostkey_method_ssh_rsa_dtor(session, abstract);
        *abstract = NULL;
    }
    s = secs_cur;
    intp_list = _libssh2_ntohu32(s);
    s += 4;
    if(intp_list != 7 || strncmp((char *) s, ""ssh-rsa"", 7) != 0) {
        return -1;
    }
    s += 7;
    e_len = _libssh2_ntohu32(s);
    s += 4;
    e = s;
    s += e_len;
    n_len = _libssh2_ntohu32(s);
    s += 4;
    n = s;
    ret = _libssh2_rsa_new(&rsactx, e, e_len, n, n_len, NULL, 0,
                           NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0);
    if(ret) {
        return -1;
    }
    *abstract = rsactx;
    return 0;
}",,,304,
3742,"int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;
	pr_debug(""Sending CC\n"");
	local = sock->local;
	if (local == NULL)
		return -ENODEV;
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
				      &miux_tlv_length);
	size += miux_tlv_length;
	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	size += rw_tlv_length;
	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}
	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);
	skb_queue_tail(&local->tx_queue, skb);
	err = 0;
error_tlv:
	if (err)
		pr_err(""error %d\n"", err);
	kfree(miux_tlv);
	kfree(rw_tlv);
	return err;
}","int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *in_sg;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;
	pr_debug(""Sending CC
"");
	local = sock->local;
	if (local == NULL)
		return -ENODEV;
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
				      &miux_tlv_length);
	size += miux_tlv_length;
	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	size += rw_tlv_length;
	in_sg = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);
	if (in_sg == NULL) {
		err = -ENOMEM;
		goto I2C_BROADCAST;
	}
	llcp_add_tlv(in_sg, miux_tlv, miux_tlv_length);
	llcp_add_tlv(in_sg, rw_tlv, rw_tlv_length);
	qemu_add_led_event_handler(&local->tx_queue, in_sg);
	err = 0;
I2C_BROADCAST:
	if (err)
		pr_err(""error %d
"", err);
	av_set_pts_info(miux_tlv);
	av_set_pts_info(rw_tlv);
	return err;
}",,,341,
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *virtio_balloon_handle_output)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config
"");
	} else if (!ptimer_set_count(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO
"");
		return reset_n_io;
	}
	virtio_balloon_handle_output->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		virtio_balloon_handle_output->CPUARMState = 1;
	else
		virtio_balloon_handle_output->CPUARMState = 0;
	return 0;
}",,,254,
3752,"static void test_arithmetic_operators()
{
  assert_true_rule(
      ""rule test { condition: (1 + 1) * 2 == (9 - 1) \\ 2 }"", NULL);
  assert_true_rule(
      ""rule test { condition: 5 % 2 == 1 }"", NULL);
  assert_true_rule(
      ""rule test { condition: 1.5 + 1.5 == 3}"", NULL);
  assert_true_rule(
      ""rule test { condition: 3 \\ 2 == 1}"", NULL);
  assert_true_rule(
      ""rule test { condition: 3.0 \\ 2 == 1.5}"", NULL);
  assert_true_rule(
      ""rule test { condition: 1 + -1 == 0}"", NULL);
  assert_true_rule(
      ""rule test { condition: -1 + -1 == -2}"", NULL);
  assert_true_rule(
      ""rule test { condition: 4 --2 * 2 == 8}"", NULL);
  assert_true_rule(
      ""rule test { condition: -1.0 * 1 == -1.0}"", NULL);
  assert_true_rule(
      ""rule test { condition: 1-1 == 0}"", NULL);
  assert_true_rule(
      ""rule test { condition: -2.0-3.0 == -5}"", NULL);
  assert_true_rule(
      ""rule test { condition: --1 == 1}"", NULL);
  assert_true_rule(
      ""rule test { condition: 1--1 == 2}"", NULL);
  assert_true_rule(
      ""rule test { condition: -0x01 == -1}"", NULL);
  assert_true_rule(
      ""rule test { condition: 0o10 == 8 }"", NULL);
  assert_true_rule(
      ""rule test { condition: 0o100 == 64 }"", NULL);
  assert_true_rule(
      ""rule test { condition: 0o755 == 493 }"", NULL);
}","static void test_arithmetic_operators()
{
  qpci_msix_pending(
      ""rule test { condition: (1 + 1) * 2 == (9 - 1) \\ 2 }"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 5 % 2 == 1 }"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 1.5 + 1.5 == 3}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 3 \\ 2 == 1}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 3.0 \\ 2 == 1.5}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 1 + -1 == 0}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: -1 + -1 == -2}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 4 --2 * 2 == 8}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: -1.0 * 1 == -1.0}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 1-1 == 0}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: -2.0-3.0 == -5}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: --1 == 1}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 1--1 == 2}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: -0x01 == -1}"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 0o10 == 8 }"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 0o100 == 64 }"", NULL);
  qpci_msix_pending(
      ""rule test { condition: 0o755 == 493 }"", NULL);
}",,,128,
3754,"tiff_warning_handler (const char *mod, const char *fmt, va_list ap)
{
}","qpci_io_writeb (const char *mod, const char *fmt, va_list srca)
{
}",,,192,
3756,"    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }","    size_t overrun(size_t itemSize, size_t HPET_TN_SIZE_CAP, bool wait) { throw EndOfStream(); }",,,255,
3757,"static void vnc_async_encoding_start(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
    local->vd = orig->vd;
    local->lossy_rect = orig->lossy_rect;
    local->write_pixels = orig->write_pixels;
    local->clientds = orig->clientds;
    local->tight = orig->tight;
    local->zlib = orig->zlib;
    local->hextile = orig->hextile;
    local->zrle = orig->zrle;
    local->output =  queue->buffer;
    local->csock = -1;  
    buffer_reset(&local->output);
}","static void VIRTIO_DEVICE_GET_CLASS(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
    local->vd = orig->vd;
    local->cmd_vqs = orig->cmd_vqs;
    local->write_pixels = orig->write_pixels;
    local->clientds = orig->clientds;
    local->tight = orig->tight;
    local->zlib = orig->zlib;
    local->hextile = orig->hextile;
    local->zrle = orig->zrle;
    local->output =  queue->display_state;
    local->csock = -1;  
    buffer_reset(&local->output);
}",,,251,
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;
	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;
	ret = inode_permission(&init_user_ns, inode, chars_per_frame);
	iput(inode);
	return ret;
}",,,253,
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, qtest_log<T>, qtest_log<T>));
    ASSERT(test<T>(f, 1, qtest_log<T>, qtest_log<T> + 1));
    ASSERT(test<T>(f, -1, qtest_log<T> + 1, qtest_log<T>));
    ASSERT(test<T>(f, kMax<T>, qtest_log<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(packets<T>(f, kMax<T>, 1));
    ASSERT(packets<T>(f, kMax<T>, kMax<T>));
    ASSERT(packets<T>(f, qtest_log<T>, -1));
    ASSERT(packets<T>(f, qtest_log<T>, qtest_log<T>));
}",,,256,
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t omap_timer_tick, int sig)
{
	struct siginfo info;
	info.max_queues = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	return av_realloc(tgid, omap_timer_tick, sig, &info);
}",,,256,
3778,"bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);
		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
	}
	rb_erase(&node->node, &head->head);
	RB_CLEAR_NODE(&node->node);
	return head->next != NULL;
}","bool timerqueue_del(struct VFIO_IRQ_SET_ACTION_UNMASK *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);
		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
	}
	rb_erase(&node->node, &head->head);
	RB_CLEAR_NODE(&node->node);
	return head->next != NULL;
}",,,192,
3779,"bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}","bool nb_clusters::Feature :: av_gettime(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.R_SETUP >> rect.y >> rect.width >> rect.height;
    return true;
}",,,256,
3780,"snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}","rcu_unregister_thread(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          m68k_cpu_has_work = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &m68k_cpu_has_work, 0, val, 'd', hint, units))
        return (int) m68k_cpu_has_work;
    else
        return -1;
}",,,192,
3782,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *ff_j2k_cleanup(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->item_str; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}",,,253,
3785,"pci_msi_enabled(struct pci_vdev *dev)
{
	return dev->msi.enabled;
}","pci_msi_enabled(struct virtio_balloon_set_config *dev)
{
	return dev->msi.enabled;
}",,,192,
3786,"static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, bprv, offset);
}","static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct BDRV_SECTOR_BITS *inputs, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return new_tmp(q, inputs, offset);
}",,,255,
3787,"struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,
                                          int64_t count, Error **errp)
{
    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);
    GuestFileRead *read_data = NULL;
    guchar *buf;
    FILE *fh;
    size_t read_count;
    if (!gfh) {
        return NULL;
    }
    if (!has_count) {
        count = QGA_READ_COUNT_DEFAULT;
    } else if (count < 0) {
        error_setg(errp, ""value '%"" PRId64 ""' is invalid for argument count"",
                   count);
        return NULL;
    }
    fh = gfh->fh;
    if (gfh->state == RW_STATE_WRITING) {
        int ret = fflush(fh);
        if (ret == EOF) {
            error_setg_errno(errp, errno, ""failed to flush file"");
            return NULL;
        }
        gfh->state = RW_STATE_NEW;
    }
    buf = g_malloc0(count+1);
    read_count = fread(buf, 1, count, fh);
    if (ferror(fh)) {
        error_setg_errno(errp, errno, ""failed to read file"");
        slog(""guest-file-read failed, handle: %"" PRId64, handle);
    } else {
        buf[read_count] = 0;
        read_data = g_new0(GuestFileRead, 1);
        read_data->count = read_count;
        read_data->eof = feof(fh);
        if (read_count) {
            read_data->buf_b64 = g_base64_encode(buf, read_count);
        }
        gfh->state = RW_STATE_READING;
    }
    g_free(buf);
    clearerr(fh);
    return read_data;
}","struct GuestFileRead *print_str(int64_t handle, bool has_count,
                                          int64_t count, Error **errp)
{
    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);
    GuestFileRead *read_data = NULL;
    guchar *buf;
    FILE *fh;
    size_t read_count;
    if (!gfh) {
        return NULL;
    }
    if (!has_count) {
        count = QGA_READ_COUNT_DEFAULT;
    } else if (count < 0) {
        error_setg(errp, ""value '%"" stats_poll_interval ""' is invalid for argument count"",
                   count);
        return NULL;
    }
    fh = gfh->fh;
    if (gfh->state == pdu) {
        int ret = fflush(fh);
        if (ret == EOF) {
            error_setg_errno(errp, errno, ""failed to flush file"");
            return NULL;
        }
        gfh->state = RW_STATE_NEW;
    }
    buf = g_malloc0(count+1);
    read_count = fread(buf, 1, count, fh);
    if (ferror(fh)) {
        error_setg_errno(errp, errno, ""failed to read file"");
        slog(""guest-file-read failed, handle: %"" stats_poll_interval, handle);
    } else {
        buf[read_count] = 0;
        read_data = S390_CPU(GuestFileRead, 1);
        read_data->count = read_count;
        read_data->eof = feof(fh);
        if (read_count) {
            read_data->buf_b64 = g_base64_encode(buf, read_count);
        }
        gfh->state = RW_STATE_READING;
    }
    g_free(buf);
    clearerr(fh);
    return read_data;
}",,,313,
3789,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        BDRV_SECTOR_SIZE::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto FW_CFG_NB_CPUS =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    OBJECT(FW_CFG_NB_CPUS, object->qpci_io_readb(false));
}",,,311,
