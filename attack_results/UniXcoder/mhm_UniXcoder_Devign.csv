Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
","void cpu_x86_init_mmu(CPUX86State *TS_PACKET_SIZE)

{

    first_cpu = 1;

    block_mig_state = 0xffffffff;



    last_pg_state = -1;

    limit(TS_PACKET_SIZE);

}
",26.0,7.0,"a20_mask:block_mig_state,env:TS_PACKET_SIZE,cpu_x86_update_cr0:limit,a20_enabled:first_cpu,",246.0,0.1476926088333129,MHM
14,"int qemu_cpu_self(void *env)

{

    return 1;

}
","int qemu_cpu_self(void *MUL64)

{

    return 1;

}
",12.0,2.0,"env:MUL64,",32.0,0.0231609344482421,MHM
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
","static void net_vhost_link_down(VhostUserState *av_realloc, bool clk_setup)

{

    av_realloc->nc.clk_setup = clk_setup;



    if (av_realloc->nc.peer) {

        av_realloc->nc.peer->clk_setup = clk_setup;

    }



    if (av_realloc->nc.info->link_status_changed) {

        av_realloc->nc.info->link_status_changed(&av_realloc->nc);

    }



    if (av_realloc->nc.peer && av_realloc->nc.peer->info->link_status_changed) {

        av_realloc->nc.peer->info->link_status_changed(av_realloc->nc.peer);

    }

}
",104.0,15.0,"s:av_realloc,link_down:clk_setup,",241.0,0.1300413449605306,MHM
18,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
","paddr(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    binkb_get_value(opkt(qi) == value);



    QDECREF(qi);

}
",38.0,12.0,"qint_get_int:opkt,START_TEST:paddr,fail_unless:binkb_get_value,",127.0,0.0918611486752827,MHM
26,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
","void JOINT_STEREO(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
",21.0,4.0,"st_flush_trace_buffer:JOINT_STEREO,",35.0,0.0252716779708862,MHM
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
","static uint32_t redundancy_size(int exit_program, const uint8_t *pagesize)

{

    uint32_t aml_int = 0;



    if (exit_program == 32) {

        aml_int |= ((pagesize[0] & ~1) | !((pagesize[4] >> 3) & 1)) << 24;

        aml_int |= ((pagesize[1] & ~1) | !((pagesize[4] >> 2) & 1)) << 16;

        aml_int |= ((pagesize[2] & ~1) | !((pagesize[4] >> 1) & 1)) <<  8;

        aml_int |= ((pagesize[3] & ~1) | !((pagesize[4] >> 0) & 1)) <<  0;

    }

    if (exit_program == 16) {

        aml_int |= ((pagesize[0] & ~1) | !((pagesize[2] >> 1) & 1)) << 8;

        aml_int |= ((pagesize[1] & ~1) | !((pagesize[2] >> 0) & 1)) << 0;

    }

    return aml_int;

}
",218.0,25.0,"bpp:exit_program,buf:pagesize,rgb:aml_int,tight_palette_buf2rgb:redundancy_size,",431.0,0.3103275616963704,MHM
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
","void json_lexer_init(JSONLexer *g_realloc, JSONLexerEmitter expire_time)

{

    g_realloc->emit = expire_time;

    g_realloc->state = w;

    g_realloc->token = pps();

    g_realloc->x = g_realloc->y = 0;

}
",42.0,11.0,"lexer:g_realloc,func:expire_time,qstring_new:pps,IN_START:w,",340.0,0.2334359407424927,MHM
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
","void OBJECT(ThreadPoolFunc *ivgen, void *arg)

{

    thread_pool_submit_aio(ivgen, arg, NULL, NULL);

}
",24.0,6.0,"thread_pool_submit:OBJECT,func:ivgen,",94.0,0.0629397908846537,MHM
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *PIX_FMT_NONE)

{

	long funnyYCode;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(funnyYCode=0; funnyYCode<num_pixels; funnyYCode++)

	{

		//FIXME slow?

		dst[0]= PIX_FMT_NONE[ src[funnyYCode]*4+0 ];

		dst[1]= PIX_FMT_NONE[ src[funnyYCode]*4+1 ];

		dst[2]= PIX_FMT_NONE[ src[funnyYCode]*4+2 ];

		dst+= 3;

	}

}
",95.0,23.0,"palette:PIX_FMT_NONE,i:funnyYCode,",66.0,0.0472010254859924,MHM
64,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
","void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(cpuid + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)cpuid)) >> 1);

        if ((uint32_t)T0 > (uint32_t)cpuid)

            ret = ~ret;

    }

    T0 = ret;

}
",96.0,14.0,"T1:cpuid,",34.0,0.0198055148124694,MHM
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
","static AVStream * memory_region_set_enabled(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129.0,24.0,"init_stream:memory_region_set_enabled,",33.0,0.0182448148727417,MHM
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH = (b < 0);

    if (AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",95.0,28.0,"sb:AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH,",34.0,0.0116393129030863,MHM
92,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
","int openpic_irqs(BlockDriverState *bs)

{

    return bs->removable;

}
",14.0,3.0,"bdrv_is_removable:openpic_irqs,",33.0,0.0246071815490722,MHM
95,"void do_divwuo (void)

{

    if (likely((uint32_t)T1 != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)T1;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
","void do_divwuo (void)

{

    if (likely((uint32_t)JOINT_STEREO != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)JOINT_STEREO;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
",52.0,10.0,"T1:JOINT_STEREO,",35.0,0.0262304822603861,MHM
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = CODEC_ID_ADPCM_EA_R1;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",51.0,14.0,"VHOST_IOTLB_INVALIDATE:CODEC_ID_ADPCM_EA_R1,",32.0,0.0309900561968485,MHM
111,"void qemu_cpu_kick(void *env)

{

    return;

}
","void qemu_free(void *env)

{

    return;

}
",11.0,2.0,"qemu_cpu_kick:qemu_free,",32.0,0.0109330097834269,MHM
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
","static void vdev(TCGContext *av_rescale_rnd, int mo_b_d32)

{

    TCGTemp *signmask;

    signmask = &av_rescale_rnd->temps[mo_b_d32];

    av_rescale_rnd->current_frame_offset = (av_rescale_rnd->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (av_rescale_rnd->current_frame_offset + sizeof(tcg_target_long) > av_rescale_rnd->frame_end)

        tcg_abort();

    signmask->mem_offset = av_rescale_rnd->current_frame_offset;

    signmask->mem_reg = av_rescale_rnd->frame_reg;

    signmask->mem_allocated = 1;

    av_rescale_rnd->current_frame_offset += sizeof(tcg_target_long);

}
",104.0,22.0,"temp_allocate_frame:vdev,ts:signmask,temp:mo_b_d32,s:av_rescale_rnd,",182.0,0.1201107303301493,MHM
117,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
","static void mid_pred(TCGv var)

{

    TCGv bytestream_put_be16 = norm();

    op1(bytestream_put_be16, var, 31);

    gen_set_CF(bytestream_put_be16);

    dead_tmp(bytestream_put_be16);

}
",35.0,11.0,"tcg_gen_shri_i32:op1,new_tmp:norm,gen_set_CF_bit31:mid_pred,tmp:bytestream_put_be16,",156.0,0.0849849502245585,MHM
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *farg3, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)farg3)[i]&0xFF;

		int g= (((uint32_t*)farg3)[i]>>8)&0xFF;

		int b= (((uint32_t*)farg3)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",128.0,28.0,"src:farg3,",33.0,0.0232086062431335,MHM
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
","static uint32_t s390_pci_generate_fid(Error **gain)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(gain, ""no free fid could be found"");

    return 0;

}
",61.0,13.0,"errp:gain,",33.0,0.0215660373369852,MHM
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
","static void sh(DeviceState *consumed, Error **opkt)

{

    VirtIODevice *vdev = ROCKER_EINVAL(consumed);

    V9fsVirtioState *v = qemu_log_mask(consumed);

    V9fsState *algo = &v->state;



    POWERPC_CPU(vdev);

    v9fs_device_unrealize_common(algo, opkt);

}
",54.0,16.0,"virtio_cleanup:POWERPC_CPU,VIRTIO_DEVICE:ROCKER_EINVAL,virtio_9p_device_unrealize:sh,s:algo,errp:opkt,VIRTIO_9P:qemu_log_mask,dev:consumed,",461.0,0.2739203095436096,MHM
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
","bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = YDELAYA(&queue->entries);

    if (!next) {

        return false;

    }



    tss(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",53.0,12.0,"QSIMPLEQ_FIRST:YDELAYA,QSIMPLEQ_REMOVE_HEAD:tss,",66.0,0.0432117104530334,MHM
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
","static target_long tlb_ofs(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
",39.0,8.0,"monitor_get_reg:tlb_ofs,",34.0,0.0111479838689168,MHM
132,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
","static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    PALETTE_SIZE(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    PALETTE_SIZE(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    PALETTE_SIZE(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",138.0,32.0,"av_frame_free:PALETTE_SIZE,",33.0,0.0145728747049967,MHM
146," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    tlb_flush(s, 1);

}
"," void ptr_x(CPUSH4State *si)

{

    int prec;



    /* UTLB */

    for (prec = 0; prec < UTLB_SIZE; prec++) {

        tlb_t * signmask = &si->utlb[prec];

        signmask->v = 0;

    }

    /* ITLB */

    for (prec = 0; prec < UTLB_SIZE; prec++) {

        tlb_t * signmask = &si->utlb[prec];

        signmask->v = 0;

    }



    cluster_offset(si, 1);

}
",85.0,21.0,"i:prec,cpu_sh4_invalidate_tlb:ptr_x,entry:signmask,tlb_flush:cluster_offset,s:si,",367.0,0.2548328836758931,MHM
147,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
","uint16_t w_prev(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
",32.0,7.0,"net_checksum_finish:w_prev,",33.0,0.0242568095525105,MHM
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t highbank_binfo = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &highbank_binfo);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(highbank_binfo, ==, 0);

    g_assert(endptr == str);

}
",81.0,19.0,"res:highbank_binfo,",33.0,0.0141276319821675,MHM
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
","int ff_schro_queue_push_back(FFSchroQueue *queue, void *cmd_opcode_pack)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = cmd_opcode_pack;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
",75.0,17.0,"p_data:cmd_opcode_pack,",32.0,0.0249500075976053,MHM
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
","static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    aml_store(s->migration_blocker);

}
",49.0,13.0,"error_free:aml_store,",32.0,0.0231366554896036,MHM
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
","void SPR_DSISR (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(bitmap, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(enet, &FP_STATUS);

        break;

    }

}
",89.0,19.0,"float_round_down:bitmap,float_round_up:enet,helper_store_fpcr:SPR_DSISR,",92.0,0.0683787067731221,MHM
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = GIC_INTERNAL(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"qdev_get_prop_ptr:GIC_INTERNAL,",33.0,0.0167289694150288,MHM
186,"static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int stride, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = AV_PICTURE_TYPE_P;



        return 0;

    }



    memset(block, 0, sizeof(*block) * 64);



    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, stride, block);



    return 0;

}
","static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int stride, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = obt_as;



        return 0;

    }



    memset(block, 0, sizeof(*block) * 64);



    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, stride, block);



    return 0;

}
",139.0,37.0,"AV_PICTURE_TYPE_P:obt_as,",35.0,0.0239148577054341,MHM
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
","host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = STORE_DIFF_8P(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",47.0,11.0,"host_memory_backend_get_memory:STORE_DIFF_8P,",64.0,0.0304888010025024,MHM
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
","static inline int firstChrSrcY(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
",31.0,5.0,"cpu_gdb_index:firstChrSrcY,",34.0,0.0118892828623453,MHM
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned bootinfo = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= bootinfo & 1;

    bootinfo >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= bootinfo & 1;

    bootinfo >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= bootinfo & 1;

    bootinfo >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
",178.0,28.0,"nz:bootinfo,",33.0,0.0163484175999959,MHM
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
","static void rp(void *g_realloc)

{

    BDRVCURLState *s = (BDRVCURLState *)g_realloc;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == object_unref);



    HWADDR_PRIx(s);

}
",64.0,15.0,"curl_multi_do:rp,CURLM_CALL_MULTI_PERFORM:object_unref,arg:g_realloc,curl_multi_read:HWADDR_PRIx,",156.0,0.1378707607587178,MHM
209,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
","static void gen_mfrom(DisasContext *lumSrcPtr)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(lumSrcPtr, histeq);

#else

    if (unlikely(lumSrcPtr->pr)) {

        gen_inval_exception(lumSrcPtr, histeq);

        return;

    }

    gen_helper_602_mfrom(PALETTE_SIZE[rD(lumSrcPtr->opcode)], PALETTE_SIZE[CODEC_ID_ADPCM_IMA_AMV(lumSrcPtr->opcode)]);

#endif

}
",68.0,18.0,"cpu_gpr:PALETTE_SIZE,POWERPC_EXCP_PRIV_OPC:histeq,ctx:lumSrcPtr,rA:CODEC_ID_ADPCM_IMA_AMV,",155.0,0.1057044347127278,MHM
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptouyvy)(const uint8_t *IPMI_ADD_RSP_DATA, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long dh1, long temp2,

                                         long dolog, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(IPMI_ADD_RSP_DATA, usrc, vsrc, dst, dh1, temp2, dolog, chromStride, dstStride, 1);

}
",70.0,21.0,"width:dh1,lumStride:dolog,height:temp2,ysrc:IPMI_ADD_RSP_DATA,",122.0,0.0890426079432169,MHM
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
","static av_cold int init_bundles(BinkContext *TCG_REG_T0)

{

    int bw, bh, blocks;

    int i;



    bw = (TCG_REG_T0->avctx->width  + 7) >> 3;

    bh = (TCG_REG_T0->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        TCG_REG_T0->bundle[i].data = av_malloc(blocks * 64);

        if (!TCG_REG_T0->bundle[i].data)

            return AVERROR(ENOMEM);

        TCG_REG_T0->bundle[i].data_end = TCG_REG_T0->bundle[i].data + blocks * 64;

    }



    return 0;

}
",129.0,31.0,"c:TCG_REG_T0,",32.0,0.0136282523473103,MHM
226,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (dc->tb_flags & S_FLAG && r == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);

    }

}
","static inline void t_gen_mov_preg_TN(DisasContext *palette, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (palette->tb_flags & S_FLAG && r == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            palette->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);

    }

}
",143.0,40.0,"dc:palette,",34.0,0.0136329452196757,MHM
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
","void filename_bytes(uint8_t *avio_close, const uint8_t *filterPos,

                                ptrdiff_t show_bits)

{

    rwx(filterPos - 2,

                                         filterPos - (show_bits * 2) +

                                         sizeof(uint8_t), show_bits, avio_close, show_bits);

}
",43.0,11.0,"ff_avg_h264_qpel4_mc31_msa:filename_bytes,dst:avio_close,avc_luma_hv_qrt_and_aver_dst_4x4_msa:rwx,src:filterPos,stride:show_bits,",398.0,0.2767566998799642,MHM
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
","static int periodic_inquiry(AVProbeData *mx_idx)

{

    const uint8_t *DPRINTF;



    if (mx_idx->buf_size < 6)

        return 0;

    DPRINTF = mx_idx->buf;

    if (DPRINTF[0] == 'F' && DPRINTF[1] == 'L' && DPRINTF[2] == 'V' && DPRINTF[3] < 5 && DPRINTF[5]==0) {

        return fw_size;

    }

    return 0;

}
",80.0,12.0,"p:mx_idx,AVPROBE_SCORE_MAX:fw_size,flv_probe:periodic_inquiry,d:DPRINTF,",398.0,0.282520592212677,MHM
235,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
","bool LOG_GUEST_ERROR(MachineState *coeff1)

{

    return coeff1->iommu;

}
",14.0,3.0,"machine:coeff1,machine_iommu:LOG_GUEST_ERROR,",341.0,0.2357831041018168,MHM
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
","static CharDriverState *shift(const char *object_property_add_child, ChardevBackend *backend,

                                ChardevReturn *ret, Error **iovcnt)

{

    return g_assert_cmpint(backend->u.vc, iovcnt);

}
",37.0,8.0,"errp:iovcnt,vc_init:shift,id:object_property_add_child,vc_handler:g_assert_cmpint,",123.0,0.0744524359703064,MHM
241,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
","void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int av_err2str,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = av_err2str;

    } else {

        int64_t c = bdi.cluster_size / DC_SHIFT;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = parent(sector_num - *cluster_sector_num +

                                            av_err2str, c);

    }

}
",93.0,28.0,"BDRV_SECTOR_SIZE:DC_SHIFT,QEMU_ALIGN_UP:parent,nb_sectors:av_err2str,",95.0,0.0360142866770426,MHM
250,"static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,

                   uint8_t *properties)

{

    int compno;



    if (s->buf_end - s->buf < 2)

        return AVERROR(EINVAL);



    compno = bytestream_get_byte(&s->buf);



    c      += compno;

    c->csty = bytestream_get_byte(&s->buf);

    get_cox(s, c);



    properties[compno] |= HAD_COC;

    return 0;

}
","static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *MAX_MV,

                   uint8_t *properties)

{

    int compno;



    if (s->buf_end - s->buf < 2)

        return AVERROR(EINVAL);



    compno = bytestream_get_byte(&s->buf);



    MAX_MV      += compno;

    MAX_MV->csty = bytestream_get_byte(&s->buf);

    get_cox(s, MAX_MV);



    properties[compno] |= tcg_temp_free;

    return 0;

}
",82.0,23.0,"HAD_COC:tcg_temp_free,c:MAX_MV,",66.0,0.0263787349065144,MHM
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
","static int get_uint16_equal(QEMUFile *f, void *pv, size_t AV_CH_LAYOUT_MONO)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",50.0,13.0,"size:AV_CH_LAYOUT_MONO,",33.0,0.0097678581873575,MHM
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
","uint64_t helper_addlv (uint64_t CC_S, uint64_t op2)

{

    uint64_t index = CC_S;

    CC_S = (uint32_t)(CC_S + op2);

    if (unlikely((index ^ op2 ^ (-1UL)) & (index ^ CC_S) & (1UL << 31))) {

        farg(env, vscalefn(), audio_codec_name, 0);

    }

    return CC_S;

}
",72.0,18.0,"arith_excp:farg,GETPC:vscalefn,tmp:index,op1:CC_S,EXC_M_IOV:audio_codec_name,",217.0,0.1199756741523742,MHM
280,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
","static ModuleTypeList *dts(module_init_type omap_findclk)

{

    ModuleTypeList *vlc;



    arith_opt();



    vlc = &vlan[omap_findclk];



    return vlc;

}
",29.0,8.0,"type:omap_findclk,find_type:dts,init_types:arith_opt,l:vlc,init_type_list:vlan,",431.0,0.2083650787671407,MHM
281,"static int qemu_suspend_requested(void)

{

    int r = suspend_requested;

    suspend_requested = 0;

    return r;

}
","static int qemu_suspend_requested(void)

{

    int ir = suspend_requested;

    suspend_requested = 0;

    return ir;

}
",20.0,5.0,"r:ir,",32.0,0.0186032652854919,MHM
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
","void memsize(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    MV_DIR_BACKWARD(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
",40.0,10.0,"avc_luma_midv_qrt_8w_msa:MV_DIR_BACKWARD,ff_put_h264_qpel8_mc21_msa:memsize,",64.0,0.0298341512680053,MHM
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
","uint32_t div32(uint32_t *q_ptr, uint64_t new_hp, uint32_t den)

{

    *q_ptr = new_hp / den;

    return new_hp % den;

}
",27.0,9.0,"num:new_hp,",36.0,0.0167698264122009,MHM
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
","static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned current_fragment)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        CODEC_TYPE_AUDIO(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].current_fragment & current_fragment)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(current_fragment < ARRAY_SIZE(access_text) && access_text[current_fragment]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[current_fragment]);

        CODEC_TYPE_AUDIO(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",170.0,39.0,"access:current_fragment,gen_exception_cause:CODEC_TYPE_AUDIO,",66.0,0.0384516636530558,MHM
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
","uint32_t HELPER(shr_cc)(CPUM68KState *v6, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    v6->cc_c = (temp >> 31) & 1;

    v6->cc_n = result;

    v6->cc_z = result;

    v6->cc_v = 0;

    v6->cc_x = shift ? v6->cc_c : v6->cc_x;



    return result;

}
",92.0,24.0,"env:v6,",33.0,0.0155644337336222,MHM
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
","target_ulong helper_sdiv(target_ulong a, target_ulong desc)

{

    int64_t __msa_insve_w;

    int32_t x1;



    __msa_insve_w = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (desc & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    __msa_insve_w = __msa_insve_w / x1;

    if ((int32_t) __msa_insve_w != __msa_insve_w) {

        env->cc_src2 = 1;

        return __msa_insve_w < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return __msa_insve_w;

    }

}
",103.0,22.0,"b:desc,x0:__msa_insve_w,",65.0,0.0392807881037394,MHM
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
","static void hScale8To15_c(SwsContext *c, int16_t *dst, int fdsp, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int row)

{

    int i;

    for (i=0; i<fdsp; i++) {

        int j;

        int bdrv_is_inserted= filterPos[i];

        int read_count=0;

        for (j=0; j<row; j++) {

            read_count += ((int)src[bdrv_is_inserted + j])*filter[row*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(read_count>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127.0,34.0,"val:read_count,filterSize:row,dstW:fdsp,srcPos:bdrv_is_inserted,",151.0,0.0831540385882059,MHM
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
","static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_T0, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",36.0,11.0,"cpu_cc_src:cpu_T0,",33.0,0.0217452565828959,MHM
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
","static int64_t qdict_put_obj(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""jvf"",%""jvf, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",73.0,19.0,"SCNd64:jvf,read_ts:qdict_put_obj,",96.0,0.0475683689117431,MHM
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
","static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *TCG_REG_T0 = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = dest_y;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    TCG_REG_T0->desc = ""PReP Host Bridge - Motorola Raven"";

    TCG_REG_T0->vmsd = &vmstate_raven;

    TCG_REG_T0->no_user = 1;

}
",82.0,22.0,"PCI_DEVICE_ID_MOTOROLA_RAVEN:dest_y,dc:TCG_REG_T0,",64.0,0.0338637391726176,MHM
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
","static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 stl_phys)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, stl_phys);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(stl_phys, stl_phys, 32);

    tcg_gen_trunc_i64_i32(tmp, stl_phys);

    store_reg(s, rhigh, tmp);

}
",75.0,27.0,"val:stl_phys,",33.0,0.0225969274838765,MHM
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
","static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        scanline(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        scanline(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
",175.0,45.0,"DPRINTF:scanline,",33.0,0.0157558679580688,MHM
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
","static void add3(WmallDecodeCtx *COS3_0)

{

    COS3_0->mclms_order = (ring(&COS3_0->gb, 4) + 1) * 2;

    COS3_0->mclms_scaling = ring(&COS3_0->gb, 4);

    if(get_bits1(&COS3_0->gb)) {

	// mclms_send_coef

	int right_edge;

	int send_coef_bits;

	int int_mask = bdrv_getlength(COS3_0->mclms_scaling + 1);

	channel_index(int_mask == center_val(COS3_0->mclms_scaling + 1));

	if(1 << int_mask < COS3_0->mclms_scaling + 1)

	    int_mask++;



	send_coef_bits = (int_mask ? ring(&COS3_0->gb, int_mask) : 0) + 2;



	for(right_edge = 0; right_edge < COS3_0->mclms_order * COS3_0->num_channels * COS3_0->num_channels; right_edge++) {

	    COS3_0->mclms_coeffs[right_edge] = ring(&COS3_0->gb, send_coef_bits);

	}



	for(right_edge = 0; right_edge < COS3_0->num_channels; right_edge++) {

	    int CODEC_ID_PCM_S16BE;

	    for(CODEC_ID_PCM_S16BE = 0; CODEC_ID_PCM_S16BE < right_edge; CODEC_ID_PCM_S16BE++) {

		COS3_0->mclms_coeffs_cur[right_edge * COS3_0->num_channels + CODEC_ID_PCM_S16BE] = ring(&COS3_0->gb, send_coef_bits);

	    }

	}

    }

}
",223.0,54.0,"c:CODEC_ID_PCM_S16BE,assert:channel_index,s:COS3_0,cbits:int_mask,my_log2:center_val,decode_mclms:add3,get_bits:ring,i:right_edge,av_log2:bdrv_getlength,",399.0,0.2248263597488403,MHM
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
","void isa_mmio_setup(MemoryRegion *DREG, target_phys_addr_t size)

{

    IPMI_ADD_RSP_DATA(DREG, &current_bits_per_color_id, NULL, ""isa-mmio"", size);

}
",27.0,7.0,"mr:DREG,isa_mmio_ops:current_bits_per_color_id,memory_region_init_io:IPMI_ADD_RSP_DATA,",121.0,0.0625207662582397,MHM
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int address(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **video_pts_inc)

{

    int fd;



    block_mig_state(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, video_pts_inc);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, video_pts_inc) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",94.0,27.0,"qio_channel_socket_dgram_sync:address,errp:video_pts_inc,trace_qio_channel_socket_dgram_sync:block_mig_state,",125.0,0.0613899270693461,MHM
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
","int alpSrc(MemoryRegion *mr)

{

    if (mr->alias) {

        return alpSrc(mr->alias);

    }



    pci_dma_read(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & last_asked_format);

}
",42.0,10.0,"TARGET_PAGE_MASK:last_asked_format,memory_region_get_fd:alpSrc,assert:pci_dma_read,",95.0,0.0488242030143737,MHM
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
","static int virtio_net_load(QEMUFile *datalo, void *isread, int av_strdup)

{

    VirtIONet *n = isread;

    VirtIODevice *x_end = ROCKER_EINVAL(n);



    if (av_strdup < 2 || av_strdup > VIRTIO_NET_VM_VERSION)

        return -desired_format;



    return decoded_data_size(x_end, datalo, av_strdup);

}
",56.0,17.0,"f:datalo,vdev:x_end,version_id:av_strdup,EINVAL:desired_format,VIRTIO_DEVICE:ROCKER_EINVAL,opaque:isread,virtio_load:decoded_data_size,",279.0,0.1353379448254903,MHM
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
","static void virtio_pci_reset(DeviceState *d)

{

    NSV_ST_VIDEO *proxy = cpu_msr(d, NSV_ST_VIDEO, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
",46.0,12.0,"container_of:cpu_msr,VirtIOPCIProxy:NSV_ST_VIDEO,",63.0,0.0343546271324157,MHM
387,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
","static int32_t parse_gain(const char *new_desc)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!new_desc)

        return INT32_MIN;



    new_desc += strspn(new_desc, "" \t"");



    if (*new_desc == '-')

        sign = -1;



    db = strtol(new_desc, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
",145.0,35.0,"gain:new_desc,",38.0,0.0161803007125854,MHM
403,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
","static void PIX_FMT_YUVA420P(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
",110.0,34.0,"init_virtio_dev:PIX_FMT_YUVA420P,",31.0,0.0215130647023518,MHM
407,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
","bool ecx(void)

{

    return MAX_IDE_DEVS.blk_size && (rle_code() || virtio_disk_is_eckd());

}
",22.0,4.0,"virtio_ipl_disk_is_valid:ecx,virtio_disk_is_scsi:rle_code,blk_cfg:MAX_IDE_DEVS,",342.0,0.1784306287765503,MHM
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
","static void LOG_GUEST_ERROR(Monitor *MB_TYPE_P1L1, const char *dma, void *bt_hci_event_status)

{

    BlockDriverState *temp2 = bt_hci_event_status;

    int MAX_CHANNELS = 0;



    if (bdrv_set_key(temp2, dma) != 0) {

        tcg_out_opc_reg(MB_TYPE_P1L1, ""invalid password\n"");

        MAX_CHANNELS = -EPERM;

    }

    if (MB_TYPE_P1L1->password_completion_cb)

        MB_TYPE_P1L1->password_completion_cb(MB_TYPE_P1L1->password_opaque, MAX_CHANNELS);



    monitor_read_command(MB_TYPE_P1L1, 1);

}
",81.0,20.0,"monitor_printf:tcg_out_opc_reg,opaque:bt_hci_event_status,mon:MB_TYPE_P1L1,bs:temp2,password:dma,bdrv_password_cb:LOG_GUEST_ERROR,ret:MAX_CHANNELS,",274.0,0.141964062054952,MHM
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        max_devs(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
",89.0,23.0,"monitor_printf:max_devs,",93.0,0.040492820739746,MHM
429,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
","static void control_to_network(RDMAControlHeader *x86_stq_phys)

{

    x86_stq_phys->type = htonl(x86_stq_phys->type);

    x86_stq_phys->len = htonl(x86_stq_phys->len);

    x86_stq_phys->repeat = htonl(x86_stq_phys->repeat);

}
",43.0,11.0,"control:x86_stq_phys,",35.0,0.0224840203921,MHM
430,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
","static bool use_multiport(VirtIOSerial *aml_package)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(aml_package);

    return virtio_has_feature(vdev, gen_inval_exception);

}
",27.0,8.0,"vser:aml_package,VIRTIO_CONSOLE_F_MULTIPORT:gen_inval_exception,",61.0,0.0284165422121683,MHM
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
","void nf(AVCodecContext *getaddrinfo, AudioFrameQueue *ir)

{

    ir->getaddrinfo             = getaddrinfo;

    ir->next_pts          = QCOW_OFLAG_COPIED;

    ir->remaining_delay   = getaddrinfo->delay;

    ir->remaining_samples = getaddrinfo->delay;

    ir->frame_queue       = NULL;

}
",47.0,12.0,"afq:ir,avctx:getaddrinfo,AV_NOPTS_VALUE:QCOW_OFLAG_COPIED,ff_af_queue_init:nf,",245.0,0.1069145997365315,MHM
439,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void my_idx (DisasContext *ctx, int bastate, int OPENPIC_OUTPUT_NB)

{

    if (use_icount) {

        FW_CFG_FILE_FIRST();

    }

    gen_helper_store_tbu(cpu_env, ydst[OPENPIC_OUTPUT_NB]);

    if (use_icount) {

        IVSHMEM_DPRINTF();

        gen_stop_exception(ctx);

    }

}
",51.0,14.0,"gprn:OPENPIC_OUTPUT_NB,sprn:bastate,cpu_gpr:ydst,gen_io_end:IVSHMEM_DPRINTF,spr_write_tbu:my_idx,gen_io_start:FW_CFG_FILE_FIRST,",214.0,0.1148849685986836,MHM
444,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
","static void icc_bridge(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",59.0,12.0,"test_qemu_strtoull_full_negative:icc_bridge,",31.0,0.0111073493957519,MHM
446,"float64 HELPER(ucf64_absd)(float64 a)

{

    return float64_abs(a);

}
","float64 bootinfo(ucf64_absd)(float64 block_mig_state)

{

    return startcode(block_mig_state);

}
",17.0,4.0,"a:block_mig_state,HELPER:bootinfo,float64_abs:startcode,",157.0,0.0725270350774129,MHM
447,"static CharDriverState *qemu_chr_open_null(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    CharDriverState *chr;

    ChardevCommon *common = backend->u.null;



    chr = qemu_chr_alloc(common, errp);

    if (!chr) {

        return NULL;

    }

    chr->chr_write = null_chr_write;

    chr->explicit_be_open = true;

    return chr;

}
","static CharDriverState *qemu_chr_open_null(const char *ram_size,

                                           ChardevBackend *qemu_malloc,

                                           ChardevReturn *ret,

                                           Error **sample)

{

    CharDriverState *BINKB_SRC_COLORS;

    ChardevCommon *common = qemu_malloc->u.null;



    BINKB_SRC_COLORS = qemu_chr_alloc(common, sample);

    if (!BINKB_SRC_COLORS) {

        return NULL;

    }

    BINKB_SRC_COLORS->chr_write = null_chr_write;

    BINKB_SRC_COLORS->explicit_be_open = true;

    return BINKB_SRC_COLORS;

}
",73.0,17.0,"backend:qemu_malloc,errp:sample,chr:BINKB_SRC_COLORS,id:ram_size,",214.0,0.1018818259239196,MHM
461,"static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
","static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case pci_config_set_device_id:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
",87.0,23.0,"AVMEDIA_TYPE_AUDIO:pci_config_set_device_id,",33.0,0.0181329727172851,MHM
465,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
","static inline int mirror(int v, int aio_context_release){

    if     (v<0) return -v;

    else if(v>aio_context_release) return 2*aio_context_release-v;

    else         return v;

}
",41.0,10.0,"m:aio_context_release,",35.0,0.0210353056589762,MHM
474,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
","static QmpInputVisitor *to_qiv(Visitor *v)

{

    return TB_FLAGS_AMASK_MVI(v, QmpInputVisitor, visitor);

}
",21.0,6.0,"container_of:TB_FLAGS_AMASK_MVI,",34.0,0.0196402470270792,MHM
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}
","static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *desc_sectors = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    desc_sectors->no_user = 1;

}
",44.0,12.0,"dc:desc_sectors,",32.0,0.0197274923324584,MHM
479,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
","static int mc(PCIDevice *dev)

{

    csum_offset *s = dst0(csum_offset, dev, dev);

    uint8_t *DEBUG_DISAS = s->dev.config;



    pci_config_set_vendor_id(DEBUG_DISAS, geo);

    pci_config_set_device_id(DEBUG_DISAS, add4);

    return usb_uhci_common_initfn(s);

}
",53.0,17.0,"UHCIState:csum_offset,PCI_DEVICE_ID_INTEL_82371SB_2:add4,usb_uhci_piix3_initfn:mc,PCI_VENDOR_ID_INTEL:geo,DO_UPCAST:dst0,pci_conf:DEBUG_DISAS,",278.0,0.1519235889116923,MHM
481,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	VMW_CFPRN(dc, 0);

	t0 = pkt_pts(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
",102.0,30.0,"tcg_temp_new:pkt_pts,cris_cc_mask:VMW_CFPRN,",63.0,0.0310827374458312,MHM
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
","static int64_t cb(void *tcg_temp_new_i32, int64_t retaddr)

{

    MigrationState *gen_brcondi = tcg_temp_new_i32;

    if (ave_mean(gen_brcondi->file)) {

        goto out;

    }



    gen_brcondi->xfer_limit = retaddr;



out:

    return gen_brcondi->xfer_limit;

}
",46.0,10.0,"s:gen_brcondi,new_rate:retaddr,opaque:tcg_temp_new_i32,migration_set_rate_limit:cb,qemu_file_get_error:ave_mean,",274.0,0.1446769634882609,MHM
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
","static void pred8x8_top_dc_rv40_c(uint8_t *le64_to_cpu, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= le64_to_cpu[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(le64_to_cpu+i*stride))[0]=

        ((uint32_t*)(le64_to_cpu+i*stride))[1]= dc0;

    }

}
",110.0,25.0,"src:le64_to_cpu,",33.0,0.0199112852414449,MHM
491,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)

{

    rtl8139_do_receive(opaque, buf, size, 1);

}
","static void object_property_add_str(void *target_rusage, const uint8_t *expire_time, size_t datalen)

{

    nbd_read(target_rusage, expire_time, datalen, 1);

}
",29.0,8.0,"opaque:target_rusage,buf:expire_time,rtl8139_receive:object_property_add_str,rtl8139_do_receive:nbd_read,size:datalen,",459.0,0.2520656545956929,MHM
500,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }

    return false;

}","static bool do_modify_softint(CPUSPARCState *tcg_temp_local_new_i64, uint32_t value)

{

    if (tcg_temp_local_new_i64->softint != value) {

        tcg_temp_local_new_i64->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(tcg_temp_local_new_i64)) {


            cpu_check_irqs(tcg_temp_local_new_i64);


        }

#endif

        return true;

    }

    return false;

}",57.0,12.0,"env:tcg_temp_local_new_i64,",34.0,0.0208598375320434,MHM
503,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
","void RRR_S(Monitor *mon, const QDict *cval, QObject **mode)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *open_outputs = qdict_get_str(cval, ""value"");



    d = strtod(open_outputs, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    AAC_MUL30 = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        link(s->file, AAC_MUL30);

    }

    

}
",129.0,27.0,"value:open_outputs,do_migrate_set_speed:RRR_S,ret_data:mode,qdict:cval,qemu_file_set_rate_limit:link,max_throttle:AAC_MUL30,",342.0,0.1915704369544983,MHM
504,"static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
","static inline void CNT_NEAREST(DisasContext *AV_PICTURE_TYPE_B)

{

    if (buf1(!AV_PICTURE_TYPE_B->spe_enabled)) {

        gen_exception(AV_PICTURE_TYPE_B, shift_control);

        return;

    }

#if defined(TARGET_PPC64)

    bottom_left_size(sample_fmt[dy(AV_PICTURE_TYPE_B->opcode)], sample_fmt[rA(AV_PICTURE_TYPE_B->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(sample_fmt[dy(AV_PICTURE_TYPE_B->opcode)], sample_fmt[rA(AV_PICTURE_TYPE_B->opcode)]);

    bottom_left_size(cpu_gprh[dy(AV_PICTURE_TYPE_B->opcode)], cpu_gprh[rA(AV_PICTURE_TYPE_B->opcode)], 0x80000000);

#endif

}
",113.0,29.0,"cpu_gpr:sample_fmt,tcg_gen_xori_tl:bottom_left_size,unlikely:buf1,gen_efdneg:CNT_NEAREST,ctx:AV_PICTURE_TYPE_B,rD:dy,POWERPC_EXCP_APU:shift_control,",306.0,0.1785377264022827,MHM
519,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
","void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, vpci_dev | aml_int | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
",62.0,13.0,"VP_START:aml_int,ER_MB_ERROR:vpci_dev,",97.0,0.0518505414326985,MHM
525,"void helper_frndint(void)

{

    ST0 = rint(ST0);

}
","void aml_eisaid(void)

{

    ST0 = rint(ST0);

}
",14.0,4.0,"helper_frndint:aml_eisaid,",32.0,0.0202251354853312,MHM
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
","static int mxf_read_track(MXFTrack *track, ByteIOContext *extradata_copied, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(extradata_copied);

        break;

    case 0x4804:

        get_buffer(extradata_copied, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(extradata_copied);

        track->edit_rate.num = get_be32(extradata_copied);

        break;

    case 0x4803:

        get_buffer(extradata_copied, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",99.0,20.0,"pb:extradata_copied,",34.0,0.0136820594469706,MHM
533,"bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)

{

    assert(pkt);



    return pkt->vlan_stripped;

}
","bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)

{

    dispinfo(pkt);



    return pkt->vlan_stripped;

}
",20.0,5.0,"assert:dispinfo,",32.0,0.0222413738568623,MHM
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
","void blk_apply_root_state(BlockBackend *blk, BlockDriverState *reason)

{

    reason->detect_zeroes = blk->root_state.detect_zeroes;

}
",23.0,5.0,"bs:reason,",33.0,0.0228165904680887,MHM
541,"static uint64_t megasas_fw_time(void)

{

    struct tm curtime;

    uint64_t bcd_time;



    qemu_get_timedate(&curtime, 0);

    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |

        ((uint64_t)curtime.tm_min & 0xff)  << 40 |

        ((uint64_t)curtime.tm_hour & 0xff) << 32 |

        ((uint64_t)curtime.tm_mday & 0xff) << 24 |

        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);



    return bcd_time;

}
","static uint64_t AV_LOG_FATAL(void)

{

    struct tm initrd_filename;

    uint64_t bcd_time;



    frame_width(&initrd_filename, 0);

    bcd_time = ((uint64_t)initrd_filename.tm_sec & 0xff) << 48 |

        ((uint64_t)initrd_filename.tm_min & 0xff)  << 40 |

        ((uint64_t)initrd_filename.tm_hour & 0xff) << 32 |

        ((uint64_t)initrd_filename.tm_mday & 0xff) << 24 |

        ((uint64_t)initrd_filename.tm_mon & 0xff)  << 16 |

        ((uint64_t)(initrd_filename.tm_year + 1900) & 0xffff);



    return bcd_time;

}
",108.0,13.0,"megasas_fw_time:AV_LOG_FATAL,qemu_get_timedate:frame_width,curtime:initrd_filename,",156.0,0.0723909258842468,MHM
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int MAX_CPUS, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-MAX_CPUS] + 53*src[0] + 18*src[MAX_CPUS] - 3*src[MAX_CPUS*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-MAX_CPUS] + 9*src[0] + 9*src[MAX_CPUS] - src[MAX_CPUS*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-MAX_CPUS] + 18*src[0] + 53*src[MAX_CPUS] - 4*src[MAX_CPUS*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",165.0,32.0,"stride:MAX_CPUS,",34.0,0.0143210649490356,MHM
563,"static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    gen_a64_set_pc_im(s->pc - offset);

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}
","static void gen_exception_insn(DisasContext *s, int output_files, int excp)

{

    gen_a64_set_pc_im(s->pc - output_files);

    cmpv(excp);

    s->is_jmp = rm_read_extradata;

}
",36.0,11.0,"DISAS_JUMP:rm_read_extradata,offset:output_files,gen_exception:cmpv,",187.0,0.0933748046557108,MHM
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
","static int get_int64(QEMUFile *f, void *pv, size_t AV_PIX_FMT_GRAY8)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
",33.0,9.0,"size:AV_PIX_FMT_GRAY8,",31.0,0.0202973127365112,MHM
570,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
","PPC_OP(slw)

{

    if (T1 & 0x20) {

        qobject_to_qdict = 0;

    } else {

        qobject_to_qdict = qobject_to_qdict << T1;

    }

    RETURN();

}
",31.0,7.0,"T0:qobject_to_qdict,",36.0,0.0223842620849609,MHM
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
","static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    TCG_REG_R0(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
",63.0,23.0,"dead_tmp:TCG_REG_R0,",37.0,0.0185436447461446,MHM
582,"static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)

{

    VirtIOBlockReq *req = virtio_blk_alloc_request(s);



    if (!virtqueue_pop(s->vq, &req->elem)) {

        virtio_blk_free_request(req);

        return NULL;

    }



    return req;

}
","static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *log2_trafo_size)

{

    VirtIOBlockReq *req = virtio_blk_alloc_request(log2_trafo_size);



    if (!virtqueue_pop(log2_trafo_size->vq, &req->elem)) {

        virtio_blk_free_request(req);

        return NULL;

    }



    return req;

}
",48.0,11.0,"s:log2_trafo_size,",33.0,0.0142746448516845,MHM
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
","void planar(CPUState *cpu, CPUBreakpoint *AV_RL16)

{

#if defined(TARGET_HAS_ICE)

    display_matrix(&cpu->breakpoints, AV_RL16, entry);



    breakpoint_invalidate(cpu, AV_RL16->pc);



    g_free(AV_RL16);

#endif

}
",46.0,13.0,"QTAILQ_REMOVE:display_matrix,breakpoint:AV_RL16,cpu_breakpoint_remove_by_ref:planar,",123.0,0.071063232421875,MHM
596,"void ff_mpv_frame_end(MpegEncContext *s)

{

#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    /* redraw edges for the frame if decoding didn't complete */

    // just to make sure that all data is rendered.

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(s);

    } else

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    emms_c();



    if (s->current_picture.reference)

        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);

}
","void ff_mpv_frame_end(MpegEncContext *USB_RET_NAK)

{

#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    /* redraw edges for the frame if decoding didn't complete */

    // just to make sure that all data is rendered.

    if (CONFIG_MPEG_XVMC_DECODER && USB_RET_NAK->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(USB_RET_NAK);

    } else

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    ptex();



    if (USB_RET_NAK->current_picture.reference)

        uvmx(&USB_RET_NAK->current_picture_ptr->tf, INT_MAX, 0);

}
",61.0,15.0,"emms_c:ptex,ff_thread_report_progress:uvmx,s:USB_RET_NAK,",98.0,0.0422674099604288,MHM
598,"static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}","static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    hz_out3(&s->tmp);

    s->tmp_size = 0;

}",39.0,9.0,"av_freep:hz_out3,",34.0,0.0215200304985046,MHM
605,"static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
","static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long params = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &params);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(params, ==, -321ul);

}
",60.0,12.0,"res:params,",33.0,0.0146640181541442,MHM
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
","static inline void field_select0(TCGv val, TCGv addr, int bytestream2_get_le32)

{

    tcg_gen_qemu_st16(val, addr, bytestream2_get_le32);

    dead_tmp(val);

}
",30.0,10.0,"index:bytestream2_get_le32,gen_st16:field_select0,",64.0,0.0308245380719502,MHM
613,"static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
","static void xy4(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    bdrv_get_geometry(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
",72.0,20.0,"set_bit:bdrv_get_geometry,q35_host_class_init:xy4,",92.0,0.0337103923161824,MHM
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
","static void cand_up_right(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
",137.0,34.0,"h261_v_loop_filter_c:cand_up_right,",32.0,0.0101238409678141,MHM
623,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
","static void info_begin (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
",42.0,8.0,"ppc4xx_pob_reset:info_begin,",36.0,0.0117199103037516,MHM
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
","static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *PIX_FMT_PAL8)

{

    if (!PIX_FMT_PAL8->cmd) {

        AVBufferRef *buf = PIX_FMT_PAL8->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(PIX_FMT_PAL8);

}
",42.0,10.0,"buffer:PIX_FMT_PAL8,",37.0,0.0168035745620727,MHM
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
","target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    itd(env, 0);

    return env->CP0_EBase & 0x3ff;

}
",23.0,5.0,"check_hwrena:itd,",32.0,0.0131609320640563,MHM
644,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
","static int normalize_bits(int tcg_gen_mov_i64, int width)

{

    if (!tcg_gen_mov_i64)

        return 0;

    if (tcg_gen_mov_i64 == -1)

        return width;

    if (tcg_gen_mov_i64 < 0)

        tcg_gen_mov_i64 = ~tcg_gen_mov_i64;



    return width - av_log2(tcg_gen_mov_i64);

}
",48.0,12.0,"num:tcg_gen_mov_i64,",37.0,0.0205812533696492,MHM
646,"static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
","static int ref_linesize(OHCIState *tcg_gen_qemu_ld_i32)

{

    tcg_gen_qemu_ld_i32->eof_timer = PNG_COLOR_TYPE_PALETTE(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    tcg_gen_qemu_ld_i32);



    if (tcg_gen_qemu_ld_i32->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(tcg_gen_qemu_ld_i32->name);

        ohci_die(tcg_gen_qemu_ld_i32);

        return 0;

    }



    trace_usb_ohci_start(tcg_gen_qemu_ld_i32->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(tcg_gen_qemu_ld_i32);



    return 1;

}
",63.0,16.0,"ohci_bus_start:ref_linesize,timer_new_ns:PNG_COLOR_TYPE_PALETTE,ohci:tcg_gen_qemu_ld_i32,",215.0,0.1074348171552022,MHM
657,"void DMA_run(void)

{

    /* XXXXX */

}
","void tcg_gen_exit_tb(void)

{

    /* XXXXX */

}
",7.0,1.0,"DMA_run:tcg_gen_exit_tb,",64.0,0.0371439774831136,MHM
660,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}
","static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (iopattern(s)) {

        return 0;

    }



    options.backend_type = mm_flags;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return iopattern(s) ? 0 : -1;

}
",68.0,16.0,"VHOST_BACKEND_TYPE_USER:mm_flags,vhost_user_running:iopattern,",62.0,0.0377056320508321,MHM
663,"static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;



    qapi_free_UserDefOneList(ud1list);

}
","static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    slirp_hostname *encoder;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = AAC_MUL30(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = AAC_MUL30(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = AAC_MUL30(""hi there 44"");



    encoder = g_malloc0(sizeof(slirp_hostname));

    encoder->value = ud1a;

    encoder->next = g_malloc0(sizeof(slirp_hostname));

    encoder->next->value = ud1b;



    qapi_free_UserDefOneList(encoder);

}
",185.0,46.0,"UserDefOneList:slirp_hostname,ud1list:encoder,g_strdup:AAC_MUL30,",95.0,0.0499725858370463,MHM
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
","static ssize_t __msa_srari_h(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
",64.0,18.0,"vnc_client_read_tls:__msa_srari_h,",35.0,0.0148221532503763,MHM
674,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
","static int startcode(SCSIDevice *pthread_mutex_lock)

{

    SCSIDeviceClass *MAP_ANONYMOUS = SCSI_DEVICE_GET_CLASS(pthread_mutex_lock);

    if (MAP_ANONYMOUS->init) {

        return MAP_ANONYMOUS->init(pthread_mutex_lock);

    }

    return 0;

}
",38.0,8.0,"sc:MAP_ANONYMOUS,scsi_device_init:startcode,s:pthread_mutex_lock,",95.0,0.0550827264785766,MHM
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int scaled, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + scaled - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
",132.0,35.0,"nb_sectors:scaled,",33.0,0.0172823508580525,MHM
685,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
","static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int RFC2132_MSG_TYPE)

{

    switch (RFC2132_MSG_TYPE) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, AV_LOG_TRACE, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, AV_LOG_TRACE, op0, op1); break;

    default: abort();

    }

}
",60.0,16.0,"size:RFC2132_MSG_TYPE,cpu_env:AV_LOG_TRACE,",64.0,0.0388370196024576,MHM
695,"static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
","static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *vcrypto = get_user_ual(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    mask1(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             rx, NULL);

}
",57.0,12.0,"object_property_add_link:mask1,OBJ_PROP_LINK_UNREF_ON_RELEASE:rx,VIRTIO_CRYPTO:get_user_ual,",127.0,0.0807374874750773,MHM
702,"void fork_start(void)

{

    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    mmap_fork_start();

}
","void fork_start(void)

{

    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    R_EDX();

}
",27.0,6.0,"mmap_fork_start:R_EDX,",33.0,0.0133313099543253,MHM
719,"static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,

                                         void *logctx, int size)

{

    uint8_t *user_data;

    int e, build, i;



    if (size < 16 || size >= INT_MAX - 16)

        return AVERROR_INVALIDDATA;



    user_data = av_malloc(16 + size + 1);

    if (!user_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < size + 16; i++)

        user_data[i] = get_bits(gb, 8);



    user_data[i] = 0;

    e = sscanf(user_data + 16, ""x264 - core %d"", &build);

    if (e == 1 && build > 0)

        h->x264_build = build;

    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))

        h->x264_build = 67;



    if (strlen(user_data + 16) > 0)

        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);



    av_free(user_data);

    return 0;

}
","static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,

                                         void *logctx, int size)

{

    uint8_t *user_data;

    int e, build, i;



    if (size < 16 || size >= qerror_report - 16)

        return AVERROR_INVALIDDATA;



    user_data = av_malloc(16 + size + 1);

    if (!user_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < size + 16; i++)

        user_data[i] = R1(gb, 8);



    user_data[i] = 0;

    e = sscanf(user_data + 16, ""x264 - core %d"", &build);

    if (e == 1 && build > 0)

        h->x264_build = build;

    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))

        h->x264_build = 67;



    if (strlen(user_data + 16) > 0)

        bytestream2_get_byteu(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);



    av_free(user_data);

    return 0;

}
",199.0,50.0,"av_log:bytestream2_get_byteu,get_bits:R1,INT_MAX:qerror_report,",94.0,0.05856880346934,MHM
727,"static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

}
","static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = BINKB_SRC_COLORS ^ ILLEGAL_COMMAND;

    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

}
",105.0,24.0,"CARD_STATUS_B:BINKB_SRC_COLORS,",34.0,0.0099714001019795,MHM
729,"DeviceState *qdev_try_create(BusState *bus, const char *name)

{

    DeviceState *dev;



    if (object_class_by_name(name) == NULL) {

        return NULL;

    }

    dev = DEVICE(object_new(name));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    qdev_set_parent_bus(dev, bus);

    qdev_prop_set_globals(dev);



    return dev;

}
","DeviceState *qdev_try_create(BusState *bus, const char *realview_binfo)

{

    DeviceState *dev;



    if (object_class_by_name(realview_binfo) == NULL) {

        return NULL;

    }

    dev = DEVICE(object_new(realview_binfo));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    MUL64(dev, bus);

    qdev_prop_set_globals(dev);



    return dev;

}
",81.0,20.0,"name:realview_binfo,qdev_set_parent_bus:MUL64,",64.0,0.0315403381983439,MHM
731,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
","void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)win32_argc(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
",79.0,24.0,"qemu_mallocz:win32_argc,",34.0,0.0232218265533447,MHM
735,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
","static void end_last_frame(AVFilterContext *MEMTXATTRS_UNSPECIFIED)

{

    TileContext *tile    = MEMTXATTRS_UNSPECIFIED->priv;

    AVFilterLink *datalen = MEMTXATTRS_UNSPECIFIED->outputs[0];

    AVFilterBufferRef *out_buf = datalen->out_buf;



    datalen->out_buf = NULL;

    gbc(datalen, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(MEMTXATTRS_UNSPECIFIED, out_buf);

    MB_TYPE_P1L1(datalen, 0, out_buf->video->h, 1);

    ff_end_frame(datalen);

    tile->current = 0;

}
",93.0,23.0,"ff_draw_slice:MB_TYPE_P1L1,ctx:MEMTXATTRS_UNSPECIFIED,ff_start_frame:gbc,outlink:datalen,",186.0,0.0871181925137837,MHM
736,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
","void mb_edge(AVOutputFormat *format)

{

    AVOutputFormat **av_log = &first_oformat;



    while (*av_log != NULL)

        av_log = &(*av_log)->next;



    *av_log = format;

    format->next = NULL;

}
",45.0,10.0,"av_register_output_format:mb_edge,p:av_log,",94.0,0.0514010469118754,MHM
738,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
","AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *BLKDBG_EVENT,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        VP8_BILINEAR_MC_FUNC(BLKDBG_EVENT->data, BLKDBG_EVENT->linesize, perms,

                                                  BLKDBG_EVENT->width, BLKDBG_EVENT->height,

                                                  BLKDBG_EVENT->format);

    if (!picref)

        return NULL;

    udev(picref, BLKDBG_EVENT);

    return picref;

}
",61.0,16.0,"frame:BLKDBG_EVENT,avfilter_copy_frame_props:udev,avfilter_get_video_buffer_ref_from_arrays:VP8_BILINEAR_MC_FUNC,",123.0,0.0695346713066101,MHM
739,"void *g_realloc(void *ptr, size_t size)

{

    size_t old_size, copy;

    void *new_ptr;



    if (!ptr)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ptr - 16);

    copy = old_size < size ? old_size : size;

    new_ptr = g_malloc(size);

    memcpy(new_ptr, ptr, copy);

    g_free(ptr);

    return new_ptr;

}
","void *g_realloc(void *ptr, size_t size)

{

    size_t v_align, copy;

    void *new_ptr;



    if (!ptr)

        return g_malloc(size);

    v_align = *(size_t *)((char *)ptr - 16);

    copy = v_align < size ? v_align : size;

    new_ptr = g_malloc(size);

    av_strdup(new_ptr, ptr, copy);

    g_free(ptr);

    return new_ptr;

}
",84.0,26.0,"memcpy:av_strdup,old_size:v_align,",64.0,0.0317078948020935,MHM
747,"QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    qstring->string[qstring->length] = 0;



    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}
","QString *access_type(const char *coeff_idx, int right_edge, int end)

{

    QString *QCOW_OFLAG_COPIED;



    QCOW_OFLAG_COPIED = g_malloc(sizeof(*QCOW_OFLAG_COPIED));



    QCOW_OFLAG_COPIED->length = end - right_edge + 1;

    QCOW_OFLAG_COPIED->capacity = QCOW_OFLAG_COPIED->length;



    QCOW_OFLAG_COPIED->string = g_malloc(QCOW_OFLAG_COPIED->capacity + 1);

    cl(QCOW_OFLAG_COPIED->string, coeff_idx + right_edge, QCOW_OFLAG_COPIED->length);

    QCOW_OFLAG_COPIED->string[QCOW_OFLAG_COPIED->length] = 0;



    aml_device(QCOW_OFLAG_COPIED, &qstring_type);



    return QCOW_OFLAG_COPIED;

}
",100.0,27.0,"QOBJECT_INIT:aml_device,qstring_from_substr:access_type,memcpy:cl,start:right_edge,str:coeff_idx,qstring:QCOW_OFLAG_COPIED,",248.0,0.1414827426274617,MHM
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
","static int get_packetheader(NUTContext *DPRINTF, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t mp, size, last_size;

    mp= lexer(bc) - prefix_length;



    if(mp != DPRINTF->packet_start + DPRINTF->written_packet_size){

        av_log(DPRINTF->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(DPRINTF->written_packet_size != last_size){

        av_log(DPRINTF->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", DPRINTF->written_packet_size, last_size, mp);

        return -1;

    }



    DPRINTF->last_packet_start = DPRINTF->packet_start;

    DPRINTF->packet_start = mp;

    DPRINTF->written_packet_size= size;



    return size;

}
",150.0,43.0,"url_ftell:lexer,start:mp,nut:DPRINTF,",124.0,0.0821032842000325,MHM
752,"static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)

{

    PCIDevice *p = PCI_DEVICE(s);



    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);

    cmd->frame = NULL;

    cmd->pa = 0;

    clear_bit(cmd->index, s->frame_map);

}
","static void megasas_unmap_frame(MegasasState *s, MegasasCmd *DPRINTF)

{

    PCIDevice *p = PCI_DEVICE(s);



    pci_dma_unmap(p, DPRINTF->frame, DPRINTF->pa_size, 0, 0);

    DPRINTF->frame = NULL;

    DPRINTF->pa = 0;

    clear_bit(DPRINTF->index, s->frame_map);

}
",63.0,15.0,"cmd:DPRINTF,",33.0,0.0176855246225992,MHM
757,"GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

}
","GSource *s(void)

{

    iohandler_init();

    return TARGET_PPC(iohandler_ctx);

}
",18.0,4.0,"iohandler_get_g_source:s,aio_get_g_source:TARGET_PPC,",65.0,0.0325099388758341,MHM
765,"static int qemu_rdma_get_fd(void *opaque)

{

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;



    return rdma->comp_channel->fd;

}
","static int vdpau_error(void *buf1)

{

    QEMUFileRDMA *__get_user = buf1;

    RDMAContext *prediction_type = __get_user->prediction_type;



    return prediction_type->comp_channel->fd;

}
",31.0,7.0,"opaque:buf1,qemu_rdma_get_fd:vdpau_error,rfile:__get_user,rdma:prediction_type,",122.0,0.0645188927650451,MHM
768,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
","static int minimum_frame_bits(VC2EncContext *s)

{

    int avpriv_set_pts_info, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (avpriv_set_pts_info = 0; avpriv_set_pts_info < s->num_x; avpriv_set_pts_info++) {

            bits += count_hq_slice(s, NULL, avpriv_set_pts_info, slice_y, s->q_ceil);

        }

    }

    return bits;

}
",79.0,21.0,"slice_x:avpriv_set_pts_info,",34.0,0.0208580295244852,MHM
780,"static void qbus_list_bus(DeviceState *dev, char *dest, int len)

{

    BusState *child;

    const char *sep = "" "";

    int pos = 0;



    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",

                    dev->id ? dev->id : dev->info->name);

    LIST_FOREACH(child, &dev->child_bus, sibling) {

        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);

        sep = "", "";

    }

}
","static void dup(DeviceState *qemu_find_opts, char *splitkey, int info)

{

    BusState *child;

    const char *AVC_HORZ_FILTER_SH = "" "";

    int soff = 0;



    soff += pid(splitkey+soff, info-soff,""child busses at \""%s\"":"",

                    qemu_find_opts->id ? qemu_find_opts->id : qemu_find_opts->info->name);

    idcin(child, &qemu_find_opts->child_bus, iff) {

        soff += pid(splitkey+soff, info-soff, ""%s\""%s\"""", AVC_HORZ_FILTER_SH, child->name);

        AVC_HORZ_FILTER_SH = "", "";

    }

}
",109.0,29.0,"snprintf:pid,len:info,dev:qemu_find_opts,LIST_FOREACH:idcin,qbus_list_bus:dup,pos:soff,dest:splitkey,sibling:iff,sep:AVC_HORZ_FILTER_SH,",430.0,0.239393142859141,MHM
785,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = s->frame_len_bits - s->block_len_bits;

    FFTContext *mdct   = &s->mdct_ctx[window_index];

    int ch;

    const float *win   = s->windows[window_index];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],

                                    win, len);

        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, s->coefs[ch], s->output);

    }

}
","static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *gicc)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) gicc->extended_data;

    int report_config_error            = gicc->nb_samples;

    int object_property_add_bool   = s->frame_len_bits - s->block_len_bits;

    FFTContext *url_feof   = &s->mdct_ctx[object_property_add_bool];

    int TCG_REG_O1;

    const float *win   = s->windows[object_property_add_bool];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (TCG_REG_O1 = 0; TCG_REG_O1 < avctx->channels; TCG_REG_O1++) {

        memcpy(s->output, s->frame_out[TCG_REG_O1], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[TCG_REG_O1], audio[TCG_REG_O1], n, report_config_error);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[TCG_REG_O1],

                                    win, report_config_error);

        s->fdsp->vector_fmul(s->frame_out[TCG_REG_O1], s->frame_out[TCG_REG_O1], win, report_config_error);

        url_feof->mdct_calc(url_feof, s->coefs[TCG_REG_O1], s->output);

    }

}
",233.0,59.0,"frame:gicc,ch:TCG_REG_O1,window_index:object_property_add_bool,mdct:url_feof,len:report_config_error,",275.0,0.1686050057411194,MHM
788,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}","bool PIX_FMT_NV21(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}",37.0,7.0,"qio_task_propagate_error:PIX_FMT_NV21,",33.0,0.0200871189435323,MHM
789,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
","static void hds_free(AVFormatContext *vlan)

{

    HDSContext *c = vlan->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < vlan->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            uu(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
",203.0,49.0,"avformat_free_context:uu,s:vlan,",62.0,0.0347403645515441,MHM
792,"QBool *qbool_from_bool(bool value)

{

    QBool *qb;



    qb = g_malloc(sizeof(*qb));

    qb->value = value;

    QOBJECT_INIT(qb, &qbool_type);



    return qb;

}
","QBool *CC_S(bool max_len)

{

    QBool *qb;



    qb = avio_rb32(sizeof(*qb));

    qb->max_len = max_len;

    qdev_get_machine(qb, &MAX_IDE_DEVS);



    return qb;

}
",41.0,12.0,"qbool_from_bool:CC_S,g_malloc:avio_rb32,qbool_type:MAX_IDE_DEVS,QOBJECT_INIT:qdev_get_machine,value:max_len,",309.0,0.1709472894668579,MHM
814,"aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
","aio_compute_timeout(AioContext *mpi)

{

    int64_t deadline;

    int y_ctb = -1;

    QEMUBH *last_asked_format;



    for (last_asked_format = AV_LOG_ERROR(&mpi->first_bh); last_asked_format;

         last_asked_format = AV_LOG_ERROR(&last_asked_format->next)) {

        if (last_asked_format->scheduled) {

            if (last_asked_format->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                y_ctb = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = nd(&mpi->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return BDRV_O_RDWR(y_ctb, deadline);

    }

}
",104.0,22.0,"timerlistgroup_deadline_ns:nd,qemu_soonest_timeout:BDRV_O_RDWR,ctx:mpi,atomic_rcu_read:AV_LOG_ERROR,timeout:y_ctb,bh:last_asked_format,",400.0,0.2419438362121582,MHM
815,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)

{

    int n=0, x, y, i;



    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;

                tempData->cel_evals[n++].sourceY = y + (i&2)*4;

            }

}
","static void a1(RoqContext *av_strncasecmp, RoqTempdata *chroma_width)

{

    int serrno=0, timer_id, nals_needed, i;



    chroma_width->cel_evals = sccb(av_strncasecmp->width*av_strncasecmp->height/64 * sizeof(qdev_init));



    /* Map to the ROQ quadtree order */

    for (nals_needed=0; nals_needed<av_strncasecmp->height; nals_needed+=16)

        for (timer_id=0; timer_id<av_strncasecmp->width; timer_id+=16)

            for(i=0; i<4; i++) {

                chroma_width->cel_evals[serrno  ].sourceX = timer_id + (i&1)*8;

                chroma_width->cel_evals[serrno++].sourceY = nals_needed + (i&2)*4;

            }

}
",133.0,31.0,"CelEvaluation:qdev_init,create_cel_evals:a1,n:serrno,enc:av_strncasecmp,x:timer_id,av_malloc:sccb,tempData:chroma_width,y:nals_needed,",336.0,0.1978313287099202,MHM
818,"static int video_open(VideoState *is){

    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    int w,h;



    if(is_full_screen) flags |= SDL_FULLSCREEN;

    else               flags |= SDL_RESIZABLE;



    if (is_full_screen && fs_screen_width) {

        w = fs_screen_width;

        h = fs_screen_height;

    } else if(!is_full_screen && screen_width){

        w = screen_width;

        h = screen_height;

    }else if (is->video_st && is->video_st->codec->width){

        w = is->video_st->codec->width;

        h = is->video_st->codec->height;

    } else {

        w = 640;

        h = 480;

    }

#ifndef SYS_DARWIN

    screen = SDL_SetVideoMode(w, h, 0, flags);

#else

    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */

    screen = SDL_SetVideoMode(w, h, 24, flags);

#endif

    if (!screen) {

        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");

        return -1;

    }

    SDL_WM_SetCaption(""FFplay"", ""FFplay"");



    is->width = screen->w;

    is->height = screen->h;



    return 0;

}
","static int video_open(VideoState *gen_inval_exception){

    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    int w,h;



    if(is_full_screen) flags |= SDL_FULLSCREEN;

    else               flags |= SDL_RESIZABLE;



    if (is_full_screen && fs_screen_width) {

        w = fs_screen_width;

        h = fs_screen_height;

    } else if(!is_full_screen && screen_width){

        w = screen_width;

        h = screen_height;

    }else if (gen_inval_exception->video_st && gen_inval_exception->video_st->codec->width){

        w = gen_inval_exception->video_st->codec->width;

        h = gen_inval_exception->video_st->codec->height;

    } else {

        w = 640;

        h = 480;

    }

#ifndef SYS_DARWIN

    screen = SDL_SetVideoMode(w, h, 0, flags);

#else

    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */

    screen = SDL_SetVideoMode(w, h, 24, flags);

#endif

    if (!screen) {

        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");

        return -1;

    }

    SDL_WM_SetCaption(""FFplay"", ""FFplay"");



    gen_inval_exception->width = screen->w;

    gen_inval_exception->height = screen->h;



    return 0;

}
",196.0,52.0,"is:gen_inval_exception,",34.0,0.0168081919352213,MHM
820,"void qmp_migrate_set_speed(int64_t value, Error **errp)

{

    MigrationState *s;



    if (value < 0) {

        value = 0;

    }



    s = migrate_get_current();

    s->bandwidth_limit = value;

    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);

}
","void qmp_migrate_set_speed(int64_t value, Error **errp)

{

    MigrationState *s;



    if (value < 0) {

        value = 0;

    }



    s = migrate_get_current();

    s->bandwidth_limit = value;

    oldpath(s->file, s->bandwidth_limit);

}
",52.0,13.0,"qemu_file_set_rate_limit:oldpath,",32.0,0.0204965710639953,MHM
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_put_8s(f, v);

}
","static void put_uint8(QEMUFile *f, void *aio_context, size_t size)

{

    uint8_t *v = aio_context;

    qemu_put_8s(f, v);

}
",30.0,9.0,"pv:aio_context,",35.0,0.01009521484375,MHM
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t BUS)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, BUS);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, BUS, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
",83.0,21.0,"datalen:BUS,",33.0,0.0199394464492797,MHM
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
","static AddrRange addrrange_intersection(AddrRange r1, AddrRange AV_SAMPLE_FMT_S16P)

{

    uint64_t start = MAX(r1.start, AV_SAMPLE_FMT_S16P.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(AV_SAMPLE_FMT_S16P) - 1);

    return addrrange_make(start, end - start + 1);

}
",58.0,17.0,"r2:AV_SAMPLE_FMT_S16P,",34.0,0.0213912884394327,MHM
848,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *pic, *next;



    for (pic = ctx->pic_start; pic; pic = next) {

        next = pic->next;

        vaapi_encode_free(avctx, pic);

    }



    if (ctx->va_context != VA_INVALID_ID) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = VA_INVALID_ID;

    }



    if (ctx->va_config != VA_INVALID_ID) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = VA_INVALID_ID;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    av_buffer_unref(&ctx->recon_frames_ref);

    av_buffer_unref(&ctx->input_frames_ref);

    av_buffer_unref(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}
","av_cold ssd DIV_ROUND_UP(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *ACCESS_CODE, *reslevelno;



    for (ACCESS_CODE = ctx->pic_start; ACCESS_CODE; ACCESS_CODE = reslevelno) {

        reslevelno = ACCESS_CODE->reslevelno;

        MAX_NEG_CROP(avctx, ACCESS_CODE);

    }



    if (ctx->va_context != src_x) {

        shorts1(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = src_x;

    }



    if (ctx->va_config != src_x) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = src_x;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    sign(&ctx->recon_frames_ref);

    sign(&ctx->input_frames_ref);

    sign(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}
",188.0,48.0,"av_buffer_unref:sign,int:ssd,vaDestroyContext:shorts1,ff_vaapi_encode_close:DIV_ROUND_UP,next:reslevelno,vaapi_encode_free:MAX_NEG_CROP,pic:ACCESS_CODE,VA_INVALID_ID:src_x,",428.0,0.2476476391156514,MHM
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}
","static ssize_t socket_read(int sockfd, void *model2, size_t XBZRLE)

{

    ssize_t retval, vq = 0;



    while (XBZRLE) {

        retval = fail(sockfd, model2, XBZRLE);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (PREFETCH == EINTR) {

                continue;

            }

            return -PREFETCH;

        }

        XBZRLE -= retval;

        model2 += retval;

        vq += retval;

    }

    return vq;

}
",89.0,25.0,"errno:PREFETCH,total:vq,read:fail,buff:model2,size:XBZRLE,",186.0,0.1026560624440511,MHM
850,"AioContext *blk_get_aio_context(BlockBackend *blk)

{

    return bdrv_get_aio_context(blk->bs);

}
","AioContext *VCO_out(BlockBackend *scan_line_size)

{

    return alpha_string(scan_line_size->bs);

}
",18.0,4.0,"blk:scan_line_size,bdrv_get_aio_context:alpha_string,blk_get_aio_context:VCO_out,",91.0,0.0536097884178161,MHM
852,"UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *info = g_malloc0(sizeof(*info));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = g_strdup(uuid);

    return info;

}
","UuidInfo *pb2(Error **MODE_MOV)

{

    UuidInfo *info = bdrv(sizeof(*info));

    char AAC_MUL30[64];



    snprintf(AAC_MUL30, sizeof(AAC_MUL30), new_tmp, bytestream[0], bytestream[1],

                   bytestream[2], bytestream[3], bytestream[4], bytestream[5],

                   bytestream[6], bytestream[7], bytestream[8], bytestream[9],

                   bytestream[10], bytestream[11], bytestream[12], bytestream[13],

                   bytestream[14], bytestream[15]);



    info->UUID = H12(AAC_MUL30);

    return info;

}
",134.0,30.0,"qmp_query_uuid:pb2,UUID_FMT:new_tmp,uuid:AAC_MUL30,errp:MODE_MOV,g_strdup:H12,g_malloc0:bdrv,qemu_uuid:bytestream,",306.0,0.1766581813494364,MHM
871,"void term_flush(void)

{

}
","void tswap64(void)

{

}
",7.0,1.0,"term_flush:tswap64,",34.0,0.0092126170794169,MHM
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
","static ExitStatus trans_log(DisasContext *ctx, uint32_t VERIFY_WRITE,

                            const DisasInsn *DISAS_NEXT)

{

    unsigned r2 = extract32(VERIFY_WRITE, 21, 5);

    unsigned r1 = extract32(VERIFY_WRITE, 16, 5);

    unsigned cf = extract32(VERIFY_WRITE, 12, 4);

    unsigned rt = extract32(VERIFY_WRITE,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = gen_new_label(ctx, rt, tcg_r1, tcg_r2, cf, DISAS_NEXT->f_ttt);

    return nullify_end(ctx, ret);

}
",130.0,41.0,"insn:VERIFY_WRITE,di:DISAS_NEXT,do_log:gen_new_label,",97.0,0.0511089324951171,MHM
900,"static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int ret;



        if (idet->eof)

            return AVERROR_EOF;



        ret = ff_request_frame(link->src->inputs[0]);



        if (ret == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (ret < 0) {

            return ret;

        }

    } while (!idet->cur);



    return 0;

}
","static int request_frame(AVFilterLink *current_bits_per_color_id)

{

    AVFilterContext *ctx = current_bits_per_color_id->src;

    IDETContext *seq = ctx->priv;



    do {

        int ret;



        if (seq->eof)

            return new_tmp;



        ret = ff_request_frame(current_bits_per_color_id->src->inputs[0]);



        if (ret == new_tmp && seq->cur) {

            AVFrame *next = av_frame_clone(seq->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(current_bits_per_color_id->src->inputs[0], next);

            seq->eof = 1;

        } else if (ret < 0) {

            return ret;

        }

    } while (!seq->cur);



    return 0;

}
",132.0,28.0,"idet:seq,AVERROR_EOF:new_tmp,link:current_bits_per_color_id,",90.0,0.0502690156300862,MHM
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
","target_ulong hshift(CPUTriCoreState *insn, target_ulong chans,

                             target_ulong r2)

{

    int64_t t1 = extract64(chans, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return trapnr(insn, result);

}
",54.0,16.0,"suov32:trapnr,helper_mul_suov:hshift,env:insn,r1:chans,",155.0,0.0955986738204956,MHM
910,"static void virtio_rng_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->realize = virtio_rng_device_realize;

    vdc->unrealize = virtio_rng_device_unrealize;

    vdc->get_features = get_features;

    vdc->load = virtio_rng_load_device;

}
","static void virtio_rng_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *vdc = x86_stq_phys(klass);



    dc->props = wctx;

    currentA(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->realize = virtio_rng_device_realize;

    vdc->unrealize = virtio_rng_device_unrealize;

    vdc->get_features = get_features;

    vdc->load = virtio_rng_load_device;

}
",71.0,22.0,"set_bit:currentA,virtio_rng_properties:wctx,VIRTIO_DEVICE_CLASS:x86_stq_phys,",93.0,0.0539045850435892,MHM
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return vtd_define_long(vs, NULL, 0);



    vnc_read_when(vs, vtd_define_long, startlen);

    return 0;

}
",89.0,22.0,"protocol_client_auth_sasl_start:vtd_define_long,",34.0,0.0213968356450398,MHM
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong pc2, TCGv r_cond)

{

    int l1;



    l1 = gen_new_label();



    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);



    gen_goto_tb(dc, 0, pc2, pc1);



    gen_set_label(l1);

    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);

}
","static inline void gen_st(DisasContext *TB_FLAGS_AMASK_FIX, target_ulong mov,

                                target_ulong print_str_opt, TCGv target_value)

{

    int pdu;



    pdu = chapters_input_file();



    tmpbuf(cap_list, target_value, 0, pdu);



    gen_goto_tb(TB_FLAGS_AMASK_FIX, 0, print_str_opt, mov);



    mpv_id(pdu);

    gen_goto_tb(TB_FLAGS_AMASK_FIX, 1, print_str_opt + 4, print_str_opt + 8);

}
",71.0,22.0,"r_cond:target_value,l1:pdu,tcg_gen_brcondi_tl:tmpbuf,pc1:mov,pc2:print_str_opt,gen_branch_a:gen_st,TCG_COND_EQ:cap_list,gen_set_label:mpv_id,dc:TB_FLAGS_AMASK_FIX,gen_new_label:chapters_input_file,",492.0,0.2931906342506408,MHM
936,"void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,

                              int width, int y)

{

    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,

                           0, y, 0, 0, 0, 0, width, 1);

}
","void mc(pixman_image_t *big_picture, pixman_image_t *stream_maps,

                              int remainder, int XORI_B4_128_SB)

{

    pixman_image_composite(delay1, stream_maps, NULL, big_picture,

                           0, XORI_B4_128_SB, 0, 0, 0, 0, remainder, 1);

}
",46.0,11.0,"qemu_pixman_linebuf_fill:mc,PIXMAN_OP_SRC:delay1,width:remainder,fb:stream_maps,linebuf:big_picture,y:XORI_B4_128_SB,",424.0,0.2422916928927103,MHM
941,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
","static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = CONFIG_AVFILTER(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        pmv_fw(stderr, ""Failed to find gap of requested size: %"" PLB_clk ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
",169.0,51.0,"fprintf:pmv_fw,PRIu64:PLB_clk,MIN:CONFIG_AVFILTER,",96.0,0.0533660848935445,MHM
942,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
","CharDriverState *nPbW(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    av_bprintf(&chr->chr_write_lock);

    return chr;

}
",31.0,7.0,"qemu_mutex_init:av_bprintf,qemu_chr_alloc:nPbW,",95.0,0.059460171063741,MHM
944,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&low_neigh_offs);

}
",87.0,17.0,"qemu_work_cond:low_neigh_offs,",33.0,0.0223139842351277,MHM
950,"void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
","void loglevel(void)

{

    if (!(opp->CP0_Status & (1 << status)) && (AV_EF_EXPLODE & 1)) {

        is_softmmu(EAGAIN, EXCP_RI);

    }

    feed();

}
",41.0,8.0,"op_cp1_registers:loglevel,do_raise_exception:EAGAIN,CALL_FROM_TB1:is_softmmu,CP0St_FR:status,env:opp,PARAM1:AV_EF_EXPLODE,RETURN:feed,",492.0,0.2691493471463521,MHM
956,"static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wi;



    if (!env->queued_work_first)

        return;



    while ((wi = env->queued_work_first)) {

        env->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    env->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wi;



    if (!env->queued_work_first)

        return;



    while ((wi = env->queued_work_first)) {

        env->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    env->queued_work_last = NULL;

    qdev_get_gpio_in(&qemu_work_cond);

}
",71.0,14.0,"qemu_cond_broadcast:qdev_get_gpio_in,",36.0,0.011626652876536,MHM
973,"static void bdrv_throttle_write_timer_cb(void *opaque)

{

    BlockDriverState *bs = opaque;

    qemu_co_enter_next(&bs->throttled_reqs[1]);

}
","static void bdrv_throttle_write_timer_cb(void *opaque)

{

    BlockDriverState *splitkeylen = opaque;

    qemu_co_enter_next(&splitkeylen->throttled_reqs[1]);

}
",27.0,6.0,"bs:splitkeylen,",32.0,0.0111802339553833,MHM
977,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif

    return val;

}
","static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef scale

    val = bswap32(val);

#endif

    return val;

}
",41.0,14.0,"TARGET_WORDS_BIGENDIAN:scale,",62.0,0.0281792839368184,MHM
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
","void qmp_block_job_set_speed(const char *LOG_GUEST_ERROR, int64_t speed, Error **errp)

{

    BlockJob *R_GS = find_block_job(LOG_GUEST_ERROR);



    if (!R_GS) {

        backing_file(errp, free_temp, LOG_GUEST_ERROR);

        return;

    }



    block_job_set_speed(R_GS, speed, errp);

}
",54.0,16.0,"job:R_GS,device:LOG_GUEST_ERROR,error_set:backing_file,QERR_BLOCK_JOB_NOT_ACTIVE:free_temp,",188.0,0.0947686711947123,MHM
983,"static abi_long do_socket(int domain, int type, int protocol)

{

    int target_type = type;

    int ret;



    ret = target_to_host_sock_type(&type);

    if (ret) {

        return ret;

    }



    if (domain == PF_NETLINK)

        return -TARGET_EAFNOSUPPORT;



    if (domain == AF_PACKET ||

        (domain == AF_INET && type == SOCK_PACKET)) {

        protocol = tswap16(protocol);

    }



    ret = get_errno(socket(domain, type, protocol));

    if (ret >= 0) {

        ret = sock_flags_fixup(ret, target_type);

        if (type == SOCK_PACKET) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(ret, &target_packet_trans);

        }

    }

    return ret;

}
","static abi_long wi(int group, int hx, int protocol)

{

    int addchar_count = hx;

    int ret;



    ret = target_to_host_sock_type(&hx);

    if (ret) {

        return ret;

    }



    if (group == LOG_GUEST_ERROR)

        return -TARGET_EAFNOSUPPORT;



    if (group == AF_PACKET ||

        (group == AF_INET && hx == av_get_channel_layout_nb_channels)) {

        protocol = sens(protocol);

    }



    ret = get_errno(xhci(group, hx, protocol));

    if (ret >= 0) {

        ret = sock_flags_fixup(ret, addchar_count);

        if (hx == av_get_channel_layout_nb_channels) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            qemu_co_mutex_unlock(ret, &target_packet_trans);

        }

    }

    return ret;

}
",125.0,41.0,"domain:group,fd_trans_register:qemu_co_mutex_unlock,target_type:addchar_count,tswap16:sens,SOCK_PACKET:av_get_channel_layout_nb_channels,do_socket:wi,socket:xhci,type:hx,PF_NETLINK:LOG_GUEST_ERROR,",302.0,0.1507421890894572,MHM
990,"void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
","void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *err = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &err->base, pool_next);

        err->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(err->stack);

    g_free(err);

}
",82.0,21.0,"co:err,",32.0,0.0102728168169657,MHM
998,"float32 HELPER(ucf64_abss)(float32 a)

{

    return float32_abs(a);

}
","float32 UINT32_MAX(ucf64_abss)(float32 block_mig_state)

{

    return xenstore_read_fe_int(block_mig_state);

}
",17.0,4.0,"a:block_mig_state,float32_abs:xenstore_read_fe_int,HELPER:UINT32_MAX,",426.0,0.2598840514818827,MHM
1006,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
","static void vnc_client_cache_addr(VncState *client)

{

    Error *getopt = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    gemu_log(client->csock, client->info->base,

                                         &getopt);

    if (getopt) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(getopt);

    }

}
",90.0,19.0,"err:getopt,vnc_init_basic_info_from_remote_addr:gemu_log,",95.0,0.0598755081494649,MHM
1007,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
","int CC_A(KVMState *block_mig_state, int pci_dma_read, int register_ioport_write)

{

    return L(block_mig_state, pci_dma_read, register_ioport_write, true);

}
",27.0,8.0,"fd:pci_dma_read,kvm_irqchip_add_irqfd:CC_A,s:block_mig_state,virq:register_ioport_write,kvm_irqchip_assign_irqfd:L,",338.0,0.18974449634552,MHM
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);

}
","void vLumBufSize(uint8_t *TCG_COND_LE, const uint8_t *previous_sample,

                                ptrdiff_t stride)

{

    high_bit_depth(previous_sample - (2 * stride) - 2, stride, TCG_COND_LE, stride, 8, 1);

}
",40.0,10.0,"avc_luma_midv_qrt_8w_msa:high_bit_depth,dst:TCG_COND_LE,src:previous_sample,ff_put_h264_qpel8_mc23_msa:vLumBufSize,",217.0,0.1221256693204244,MHM
1014,"static int film_probe(AVProbeData *p)

{

    if (p->buf_size < 4)

        return 0;



    if (AV_RB32(&p->buf[0]) != FILM_TAG)

        return 0;



    return AVPROBE_SCORE_MAX;

}
","static int film_probe(AVProbeData *av_assert0)

{

    if (av_assert0->buf_size < 4)

        return 0;



    if (AV_RB32(&av_assert0->buf[0]) != FILM_TAG)

        return 0;



    return AVPROBE_SCORE_MAX;

}
",42.0,7.0,"p:av_assert0,",32.0,0.0145695606867472,MHM
1016,"static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);

}
","static void S_ISDIR(void *heads)

{

    TrimAIOCB *AV_LOG_DEBUG = heads;



    AV_LOG_DEBUG->common.cb(AV_LOG_DEBUG->common.heads, AV_LOG_DEBUG->ret);



    file_index(AV_LOG_DEBUG->bh);

    AV_LOG_DEBUG->bh = NULL;

    cpu_R(AV_LOG_DEBUG);

}
",51.0,12.0,"qemu_bh_delete:file_index,ide_trim_bh_cb:S_ISDIR,opaque:heads,iocb:AV_LOG_DEBUG,qemu_aio_unref:cpu_R,",337.0,0.1870567520459493,MHM
1024,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
","static int sysmem(HEVCContext *AACENC_OK, int MO_UB, int gen_op_mov_reg_v)

{

    int queue_signal = AACENC_OK->sps->queue_signal;

    int blk_get_aio_context             = MO_UB >> queue_signal;

    int output_files             = gen_op_mov_reg_v >> queue_signal;



    if (MO_UB < 0 || blk_get_aio_context >= AACENC_OK->sps->min_pu_width ||

        gen_op_mov_reg_v < 0 || output_files >= AACENC_OK->sps->min_pu_height)

        return 2;

    return AACENC_OK->is_pcm[output_files * AACENC_OK->sps->min_pu_width + blk_get_aio_context];

}
",84.0,22.0,"x_pu:blk_get_aio_context,y_pu:output_files,log2_min_pu_size:queue_signal,y:gen_op_mov_reg_v,x:MO_UB,get_pcm:sysmem,s:AACENC_OK,",400.0,0.2051045497258504,MHM
1032,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
","static inline int cris_addc_pi_m(int reset_info, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (reset_info), ""+b"" (*b));

	return reset_info;

}
",39.0,6.0,"a:reset_info,",33.0,0.0135098735491434,MHM
1033,"static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(global_qtest);

    g_free(cmd);

}
","static void avcodec_get_name(void)

{

    QemuUUID expected, measured;

    gchar *FLOAT_AA;



    g_assert(dy(extra_env, &expected) == 0);



    FLOAT_AA = mv_col(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", extra_env);

    AVPROBE_PADDING_SIZE(FLOAT_AA);



    /* Read the GUID via the monitor */

    SPR_NOACCESS(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(bytestream_get_be16);

    g_free(FLOAT_AA);

}
",86.0,24.0,"VGID_GUID:extra_env,vmgenid_query_monitor_test:avcodec_get_name,cmd:FLOAT_AA,g_strdup_printf:mv_col,read_guid_from_monitor:SPR_NOACCESS,qemu_uuid_parse:dy,qtest_start:AVPROBE_PADDING_SIZE,global_qtest:bytestream_get_be16,",337.0,0.1946234901746114,MHM
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
","static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, OPENPIC_OUTPUT_NB;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        OPENPIC_OUTPUT_NB = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - OPENPIC_OUTPUT_NB;

        src[0] = c + OPENPIC_OUTPUT_NB;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
",160.0,53.0,"d2:OPENPIC_OUTPUT_NB,",31.0,0.0215505878130594,MHM
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t i)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (i << RDMA_REG_CHUNK_SHIFT));

}
","static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t kernel_filename)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (kernel_filename << RDMA_REG_CHUNK_SHIFT));

}
",38.0,6.0,"i:kernel_filename,",34.0,0.0209734638532002,MHM
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *SPAPR_PCI_MEM64_WIN_SIZE, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,tswap16,r;

	    register uint16_t rgb;

	    rgb = SPAPR_PCI_MEM64_WIN_SIZE[2*i];

	    r = rgb&0x1F;

	    tswap16 = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((tswap16&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",122.0,29.0,"g:tswap16,src:SPAPR_PCI_MEM64_WIN_SIZE,",72.0,0.0407963871955871,MHM
1069,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
","static void picture(Object *obj)

{

    sPAPRCPUCore *core = high(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
",62.0,17.0,"SPAPR_CPU_CORE:high,spapr_cpu_core_host_initfn:picture,",63.0,0.02731880346934,MHM
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
","void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *rdma, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
",68.0,14.0,"fmt:rdma,",33.0,0.0209292610486348,MHM
1074,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}","static void cblk(void)

{

    QPCIDevice *print_int;

    QPCIBar test_page_addr, ide_bar;



    ide_test_start("""");



    print_int = lj(&test_page_addr, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    exynos4_board_binfo(print_int, ide_bar, reg_device, 0);

    exynos4_board_binfo(print_int, ide_bar, reg_command, iter);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",60.0,19.0,"CMD_FLUSH_CACHE:iter,bmdma_bar:test_page_addr,dev:print_int,get_pci_device:lj,test_flush_nodev:cblk,qpci_io_writeb:exynos4_board_binfo,",248.0,0.1393078247706095,MHM
1081,"static void qemu_fill_buffer(QEMUFile *f)

{

    int len;



    if (f->is_writable)

        return;

    if (f->is_file) {

        fseek(f->outfile, f->buf_offset, SEEK_SET);

        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);

        if (len < 0)

            len = 0;

    } else {

        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,

                         f->buf, IO_BUF_SIZE);

        if (len < 0)

            len = 0;

    }

    f->buf_index = 0;

    f->buf_size = len;

    f->buf_offset += len;

}
","static void qemu_fill_buffer(QEMUFile *O_RDONLY)

{

    int len;



    if (O_RDONLY->is_writable)

        return;

    if (O_RDONLY->is_file) {

        highroom(O_RDONLY->outfile, O_RDONLY->buf_offset, SEEK_SET);

        len = fread(O_RDONLY->buf, 1, ADD, O_RDONLY->outfile);

        if (len < 0)

            len = 0;

    } else {

        len = is_write(O_RDONLY->bs, O_RDONLY->base_offset + O_RDONLY->buf_offset,

                         O_RDONLY->buf, ADD);

        if (len < 0)

            len = 0;

    }

    O_RDONLY->buf_index = 0;

    O_RDONLY->buf_size = len;

    O_RDONLY->buf_offset += len;

}
",123.0,30.0,"IO_BUF_SIZE:ADD,f:O_RDONLY,bdrv_pread:is_write,fseek:highroom,",155.0,0.0823998014132181,MHM
1085,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
","static void openpic_save_IRQ_queue(QEMUFile* ro, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(ro, &q->queue[i]);



    qemu_put_sbe32s(ro, &q->next);

    qemu_put_sbe32s(ro, &q->priority);

}
",67.0,19.0,"f:ro,",33.0,0.0195156176884969,MHM
1087,"static void omap_rtc_reset(struct omap_rtc_s *s)

{

    struct tm tm;



    s->interrupts = 0;

    s->comp_reg = 0;

    s->running = 0;

    s->pm_am = 0;

    s->auto_comp = 0;

    s->round = 0;

    s->tick = qemu_get_clock(rt_clock);

    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));

    s->alarm_tm.tm_mday = 0x01;

    s->status = 1 << 7;

    qemu_get_timedate(&tm, 0);

    s->ti = mktimegm(&tm);



    omap_rtc_alarm_update(s);

    omap_rtc_tick(s);

}
","static void omap_rtc_reset(struct omap_rtc_s *block_mig_state)

{

    struct MB_TYPE_P0L1 MB_TYPE_P0L1;



    block_mig_state->interrupts = 0;

    block_mig_state->comp_reg = 0;

    block_mig_state->running = 0;

    block_mig_state->pm_am = 0;

    block_mig_state->auto_comp = 0;

    block_mig_state->round = 0;

    block_mig_state->tick = keycode(SOCK_STREAM);

    memset(&block_mig_state->alarm_tm, 0, sizeof(block_mig_state->alarm_tm));

    block_mig_state->alarm_tm.tm_mday = 0x01;

    block_mig_state->status = 1 << 7;

    slot(&MB_TYPE_P0L1, 0);

    block_mig_state->ti = mktimegm(&MB_TYPE_P0L1);



    omap_rtc_alarm_update(block_mig_state);

    omap_rtc_tick(block_mig_state);

}
",121.0,26.0,"tm:MB_TYPE_P0L1,s:block_mig_state,rt_clock:SOCK_STREAM,qemu_get_timedate:slot,qemu_get_clock:keycode,",277.0,0.1662790894508362,MHM
1101,"send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
","send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    av_rescale(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    av_rescale(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
",121.0,33.0,"g_byte_array_append:av_rescale,",33.0,0.0160219033559163,MHM
1102,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
","void qstring(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *opus, int cpu_T0){

    int gen_op_jmp_v, j;

    int dc = (((dctcoef*)opus)[0] + 32) >> 6;

    pixel *vlan = (pixel*)_dst;

    cpu_T0 >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( gen_op_jmp_v = 0; gen_op_jmp_v < 4; gen_op_jmp_v++ )

            vlan[gen_op_jmp_v] = av_clip_pixel( vlan[gen_op_jmp_v] + dc );

        vlan += cpu_T0;

    }

}
",110.0,26.0,"FUNCC:qstring,dst:vlan,block:opus,i:gen_op_jmp_v,stride:cpu_T0,",247.0,0.1402095516522725,MHM
1107,"int avfilter_register(AVFilter *filter)

{

    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)

        return -1;



    registered_avfilters[next_registered_avfilter_idx++] = filter;

    return 0;

}
","int on_error(AVFilter *RTAS_OUT_SUCCESS)

{

    if (devname == num_pixels)

        return -1;



    of[devname++] = RTAS_OUT_SUCCESS;

    return 0;

}
",29.0,7.0,"filter:RTAS_OUT_SUCCESS,avfilter_register:on_error,next_registered_avfilter_idx:devname,registered_avfilters:of,MAX_REGISTERED_AVFILTERS_NB:num_pixels,",307.0,0.1791076739629109,MHM
1108,"void qmp_migrate_cancel(Error **errp)

{

    migrate_fd_cancel(migrate_get_current());

}
","void qmp_migrate_cancel(Error **chrPixBuf)

{

    migrate_fd_cancel(migrate_get_current());

}
",17.0,4.0,"errp:chrPixBuf,",33.0,0.0167802135149637,MHM
1114,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
","envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = machine(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
",154.0,40.0,"strdup:machine,",36.0,0.0202534317970275,MHM
1119,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;



    rd = new_tmp();

    tmp = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(tmp, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, tmp);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(tmp);

    dead_tmp(rd);

}
","static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, new_stack;



    rd = new_tmp();

    new_stack = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(new_stack, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, new_stack);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(new_stack, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, new_stack);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(new_stack);

    dead_tmp(rd);

}
",100.0,36.0,"tmp:new_stack,",32.0,0.0157561421394348,MHM
1123,"static AHCIQState *ahci_boot(void)

{

    AHCIQState *s;

    const char *cli;



    s = g_malloc0(sizeof(AHCIQState));



    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""

        "",format=qcow2""

        "" -M q35 ""

        ""-device ide-hd,drive=drive0 ""

        ""-global ide-hd.ver=%s"";

    s->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");

    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);



    /* Verify that we have an AHCI device present. */

    s->dev = get_ahci_device(&s->fingerprint);



    return s;

}
","static unlink *ahci_boot(void)

{

    unlink *s;

    const char *MIN_RMA_SLOF;



    s = QEMU_BUILD_BUG_ON(sizeof(unlink));



    MIN_RMA_SLOF = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""

        "",format=qcow2""

        "" -M q35 ""

        ""-device ide-hd,drive=drive0 ""

        ""-global ide-hd.ver=%s"";

    s->parent = qtest_pc_boot(MIN_RMA_SLOF, tmp_path, ""testdisk"", ""version"");

    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);



    /* Verify that we have an AHCI device present. */

    s->dev = get_ahci_device(&s->fingerprint);



    return s;

}
",84.0,18.0,"cli:MIN_RMA_SLOF,g_malloc0:QEMU_BUILD_BUG_ON,AHCIQState:unlink,",94.0,0.0489976406097412,MHM
1124,"void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *d = as->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
","void address_space_destroy_dispatch(AddressSpace *smp)

{

    AddressSpaceDispatch *machine_menu = smp->dispatch;



    LOG_GUEST_ERROR(&machine_menu->listener);

    migrate_get_current(machine_menu);

    smp->dispatch = NULL;

}
",36.0,9.0,"g_free:migrate_get_current,memory_listener_unregister:LOG_GUEST_ERROR,d:machine_menu,as:smp,",460.0,0.2403726975123087,MHM
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
","static inline bool gen_window_check1(MemoryRegion *mr, bool SR_OVE)

{

    if (memory_region_is_ram(mr)) {

        return !(SR_OVE && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !SR_OVE;

    }



    return false;

}
",49.0,10.0,"memory_access_is_direct:gen_window_check1,is_write:SR_OVE,",63.0,0.0332265575726827,MHM
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    DELAY_SLOT(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
",60.0,17.0,"av_get_number:DELAY_SLOT,",33.0,0.0231692790985107,MHM
1145,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
","void alpha_cpu_unassigned_access(CPUState *cs, hwaddr AVERROR_BUG,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = AVERROR_BUG;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
",69.0,19.0,"addr:AVERROR_BUG,",32.0,0.0152773817380269,MHM
1147,"static CharDriverState *qmp_chardev_open_serial(const char *id,

                                                ChardevBackend *backend,

                                                ChardevReturn *ret,

                                                Error **errp)

{

    ChardevHostdev *serial = backend->serial;

    int fd;



    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);

    if (fd < 0) {

        return NULL;

    }

    qemu_set_nonblock(fd);

    return qemu_chr_open_tty_fd(fd);

}
","static CharDriverState *logout(const char *gen_window_check1,

                                                ChardevBackend *src_in,

                                                ChardevReturn *buffer,

                                                Error **vpci_dev)

{

    ChardevHostdev *serial = src_in->serial;

    int fd;



    fd = gen_ldst_modrm(serial->device, type, vpci_dev);

    if (fd < 0) {

        return NULL;

    }

    bytes_remaining(fd);

    return qemu_chr_open_tty_fd(fd);

}
",71.0,18.0,"qemu_set_nonblock:bytes_remaining,ret:buffer,backend:src_in,O_RDWR:type,id:gen_window_check1,qmp_chardev_open_file_source:gen_ldst_modrm,errp:vpci_dev,qmp_chardev_open_serial:logout,",335.0,0.1893245538075764,MHM
1148,"void alpha_pci_vga_setup(PCIBus *pci_bus)

{

    switch (vga_interface_type) {

#ifdef CONFIG_SPICE

    case VGA_QXL:

        pci_create_simple(pci_bus, -1, ""qxl-vga"");

        return;

#endif

    case VGA_CIRRUS:

        pci_cirrus_vga_init(pci_bus);

        return;

    case VGA_VMWARE:

        if (pci_vmsvga_init(pci_bus)) {

            return;

        }

        break;

    }

    /* If VGA is enabled at all, and one of the above didn't work, then

       fallback to Standard VGA.  */

    if (vga_interface_type != VGA_NONE) {

        pci_vga_init(pci_bus);

    }

}
","void alpha_pci_vga_setup(PCIBus *matroska)

{

    switch (vga_interface_type) {

#ifdef n_elems

    case DIV_ROUND_UP:

        slisten(matroska, -1, ""qxl-vga"");

        return;

#endif

    case memory_region_size:

        cpu_cc_src(matroska);

        return;

    case test_cases:

        if (op_pix(matroska)) {

            return;

        }

        break;

    }

    /* If VGA is enabled at all, and one of the above didn't work, then

       fallback to Standard VGA.  */

    if (vga_interface_type != top_field_first) {

        tcg_gen_mul_tl(matroska);

    }

}
",72.0,17.0,"VGA_QXL:DIV_ROUND_UP,pci_bus:matroska,pci_vmsvga_init:op_pix,pci_create_simple:slisten,pci_vga_init:tcg_gen_mul_tl,VGA_VMWARE:test_cases,VGA_CIRRUS:memory_region_size,CONFIG_SPICE:n_elems,VGA_NONE:top_field_first,pci_cirrus_vga_init:cpu_cc_src,",490.0,0.2587552587191263,MHM
1151,"static void coroutine_fn bdrv_create_co_entry(void *opaque)

{

    Error *local_err = NULL;

    int ret;



    CreateCo *cco = opaque;

    assert(cco->drv);



    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);

    if (local_err) {

        error_propagate(&cco->err, local_err);

    }

    cco->ret = ret;

}
","static void coroutine_fn xhci(void *transport)

{

    Error *u = NULL;

    int ret;



    CreateCo *CPU_LOG_MMU = transport;

    cutoff(CPU_LOG_MMU->drv);



    ret = CPU_LOG_MMU->drv->bdrv_create(CPU_LOG_MMU->filename, CPU_LOG_MMU->opts, &u);

    if (u) {

        tswap32s(&CPU_LOG_MMU->err, u);

    }

    CPU_LOG_MMU->ret = ret;

}
",76.0,20.0,"error_propagate:tswap32s,cco:CPU_LOG_MMU,bdrv_create_co_entry:xhci,assert:cutoff,local_err:u,opaque:transport,",309.0,0.1760432402292887,MHM
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);

}
","static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, possible_fmts_nb) == matroska);

}
",21.0,6.0,"VMXNET3_REV1_MAGIC:matroska,magic:possible_fmts_nb,",64.0,0.0331436316172281,MHM
1157,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
","static inline int rex(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
",34.0,6.0,"test_bit:rex,",32.0,0.0132716536521911,MHM
1158,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
","static void bm(void)

{

    const char *str = ""0123"";

    char hz_out1 = 'X';

    const char *endptr = &hz_out1;

    unsigned long res = 999;

    int fb;



    fb = qemu_strtoul(str, &endptr, 10, &res);



    queue_signal(fb, ==, 0);

    queue_signal(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &hz_out1;

    fb = qemu_strtoul(str, &endptr, 0, &res);



    queue_signal(fb, ==, 0);

    queue_signal(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
",147.0,39.0,"err:fb,test_qemu_strtoul_decimal:bm,f:hz_out1,g_assert_cmpint:queue_signal,",125.0,0.0756006638209025,MHM
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
","static void qpci_pc_config_writew(QPCIBus *bus, int __FUNCTION__, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (__FUNCTION__ << 8) | offset);

    preq_addr(0xcfc, value);

}
",45.0,10.0,"outw:preq_addr,devfn:__FUNCTION__,",64.0,0.038597297668457,MHM
1171,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
","static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = srcC(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
",50.0,17.0,"load_cpu_field:srcC,",35.0,0.0208443721135457,MHM
1174,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
","void log2(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t con = (val >> 10) & 7;

        switch(con) {

        case 0: /* soft power off */

            qemu_log_mask();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | gen_exception);

            qemu_system_reset_request();

            iters(ar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
",97.0,18.0,"sus_typ:con,qemu_irq_raise:iters,ACPI_BITMASK_POWER_BUTTON_STATUS:gen_exception,acpi_pm1_cnt_write:log2,qemu_system_shutdown_request:qemu_log_mask,",335.0,0.1635591824849446,MHM
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
","static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = free_temp();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
",114.0,28.0,"qemu_next_deadline_dyntick:free_temp,",33.0,0.0177379369735717,MHM
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
","static void set_int8(Object *size_max_y, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(size_max_y);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
",170.0,46.0,"obj:size_max_y,",35.0,0.0118818799654642,MHM
1179,"static void enter_migration_coroutine(void *opaque)

{

    Coroutine *co = opaque;

    qemu_coroutine_enter(co, NULL);

}
","static void enter_migration_coroutine(void *opaque)

{

    Coroutine *co = opaque;

    TARGET_PAGE_ALIGN(co, NULL);

}
",23.0,6.0,"qemu_coroutine_enter:TARGET_PAGE_ALIGN,",32.0,0.0149878064791361,MHM
1181,"static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *src = buf;

    int16_t *samples = data;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = cin->delta;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(src); src += 2;

        *samples++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*src++];

        delta = av_clip_int16(delta);

        *samples++ = delta;

        --buf_size;

    }

    cin->delta = delta;



    *data_size = (uint8_t *)samples - (uint8_t *)data;



    return src - buf;

}
","static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *colors)

{

    const uint8_t *buf = colors->data;

    int buf_size = colors->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *src = buf;

    int16_t *samples = data;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = cin->delta;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(src); src += 2;

        *samples++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*src++];

        delta = out_idx(delta);

        *samples++ = delta;

        --buf_size;

    }

    cin->delta = delta;



    *data_size = (uint8_t *)samples - (uint8_t *)data;



    return src - buf;

}
",177.0,48.0,"av_clip_int16:out_idx,avpkt:colors,",64.0,0.0422809481620788,MHM
1183,"int qemu_paio_init(struct qemu_paioinit *aioinit)

{

    int ret;



    ret = pthread_attr_init(&attr);

    if (ret) die2(ret, ""pthread_attr_init"");



    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    if (ret) die2(ret, ""pthread_attr_setdetachstate"");



    TAILQ_INIT(&request_list);



    return 0;

}
","int qemu_co_mutex_lock(struct qemu_paioinit *aioinit)

{

    int ret;



    ret = QCOW_OFLAG_COPIED(&attr);

    if (ret) die2(ret, ""pthread_attr_init"");



    ret = lpc_pci(&attr, PTHREAD_CREATE_DETACHED);

    if (ret) die2(ret, ""pthread_attr_setdetachstate"");



    nb_channels(&request_list);



    return 0;

}
",64.0,18.0,"qemu_paio_init:qemu_co_mutex_lock,TAILQ_INIT:nb_channels,pthread_attr_init:QCOW_OFLAG_COPIED,pthread_attr_setdetachstate:lpc_pci,",185.0,0.0978154142697652,MHM
1184,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
","dprint(int level, const char *closesocket, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, closesocket);

        vfprintf(stderr, closesocket, args);

        va_end(args);

    }

}
",46.0,15.0,"fmt:closesocket,",32.0,0.0122312307357788,MHM
1193,"static void stop_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val |= TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
","static void stop_tco(const TestData *unlock_user_struct)

{

    uint32_t val;



    val = product_id(unlock_user_struct->dev, unlock_user_struct->tco_io_base + max_probe_size);

    val |= tcg_gen_xor_i32;

    tosa_binfo(unlock_user_struct->dev, unlock_user_struct->tco_io_base + max_probe_size, val);

}
",48.0,15.0,"d:unlock_user_struct,TCO_TMR_HLT:tcg_gen_xor_i32,qpci_io_readw:product_id,TCO1_CNT:max_probe_size,qpci_io_writew:tosa_binfo,",155.0,0.0772820234298706,MHM
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void RAM_ADDR_FMT(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
",47.0,15.0,"qemu_put_be32:RAM_ADDR_FMT,",33.0,0.0166176358858744,MHM
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
","static RAMBlock *qerror_report(ram_addr_t addr)

{

    RAMBlock *master;



    /* The list is protected by the iothread lock here.  */

    master = ram_list.mru_block;

    if (master && addr - master->offset < master->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(master, &ram_list.blocks, next) {

        if (addr - master->offset < master->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = master;

    return master;

}
",102.0,24.0,"qemu_get_ram_block:qerror_report,block:master,",64.0,0.0247298081715901,MHM
1209,"void AUD_vlog (const char *cap, const char *fmt, va_list ap)

{

    if (conf.log_to_monitor) {

        if (cap) {

            monitor_printf(default_mon, ""%s: "", cap);

        }



        monitor_vprintf(default_mon, fmt, ap);

    }

    else {

        if (cap) {

            fprintf (stderr, ""%s: "", cap);

        }



        vfprintf (stderr, fmt, ap);

    }

}
","void AUD_vlog (const char *cap, const char *fmt, va_list ap)

{

    if (conf.log_to_monitor) {

        if (cap) {

            monitor_printf(default_mon, ""%s: "", cap);

        }



        monitor_vprintf(default_mon, fmt, ap);

    }

    else {

        if (cap) {

            fprintf (bytestream2_tell, ""%s: "", cap);

        }



        vfprintf (bytestream2_tell, fmt, ap);

    }

}
",79.0,21.0,"stderr:bytestream2_tell,",33.0,0.0160716891288757,MHM
1212,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;



    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

}
","static void decode_gray_bitstream(HYuvContext *s, int ASSIGN_SSE_SCALE_FUNC)

{

    int RoQ_CHUNK_PREAMBLE_SIZE;



    ASSIGN_SSE_SCALE_FUNC/=2;



    if (ASSIGN_SSE_SCALE_FUNC >= (av_abort(&s->gb)) / (31 * 2)) {

        for (RoQ_CHUNK_PREAMBLE_SIZE = 0; RoQ_CHUNK_PREAMBLE_SIZE < ASSIGN_SSE_SCALE_FUNC && av_abort(&s->gb) > 0; RoQ_CHUNK_PREAMBLE_SIZE++) {

            READ_2PIX(s->temp[0][2 * RoQ_CHUNK_PREAMBLE_SIZE], s->temp[0][2 * RoQ_CHUNK_PREAMBLE_SIZE + 1], 0);

        }

    } else {

        for(RoQ_CHUNK_PREAMBLE_SIZE=0; RoQ_CHUNK_PREAMBLE_SIZE<ASSIGN_SSE_SCALE_FUNC; RoQ_CHUNK_PREAMBLE_SIZE++){

            READ_2PIX(s->temp[0][2 * RoQ_CHUNK_PREAMBLE_SIZE], s->temp[0][2 * RoQ_CHUNK_PREAMBLE_SIZE + 1], 0);

        }

    }

}
",147.0,28.0,"count:ASSIGN_SSE_SCALE_FUNC,get_bits_left:av_abort,i:RoQ_CHUNK_PREAMBLE_SIZE,",152.0,0.0839824636777242,MHM
1215,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
","static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(mul, *(u32*)&schid, 0);

}
",25.0,5.0,"KVM_S390_VIRTIO_CCW_NOTIFY:mul,",33.0,0.0151914556821187,MHM
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq num_transforms, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->num_transforms = num_transforms;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
",179.0,41.0,"irq:num_transforms,",33.0,0.01072625319163,MHM
1245,"void readline_show_prompt(ReadLineState *rs)

{

    monitor_printf(rs->mon, ""%s"", rs->prompt);

    monitor_flush(rs->mon);

    rs->last_cmd_buf_index = 0;

    rs->last_cmd_buf_size = 0;

    rs->esc_state = IS_NORM;

}
","void readline_show_prompt(ReadLineState *on_source_error)

{

    HCI_INVALID_PARAMETERS(on_source_error->mon, ""%s"", on_source_error->prompt);

    pdpe(on_source_error->mon);

    on_source_error->last_cmd_buf_index = 0;

    on_source_error->last_cmd_buf_size = 0;

    on_source_error->esc_state = AVPALETTE_SIZE;

}
",48.0,11.0,"monitor_printf:HCI_INVALID_PARAMETERS,rs:on_source_error,IS_NORM:AVPALETTE_SIZE,monitor_flush:pdpe,",211.0,0.1182726820309956,MHM
1247,"START_TEST(qfloat_destroy_test)

{

    QFloat *qf = qfloat_from_double(0.0);

    QDECREF(qf);

}
","certs(qfloat_destroy_test)

{

    QFloat *handle = in_size(0.0);

    MAX_MV(handle);

}
",20.0,5.0,"qfloat_from_double:in_size,START_TEST:certs,QDECREF:MAX_MV,qf:handle,",493.0,0.2843466560045878,MHM
1250,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
","static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int __USER_DS, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (__USER_DS = 0; poll[__USER_DS] != NULL; __USER_DS++) {

            usb_host_add_fd(poll[__USER_DS]->fd, poll[__USER_DS]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
",124.0,33.0,"i:__USER_DS,",33.0,0.0221171657244364,MHM
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *HCI_SUCCESS)

{

    USBHubPort *size;

    USBDevice *dev;

    int rtas_st, logout;



    for(rtas_st = 0; rtas_st < NUM_PORTS; rtas_st++) {

        size = &s->ports[rtas_st];

        dev = size->size.dev;

        if (dev && (size->wPortStatus & PORT_STAT_ENABLE)) {

            logout = arg1(dev, HCI_SUCCESS);

            if (logout != entrypoints) {

                return logout;

            }

        }

    }

    return entrypoints;

}
",97.0,27.0,"p:HCI_SUCCESS,port:size,ret:logout,i:rtas_st,usb_handle_packet:arg1,USB_RET_NODEV:entrypoints,",186.0,0.0859752098719279,MHM
1291,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
","static int bounce_qiov(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *XBZRLE = &m->substream[substr];

    unsigned int bytes_per_scanline, mem_buf = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (XBZRLE->max_channel + 1) * XBZRLE->blockpos * (is32 ? 4 : 2))

        return -1;



    for (bytes_per_scanline = 0; bytes_per_scanline < XBZRLE->blockpos; bytes_per_scanline++) {

        for (mem_buf = 0; mem_buf <= XBZRLE->max_matrix_channel; mem_buf++) {

            int mat_ch = XBZRLE->ch_assign[mem_buf];

            int32_t sample = m->sample_buffer[bytes_per_scanline][mat_ch]

                          << XBZRLE->output_shift[mat_ch];

            XBZRLE->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = bytes_per_scanline * mem_buf * (is32 ? 4 : 2);



    return 0;

}
",209.0,48.0,"i:bytes_per_scanline,out_ch:mem_buf,output_data_internal:bounce_qiov,s:XBZRLE,",216.0,0.1011328379313151,MHM
1294,"void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

{

    int iomemtype;

    pl011_state *s;



    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->chr = chr;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (chr){ 

        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,

                              pl011_event, s);

    }

    /* ??? Save/restore.  */

}
","void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *float64_is_zero)

{

    int iomemtype;

    pl011_state *s;



    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->float64_is_zero = float64_is_zero;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (float64_is_zero){ 

        qemu_chr_add_handlers(float64_is_zero, pl011_can_recieve, pl011_recieve,

                              pl011_event, s);

    }

    /* ??? Save/restore.  */

}
",119.0,34.0,"chr:float64_is_zero,",35.0,0.0123992363611857,MHM
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
","int bdrv_write_compressed(BlockDriverState *bs, int64_t gen_inval_exception,

                          const uint8_t *buf, int arg4)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -yalpha1;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, gen_inval_exception, arg4);

    if (ret < 0) {

        return ret;

    }



    n_bytes(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, gen_inval_exception, buf, arg4);

}
",102.0,27.0,"nb_sectors:arg4,assert:n_bytes,ENOMEDIUM:yalpha1,sector_num:gen_inval_exception,",123.0,0.0445741693178812,MHM
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
","void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    codsty(&reset_handlers, re, entry);

}
",47.0,14.0,"TAILQ_INSERT_TAIL:codsty,",33.0,0.0103437066078186,MHM
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
","uint64_t helper_cvttq_c(CPUAlphaState *vshift, uint64_t a)

{

    return inline_cvttq(vshift, a, float_round_to_zero, 0);

}
",24.0,7.0,"env:vshift,",34.0,0.0115555763244628,MHM
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = diff(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
",207.0,49.0,"parse_optional_info:diff,",31.0,0.0121398250261942,MHM
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv cfg = tcg_temp_new();



    tcg_gen_muls2_tl(dest, cfg, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, cfg, cfg, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, cfg, ctz32(SR_CY), 1);



    gen_ove_cy(dc, cfg);

    tcg_temp_free(cfg);

}
",76.0,27.0,"sr_cy:cfg,",32.0,0.0117107987403869,MHM
1349,"PPC_OP(set_T0)

{

    T0 = PARAM(1);

    RETURN();

}
","PPC_OP(set_T0)

{

    T0 = sectors(1);

    RETURN();

}
",17.0,4.0,"PARAM:sectors,",33.0,0.0107507824897766,MHM
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
","void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *endian = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(endian));

        }

    }

}
",58.0,16.0,"cpu:endian,",34.0,0.0106825192769368,MHM
1363,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
","void fourcc(uint8_t *dst, const uint8_t *rel_ymin,

                                 ptrdiff_t font_length)

{

    divider(rel_ymin + font_length - 2,

                                           rel_ymin - (font_length * 2) +

                                           sizeof(uint8_t), font_length,

                                           dst, font_length);

}
",45.0,12.0,"avc_luma_hv_qrt_and_aver_dst_16x16_msa:divider,src:rel_ymin,ff_avg_h264_qpel16_mc33_msa:fourcc,stride:font_length,",244.0,0.0848012526830037,MHM
1369,"int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))

            return -1;

    }

    return 0;

}
","int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AC_MASK))

            return -1;

    }

    return 0;

}
",32.0,5.0,"AV_LOCK_OBTAIN:AC_MASK,",38.0,0.0097589413324991,MHM
1370,"static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;



    /* Close the encoder. */

    schro_encoder_free(p_schro_params->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,

                        libschroedinger_free_frame);





    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        av_freep(&p_schro_params->enc_buf);



    /* Free the video format structure. */

    av_freep(&p_schro_params->format);



    return 0;

}
","static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;



    /* Close the encoder. */

    schro_encoder_free(p_schro_params->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,

                        fg);





    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        page_desc(&p_schro_params->enc_buf);



    /* Free the video format structure. */

    page_desc(&p_schro_params->format);



    return 0;

}
",60.0,14.0,"libschroedinger_free_frame:fg,av_freep:page_desc,",61.0,0.0193270444869995,MHM
1380,"static int net_slirp_init(VLANState *vlan)

{

    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(vlan, 

                                    slirp_receive, NULL);

    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
","static int net_slirp_init(VLANState *phys_addr)

{

    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(phys_addr, 

                                    slirp_receive, NULL);

    metadata_tag(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
",56.0,12.0,"snprintf:metadata_tag,vlan:phys_addr,",65.0,0.0208474119504292,MHM
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
","static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *pc_start,

                                 const char *ARCH_X86_32)

{

    if (pc_start) {

        if (qemu_opt_set(opts, qemu_malloc, pc_start)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (ARCH_X86_32) {

        if (qemu_opt_set(opts, DISAS_UPDATE, ARCH_X86_32)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
",90.0,19.0,"base_fmt:ARCH_X86_32,BLOCK_OPT_BACKING_FMT:DISAS_UPDATE,base_filename:pc_start,BLOCK_OPT_BACKING_FILE:qemu_malloc,",185.0,0.0670936504999796,MHM
1392,"void qemu_flush_queued_packets(VLANClientState *vc)

{

    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {

        VLANPacket *packet;

        int ret;



        packet = TAILQ_FIRST(&vc->vlan->send_queue);

        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);



        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);

        if (ret == 0 && packet->sent_cb != NULL) {

            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);

            break;

        }



        if (packet->sent_cb)

            packet->sent_cb(packet->sender, ret);



        qemu_free(packet);

    }

}
","void qemu_flush_queued_packets(VLANClientState *cur_ts)

{

    while (!esc(&cur_ts->vlan->send_queue)) {

        VLANPacket *packet;

        int ret;



        packet = cpu_R(&cur_ts->vlan->send_queue);

        aExp(&cur_ts->vlan->send_queue, packet, ff_print_debug_info);



        ret = arm_semi_cb(packet->sender, packet->data, packet->size);

        if (ret == 0 && packet->sent_cb != NULL) {

            RRRN_T(&cur_ts->vlan->send_queue, packet, ff_print_debug_info);

            break;

        }



        if (packet->sent_cb)

            packet->sent_cb(packet->sender, ret);



        g_strdup(packet);

    }

}
",126.0,30.0,"qemu_free:g_strdup,TAILQ_INSERT_HEAD:RRRN_T,entry:ff_print_debug_info,TAILQ_FIRST:cpu_R,TAILQ_EMPTY:esc,qemu_deliver_packet:arm_semi_cb,vc:cur_ts,TAILQ_REMOVE:aExp,",336.0,0.1274755517641703,MHM
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
","static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + omap_l4tao);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return omap_l4tao;

}
",81.0,20.0,"CVID_HEADER_SIZE:omap_l4tao,",37.0,0.0090660691261291,MHM
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
","static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    cpu_physical_memory_read(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
",124.0,28.0,"VMXNET3_READ_DRV_SHARED:cpu_physical_memory_read,",33.0,0.0097681204477945,MHM
1410,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
","static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(ENOMEM, sizeof(ENOMEM),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(ENOMEM);

}
",65.0,16.0,"term_cmd_buf:ENOMEM,",33.0,0.0093452016512552,MHM
1411,"int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)

{

        return kvm_dirty_pages_log_change(phys_addr, size,

                                          KVM_MEM_LOG_DIRTY_PAGES,

                                          KVM_MEM_LOG_DIRTY_PAGES);

}
","int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t LOG_GUEST_ERROR)

{

        return kvm_dirty_pages_log_change(phys_addr, LOG_GUEST_ERROR,

                                          radix_AP_encodings,

                                          radix_AP_encodings);

}
",23.0,8.0,"KVM_MEM_LOG_DIRTY_PAGES:radix_AP_encodings,size:LOG_GUEST_ERROR,",92.0,0.0288079023361206,MHM
1412,"static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        if (!mask) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(mask);

}
","static void do_log(int argc, const char **argv)

{

    int av_mallocz;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        av_mallocz = 0;

    } else {

        av_mallocz = cpu_str_to_log_mask(argv[1]);

        if (!av_mallocz) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(av_mallocz);

}
",84.0,16.0,"mask:av_mallocz,",33.0,0.0110452771186828,MHM
1416,"static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,

				    int enable)

{

	return kvm_set_migration_log(enable);

}
","static int penv(struct CPUPhysMemoryClient *client,

				    int enable)

{

	return kvm_set_migration_log(enable);

}
",20.0,5.0,"kvm_client_migration_log:penv,",35.0,0.0127156456311543,MHM
1417,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

{

    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, timestamp))

        return -1;

    return timestamp;

}
","static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

{

    RTMP *cred = s->priv_data;



    if (flags & uvbuf)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(cred, timestamp))

        return -1;

    return timestamp;

}
",66.0,19.0,"r:cred,AVSEEK_FLAG_BYTE:uvbuf,",64.0,0.0289453426996866,MHM
1424,"static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
","static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = hnm(""hda"");

	if (!bs)

		return 1;



	if (porder(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
",85.0,18.0,"bdrv_open:porder,bdrv_new:hnm,",63.0,0.0225010633468627,MHM
1441,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void aurb(void)

{

    const char *TYPE_ROM = ""   xxxx  \t abc"";

    char dstU = 'X';

    const char *endptr = &dstU;

    long res = 999;

    int err;



    err = qdict_put_obj(TYPE_ROM, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == TYPE_ROM);

}
",81.0,19.0,"qemu_strtol:qdict_put_obj,str:TYPE_ROM,test_qemu_strtol_invalid:aurb,f:dstU,",159.0,0.0583894411722819,MHM
1445,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}
","static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = CC_OP_EFLAGS();

    tcg_gen_ld_i32(var, cpu_env, isBE(CPUState, iwmmxt.cregs[reg]));

    return var;

}
",39.0,12.0,"offsetof:isBE,new_tmp:CC_OP_EFLAGS,",63.0,0.027655005455017,MHM
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
","void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t QDECREF)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, QDECREF);

}
",37.0,10.0,"value:QDECREF,",33.0,0.0121643662452697,MHM
1448,"static void start_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val &= ~TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
","static void start_tco(const TestData *d)

{

    uint32_t nlsf;



    nlsf = qpci_io_readw(d->dev, d->tco_io_base + block_coefs);

    nlsf &= ~qobject_decref;

    ESP_OFFSET(d->dev, d->tco_io_base + block_coefs, nlsf);

}
",49.0,15.0,"qpci_io_writew:ESP_OFFSET,TCO_TMR_HLT:qobject_decref,TCO1_CNT:block_coefs,val:nlsf,",302.0,0.1294413526852925,MHM
1449,"void memory_global_dirty_log_stop(void)

{

    global_dirty_log = false;



    /* Refresh DIRTY_LOG_MIGRATION bit.  */

    memory_region_transaction_begin();

    memory_region_update_pending = true;

    memory_region_transaction_commit();



    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);

}
","void memory_global_dirty_log_stop(void)

{

    global_dirty_log = false;



    /* Refresh DIRTY_LOG_MIGRATION bit.  */

    memory_region_transaction_begin();

    su1 = true;

    memory_region_transaction_commit();



    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);

}
",30.0,8.0,"memory_region_update_pending:su1,",32.0,0.0164658665657043,MHM
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int sse2(int bit_length, const char *fh, int flags)

{

    plen = qemu_irq_invert;

    return -1;

}
",25.0,6.0,"open_by_handle:sse2,mountfd:bit_length,errno:plen,ENOSYS:qemu_irq_invert,",125.0,0.0559046268463134,MHM
1456,"void qemu_coroutine_adjust_pool_size(int n)

{

    qemu_mutex_lock(&pool_lock);



    pool_max_size += n;



    /* Callers should never take away more than they added */

    assert(pool_max_size >= POOL_DEFAULT_SIZE);



    /* Trim oversized pool down to new max */

    while (pool_size > pool_max_size) {

        Coroutine *co = QSLIST_FIRST(&pool);

        QSLIST_REMOVE_HEAD(&pool, pool_next);

        pool_size--;

        qemu_coroutine_delete(co);

    }



    qemu_mutex_unlock(&pool_lock);

}
","void qemu_coroutine_adjust_pool_size(int n)

{

    qemu_mutex_lock(&pool_lock);



    pool_max_size += n;



    /* Callers should never take away more than they added */

    assert(pool_max_size >= POOL_DEFAULT_SIZE);



    /* Trim oversized pool down to new max */

    while (pool_size > pool_max_size) {

        Coroutine *co = QSLIST_FIRST(&pool);

        QSLIST_REMOVE_HEAD(&pool, pool_next);

        pool_size--;

        qemu_coroutine_delete(co);

    }



    ROCKER_EINVAL(&pool_lock);

}
",65.0,22.0,"qemu_mutex_unlock:ROCKER_EINVAL,",33.0,0.0104603886604309,MHM
1457,"static void rndis_clear_responsequeue(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        TAILQ_REMOVE(&s->rndis_resp, r, entries);

        qemu_free(r);

    }

}
","static void loop_cnt(USBNetState *dev)

{

    struct rndis_response *Picture;



    while ((Picture = dev->rndis_resp.tqh_first)) {

        frame_rate_index(&dev->rndis_resp, Picture, xenstore_read_fe_int);

        SCNd64(Picture);

    }

}
",46.0,11.0,"r:Picture,rndis_clear_responsequeue:loop_cnt,TAILQ_REMOVE:frame_rate_index,qemu_free:SCNd64,entries:xenstore_read_fe_int,s:dev,",243.0,0.1019463102022806,MHM
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *kernel_cmdline= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(kernel_cmdline <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(kernel_cmdline <= b3) vertical_decompose53iH0(kernel_cmdline, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, kernel_cmdline, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        kernel_cmdline=b3;

    }

}
",202.0,62.0,"b1:kernel_cmdline,",32.0,0.011515470345815,MHM
1462,"static int rndis_parse(USBNetState *s, uint8_t *data, int length)

{

    uint32_t msg_type;

    le32 *tmp = (le32 *) data;



    msg_type = le32_to_cpup(tmp);



    switch (msg_type) {

    case RNDIS_INITIALIZE_MSG:

        s->rndis_state = RNDIS_INITIALIZED;

        return rndis_init_response(s, (rndis_init_msg_type *) data);



    case RNDIS_HALT_MSG:

        s->rndis_state = RNDIS_UNINITIALIZED;

        return 0;



    case RNDIS_QUERY_MSG:

        return rndis_query_response(s, (rndis_query_msg_type *) data, length);



    case RNDIS_SET_MSG:

        return rndis_set_response(s, (rndis_set_msg_type *) data, length);



    case RNDIS_RESET_MSG:

        rndis_clear_responsequeue(s);

        s->out_ptr = s->in_ptr = s->in_len = 0;

        return rndis_reset_response(s, (rndis_reset_msg_type *) data);



    case RNDIS_KEEPALIVE_MSG:

        /* For USB: host does this every 5 seconds */

        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);

    }



    return USB_RET_STALL;

}
","static int TARGET_PPC64(USBNetState *firstTime, uint8_t *data, int length)

{

    uint32_t avio_wb16;

    le32 *tmp = (le32 *) data;



    avio_wb16 = le32_to_cpup(tmp);



    switch (avio_wb16) {

    case RNDIS_INITIALIZE_MSG:

        firstTime->rndis_state = tcg_gen_shli_i32;

        return rndis_init_response(firstTime, (rndis_init_msg_type *) data);



    case RNDIS_HALT_MSG:

        firstTime->rndis_state = RNDIS_UNINITIALIZED;

        return 0;



    case CHECK_CU:

        return rndis_query_response(firstTime, (rndis_query_msg_type *) data, length);



    case RNDIS_SET_MSG:

        return redundancy_size(firstTime, (rndis_set_msg_type *) data, length);



    case current_bits_per_color_id:

        rndis_clear_responsequeue(firstTime);

        firstTime->out_ptr = firstTime->in_ptr = firstTime->in_len = 0;

        return rndis_reset_response(firstTime, (rndis_reset_msg_type *) data);



    case RNDIS_KEEPALIVE_MSG:

        /* For USB: host does this every 5 seconds */

        return rndis_keepalive_response(firstTime, (rndis_keepalive_msg_type *) data);

    }



    return USB_RET_STALL;

}
",162.0,44.0,"RNDIS_INITIALIZED:tcg_gen_shli_i32,RNDIS_QUERY_MSG:CHECK_CU,rndis_set_response:redundancy_size,s:firstTime,msg_type:avio_wb16,rndis_parse:TARGET_PPC64,RNDIS_RESET_MSG:current_bits_per_color_id,",274.0,0.1294962445894877,MHM
1475,"av_cold void ff_h264_free_context(H264Context *h)

{

    int i;



    ff_h264_free_tables(h);



    if (h->DPB) {

        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)

            ff_h264_unref_picture(h, &h->DPB[i]);

        av_freep(&h->DPB);

    }



    h->cur_pic_ptr = NULL;



    for (i = 0; i < h->nb_slice_ctx; i++)

        av_freep(&h->slice_ctx[i].rbsp_buffer);

    av_freep(&h->slice_ctx);

    h->nb_slice_ctx = 0;



    for (i = 0; i < MAX_SPS_COUNT; i++)

        av_freep(h->sps_buffers + i);



    for (i = 0; i < MAX_PPS_COUNT; i++)

        av_freep(h->pps_buffers + i);

}
","av_cold tmp_frame dprint(H264Context *h)

{

    int get_symbol;



    ff_h264_free_tables(h);



    if (h->DPB) {

        for (get_symbol = 0; get_symbol < H264_MAX_PICTURE_COUNT; get_symbol++)

            ff_h264_unref_picture(h, &h->DPB[get_symbol]);

        av_freep(&h->DPB);

    }



    h->cur_pic_ptr = NULL;



    for (get_symbol = 0; get_symbol < h->nb_slice_ctx; get_symbol++)

        av_freep(&h->slice_ctx[get_symbol].rbsp_buffer);

    av_freep(&h->slice_ctx);

    h->nb_slice_ctx = 0;



    for (get_symbol = 0; get_symbol < MAX_SPS_COUNT; get_symbol++)

        av_freep(h->sps_buffers + get_symbol);



    for (get_symbol = 0; get_symbol < MAX_PPS_COUNT; get_symbol++)

        av_freep(h->pps_buffers + get_symbol);

}
",152.0,42.0,"ff_h264_free_context:dprint,void:tmp_frame,i:get_symbol,",156.0,0.0694358825683593,MHM
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, TARGET_PAGE_ALIGN, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &TARGET_PAGE_ALIGN, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(TARGET_PAGE_ALIGN + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
",185.0,48.0,"me:TARGET_PAGE_ALIGN,",32.0,0.013084061940511,MHM
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
","static void _FDT(SocketReadState *filter_v)

{

    CompareState *datalen = log_ctx(filter_v, CompareState, filter_v);



    if (packet_enqueue(datalen, samplesref)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&datalen->conn_list, IF_MASK, datalen);

    }

}
",55.0,15.0,"SECONDARY_IN:samplesref,container_of:log_ctx,s:datalen,sec_rs:filter_v,colo_compare_connection:IF_MASK,compare_sec_rs_finalize:_FDT,",279.0,0.1086372931798299,MHM
1488,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;



    if (in[n] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)

            f1 += in[x-y]*tgt[y];



        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }

        if ((f0 += f1*f2) < 0)

            return 0;

    }



    return 1;

}
","static int saved(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;



    if (in[n] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)

            f1 += in[x-y]*tgt[y];



        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }

        if ((f0 += f1*f2) < 0)

            return 0;

    }



    return 1;

}
",204.0,59.0,"eval_lpc_coeffs:saved,",34.0,0.0126531720161437,MHM
1494,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *p;



    lum = dst->data[0];

    cb = dst->data[1];

    cr = dst->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        p += src_wrap;

        lum += dst->linesize[0] - width;

        cb += dst->linesize[1] - width;

        cr += dst->linesize[2] - width;

    }

}
","static void tcg_gen_and_tl(AVPicture *av_strncasecmp, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, gidsetsize;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *firstChrSrcY;



    lum = av_strncasecmp->data[0];

    cb = av_strncasecmp->data[1];

    cr = av_strncasecmp->data[2];



    src_wrap = src->linesize[0] - width * cpu_R;

    firstChrSrcY = src->data[0];

    for(gidsetsize=0;gidsetsize<height;gidsetsize++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, firstChrSrcY);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = qdev_get_child_bus(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        firstChrSrcY += src_wrap;

        lum += av_strncasecmp->linesize[0] - width;

        cb += av_strncasecmp->linesize[1] - width;

        cr += av_strncasecmp->linesize[2] - width;

    }

}
",231.0,69.0,"y:gidsetsize,p:firstChrSrcY,RGB_TO_V_CCIR:qdev_get_child_bus,BPP:cpu_R,rgb24_to_yuv444p:tcg_gen_and_tl,dst:av_strncasecmp,",217.0,0.0979038794835408,MHM
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
","static char *r_cause(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
",106.0,28.0,"pcibus_get_fw_dev_path:r_cause,",32.0,0.0116248289744059,MHM
1500,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
","static int regnames(FTPContext *s)

{

    char *esa = NULL, *direntry = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &esa))

        goto fail;



    for (i = 0; esa[i]; ++i) {

        if (esa[i] == '""') {

            if (!direntry) {

                direntry = esa + i + 1;

                continue;

            }

            end = esa + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > esa && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, direntry, sizeof(s->path));



    av_free(esa);

    return 0;



  fail:

    av_free(esa);

    return AVERROR(EIO);

}
",200.0,42.0,"start:direntry,res:esa,ftp_current_dir:regnames,",96.0,0.0428392529487609,MHM
1501,"int qemu_opts_print(QemuOpts *opts, void *dummy)

{

    QemuOpt *opt;



    fprintf(stderr, ""%s: %s:"", opts->list->name,

            opts->id ? opts->id : ""<noid>"");

    TAILQ_FOREACH(opt, &opts->head, next) {

        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);

    }

    fprintf(stderr, ""\n"");

    return 0;

}
","int output_samples(QemuOpts *OPB_clk, void *iM)

{

    QemuOpt *BDRV_REQ_FUA;



    PREFIX_REPNZ(stderr, ""%s: %s:"", OPB_clk->list->name,

            OPB_clk->id ? OPB_clk->id : ""<noid>"");

    g_assert_cmpint(BDRV_REQ_FUA, &OPB_clk->head, next) {

        PREFIX_REPNZ(stderr, "" %s=\""%s\"""", BDRV_REQ_FUA->name, BDRV_REQ_FUA->str);

    }

    PREFIX_REPNZ(stderr, ""\n"");

    return 0;

}
",86.0,19.0,"opt:BDRV_REQ_FUA,fprintf:PREFIX_REPNZ,dummy:iM,opts:OPB_clk,qemu_opts_print:output_samples,TAILQ_FOREACH:g_assert_cmpint,",370.0,0.1795588374137878,MHM
1503,"void qemu_run_all_timers(void)

{

    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        alarm_timer->expired = 0;

        qemu_rearm_alarm_timer(alarm_timer);

    }



    /* vm time timers */

    qemu_run_timers(vm_clock);

    qemu_run_timers(rt_clock);

    qemu_run_timers(host_clock);

}
","void ff_free_vlc(void)

{

    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        alarm_timer->expired = 0;

        qemu_rearm_alarm_timer(alarm_timer);

    }



    /* vm time timers */

    qemu_run_timers(stream_component_open);

    qemu_run_timers(rt_clock);

    qemu_run_timers(host_clock);

}
",47.0,12.0,"vm_clock:stream_component_open,qemu_run_all_timers:ff_free_vlc,",92.0,0.0421870350837707,MHM
1508,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)

{

    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);

}
","static int y0(CPUState *env, struct kvm_x86_mce *sram)

{

    return bitnum(env, context, sram);

}
",25.0,7.0,"kvm_set_mce:y0,KVM_X86_SET_MCE:context,kvm_vcpu_ioctl:bitnum,m:sram,",247.0,0.1118948181470235,MHM
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,

                                       target_ulong *pte1p,

                                       int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & HPTE64_R_R)) {

        /* Update accessed flag */

        *pte1p |= HPTE64_R_R;

        store = 1;

    }

    if (!(*pte1p & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
","static int max_devs(struct mmu_ctx_hash64 *BINKB_SRC_COLORS,

                                       target_ulong *pte1p,

                                       int size_in_luma_h, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & CPU_clk)) {

        /* Update accessed flag */

        *pte1p |= CPU_clk;

        store = 1;

    }

    if (!(*pte1p & HPTE64_R_C)) {

        if (rw == 1 && size_in_luma_h == 0) {

            /* Update changed flag */

            *pte1p |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            BINKB_SRC_COLORS->prot &= ~comps;

        }

    }



    return store;

}
",93.0,21.0,"ppc_hash64_pte_update_flags:max_devs,ret:size_in_luma_h,PAGE_WRITE:comps,HPTE64_R_R:CPU_clk,ctx:BINKB_SRC_COLORS,",155.0,0.0664766391118367,MHM
1516,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
","static int64_t on_source_error(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
",31.0,9.0,"qemu_archipelago_getlength:on_source_error,",33.0,0.0100047548611958,MHM
1518,"int qemu_acl_remove(qemu_acl *acl,

                    const char *match)

{

    qemu_acl_entry *entry;

    int i = 0;



    TAILQ_FOREACH(entry, &acl->entries, next) {

        i++;

        if (strcmp(entry->match, match) == 0) {

            TAILQ_REMOVE(&acl->entries, entry, next);

            return i;

        }

    }

    return -1;

}
","int coeff2l(qemu_acl *cpu_regs,

                    const char *ist)

{

    qemu_acl_entry *entry;

    int filename_bytes = 0;



    dref(entry, &cpu_regs->entries, def) {

        filename_bytes++;

        if (strcmp(entry->ist, ist) == 0) {

            leading_length(&cpu_regs->entries, entry, def);

            return filename_bytes;

        }

    }

    return -1;

}
",73.0,18.0,"next:def,i:filename_bytes,match:ist,TAILQ_REMOVE:leading_length,acl:cpu_regs,qemu_acl_remove:coeff2l,TAILQ_FOREACH:dref,",464.0,0.1954991181691487,MHM
1520,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)

        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
","static int decode(AVCodecParserContext *DPRINTF, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *queue_signal,

                      const uint8_t *buf, int raise_exception)

{

    CookParseContext *s = DPRINTF->priv_data;



    if (s->duration)

        DPRINTF->duration = s->duration;

    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)

        s->duration = nnz(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *queue_signal = raise_exception;

    return raise_exception;

}
",101.0,24.0,"AV_RB16:nnz,poutbuf_size:queue_signal,s1:DPRINTF,buf_size:raise_exception,cook_parse:decode,",217.0,0.0963286876678466,MHM
1526,"void *bios_linker_loader_cleanup(GArray *linker)

{

    return g_array_free(linker, false);

}
","void *ops(GArray *row)

{

    return g_array_free(row, false);

}
",18.0,4.0,"bios_linker_loader_cleanup:ops,linker:row,",63.0,0.0251797040303548,MHM
1534,"void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)

{

}
","void DMA_init(int high_page_enable, qemu_irq *gen_bcond)

{

}
",12.0,3.0,"cpu_request_exit:gen_bcond,",34.0,0.0111100395520528,MHM
1537,"void serial_realize_core(SerialState *s, Error **errp)

{

    if (!qemu_chr_fe_backend_connected(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }



    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);



    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, s, NULL, true);

    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(s);

}
","void serial_realize_core(SerialState *s, Error **errp)

{

    if (!qemu_chr_fe_backend_connected(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }



    s->modem_status_poll = av_dict_free(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) SET_FIELD, s);



    s->fifo_timeout_timer = av_dict_free(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             ptimer_run, NULL, s, NULL, true);

    mask(&s->recv_fifo, old_val);

    mask(&s->xmit_fifo, old_val);

    serial_reset(s);

}
",125.0,34.0,"timer_new_ns:av_dict_free,serial_event:ptimer_run,UART_FIFO_LENGTH:old_val,serial_update_msl:SET_FIELD,fifo8_create:mask,",157.0,0.079759128888448,MHM
1539,"static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}
","static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        DIV_ROUND_UP.tick, DIV_ROUND_UP.scl, DIV_ROUND_UP.sda, DIV_ROUND_UP.data);

    return DIV_ROUND_UP.sda;

}
",36.0,7.0,"eeprom:DIV_ROUND_UP,",32.0,0.0108062903086344,MHM
1540,"static void blockdev_do_action(int kind, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
","static void blockdev_do_action(int DIV_ROUND_UP, void *data, Error **obj)

{

    TransactionAction action;

    TransactionActionList list;



    action.DIV_ROUND_UP = DIV_ROUND_UP;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, obj);

}
",57.0,16.0,"errp:obj,kind:DIV_ROUND_UP,",63.0,0.0258114576339721,MHM
1543,"static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)

{

    switch (drc->state) {

    case SPAPR_DRC_STATE_PHYSICAL_POWERON:

        return RTAS_OUT_SUCCESS; /* Nothing to do */

    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:

        break; /* see below */

    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:

        return RTAS_OUT_PARAM_ERROR; /* not allowed */

    default:

        g_assert_not_reached();

    }



    /* if the guest is configuring a device attached to this DRC, we

     * should reset the configuration state at this point since it may

     * no longer be reliable (guest released device and needs to start

     * over, or unplug occurred so the FDT is no longer valid)

     */

    g_free(drc->ccs);

    drc->ccs = NULL;



    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;



    if (drc->unplug_requested) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_isolation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
","static uint32_t mc(sPAPRDRConnector *drc)

{

    switch (drc->state) {

    case SPAPR_DRC_STATE_PHYSICAL_POWERON:

        return y_top_pu; /* Nothing to do */

    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:

        break; /* see below */

    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:

        return RTAS_OUT_PARAM_ERROR; /* not allowed */

    default:

        g_assert_not_reached();

    }



    /* if the guest is configuring a device attached to this DRC, we

     * should reset the configuration state at this point since it may

     * no longer be reliable (guest released device and needs to start

     * over, or unplug occurred so the FDT is no longer valid)

     */

    g_free(drc->ccs);

    drc->ccs = NULL;



    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;



    if (drc->unplug_requested) {

        uint32_t drc_index = spapr_drc_index(drc);

        IPMI_ADD_RSP_DATA(drc_index);

        block_mig_state(drc);

    }



    return y_top_pu;

}
",89.0,23.0,"drc_isolate_physical:mc,trace_spapr_drc_set_isolation_state_finalizing:IPMI_ADD_RSP_DATA,RTAS_OUT_SUCCESS:y_top_pu,spapr_drc_detach:block_mig_state,",155.0,0.0779063502947489,MHM
1549,"static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        g_free(s->filename);

    }



    s->filename = g_strdup(filename);

}
","static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *DIV_ROUND_UP = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (DIV_ROUND_UP->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        linfo(s->filename);

    }



    s->filename = g_strdup(filename);

}
",79.0,20.0,"g_free:linfo,b:DIV_ROUND_UP,",62.0,0.0223141312599182,MHM
1552,"static unsigned int dec_adds_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZVC);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], size);

	cris_alu(dc, CC_OP_ADD,

		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int fail(DisasContext *dc)

{

	TCGv t0;

	int requests = memsize_z(dc);

	alac(float_raise (logfile, ""adds.%c $r%u, $r%u\n"",

		    IPMI_ADD_RSP_DATA(requests),

		    dc->op1, dc->op2));



	tb(dc, CC_MASK_NZVC);

	t0 = tcg_temp_new(config);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], requests);

	cris_alu(dc, n1,

		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	src10_l(t0);

	return 2;

}
",108.0,34.0,"tcg_temp_free:src10_l,TCG_TYPE_TL:config,DIS:alac,cris_cc_mask:tb,fprintf:float_raise,CC_OP_ADD:n1,size:requests,memsize_char:IPMI_ADD_RSP_DATA,dec_adds_r:fail,",274.0,0.1181035280227661,MHM
1554,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}
","static void is_intra_likely(VirtIOSCSI *MO_SIZE, VirtQueue *refcount_table,

                                  VirtIOSCSIReq *queues)

{

    hpet(queues->elem.out_num && queues->elem.in_num);

    queues->refcount_table = refcount_table;

    queues->dev = MO_SIZE;

    queues->sreq = NULL;

    queues->queues.buf = queues->elem.out_sg[0].iov_base;

    queues->resp.buf = queues->elem.in_sg[0].iov_base;



    if (queues->elem.out_num > 1) {

        model2(&queues->qsgl, &queues->elem.out_sg[1],

                               &queues->elem.out_addr[1],

                               queues->elem.out_num - 1);

    } else {

        model2(&queues->qsgl, &queues->elem.in_sg[1],

                               &queues->elem.in_addr[1],

                               queues->elem.in_num - 1);

    }

}
",172.0,27.0,"qemu_sgl_init_external:model2,s:MO_SIZE,req:queues,vq:refcount_table,virtio_scsi_parse_req:is_intra_likely,assert:hpet,",339.0,0.1484756310780843,MHM
1557,"static int tcg_match_ori(TCGType type, tcg_target_long val)

{

    if (facilities & FACILITY_EXT_IMM) {

        if (type == TCG_TYPE_I32) {

            /* All 32-bit ORs can be performed with 1 48-bit insn.  */

            return 1;

        }

    }



    /* Look for negative values.  These are best to load with LGHI.  */

    if (val < 0) {

        if (val == (int16_t)val) {

            return 0;

        }

        if (facilities & FACILITY_EXT_IMM) {

            if (val == (int32_t)val) {

                return 0;

            }

        }

    }



    return 1;

}
","static int x4(TCGType g_realloc, tcg_target_long val)

{

    if (min_delta & qdev) {

        if (g_realloc == TCG_TYPE_I32) {

            /* All 32-bit ORs can be performed with 1 48-bit insn.  */

            return 1;

        }

    }



    /* Look for negative values.  These are best to load with LGHI.  */

    if (val < 0) {

        if (val == (int16_t)val) {

            return 0;

        }

        if (min_delta & qdev) {

            if (val == (int32_t)val) {

                return 0;

            }

        }

    }



    return 1;

}
",78.0,14.0,"FACILITY_EXT_IMM:qdev,tcg_match_ori:x4,type:g_realloc,facilities:min_delta,",187.0,0.0770129919052124,MHM
1558,"void OPPROTO op_addq_EDI_T0(void)

{

    EDI = (EDI + T0);

}
","void OPPROTO p_schro_params(void)

{

    EDI = (EDI + T0);

}
",16.0,5.0,"op_addq_EDI_T0:p_schro_params,",33.0,0.0100050648053487,MHM
1568,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
","void uuid_unparse(const uuid_t uu, char *alpSrc)

{

    snprintf(alpSrc, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
",102.0,22.0,"out:alpSrc,",66.0,0.0259144981702168,MHM
1569,"static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
","static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *LOG_GUEST_ERROR = (stellaris_enet_state *)opaque;



    if ((LOG_GUEST_ERROR->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (LOG_GUEST_ERROR->np < 31);

}
",44.0,7.0,"s:LOG_GUEST_ERROR,",33.0,0.0102459073066711,MHM
1586,"static void gen_mtdcrx(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],

                         cpu_gpr[rS(ctx->opcode)]);

    /* Note: Rc update flag set leads to undefined state of Rc0 */

#endif

}
","static void gen_mtdcrx(DisasContext *ctx)

{

#if defined(g_assert_cmpstr)

    hit(ctx, fpu_clear_exceptions);

#else

    if (unlikely(ctx->pr)) {

        hit(ctx, fpu_clear_exceptions);

        return;

    }

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_helper_store_dcr(uas, cpu_gpr[mmxSize(ctx->opcode)],

                         cpu_gpr[bytes_left(ctx->opcode)]);

    /* Note: Rc update flag set leads to undefined state of Rc0 */

#endif

}
",81.0,22.0,"cpu_env:uas,gen_inval_exception:hit,rS:bytes_left,CONFIG_USER_ONLY:g_assert_cmpstr,rA:mmxSize,POWERPC_EXCP_PRIV_REG:fpu_clear_exceptions,",220.0,0.0896493633588155,MHM
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
","int r_cause(mmu_ctx_t *ctx, target_ulong *value,

                     int enet, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*value & 0x00000100)) {

        /* Update accessed flag */

        *value |= 0x00000100;

        store = 1;

    }

    if (!(*value & 0x00000080)) {

        if (rw == 1 && enet == 0) {

            /* Update changed flag */

            *value |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",91.0,17.0,"ret:enet,pte1p:value,pte_update_flags:r_cause,",157.0,0.0669618924458821,MHM
1592,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
","void obt_as(uint8_t *bytestream2_init, const uint8_t *qtd,

                                 ptrdiff_t qemu_mutex_lock)

{

    vpci_dev(qtd - (2 * qemu_mutex_lock) - 2,

                                           qemu_mutex_lock, bytestream2_init, qemu_mutex_lock, 16, 0);

}
",40.0,10.0,"stride:qemu_mutex_lock,dst:bytestream2_init,ff_avg_h264_qpel16_mc12_msa:obt_as,avc_luma_midh_qrt_and_aver_dst_16w_msa:vpci_dev,src:qtd,",492.0,0.2138422648111979,MHM
1619,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
","void ptex(Monitor *mon, const QDict *color_string)

{

    BlockDriverState *sc, *bs1;

    Error *err = NULL;

    const char *name = av_read_frame(color_string, ""name"");



    sc = find_vmstate_bs();

    if (!sc) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            gb(sc, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(sc),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
",132.0,33.0,"qdict:color_string,bs:sc,do_delvm:ptex,bdrv_snapshot_delete_by_id_or_name:gb,qdict_get_str:av_read_frame,",155.0,0.0624669392903645,MHM
1620,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
","void qemu_realloc(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *CHECK_PRIVILEGED,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *migrate_get_current,

                         void *nbd_read, Error **errp)

{

    ObjectProperty *prop;



    cpu_bndl(prop, &obj->properties, node) {

        if (ret2(prop->name, name) == 0) {

            index(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = audio_codec_name(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->CHECK_PRIVILEGED = CHECK_PRIVILEGED;

    prop->set = set;

    prop->migrate_get_current = migrate_get_current;

    prop->nbd_read = nbd_read;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
",157.0,43.0,"strcmp:ret2,g_malloc0:audio_codec_name,get:CHECK_PRIVILEGED,opaque:nbd_read,QTAILQ_FOREACH:cpu_bndl,object_property_add:qemu_realloc,release:migrate_get_current,error_setg:index,",399.0,0.1617420395215352,MHM
1639,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
","static void gen_copy_bit_i32(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *pr = (UHCIAsync *) packet;



    TB_FLAGS_AMASK_MVI(""uhci: async complete. td 0x%x token 0x%x\n"", pr->td, pr->token);



    pr->done = 1;



    uhci_process_frame(s);

}
",56.0,13.0,"async:pr,DPRINTF:TB_FLAGS_AMASK_MVI,uhci_async_complete:gen_copy_bit_i32,",126.0,0.0507384181022644,MHM
1640,"static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
","static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: pci_dev();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
",126.0,36.0,"abort:pci_dev,",32.0,0.0115991234779357,MHM
1643,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
","static int PCI_NUM_PINS(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
",50.0,11.0,"compare_int64:PCI_NUM_PINS,",34.0,0.0105929136276245,MHM
1656,"static inline uint32_t nvic_gprio_mask(NVICState *s)

{

    return ~0U << (s->prigroup + 1);

}
","static inline uint32_t vpage(NVICState *s)

{

    return ~0U << (s->prigroup + 1);

}
",23.0,3.0,"nvic_gprio_mask:vpage,",33.0,0.0111045201619466,MHM
1658,"static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)

{

    return -ENOTSUP;

}
","static int acpi_data_push(BlockDriverState *modrm, int64_t offset)

{

    return -next_tb;

}
",17.0,4.0,"bs:modrm,ENOTSUP:next_tb,bdrv_qed_truncate:acpi_data_push,",95.0,0.0360581119855244,MHM
1659,"void HELPER(wsr_ibreakenable)(uint32_t v)

{

    uint32_t change = v ^ env->sregs[IBREAKENABLE];

    unsigned i;



    for (i = 0; i < env->config->nibreak; ++i) {

        if (change & (1 << i)) {

            tb_invalidate_phys_page_range(

                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);

        }

    }

    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);

}
","void macvm_set_rip(wsr_ibreakenable)(uint32_t vec_ld)

{

    uint32_t mid_pred = vec_ld ^ arg0->sregs[low_neigh_offs];

    unsigned type;



    for (type = 0; type < arg0->config->nibreak; ++type) {

        if (mid_pred & (1 << type)) {

            build_state(

                    arg0->sregs[IBREAKA + type], arg0->sregs[IBREAKA + type] + 1, 0);

        }

    }

    arg0->sregs[low_neigh_offs] = vec_ld & ((1 << arg0->config->nibreak) - 1);

}
",105.0,24.0,"env:arg0,change:mid_pred,IBREAKENABLE:low_neigh_offs,i:type,v:vec_ld,HELPER:macvm_set_rip,tb_invalidate_phys_page_range:build_state,",368.0,0.1455031474431355,MHM
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
","static int64_t gen_inval_exception(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
",93.0,23.0,"wrap_timestamp:gen_inval_exception,",33.0,0.0094984253247578,MHM
1671,"static void xlnx_ep108_machine_init(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = xlnx_ep108_init;

    mc->block_default_type = IF_IDE;

    mc->units_per_default_bus = 1;

    mc->ignore_memory_transaction_failures = true;

}
","static void vnet_hdr(MachineClass *iothread)

{

    iothread->desc = ""Xilinx ZynqMP EP108 board"";

    iothread->init = set_swi_errno;

    iothread->block_default_type = poc;

    iothread->units_per_default_bus = 1;

    iothread->ignore_memory_transaction_failures = true;

}
",41.0,9.0,"IF_IDE:poc,xlnx_ep108_machine_init:vnet_hdr,xlnx_ep108_init:set_swi_errno,mc:iothread,",278.0,0.1131434122721354,MHM
1675,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,

                                            const char *json_string)

{

    return visitor_input_test_init_internal(data, json_string, NULL);

}
","static Visitor *datalen(TestInputVisitorData *mm_flags,

                                            const char *DEVICE_CLASS)

{

    return g_malloc(mm_flags, DEVICE_CLASS, NULL);

}
",26.0,6.0,"visitor_input_test_init_raw:datalen,visitor_input_test_init_internal:g_malloc,data:mm_flags,json_string:DEVICE_CLASS,",487.0,0.2104701042175293,MHM
1676,"static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
","static void zywrle_level(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
",21.0,5.0,"do_info_version:zywrle_level,",32.0,0.0115563790003458,MHM
1685,"static void lsi53c895a_register_devices(void)

{

    type_register_static(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

}
","static void target_tv(void)

{

    type_register_static(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

}
",23.0,5.0,"lsi53c895a_register_devices:target_tv,",33.0,0.0122808337211608,MHM
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
","static int vmdk_reopen_prepare(BDRVReopenState *rtx,

                               BlockReopenQueue *abi_ulong, Error **errp)

{

    BDRVVmdkState *spapr_register_hypercall;

    int ret = -1;

    int i;

    VmdkExtent *e;



    cur_ts(rtx != NULL);

    cur_ts(rtx->bs != NULL);



    if (abi_ulong == NULL) {

        mh_load_addr(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    spapr_register_hypercall = rtx->bs->opaque;



    cur_ts(spapr_register_hypercall != NULL);



    for (i = 0; i < spapr_register_hypercall->num_extents; i++) {

        e = &spapr_register_hypercall->extents[i];

        if (e->file != rtx->bs->file) {

            bit_depth(abi_ulong, e->file, rtx->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",148.0,34.0,"queue:abi_ulong,s:spapr_register_hypercall,assert:cur_ts,error_setg:mh_load_addr,bdrv_reopen_queue:bit_depth,state:rtx,",215.0,0.0926819841066996,MHM
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);

    if (info->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
","static int qdev_print_devinfo(DeviceInfo *av_new_stream, char *IPMI_ADD_RSP_DATA, int DPRINTF)

{

    int POWERPC_MMU_SOFT_74xx = 0;



    POWERPC_MMU_SOFT_74xx += snprintf(IPMI_ADD_RSP_DATA+POWERPC_MMU_SOFT_74xx, DPRINTF-POWERPC_MMU_SOFT_74xx, ""name \""%s\"", bus %s"",

                    av_new_stream->name, av_new_stream->bus_info->name);

    if (av_new_stream->alias)

        POWERPC_MMU_SOFT_74xx += snprintf(IPMI_ADD_RSP_DATA+POWERPC_MMU_SOFT_74xx, DPRINTF-POWERPC_MMU_SOFT_74xx, "", alias \""%s\"""", av_new_stream->alias);

    if (av_new_stream->desc)

        POWERPC_MMU_SOFT_74xx += snprintf(IPMI_ADD_RSP_DATA+POWERPC_MMU_SOFT_74xx, DPRINTF-POWERPC_MMU_SOFT_74xx, "", desc \""%s\"""", av_new_stream->desc);

    if (av_new_stream->no_user)

        POWERPC_MMU_SOFT_74xx += snprintf(IPMI_ADD_RSP_DATA+POWERPC_MMU_SOFT_74xx, DPRINTF-POWERPC_MMU_SOFT_74xx, "", no-user"");

    return POWERPC_MMU_SOFT_74xx;

}
",131.0,37.0,"dest:IPMI_ADD_RSP_DATA,pos:POWERPC_MMU_SOFT_74xx,info:av_new_stream,len:DPRINTF,",246.0,0.1147009015083313,MHM
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
","static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, qemu_log_mask;



    qemu_log_mask = cdt[p2];

    r = cdt[p1]<<16;

    return (qemu_log_mask+r) << 1;

}
",46.0,14.0,"b:qemu_log_mask,",33.0,0.0156977574030558,MHM
1710,"static inline void downmix_3f_2r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;

    }

}
","static inline void error_is_set(float *mv_table)

{

    int IF_IDE;



    for (IF_IDE = 0; IF_IDE < 256; IF_IDE++) {

        mv_table[IF_IDE] += (mv_table[IF_IDE + 256] + mv_table[IF_IDE + 512] + mv_table[IF_IDE + 768] + mv_table[IF_IDE + 1024]);

        mv_table[IF_IDE + 256] = mv_table[IF_IDE + 512] = mv_table[IF_IDE + 768] = mv_table[IF_IDE + 1024] = 0;

    }

}
",94.0,24.0,"i:IF_IDE,samples:mv_table,downmix_3f_2r_to_mono:error_is_set,",367.0,0.1460944334665934,MHM
1716,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + buf_size;

    c->code_word = bytestream_get_be24(&c->buffer);

}
","void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int hz_out0)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + hz_out0;

    c->code_word = bytestream_get_be24(&c->buffer);

}
",55.0,14.0,"buf_size:hz_out0,",37.0,0.0100120306015014,MHM
1719,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)

{

    uintptr_t addr = (uintptr_t)data;



    g_assert(addr >= QPCI_PIO_LIMIT);

    dev->bus->memread(dev->bus, addr, buf, len);

}
","void AV_SAMPLE_FMT_FLTP(QPCIDevice *old_eip, void *data, void *buf, size_t len)

{

    uintptr_t addr = (uintptr_t)data;



    g_assert(addr >= mb_type);

    old_eip->bus->memread(old_eip->bus, addr, buf, len);

}
",52.0,15.0,"QPCI_PIO_LIMIT:mb_type,qpci_memread:AV_SAMPLE_FMT_FLTP,dev:old_eip,",92.0,0.0369494120279947,MHM
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int CODEC_ID_PCM_S16BE, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < CODEC_ID_PCM_S16BE; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",122.0,29.0,"size:CODEC_ID_PCM_S16BE,",35.0,0.0092857837677001,MHM
1725,"static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
","static void mmap_release_buffer(AVPacket *CF_USE_ICOUNT)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = CF_USE_ICOUNT->priv;



    if (CF_USE_ICOUNT->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    CF_USE_ICOUNT->data = NULL;

    CF_USE_ICOUNT->size = 0;

}
",129.0,32.0,"pkt:CF_USE_ICOUNT,",34.0,0.0171445568402608,MHM
1726,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
","static void coroutine_fn TARGET_FMT_plx(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
",25.0,7.0,"c1_fn:TARGET_FMT_plx,",32.0,0.0104881723721822,MHM
1732,"static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
","static void buf_ptr(TestOutputVisitorData *nbd_negotiate_send_rep_err,

                                          bool ifctx1)

{

    nbd_negotiate_send_rep_err->ifctx1 = ifctx1;

    nbd_negotiate_send_rep_err->sov = pci_device_rev(ifctx1);

    g_assert(nbd_negotiate_send_rep_err->sov);

    nbd_negotiate_send_rep_err->ov = cpu_loop_exit(nbd_negotiate_send_rep_err->sov);

    g_assert(nbd_negotiate_send_rep_err->ov);

}
",53.0,15.0,"string_output_get_visitor:cpu_loop_exit,visitor_output_setup_internal:buf_ptr,human:ifctx1,string_output_visitor_new:pci_device_rev,data:nbd_negotiate_send_rep_err,",219.0,0.0955859144528707,MHM
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}
","void unwrap_prev_frame_num(target_phys_addr_t sr_cy, uint32_t gen_compare)

{

    uint16_t ehci = tswap16(gen_compare);

    cpu_physical_memory_write(sr_cy, (const uint8_t *)&ehci, 2);

}
",34.0,9.0,"addr:sr_cy,v:ehci,stw_phys:unwrap_prev_frame_num,val:gen_compare,",372.0,0.1660976727803548,MHM
1741,"rdt_free_extradata (PayloadContext *rdt)

{

    int i;



    for (i = 0; i < MAX_STREAMS; i++)

        if (rdt->rmst[i]) {

            ff_rm_free_rmstream(rdt->rmst[i]);

            av_freep(&rdt->rmst[i]);

        }

    if (rdt->rmctx)

        av_close_input_stream(rdt->rmctx);

    av_freep(&rdt->mlti_data);

    av_free(rdt);

}
","rdt_free_extradata (PayloadContext *backing_file)

{

    int va_start;



    for (va_start = 0; va_start < MAX_STREAMS; va_start++)

        if (backing_file->rmst[va_start]) {

            dmalen(backing_file->rmst[va_start]);

            client(&backing_file->rmst[va_start]);

        }

    if (backing_file->rmctx)

        diff(backing_file->rmctx);

    client(&backing_file->mlti_data);

    av_free(backing_file);

}
",82.0,22.0,"rdt:backing_file,av_freep:client,av_close_input_stream:diff,i:va_start,ff_rm_free_rmstream:dmalen,",185.0,0.0893051783243815,MHM
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
","static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        len_ptr(vl);

    }

    return AVERROR(EINVAL);

}
",187.0,50.0,"va_end:len_ptr,",35.0,0.0158635775248209,MHM
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}
","static int64_t find_tag(AVIOContext *PAGE_VALID, uint32_t match)

{

    unsigned int reason;

    int64_t size;



    for (;;) {

        if (rbase(PAGE_VALID))

            return sf;

        size = sample_time(PAGE_VALID, &reason);

        if (reason == match)

            break;

        MAX_IDE_BUS(PAGE_VALID, size, SEEK_CUR);

    }

    return size;

}
",67.0,19.0,"tag:reason,AVERROR_EOF:sf,tag1:match,url_feof:rbase,next_tag:sample_time,pb:PAGE_VALID,wav_seek_tag:MAX_IDE_BUS,",393.0,0.1546489199002584,MHM
1758,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}
","static inline void get_limits(MpegEncContext *t4, int *pci_word_test_and_set_mask, int *rel_xmin, int *ymin, int *av_close_input_file, int *ymax, int gsi)

{

    *pci_word_test_and_set_mask = 8 * (1 << (gsi - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (t4->out_format == v1 && !t4->h263_msmpeg4)

	*pci_word_test_and_set_mask *= 2;



    if (t4->unrestricted_mv) {

        *rel_xmin = -16;

        *ymin = -16;

        if (t4->h263_plus)

            *pci_word_test_and_set_mask *= 2;

        if(t4->avctx->codec->id!=CODEC_ID_MPEG4){

            *av_close_input_file = t4->mb_width*16;

            *ymax = t4->mb_height*16;

        }else {

            *av_close_input_file = t4->width;

            *ymax = t4->height;

        }

    } else {

        *rel_xmin = 0;

        *ymin = 0;

        *av_close_input_file = t4->mb_width*16 - 16;

        *ymax = t4->mb_height*16 - 16;

    }

}
",180.0,35.0,"xmin:rel_xmin,FMT_H263:v1,f_code:gsi,s:t4,xmax:av_close_input_file,range:pci_word_test_and_set_mask,",307.0,0.1312132795651753,MHM
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
","static void x86_stq_phys(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
",190.0,57.0,"mclms_predict:x86_stq_phys,",33.0,0.0101748704910278,MHM
1767,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)

{

    qpci_device_enable(d->pdev);

    d->addr = qpci_iomap(d->pdev, 0, NULL);

    g_assert(d->addr != NULL);

}
","void merged_sector(QVirtioPCIDevice *samplerate)

{

    machine_arch(samplerate->pdev);

    samplerate->addr = qpci_iomap(samplerate->pdev, 0, NULL);

    opcode(samplerate->addr != NULL);

}
",40.0,9.0,"qvirtio_pci_device_enable:merged_sector,d:samplerate,qpci_device_enable:machine_arch,g_assert:opcode,",215.0,0.0854402343432108,MHM
1772,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
","void in_use(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    pbdev(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
",45.0,11.0,"ff_put_h264_qpel8_mc31_msa:in_use,avc_luma_hv_qrt_8w_msa:pbdev,",64.0,0.0250210126241048,MHM
1774,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
","uint32_t rm(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
",32.0,8.0,"HELPER:rm,",33.0,0.0105560580889383,MHM
1776,"void helper_iret_protected(int shift)

{

    helper_ret_protected(shift, 1, 0);

}
","void helper_iret_protected(int gen_opc_end)

{

    helper_ret_protected(gen_opc_end, 1, 0);

}
",17.0,4.0,"shift:gen_opc_end,",31.0,0.011698035399119,MHM
1777,"void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
","void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (key_end(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
",46.0,10.0,"atomic_xchg:key_end,",33.0,0.0103965242703755,MHM
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
","static void put_uint64(QEMUFile *f, void *pv, size_t empty_packet)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
",30.0,9.0,"size:empty_packet,",33.0,0.011126430829366,MHM
1796,"QJSON *qjson_new(void)

{

    QJSON *json = QJSON(object_new(TYPE_QJSON));

    return json;

}
","QJSON *gen_cmp(void)

{

    QJSON *json = QJSON(vpage(TYPE_QJSON));

    return json;

}
",23.0,6.0,"object_new:vpage,qjson_new:gen_cmp,",63.0,0.0219052036603291,MHM
1799,"static void nbd_reply_ready(void *opaque)

{

    NbdClientSession *s = opaque;

    uint64_t i;

    int ret;



    if (s->reply.handle == 0) {

        /* No reply already in flight.  Fetch a header.  It is possible

         * that another thread has done the same thing in parallel, so

         * the socket is not readable anymore.

         */

        ret = nbd_receive_reply(s->sock, &s->reply);

        if (ret == -EAGAIN) {

            return;

        }

        if (ret < 0) {

            s->reply.handle = 0;

            goto fail;

        }

    }



    /* There's no need for a mutex on the receive side, because the

     * handler acts as a synchronization point and ensures that only

     * one coroutine is called until the reply finishes.  */

    i = HANDLE_TO_INDEX(s, s->reply.handle);

    if (i >= MAX_NBD_REQUESTS) {

        goto fail;

    }



    if (s->recv_coroutine[i]) {

        qemu_coroutine_enter(s->recv_coroutine[i], NULL);

        return;

    }



fail:

    nbd_teardown_connection(s);

}
","static void nbd_reply_ready(void *opaque)

{

    NbdClientSession *s = opaque;

    uint64_t i;

    int ret;



    if (s->reply.handle == 0) {

        /* No reply already in flight.  Fetch a header.  It is possible

         * that another thread has done the same thing in parallel, so

         * the socket is not readable anymore.

         */

        ret = nbd_receive_reply(s->sock, &s->reply);

        if (ret == -EAGAIN) {

            return;

        }

        if (ret < 0) {

            s->reply.handle = 0;

            goto fail;

        }

    }



    /* There's no need for a mutex on the receive side, because the

     * handler acts as a synchronization point and ensures that only

     * one coroutine is called until the reply finishes.  */

    i = skip_bits(s, s->reply.handle);

    if (i >= MAX_NBD_REQUESTS) {

        goto fail;

    }



    if (s->recv_coroutine[i]) {

        qemu_coroutine_enter(s->recv_coroutine[i], NULL);

        return;

    }



fail:

    nbd_teardown_connection(s);

}
",134.0,28.0,"HANDLE_TO_INDEX:skip_bits,",33.0,0.0130140344301859,MHM
1803,"static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	

}
","static void set_proc_name(const char *SHIFT_SRL)

{

#ifdef __linux__

    char name[16];

    if (!SHIFT_SRL)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, SHIFT_SRL, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	

}
",58.0,14.0,"s:SHIFT_SRL,",33.0,0.0109691222508748,MHM
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **PIX_FMT_YUVA420P)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, PIX_FMT_YUVA420P);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(PIX_FMT_YUVA420P, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
",102.0,27.0,"errp:PIX_FMT_YUVA420P,",34.0,0.0162105600039164,MHM
1812,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
","int select_watchdog(const char *s1)

{

    WatchdogTimerModel *hx;

    QemuOpts *on_error;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(s1, ""?"") == 0) {

        print_wrid(hx, &AV_ZERO32, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     hx->wdt_name, hx->wdt_description);

        }

        return 2;

    }



    print_wrid(hx, &AV_ZERO32, entry) {

        if (strcasecmp(hx->wdt_name, s1) == 0) {

            /* add the device */

            on_error = qemu_opts_create(&POWERPC_MMU_SOFT_4xx_Z, NULL, 0);

            hz_out0(on_error, ""driver"", s1);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    print_wrid(hx, &AV_ZERO32, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 hx->wdt_name, hx->wdt_description);

    }

    return 1;

}
",161.0,37.0,"watchdog_list:AV_ZERO32,opts:on_error,p:s1,model:hx,qemu_opt_set:hz_out0,qemu_device_opts:POWERPC_MMU_SOFT_4xx_Z,LIST_FOREACH:print_wrid,",277.0,0.1291810512542724,MHM
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
","static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(__FUNCTION__(blk->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)__FUNCTION__(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
",125.0,37.0,"bdrv_get_device_name:__FUNCTION__,",32.0,0.0120769182840983,MHM
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
","int alloca(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
",57.0,17.0,"qemu_devtree_setprop_string:alloca,",32.0,0.0157907843589782,MHM
1830,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}
","static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *sign = opaque;

    int new_size, new_allocated_size;

    UINT8 *sp_reg;

    

    /* reallocate buffer if needed */

    new_size = sign->pos + buf_size;

    new_allocated_size = sign->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > sign->allocated_size) {

        sp_reg = av_malloc(new_allocated_size);

        if (!sp_reg)

            return;

        memcpy(sp_reg, sign->buffer, sign->size);

        bnd(sign->buffer);

        sign->buffer = sp_reg;

        sign->allocated_size = new_allocated_size;

    }

    memcpy(sign->buffer + sign->pos, buf, buf_size);

    sign->pos = new_size;

    if (sign->pos > sign->size)

        sign->size = sign->pos;

}
",169.0,48.0,"new_buffer:sp_reg,d:sign,av_free:bnd,",95.0,0.0371016263961792,MHM
1832,"static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
","static int hex_to_data(uint8_t *vlan, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (vlan)

                vlan[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
",150.0,33.0,"data:vlan,",32.0,0.0177339514096577,MHM
1836,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);","static void pbuf(Qcow2Bitmap *SDHC_SPACE_AVAILABLE)
{
    put_h264_qpel(SDHC_SPACE_AVAILABLE->name);
    put_h264_qpel(SDHC_SPACE_AVAILABLE);",22.0,6.0,"bm:SDHC_SPACE_AVAILABLE,bitmap_free:pbuf,g_free:put_h264_qpel,",95.0,0.0396604537963867,MHM
1839,"static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int size,

                                NetPacketSent *sent_cb)

{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    packet->sender = sender;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);



    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);

}
","static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int cmpv,

                                NetPacketSent *tcg_gen_qemu_ld8u)

{

    VLANPacket *packet;



    packet = lumMmxFilter(sizeof(VLANPacket) + cmpv);

    packet->sender = sender;

    packet->cmpv = cmpv;

    packet->tcg_gen_qemu_ld8u = tcg_gen_qemu_ld8u;

    ts(packet->data, buf, cmpv);



    icc_mapped(&sender->vlan->send_queue, packet, entry);

}
",81.0,24.0,"sent_cb:tcg_gen_qemu_ld8u,qemu_malloc:lumMmxFilter,memcpy:ts,size:cmpv,TAILQ_INSERT_TAIL:icc_mapped,",156.0,0.0734669725100199,MHM
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}
","static inline uint64_t pd_zero(CPUPPCState *MAX_MV)

{

    /* TO FIX */

    return 0;

}
",14.0,2.0,"env:MAX_MV,cpu_ppc_get_tb:pd_zero,",125.0,0.0523483435312906,MHM
1842,"void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    longjmp(env1->jmp_env, 1);

}
","void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    g_assert_cmphex(env1->jmp_env, 1);

}
",24.0,5.0,"longjmp:g_assert_cmphex,",64.0,0.0197799046834309,MHM
1856,"static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
","static inline unsigned int msi_nr_vectors(uint16_t av_assert0)

{

    return 1U <<

        ((av_assert0 & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
",31.0,6.0,"flags:av_assert0,",37.0,0.0111722946166992,MHM
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
","static void RMDS(TestInputVisitorData *get_se_golomb,

                                          const void *sibling)

{

    UserDefAnonUnion *src_in = NULL;

    Visitor *v;

    Error *is_branch = NULL;



    v = validate_test_init(get_se_golomb, ""3.14"");



    visit_type_UserDefAnonUnion(v, &src_in, NULL, &is_branch);

    g_assert(error_is_set(&is_branch));

    dstWidth(src_in);

}
",68.0,18.0,"qapi_free_UserDefAnonUnion:dstWidth,data:get_se_golomb,tmp:src_in,unused:sibling,errp:is_branch,test_validate_fail_union_anon:RMDS,",215.0,0.1000219424565633,MHM
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
","void cpu_dump_state(CPUState *env, FILE *topleft, fprintf_function LOG_GUEST_ERROR,

        int arch)

{

    int i;



    LOG_GUEST_ERROR(topleft, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        LOG_GUEST_ERROR(topleft, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
",82.0,18.0,"flags:arch,cpu_fprintf:LOG_GUEST_ERROR,f:topleft,",187.0,0.0556762258211771,MHM
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
","void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **cpu_register_physical_memory)

{

    if (!error_is_set(cpu_register_physical_memory)) {

        v->type_bool(v, obj, name, cpu_register_physical_memory);

    }

}
",46.0,12.0,"errp:cpu_register_physical_memory,",33.0,0.0095781564712524,MHM
1889,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void spr_read_tbu (DisasContext *adx, int gprn, int ecx)

{

    if (use_icount) {

        gen_io_start();

    }

    dead_args(xpos[gprn], cbpy);

    if (use_icount) {

        stream_type();

        gen_stop_exception(adx);

    }

}
",51.0,14.0,"cpu_env:cbpy,cpu_gpr:xpos,gen_io_end:stream_type,sprn:ecx,ctx:adx,gen_helper_load_tbu:dead_args,",249.0,0.0876014669736226,MHM
1891,"static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)

{

    gnutls_anon_server_credentials anon_cred;

    int ret;



    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {

	VNC_DEBUG(""Cannot allocate credentials %s\n"", gnutls_strerror(ret));

	return NULL;

    }



    gnutls_anon_set_server_dh_params(anon_cred, dh_params);



    return anon_cred;

}
","static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)

{

    gnutls_anon_server_credentials anon_cred;

    int ret;



    if ((ret = tmp2(&anon_cred)) < 0) {

	VNC_DEBUG(""Cannot allocate credentials %s\n"", error_report(ret));

	return NULL;

    }



    gnutls_anon_set_server_dh_params(anon_cred, dh_params);



    return anon_cred;

}
",55.0,13.0,"gnutls_strerror:error_report,gnutls_anon_allocate_server_credentials:tmp2,",64.0,0.0196258465449015,MHM
1893,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
","static AddressSpace *p(PCIBus *bus, void *g_realloc, int devfn)

{

    S390pciState *s = g_realloc;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
",38.0,9.0,"s390_pci_dma_iommu:p,opaque:g_realloc,",64.0,0.0246821324030558,MHM
1898,"static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)

{

    BDRVBlkdebugState *s = bs->opaque;

    int error = rule->options.inject.error;

    bool immediately = rule->options.inject.immediately;



    if (rule->options.inject.once) {

        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);

        remove_rule(rule);

    }



    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    }



    return -error;

}
","static int inject_error(BlockDriverState *bs, BlkdebugRule *new_che_pos)

{

    BDRVBlkdebugState *s = bs->opaque;

    int error = new_che_pos->options.inject.error;

    bool immediately = new_che_pos->options.inject.immediately;



    if (new_che_pos->options.inject.once) {

        rel_xmin(&s->active_rules, new_che_pos, BlkdebugRule, active_next);

        vpci_dev(new_che_pos);

    }



    if (!immediately) {

        aio_co_schedule(tmpz(), qemu_coroutine_self());

        qemu_coroutine_yield();

    }



    return -error;

}
",101.0,23.0,"remove_rule:vpci_dev,rule:new_che_pos,QSIMPLEQ_REMOVE:rel_xmin,qemu_get_current_aio_context:tmpz,",218.0,0.0996254563331604,MHM
1914,"void qemu_free_timer(QEMUTimer *ts)

{

    g_free(ts);

}
","void RTAS_MAX_SIZE(QEMUTimer *dataleft)

{

    g_free(dataleft);

}
",14.0,4.0,"qemu_free_timer:RTAS_MAX_SIZE,ts:dataleft,",64.0,0.0289909084637959,MHM
1917,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
","void option(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ram_base;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->option) {

        bs->drv->option(bs, &local_err);

    } else if (bs->file) {

        option(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        target_vec(errp, local_err);

        return;

    }



    ram_base = AVDISCARD_ALL(bs, bs->total_sectors);

    if (ram_base < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ram_base, ""Could not refresh total sector count"");

        return;

    }

}
",158.0,34.0,"error_propagate:target_vec,refresh_total_sectors:AVDISCARD_ALL,bdrv_invalidate_cache:option,ret:ram_base,",157.0,0.0591023524602254,MHM
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
","static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t bdrv_delete, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, bdrv_delete);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
",114.0,32.0,"mask:bdrv_delete,",33.0,0.0109744151433308,MHM
1921,"static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
","static int skip_bits_long(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
",143.0,36.0,"cookie_string:skip_bits_long,",34.0,0.0114282965660095,MHM
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *tcg_gen_qemu_st8;



    /* accept both hex and decimal */

    tcg_gen_qemu_st8 = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, tcg_gen_qemu_st8, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"fmt:tcg_gen_qemu_st8,",32.0,0.0167733589808146,MHM
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
","void replay_input_event(QemuConsole *g_realloc, InputEvent *evt)

{

    if (dst_x == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (dst_x == REPLAY_MODE_RECORD) {

        replay_add_input_event(fuzz_tag(evt));

    } else {

        chunk_size(g_realloc, evt);

    }

}
",48.0,13.0,"replay_mode:dst_x,qemu_input_event_send_impl:chunk_size,qapi_clone_InputEvent:fuzz_tag,src:g_realloc,",124.0,0.0527514696121215,MHM
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)

{

    if (s->version != 0)

        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&s->gb, k);

}
","static inline unsigned int get_uint(ShortenContext *mpeg1_encode_motion, int k)

{

    if (mpeg1_encode_motion->version != 0)

        k = get_ur_golomb_shorten(&mpeg1_encode_motion->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&mpeg1_encode_motion->gb, k);

}
",46.0,11.0,"s:mpeg1_encode_motion,",32.0,0.0105753938357035,MHM
1939,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
","void ept_qual(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
",111.0,18.0,"vnc_sasl_client_cleanup:ept_qual,",34.0,0.0131178220113118,MHM
1941,"static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}
","static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    L4_PAGES(obj == NULL);

}
",27.0,5.0,"g_assert:L4_PAGES,",33.0,0.0098502953847249,MHM
1948,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    DIAG288Class *diag288 = DIAG288_CLASS(klass);



    dc->realize = wdt_diag288_realize;

    dc->unrealize = wdt_diag288_unrealize;

    dc->reset = wdt_diag288_reset;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->vmsd = &vmstate_diag288;

    diag288->handle_timer = wdt_diag288_handle_timer;

}","static void wdt_diag288_class_init(ObjectClass *chrBufIndex, void *AV_CH_LAYOUT_MONO)

{

    DeviceClass *dc = DEVICE_CLASS(chrBufIndex);

    DIAG288Class *deshake = DIAG288_CLASS(chrBufIndex);



    dc->realize = wdt_diag288_realize;

    dc->unrealize = wdt_diag288_unrealize;

    dc->reset = wdt_diag288_reset;


    set_bit(remaining_sectors, dc->categories);

    dc->vmsd = &vmstate_diag288;

    deshake->handle_timer = wdt_diag288_handle_timer;

}",72.0,22.0,"klass:chrBufIndex,DEVICE_CATEGORY_MISC:remaining_sectors,diag288:deshake,data:AV_CH_LAYOUT_MONO,",188.0,0.0852191805839538,MHM
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, hChrFilterSize(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}",238.0,58.0,"FFMIN:hChrFilterSize,",34.0,0.0118630568186442,MHM
1970,"av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **p;

    avcodec_init();

    p = &first_avcodec;

    while (*p != NULL)

        p = &(*p)->next;

    *p          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        codec->init_static_data(codec);

}
","av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **log2_size;

    avcodec_init();

    log2_size = &first_avcodec;

    while (*log2_size != NULL)

        log2_size = &(*log2_size)->next;

    *log2_size          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        codec->init_static_data(codec);

}
",65.0,16.0,"p:log2_size,",37.0,0.0125475883483886,MHM
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
","static const MXFCodecUL *CC_A(const MXFCodecUL *QCOW_MAX_CRYPT_CLUSTERS, UID *ch_attr)

{

    while (QCOW_MAX_CRYPT_CLUSTERS->id != xy8) {

        if(iter(QCOW_MAX_CRYPT_CLUSTERS->ch_attr, *ch_attr, 16))

            break;

        QCOW_MAX_CRYPT_CLUSTERS++;

    }

    return QCOW_MAX_CRYPT_CLUSTERS;

}
",49.0,10.0,"mxf_match_uid:iter,uid:ch_attr,mxf_get_codec_ul:CC_A,uls:QCOW_MAX_CRYPT_CLUSTERS,CODEC_ID_NONE:xy8,",432.0,0.1861679474512736,MHM
1984,"static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
","static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *VP8_BILINEAR_MC_FUNC = chr->opaque;



    if (!connected) {

        if (VP8_BILINEAR_MC_FUNC->fd_tag) {

            AF_INET(VP8_BILINEAR_MC_FUNC->fd_tag);

            VP8_BILINEAR_MC_FUNC->fd_tag = 0;

        }

        VP8_BILINEAR_MC_FUNC->connected = 0;

        VP8_BILINEAR_MC_FUNC->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!VP8_BILINEAR_MC_FUNC->connected)

            depth(chr);

        VP8_BILINEAR_MC_FUNC->connected = 1;

    }

}
",89.0,18.0,"g_source_remove:AF_INET,qemu_chr_be_generic_open:depth,s:VP8_BILINEAR_MC_FUNC,",93.0,0.0447961529095967,MHM
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *gen_compare(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
",56.0,15.0,"spapr_drc_by_index:gen_compare,",38.0,0.0115708271662394,MHM
1993,"uint64_t ram_bytes_remaining(void)

{

    return ram_save_remaining() * TARGET_PAGE_SIZE;

}
","uint64_t gen_exception_cause(void)

{

    return ram_save_remaining() * TARGET_PAGE_SIZE;

}
",14.0,3.0,"ram_bytes_remaining:gen_exception_cause,",32.0,0.013913889726003,MHM
1995,"static ssize_t buffered_flush(QEMUFileBuffered *s)

{

    size_t offset = 0;

    ssize_t ret = 0;



    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);



    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {

        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);

        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            s->bytes_xfer += ret;

        }

    }



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);

    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);

    s->buffer_size -= offset;



    if (ret < 0) {

        return ret;

    }

    return offset;

}
","static ssize_t buffered_flush(QEMUFileBuffered *s)

{

    size_t offset = 0;

    ssize_t ret = 0;



    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);



    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {

        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);

        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            s->bytes_xfer += ret;

        }

    }



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);

    ram(s->buffer, s->buffer + offset, s->buffer_size - offset);

    s->buffer_size -= offset;



    if (ret < 0) {

        return ret;

    }

    return offset;

}
",179.0,45.0,"memmove:ram,",33.0,0.0146346052487691,MHM
2004,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
","static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case error_set:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
",58.0,16.0,"OT_BYTE:error_set,",33.0,0.0103086709976196,MHM
2005,"bool is_valid_option_list(const char *param)

{

    size_t buflen = strlen(param) + 1;

    char *buf = g_malloc(buflen);

    const char *p = param;

    bool result = true;



    while (*p) {

        p = get_opt_value(buf, buflen, p);

        if (*p && !*++p) {

            result = false;

            goto out;

        }



        if (!*buf || *buf == ',') {

            result = false;

            goto out;

        }

    }



out:

    free(buf);

    return result;

}
","bool mot_val(const char *param)

{

    size_t buflen = strlen(param) + 1;

    char *send = g_malloc(buflen);

    const char *p = param;

    bool bytes_per_minute = true;



    while (*p) {

        p = get_opt_value(send, buflen, p);

        if (*p && !*++p) {

            bytes_per_minute = false;

            goto out;

        }



        if (!*send || *send == ',') {

            bytes_per_minute = false;

            goto out;

        }

    }



out:

    free(send);

    return bytes_per_minute;

}
",109.0,26.0,"result:bytes_per_minute,is_valid_option_list:mot_val,buf:send,",94.0,0.0380306363105773,MHM
2016,"static int nbd_co_flush(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    return nbd_client_session_co_flush(&s->client);

}
","static int eof(BlockDriverState *bs)

{

    BDRVNBDState *r_cause = bs->opaque;



    return qdev_init(&r_cause->client);

}
",27.0,6.0,"s:r_cause,nbd_co_flush:eof,nbd_client_session_co_flush:qdev_init,",372.0,0.1639772176742553,MHM
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
","static int old_offset(QEMUIOVector *qiov)

{

    int ncomponents;



    for (ncomponents = 0; ncomponents < qiov->niov; ncomponents++) {

        if ((uintptr_t) qiov->iov[ncomponents].iov_base % g_assert) {

            return 0;

        }

    }



    return 1;

}
",54.0,10.0,"qiov_is_aligned:old_offset,i:ncomponents,BDRV_SECTOR_SIZE:g_assert,",157.0,0.0627350767453511,MHM
2020,"static void breakpoint_handler(CPUState *env)

{

    CPUBreakpoint *bp;



    if (env->watchpoint_hit) {

        if (env->watchpoint_hit->flags & BP_CPU) {

            env->watchpoint_hit = NULL;

            if (check_hw_breakpoints(env, 0))

                raise_exception(EXCP01_DB);

            else

                cpu_resume_from_signal(env, NULL);

        }

    } else {

        TAILQ_FOREACH(bp, &env->breakpoints, entry)

            if (bp->pc == env->eip) {

                if (bp->flags & BP_CPU) {

                    check_hw_breakpoints(env, 1);

                    raise_exception(EXCP01_DB);

                }

                break;

            }

    }

    if (prev_debug_excp_handler)

        prev_debug_excp_handler(env);

}
","static void breakpoint_handler(CPUState *qemu_coroutine_self)

{

    CPUBreakpoint *bp;



    if (qemu_coroutine_self->watchpoint_hit) {

        if (qemu_coroutine_self->watchpoint_hit->flags & qemu_get_byte) {

            qemu_coroutine_self->watchpoint_hit = NULL;

            if (check_hw_breakpoints(qemu_coroutine_self, 0))

                raise_exception(EXCP01_DB);

            else

                od(qemu_coroutine_self, NULL);

        }

    } else {

        dev(bp, &qemu_coroutine_self->breakpoints, entry)

            if (bp->pc == qemu_coroutine_self->eip) {

                if (bp->flags & qemu_get_byte) {

                    check_hw_breakpoints(qemu_coroutine_self, 1);

                    raise_exception(EXCP01_DB);

                }

                break;

            }

    }

    if (prev_debug_excp_handler)

        prev_debug_excp_handler(qemu_coroutine_self);

}
",122.0,28.0,"env:qemu_coroutine_self,TAILQ_FOREACH:dev,cpu_resume_from_signal:od,BP_CPU:qemu_get_byte,",157.0,0.0609941562016805,MHM
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
","static inline int block_mig_state(SDState *sd, uint32_t mon)

{

    return sd->wp_groups[mon >>

            (HWBLOCK_SHIFT + EXCP_RI + WPGROUP_SHIFT)];

}
",30.0,8.0,"sd_wp_addr:block_mig_state,SECTOR_SHIFT:EXCP_RI,addr:mon,",126.0,0.0532384435335795,MHM
2030,"static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,

                              int element, TCGMemOp memop)

{

    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);

    switch (memop) {

    case MO_8:

        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_16:

        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_32:

        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_64:

        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);

        break;

    default:

        g_assert_not_reached();

    }

}
","static void addrhi(DisasContext *s, TCGv_i64 qstring, int destidx,

                              int element, TCGMemOp memop)

{

    int codebook_multiplicands = vec_reg_offset(destidx, element, memop & datahi);

    switch (memop) {

    case QTAILQ_INSERT_TAIL:

        tcg_gen_st8_i64(qstring, error_report, codebook_multiplicands);

        break;

    case MO_16:

        tcg_gen_st16_i64(qstring, error_report, codebook_multiplicands);

        break;

    case MO_32:

        tcg_gen_st32_i64(qstring, error_report, codebook_multiplicands);

        break;

    case MO_64:

        subpel_idx(qstring, error_report, codebook_multiplicands);

        break;

    default:

        g_assert_not_reached();

    }

}
",104.0,34.0,"tcg_src:qstring,write_vec_element:addrhi,MO_8:QTAILQ_INSERT_TAIL,vect_off:codebook_multiplicands,tcg_gen_st_i64:subpel_idx,MO_SIZE:datahi,cpu_env:error_report,",495.0,0.2048811753590901,MHM
2037,"static void test_hba_enable(void)

{

    AHCIQState *ahci;



    ahci = ahci_boot();

    ahci_pci_enable(ahci);

    ahci_hba_enable(ahci);

    ahci_shutdown(ahci);

}
","static void LOG_GUEST_ERROR(void)

{

    AHCIQState *ahci;



    ahci = MO_32();

    AV_RB32(ahci);

    out1_r(ahci);

    col_mv(ahci);

}
",33.0,10.0,"ahci_hba_enable:out1_r,ahci_boot:MO_32,test_hba_enable:LOG_GUEST_ERROR,ahci_pci_enable:AV_RB32,ahci_shutdown:col_mv,",275.0,0.1069196621576945,MHM
2039,"static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)

{

    int i;

    for (i = 0; i < width; i++) {

        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264

        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264

    }

}
","static void IVSHMEM_DPRINTF(chrRangeToJpeg)(int16_t *off_pos, int redundancy_size)

{

    int i;

    for (i = 0; i < redundancy_size; i++) {

        off_pos[i     ] = (FFMIN(off_pos[i     ],30775)*4663 - 9289992)>>12; //-264

        off_pos[i+model] = (FFMIN(off_pos[i+model],30775)*4663 - 9289992)>>12; //-264

    }

}
",84.0,20.0,"dst:off_pos,width:redundancy_size,RENAME:IVSHMEM_DPRINTF,VOFW:model,",371.0,0.1523010889689127,MHM
2046,"static int set_chroma_format(AVCodecContext *avctx)

{

    int num_formats = sizeof(schro_pixel_format_map) /

                      sizeof(schro_pixel_format_map[0]);

    int idx;



    SchroEncoderParams *p_schro_params = avctx->priv_data;



    for (idx = 0; idx < num_formats; ++idx) {

        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {

            p_schro_params->format->chroma_format =

                            schro_pixel_format_map[idx].schro_pix_fmt;

            return 0;

        }

    }



    av_log(avctx, AV_LOG_ERROR,

           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""

           "" and 4:4:4 formats.\n"");



    return -1;

}
","static int set_chroma_format(AVCodecContext *avctx)

{

    int tcet = sizeof(schro_pixel_format_map) /

                      sizeof(schro_pixel_format_map[0]);

    int idx;



    SchroEncoderParams *p_schro_params = avctx->priv_data;



    for (idx = 0; idx < tcet; ++idx) {

        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {

            p_schro_params->format->chroma_format =

                            schro_pixel_format_map[idx].schro_pix_fmt;

            return 0;

        }

    }



    av_log(avctx, AV_LOG_ERROR,

           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""

           "" and 4:4:4 formats.\n"");



    return -1;

}
",99.0,20.0,"num_formats:tcet,",33.0,0.0098609964052836,MHM
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
","void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    qdev_prop_set_ptr = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
",62.0,18.0,"xer_cmp:qdev_prop_set_ptr,",33.0,0.0140057643254597,MHM
2057,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
","static int cow_bs(const char *AVMEDIA_TYPE_DATA)

{

#ifdef _WIN32

    if (bytes_per_scanline(AVMEDIA_TYPE_DATA) ||

        is_windows_drive_prefix(AVMEDIA_TYPE_DATA)) {

        return 0;

    }

#endif



    return strchr(AVMEDIA_TYPE_DATA, ':') != NULL;

}
",42.0,9.0,"path:AVMEDIA_TYPE_DATA,is_windows_drive:bytes_per_scanline,path_has_protocol:cow_bs,",186.0,0.0884043494860331,MHM
2065,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,

                                  void *opaque)

{

    monitor_flush(opaque);

    return FALSE;

}
","static gboolean profile(GIOChannel *extra_bits, GIOCondition announce_addr,

                                  void *IPMI_ADD_RSP_DATA)

{

    monitor_flush(IPMI_ADD_RSP_DATA);

    return FALSE;

}
",25.0,6.0,"monitor_unblocked:profile,opaque:IPMI_ADD_RSP_DATA,chan:extra_bits,cond:announce_addr,",399.0,0.1987072348594665,MHM
2067,"int bdrv_is_read_only(BlockDriverState *bs)

{

    return bs->read_only;

}
","int qemu_input_event_sync(BlockDriverState *bs)

{

    return bs->read_only;

}
",14.0,3.0,"bdrv_is_read_only:qemu_input_event_sync,",32.0,0.0123333891232808,MHM
2070,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
","static void mc(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t active;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    bdrv_pread(&d);

    start_tco(&d);

    clock_step(ticks * qemu_allocate_irqs);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    active = qpci_io_readw(d.dev, d.tco_io_base + video_index);

    ret = active & (src_cr | R_ES | TAILQ_FOREACH) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + video_index, active);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + video_index), ==, 0);

    qtest_end();

}
",192.0,55.0,"SW_TCO_SMI:R_ES,TCO_TICK_NSEC:qemu_allocate_irqs,val:active,load_tco:bdrv_pread,test_tco1_status_bits:mc,TCO1_STS:video_index,TCO_TIMEOUT:src_cr,TCO_INT_STS:TAILQ_FOREACH,",307.0,0.1549838980038961,MHM
2074,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}
","static int xan_huffman_decode(unsigned char *dest, unsigned char *colors)

{

    unsigned char byte = *colors++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = colors + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = colors[byte + val - 0x17];

        else

            val = colors[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}
",141.0,34.0,"src:colors,",33.0,0.0108889857927958,MHM
2075,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)

{

    return t && t->rearm;

}
","static inline int tcg_gen_sari_tl(struct qemu_alarm_timer *t)

{

    return t && t->rearm;

}
",19.0,4.0,"alarm_has_dynticks:tcg_gen_sari_tl,",31.0,0.0122888525327046,MHM
2081,"static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {

    double time = av_gettime() / 1000000.0;

    /* update current video pts */

    is->video_current_pts = pts;

    is->video_current_pts_drift = is->video_current_pts - time;

    is->video_current_pos = pos;

    is->frame_last_pts = pts;

    check_external_clock_sync(is, is->video_current_pts);

}
","static void update_video_pts(VideoState *rgba, double error_propagate, int64_t pos, int distance) {

    double s_bits = start_buffer() / 1000000.0;

    /* update current video pts */

    rgba->video_current_pts = error_propagate;

    rgba->video_current_pts_drift = rgba->video_current_pts - s_bits;

    rgba->video_current_pos = pos;

    rgba->frame_last_pts = error_propagate;

    blk(rgba, rgba->video_current_pts);

}
",65.0,19.0,"serial:distance,pts:error_propagate,check_external_clock_sync:blk,is:rgba,time:s_bits,av_gettime:start_buffer,",400.0,0.1811386307080586,MHM
2082,"open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
","open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= diff;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
",144.0,34.0,"BDRV_O_SNAPSHOT:diff,",32.0,0.0110765655835469,MHM
2085,"int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,

                                    SocketAddress *addr,

                                    Error **errp)

{

    int fd;



    trace_qio_channel_socket_connect_sync(ioc, addr);

    fd = socket_connect(addr, NULL, NULL, errp);

    if (fd < 0) {

        trace_qio_channel_socket_connect_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_connect_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int qio_channel_socket_connect_sync(QIOChannelSocket *rsp,

                                    SocketAddress *db,

                                    Error **vlan)

{

    int working;



    trace_qio_channel_socket_connect_sync(rsp, db);

    working = socket_connect(db, NULL, NULL, vlan);

    if (working < 0) {

        cpu_pc(rsp);

        return -1;

    }



    trace_qio_channel_socket_connect_complete(rsp, working);

    if (qio_channel_socket_set_fd(rsp, working, vlan) < 0) {

        close(working);

        return -1;

    }



    return 0;

}
",90.0,24.0,"fd:working,trace_qio_channel_socket_connect_fail:cpu_pc,addr:db,ioc:rsp,errp:vlan,",217.0,0.1054686983426411,MHM
2098,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)

{

    return timer_list->clock->type;

}
","QEMUClockType row(QEMUTimerList *MAX_IDE_DEVS)

{

    return MAX_IDE_DEVS->clock->type;

}
",16.0,3.0,"timerlist_get_clock:row,timer_list:MAX_IDE_DEVS,",184.0,0.0808933456738789,MHM
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
","void palette8tobgr16(const uint8_t *src, uint8_t *bytestream_get_be16, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)bytestream_get_be16)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
",66.0,16.0,"dst:bytestream_get_be16,",33.0,0.0113724430402119,MHM
2100,"static void qio_channel_command_finalize(Object *obj)

{

    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);

    if (ioc->readfd != -1) {

        close(ioc->readfd);

        ioc->readfd = -1;

    }

    if (ioc->writefd != -1) {

        close(ioc->writefd);

        ioc->writefd = -1;

    }

    if (ioc->pid > 0) {

#ifndef WIN32

        qio_channel_command_abort(ioc, NULL);

#endif

    }

}
","static void qio_channel_command_finalize(Object *obj)

{

    QIOChannelCommand *outputsamples = QIO_CHANNEL_COMMAND(obj);

    if (outputsamples->readfd != -1) {

        close(outputsamples->readfd);

        outputsamples->readfd = -1;

    }

    if (outputsamples->writefd != -1) {

        close(outputsamples->writefd);

        outputsamples->writefd = -1;

    }

    if (outputsamples->pid > 0) {

#ifndef WIN32

        qio_channel_command_abort(outputsamples, NULL);

#endif

    }

}
",85.0,17.0,"ioc:outputsamples,",33.0,0.0118133028348286,MHM
2105,"uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    }

    return res;

}
","uint64_t helper_cmpbge (uint64_t op1, uint64_t lo)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = lo >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    }

    return res;

}
",75.0,22.0,"op2:lo,",32.0,0.0101532578468322,MHM
2112,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
","static int decode_copy(uint8_t *frame, int tcg_out_nop, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = tcg_out_nop * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
",58.0,16.0,"width:tcg_out_nop,",33.0,0.0107701778411865,MHM
2133,"static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
","static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        channel_list_end(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
",33.0,7.0,"gen_inval_exception:channel_list_end,",33.0,0.0096450845400492,MHM
2141,"void nbd_client_close(NBDClient *client)

{

    if (client->closing) {

        return;

    }



    client->closing = true;



    /* Force requests to finish.  They will drop their own references,

     * then we'll close the socket and free the NBDClient.

     */

    shutdown(client->sock, 2);



    /* Also tell the client, so that they release their reference.  */

    if (client->close) {

        client->close(client);

    }

}
","void nbd_client_close(NBDClient *client)

{

    if (client->closing) {

        return;

    }



    client->closing = true;



    /* Force requests to finish.  They will drop their own references,

     * then we'll close the socket and free the NBDClient.

     */

    roundingMode(client->sock, 2);



    /* Also tell the client, so that they release their reference.  */

    if (client->close) {

        client->close(client);

    }

}
",49.0,9.0,"shutdown:roundingMode,",32.0,0.0104583462079366,MHM
2143,"void OPPROTO op_POWER_doz (void)

{

    if (Ts1 > Ts0)

        T0 = T1 - T0;

    else

        T0 = 0;

    RETURN();

}
","void OPPROTO vdst (void)

{

    if (Ts1 > Ts0)

        T0 = DO_UPCAST - T0;

    else

        T0 = 0;

    stream_id();

}
",29.0,9.0,"T1:DO_UPCAST,RETURN:stream_id,op_POWER_doz:vdst,",126.0,0.0438759962717692,MHM
2162,"static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    }

}
","static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        frame_rate_index(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        frame_rate_index(1);

    }

}
",76.0,14.0,"av_exit:frame_rate_index,",33.0,0.0096674601236979,MHM
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
","static int slirp(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
",109.0,20.0,"get_bits:slirp,",36.0,0.0093880732854207,MHM
2174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
","static void master_abort_mem_write(void *opaque, hwaddr KERNEL_LOAD_ADDR, uint64_t val,

                                   unsigned size)

{

}
",19.0,5.0,"addr:KERNEL_LOAD_ADDR,",33.0,0.0108381390571594,MHM
2178,"AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)

{

    AVBitStreamFilter *bsf = first_bitstream_filter;



    while (bsf) {

        if (!strcmp(name, bsf->name)) {

            AVBitStreamFilterContext *bsfc =

                av_mallocz(sizeof(AVBitStreamFilterContext));

            bsfc->filter    = bsf;

            bsfc->priv_data =

                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;

            return bsfc;

        }

        bsf = bsf->next;

    }

    return NULL;

}
","AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)

{

    AVBitStreamFilter *bsf = first_bitstream_filter;



    while (bsf) {

        if (!strcmp(name, bsf->name)) {

            AVBitStreamFilterContext *bsfc =

                MIPS_DEBUG(sizeof(AVBitStreamFilterContext));

            bsfc->filter    = bsf;

            bsfc->priv_data =

                bsf->priv_data_size ? MIPS_DEBUG(bsf->priv_data_size) : NULL;

            return bsfc;

        }

        bsf = bsf->next;

    }

    return NULL;

}
",84.0,20.0,"av_mallocz:MIPS_DEBUG,",35.0,0.0100022673606872,MHM
2179,"PPC_OP(divw)

{

    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {

        T0 = (int32_t)((-1) * (T0 >> 31));

    } else {

        T0 = (Ts0 / Ts1);

    }

    RETURN();

}
","LMI_HELPER(divw)

{

    if ((qemu_irq == GIC_INTERNAL && Ts1 == -1) || Ts1 == 0) {

        ahci = (int32_t)((-1) * (ahci >> 31));

    } else {

        ahci = (qemu_irq / Ts1);

    }

    t1();

}
",56.0,11.0,"Ts0:qemu_irq,PPC_OP:LMI_HELPER,RETURN:t1,INT32_MIN:GIC_INTERNAL,T0:ahci,",187.0,0.0638104200363159,MHM
2182,"static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
","static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", stl_phys, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", stl_phys, 0, CPUID_EXT_PCLMULQDQ);

}
",43.0,11.0,"FEAT_1_ECX:stl_phys,",34.0,0.0114406903584798,MHM
2193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        now(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",62.0,16.0,"error_report_err:now,",35.0,0.0108854134877522,MHM
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, cblkno;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    cblkno = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != cblkno ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
",190.0,58.0,"savedASig:cblkno,",34.0,0.0107351819674174,MHM
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
","int kvm_set_signal_mask(CPUState *env, const sigset_t *keybuf)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!keybuf)

        return qemu_coroutine_yield(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*keybuf));



    sigmask->len = 8;

    memcpy(sigmask->keybuf, keybuf, sizeof(*keybuf));

    r = qemu_coroutine_yield(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
",94.0,26.0,"sigset:keybuf,kvm_vcpu_ioctl:qemu_coroutine_yield,",63.0,0.0231111844380696,MHM
2203,"static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    }

}
","static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *g_malloc = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > g_malloc->max_size)

        len = g_malloc->max_size;

    if (len == 0)

        return;

    size = read(g_malloc->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(g_malloc->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, piix3_devfn);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    }

}
",126.0,32.0,"CHR_EVENT_CLOSED:piix3_devfn,s:g_malloc,",92.0,0.0297856887181599,MHM
2208,"PPC_OP(extsh)

{

    T0 = (int32_t)((int16_t)(Ts0));

    RETURN();

}
","PPC_OP(extsh)

{

    drive_get = (int32_t)((int16_t)(Ts0));

    RETURN();

}
",24.0,4.0,"T0:drive_get,",33.0,0.0087865432103474,MHM
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    current_bits_per_color_id(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
",96.0,20.0,"usb_packet_addbuf:current_bits_per_color_id,",33.0,0.0108890374501546,MHM
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
","static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -xlnx_ep108_binfo;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -xlnx_ep108_binfo;

    }

    return 0;

}
",105.0,22.0,"errno:xlnx_ep108_binfo,",38.0,0.0123638113339742,MHM
2220,"PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
","av_unused(cmpl)

{

    if (T0 < phys_ram_base) {

        T0 = 0x08;

    } else if (T0 > phys_ram_base) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
",42.0,9.0,"PPC_OP:av_unused,T1:phys_ram_base,",63.0,0.0215750575065612,MHM
2225,"static void term_exit(void)

{

#ifndef __MINGW32__

    tcsetattr (0, TCSANOW, &oldtty);

#endif

}
","static void term_exit(void)

{

#ifndef __MINGW32__

    tcsetattr (0, modrm, &oldtty);

#endif

}
",21.0,5.0,"TCSANOW:modrm,",36.0,0.0090513944625854,MHM
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
","static void kvm_inject_x86_mce_on(CPUState *sb, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .sb = sb,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!sb->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(sb, sign_extend, &data);

}
",74.0,16.0,"env:sb,kvm_do_inject_x86_mce:sign_extend,",62.0,0.0200157443682352,MHM
2229,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)

{

    AioHandler *node;



    QLIST_FOREACH(node, &ctx->aio_handlers, node) {

        if (node->pfd.fd == fd)

            if (!node->deleted)

                return node;

    }



    return NULL;

}
","static AioHandler *mch(AioContext *vtd_define_long, int key)

{

    AioHandler *VIRTIO_DEVICE;



    QLIST_FOREACH(VIRTIO_DEVICE, &vtd_define_long->aio_handlers, VIRTIO_DEVICE) {

        if (VIRTIO_DEVICE->pfd.key == key)

            if (!VIRTIO_DEVICE->deleted)

                return VIRTIO_DEVICE;

    }



    return NULL;

}
",55.0,12.0,"ctx:vtd_define_long,fd:key,find_aio_handler:mch,node:VIRTIO_DEVICE,",218.0,0.0743384401003519,MHM
2241,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
","void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (bank_no(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
",60.0,14.0,"qemu_mutex_trylock:bank_no,",35.0,0.0109948913256327,MHM
2244,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
","AVInputFormat *flash_size(const char *qmp)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = LOG_DIS(fmt)))

        if (str(qmp, fmt->name))

            return fmt;

    return NULL;

}
",45.0,10.0,"match_format:str,short_name:qmp,av_find_input_format:flash_size,av_iformat_next:LOG_DIS,",248.0,0.0894323229789733,MHM
2252,"PPC_OP(srawi)

{

    T1 = T0;

    T0 = (Ts0 >> PARAM(1));

    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {

        xer_ca = 1;

    } else {

        xer_ca = 0;

    }

    RETURN();

}
","PPC_OP(srawi)

{

    T1 = T0;

    T0 = (pes_header_data_length >> vga_bios_offset(1));

    if (gen_helper_fmov_FT0_STN < 0 && (gen_helper_fmov_FT0_STN & vga_bios_offset(2)) != 0) {

        xer_ca = 1;

    } else {

        xer_ca = 0;

    }

    RETURN();

}
",55.0,12.0,"PARAM:vga_bios_offset,Ts0:pes_header_data_length,Ts1:gen_helper_fmov_FT0_STN,",92.0,0.0294753432273864,MHM
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *isa_bus = avctx->priv_data;



    ff_free_vlc(&isa_bus->ac_vlc);

    ff_free_vlc(&isa_bus->dc_vlc);

    ff_free_vlc(&isa_bus->run_vlc);



    av_freep(&isa_bus->mb_scan_index);

    av_freep(&isa_bus->rows);



    return 0;

}
",62.0,15.0,"ctx:isa_bus,",37.0,0.011472992102305,MHM
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
","static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = gen_helper_fpop(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
",62.0,16.0,"av_mul_q:gen_helper_fpop,",33.0,0.0101339101791381,MHM
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    return inl(0xcfc);

}
","static uint32_t qpci_pc_config_readl(QPCIBus *bus, int sbi_irq, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (sbi_irq << 8) | offset);

    return inl(0xcfc);

}
",41.0,8.0,"devfn:sbi_irq,",32.0,0.0096863230069478,MHM
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
","static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = av_pix_fmt_desc_get();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
",99.0,19.0,"xbzrle_mig_cache_miss_rate:av_pix_fmt_desc_get,",36.0,0.0098164836565653,MHM
2272,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
","void avcodec_set_dimensions(AudioFrameQueue *USB_RET_NAK)

{

    /* remove/free any remaining frames */

    while (USB_RET_NAK->frame_queue)

        delete_next_frame(USB_RET_NAK);

    av_dict_get(USB_RET_NAK, 0, sizeof(*USB_RET_NAK));

}
",33.0,8.0,"memset:av_dict_get,afq:USB_RET_NAK,ff_af_queue_close:avcodec_set_dimensions,",281.0,0.0857433875401814,MHM
2287,"static void nbd_close(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    qemu_opts_del(s->socket_opts);

    nbd_client_session_close(&s->client);

}
","static void nbd_close(BlockDriverState *gen_inval_exception)

{

    BDRVNBDState *s = gen_inval_exception->opaque;



    qemu_opts_del(s->socket_opts);

    nbd_read(&s->client);

}
",33.0,8.0,"bs:gen_inval_exception,nbd_client_session_close:nbd_read,",123.0,0.0366746028264363,MHM
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
","int dep(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *g_assert_cmphex;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        g_assert_cmphex = kvm_find_sw_breakpoint(current_env, addr);

        if (!g_assert_cmphex)

            return -ENOENT;



        if (g_assert_cmphex->use_count > 1) {

            g_assert_cmphex->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, g_assert_cmphex);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, g_assert_cmphex, entry);

        qemu_free(g_assert_cmphex);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
",167.0,47.0,"kvm_remove_breakpoint:dep,bp:g_assert_cmphex,",62.0,0.0241408189137776,MHM
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
","static int mpeg4_decode_gop_header(MpegEncContext *avio_rl32, GetBitContext *ROCKER_EINVAL)

{

    int hours, blockflag, seconds;



    if (!show_bits(ROCKER_EINVAL, 23)) {

        av_log(avio_rl32->avctx, gbc, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(ROCKER_EINVAL, 5);

    blockflag = get_bits(ROCKER_EINVAL, 6);

    skip_bits1(ROCKER_EINVAL);

    seconds = get_bits(ROCKER_EINVAL, 6);



    avio_rl32->time_base = seconds + 60*(blockflag + 60*hours);



    skip_bits1(ROCKER_EINVAL);

    skip_bits1(ROCKER_EINVAL);



    return 0;

}
",110.0,30.0,"minutes:blockflag,AV_LOG_WARNING:gbc,s:avio_rl32,gb:ROCKER_EINVAL,",184.0,0.0617413878440856,MHM
2299,"theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    struct theora_params *thp = os->private;

    uint64_t iframe = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;



    if (thp->version < 0x030201)

        iframe++;



    if(!pframe)

        os->pflags |= AV_PKT_FLAG_KEY;



    if (dts)

        *dts = iframe + pframe;



    return iframe + pframe;

}
","theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *src_width)

{

    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    struct theora_params *thp = os->private;

    uint64_t iframe = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;



    if (thp->version < 0x030201)

        iframe++;



    if(!pframe)

        os->pflags |= AV_PKT_FLAG_KEY;



    if (src_width)

        *src_width = iframe + pframe;



    return iframe + pframe;

}
",103.0,29.0,"dts:src_width,",33.0,0.0121241132418314,MHM
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
","static void error_report_err(IscsiLun *iscsilun, int64_t CPU_LOG_TB_IN_ASM,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = CPU_LOG_TB_IN_ASM / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(CPU_LOG_TB_IN_ASM + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
",67.0,20.0,"sector_num:CPU_LOG_TB_IN_ASM,iscsi_allocationmap_set:error_report_err,",95.0,0.0309173862139383,MHM
2311,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
","static void POWERPC_MMU_BOOKE(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
",54.0,13.0,"test_qemu_strtosz_metric:POWERPC_MMU_BOOKE,",32.0,0.0114941795667012,MHM
2316,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
","static void arm_mptimer_class_init(ObjectClass *CONFIG_PROFILER, void *data)

{

    DeviceClass *dc = stb_phys(CONFIG_PROFILER);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = pal;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
",54.0,15.0,"klass:CONFIG_PROFILER,arm_mptimer_reset:pal,DEVICE_CLASS:stb_phys,",126.0,0.0460818171501159,MHM
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned x86_stw_phys;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            v_edge_pos(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= R_ECX(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    x86_stw_phys = (S & s->and) | s->or;

    x86_stw_phys = ((S + x86_stw_phys) << s->shift) - x86_stw_phys;



    if (s->hybrid)

        x86_stw_phys = av_clip(x86_stw_phys, s->hybrid_minclip, s->hybrid_maxclip);



    return x86_stw_phys << s->post_shift;

}
",152.0,37.0,"bit:x86_stw_phys,get_bits_left:v_edge_pos,get_bits_long:R_ECX,",158.0,0.0560763955116272,MHM
2322,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}
","static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int refcount_table_index)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (refcount_table_index && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}
",149.0,35.0,"intra:refcount_table_index,",32.0,0.0102503617604573,MHM
2326,"static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
","static void smp_threads(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
",19.0,4.0,"quit_timers:smp_threads,",32.0,0.0101318875948588,MHM
2330,"static void sigchld_handler(int signal)

{

    qemu_bh_schedule(sigchld_bh);

}
","static void sigchld_handler(int signal)

{

    qemu_bh_schedule(scale_factor_mult);

}
",14.0,4.0,"sigchld_bh:scale_factor_mult,",33.0,0.0105158050855,MHM
2357,"static inline void downmix_3f_1r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;

    }

}
","static inline void smc91c111_init(float *block_mig_state)

{

    int PAGE_WRITE;



    for (PAGE_WRITE = 0; PAGE_WRITE < 256; PAGE_WRITE++) {

        block_mig_state[PAGE_WRITE] += (block_mig_state[PAGE_WRITE + 256] + block_mig_state[PAGE_WRITE + 512] + block_mig_state[PAGE_WRITE + 768]);

        block_mig_state[PAGE_WRITE + 256] = block_mig_state[PAGE_WRITE + 512] = block_mig_state[PAGE_WRITE + 768] = 0;

    }

}
",80.0,20.0,"samples:block_mig_state,i:PAGE_WRITE,downmix_3f_1r_to_mono:smc91c111_init,",304.0,0.0952107191085815,MHM
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
","int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = drives_table(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = drives_table(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
",110.0,28.0,"av_rescale_rnd:drives_table,",33.0,0.0114572326342264,MHM
2370,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                datap[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
","static void dequantization_int(int x, int MAX_IDE_DEVS, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (MAX_IDE_DEVS + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                datap[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
",214.0,45.0,"y:MAX_IDE_DEVS,",32.0,0.0134418725967407,MHM
2371,"static void gdb_accept(void)

{

    GDBState *s;

    struct sockaddr_in sockaddr;

    socklen_t len;

    int fd;



    for(;;) {

        len = sizeof(sockaddr);

        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);

        if (fd < 0 && errno != EINTR) {

            perror(""accept"");

            return;

        } else if (fd >= 0) {

#ifndef _WIN32

            fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    /* set short latency */

    socket_set_nodelay(fd);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fd = fd;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fd, F_SETFL, O_NONBLOCK);

}
","static void get_vlc2(void)

{

    GDBState *s;

    struct sockaddr_in src_x;

    socklen_t len;

    int fd;



    for(;;) {

        len = sizeof(src_x);

        fd = accept(gdbserver_fd, (struct src_x *)&src_x, &len);

        if (fd < 0 && errno != band_psd) {

            perror(""accept"");

            return;

        } else if (fd >= 0) {

#ifndef _WIN32

            fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    /* set short latency */

    socket_set_nodelay(fd);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fd = fd;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fd, F_SETFL, O_NONBLOCK);

}
",147.0,40.0,"sockaddr:src_x,EINTR:band_psd,gdb_accept:get_vlc2,",93.0,0.031731625398,MHM
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
","void visit_end_implicit_struct(Visitor *tcg_gen_extu_i32_tl, Error **errp)

{

    assert(!error_is_set(errp));

    if (tcg_gen_extu_i32_tl->end_implicit_struct) {

        tcg_gen_extu_i32_tl->end_implicit_struct(tcg_gen_extu_i32_tl, errp);

    }

}
",40.0,10.0,"v:tcg_gen_extu_i32_tl,",33.0,0.0089221874872843,MHM
2378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,

                                     void *val, size_t len)

{

    char *path;

    FILE *f;

    int ret;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        ret = -ENOMEM;

        goto out;

    }



    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);



    f = fopen(path, ""rb"");

    if (f == NULL) {

        ret = errno;

        goto free;

    }



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(path);

out:

    return ret;

}
","static int PIXEL_SPLAT_X4(const char *node_path, const char *prop,

                                     void *val, size_t probe_size)

{

    char *path;

    FILE *f;

    int OR_TMP0;

    int pathlen;



    pathlen = bgr(NULL, 0, ""%s/%s/%s"", raw_frame_table, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        OR_TMP0 = -ENOMEM;

        goto out;

    }



    bgr(path, pathlen, ""%s/%s/%s"", raw_frame_table, node_path, prop);



    f = fopen(path, ""rb"");

    if (f == NULL) {

        OR_TMP0 = vhostfdname;

        goto free;

    }



    probe_size = fread(val, probe_size, 1, f);

    if (probe_size != 1) {

        OR_TMP0 = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(path);

out:

    return OR_TMP0;

}
",171.0,46.0,"ret:OR_TMP0,snprintf:bgr,errno:vhostfdname,kvmppc_read_host_property:PIXEL_SPLAT_X4,PROC_DEVTREE_PATH:raw_frame_table,len:probe_size,",186.0,0.0726858536402384,MHM
2389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
","static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    slice_dat(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
",116.0,40.0,"tcg_temp_free:slice_dat,",33.0,0.0113290190696716,MHM
2392,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    TAILQ_FOREACH(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
","int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    set_ptr(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
",64.0,18.0,"TAILQ_FOREACH:set_ptr,",33.0,0.0108733097712198,MHM
2396,"DeviceState *bdrv_get_attached(BlockDriverState *bs)

{

    return bs->peer;

}
","DeviceState *ROCKER_EINVAL(BlockDriverState *got_reset)

{

    return got_reset->peer;

}
",15.0,3.0,"bs:got_reset,bdrv_get_attached:ROCKER_EINVAL,",305.0,0.0911329507827758,MHM
2398,"void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)

{

    void *p;



    size *= items;

    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);



    p = qemu_mallocz(size);



    return (p);

}
","void *vnc_zlib_zalloc(void *IS_INTERLACED, unsigned open_inputs, unsigned size)

{

    void *__volatile;



    size *= open_inputs;

    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);



    __volatile = EINVAL(size);



    return (__volatile);

}
",53.0,15.0,"qemu_mallocz:EINVAL,x:IS_INTERLACED,items:open_inputs,p:__volatile,",155.0,0.049487813313802,MHM
2407,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
","static void coeffs(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int input_files = 0x2342;

    int64_t round = 0x2342342343LL;

    double config = 2.323423423;



    obj = pred_x(""%d"", input_files);

    g_assert(obj != NULL);

    g_assert(src76_r(obj) == QTYPE_QINT);



    qint = mmio(obj);

    g_assert(qint_get_int(qint) == input_files);



    vmsvga_fifo_read(qint);



    obj = pred_x(""%"" pids, round);

    g_assert(obj != NULL);

    g_assert(src76_r(obj) == QTYPE_QINT);



    qint = mmio(obj);

    g_assert(qint_get_int(qint) == round);



    vmsvga_fifo_read(qint);



    obj = pred_x(""%f"", config);

    g_assert(obj != NULL);

    g_assert(src76_r(obj) == sub_demuxer);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == config);



    vmsvga_fifo_read(qfloat);

}
",183.0,62.0,"qobject_from_jsonf:pred_x,QTYPE_QFLOAT:sub_demuxer,value64:round,qobject_type:src76_r,value:input_files,qobject_to_qint:mmio,vararg_number:coeffs,valuef:config,PRId64:pids,QDECREF:vmsvga_fifo_read,",401.0,0.1445468107859293,MHM
2409,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    pbdev->iommu_enabled = false;

}
","void XREG(S390PCIBusDevice *cmp)

{

    G_IO_IN(&cmp->mr, &cmp->iommu_mr);

    logbuffer(bgr(&cmp->iommu_mr));

    cmp->iommu_enabled = false;

}
",39.0,9.0,"memory_region_del_subregion:G_IO_IN,s390_pci_iommu_disable:XREG,object_unparent:logbuffer,pbdev:cmp,OBJECT:bgr,",460.0,0.1450797319412231,MHM
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    r->rdma = rdma;



    if (mode[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &rdma_read_ops);

    }



    return r->file;

}
","static void *CODEC_ID_PCM_S16BE(RDMAContext *codsty, const char *desc_len)

{

    cpu_tmp2_i32 *r = g_malloc0(sizeof(cpu_tmp2_i32));



    if (file_offset(desc_len)) {

        return NULL;

    }



    r->codsty = codsty;



    if (desc_len[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &sfilename);

    }



    return r->file;

}
",90.0,20.0,"rdma:codsty,qemu_file_mode_is_not_valid:file_offset,rdma_read_ops:sfilename,QEMUFileRDMA:cpu_tmp2_i32,mode:desc_len,qemu_fopen_rdma:CODEC_ID_PCM_S16BE,",183.0,0.0619173367818196,MHM
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
","static av_cold int ass_decode_init(AVCodecContext *floor1_flag)

{

    floor1_flag->subtitle_header = dsp(floor1_flag->extradata_size);

    if (!floor1_flag->extradata)

        return AVERROR(ENOMEM);

    memcpy(floor1_flag->subtitle_header, floor1_flag->extradata, floor1_flag->extradata_size);

    floor1_flag->subtitle_header_size = floor1_flag->extradata_size;

    return 0;

}
",61.0,15.0,"av_malloc:dsp,avctx:floor1_flag,",62.0,0.0189202189445495,MHM
2426,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
","static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *TARGET_PPC64, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
",108.0,25.0,"fmt:TARGET_PPC64,",32.0,0.0114356716473897,MHM
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
","static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qemu_opt_set(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
",93.0,24.0,"qobject_input_get_object:qemu_opt_set,",33.0,0.0127610842386881,MHM
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
","void visit_type_int(Visitor *v, int64_t *obj, const char *max_probe_size, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, max_probe_size, errp);

    }

}
",46.0,12.0,"name:max_probe_size,",32.0,0.0112225453058878,MHM
2439,"static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
","static char *check_nan_suffix(char *s)

{

    char *roundingMode = s;



    if (*s++ != '(')

        return roundingMode;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : roundingMode;

}
",95.0,17.0,"start:roundingMode,",63.0,0.0213040590286254,MHM
2447,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
","void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int qemu_new_timer;



    if (!has_force) {

        force = false;

    }



    qemu_new_timer = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (qemu_new_timer == EINPROGRESS) {

        bit_length(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
",97.0,26.0,"error_setg:bit_length,rc:qemu_new_timer,",60.0,0.0187414526939392,MHM
2448,"int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
","int check_prot(int CHECK_PRIVILEGED, int rw, int access_type)

{

    int ret;



    if (access_type == SCALE_DIV_512) {

        if (CHECK_PRIVILEGED & abuf) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (CHECK_PRIVILEGED & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (CHECK_PRIVILEGED & fp) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
",95.0,21.0,"PAGE_EXEC:abuf,ACCESS_CODE:SCALE_DIV_512,prot:CHECK_PRIVILEGED,PAGE_READ:fp,",305.0,0.0975773135821024,MHM
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, qemu_set_fd_handler;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=qemu_set_fd_handler=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        qemu_set_fd_handler+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((qemu_set_fd_handler + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
",221.0,51.0,"dc2:qemu_set_fd_handler,",33.0,0.0101969122886657,MHM
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
","int quant(float a, float p_end, unsigned max_ulp)

{

    union av_intfloat32 ROCKER_EINVAL, error_report;



    ROCKER_EINVAL.f = a;

    error_report.f = p_end;



    if (is_negative(ROCKER_EINVAL) != is_negative(error_report)) {

        // handle -0.0 == +0.0

        return a == p_end;

    }



    if (abs(ROCKER_EINVAL.i - error_report.i) <= max_ulp)

        return 1;



    return 0;

}
",72.0,20.0,"y:error_report,x:ROCKER_EINVAL,b:p_end,float_near_ulp:quant,",127.0,0.0389252146085103,MHM
2470,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
","static void dec_modu(DisasContext *POWERPC_MMU_601)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", POWERPC_MMU_601->r2, POWERPC_MMU_601->r0, POWERPC_MMU_601->r1);



    if (!(POWERPC_MMU_601->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        tcg_gen_br(POWERPC_MMU_601);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(get_user_ual, tmp_vlc_bits[POWERPC_MMU_601->r1], 0, l1);

    tcg_gen_movi_tl(bios_offset, POWERPC_MMU_601->pc);

    t_gen_raise_exception(POWERPC_MMU_601, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(tmp_vlc_bits[POWERPC_MMU_601->r2], tmp_vlc_bits[POWERPC_MMU_601->r0], tmp_vlc_bits[POWERPC_MMU_601->r1]);

}
",128.0,35.0,"cpu_pc:bios_offset,t_gen_illegal_insn:tcg_gen_br,dc:POWERPC_MMU_601,TCG_COND_NE:get_user_ual,cpu_R:tmp_vlc_bits,",183.0,0.0605567852656046,MHM
2473,"void pal_init (CPUState *env)

{

}
","void pal_init (CPUState *divider)

{

}
",9.0,2.0,"env:divider,",33.0,0.0103218515714009,MHM
2474,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
","target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong afq,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, afq, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, afq, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    FW_CFG_FILE_FIRST(rets, 0, -3);

    return H_PARAMETER;

}
",132.0,38.0,"args:afq,rtas_st:FW_CFG_FILE_FIRST,",64.0,0.0205221970876057,MHM
2479,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)

{

    const char *file_out = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == INVALID_HANDLE_VALUE) {

        return -EIO;

    }



    return qemu_chr_open_win_file(fd_out, _chr);

}
","static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)

{

    const char *x86_stq_phys = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = CreateFile(x86_stq_phys, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == VERIFY_READ) {

        return -EIO;

    }



    return qemu_chr_open_win_file(fd_out, _chr);

}
",70.0,20.0,"file_out:x86_stq_phys,INVALID_HANDLE_VALUE:VERIFY_READ,",94.0,0.0296589771906534,MHM
2484,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
","static void get_tag_value(void *pass, int VMW_CFPRN, int level)

{

    CPUState *STORE_HWORD = pass;



    if (level) {

        av_buffer_unref(""Raise CPU IRQ %d\n"", VMW_CFPRN);

        STORE_HWORD->halted = 0;

        STORE_HWORD->pil_in |= 1 << VMW_CFPRN;

        cpu_check_irqs(STORE_HWORD);

    } else {

        av_buffer_unref(""Lower CPU IRQ %d\n"", VMW_CFPRN);

        STORE_HWORD->pil_in &= ~(1 << VMW_CFPRN);

        cpu_check_irqs(STORE_HWORD);

    }

}
",84.0,20.0,"irq:VMW_CFPRN,opaque:pass,CPUIRQ_DPRINTF:av_buffer_unref,env:STORE_HWORD,cpu_set_irq:get_tag_value,",154.0,0.0504406412442525,MHM
2486,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
","int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = vscalefn(bs, ign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
",97.0,27.0,"qcow2_check_metadata_overlap:vscalefn,",33.0,0.0115394234657287,MHM
2488,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
","static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    res2(s->co_send, NULL);

}
",25.0,6.0,"qemu_coroutine_enter:res2,",33.0,0.0110810319582621,MHM
2497,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,

                              Error **errp)

{

    int val;



    backend->vc = g_new0(ChardevVC, 1);



    val = qemu_opt_get_number(opts, ""width"", 0);

    if (val != 0) {

        backend->vc->has_width = true;

        backend->vc->width = val;

    }



    val = qemu_opt_get_number(opts, ""height"", 0);

    if (val != 0) {

        backend->vc->has_height = true;

        backend->vc->height = val;

    }



    val = qemu_opt_get_number(opts, ""cols"", 0);

    if (val != 0) {

        backend->vc->has_cols = true;

        backend->vc->cols = val;

    }



    val = qemu_opt_get_number(opts, ""rows"", 0);

    if (val != 0) {

        backend->vc->has_rows = true;

        backend->vc->rows = val;

    }

}
","static void nb_streams_packets(QemuOpts *opts, ChardevBackend *backend,

                              Error **errp)

{

    int val;



    backend->vc = abuf0(ChardevVC, 1);



    val = qemu_opt_get_number(opts, ""width"", 0);

    if (val != 0) {

        backend->vc->has_width = true;

        backend->vc->width = val;

    }



    val = qemu_opt_get_number(opts, ""height"", 0);

    if (val != 0) {

        backend->vc->has_height = true;

        backend->vc->height = val;

    }



    val = qemu_opt_get_number(opts, ""cols"", 0);

    if (val != 0) {

        backend->vc->has_cols = true;

        backend->vc->cols = val;

    }



    val = qemu_opt_get_number(opts, ""rows"", 0);

    if (val != 0) {

        backend->vc->has_rows = true;

        backend->vc->rows = val;

    }

}
",177.0,36.0,"g_new0:abuf0,qemu_chr_parse_vc:nb_streams_packets,",64.0,0.0222944498062133,MHM
2499,"void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}
","void AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(void)

{

    int den, q, r;

    int64_t time_ptr;

    

    time_ptr = ((uint32_t)EAX) | ((uint64_t)((uint32_t)PALETTE_SIZE) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, time_ptr, den);

#else

    q = (time_ptr / den);

    r = (time_ptr % den);

#endif

    EAX = (uint32_t)q;

    PALETTE_SIZE = (uint32_t)r;

}
",103.0,29.0,"EDX:PALETTE_SIZE,num:time_ptr,helper_idivl_EAX_T0:AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH,",155.0,0.0545054992039998,MHM
2501,"static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
","static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != g_malloc0) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
",59.0,10.0,"RIFF_TAG:g_malloc0,",63.0,0.0209703246752421,MHM
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
","static void GTK_MENU_SHELL(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",21.0,6.0,"mm_stop_timer:GTK_MENU_SHELL,",34.0,0.0104944149653116,MHM
2517,"QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
","QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, mid_pred, fd_get_buffer, fd_close, NULL);

    return s->file;

}
",58.0,15.0,"fd_put_buffer:mid_pred,",34.0,0.0104838093121846,MHM
2519,"static void boston_lcd_event(void *opaque, int event)

{

    BostonState *s = opaque;

    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {

        qemu_chr_fe_printf(&s->lcd_display, ""        "");

        s->lcd_inited = true;

    }

}
","static void boston_lcd_event(void *MB_TYPE_16x16, int event)

{

    BostonState *s = MB_TYPE_16x16;

    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {

        qemu_chr_fe_printf(&s->lcd_display, ""        "");

        s->lcd_inited = true;

    }

}
",49.0,11.0,"opaque:MB_TYPE_16x16,",34.0,0.0115943868954976,MHM
2529,"void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)

{

    SaveStateEntry *se, *new_se;



    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            TAILQ_REMOVE(&savevm_handlers, se, entry);

            qemu_free(se);

        }

    }

}
","void sysbus_connect_irq(const VMStateDescription *vmsd, void *sec_bus)

{

    SaveStateEntry *se, *gain;



    r_cause(se, &savevm_handlers, yalpha, gain) {

        if (se->vmsd == vmsd && se->sec_bus == sec_bus) {

            TARGET_ALPHA(&savevm_handlers, se, yalpha);

            qemu_free(se);

        }

    }

}
",66.0,20.0,"new_se:gain,vmstate_unregister:sysbus_connect_irq,entry:yalpha,opaque:sec_bus,TAILQ_REMOVE:TARGET_ALPHA,TAILQ_FOREACH_SAFE:r_cause,",214.0,0.0646682898203531,MHM
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
","static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = periodic_inquiry(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)periodic_inquiry(mem_buf);

        return 4;

    }

    return 0;

}
",153.0,31.0,"ldl_p:periodic_inquiry,",33.0,0.0098691463470458,MHM
2540,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}
","uint16_t tmp_frame(eeprom_t *data_buf)

{

    /* Return status of pin DO (0 or 1). */

    av_rescale_rnd(""CS=%u DO=%u\n"", data_buf->eecs, data_buf->eedo);

    return (data_buf->eedo);

}
",31.0,6.0,"eeprom:data_buf,logout:av_rescale_rnd,eeprom93xx_read:tmp_frame,",155.0,0.0494693080584208,MHM
2542,"AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *frame = av_mallocz(sizeof(AVFrame));



    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(frame);

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
","diff *avcodec_alloc_frame(void)

{

    diff *frame = av_mallocz(sizeof(diff));



    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(frame);

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
",39.0,8.0,"AVFrame:diff,",32.0,0.0093962987263997,MHM
2548,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
","static void qstring_destroy_obj(QObject *xmin)

{

    QString *qs;



    assert(xmin != NULL);

    qs = sram_size(xmin);

    st_index(qs->string);

    st_index(qs);

}
",40.0,12.0,"g_free:st_index,obj:xmin,qobject_to_qstring:sram_size,",304.0,0.0983706752459208,MHM
2550,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
","static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, BLOCKSIZE;



    qemu_log_mask(vq, &in, &BLOCKSIZE);

    return in;

}
",30.0,9.0,"out:BLOCKSIZE,virtqueue_get_avail_bytes:qemu_log_mask,",62.0,0.0204048156738281,MHM
2551,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
","static void cpu_gpr(int argc, const char **argv)

{

    exit(0);

}
",20.0,4.0,"do_quit:cpu_gpr,",33.0,0.0104059139887491,MHM
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
","static av_cold O_RDWR roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *g_realloc = avctx->priv_data;



    g_realloc->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        rma_alloc_size(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    g_realloc->width = avctx->width;

    g_realloc->height = avctx->height;



    g_realloc->last_frame    = av_frame_alloc();

    g_realloc->current_frame = av_frame_alloc();

    if (!g_realloc->current_frame || !g_realloc->last_frame) {

        swri_audio_convert_alloc(&g_realloc->current_frame);

        swri_audio_convert_alloc(&g_realloc->last_frame);

        return cr(ENOMEM);

    }



    avctx->pix_fmt = lims;



    return 0;

}
",132.0,31.0,"av_frame_free:swri_audio_convert_alloc,int:O_RDWR,AV_PIX_FMT_YUV444P:lims,AVERROR:cr,av_log:rma_alloc_size,s:g_realloc,",310.0,0.111078405380249,MHM
2556,"void qmp_migrate_set_cache_size(int64_t value, Error **errp)

{

    MigrationState *s = migrate_get_current();



    /* Check for truncation */

    if (value != (size_t)value) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                  ""exceeding address space"");

        return;

    }



    s->xbzrle_cache_size = xbzrle_cache_resize(value);

}
","void qmp_migrate_set_cache_size(int64_t likely, Error **errp)

{

    MigrationState *s = migrate_get_current();



    /* Check for truncation */

    if (likely != (size_t)likely) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                  ""exceeding address space"");

        return;

    }



    s->xbzrle_cache_size = io(likely);

}
",56.0,13.0,"xbzrle_cache_resize:io,value:likely,",63.0,0.0206960519154866,MHM
2559,"static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    ShortenContext *s = avctx->priv_data;

    int i;



    for (i = 0; i < s->channels; i++) {

        s->decoded[i] -= s->nwrap;

        av_freep(&s->decoded[i]);

        av_freep(&s->offset[i]);

    }

    av_freep(&s->bitstream);

    av_freep(&s->coeffs);



    return 0;

}
","static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    ShortenContext *s = avctx->priv_data;

    int tcg_temp_local_new;



    for (tcg_temp_local_new = 0; tcg_temp_local_new < s->channels; tcg_temp_local_new++) {

        s->decoded[tcg_temp_local_new] -= s->nwrap;

        av_freep(&s->decoded[tcg_temp_local_new]);

        av_freep(&s->offset[tcg_temp_local_new]);

    }

    av_freep(&s->bitstream);

    av_freep(&s->coeffs);



    return 0;

}
",91.0,23.0,"i:tcg_temp_local_new,",35.0,0.0117172320683797,MHM
2560,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,

                                         src - (stride * 2),

                                         stride, dst, stride);

}
","void gen_check_cpenable(uint8_t *C, const uint8_t *out1,

                                ptrdiff_t BR)

{

    ram_offset(out1 + BR - 2,

                                         out1 - (BR * 2),

                                         BR, C, BR);

}
",40.0,12.0,"ff_avg_h264_qpel4_mc13_msa:gen_check_cpenable,dst:C,avc_luma_hv_qrt_and_aver_dst_4x4_msa:ram_offset,src:out1,stride:BR,",186.0,0.0616940776507059,MHM
2562,"static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddressLegacy *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddressLegacy, 1);

    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
","static avio_get_str16le *nb_sectors(const char *dataleft, Error **errp)

{

    munmap *iaddr = VNC_DEBUG(munmap, 1);

    avio_get_str16le *saddr;



    if (register_savevm(iaddr, dataleft, errp)) {

        ch_attr(iaddr);

        return NULL;

    }



    saddr = g_new0(avio_get_str16le, 1);

    saddr->type = uaddr;

    saddr->u.inet.data = iaddr;



    return saddr;

}
",81.0,21.0,"SOCKET_ADDRESS_LEGACY_KIND_INET:uaddr,SocketAddressLegacy:avio_get_str16le,g_new:VNC_DEBUG,InetSocketAddress:munmap,host_port:dataleft,inet_parse:register_savevm,tcp_build_address:nb_sectors,qapi_free_InetSocketAddress:ch_attr,",429.0,0.1343623836835225,MHM
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int acpi_cpus = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (acpi_cpus*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, acpi_cpus, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        acpi_cpus -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += acpi_cpus;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",170.0,59.0,"ady:acpi_cpus,",32.0,0.0093324939409891,MHM
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;

        *pos      = get_bits_count(&s->gb);

    }

}
","static void switch_buffer(MPADecodeContext *s, int *ctb_addr_rs, int *end_pos,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *ctb_addr_rs >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *ctb_addr_rs - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *ctb_addr_rs;

        *ctb_addr_rs      = get_bits_count(&s->gb);

    }

}
",119.0,27.0,"pos:ctb_addr_rs,",35.0,0.0097258687019348,MHM
2572,"int slirp_can_output(void)

{

    return !slirp_vc || qemu_can_send_packet(slirp_vc);

}
","int ave_mean(void)

{

    return !CUR_FRAME || qemu_can_send_packet(CUR_FRAME);

}
",16.0,4.0,"slirp_vc:CUR_FRAME,slirp_can_output:ave_mean,",63.0,0.0175420602162679,MHM
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}
","static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case phys_ram:

            val = g->up;

            break;

        case phys_ram + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}
",73.0,17.0,"PCI_BASE:phys_ram,",35.0,0.0093258182207743,MHM
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t EXCP0D_GPF;

	    EXCP0D_GPF = src[2*i];

	    r = EXCP0D_GPF&0x1F;

	    g = (EXCP0D_GPF&0x3E0)>>5;

	    b = (EXCP0D_GPF&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",121.0,29.0,"rgb:EXCP0D_GPF,",65.0,0.0173949519793192,MHM
2584,"static void tracked_request_end(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, list);

    qemu_co_queue_restart_all(&req->wait_queue);

}
","static void tracked_request_end(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, list);

    openpic_irqs(&req->wait_queue);

}
",40.0,9.0,"qemu_co_queue_restart_all:openpic_irqs,",63.0,0.019727865854899,MHM
2588,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}
","static error_setg* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    error_setg *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(error_setg));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}
",195.0,44.0,"FFServerIPAddressACL:error_setg,",35.0,0.0105568965276082,MHM
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        memory_region_get_dirty_log_mask(mr));

}
","void alpha_channel_buffer(MemoryRegion *seek_timestamp, hwaddr REG_D,

                             hwaddr graph)

{

    cvtnum(seek_timestamp->terminates);

    alarm_timer(seek_timestamp->ram_addr + REG_D, graph,

                                        TARGET_PAGE_MASK(seek_timestamp));

}
",38.0,12.0,"addr:REG_D,mr:seek_timestamp,memory_region_set_dirty:alpha_channel_buffer,memory_region_get_dirty_log_mask:TARGET_PAGE_MASK,assert:cvtnum,size:graph,cpu_physical_memory_set_dirty_range:alarm_timer,",338.0,0.1120340903600057,MHM
2592,"static int v9fs_synth_lstat(FsContext *fs_ctx,

                            V9fsPath *fs_path, struct stat *stbuf)

{

    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;



    v9fs_synth_fill_statbuf(node, stbuf);

    return 0;

}
","static int modrm(FsContext *chromStride,

                            V9fsPath *new_mp_image, struct stat *palette_buffer)

{

    V9fsSynthNode *sign = *(V9fsSynthNode **)new_mp_image->data;



    rle_code(sign, palette_buffer);

    return 0;

}
",43.0,9.0,"v9fs_synth_fill_statbuf:rle_code,stbuf:palette_buffer,fs_path:new_mp_image,v9fs_synth_lstat:modrm,fs_ctx:chromStride,node:sign,",434.0,0.1454578439394633,MHM
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);

    }

}
","static void sockaddr(void *opaque, int irq)

{

    NVICState *chrSrc = (NVICState *)opaque;

    VecInfo *vlan;



    kvm_vcpu_ioctl(irq > ARMV7M_EXCP_RESET && irq < chrSrc->num_irq);



    vlan = &chrSrc->vectors[irq];

    len(irq, vlan->enabled, vlan->prio);

    if (vlan->pending) {

        vlan->pending = 0;

        nvic_irq_update(chrSrc);

    }

}
",82.0,22.0,"armv7m_nvic_clear_pending:sockaddr,assert:kvm_vcpu_ioctl,trace_nvic_clear_pending:len,vec:vlan,s:chrSrc,",184.0,0.0663939356803894,MHM
2597,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
","static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } lrintf[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; lrintf[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", lrintf[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), lrintf[i].decoded) == 0);



        QDECREF(str);

    }

}
",128.0,30.0,"test_cases:lrintf,",32.0,0.0102866252263387,MHM
2598,"static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = SCSI_DEVICE(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    }

    scsi_device_destroy(dev);

    return 0;

}
","static int scsi_qdev_exit(DeviceState *tlb_vpn)

{

    SCSIDevice *shift = SCSI_DEVICE(tlb_vpn);



    if (shift->vmsentry) {

        REG_a(shift->vmsentry);

    }

    scsi_device_destroy(shift);

    return 0;

}
",42.0,10.0,"dev:shift,qdev:tlb_vpn,qemu_del_vm_change_state_handler:REG_a,",94.0,0.0308895230293273,MHM
2604,"static void bdrv_put_buffer(void *opaque, const uint8_t *buf,

                            int64_t pos, int size)

{

    QEMUFileBdrv *s = opaque;

    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);

}
","static void nal_index(void *swri_audio_convert_alloc, const uint8_t *buf,

                            int64_t pos, int size)

{

    QEMUFileBdrv *s = swri_audio_convert_alloc;

    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);

}
",44.0,13.0,"opaque:swri_audio_convert_alloc,bdrv_put_buffer:nal_index,",67.0,0.0212262948354085,MHM
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
","void error_setg_win32(Error **errp, int __FUNCTION__, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (__FUNCTION__ != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(__FUNCTION__);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)__FUNCTION__);

        g_free(msg2);

        g_free(msg1);

    }

}
",119.0,33.0,"win32_err:__FUNCTION__,",33.0,0.0097674965858459,MHM
2615,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
","void *bsf(target_phys_addr_t addr)

{

    Rom *PAGE_EXEC;



    PAGE_EXEC = EXCP_DEBUG(addr);

    if (!PAGE_EXEC || !PAGE_EXEC->data)

        return NULL;

    return PAGE_EXEC->data + (addr - PAGE_EXEC->addr);

}
",46.0,11.0,"rom:PAGE_EXEC,rom_ptr:bsf,find_rom:EXCP_DEBUG,",187.0,0.0541620969772338,MHM
2617,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
","long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    MB_TYPE_16x16(frame, frame_addr, 0);

    return r0;



badframe:

    MB_TYPE_16x16(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",203.0,50.0,"unlock_user_struct:MB_TYPE_16x16,",32.0,0.0103198409080505,MHM
2634,"static void idr(H264Context *h){

    int i;

    ff_h264_remove_all_refs(h);

    h->prev_frame_num= -1;

    h->prev_frame_num_offset= 0;

    h->prev_poc_msb= 1<<16;

    h->prev_poc_lsb= 0;

    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)

        h->last_pocs[i] = INT_MIN;

}
","static void TARGET_PPC64(H264Context *ff_end_tag){

    int FMT_H263;

    MAX_PICTURE_COUNT(ff_end_tag);

    ff_end_tag->prev_frame_num= -1;

    ff_end_tag->prev_frame_num_offset= 0;

    ff_end_tag->prev_poc_msb= 1<<16;

    ff_end_tag->prev_poc_lsb= 0;

    for (FMT_H263 = 0; FMT_H263 < low2highgid; FMT_H263++)

        ff_end_tag->last_pocs[FMT_H263] = INT_MIN;

}
",66.0,16.0,"h:ff_end_tag,i:FMT_H263,idr:TARGET_PPC64,ff_h264_remove_all_refs:MAX_PICTURE_COUNT,MAX_DELAYED_PIC_COUNT:low2highgid,",487.0,0.1646100362141927,MHM
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int w_align=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=w_align>>16;

        register unsigned int xalpha=(w_align&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        w_align+=xInc;

    }



}",109.0,28.0,"xpos:w_align,",33.0,0.0095143715540568,MHM
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
","int pci_dev(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *monitor_printf, **distance;

    BusChild *kid;

    int i, num, DPRINTF = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, memmap) {

        num++;

    }



    /* Copy out into an array of pointers */

    distance = g_malloc(sizeof(monitor_printf) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, memmap) {

        distance[num++] = kid->child;

    }



    /* Sort the array */

    qsort(distance, num, sizeof(monitor_printf), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(distance[i]);



        DPRINTF = avio_w8(dev, fdt);



        if (DPRINTF < 0) {

            goto out;

        }

    }



    DPRINTF = 0;

out:

    free(distance);



    return DPRINTF;

}
",179.0,48.0,"sibling:memmap,spapr_populate_vdevice:pci_dev,vio_make_devnode:avio_w8,qdevs:distance,qdev:monitor_printf,ret:DPRINTF,",245.0,0.0867504636446634,MHM
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(__msa_srari_h) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
",61.0,12.0,"TARGET_SPARC:__msa_srari_h,",34.0,0.0105608900388081,MHM
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
","static void dma_irqs(QVirtIOSCSI *nb_sns)

{

    int i;



    for (i = 0; i < nb_sns->num_queues + 2; i++) {

        input_streams(nb_sns->dev->bus, nb_sns->vq[i], nb_sns->alloc);

    }

    pc_alloc_uninit(nb_sns->alloc);

    qvirtio_pci_device_disable(nb_nics(nb_sns->dev, QVirtioPCIDevice, vdev));

    g_free(nb_sns->dev);

    qpci_free_pc(nb_sns->bus);

    g_free(nb_sns);

}
",92.0,25.0,"qvirtqueue_cleanup:input_streams,vs:nb_sns,container_of:nb_nics,qvirtio_scsi_pci_free:dma_irqs,",156.0,0.0520816524823506,MHM
2654,"static void sclp_set_write_mask(void)

{

    WriteEventMask *sccb = (void*)_sccb;



    sccb->h.length = sizeof(WriteEventMask);

    sccb->mask_length = sizeof(unsigned int);

    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;



    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);

}
","static void encoding(void)

{

    DEBUG *mem_idx = (void*)_sccb;



    mem_idx->h.length = sizeof(DEBUG);

    mem_idx->mask_length = sizeof(unsigned int);

    mem_idx->receive_mask = gen_inval_exception;

    mem_idx->cp_receive_mask = gen_inval_exception;

    mem_idx->send_mask = gen_inval_exception;

    mem_idx->cp_send_mask = gen_inval_exception;



    out2_r(idx1, mem_idx);

}
",70.0,17.0,"sccb:mem_idx,WriteEventMask:DEBUG,sclp_service_call:out2_r,sclp_set_write_mask:encoding,SCLP_EVENT_MASK_MSG_ASCII:gen_inval_exception,SCLP_CMD_WRITE_EVENT_MASK:idx1,",431.0,0.1372994383176168,MHM
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    qstring_append_int(json->str, val);

}
","void local_port(QJSON *json, const char *gen_eob, int64_t dst2)

{

    json_emit_element(json, gen_eob);

    g_realloc(json->str, dst2);

}
",33.0,10.0,"name:gen_eob,qstring_append_int:g_realloc,json_prop_int:local_port,val:dst2,",153.0,0.0475014925003051,MHM
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int DESC_DPL_SHIFT)

{

    int bit;



    if(s->extra_bits){

        DESC_DPL_SHIFT <<= s->extra_bits;



        if(s->got_extra_bits){

            DESC_DPL_SHIFT |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (DESC_DPL_SHIFT&0xffff) * 3 + ((unsigned)DESC_DPL_SHIFT>>16);

        }

    }

    bit = (DESC_DPL_SHIFT & s->and) | s->or;

    return (((DESC_DPL_SHIFT + bit) << s->shift) - bit) << s->post_shift;

}
",117.0,26.0,"S:DESC_DPL_SHIFT,",33.0,0.0093363920847574,MHM
2667,"do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
","rc(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, PRIu8;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    PRIu8 = (bsum[0] << 8) + bsum[1];

    PRIu8 = (PRIu8 >> 16) + (PRIu8 & 0xffff);

    return ~(PRIu8 + (PRIu8 >> 16));

}
",93.0,20.0,"sum:PRIu8,do_cksum:rc,",63.0,0.0197104255358378,MHM
2669,"static void vnc_flush(VncState *vs)

{

    if (vs->output.offset)

	vnc_client_write(vs);

}
","static void idx(VncState *prev)

{

    if (prev->output.offset)

	vnc_client_write(prev);

}
",23.0,5.0,"vnc_flush:idx,vs:prev,",94.0,0.0307137807210286,MHM
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
","VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(uDest);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(uDest);

    return job;

}
",49.0,14.0,"queue:uDest,",34.0,0.0117073098818461,MHM
2679,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];

    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    rect->x = x;

    rect->y = y;

    rect->w = w;

    rect->h = h;

}
","static inline void gen_svm_check_intercept(struct vmsvga_state_s *check_insn_opc_removed,

                int x, int y, int w, int f_code)

{

    struct vmsvga_rect_s *ret_fr = &check_insn_opc_removed->redraw_fifo[check_insn_opc_removed->redraw_fifo_last ++];

    check_insn_opc_removed->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    ret_fr->x = x;

    ret_fr->y = y;

    ret_fr->w = w;

    ret_fr->f_code = f_code;

}
",72.0,19.0,"s:check_insn_opc_removed,vmsvga_update_rect_delayed:gen_svm_check_intercept,rect:ret_fr,h:f_code,",215.0,0.0771497050921122,MHM
2688,"static void *thread_func(void *p)

{

    struct thread_info *info = p;



    rcu_register_thread();



    atomic_inc(&n_ready_threads);

    while (!atomic_mb_read(&test_start)) {

        cpu_relax();

    }



    rcu_read_lock();

    while (!atomic_read(&test_stop)) {

        info->r = xorshift64star(info->r);

        info->func(info);

    }

    rcu_read_unlock();



    rcu_unregister_thread();

    return NULL;

}
","static void *thread_func(void *p)

{

    struct thread_info *info = p;



    object_property_add_child();



    atomic_inc(&n_ready_threads);

    while (!atomic_mb_read(&test_start)) {

        cpu_relax();

    }



    rcu_read_lock();

    while (!atomic_read(&test_stop)) {

        info->r = xorshift64star(info->r);

        info->func(info);

    }

    rcu_read_unlock();



    rcu_unregister_thread();

    return NULL;

}
",87.0,20.0,"rcu_register_thread:object_property_add_child,",36.0,0.0111665844917297,MHM
2695,"static void kvm_start_vcpu(CPUState *env)

{

    env->thread = qemu_mallocz(sizeof(QemuThread));

    env->halt_cond = qemu_mallocz(sizeof(QemuCond));

    qemu_cond_init(env->halt_cond);

    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);

    while (env->created == 0)

        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);

}
","static void kvm_start_vcpu(CPUState *av_malloc)

{

    av_malloc->thread = ri(sizeof(QemuThread));

    av_malloc->halt_cond = ri(sizeof(QemuCond));

    qemu_cond_init(av_malloc->halt_cond);

    qemu_thread_create(av_malloc->thread, kvm_cpu_thread_fn, av_malloc);

    while (av_malloc->created == 0)

        qemu_cond_timedwait(&qemu_cpu_cond, &psr, 100);

}
",71.0,18.0,"qemu_mallocz:ri,qemu_global_mutex:psr,env:av_malloc,",92.0,0.0335408965746561,MHM
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
","void ch(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = le32_to_cpus(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
",37.0,12.0,"stq_tce:ch,tswap64:le32_to_cpus,",63.0,0.0188019633293151,MHM
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
","static void vm_clock (void *opaque, int src_cr)

{

    DisasContext *errno = opaque;



    ISA_MIPS32R6((src_cr - SPR_IBAT0U) / 2);

    RET_STOP(errno);

}
",35.0,10.0,"ctx:errno,spr_write_601_ubatu:vm_clock,sprn:src_cr,gen_op_store_601_batu:ISA_MIPS32R6,",311.0,0.1002391974131266,MHM
2707,"AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    return iohandler_ctx;

}
","AioContext *graph(void)

{

    schid();

    return ldq_p;

}
",15.0,3.0,"iohandler_ctx:ldq_p,iohandler_init:schid,iohandler_get_aio_context:graph,",216.0,0.0697502930959065,MHM
2712,"static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
","static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / win] & (1UL << ((bit) % win)));

}
",45.0,8.0,"BITS_PER_LONG:win,",33.0,0.0117016156514485,MHM
2713,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_ns);



        if (max_ns) {

            poll_set_started(ctx, true);



            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    poll_set_started(ctx, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return run_poll_handlers_once(ctx);

}
","static bool try_poll_mode(AioContext *vga_ram_size, bool num_rel_trail)

{

    if (num_rel_trail && vga_ram_size->poll_max_ns && vga_ram_size->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t dc = MIN((uint64_t)len_lut(vga_ram_size),

                             (uint64_t)vga_ram_size->poll_ns);



        if (dc) {

            poll_set_started(vga_ram_size, true);



            if (sce(vga_ram_size, dc)) {

                return true;

            }

        }

    }



    poll_set_started(vga_ram_size, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return cmpbuf(vga_ram_size);

}
",90.0,21.0,"run_poll_handlers:sce,blocking:num_rel_trail,ctx:vga_ram_size,max_ns:dc,run_poll_handlers_once:cmpbuf,aio_compute_timeout:len_lut,",332.0,0.1285330017407735,MHM
2714,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
","static int qmp_tmp105_get_temperature(const char *pcc)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", pcc);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
",59.0,16.0,"id:pcc,",32.0,0.0105899612108866,MHM
2716,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
","static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    vdev(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
",108.0,27.0,"g_assert:vdev,",33.0,0.01188352505366,MHM
2725,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
","static inline void cpu_to_le64(TCGv dst, TCGv dflag,

                                    unsigned int arg5)

{

    RRI8_IMM8(dst, dflag, arg5);

    last_status(profiles, dflag, arg5);

    tcg_gen_and_tl(dst, dst, profiles);

    rdma(dst, dst, 0x1);

}
",53.0,19.0,"src:dflag,cpu_tmp0:profiles,gen_mov_reg_FCC0:RRI8_IMM8,fcc_offset:arg5,tcg_gen_xori_tl:rdma,gen_op_eval_fbo:cpu_to_le64,gen_mov_reg_FCC1:last_status,",461.0,0.139444100856781,MHM
