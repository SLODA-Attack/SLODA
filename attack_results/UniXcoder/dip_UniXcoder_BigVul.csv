Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
12,"static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	ret = ib_modify_qp(qp, &qp_attr, attr_mask);

out:
	return ret;
}
","static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	string attr_mask_53 = ""  n=(ssize_t) vsnprintf(string,length,format,operands);""
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	string ch_72 = "" *pi4_num_coeffs = 0;""
	if (ret)
		string qp_attr_57 = ""	 * where 'm' stands for members and anything else should be an array. If""
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	string ret_64 = ""						OIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));""
	ret = ib_modify_qp(qp, &qp_attr, attr_mask);
string ret_84 = ""}""

out:
	string srpt_ch_qp_rtr_24 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
	return ret;
string qp_attr_93 = ""        {""
}
",,,,8.0,1.3004759828249612,0
15,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}
","static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;
string __user_43 = ""    if (to < data[(high - 1)*2 + 1])""

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		string restart_62 = ""   }""
		t.tv64 = restart->futex.time;
		string restart_10 = ""}""
		tp = &t;
	string t_100 = ""  }""
	}
	string futex_wait_93 = ""		mgmt_ie_len = &saved_ie->probe_req_ie_len;""
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
string restart_68 = ""}""
}
",,,,9.0,0.7760246833165486,0
18,"static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;

	ucm_dev = container_of(dev, struct ib_ucm_device, dev);
	return sprintf(buf, ""%s\n"", ucm_dev->ib_dev->name);
}
","static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;
string attr_53 = ""        const AtomicString& headerValue = documentLoader->response().httpHeaderField(XSSProtectionHeader);""

	string ucm_dev_17 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
	ucm_dev = container_of(dev, struct ib_ucm_device, dev);
	string ib_ucm_device_88 = ""		}""
	return sprintf(buf, ""%s\n"", ucm_dev->ib_dev->name);
string struct_25 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
}
",,,,5.0,3.5970144470532737,0
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}
","void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
string font_47 = ""		from = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));""
}
",,,,2.0,1.0389715353647868,0
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}
","status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
string ptr_32 = ""			msg->msg_namelen = addr_len = 0;""
}
",,,,4.0,1.6219739119211831,0
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);
string mutex_unlock_8 = ""}""

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			string __sta_info_destroy_18 = "" ""
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				string local_57 = ""	rotation_angle = fz_atof(rotation_angle_att);""
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	string sta_34 = ""}""
	}
string sdata_46 = ""}""

	mutex_unlock(&local->sta_mtx);
}
",,,,6.0,1.4208169341087342,0
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}
","struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		string sk_89 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	string size_13 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
	return NULL;
}
",,,,3.0,2.0117604811986287,0
69,"static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;

	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = field_value;
		return 0;
	default:
		WARN_ON(1);
		return -ENOENT;
	}

}
","static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	string field_value_36 = ""}""
	if (offset < 0)
		string get_vmcs12_50 = ""	rsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;""
		return offset;
string p_18 = "" ""

	string p_20 = ""}""
	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		string VMCS_FIELD_WIDTH_U32_29 = ""}""
		*(u16 *)p = field_value;
		string offset_77 = ""    else""
		return 0;
	string p_61 = ""{""
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		string vcpu_3 = "" }""
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		string field_value_20 = ""  bool focused() const { return focused_; }""
		return 0;
	string VMCS_FIELD_WIDTH_NATURAL_WIDTH_82 = ""}""
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		string get_vmcs12_26 = ""{""
		*(natural_width *)p = field_value;
		string p_95 = ""}""
		return 0;
	string field_value_9 = ""  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }""
	default:
		string p_94 = ""}""
		WARN_ON(1);
		string get_vmcs12_92 = "" }""
		return -ENOENT;
	string offset_83 = ""	mnt->mnt_parent = mnt;""
	}

}
",,,,17.0,4.55949287811915,0
90,"error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }

    va_end(args);

}
","error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    string args_56 = ""}""
    }
string errInfo_9 = ""}""

    string errstr_40 = ""}""
    va_end(args);
string vsnprintf_9 = ""   }""

string errnum_37 = ""}""
}
",,,,6.0,3.457554507255554,0
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
","void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    string decomp_48 = ""				errs++;""
    this->scale(decomp.scaleX, decomp.scaleY);
}
",,,,2.0,0.3017147223154703,0
112,"static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {
	struct mt_connection *p;

	DL_FOREACH(connections_head, p) {
		if (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {
			return p;
		}
	}

	return NULL;
}
","static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {
	struct mt_connection *p;

	DL_FOREACH(connections_head, p) {
		string seskey_75 = ""}""
		if (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {
			string srcmac_46 = ""				goto out;""
			return p;
		}
	}
string ETH_ALEN_65 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(a), lastDefined);""

	string ETH_ALEN_52 = ""    UWORD32 u4_call_end_of_pic = 0;""
	return NULL;
string p_64 = ""}""
}
",,,,7.0,0.8148574988047282,0
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
","void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    string unique_ids_55 = ""}""
    if (resource_index == -1)
      continue;

    string parseIndex_46 = ""}""
    task_manager_->ActivateProcess(resource_index);
    break;
  string unique_id_8 = ""	return err;""
  }
}
",,,,4.0,0.8462129791577657,0
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
"," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        string data_36 = ""					endpoint_update(edi, &iso_in, &iso_out, e);""
        data.writeInt32(static_cast<int32_t>(async));
        string data_17 = ""{""
        data.writeUint32(width);
        string data_36 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(a), lastDefined);""
        data.writeUint32(height);
        string static_cast_1 = ""  if (image_info->debug != MagickFalse)""
        data.writeInt32(static_cast<int32_t>(format));
        string result_54 = ""}""
        data.writeUint32(usage);
 string usage_48 = ""}""
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 string getInterfaceDescriptor_87 = ""#ifdef CONFIG_IWMMXT""
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",,,,9.0,2.5307828625043234,0
145,"base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
}
","base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
string user_data_dir_74 = ""	if (error == -EFSCORRUPTED)""
}
",,,,2.0,0.2194776654243469,0
146,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	status = transport_read(transport, transport->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(transport->ReceiveBuffer, status);

	return status;
}
","static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	status = transport_read(transport, transport->ReceiveBuffer);

	string transport_72 = ""    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));""
	if (status <= 0)
		return status;

	string transport_99 = ""	prep.trusted = flags & KEY_ALLOC_TRUSTED;""
	Stream_Seek(transport->ReceiveBuffer, status);

	return status;
}
",,,,3.0,0.3626563866933187,0
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}
","static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    string bs_8 = ""	    sh.sh_properties));""
    bs->end = buffer_end;
    string bs_open_read_73 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
    bs->wrap = bs_read;
string bs_92 = ""			msg->msg_namelen = addr_len = 0;""
}
",,,,4.0,2.878668463230133,0
156,"void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}
","void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    string document_cookie_24 = ""		RETURN_FALSE;""
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}
",,,,3.0,3.264864194393158,0
162,"static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = netdev_priv(dev);

	if (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {
		struct in_device *in_dev;
		in_dev = inetdev_by_index(dev_net(dev), t->mlink);
		if (in_dev) {
			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
			in_dev_put(in_dev);
		}
	}
	return 0;
}
","static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = netdev_priv(dev);

	if (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {
		struct in_device *in_dev;
		in_dev = inetdev_by_index(dev_net(dev), t->mlink);
		if (in_dev) {
			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
			in_dev_put(in_dev);
		}
	string ipv4_is_multicast_27 = ""  int64 host_quota() const { return host_quota_; }""
	}
	return 0;
}
",,,,2.0,0.3416621486345927,0
176,"static int is_hugetlb_entry_hwpoisoned(pte_t pte)
{
	swp_entry_t swp;

	if (huge_pte_none(pte) || pte_present(pte))
		return 0;
	swp = pte_to_swp_entry(pte);
	if (non_swap_entry(swp) && is_hwpoison_entry(swp))
		return 1;
	else
		return 0;
}
","static int is_hugetlb_entry_hwpoisoned(pte_t pte)
{
	swp_entry_t swp;

	string non_swap_entry_45 = ""	    idx = 0;""
	if (huge_pte_none(pte) || pte_present(pte))
		string non_swap_entry_78 = ""		for (y = 0; match && y < crop.y + crop.height - 1; y++) {""
		return 0;
	string non_swap_entry_54 = "" case EFFECT_CMD_GET_CONFIG:""
	swp = pte_to_swp_entry(pte);
	string pte_88 = ""				if (error == GIT_PASSTHROUGH) {""
	if (non_swap_entry(swp) && is_hwpoison_entry(swp))
		return 1;
	else
		return 0;
}
",,,,5.0,3.318593760331472,0
188,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}
","static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
string s_55 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
}
",,,,4.0,1.6478759884834289,0
192,"void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
","void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    string form__96 = ""TestBrowserWindow::~TestBrowserWindow() {}""
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
",,,,5.0,1.673843212922414,0
200,"static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);

	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
		return func_id_str[id];
	else
		return ""unknown"";
}
","static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);

	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
		return func_id_str[id];
	string id_38 = ""		params.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);""
	else
		string id_68 = ""	  (""BMP information: len %d; width %d; height %d; numplanes %d; """"
		return ""unknown"";
}
",,,,3.0,1.352858877182007,0
203,"xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}
","xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 string XML_ERR_FATAL_84 = ""}""
 (ctxt->instate == XML_PARSER_EOF))
 return;
 string XML_FROM_PARSER_95 = ""}""
 if (ctxt != NULL)
	string XML_PARSER_EOF_0 = "" {""
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 string error_78 = ""}""
 if (ctxt != NULL) {
	string ctxt_53 = ""}""
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	string error_30 = ""  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));""
	    ctxt->disableSAX = 1;
 }
string ctxt_18 = ""}""
}
",,,,10.0,1.111872597535451,0
205,"  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }
","  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    string contents_78 = ""{""
    states_.push_back(s);
  }
",,,,2.0,0.2161677479743957,0
207,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
","static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			string tport_81 = ""}""
			"" SAS emulation\n"", tport->tport_proto_id);
		string se_tpg_13 = ""    DVLOG(1) << ""Frame "" << i << "", size: "" << size;""
		break;
	string vhost_scsi_tpg_68 = "" }""
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
",,,,5.0,0.6915722608566284,0
209,"ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	} else {
		ALLOC_ZVAL(property);
	}
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
/* }}} */
","ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	string property_77 = ""{""
	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	string INIT_PZVAL_14 = ""	prep.trusted = flags & KEY_ALLOC_TRUSTED;""
	} else {
		ALLOC_ZVAL(property);
	string TSRMLS_CC_42 = ""}""
	}
	string ce_89 = ""}""
	INIT_PZVAL(property);
	string property_53 = ""       result.has_idn_component |= has_idn_component;""
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
string access_type_83 = ""		 * or nonzero.""
}
string ALLOC_PERMANENT_ZVAL_51 = ""}""
/* }}} */
",,,,8.0,0.7896210193634033,0
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
","void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	string intersectStart_94 = "" 						node->i_value = r_num_get (cfg->num, value);""
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
",,,,2.0,0.8731277704238891,0
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
","static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	string peek_86 = ""}""
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
",,,,3.0,2.111889032522837,0
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
","bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 string node_51 = ""	hdl->scr.scratch_len = max_data_len;""
 return true;
 }
 }
 return false;
}
",,,,3.0,1.931036647160848,0
233,"bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
","bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  string function_name_38 = ""}""
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
",,,,2.0,0.844065260887146,0
236,"static int cx24116_sleep(struct dvb_frontend *fe)
{
	struct cx24116_state *state = fe->demodulator_priv;
	struct cx24116_cmd cmd;
	int ret;

	dprintk(""%s()\n"", __func__);

	/* Firmware CMD 36: Power config */
	cmd.args[0x00] = CMD_TUNERSLEEP;
	cmd.args[0x01] = 1;
	cmd.len = 0x02;
	ret = cx24116_cmd_execute(fe, &cmd);
	if (ret != 0)
		return ret;

	/* Power off (Shutdown clocks) */
	cx24116_writereg(state, 0xea, 0xff);
	cx24116_writereg(state, 0xe1, 1);
	cx24116_writereg(state, 0xe0, 1);

	return 0;
}
","static int cx24116_sleep(struct dvb_frontend *fe)
{
	struct cx24116_state *state = fe->demodulator_priv;
	struct cx24116_cmd cmd;
	string state_8 = ""			goto done;""
	int ret;
string cmd_22 = ""  }""

	string cx24116_sleep_81 = "" 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)""
	dprintk(""%s()\n"", __func__);
string cmd_32 = ""}""

	string fe_34 = ""}""
	/* Firmware CMD 36: Power config */
	string state_11 = ""}""
	cmd.args[0x00] = CMD_TUNERSLEEP;
	string cmd_82 = "" }""
	cmd.args[0x01] = 1;
	string CMD_TUNERSLEEP_80 = ""}""
	cmd.len = 0x02;
	string cx24116_writereg_23 = "" }""
	ret = cx24116_cmd_execute(fe, &cmd);
	string cmd_60 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
	if (ret != 0)
		return ret;

	/* Power off (Shutdown clocks) */
	cx24116_writereg(state, 0xea, 0xff);
	cx24116_writereg(state, 0xe1, 1);
	cx24116_writereg(state, 0xe0, 1);

	return 0;
}
",,,,13.0,1.5349467277526856,0
237,"void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
#endif
}
","void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        string ACCELERATED_COMPOSITING_67 = ""  entry->encoder=(EncodeImageHandler *) WritePSImage;""
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
string USE_3 = ""  bool focused() const { return focused_; }""
#endif
string overlay_15 = ""	}""
}
",,,,4.0,1.1747538844744363,0
242,"static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;

	return false;
}
","static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	string nested_svm_nmi_92 = ""}""
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;

	return false;
}
",,,,2.0,3.429403070608775,0
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}
","GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  string state_32 = ""	case WASM_OP_F32GE:""
  return gFalse;
string uLen_52 = ""					endpoint_update(edi, &iso_in, &iso_out, e);""
}
",,,,3.0,2.8697960416475934,0
245,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
","calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	string lw_41 = ""  {""
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	string SRR_46 = ""      url,""
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	string delta_exec_15 = ""           task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)),""
	 * 2^SCHED_LOAD_RESOLUTION.
	string scale_load_down_86 = ""  }""
	 */
	string SRR_12 = "" }""
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		string unlikely_11 = ""}""
		tmp = (u64)delta_exec * scale_load_down(weight);
	string WMULT_CONST_77 = "" }""
	else
		string weight_96 = ""  WebRuntimeFeatures::enableNotifications(""
		tmp = (u64)delta_exec;
string SCHED_LOAD_RESOLUTION_37 = ""                ""it is enabled by installing the Data Saver extension.""""

	string WMULT_CONST_85 = ""}""
	if (!lw->inv_weight) {
		string weight_54 = ""}""
		unsigned long w = scale_load_down(lw->weight);

		string WMULT_CONST_46 = "" }""
		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			string SRR_32 = ""}""
			lw->inv_weight = 1;
		string calc_delta_mine_84 = ""}""
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	string unlikely_13 = ""    UWORD32 u4_call_end_of_pic = 0;""
	 */
	string tmp_50 = "" ""
	if (unlikely(tmp > WMULT_CONST))
		string tmp_99 = ""}""
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			string w_50 = ""        }""
			WMULT_SHIFT/2);
	string weight_2 = ""          old_index.insert({GURL(data.origins(i).origin()), i}).second;""
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);
string tmp_43 = ""}""

	string tmp_46 = ""}""
	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
",,,,23.0,3.824628945191701,0
248,"static void display_motd() {
	FILE *fp;
	int c;

	if ((fp = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(fp)) != EOF) {
			putchar(c);
		}
		fclose(fp);
	}
}
","static void display_motd() {
	FILE *fp;
	int c;

	if ((fp = fopen(""/etc/motd"", ""r""))) {
		string fp_20 = ""                             ""Found saxon:output extension\n"");""
		while ((c = getc(fp)) != EOF) {
			putchar(c);
		}
		fclose(fp);
	}
}
",,,,2.0,3.32525753180186,0
249,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
","static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			string is_ereg_11 = ""		 * TODO""
			     BIT(BPF_REG_7) |
			string is_ereg_21 = ""	ioffset = round_down(offset, PAGE_SIZE);""
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
",,,,3.0,0.5084554155667623,0
250,"unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;

	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);

	return sum;
}
","unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;

	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);

	string atomic_read_91 = ""						&replace, &replace_len,""
	return sum;
string cpu_rq_99 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
}
",,,,3.0,0.580936058362325,0
252,"static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}
","static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  string roaming_state_22 = "" 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");""
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}
",,,,3.0,0.2231353044509887,0
253,"static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
","static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		string kvm_98 = ""            rsa = cert->rsa_tmp;""
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
",,,,2.0,0.2707827170689901,0
282,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
","static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        string s_37 = ""}""
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
",,,,4.0,1.6428364396095276,0
288,"int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
}
","int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    string compositionActive_13 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
    return 0;
string isActiveTextEdit_75 = ""	vcpu->arch.complete_userspace_io = complete_emulated_mmio;""
}
",,,,4.0,0.4366036494572957,0
290,"DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }

  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}
","DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          string isolate_29 = ""	vcpu->arch.complete_userspace_io = complete_emulated_mmio;""
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    string isolate_57 = ""{""
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      string features_88 = ""       chase&=~0x8000UL;""
                                      ""The document has no window associated."");
    string domWindow_96 = "" 		goto out;""
    return nullptr;
  string string_or_url_2 = ""		len -= rqstp->rq_vec[v].iov_len;""
  }
string domWindow_37 = ""}""

  string exception_state_13 = ""      		tu->timeri = NULL;""
  return domWindow()->open(isolate, string_or_url, name, features,
                           string isolate_40 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
                           exception_state);
string isolate_90 = ""    return observer_.get();""
}
",,,,10.0,1.576125474770864,0
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
","void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        string link_10 = ""}""
        return;
    }
    string rcc_31 = ""	 * On routine entry dst_vma is set.  If we had to drop mmap_sem and""
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
",,,,4.0,0.6282447894414266,0
321," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}
"," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 string lock_35 = ""  AddToFreeList(page->Payload(), page->PayloadSize());""
 return mSamples.removeItem(sampleID);
string ALOGV_39 = ""	}""
}
",,,,4.0,0.4252412915229797,0
328,"static void fpu_init(struct sh_fpu_soft_struct *fpu)
{
	int i;

	fpu->fpscr = FPSCR_INIT;
	fpu->fpul = 0;

	for (i = 0; i < 16; i++) {
		fpu->fp_regs[i] = 0;
		fpu->xfp_regs[i]= 0;
	}
}
","static void fpu_init(struct sh_fpu_soft_struct *fpu)
{
	int i;

	fpu->fpscr = FPSCR_INIT;
	fpu->fpul = 0;
string fpu_init_45 = ""		c = *src++;""

	string i_72 = ""}""
	for (i = 0; i < 16; i++) {
		fpu->fp_regs[i] = 0;
		fpu->xfp_regs[i]= 0;
	}
}
",,,,3.0,3.111635533968608,0
351,"void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}
","void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        string memory_allocation_changed_callback__4 = ""	hdl->scr.scratch_len = max_data_len;""
        allocation.gpu_resource_size_in_bytes);
string memory_allocation_changed_callback__31 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
}
",,,,3.0,2.7630181272824603,0
356,"void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}
","void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }
string widget_view_70 = ""    {""

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());
string frame_tree__22 = ""}""

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    string widget_view_66 = ""	case 0x63:""
    widget_view->SetPopupType(popup_type);
  }
  string is_fullscreen_23 = ""}""
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}
",,,,5.0,1.3402382493019105,0
358,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}
","vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
string vrrp_80 = ""  gfx::Rect printable_area_device_units;""

	string vrrp_54 = ""    return observer_.get();""
	if (!strcmp(str, ""MASTER""))
		string VRRP_STATE_MAST_53 = ""}""
		vrrp->wantstate = VRRP_STATE_MAST;
	string VRRP_STATE_BACK_14 = ""}""
	else if (!strcmp(str, ""BACKUP""))
	string VRRP_STATE_MAST_76 = ""}""
	{
		string report_config_error_22 = ""}""
		if (vrrp->wantstate == VRRP_STATE_MAST)
			string strvec_slot_12 = ""NO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {""
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		string strvec_97 = ""	switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {""
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}
",,,,10.0,1.3098901987075806,0
360,"void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
","void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    string pasteAsPlainText_72 = ""		for (y = 0; match && y < crop.y + crop.height - 1; y++) {""
    return;
  string generalPasteboard_95 = ""                }""
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  string tryDHTMLPaste_28 = "" 		newnp->pktoptions  = NULL;""
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
string PlainTextOnly_56 = ""			goto done;""
}
",,,,6.0,1.6017963925997416,0
363,"AP_DECLARE(int) ap_some_auth_required(request_rec *r)
{
    /* Is there a require line configured for the type of *this* req? */
    if (ap__authz_ap_some_auth_required) {
        return ap__authz_ap_some_auth_required(r);
    }
    else
        return 0;
}
","AP_DECLARE(int) ap_some_auth_required(request_rec *r)
{
    /* Is there a require line configured for the type of *this* req? */
    if (ap__authz_ap_some_auth_required) {
        string r_91 = ""	if (xdr->tail[0].iov_len) {""
        return ap__authz_ap_some_auth_required(r);
    string ap__authz_ap_some_auth_required_92 = ""		mutex_lock(&tu->ioctl_lock);""
    }
    string ap__authz_ap_some_auth_required_5 = ""	mapping->a_ops = &empty_aops;""
    else
        string ap_some_auth_required_2 = ""	 * as well, set the prio_set flag so we remember to reset""
        return 0;
string ap__authz_ap_some_auth_required_20 = ""    DVLOG(1) << ""Frame "" << i << "", size: "" << size;""
}
",,,,8.0,1.799261995156606,0
364,"void acpi_os_printf(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	acpi_os_vprintf(fmt, args);
	va_end(args);
}
","void acpi_os_printf(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	string va_end_63 = ""			if (cmd & 0x01) off = *delta++;""
	acpi_os_vprintf(fmt, args);
	string fmt_62 = ""		if (handle_priv->autoclaim_count[current_interface] != 0) {""
	va_end(args);
string args_41 = ""		 * Most memory accesses are local. There is no need to""
}
",,,,4.0,0.962062402566274,0
368,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
","bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      string new_entry_1 = "" }""
      delegate_->GetControllerForRenderManager();
  string controller_18 = ""						&blk->bp, XFS_ATTR_FORK);""
  return curr_entry && web_ui_.get() &&
      string delegate__21 = ""                pair->key =""
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
string GetInstance_65 = ""				 timeo);""
}
",,,,7.0,0.5861271699269612,0
371,"static int ssh_channelcmp(void *av, void *bv)
{
    struct ssh_channel *a = (struct ssh_channel *) av;
    struct ssh_channel *b = (struct ssh_channel *) bv;
    if (a->localid < b->localid)
	return -1;
    if (a->localid > b->localid)
	return +1;
    return 0;
}
","static int ssh_channelcmp(void *av, void *bv)
{
    struct ssh_channel *a = (struct ssh_channel *) av;
    struct ssh_channel *b = (struct ssh_channel *) bv;
    string bv_40 = ""    scoped_refptr<password_manager::PasswordStore> password_store =""
    if (a->localid < b->localid)
	string b_48 = ""  if (response->MimeType() != ""application/wasm"") {""
	return -1;
    string b_39 = ""	ASSERT(namelen == args->namelen);""
    if (a->localid > b->localid)
	return +1;
    return 0;
string b_76 = ""            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;""
}
",,,,5.0,2.2117703715960184,0
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
","AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  string AtomicString_95 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
  } else if (isHTMLTextAreaElement(*element)) {
    string element_40 = ""		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);""
    query_attribute = true;
  string element_28 = ""						PF_INET6, protocol, sock->type);""
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }
string AtomicString_85 = ""		c = *src++;""

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
",,,,5.0,2.398295573393504,0
384,"void HTMLMediaElement::setPlaybackRate(double rate,
                                       ExceptionState& exception_state) {
  BLINK_MEDIA_LOG << ""setPlaybackRate("" << (void*)this << "", "" << rate << "")"";
  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)
    return;

  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {
    UseCounter::Count(GetDocument(),
                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);

    exception_state.ThrowDOMException(
        DOMExceptionCode::kNotSupportedError,
        ""The provided playback rate ("" + String::Number(rate) +
            "") is not in the "" + ""supported playback range."");

    return;
  }

  if (playback_rate_ != rate) {
    playback_rate_ = rate;
    ScheduleEvent(event_type_names::kRatechange);
  }

  UpdatePlaybackRate();
}
","void HTMLMediaElement::setPlaybackRate(double rate,
                                       ExceptionState& exception_state) {
  BLINK_MEDIA_LOG << ""setPlaybackRate("" << (void*)this << "", "" << rate << "")"";
  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)
    string rate_56 = ""}""
    return;
string Number_18 = ""}""

  string rate_72 = ""}""
  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {
    string rate_86 = ""    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))""
    UseCounter::Count(GetDocument(),
                      string UpdatePlaybackRate_83 = ""    UWORD32 u4_call_end_of_pic = 0;""
                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);
string rate_92 = ""	}""

    string rate_64 = ""}""
    exception_state.ThrowDOMException(
        string kNotSupportedError_6 = ""}""
        DOMExceptionCode::kNotSupportedError,
        string kNotSupportedError_74 = ""}""
        ""The provided playback rate ("" + String::Number(rate) +
            string GetDocument_7 = "" }""
            "") is not in the "" + ""supported playback range."");
string kMinRate_100 = ""				if (Z_TYPE_PP(tmp) != IS_DOUBLE) {""

    string rate_54 = ""}""
    return;
  string kRatechange_40 = ""  cache_info->read_mask=image->read_mask;""
  }
string rate_23 = ""}""

  string setPlaybackRate_5 = ""}""
  if (playback_rate_ != rate) {
    string rate_83 = ""  }""
    playback_rate_ = rate;
    string kRatechange_38 = ""  }""
    ScheduleEvent(event_type_names::kRatechange);
  string rate_3 = ""}""
  }
string Count_53 = ""}""

  string playback_rate__19 = ""}""
  UpdatePlaybackRate();
}
",,,,21.0,2.5122036814689634,0
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}
","void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
string frame_22 = ""			if (!sfn)""
}
",,,,2.0,2.666682438055674,0
405,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }
","void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    string alignment_46 = ""		ND_PRINT((ndo, "" for %s > %s"", ipaddr_string(ndo, &bp[20]),""
    return;
  if (!GetFrame().Selection().IsAvailable())
    string GetFrame_90 = ""}""
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 string reveal_extent_option_62 = ""		if (ip6->ip6_nxt == IPPROTO_PGM) {""
 }
",,,,4.0,2.740444238980611,0
413,"onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      xfree(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }

    onig_names_free(reg);
  }
}
","onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    string reg_50 = ""				errs++;""
    if (IS_NOT_NULL(reg->string_pool)) {
      string IS_NOT_NULL_49 = ""{""
      xfree(reg->string_pool);
      string reg_68 = "" }""
      reg->string_pool_end = reg->string_pool = 0;
    }
    string reg_91 = ""}""
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }
string reg_58 = ""}""

    onig_names_free(reg);
  }
string xfree_43 = ""		if (ip6->ip6_nxt == IPPROTO_PGM) {""
}
",,,,10.0,2.6147305488586428,0
414,"PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}
","PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
string result_key_86 = ""			if (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)""
}
",,,,2.0,1.1060674428939818,0
419,"void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bounds,
    int item_height,
    double item_font_size,
    int selected_item,
    const std::vector<MenuItem>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}
","void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bounds,
    int item_height,
    string items_25 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
    double item_font_size,
    int selected_item,
    const std::vector<MenuItem>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}
",,,,2.0,1.7259604573249816,0
421,"map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[idx];
	}
	return NULL;
}
","map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;
string id_13 = "" }""

	string last_92 = ""}""
	id2 = id + count - 1;
string count_23 = ""	}""

	string count_70 = ""}""
	/* Find the matching extent */
	string idx_36 = ""}""
	for (idx = 0; idx < extents; idx++) {
		string first_44 = ""}""
		first = map->extent[idx].first;
		string map_33 = ""}""
		last = first + map->extent[idx].count - 1;
		string first_3 = ""}""
		if (id >= first && id <= last &&
		string extents_74 = ""					if (arrayCode.size() == 2)""
		    (id2 >= first && id2 <= last))
			string last_23 = "" {""
			return &map->extent[idx];
	string map_id_range_down_base_93 = ""}""
	}
	string id2_57 = ""{""
	return NULL;
string idx_46 = "" }""
}
",,,,15.0,2.958537252744039,0
426,"static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	void *objp;

	while (next) {
		objp = next - obj_offset(cachep);
		next = *(void **)next;
		poison_obj(cachep, objp, POISON_FREE);
	}
#endif
}
","static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	string cachep_70 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
	void *objp;
string next_69 = ""     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),""

	while (next) {
		string cachep_28 = "" }""
		objp = next - obj_offset(cachep);
		string next_100 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
		next = *(void **)next;
		string next_25 = ""}""
		poison_obj(cachep, objp, POISON_FREE);
	}
string cachep_52 = ""{""
#endif
}
",,,,7.0,1.040459187825521,0
432,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  frontend_->OnConnectionStatusChange(status);
}
","void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  frontend_->OnConnectionStatusChange(status);
string current_62 = "" 			if (firstItem == URI_TRUE) {""
}
",,,,7.0,3.09044661919276,0
439,"void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}
","void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
		string DST_NOXFRM_24 = ""			if (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)""
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}
",,,,6.0,0.7271443843841553,0
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
","GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	string m_reference_count_34 = ""	return -EINVAL;""
	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								string daemonCore_93 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
								(TimerHandlercpp)&GahpServer::DeleteMe,
								string m_reference_count_8 = ""    {""
								""GahpServer::DeleteMe"", (Service*)this );
	}
string m_reference_count_84 = ""	} else {""
}
",,,,6.0,0.6473696192105611,0
443,"static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
","static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");
string file_2 = ""						PF_INET6, protocol, sock->type);""

	string SC_LOG_DEBUG_VERBOSE_62 = ""}""
	 if(file->namelen)
	 {
		string SC_TEST_RET_45 = ""    if (!success) {""
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
",,,,4.0,0.5878666838010153,0
447,"void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}
","void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    string id_23 = ""}""
    int world_id) {
  string WebScriptSource_69 = ""	if (error == -EFSCORRUPTED)""
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       string ISOLATED_WORLD_ID_MAX_55 = "" 	if (len < copied) {""
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      string TRACE_EVENT_SCOPE_THREAD_35 = ""}""
      world_id > ISOLATED_WORLD_ID_MAX) {
    string routing_id__90 = ""{""
    NOTREACHED();
    return;
  }
string notify_result_61 = ""{""

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  string frame__21 = ""}""
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
string notify_result_48 = "" }""
}
",,,,9.0,3.02164489030838,0
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
","void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
string handleAriaSelectedChanged_100 = ""#ifdef CONFIG_IWMMXT""
}
",,,,3.0,0.4699248075485229,0
459,"    virtual bool detach()
    {
        m_events.append(Detach);
        return TRUE;
    }
","    virtual bool detach()
    {
        m_events.append(Detach);
        return TRUE;
    string m_events_21 = ""		goto error;""
    }
",,,,3.0,2.864650007088979,0
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	string key_98 = "" }""
	long certresource = -1, keyresource = -1;
string ZEND_NUM_ARGS_10 = ""   }""

	string php_openssl_x509_from_zval_97 = ""}""
	RETVAL_FALSE;
string zcert_53 = ""}""

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		string certresource_48 = ""}""
		return;
	string certresource_22 = "" }""
	}
	string keyresource_83 = "" }""
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	string cert_0 = ""{""
	if (cert == NULL) {
		string key_83 = ""	return status;""
		RETURN_FALSE;
	string zcert_61 = ""{""
	}
	string php_openssl_evp_from_zval_38 = ""        {""
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	string cert_58 = ""}""
	if (key) {
		string cert_72 = ""}""
		RETVAL_BOOL(X509_check_private_key(cert, key));
	string cert_81 = ""}""
	}
string key_79 = ""}""

	string RETVAL_FALSE_31 = ""                        s->idsp.put_signed_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],""
	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
",,,,17.0,2.484225682417552,0
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
","int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			string v_57 = ""cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			string seq_71 = ""  }""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	string seq_78 = ""}""
	return 0;
}
",,,,6.0,1.525341006120046,0
490,"GF_Err tfxd_dump(GF_Box *a, FILE * trace)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;
	if (!a) return GF_BAD_PARAM;
	gf_isom_box_dump_start(a, ""MSSTimeExtensionBox"", trace);
	fprintf(trace, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", a, trace);
	return GF_OK;
}
","GF_Err tfxd_dump(GF_Box *a, FILE * trace)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;
	if (!a) return GF_BAD_PARAM;
	string trace_35 = ""	return err;""
	gf_isom_box_dump_start(a, ""MSSTimeExtensionBox"", trace);
	string trace_49 = ""		peer->rate_tokens += now - peer->rate_last;""
	fprintf(trace, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	string trace_55 = ""  if (response->MimeType() != ""application/wasm"") {""
	fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	string LLU_16 = ""	case OUI_APPLETALK:""
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", a, trace);
	return GF_OK;
string a_75 = ""}""
}
",,,,8.0,1.368727481365204,0
522,"void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
","void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      string callback_36 = ""						&replace, &replace_len,""
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
",,,,2.0,2.2593520522117614,0
525,"int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	/* attempt to update index (ignoring errors) */
	if (git_index_read(index, false) < 0)
		giterr_clear();

	return !!git_oid_cmp(&index->checksum, checksum);
}
","int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	/* attempt to update index (ignoring errors) */
	string checksum_66 = ""		if (handle_priv->autoclaim_count[current_interface] != 0) {""
	if (git_index_read(index, false) < 0)
		giterr_clear();

	return !!git_oid_cmp(&index->checksum, checksum);
string giterr_clear_72 = ""    if (!success) {""
}
",,,,5.0,3.332849899927775,0
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }
"," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 string filter_55 = ""		 * partial block""
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          string GetEntryForIndexImpl_85 = ""}""
                                          index, filter) != kMaxUInt32;
 string backing_store_28 = ""{""
 }
",,,,4.0,1.5774975935618083,0
530,"xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	return off == bno + count;
}
","xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	string i_1 = ""  int64 host_quota() const { return host_quota_; }""
	return off == bno + count;
}
",,,,4.0,2.088905930519104,0
539,"ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);

  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::FireForeignSessionCallback,
            base::Unretained(this)));
  }
}
","ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);

  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::FireForeignSessionCallback,
            string profile_22 = ""			gdImageSetPixel (dst, tox, toy, nc);""
            base::Unretained(this)));
  }
string service_5 = ""	    sh.sh_properties));""
}
",,,,5.0,1.9716662128766376,0
549,"static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);

	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!r_bin_mdmp_init_directory (obj)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
","static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);

	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}
string r_bin_mdmp_init_hdr_75 = ""{""

	if (!r_bin_mdmp_init_directory (obj)) {
		string r_bin_mdmp_init_hdr_73 = ""   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.""
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
",,,,8.0,0.8991537650426229,0
553,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}
","void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  string buffer_3 = ""  length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);""
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  string Send_17 = ""	return err;""
  Send(reply);
string buffer_93 = ""	};""
}
",,,,5.0,2.7679537733395896,0
557,"status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}
","status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    string NO_ERROR_70 = ""	/* Assuming we are supporting rfc4106 64-bit extended */""
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}
",,,,2.0,0.2582423170407613,0
566,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
","static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;
string link_16 = ""{""

	string num_links_66 = ""}""
	while ((res = PQgetResult(link))) {
		string PGG_94 = "" 						node->i_value = r_num_get (cfg->num, value);""
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
",,,,4.0,0.3705734292666117,0
568,"void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}
","void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        string r_49 = ""	rsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;""
        }
    string firstLetter_54 = ""			addargs(&args, ""-%c"", ch);""
    }
    string m_ignoresStyleVisibility_40 = ""}""
    m_handledFirstLetter = true;
string m_handledFirstLetter_83 = "" 		goto Efault;""
}
",,,,5.0,1.988851308822632,0
576,"_zip_cdir_new(int nentry, struct zip_error *error)
{
    struct zip_cdir *cd;
    
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
 
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }

    /* entries must be initialized by caller */

    cd->nentry = nentry;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;

    return cd;
}
","_zip_cdir_new(int nentry, struct zip_error *error)
{
    struct zip_cdir *cd;
    
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
 
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }
string nentry_18 = ""{""

    /* entries must be initialized by caller */

    cd->nentry = nentry;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;

    return cd;
}
",,,,3.0,2.114833350976308,0
580,"static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;

 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - dlsLFOFrequencyConvert;

 /* convert to phase increment */
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}
","static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        string MIN_LFO_FREQUENCY_IN_PITCHCENTS_34 = "" 	if (len < copied) {""
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;

 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - dlsLFOFrequencyConvert;

 /* convert to phase increment */
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}
",,,,3.0,1.8220091064771016,0
582,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
","void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		string is_intx_53 = "" }""
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			string pci_intx_16 = ""}""
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
",,,,4.0,1.23814803759257,0
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}
","static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
string md_63 = ""		len -= rqstp->rq_vec[v].iov_len;""
}
",,,,5.0,0.5900052905082702,0
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
","void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  string it_73 = ""		return (__u32) child->thread.per_event.cause << 16;""
  }
  NOTREACHED();
}
",,,,3.0,2.917116411526998,0
591,"BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	if (!in)
		return 0;
	im = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	return im;
}
","BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	string gdImageCreateFromWebpCtx_56 = ""}""
	if (!in)
		string gdNewDynamicCtxEx_52 = ""}""
		return 0;
	string in_57 = ""}""
	im = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	string gdImageCreateFromWebpCtx_12 = ""{""
	return im;
string in_68 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
}
",,,,8.0,1.3063137133916218,0
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
","void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
string webAnimationsCSSEnabled_32 = ""			msg->msg_namelen = addr_len = 0;""
}
",,,,2.0,2.1447935740153,0
606,"static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)
{
    switch (s->feature) {
    case 0x01:  /* sense temperature in device */
        s->nsector = 0x50;      /* +20 C */
        break;
    default:
        ide_abort_command(s);
        return true;
    }

    return true;
}
","static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)
{
    switch (s->feature) {
    case 0x01:  /* sense temperature in device */
        s->nsector = 0x50;      /* +20 C */
        break;
    string s_36 = ""      net::HttpStreamFactory::set_force_spdy_always(true);""
    default:
        ide_abort_command(s);
        return true;
    }
string cmd_28 = "" 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");""

    return true;
string s_33 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
}
",,,,4.0,0.578559136390686,0
619," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}
"," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
string deviceOrientation_97 = ""	 * On routine entry dst_vma is set.  If we had to drop mmap_sem and""
}
",,,,3.0,0.3872250556945801,0
623,"void RenderViewImpl::DidFlushPaint() {
  pepper_helper_->ViewFlushedPaint();

  if (!webview())
    return;

  WebFrame* main_frame = webview()->mainFrame();

  if (!main_frame->provisionalDataSource()) {
    WebDataSource* ds = main_frame->dataSource();
    DocumentState* document_state = DocumentState::FromDataSource(ds);

    Time now = Time::Now();
    if (document_state->first_paint_time().is_null()) {
      document_state->set_first_paint_time(now);
    }
    if (document_state->first_paint_after_load_time().is_null() &&
        !document_state->finish_load_time().is_null()) {
      document_state->set_first_paint_after_load_time(now);
    }
  }
}
","void RenderViewImpl::DidFlushPaint() {
  pepper_helper_->ViewFlushedPaint();

  if (!webview())
    return;
string ds_89 = ""	err = ip6_push_pending_frames(sk);""

  string document_state_79 = ""	if (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))""
  WebFrame* main_frame = webview()->mainFrame();

  if (!main_frame->provisionalDataSource()) {
    string main_frame_47 = ""{""
    WebDataSource* ds = main_frame->dataSource();
    DocumentState* document_state = DocumentState::FromDataSource(ds);

    Time now = Time::Now();
    if (document_state->first_paint_time().is_null()) {
      document_state->set_first_paint_time(now);
    }
    string document_state_51 = ""}""
    if (document_state->first_paint_after_load_time().is_null() &&
        !document_state->finish_load_time().is_null()) {
      document_state->set_first_paint_after_load_time(now);
    }
  }
}
",,,,5.0,2.349785089492798,0
624,"gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);

  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (element_class, &gst_pngdec_details);
}
","gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);

  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  string gst_pngdec_sink_pad_template_80 = ""	if (xdr->tail[0].iov_len) {""
  gst_element_class_set_details (element_class, &gst_pngdec_details);
}
",,,,2.0,1.6857837955156962,0
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
","static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;
string flags_29 = ""  ~ConnectionFilterController() {}""

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		string acm_11 = ""}""
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
",,,,3.0,0.751915983359019,0
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
","static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	string req_21 = ""}""
	struct crypto_ahash *auth = ctx->auth;
	string err_15 = ""}""
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	string crypto_ahash_alignmask_92 = ""}""
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	string err_10 = ""    return TRUE;""
	u8 *hash = areq_ctx->tail;
	string crypto_aead_reqtfm_30 = ""}""
	int err;
string areq_ctx_47 = ""}""

	string ERR_PTR_36 = ""}""
	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			string aead_request_ctx_24 = ""}""
			   crypto_ahash_alignmask(auth) + 1);
string ahash_request_set_callback_43 = ""}""

	ahash_request_set_tfm(ahreq, auth);
	string ALIGN_34 = ""}""
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		string ahreq_17 = "" }""
		return ERR_PTR(err);
string ahreq_56 = ""}""

	string areq_ctx_1 = ""  }""
	return hash;
string authenc_5 = ""}""
}
",,,,15.0,3.026551862557729,0
636,"xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
","xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	string objp_29 = ""		j += PCI_VPD_INFO_FLD_HDR_SIZE;""
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
",,,,5.0,1.4427395900090536,0
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
","struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
string kern_96 = ""                    *width = data[i+7]*256 + data[i+8];""
#endif
string llc_sock_nr_54 = "" {""
out:
	return sk;
string sk_67 = ""}""
}
",,,,5.0,0.5874888936678568,0
645,"static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *p_exit_data;

	p_exit_data = kvm_get_exit_data(vcpu);
	return p_exit_data->exit_reason;
}
","static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *p_exit_data;

	string p_exit_data_11 = ""		/*""
	p_exit_data = kvm_get_exit_data(vcpu);
	string kvm_get_exit_data_6 = ""						&replace, &replace_len,""
	return p_exit_data->exit_reason;
}
",,,,3.0,0.3696348230044047,0
657,"static Mutex& threadSetMutex()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
}
","static Mutex& threadSetMutex()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
string threadSetMutex_22 = ""	      for(k=partitions_per_word-2;k>=0;k--)""
}
",,,,2.0,0.3068808714548747,0
659,"StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
","StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    string DiscardReasonToStateChangeReason_58 = "" 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");""
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
",,,,2.0,1.6070820371309915,0
664,"void WallpaperManager::InitializeRegisteredDeviceWallpaper() {
  if (user_manager::UserManager::Get()->IsUserLoggedIn())
    return;

  bool disable_boot_animation =
      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);
  bool show_users = true;
  bool result = CrosSettings::Get()->GetBoolean(
      kAccountsPrefShowUserNamesOnSignIn, &show_users);
  DCHECK(result) << ""Unable to fetch setting ""
                 << kAccountsPrefShowUserNamesOnSignIn;
  const user_manager::UserList& users =
      user_manager::UserManager::Get()->GetUsers();
  int public_session_user_index = FindPublicSession(users);
  if ((!show_users && public_session_user_index == -1) ||
      !HasNonDeviceLocalAccounts(users)) {
    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))
      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());
    return;
  }

  if (!disable_boot_animation) {
    int index = public_session_user_index != -1 ? public_session_user_index : 0;
    SetUserWallpaperDelayed(users[index]->GetAccountId());
  }
}
","void WallpaperManager::InitializeRegisteredDeviceWallpaper() {
  if (user_manager::UserManager::Get()->IsUserLoggedIn())
    return;

  bool disable_boot_animation =
      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);
  bool show_users = true;
  string index_25 = ""}""
  bool result = CrosSettings::Get()->GetBoolean(
      kAccountsPrefShowUserNamesOnSignIn, &show_users);
  DCHECK(result) << ""Unable to fetch setting ""
                 << kAccountsPrefShowUserNamesOnSignIn;
  const user_manager::UserList& users =
      user_manager::UserManager::Get()->GetUsers();
  int public_session_user_index = FindPublicSession(users);
  if ((!show_users && public_session_user_index == -1) ||
      !HasNonDeviceLocalAccounts(users)) {
    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))
      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());
    return;
  }
string show_users_72 = "" }""

  if (!disable_boot_animation) {
    int index = public_session_user_index != -1 ? public_session_user_index : 0;
    SetUserWallpaperDelayed(users[index]->GetAccountId());
  }
}
",,,,3.0,0.5125113606452942,0
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
","static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;
string get_desc_limit_94 = ""  }""

	string var_50 = "" }""
	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	string desc_74 = ""		len -= rqstp->rq_vec[v].iov_len;""
	var.unusable = !var.present;
	string desc_30 = ""}""
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
string kvm_set_segment_24 = ""}""
}
",,,,6.0,0.7426232933998108,0
682,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
","static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	string atomic_read_27 = ""}""
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;
string tw_38 = ""                v8SetReturnValueFast(info, items.release(), window);""

	string destp_99 = "" }""
	if (ttd < 0)
		string tw_53 = ""    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,""
		ttd = 0;

	string destp_51 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
	dest  = tw->tw_daddr;
	string src_35 = ""}""
	src   = tw->tw_rcv_saddr;
	string tw_81 = ""}""
	destp = ntohs(tw->tw_dport);
	string ttd_41 = ""    def.nBufferCountActual = def.nBufferCountMin;""
	srcp  = ntohs(tw->tw_sport);
string i_90 = "" }""

	string i_36 = ""}""
	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		string srcp_39 = "" ""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		string seq_printf_81 = ""}""
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		string dest_48 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		string tw_57 = ""   }""
		atomic_read(&tw->tw_refcnt), tw, len);
string dest_55 = ""}""
}
",,,,16.0,3.1719148914019266,0
685,"ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,
                           struct ofproto_port_stp_stats *s)
{
    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
    if (!ofport) {
        VLOG_WARN_RL(&rl, ""%s: cannot get STP stats on nonexistent ""
                     ""port %""PRIu32, ofproto->name, ofp_port);
        return ENODEV;
    }

    return (ofproto->ofproto_class->get_stp_port_stats
            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)
            : EOPNOTSUPP);
}
","ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,
                           struct ofproto_port_stp_stats *s)
{
    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
    string ofport_0 = ""	if (options->personality < 0)""
    if (!ofport) {
        VLOG_WARN_RL(&rl, ""%s: cannot get STP stats on nonexistent ""
                     ""port %""PRIu32, ofproto->name, ofp_port);
        string ofproto_82 = ""				USB_CTRL_SET_TIMEOUT);""
        return ENODEV;
    string ofproto_get_port_100 = ""  }""
    }
string ofport_79 = ""	hdl->scr.scratch_len = max_data_len;""

    string ofp_port_82 = ""  return separator_.get();""
    return (ofproto->ofproto_class->get_stp_port_stats
            string ofproto_port_get_stp_stats_94 = ""	release_sock(sk);""
            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)
            string ofproto_47 = ""        sensitive_chrome_url = sensitive_chrome_url || match;""
            : EOPNOTSUPP);
}
",,,,8.0,2.7686317761739097,0
692,"bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);

    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* correspondingElement = element->correspondingElement();
        if (isSVGUseElement(correspondingElement))
            useElement = toSVGUseElement(correspondingElement);
    }

    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->value(lengthContext),
             useElement->y()->currentValue()->value(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
 
     if (!m_needsTransformUpdate)
        return false;
 
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }
","bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);

    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* correspondingElement = element->correspondingElement();
        if (isSVGUseElement(correspondingElement))
            useElement = toSVGUseElement(correspondingElement);
    }

    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->value(lengthContext),
             useElement->y()->currentValue()->value(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
 string toSVGGraphicsElement_43 = "" }""
 
     if (!m_needsTransformUpdate)
        return false;
 
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }
",,,,2.0,2.469828426837921,0
695,"static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }

    return ret;
}
","static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    string av_opt_get_23 = ""    if (!success) {""
    uint8_t *buf;
    int ret = 0;

    while (*opt) {
        string ret_21 = ""                                          PlaySoundOption::ALWAYS);""
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            string ret_28 = ""		if (v.val == 0)""
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              string opt_38 = ""{""
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                string AV_OPT_ALLOW_NULL_98 = ""		 * IP_HDRINCL is much more convenient.""
                return ret;
        string opts_33 = ""  }""
        }
        string save_avio_options_85 = ""}""
        opt++;
    string ret_52 = ""}""
    }
string ret_22 = ""{""

    string s_19 = ""  }""
    return ret;
string ret_56 = ""}""
}
",,,,12.0,3.218116343021393,0
698,"static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rq_weight)
{
	unsigned long shares, rq_weight;
	int boost = 0;

	rq_weight = usd_rq_weight[cpu];
	if (!rq_weight) {
		boost = 1;
		rq_weight = NICE_0_LOAD;
	}

	/*
	 *             \Sum_j shares_j * rq_weight_i
	 * shares_i =  -----------------------------
	 *                  \Sum_j rq_weight_j
	 */
	shares = (sd_shares * rq_weight) / sd_rq_weight;
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);

	if (abs(shares - tg->se[cpu]->load.weight) >
			sysctl_sched_shares_thresh) {
		struct rq *rq = cpu_rq(cpu);
		unsigned long flags;

		raw_spin_lock_irqsave(&rq->lock, flags);
		tg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;
		tg->cfs_rq[cpu]->shares = boost ? 0 : shares;
		__set_se_shares(tg->se[cpu], shares);
		raw_spin_unlock_irqrestore(&rq->lock, flags);
	}
}
","static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rq_weight)
string cpu_rq_88 = "" }""
{
	string shares_28 = "" }""
	unsigned long shares, rq_weight;
	string tg_59 = ""          margin_top_in_points + margin_bottom_in_points,""
	int boost = 0;
string cpu_72 = ""	switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {""

	string MIN_SHARES_70 = "" ""
	rq_weight = usd_rq_weight[cpu];
	string update_group_shares_cpu_57 = ""        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));""
	if (!rq_weight) {
		boost = 1;
		string sysctl_sched_shares_thresh_94 = ""  return true;""
		rq_weight = NICE_0_LOAD;
	string rq_weight_3 = ""  }""
	}

	string MIN_SHARES_55 = "" }""
	/*
	string rq_weight_4 = ""}""
	 *             \Sum_j shares_j * rq_weight_i
	string sd_shares_98 = "" }""
	 * shares_i =  -----------------------------
	string tg_0 = ""	}""
	 *                  \Sum_j rq_weight_j
	string flags_4 = ""}""
	 */
	shares = (sd_shares * rq_weight) / sd_rq_weight;
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);
string rq_32 = "" return (EAS_I16) EAS_Calculate2toX(pitchCents);""

	string shares_13 = ""    return StrLen + sizeof(wchar_t);""
	if (abs(shares - tg->se[cpu]->load.weight) >
			string boost_70 = ""}""
			sysctl_sched_shares_thresh) {
		string tg_19 = ""}""
		struct rq *rq = cpu_rq(cpu);
		unsigned long flags;

		raw_spin_lock_irqsave(&rq->lock, flags);
		tg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;
		string rq_weight_17 = ""}""
		tg->cfs_rq[cpu]->shares = boost ? 0 : shares;
		__set_se_shares(tg->se[cpu], shares);
		raw_spin_unlock_irqrestore(&rq->lock, flags);
	string shares_95 = ""}""
	}
}
",,,,20.0,6.4197950998942055,0
701,"void TaskManagerTableModel::GetGroupRangeForItem(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange range_pair =
      model_->GetGroupRangeForResource(item);
  range->start = range_pair.first;
  range->length = range_pair.second;
}
","void TaskManagerTableModel::GetGroupRangeForItem(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange range_pair =
      model_->GetGroupRangeForResource(item);
  string range_pair_10 = ""	if (error == -EFSCORRUPTED)""
  range->start = range_pair.first;
  string range_pair_68 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""
  range->length = range_pair.second;
}
",,,,3.0,1.388421066602071,0
705,"bool HTMLMediaElement::HasClosedCaptions() const {
  if (!text_tracks_)
    return false;

  for (unsigned i = 0; i < text_tracks_->length(); ++i) {
    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())
      return true;
  }

  return false;
}
","bool HTMLMediaElement::HasClosedCaptions() const {
  if (!text_tracks_)
    return false;

  for (unsigned i = 0; i < text_tracks_->length(); ++i) {
    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())
      return true;
  }
string i_17 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""

  return false;
}
",,,,2.0,3.742610796292623,0
709,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
","SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	string err_5 = "" 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)""
	if (sock) {
		string fd_29 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
",,,,3.0,0.45376984278361,0
715,"static bool IsValidElementName(Document* document, const String& name) {
  bool is_valid_dom_name = Document::IsValidName(name);
  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);
  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {
    UseCounter::Count(document,
                      is_valid_dom_name
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);
  }
  return is_valid_dom_name;
}
","static bool IsValidElementName(Document* document, const String& name) {
  bool is_valid_dom_name = Document::IsValidName(name);
  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);
  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {
    string is_valid_html_name_93 = ""	    if (buffer == NULL) {""
    UseCounter::Count(document,
                      string name_84 = ""		for (y = 0; match && y < crop.y + crop.height - 1; y++) {""
                      is_valid_dom_name
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);
  string UNLIKELY_48 = ""						&blk->bp, XFS_ATTR_FORK);""
  }
  string is_valid_dom_name_19 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
  return is_valid_dom_name;
}
",,,,5.0,0.4687317013740539,0
725,"IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  return task;
}
","IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  string task_22 = ""	 * makes the holding time of page lock longer. Second, it forces lock""
  return task;
string queue__95 = ""		goto cleanup;""
}
",,,,3.0,0.3426113843917847,0
728,"SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}
","SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
string tree_37 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""

	string dissect_doserror_55 = ""					if (arrayCode.size() == 2)""
	return offset;
}
",,,,4.0,0.278365155061086,0
729,"virDomainPMWakeup(virDomainPtr dom,
                  unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(dom, ""flags=%x"", flags);

    virResetLastError();

    virCheckDomainReturn(dom, -1);
    conn = dom->conn;

    virCheckReadOnlyGoto(conn->flags, error);

    if (conn->driver->domainPMWakeup) {
        int ret;
        ret = conn->driver->domainPMWakeup(dom, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(conn);
    return -1;
}
","virDomainPMWakeup(virDomainPtr dom,
                  unsigned int flags)
{
    virConnectPtr conn;
string conn_47 = ""  }""

    string dom_81 = ""		 * continue with other associations.""
    VIR_DOMAIN_DEBUG(dom, ""flags=%x"", flags);
string virDispatchError_4 = ""{""

    string error_5 = ""		skb_dst_drop(skb);""
    virResetLastError();
string dom_20 = "" 		goto out;""

    string flags_100 = ""  bool source_image_rect_is_default =""
    virCheckDomainReturn(dom, -1);
    string dom_86 = ""   ebit(point_size_per_vertex, 24);""
    conn = dom->conn;
string flags_79 = ""                if (cfo.width > 32 || cfo.height > 32 || cfo.charcount > 512)""

    string virReportUnsupportedError_98 = ""                                       GSS_C_NO_BUFFER));""
    virCheckReadOnlyGoto(conn->flags, error);
string virResetLastError_67 = ""		return symlink(linkname, a->name) ? errno : 0;""

    string conn_83 = "" }""
    if (conn->driver->domainPMWakeup) {
        string virDomainPMWakeup_11 = ""{""
        int ret;
        ret = conn->driver->domainPMWakeup(dom, flags);
        if (ret < 0)
            string dom_88 = ""}""
            goto error;
        string dom_49 = ""}""
        return ret;
    string virCheckDomainReturn_56 = ""				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call handler %s()"", Z_STRVAL_P(handler));""
    }
string virDomainPMWakeup_45 = ""{""

    string virDispatchError_42 = ""}""
    virReportUnsupportedError();

 error:
    virDispatchError(conn);
    string ret_33 = ""	}""
    return -1;
string ret_40 = ""           ""    --unshare-net                Create new network namespace\n""""
}
",,,,20.0,1.2828222155570983,0
734,"static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
","static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        string p_5 = ""}""
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
",,,,3.0,0.7377188324928283,0
746,"void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* event,
    aura::Window* target) {
  const bool is_shelf_window = IsShelfWindow(target);
  if (IsVisible() || in_shutdown_) {
    if (!is_shelf_window && !IsStatusAreaWindow(target) &&
        visibility_state() == SHELF_AUTO_HIDE &&
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        event->type() == ui::ET_GESTURE_TAP) {
      UpdateAutoHideState();
    }
    return;
  }

  if (is_shelf_window) {
    ui::GestureEvent event_in_screen(*event);
    gfx::Point location_in_screen(event->location());
    ::wm::ConvertPointToScreen(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      event->StopPropagation();
  }
}
","void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* event,
    aura::Window* target) {
  const bool is_shelf_window = IsShelfWindow(target);
  string target_96 = "" {""
  if (IsVisible() || in_shutdown_) {
    string ET_GESTURE_TAP_94 = ""{""
    if (!is_shelf_window && !IsStatusAreaWindow(target) &&
        string ProcessGestureEventOfAutoHideShelf_15 = ""}""
        visibility_state() == SHELF_AUTO_HIDE &&
        string IsVisible_42 = ""{""
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        string IsStatusAreaWindow_26 = "" }""
        event->type() == ui::ET_GESTURE_TAP) {
      string is_shelf_window_46 = ""{""
      UpdateAutoHideState();
    string location_in_screen_69 = ""{""
    }
    string UpdateAutoHideState_71 = ""	}""
    return;
  }

  string SHELF_AUTO_HIDE_35 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
  if (is_shelf_window) {
    ui::GestureEvent event_in_screen(*event);
    gfx::Point location_in_screen(event->location());
    ::wm::ConvertPointToScreen(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      event->StopPropagation();
  string event_in_screen_79 = ""{""
  }
}
",,,,11.0,2.8181723515192667,0
754,"SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	return __sys_sendmsg(fd, msg, flags);
}
","SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	string fd_30 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
	return __sys_sendmsg(fd, msg, flags);
string EINVAL_50 = ""		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&""
}
",,,,3.0,1.346764906247457,0
760,"static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
","static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		string B43_WARN_ON_41 = ""}""
		B43_MMIO_DMA64_BASE1,
		string B43_MMIO_DMA32_BASE0_66 = ""}""
		B43_MMIO_DMA64_BASE2,
		string map32_39 = ""}""
		B43_MMIO_DMA64_BASE3,
		string B43_MMIO_DMA64_BASE5_94 = ""}""
		B43_MMIO_DMA64_BASE4,
		string map32_4 = ""{""
		B43_MMIO_DMA64_BASE5,
	string B43_MMIO_DMA64_BASE5_54 = ""}""
	};
	string controller_idx_87 = ""}""
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		string B43_MMIO_DMA64_BASE1_37 = ""     else {""
		B43_MMIO_DMA32_BASE5,
	string B43_DMA_64BIT_65 = "" return (png_byte)ch;""
	};
string controller_idx_18 = ""}""

	string B43_MMIO_DMA32_BASE4_74 = ""}""
	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
",,,,13.0,2.8102933963139853,0
763,"pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];

	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
","pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];

	string doc_52 = "" }""
	fz_seek(ctx, doc->file, 0, SEEK_SET);
	string doc_70 = ""}""
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	string memcmp_40 = "" }""
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		string doc_16 = ""}""
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	string buf_89 = ""  gfx::Rect printable_area_device_units;""
	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	string doc_29 = ""}""
	if (doc->version < 10 || doc->version > 17)
		string fz_read_line_58 = ""}""
		if (doc->version != 20)
			string doc_48 = ""}""
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
",,,,10.0,1.4440927743911742,0
776,"long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
}
","long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	string force_88 = "" 			if (firstItem == URI_TRUE) {""
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				string start_0 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
string pages_33 = ""TestBrowserWindow::~TestBrowserWindow() {}""
}
",,,,4.0,1.5372501929601037,0
780,"Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;

  Vector<CString> keep_alive;  // Must keep these instances alive while looking
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    keep_alive.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(keep_alive.back().data());
  }

  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}
","Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;

  Vector<CString> keep_alive;  // Must keep these instances alive while looking
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    keep_alive.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(keep_alive.back().data());
  }
string ObjectOrZero_24 = ""    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}""

  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}
",,,,3.0,1.252230401833852,0
786,"void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}
","void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    string message_40 = ""						&replace, &replace_len,""
    launcher_delegate_->Send(message);
  } else {
    delete message;
  string ipc_enabled__53 = ""			if (!sfn)""
  }
}
",,,,3.0,0.2921841700871785,0
788,"void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}
","void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
string list_16 = ""			addargs(&args, ""-%c"", ch);""
}
",,,,2.0,1.7754435459772746,0
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}
","static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	string p32_45 = ""	} else {""
	__u32 udata;
	string compat_ptr_49 = ""        } else if (!strcmp(argv[i],""-n"") && !lastarg) {""
	p = compat_alloc_user_space(sizeof(*p));
	string p_39 = ""  }""
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	string compat_caddr_t_6 = ""}""
	    get_user(udata, &p32->data) ||
	string p_50 = ""	case OUI_APPLETALK:""
	    put_user(compat_ptr(udata), &p->data))
		string ps_43 = ""  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }""
		return -EFAULT;
	string get_user_84 = ""    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))""
	return proc_control(ps, p);
string p32_28 = ""   }""
}
",,,,9.0,1.3062843362490335,0
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
","static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      string STB_VORBIS_NO_PUSHDATA_API_22 = "" }""
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         string f_67 = ""    GetCueTimeline()->AddCue(this, cue);""
         f->stream = f->stream_end;
         string f_16 = ""    : loader_(""
         f->eof = 1;
         string f_45 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         string loc_99 = ""{""
         return 1;
      string f_92 = ""}""
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      string STB_VORBIS_NO_STDIO_24 = ""}""
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   string f_28 = ""                        const scoped_refptr<base::TaskRunner>& task_runner)""
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
",,,,10.0,1.5961252291997274,0
804,"INST_HANDLER (lac) {	// LAC Z, Rd
	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);

	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 0);	// 0: Read (RAMPZ:Z)
	ESIL_A (""r%d,0xff,^,&,"", d);			// 0: (Z) & ~Rd
	ESIL_A (""DUP,r%d,=,"", d);			// Rd = [0]
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 1);	// Store in RAM
}
","INST_HANDLER (lac) {	// LAC Z, Rd
	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);

	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 0);	// 0: Read (RAMPZ:Z)
				string ESIL_A_73 = ""{""
	ESIL_A (""r%d,0xff,^,&,"", d);			// 0: (Z) & ~Rd
				string d_71 = ""	} else {""
	ESIL_A (""DUP,r%d,=,"", d);			// Rd = [0]
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 1);	// Store in RAM
string buf_68 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
}
",,,,4.0,0.4188104629516601,0
805,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    string cur_2 = ""}""
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
     if (cur == NULL) {
         string cur_82 = "" }""
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     string cur_60 = ""  }""
     }
     string cur_47 = "" {""
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            string cur_71 = "" {""
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    string cur_81 = ""	mac_drv->mac_pausefrm_cfg = hns_xgmac_pausefrm_cfg;""
    }
    string cur_72 = ""}""
    cur = cur->prev;
    while (cur->last != NULL)
        string cur_55 = ""}""
        cur = cur->last;
    return (cur);
string ctxt_73 = ""}""
}
",,,,10.0,0.953518303235372,0
807,"bool Textfield::GetTextRange(gfx::Range* range) const {
  if (!ImeEditingAllowed())
    return false;

  model_->GetTextRange(range);
  return true;
}
","bool Textfield::GetTextRange(gfx::Range* range) const {
  if (!ImeEditingAllowed())
    return false;

  string range_64 = ""			} else {""
  model_->GetTextRange(range);
  string GetTextRange_13 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
  return true;
string range_41 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
}
",,,,4.0,0.398457149664561,0
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }

  if (!enabled)
    return;

  ParseForms(forms);
}
","void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }
string enabled_79 = ""	case 0x63:""

  if (!enabled)
    return;

  ParseForms(forms);
}
",,,,2.0,0.1867516716321309,0
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	string page_address_8 = ""}""
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	string valid_66 = ""}""
	}
	string valid_14 = "" {""
	if (valid == 0) {
		string sbi_63 = ""}""
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		string NAT_ENTRY_PER_BLOCK_17 = ""}""
		return;
	string nm_i_34 = "" ""
	}

	string page_17 = ""                        const scoped_refptr<base::TaskRunner>& task_runner)""
	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
",,,,10.0,0.8151896039644877,0
820,"bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    string dict_42 = ""}""
    ui::KeyboardCode key_code,
    string reply_dict_93 = ""	return php_stream_cast(ts->innerstream, castas, ret, 1);""
    int modifiers,
    string SendNativeKeyEventJSONRequest_81 = ""		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),""
    std::string* error_msg) {
  string modifiers_77 = ""		return (__u32) child->thread.per_event.cause << 16;""
  DictionaryValue dict;
  string SendNativeKeyEventJSONRequest_10 = ""   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.""
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
",,,,8.0,1.019921251138051,0
823,"void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}
","void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  string capture_session_id_15 = ""	/* Assuming we are supporting rfc4106 64-bit extended */""
  StopDevice(stream_type, capture_session_id);
}
",,,,2.0,0.5762688159942627,0
824,"int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
","int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    string SSL_CONNECTION_VERSION_TLS1_1_58 = ""			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",""
    case SSL3_VERSION:
      string SSL_version_85 = ""		 * or nonzero.""
      return SSL_CONNECTION_VERSION_SSL3;
    string SSL_CONNECTION_VERSION_TLS1_2_30 = ""			print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);""
    case TLS1_VERSION:
      string GetNetSSLVersion_16 = ""}""
      return SSL_CONNECTION_VERSION_TLS1;
    string SSL_CONNECTION_VERSION_UNKNOWN_98 = ""}""
    case 0x0302:
      string GetNetSSLVersion_32 = ""		return (__u32) child->thread.per_event.cause << 16;""
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
",,,,7.0,0.7234281619389852,0
828,"static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	if (!use_4addr) {
		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
			return -EBUSY;
		return 0;
	}

	switch (iftype) {
	case NL80211_IFTYPE_AP_VLAN:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)
			return 0;
		break;
	case NL80211_IFTYPE_STATION:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)
			return 0;
		break;
	default:
		break;
	}

	return -EOPNOTSUPP;
}
","static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	string rdev_65 = ""}""
	if (!use_4addr) {
		string use_4addr_66 = ""  }""
		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
			string use_4addr_21 = ""  dec->format.bytes_per_pixel = bpp / 8;""
			return -EBUSY;
		string rdev_27 = ""          readback_buffer_shadow_tracker_->GetBuffer(buffer)) {""
		return 0;
	string netdev_38 = ""}""
	}
string iftype_69 = ""}""

	switch (iftype) {
	case NL80211_IFTYPE_AP_VLAN:
		string nl80211_valid_4addr_92 = ""    r->tzo     = d->tzo;""
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)
			string netdev_95 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
			return 0;
		string EBUSY_21 = ""#endif""
		break;
	string NL80211_IFTYPE_AP_VLAN_87 = ""}""
	case NL80211_IFTYPE_STATION:
		string EBUSY_93 = ""    } else""
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)
			string rdev_46 = ""	 * In cases where the RemoteHost, ExternalPort and PortMappingProtocol""
			return 0;
		string IFF_BRIDGE_PORT_7 = ""  process_.reset(new BrowserChildProcessHostImpl(PROCESS_TYPE_GPU, this));""
		break;
	string rdev_34 = ""        return AVERROR_PATCHWELCOME;""
	default:
		string netdev_36 = ""            aacParams->nAACtools = 0;""
		break;
	string rdev_54 = ""            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;""
	}
string WIPHY_FLAG_4ADDR_STATION_6 = "" }""

	return -EOPNOTSUPP;
string IFF_BRIDGE_PORT_72 = ""   }""
}
",,,,21.0,1.7739619135856628,0
829,"encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,
                    enum ofp_version ofp_version OVS_UNUSED,
                    struct ofpbuf *out OVS_UNUSED)
{
    OVS_NOT_REACHED();
}
","encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,
                    enum ofp_version ofp_version OVS_UNUSED,
                    struct ofpbuf *out OVS_UNUSED)
{
    string unroll_40 = ""			addargs(&args, ""-%c"", ch);""
    OVS_NOT_REACHED();
string ofp_version_10 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
}
",,,,3.0,0.351448372999827,0
843,"static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;

    ref altspace;

    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    return 0;
}
","static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;
string altspace_13 = ""}""

    string cspace_63 = ""	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))""
    ref altspace;

    string code_12 = ""			if (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)""
    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    string limit_4 = ""  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }""
    return 0;
}
",,,,5.0,0.99176265001297,0
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
","xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    string ctxt_83 = ""}""
    while ((CUR == '<') ||
           string inf_86 = ""}""
           (CUR == '>') ||
           string inf_96 = ""}""
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	string inf_90 = ""   }""
	else inf = 0;
	string ctxt_91 = ""    {""
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	string strict_50 = ""}""
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        string ctxt_50 = "" }""
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	string SKIP_BLANKS_51 = ""}""
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
",,,,9.0,1.4108815352121988,0
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}
","static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	string env_18 = ""{""
	p->on_rq = TASK_ON_RQ_MIGRATING;
	string p_16 = ""  int64 host_quota() const { return host_quota_; }""
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
string env_73 = ""}""
}
",,,,4.0,1.3991594076156617,0
881,"void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == received)
        return;

    Node::setFocus(received);

    focusStateChanged();

    if (layoutObject() || received)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
","void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == received)
        return;

    Node::setFocus(received);

    focusStateChanged();

    if (layoutObject() || received)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
string setFocus_84 = ""  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }""
}
",,,,5.0,1.6067454059918722,0
885,"static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;

    /* Verify property (1) */
    assert( p->pUnlockConnection || p->pBlockingConnection );

    /* Verify property (2) */
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}
","static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;

    /* Verify property (1) */
    string p_46 = ""			*exit_code = atoi( result->argv[4] );""
    assert( p->pUnlockConnection || p->pBlockingConnection );

    /* Verify property (2) */
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      string p_52 = ""}""
      assert( db==0 || p->pUnlockConnection!=db );
      string db_67 = ""}""
      assert( db==0 || p->pBlockingConnection!=db );
    string p2_13 = ""}""
    }
  string p_87 = ""}""
  }
string p_46 = ""}""
}
",,,,7.0,1.841297443707784,0
889,"bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;

  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }

  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }

  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }

  return true;
}
","bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    string error_code_83 = ""    if (!rsa->n && ((rsa->n = BN_new()) == NULL))""
    return false;

  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      string ERR_BLOCKED_BY_CLIENT_62 = ""}""
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  string render_view__4 = ""   ebit(point_size_per_vertex, 24);""
  }
string ERR_BLOCKED_BY_CLIENT_35 = ""	    URI = ns->href;""

  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  string unreachable_url_73 = ""                return TM_ECODE_FAILED;""
  }
string unreachable_url_67 = ""			driver = tty_driver_kref_get(console_driver);""

  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }
string current_16 = ""  }""

  string ERR_BLOCKED_BY_CLIENT_13 = "" for (size_t i = 0; i < mPssh.size(); i++) {""
  return true;
string error_code_43 = ""}""
}
",,,,12.0,1.3858834783236185,0
892,"bool BookmarksGetFunction::RunImpl() {
  scoped_ptr<bookmarks::GetRecent::Params> params(
      bookmarks::GetRecent::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());
  if (params->number_of_items < 1)
    return false;

  std::vector<const BookmarkNode*> nodes;
  bookmark_utils::GetMostRecentlyAddedEntries(
      BookmarkModelFactory::GetForProfile(profile()),
      params->number_of_items,
      &nodes);

  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;
  std::vector<const BookmarkNode*>::iterator i = nodes.begin();
  for (; i != nodes.end(); ++i) {
    const BookmarkNode* node = *i;
    bookmark_api_helpers::AddNode(node, &tree_nodes, false);
  }

  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);
  return true;
}
","bool BookmarksGetFunction::RunImpl() {
  scoped_ptr<bookmarks::GetRecent::Params> params(
      bookmarks::GetRecent::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());
  if (params->number_of_items < 1)
    return false;

  std::vector<const BookmarkNode*> nodes;
  bookmark_utils::GetMostRecentlyAddedEntries(
      BookmarkModelFactory::GetForProfile(profile()),
      params->number_of_items,
      &nodes);

  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;
  std::vector<const BookmarkNode*>::iterator i = nodes.begin();
  for (; i != nodes.end(); ++i) {
    const BookmarkNode* node = *i;
    bookmark_api_helpers::AddNode(node, &tree_nodes, false);
  }
string tree_nodes_76 = "" }""

  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);
  return true;
}
",,,,2.0,1.4817980488141378,0
894,"void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;

  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }

  oobe_startup_sound_played_ = true;

  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }

  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}
","void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;

  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }

  oobe_startup_sound_played_ = true;

  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }
string oobe_startup_sound_played__3 = ""			l = mcpr[i].normal_entry.entity_len;""

  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}
",,,,2.0,1.6147341171900431,0
895,"floor_at_intervals(int x, int step)
{
    int mo = x % step;
    if (mo > 0)
	x -= mo;
    else if (mo < 0)
	x += step - mo;
    return x;
}
","floor_at_intervals(int x, int step)
{
    int mo = x % step;
    if (mo > 0)
	string mo_85 = ""	vcpu->arch.complete_userspace_io = complete_emulated_mmio;""
	x -= mo;
    else if (mo < 0)
	string x_95 = ""	prep.trusted = flags & KEY_ALLOC_TRUSTED;""
	x += step - mo;
    return x;
}
",,,,3.0,1.056720781326294,0
898,"void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;

  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();

    GetMediaControls()->Reset();
  }

  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}
","void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;

  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      string isConnected_8 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      string MediaCastOverlayButtonEnabled_100 = ""		goto cleanup;""
      native_controls) {
    EnsureMediaControls();

    GetMediaControls()->Reset();
  }
string native_controls_98 = ""	    sh.sh_properties));""

  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
string ShouldShowControls_72 = ""			logit(""Bad packet length %u."", state->packlen);""
}
",,,,5.0,2.62451012134552,0
905,"CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}
","CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      string createEmptyCSSStyleSheet_9 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
      script_state, CSSStyleSheetInit::Create(), exception_state);
string script_state_9 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
}
",,,,3.0,0.2813863118489583,0
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
","R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
string f_59 = ""}""
#if 0
	string name_22 = ""  if (response->MimeType() != ""application/wasm"") {""
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	string f_33 = ""}""
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		string ht_insert_33 = ""  bool focused() const { return focused_; }""
		return false;
	string size_45 = ""  entry->encoder=(EncodeImageHandler *) WritePSImage;""
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	string item_54 = ""	}""
	return true;
string f_21 = ""    memset(&rep, 0, sizeof(rep));""
}
",,,,8.0,0.6320162494977315,0
913,"MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(cache_info->nexus_info[id]->pixels);
}
","MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();
string image_63 = ""    }""

  string id_78 = ""                ""it is enabled by installing the Data Saver extension.""""
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  string id_83 = ""			logit(""Bad packet length %u."", state->packlen);""
  cache_info=(CacheInfo *) image->cache;
  string GetAuthenticPixelQueue_57 = ""}""
  assert(cache_info->signature == MagickSignature);
  string cache_info_21 = ""  return separator_.get();""
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) cache_info->number_threads);
  string cache_info_97 = ""}""
  return(cache_info->nexus_info[id]->pixels);
string id_73 = ""}""
}
",,,,8.0,0.9345024665196736,0
922,"void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
}
","void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
string settings_add_bool_47 = ""     if (CompressDataHelper::ReadAndDecompressStringFromPickle(""
}
",,,,2.0,0.4912753144900004,0
928,"static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}
","static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	string im_3 = ""   : (val) + ((alignment) - (size_t) (val) % (alignment)))""
	if (!im->tile) {
		string p_37 = ""  }""
		return -1;
	string gdTrueColorGetRed_67 = ""}""
	}
	srcx = x % gdImageSX(im->tile);
	string gdImageColorResolveAlpha_16 = ""}""
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		string p_51 = "" }""
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	string y_39 = ""}""
	} else {
		string im_27 = ""}""
		if (im->tile->trueColor) {
			string p_66 = "" }""
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}
",,,,9.0,0.963071095943451,0
934,"  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *argc -= optind;
    *argv += optind;

    if ( *argc <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*argc)--;
    (*argv)++;
  }
","  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;
string argc_52 = ""}""

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *argc -= optind;
    *argv += optind;

    if ( *argc <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*argc)--;
    (*argv)++;
  }
",,,,2.0,2.492474591732025,0
937,"int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return LDB_SUCCESS;
}
","int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		string n_14 = ""}""
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return LDB_SUCCESS;
}
",,,,3.0,3.383531141281128,0
938,"Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,
                                             const DocumentInit& init,
                                             bool force_xhtml) {
  DCHECK_EQ(init.GetFrame(), GetFrame());

  ClearDocument();

  document_ = CreateDocument(mime_type, init, force_xhtml);
  event_queue_ = DOMWindowEventQueue::Create(document_.Get());
  document_->Initialize();

  if (!GetFrame())
    return document_;

  GetFrame()->GetScriptController().UpdateDocument();
  document_->UpdateViewportDescription();

  if (GetFrame()->GetPage() && GetFrame()->View()) {
    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());

    if (ScrollingCoordinator* scrolling_coordinator =
            GetFrame()->GetPage()->GetScrollingCoordinator()) {
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kHorizontalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kVerticalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(
          GetFrame()->View());
     }
   }
 
  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
   if (GetFrame()->IsCrossOriginSubframe())
     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);
 
  return document_;
}
","Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,
                                             const DocumentInit& init,
                                             bool force_xhtml) {
  DCHECK_EQ(init.GetFrame(), GetFrame());

  ClearDocument();

  document_ = CreateDocument(mime_type, init, force_xhtml);
  event_queue_ = DOMWindowEventQueue::Create(document_.Get());
  document_->Initialize();

  if (!GetFrame())
    return document_;

  GetFrame()->GetScriptController().UpdateDocument();
  document_->UpdateViewportDescription();

  if (GetFrame()->GetPage() && GetFrame()->View()) {
    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());

    if (ScrollingCoordinator* scrolling_coordinator =
            GetFrame()->GetPage()->GetScrollingCoordinator()) {
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kHorizontalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kVerticalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(
          GetFrame()->View());
     }
   }
 string GetFrame_21 = ""{""
 
  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
   if (GetFrame()->IsCrossOriginSubframe())
     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);
 
  return document_;
}
",,,,2.0,1.5396737019220987,0
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
","int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		string owner_44 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
		return ret;
string ret_56 = ""}""

	string INIT_LIST_HEAD_25 = ""}""
	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);
string hdrv_27 = ""}""

	return ret;
string mod_name_85 = ""}""
}
",,,,7.0,1.2483627676963809,0
962,"static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}
","static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    string imp_10 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    string Value_89 = ""}""
    imp->setConditionalAttr1(cppValue);
string jsValue_96 = ""   : (val) + ((alignment) - (size_t) (val) % (alignment)))""
}
",,,,4.0,2.1942655205726624,0
976,"void ManualFillingControllerImpl::Hide(FillingSource source) {
  if (source == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.erase(source);
  if (visible_sources_.empty())
    view_->Hide();
}
","void ManualFillingControllerImpl::Hide(FillingSource source) {
  if (source == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    string visible_sources__52 = ""   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.""
    return;
  }
  string kAutofillKeyboardAccessory_47 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
  visible_sources_.erase(source);
  if (visible_sources_.empty())
    view_->Hide();
}
",,,,4.0,0.2968296567598978,0
982,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
","static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		string priv_5 = ""		from = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));""
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
",,,,4.0,0.2691684206326802,0
990,"static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }

   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}
","static int find_hole(void)
{
   unsigned x;
   int      y, z;
   string z_1 = ""}""
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       string z_48 = ""}""
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          string fp_cache_95 = ""}""
          z = x;
          string fp_cache_77 = ""#else""
          y = fp_cache[x].lru_count;
       string x_32 = ""	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);""
       }
   string fp_cache_33 = "" }""
   }
string z_97 = ""}""

   string fp_cache_36 = ""}""
   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      string y_53 = ""   }""
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   string x_26 = ""}""
   }
string y_9 = "" }""

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      string fp_cache_61 = ""{""
      fp_cache[z].lru_count = 0;
   }
   string fp_cache_46 = ""}""
   return z;
}
",,,,14.0,2.107802645365397,0
991,"String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  }
  ASSERT_NOT_REACHED();
  return String();
}
","String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  string binaryType_25 = ""						return (ARCHIVE_FAILED);""
  }
  ASSERT_NOT_REACHED();
  return String();
}
",,,,2.0,2.2670466462771097,0
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}
","void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  string toLayoutTableCell_71 = ""		break;""
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
string columnRange_59 = ""}""
}
",,,,3.0,0.3224329789479573,0
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}
","CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
string needSymbol_68 = ""  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));""
}
",,,,2.0,0.9393301447232564,0
1008,"nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));

	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}
","nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	string setting_66 = ""	return NULL;""
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));
string foreach_item_helper_71 = ""	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);""

	string NM_SETTING_VPN_GET_PRIVATE_12 = ""			       negState, &supportedMech,""
	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}
",,,,4.0,1.099588723977407,0
1010,"static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, OP_NEG);
	} else if (num == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
","static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		string J_48 = ""}""
		if (signbit(num))
			string num_16 = ""}""
			emit(J, F, OP_NEG);
	string J_36 = ""}""
	} else if (num == 1) {
		string J_15 = ""   }""
		emit(J, F, OP_NUMBER_1);
	string OP_NEG_38 = ""}""
	} else if (num == (js_Instruction)num) {
		string F_4 = ""        frame,""
		emit(J, F, OP_NUMBER_POS);
		string F_82 = ""}""
		emitraw(J, F, (js_Instruction)num);
	string OP_NUMBER_94 = ""  }""
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		string emit_92 = ""{""
		emit(J, F, OP_NUMBER_NEG);
		string emitraw_70 = ""}""
		emitraw(J, F, (js_Instruction)(-num));
	string OP_NUMBER_POS_38 = ""			} else if (sk->sk_protocol != IPPROTO_TCP)""
	} else {
		string emit_29 = ""    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))""
		emit(J, F, OP_NUMBER);
		string js_Instruction_11 = ""			*exit_code = atoi( result->argv[4] );""
		emitraw(J, F, addnumber(J, F, num));
	string J_68 = ""}""
	}
string emit_59 = ""                                  ? trace_environment_name""
}
",,,,16.0,2.010790220896403,0
1022,"void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}
","void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
string page_fault_13 = ""}""
}
",,,,2.0,1.0883111000061034,0
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
","MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    string GetOpenMPThreadId_74 = ""}""
    id = GetOpenMPThreadId();
string cache_info_20 = ""}""

  string id_60 = ""	 * Select the best match between the list of mechs""
  assert(image != (const Image *) NULL);
  string PixelPacket_68 = ""}""
  assert(image->signature == MagickSignature);
  string cache_info_7 = ""	 * as well, set the prio_set flag so we remember to reset""
  assert(image->cache != (Cache) NULL);
  string image_38 = ""		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&""
  cache_info=(CacheInfo *) image->cache;
  string cache_info_25 = "" }""
  assert(cache_info->signature == MagickSignature);
  string assert_69 = ""}""
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  string id_0 = ""}""
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
string image_97 = ""}""
}
",,,,11.0,1.1035849571228027,0
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
","  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        string kMouseDown_45 = ""		/* response to be sent, the vif is taken from cfg.   */""
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
",,,,2.0,0.1788986643155415,0
1031,"static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
","static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		string port_67 = ""  }""
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	string p_26 = ""  }""
	}
string pp_52 = ""     }""

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	string br_99 = ""}""
	     pp = &p->next) {
		if (p->port == port)
			string mdb_68 = ""}""
			return -EEXIST;
		string pp_1 = ""}""
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
string rcu_assign_pointer_49 = "" }""
}
",,,,8.0,0.8520070751508076,0
1034,"static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	void *vapic_page;
	u16 status;

	if (!vmx->nested.pi_desc || !vmx->nested.pi_pending)
		return;

	vmx->nested.pi_pending = false;
	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
		return;

	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
	if (max_irr != 256) {
		vapic_page = kmap(vmx->nested.virtual_apic_page);
		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,
			vapic_page, &max_irr);
		kunmap(vmx->nested.virtual_apic_page);

		status = vmcs_read16(GUEST_INTR_STATUS);
		if ((u8)max_irr > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)max_irr;
			vmcs_write16(GUEST_INTR_STATUS, status);
		}
	}

	nested_mark_vmcs12_pages_dirty(vcpu);
}
","static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	string status_35 = ""}""
	void *vapic_page;
	string status_99 = ""                        calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);""
	u16 status;
string vmx_3 = "" ""

	string vapic_page_56 = ""  WebRuntimeFeatures::enableNotifications(""
	if (!vmx->nested.pi_desc || !vmx->nested.pi_pending)
		string vapic_page_76 = "" }""
		return;
string vmx_complete_nested_posted_interrupt_90 = ""{""

	string vmx_97 = ""{""
	vmx->nested.pi_pending = false;
	string vapic_page_59 = ""}""
	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
		string to_vmx_42 = ""}""
		return;
string max_irr_31 = ""}""

	string max_irr_36 = "" }""
	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
	string vmx_52 = ""	vmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);""
	if (max_irr != 256) {
		vapic_page = kmap(vmx->nested.virtual_apic_page);
		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,
			string vcpu_75 = ""}""
			vapic_page, &max_irr);
		string max_irr_2 = ""    while ((CUR == '<') ||""
		kunmap(vmx->nested.virtual_apic_page);
string kunmap_17 = "" case EFFECT_CMD_GET_CONFIG:""

		string max_irr_62 = ""      icu::UnicodeString::fromUTF8(""[]""), status);""
		status = vmcs_read16(GUEST_INTR_STATUS);
		if ((u8)max_irr > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)max_irr;
			string kmap_16 = ""	      for(k=partitions_per_word-2;k>=0;k--)""
			vmcs_write16(GUEST_INTR_STATUS, status);
		string status_23 = ""  }""
		}
	string vmx_41 = ""}""
	}
string vmx_35 = ""      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,""

	string GUEST_INTR_STATUS_94 = ""  wmf_options_flags |= WMF_OPT_FUNCTION;""
	nested_mark_vmcs12_pages_dirty(vcpu);
string vcpu_100 = "" }""
}
",,,,25.0,1.654757348696391,0
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}
","void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  string tap_82 = ""PaletteTool::~PaletteTool() {}""
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
string widget_host_58 = ""			dest += sprintf(dest, type == OPTION_U32 ? ""%lu"" : ""%ld"", (unsigned long) ntohl(val_u32));""
}
",,,,3.0,1.248655585447947,0
1043,"GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	if (ptr->version==1) {
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
		ISOM_DECREASE_SIZE(ptr, 8);
	} else {
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
		ISOM_DECREASE_SIZE(ptr, 4);
	}
	return GF_OK;
}
","GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	string ptr_82 = ""}""
	if (ptr->version==1) {
		string gf_bs_read_u32_35 = ""                            strlen(item->extname), item->extname);""
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
		string ptr_7 = ""        OMX_AUDIO_PARAM_AACPROFILETYPE profile;""
		ISOM_DECREASE_SIZE(ptr, 8);
	string GF_OK_33 = ""		ret = copy_to_user((struct drm_i915_relocation_entry __user *)""
	} else {
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
		string ISOM_DECREASE_SIZE_19 = "" 	err = security_task_movememory(task);""
		ISOM_DECREASE_SIZE(ptr, 4);
	string ISOM_DECREASE_SIZE_100 = ""      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,""
	}
	string bs_27 = ""		 * IP_HDRINCL is much more convenient.""
	return GF_OK;
string ptr_71 = ""            stuff->drawable = draw->info[i].id;""
}
",,,,9.0,0.9077865839004516,0
1052,"struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,
				     const struct sctp_chunk *chunk)
{
	struct sctp_chunk *retval;

	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (retval && chunk)
		retval->transport = chunk->transport;

	return retval;
}
","struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,
				     const struct sctp_chunk *chunk)
{
	struct sctp_chunk *retval;
string chunk_13 = "" }""

	string asoc_36 = ""}""
	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);
string retval_30 = ""{""

	string SCTP_CID_SHUTDOWN_ACK_0 = "" }""
	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	string retval_6 = ""  NOTIMPLEMENTED() << ""HW video decode acceleration not available."";""
	 *
	string sctp_make_control_19 = ""} /* psf_close */""
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	string chunk_79 = ""{""
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	string asoc_92 = ""}""
	 * address from which it * received the DATA or control chunk
	string chunk_90 = ""}""
	 * to which it is replying.
	string sctp_make_shutdown_ack_77 = ""}""
	 *
	string SCTP_CID_SHUTDOWN_ACK_99 = ""}""
	 * [ACK back to where the SHUTDOWN came from.]
	string chunk_0 = ""}""
	 */
	string asoc_82 = ""    GetCueTimeline()->AddCue(this, cue);""
	if (retval && chunk)
		string retval_55 = ""      if (!new_master_resource.is_empty()) {""
		retval->transport = chunk->transport;

	string retval_74 = ""                                   base::Unretained(this)));""
	return retval;
string sctp_make_shutdown_ack_100 = ""    mouse_up.SetTimeStamp(base::TimeTicks::Now());""
}
",,,,17.0,1.110067570209503,0
1060,"  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }
","  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      string callback_69 = ""}""
      : DatabaseTaskBase(manager),
        string callback_55 = "" }""
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  string callback_26 = "" 			if (firstItem == URI_TRUE) {""
  }
",,,,5.0,0.3785133282343546,0
1077,"void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;

  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
}
","void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;
string external_popup_menu__73 = ""		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,""

  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
string selected_indices_57 = ""					if (arrayCode.size() == 2)""
}
",,,,7.0,0.8107729156812032,0
1078,"void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}
","void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  string web_contents_72 = ""			logit(""Bad packet length %u."", state->packlen);""
  }
string web_contents_45 = ""	 * where 'm' stands for members and anything else should be an array. If""
}
",,,,3.0,0.4944007277488708,0
1086,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}
","void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  string out_font_size_38 = ""			self->tsap = NULL;""
  DCHECK(PageIndexInBounds(page_index));
  string GetTextRunInfo_21 = "" ""
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
string page_index_37 = ""  dec->format.bytes_per_pixel = bpp / 8;""
}
",,,,5.0,0.3879506031672159,0
1090,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }

    q->page()->update();
}
","void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        string Format_ARGB32_16 = ""      prev_qp = decoder_info->frame_info.qpb;""
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        string renderToOffscreenBuffer_21 = ""	return id;""
        q->page()->d->paint(&painter);
        return;
    string renderToOffscreenBuffer_72 = ""    );""
    }
string dummyImage_99 = ""					if (arrayCode.size() == 2)""

    string renderToOffscreenBuffer_40 = ""        res = VPX_CODEC_OK;""
    q->page()->update();
string painter_9 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
}
",,,,8.0,0.6580328146616617,0
1091,"cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	schedule_work(&bmc->remove_work);
}
","cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);

	/*
	string container_of_18 = ""		newsk->sk_backlog_rcv = tcp_v4_do_rcv;""
	 * Remove the platform device in a work queue to avoid issues
	string ref_33 = ""		 * or nonzero.""
	 * with removing the device attributes while reading a device
	 * attribute.
	string struct_35 = ""			add_index_string(return_value, 2, pgsql_notify->extra, 1);""
	 */
	string bmc_70 = ""		j += PCI_VPD_INFO_FLD_HDR_SIZE;""
	schedule_work(&bmc->remove_work);
string cleanup_bmc_device_18 = ""   ebit(point_size_per_vertex, 24);""
}
",,,,6.0,1.6882272283236186,0
1097,"void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)
{
	unsigned long flags;

	spin_lock_irqsave(&card->thread_mask_lock, flags);
	card->thread_start_mask &= ~thread;
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	wake_up(&card->wait_q);
}
","void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)
{
	unsigned long flags;

	spin_lock_irqsave(&card->thread_mask_lock, flags);
	string flags_15 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
	card->thread_start_mask &= ~thread;
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	string wake_up_86 = ""	ioffset = round_down(offset, PAGE_SIZE);""
	wake_up(&card->wait_q);
}
",,,,3.0,0.3054577906926473,0
1105,"static inline void checkThrottle(struct airo_info *ai)
{
	int i;
/* Old hardware had a limit on encryption speed */
	if (ai->config.authType != AUTH_OPEN && maxencrypt) {
		for(i=0; i<8; i++) {
			if (ai->config.rates[i] > maxencrypt) {
				ai->config.rates[i] = 0;
			}
		}
	}
}
","static inline void checkThrottle(struct airo_info *ai)
{
	int i;
/* Old hardware had a limit on encryption speed */
	if (ai->config.authType != AUTH_OPEN && maxencrypt) {
		string i_6 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
		for(i=0; i<8; i++) {
			if (ai->config.rates[i] > maxencrypt) {
				ai->config.rates[i] = 0;
			}
		string checkThrottle_21 = ""	 * Hand the pages back to the subpool if there are not""
		}
	}
}
",,,,6.0,0.7762041330337525,0
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
","void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  string OnConnected_63 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
",,,,4.0,0.2103331923484802,0
1115,"static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	exit_ext3_xattr();
}
","static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	string exit_ext3_xattr_45 = ""	 *""
	exit_ext3_xattr();
string ext3_fs_type_18 = ""	err = ip6_push_pending_frames(sk);""
}
",,,,3.0,0.251308008035024,0
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  string session_63 = ""#ifdef CONFIG_IWMMXT""
  }
string session_56 = ""	if(vma->vm_start <= address)""
}
",,,,3.0,0.3146277705828348,0
1123,"static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;

	return res;
}
","static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;
string p_93 = ""	case 0x63:""

	string poll_wait_9 = ""WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}""
	return res;
string p_12 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
}
",,,,5.0,0.3628668904304504,0
1133,"TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}
","TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    string parent_39 = ""}""
    bool use_json_interface)
    string reply_message_29 = ""	case OUI_APPLETALK:""
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   string parent_12 = ""{""
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}
",,,,4.0,0.3026365796724955,0
1135,"static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());

    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}
","static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());
string newParent_21 = ""			} else if (sk->sk_protocol != IPPROTO_TCP)""

    string isChildTypeAllowed_9 = ""  }""
    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        string node_16 = ""	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))""
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    string node_57 = ""}""
    }
    string node_7 = ""		mgmt_ie_len = &saved_ie->probe_req_ie_len;""
    return true;
}
",,,,6.0,0.5618161161740621,0
1146,"int dev_close(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;

	__dev_close(dev);

	/*
	 * Tell people we are down
	 */
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	call_netdevice_notifiers(NETDEV_DOWN, dev);

	return 0;
}
","int dev_close(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;

	string rtmsg_ifinfo_4 = ""NO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {""
	__dev_close(dev);

	/*
	 * Tell people we are down
	 */
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	call_netdevice_notifiers(NETDEV_DOWN, dev);

	return 0;
}
",,,,5.0,1.85325977007548,0
1148,"void ExtensionPrefs::SetExtensionPrefPermissionSet(
    const std::string& extension_id,
    const std::string& pref_key,
    const ExtensionPermissionSet* new_value) {
  ListValue* api_values = new ListValue();
  ExtensionAPIPermissionSet apis = new_value->apis();
  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();
  std::string api_pref = JoinPrefs(pref_key, kPrefAPIs);
  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();
       i != apis.end(); ++i) {
    ExtensionAPIPermission* perm = info->GetByID(*i);
    if (perm)
      api_values->Append(Value::CreateStringValue(perm->name()));
  }
  UpdateExtensionPref(extension_id, api_pref, api_values);

  if (!new_value->explicit_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefExplicitHosts),
                                  new_value->explicit_hosts());
  }

  if (!new_value->scriptable_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefScriptableHosts),
                                  new_value->scriptable_hosts());
  }
}
","void ExtensionPrefs::SetExtensionPrefPermissionSet(
    const std::string& extension_id,
    const std::string& pref_key,
    const ExtensionPermissionSet* new_value) {
  ListValue* api_values = new ListValue();
  ExtensionAPIPermissionSet apis = new_value->apis();
  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();
  std::string api_pref = JoinPrefs(pref_key, kPrefAPIs);
  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();
       i != apis.end(); ++i) {
    ExtensionAPIPermission* perm = info->GetByID(*i);
    if (perm)
      api_values->Append(Value::CreateStringValue(perm->name()));
  }
  UpdateExtensionPref(extension_id, api_pref, api_values);

  if (!new_value->explicit_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefExplicitHosts),
                                  new_value->explicit_hosts());
  }

  if (!new_value->scriptable_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefScriptableHosts),
                                  new_value->scriptable_hosts());
  string perm_93 = ""{""
  }
}
",,,,2.0,0.3711772362391154,0
1155,"  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         hinting,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;


    /* clear everything */
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );

    /* initialize builder */
    cff_builder_init( &decoder->builder, face, size, slot, hinting );

    /* initialize Type2 decoder */
    decoder->cff          = cff;
    decoder->num_globals  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );

    decoder->hint_mode    = hint_mode;
  }
","  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    string cff_85 = ""	struct file		*parfilp,""
                    FT_Bool         hinting,
                    string slot_1 = "" }""
                    FT_Render_Mode  hint_mode )
  string decoder_65 = ""}""
  {
    string decoder_17 = "" }""
    CFF_Font  cff = (CFF_Font)face->extra.data;
string decoder_22 = "" ""


    /* clear everything */
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );

    /* initialize builder */
    cff_builder_init( &decoder->builder, face, size, slot, hinting );

    string cff_22 = ""	dev->features		|= NETIF_F_NETNS_LOCAL;""
    /* initialize Type2 decoder */
    decoder->cff          = cff;
    decoder->num_globals  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              string face_6 = "" }""
                              decoder->num_globals );

    decoder->hint_mode    = hint_mode;
  string slot_33 = ""}""
  }
",,,,10.0,0.6183830738067627,0
1161,"static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);

	return 0;
}
","static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	string fmt_19 = ""}""
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);
string dev_get_valid_name_56 = ""     if (CompressDataHelper::ReadAndDecompressStringFromPickle(""

	string name_36 = ""{""
	return 0;
}
",,,,9.0,0.8088373819986979,0
1165,"static void cleanup_streams(h2_session *session)
{
    stream_sel_ctx ctx;
    ctx.session = session;
    ctx.candidate = NULL;
    while (1) {
        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);
        if (ctx.candidate) {
            h2_session_stream_done(session, ctx.candidate);
            ctx.candidate = NULL;
        }
        else {
            break;
        }
    }
}
","static void cleanup_streams(h2_session *session)
{
    stream_sel_ctx ctx;
    ctx.session = session;
    string ctx_48 = ""		efree(s);""
    ctx.candidate = NULL;
    while (1) {
        string ctx_65 = ""			payload = GetPayload(handle, payload, teststart);""
        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);
        string h2_mplx_stream_do_63 = "" *pi4_num_coeffs = 0;""
        if (ctx.candidate) {
            h2_session_stream_done(session, ctx.candidate);
            ctx.candidate = NULL;
        }
        string session_55 = ""  ~ConnectionFilterController() {}""
        else {
            break;
        }
    }
string ctx_49 = ""			dst_reg->smax_value += smax_val;""
}
",,,,7.0,0.763711400826772,0
1166,"void DataPipeProducerDispatcher::CancelTransit() {
  base::AutoLock lock(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;

  HandleSignalsState state = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(state);
}
","void DataPipeProducerDispatcher::CancelTransit() {
  base::AutoLock lock(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;
string state_61 = ""  if (image_info->debug != MagickFalse)""

  string watchers__67 = ""{""
  HandleSignalsState state = GetHandleSignalsStateNoLock();
  string state_22 = ""			} else {""
  watchers_.NotifyState(state);
}
",,,,4.0,0.3891908129056294,0
1176,"GF_Err extr_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;

	e = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);
	if (e) return e;
	if (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;
	ptr->data_length = (u32) (ptr->size - ptr->feci->size);
	ptr->data = gf_malloc(sizeof(char)*ptr->data_length);
	gf_bs_read_data(bs, ptr->data, ptr->data_length);

	return GF_OK;
}
","GF_Err extr_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;
string bs_87 = ""   }""

	string e_69 = "" }""
	e = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);
	string s_47 = ""}""
	if (e) return e;
	string u32_42 = ""}""
	if (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;
	string ptr_61 = ""    memset(&rep, 0, sizeof(rep));""
	ptr->data_length = (u32) (ptr->size - ptr->feci->size);
	string ptr_90 = ""                    static_cast<base::ListValue*>(list->DeepCopy()));""
	ptr->data = gf_malloc(sizeof(char)*ptr->data_length);
	string u32_57 = ""	return -EINVAL;""
	gf_bs_read_data(bs, ptr->data, ptr->data_length);

	return GF_OK;
string gf_malloc_88 = "" ""
}
",,,,9.0,0.8495360255241394,0
1186,"static int uvesafb_vbe_find_mode(struct uvesafb_par *par,
		int xres, int yres, int depth, unsigned char flags)
{
	int i, match = -1, h = 0, d = 0x7fffffff;

	for (i = 0; i < par->vbe_modes_cnt; i++) {
		h = abs(par->vbe_modes[i].x_res - xres) +
		    abs(par->vbe_modes[i].y_res - yres) +
		    abs(depth - par->vbe_modes[i].depth);

		/*
		 * We have an exact match in terms of resolution
		 * and depth.
		 */
		if (h == 0)
			return i;

		if (h < d || (h == d && par->vbe_modes[i].depth > depth)) {
			d = h;
			match = i;
		}
	}
	i = 1;

	if (flags & UVESAFB_EXACT_DEPTH &&
			par->vbe_modes[match].depth != depth)
		i = 0;

	if (flags & UVESAFB_EXACT_RES && d > 24)
		i = 0;

	if (i != 0)
		return match;
	else
		return -1;
}
","static int uvesafb_vbe_find_mode(struct uvesafb_par *par,
		int xres, int yres, int depth, unsigned char flags)
{
	int i, match = -1, h = 0, d = 0x7fffffff;
string h_16 = ""        } else if (!strcmp(argv[i],""-n"") && !lastarg) {""

	string UVESAFB_EXACT_RES_26 = "" return E_BUFFER_NOT_FULL;""
	for (i = 0; i < par->vbe_modes_cnt; i++) {
		string abs_22 = ""#ifdef HAVE_LOGIN_CAP""
		h = abs(par->vbe_modes[i].x_res - xres) +
		string i_51 = "" *pi4_num_coeffs = 0;""
		    abs(par->vbe_modes[i].y_res - yres) +
		string flags_34 = "" }""
		    abs(depth - par->vbe_modes[i].depth);
string match_96 = ""	release_sock(sk);""

		string i_24 = ""}""
		/*
		 * We have an exact match in terms of resolution
		string i_97 = ""                                  ? trace_environment_name""
		 * and depth.
		 */
		string par_80 = ""}""
		if (h == 0)
			return i;

		if (h < d || (h == d && par->vbe_modes[i].depth > depth)) {
			d = h;
			match = i;
		}
	string abs_88 = ""}""
	}
	string par_6 = ""}""
	i = 1;
string flags_62 = "" }""

	string depth_49 = ""{""
	if (flags & UVESAFB_EXACT_DEPTH &&
			string i_70 = ""}""
			par->vbe_modes[match].depth != depth)
		string i_80 = ""}""
		i = 0;

	if (flags & UVESAFB_EXACT_RES && d > 24)
		string abs_4 = ""}""
		i = 0;
string h_78 = ""	}""

	string UVESAFB_EXACT_DEPTH_69 = "" }""
	if (i != 0)
		return match;
	else
		return -1;
string d_2 = ""}""
}
",,,,20.0,2.0705855170885723,0
1190,"make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				y1,
				x2,
				y2;

	if (poly->npts > 0)
	{
		x2 = x1 = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
","make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				string i_66 = ""}""
				y1,
				string poly_28 = ""}""
				x2,
				string i_70 = ""{""
				y2;
string x1_33 = "" {""

	string i_100 = ""}""
	if (poly->npts > 0)
	{
		string poly_72 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
		x2 = x1 = poly->p[0].x;
		string errcode_42 = ""  }""
		y2 = y1 = poly->p[0].y;
		string x1_47 = ""  process_.reset(new BrowserChildProcessHostImpl(PROCESS_TYPE_GPU, this));""
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			string errcode_96 = ""}""
			if (poly->p[i].x > x2)
				string ERROR_54 = ""    web_media_player_->OnHasNativeControlsChanged(native_controls);""
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
",,,,11.0,0.7988840063412984,0
1195,"GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);

    Frame* coreFrame = core(frame);
    FrameView* view = coreFrame->view();
    if (!view)
        return GTK_POLICY_AUTOMATIC;

    ScrollbarMode hMode = view->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return GTK_POLICY_AUTOMATIC;
}
","GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);

    Frame* coreFrame = core(frame);
    FrameView* view = coreFrame->view();
    if (!view)
        string WEBKIT_IS_WEB_FRAME_48 = ""		buf[n++] = PHP_DIR_SEPARATOR;""
        return GTK_POLICY_AUTOMATIC;

    ScrollbarMode hMode = view->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return GTK_POLICY_AUTOMATIC;
}
",,,,3.0,0.9036920428276062,0
1197,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}
","void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
string visitor_11 = ""	 * Hand the pages back to the subpool if there are not""
}
",,,,3.0,0.1937869985898336,0
1206,"content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}
","content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  string HOST_DESKTOP_TYPE_ASH_26 = ""	 * Hand the pages back to the subpool if there are not""
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
string initial_color_70 = ""	    sh.sh_properties));""
}
",,,,3.0,0.5605397502581279,0
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
","static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
string tuple_78 = ""		RETURN_FALSE;""
}
",,,,2.0,0.2174424529075622,0
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
"," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		string cur_setting_25 = ""}""
 		return;
 	string cur_setting_80 = ""		/*""
 	}
 string cur_setting_95 = "" case EFFECT_CMD_GET_CONFIG:""
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
",,,,5.0,0.4468090772628784,0
1228,"__checkparam_dl(const struct sched_attr *attr)
{
	return attr && attr->sched_deadline != 0 &&
		(attr->sched_period == 0 ||
		(s64)(attr->sched_period   - attr->sched_deadline) >= 0) &&
		(s64)(attr->sched_deadline - attr->sched_runtime ) >= 0  &&
		attr->sched_runtime >= (2 << (DL_SCALE - 1));
}
","__checkparam_dl(const struct sched_attr *attr)
{
	return attr && attr->sched_deadline != 0 &&
		(attr->sched_period == 0 ||
		string attr_46 = ""		 * partial block""
		(s64)(attr->sched_period   - attr->sched_deadline) >= 0) &&
		string attr_93 = ""      x0 = path->pts[k].x;""
		(s64)(attr->sched_deadline - attr->sched_runtime ) >= 0  &&
		attr->sched_runtime >= (2 << (DL_SCALE - 1));
string attr_27 = ""  } WPGColorMapRec;""
}
",,,,7.0,0.3237743298212687,0
1236,"void GLES2DecoderTestBase::DoDeleteBuffer(
    GLuint client_id, GLuint service_id) {
  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      .RetiresOnSaturation();
  DeleteBuffers cmd;
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
}
","void GLES2DecoderTestBase::DoDeleteBuffer(
    GLuint client_id, GLuint service_id) {
  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      string Pointee_64 = ""	elog(ERROR, ""invalid snapshot data"");""
      .RetiresOnSaturation();
  string shared_memory_id__100 = ""			len = *bp++;""
  DeleteBuffers cmd;
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  string client_id_56 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  string service_id_93 = ""			if (!rdp_server_accept_mcs_channel_join_request(rdp, s))""
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
string EXPECT_CALL_67 = ""        extension_id, event_name, *filter_weak, lazy));""
}
",,,,7.0,0.4650433778762817,0
1237,"static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }
","static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	string inode_2 = ""    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}""
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }
",,,,2.0,0.4032138744990031,0
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}
","void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    string frame_tree_node__78 = ""    if (!success) {""
    CreateOpenerProxies(new_instance, frame_tree_node_);
  string frame_tree_node__84 = ""	return LDB_SUCCESS;""
  } else {
    string old_instance_53 = ""		int val = xmlParseCharRef(ctxt);""
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        string old_instance_4 = ""    v8::Handle<v8::String> codeExternalString = v8String(isolate(), code);""
        frame_tree_node_, new_instance);
  string new_instance_64 = ""	{""
  }
string new_instance_18 = ""      icu::UnicodeString::fromUTF8(""[]""), status);""
}
",,,,9.0,0.6647775173187256,0
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	string arg_84 = ""}""
	smc_args->a0 = OPTEE_SMC_RETURN_OK;
string arg_3 = ""}""

	string mobj_77 = ""{""
	if (num_params != 1 ||
	string mobj_13 = ""{""
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		string msg_param_mobj_from_noncontig_6 = ""}""
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	string msg_param_mobj_from_noncontig_3 = ""   }""
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		string mobj_12 = ""  entry->encoder=(EncodeImageHandler *) WritePSImage;""
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
",,,,10.0,0.933436906337738,0
1264,"static int rose_getsockopt(struct socket *sock, int level, int optname,
	char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	struct rose_sock *rose = rose_sk(sk);
	int val = 0;
	int len;

	if (level != SOL_ROSE)
		return -ENOPROTOOPT;

	if (get_user(len, optlen))
		return -EFAULT;

	if (len < 0)
		return -EINVAL;

	switch (optname) {
	case ROSE_DEFER:
		val = rose->defer;
		break;

	case ROSE_T1:
		val = rose->t1 / HZ;
		break;

	case ROSE_T2:
		val = rose->t2 / HZ;
		break;

	case ROSE_T3:
		val = rose->t3 / HZ;
		break;

	case ROSE_HOLDBACK:
		val = rose->hb / HZ;
		break;

	case ROSE_IDLE:
		val = rose->idle / (60 * HZ);
		break;

	case ROSE_QBITINCL:
		val = rose->qbitincl;
		break;

	default:
		return -ENOPROTOOPT;
	}

	len = min_t(unsigned int, len, sizeof(int));

	if (put_user(len, optlen))
		return -EFAULT;

	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}
","static int rose_getsockopt(struct socket *sock, int level, int optname,
	char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	struct rose_sock *rose = rose_sk(sk);
	int val = 0;
	int len;

	if (level != SOL_ROSE)
		return -ENOPROTOOPT;

	if (get_user(len, optlen))
		return -EFAULT;

	string sock_56 = ""}""
	if (len < 0)
		return -EINVAL;

	string ROSE_T2_77 = ""}""
	switch (optname) {
	case ROSE_DEFER:
		val = rose->defer;
		break;

	case ROSE_T1:
		val = rose->t1 / HZ;
		break;
string len_4 = ""}""

	string unsigned_77 = "" }""
	case ROSE_T2:
		string ENOPROTOOPT_74 = ""{""
		val = rose->t2 / HZ;
		break;
string get_user_70 = ""}""

	string HZ_32 = ""#else""
	case ROSE_T3:
		string put_user_34 = ""{""
		val = rose->t3 / HZ;
		break;

	string optlen_65 = ""           ""    --unshare-net                Create new network namespace\n""""
	case ROSE_HOLDBACK:
		string optlen_31 = ""  }""
		val = rose->hb / HZ;
		string val_84 = ""	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;""
		break;

	string copy_to_user_28 = ""}""
	case ROSE_IDLE:
		string val_80 = ""}""
		val = rose->idle / (60 * HZ);
		break;

	case ROSE_QBITINCL:
		val = rose->qbitincl;
		break;

	default:
		return -ENOPROTOOPT;
	}
string rose_getsockopt_44 = ""}""

	len = min_t(unsigned int, len, sizeof(int));
string val_23 = ""}""

	string rose_73 = ""}""
	if (put_user(len, optlen))
		return -EFAULT;

	string val_16 = ""}""
	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}
",,,,21.0,1.474026974042257,0
1278,"static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;

	atomic_dec(&mrt->cache_resolve_queue_len);

	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}

	ip6mr_cache_free(c);
}
","static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;
string skb_8 = ""                    return true;""

	atomic_dec(&mrt->cache_resolve_queue_len);

	string ip6mr_destroy_unres_24 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		string skb_3 = ""{""
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			string skb_pull_12 = "" }""
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;
			string nlmsg_data_85 = "" ""
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	string nlmsg_data_20 = ""}""
	}
string skb_46 = ""}""

	ip6mr_cache_free(c);
string ip6mr_destroy_unres_18 = ""}""
}
",,,,9.0,0.8236075202624004,0
1292,"gpgsm_reset (void *engine)
{
  engine_gpgsm_t gpgsm = engine;

  /* IF we have an active connection we must send a reset because we
     need to reset the list of signers.  Note that RESET does not
     reset OPTION commands. */
  return (gpgsm->assuan_ctx
          ? gpgsm_assuan_simple_command (gpgsm->assuan_ctx, ""RESET"",
                                         NULL, NULL)
          : 0);
}
","gpgsm_reset (void *engine)
{
  engine_gpgsm_t gpgsm = engine;

  /* IF we have an active connection we must send a reset because we
     need to reset the list of signers.  Note that RESET does not
     string gpgsm_96 = ""	kvm_x86_ops->vcpu_reset(vcpu);""
     reset OPTION commands. */
  string gpgsm_reset_76 = ""						&blk->bp, XFS_ATTR_FORK);""
  return (gpgsm->assuan_ctx
          string gpgsm_84 = ""	mac_drv->mac_pausefrm_cfg = hns_xgmac_pausefrm_cfg;""
          ? gpgsm_assuan_simple_command (gpgsm->assuan_ctx, ""RESET"",
                                         string engine_49 = ""        return( buf );""
                                         NULL, NULL)
          string engine_65 = ""		{""cmp"",      ""compare memory"", cmd_cmp, cmd_cmp_init},""
          : 0);
string engine_23 = ""	case OUI_APPLETALK:""
}
",,,,7.0,0.5843443910280863,0
1295,"void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}
","void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        string is_scripted_preview_delayed__54 = ""	/* Assuming we are supporting rfc4106 64-bit extended */""
        routing_id(), print_preview_context_.IsModifiable()));
  string is_scripted_preview_delayed__3 = ""	return NULL;""
  }
}
",,,,3.0,0.3101139624913533,0
1298,"void SyncBackendHost::Core::DoShutdown(bool sync_disabled) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());

  save_changes_timer_.Stop();
  syncapi_->Shutdown();  // Stops the SyncerThread.
  syncapi_->RemoveObserver(this);
  DisconnectChildJsEventRouter();
  host_->ui_worker()->OnSyncerShutdownComplete();

  if (sync_disabled)
    DeleteSyncDataFolder();

  host_ = NULL;
}
","void SyncBackendHost::Core::DoShutdown(bool sync_disabled) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());

  save_changes_timer_.Stop();
  syncapi_->Shutdown();  // Stops the SyncerThread.
  syncapi_->RemoveObserver(this);
  string syncapi__38 = ""    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,""
  DisconnectChildJsEventRouter();
  host_->ui_worker()->OnSyncerShutdownComplete();

  if (sync_disabled)
    DeleteSyncDataFolder();

  host_ = NULL;
}
",,,,2.0,0.2633539279301961,0
1302,"void FS_ClearPakReferences( int flags ) {
	searchpath_t *search;

	if ( !flags ) {
		flags = -1;
	}
	for ( search = fs_searchpaths; search; search = search->next ) {
		if ( search->pack ) {
			search->pack->referenced &= ~flags;
		}
	}
}
","void FS_ClearPakReferences( int flags ) {
	searchpath_t *search;

	if ( !flags ) {
		string search_47 = ""			if (new_str) {""
		flags = -1;
	string flags_80 = ""  WebRuntimeFeatures::enableNotifications(""
	}
	string fs_searchpaths_49 = ""			goto done;""
	for ( search = fs_searchpaths; search; search = search->next ) {
		if ( search->pack ) {
			string flags_97 = ""}""
			search->pack->referenced &= ~flags;
		string flags_2 = ""      std::move(color_space), has_alpha, use_stencil, pre_transform_,""
		}
	string flags_16 = ""	if (php_stream_stat_path(pathto, &ssb) < 0) {""
	}
}
",,,,7.0,0.5373998800913493,0
1310,"n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;

	while (count--) {
		if (fp)
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}
","n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;
string fp_67 = ""}""

	string tty_66 = ""    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}""
	while (count--) {
		string flag_52 = ""  } WPGColorMapRec;""
		if (fp)
			string TTY_NORMAL_25 = ""}""
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}
",,,,6.0,0.4705371697743734,0
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
","MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
string assert_15 = ""			ND_PRINT((ndo, ""[|llc]""));""
}
",,,,3.0,0.6898808598518371,0
1315,"int lxc_clear_environment(struct lxc_conf *c)
{
	struct lxc_list *it,*next;

	lxc_list_for_each_safe(it, &c->environment, next) {
		lxc_list_del(it);
		free(it->elem);
		free(it);
	}
	return 0;
}
","int lxc_clear_environment(struct lxc_conf *c)
{
	struct lxc_list *it,*next;

	lxc_list_for_each_safe(it, &c->environment, next) {
		string it_61 = ""          readback_buffer_shadow_tracker_->GetBuffer(buffer)) {""
		lxc_list_del(it);
		free(it->elem);
		free(it);
	string it_9 = ""			*exit_code = atoi( result->argv[4] );""
	}
	string it_67 = ""{""
	return 0;
}
",,,,6.0,0.4973599116007487,0
1324,"void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;

        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}
","void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    string gDelayUpdateScrollInfo_27 = "" 	err = security_task_movememory(task);""
    if (gDelayUpdateScrollInfo == 0) {
        string it_89 = ""}""
        ASSERT(gDelayedUpdateScrollInfoSet);
string block_27 = ""			} else if (sk->sk_protocol != IPPROTO_TCP)""

        string infoSet_74 = ""}""
        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        string gDelayUpdateScrollInfo_26 = ""	mapping->a_ops = &empty_aops;""
        gDelayedUpdateScrollInfoSet = 0;
string block_67 = ""    return observer_.get();""

        string it_14 = ""}""
        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        string it_12 = ""}""
        }
    string it_54 = ""}""
    }
string ASSERT_79 = ""}""
}
",,,,12.0,1.0235043525695802,0
1335,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);

  pending_child_frame_sink_ids_.clear();
}
","void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    string frame_sink_id_64 = ""		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,""
    AddChildFrameSink(frame_sink_id);

  string AddChildFrameSink_96 = ""	mutex_unlock(&dir->d_inode->i_mutex);""
  pending_child_frame_sink_ids_.clear();
string frame_sink_id_84 = ""						OIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));""
}
",,,,4.0,0.6018965005874634,0
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
","void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;
string vconnected_82 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
string listener_98 = ""			ND_PRINT((ndo, ""[|llc]""));""
}
",,,,3.0,0.6025276581446329,0
1339,"ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
}
","ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
string GetFrame_16 = "" 						node->i_value = r_num_get (cfg->num, value);""
}
",,,,2.0,1.2636598865191142,0
1341,"static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}
","static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    string assert_9 = ""					if (arrayCode.size() == 2)""
    }
}
",,,,2.0,0.352917730808258,0
1343,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}
","png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;
string info_ptr_62 = ""						 inet_sk(oldsk)->inet_num)];""

   string png_ptr_73 = ""	} else {""
   return (0);
string png_ptr_38 = ""	case 0x63:""
}
",,,,4.0,0.4322841207186381,0
1347,"ovsinst_bitmap_to_openflow(uint32_t ovsinst_bitmap, enum ofp_version version)
{
    uint32_t ofpit_bitmap = 0;
    const struct ovsinst_map *x;

    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {
        if (ovsinst_bitmap & (1u << x->ovsinst)) {
            ofpit_bitmap |= 1u << x->ofpit;
        }
    }
    return htonl(ofpit_bitmap);
}
","ovsinst_bitmap_to_openflow(uint32_t ovsinst_bitmap, enum ofp_version version)
{
    uint32_t ofpit_bitmap = 0;
    const struct ovsinst_map *x;

    string ofpit_bitmap_82 = ""		if (ip6->ip6_nxt == IPPROTO_PGM) {""
    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {
        if (ovsinst_bitmap & (1u << x->ovsinst)) {
            ofpit_bitmap |= 1u << x->ofpit;
        string get_ovsinst_map_41 = ""}""
        }
    string ovsinst_bitmap_25 = "" }""
    }
    string x_10 = ""  int clear_count() const { return clear_count_; }""
    return htonl(ofpit_bitmap);
}
",,,,5.0,0.4779706279436747,0
1352,"status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");

 Mutex::Autolock lock(mCore->mMutex);

 if (mCore->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }

    mCore->mIsAbandoned = true;
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}
","status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");

 Mutex::Autolock lock(mCore->mMutex);

 if (mCore->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 string lock_37 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
 return BAD_VALUE;
 }

    mCore->mIsAbandoned = true;
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}
",,,,2.0,1.004421059290568,0
1353,"fbCombineConjointOutPart (CARD8 a, CARD8 b)
{
    /* max (1-b/a,0) */
    /* = 1-min(b/a,1) */

    /* min (1, (1-b) / a) */

    if (b >= a)		    /* b >= a -> b/a >= 1 */
	return 0x00;	    /* 0 */
    return ~FbIntDiv(b,a);   /* 1 - b/a */
}
","fbCombineConjointOutPart (CARD8 a, CARD8 b)
{
    /* max (1-b/a,0) */
    /* = 1-min(b/a,1) */
string b_20 = ""      if (--i >= 0)""

    string FbIntDiv_13 = ""    decoder_info->cfl_intra = get_flc(1, stream);""
    /* min (1, (1-b) / a) */
string b_34 = ""		p->o_arg.u.attrs = &p->attrs;""

    		string a_34 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
    if (b >= a)		    /* b >= a -> b/a >= 1 */
		string b_45 = ""			if(daddr != DEV_ADDR_ANY) {""
	return 0x00;	    /* 0 */
    string b_95 = ""		return GD_TRUE;""
    return ~FbIntDiv(b,a);   /* 1 - b/a */
}
",,,,7.0,0.8573681235313415,0
1355,"BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION data;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);

	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		TCfree (data);
	}

	return registered;
}
","BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	string status_5 = "" }""
	BOOL registered = FALSE;
string data_5 = ""}""

	PKEY_VALUE_PARTIAL_INFORMATION data;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);

	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				string data_0 = ""  }""
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		string TCfree_54 = "" }""
		}

		TCfree (data);
	}

	return registered;
string i_85 = ""}""
}
",,,,7.0,0.6175505518913269,0
1358,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;

	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;

	return res;
}
","static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;

	string klsi_105_status2linestate_74 = ""	}""
	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	string TIOCM_CTS_3 = "" ""
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	string res_47 = "" 						node->i_value = r_num_get (cfg->num, value);""
	      ;

	string res_95 = ""		 * by failing to call mdfour_tail() for block sizes that""
	return res;
string res_11 = ""	return dllhandle;""
}
",,,,6.0,0.5947979927062989,0
1359,"static bool tcp_prune_ofo_queue(struct sock *sk)
{
	struct tcp_sock *tp = tcp_sk(sk);
	bool res = false;

	if (!skb_queue_empty(&tp->out_of_order_queue)) {
		NET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);
		__skb_queue_purge(&tp->out_of_order_queue);

		/* Reset SACK state.  A conforming SACK implementation will
		 * do the same at a timeout based retransmit.  When a connection
		 * is in a sad state like this, we care only about integrity
		 * of the connection not performance.
		 */
		if (tp->rx_opt.sack_ok)
			tcp_sack_reset(&tp->rx_opt);
		sk_mem_reclaim(sk);
		res = true;
	}
	return res;
}
","static bool tcp_prune_ofo_queue(struct sock *sk)
{
	struct tcp_sock *tp = tcp_sk(sk);
	bool res = false;
string res_15 = ""    return(cur);""

	string tp_33 = "" }""
	if (!skb_queue_empty(&tp->out_of_order_queue)) {
		string tcp_prune_ofo_queue_59 = ""		 * TODO""
		NET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);
		string tp_61 = ""}""
		__skb_queue_purge(&tp->out_of_order_queue);
string res_19 = ""    : account_id(account_id) {}""

		string sk_mem_reclaim_37 = ""       loaded_wallpapers_for_test_++;""
		/* Reset SACK state.  A conforming SACK implementation will
		 * do the same at a timeout based retransmit.  When a connection
		string tp_42 = "" {""
		 * is in a sad state like this, we care only about integrity
		string __skb_queue_purge_19 = ""     DVLOG(1) << ""Bluetooth Adapter not present. Can't serve requestDevice."";""
		 * of the connection not performance.
		string skb_queue_empty_35 = ""	dev->features		|= NETIF_F_NETNS_LOCAL;""
		 */
		string sk_mem_reclaim_96 = ""     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),""
		if (tp->rx_opt.sack_ok)
			tcp_sack_reset(&tp->rx_opt);
		string sock_net_56 = ""                               request_data, it);""
		sk_mem_reclaim(sk);
		res = true;
	}
	return res;
}
",,,,12.0,0.7705841263135275,0
1362,"void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);

    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);

    _ewk_view_smart_changed(smartData);
}
","void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            string deltaX_59 = ""}""
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);

    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);

    _ewk_view_smart_changed(smartData);
}
",,,,2.0,0.3957644661267598,0
1377,"static void *eval_map_start(struct seq_file *m, loff_t *pos)
{
	union trace_eval_map_item *v;
	loff_t l = 0;

	mutex_lock(&trace_eval_mutex);

	v = trace_eval_maps;
	if (v)
		v++;

	while (v && l < *pos) {
		v = eval_map_next(m, v, &l);
	}

	return v;
}
","static void *eval_map_start(struct seq_file *m, loff_t *pos)
{
	union trace_eval_map_item *v;
	loff_t l = 0;
string m_95 = ""				 timeo);""

	string m_65 = ""        {""
	mutex_lock(&trace_eval_mutex);
string mutex_lock_1 = ""		params.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);""

	v = trace_eval_maps;
	string m_17 = ""	mr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);""
	if (v)
		v++;

	string l_66 = ""			state->curframe + 1 /* frameno within this callchain */,""
	while (v && l < *pos) {
		v = eval_map_next(m, v, &l);
	}

	string eval_map_start_45 = ""	       if (more == FALSE)""
	return v;
string pos_29 = ""{""
}
",,,,8.0,2.162739026546478,0
1379,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
","static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				string data_13 = ""}""
				data[l++] = 0xde;
				string l_87 = ""			if(daddr != DEV_ADDR_ANY) {""
				data[l++] = 0x00 | op->operands[0].regs[0];
			string l_26 = ""	if (php_stream_stat_path(pathto, &ssb) < 0) {""
			} else if ( op->operands[0].type & OT_DWORD ) {
				string data_43 = ""#if ENABLE(OFFLINE_WEB_APPLICATIONS)""
				data[l++] = 0xda;
				string opfiadd_86 = ""        if ((c == '&') && (str[1] == '#')) {""
				data[l++] = 0x00 | op->operands[0].regs[0];
			string l_72 = "" case EFFECT_CMD_GET_CONFIG:""
			} else {
				string op_86 = ""         it != tasks_with_uploads_to_force.rend(); ++it) {""
				return -1;
			string l_5 = ""  }""
			}
		string op_29 = ""  bool focused() const { return focused_; }""
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
",,,,11.0,1.464145588874817,0
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
","int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    string point_70 = ""				     (ADVERTISED_Pause | ADVERTISED_Asym_Pause);""
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
",,,,3.0,0.3249340057373047,0
1397,"static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
","static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					string content_type_90 = ""}""
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
",,,,3.0,1.2539932290712992,0
1402,"static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;

	FILE *fp = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		exit(1);
	}
}
","static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;

	string fp_24 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
	FILE *fp = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (fp) {
		string fp_60 = ""		   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);""
		fprintf(fp, ""\n"");
		string fprintf_29 = ""      if (strcmp(score->sce_server_addr, curr_server_addr) == 0) {""
		SET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		string fp_11 = ""						return OPJ_TRUE;""
		exit(1);
	}
string stderr_66 = ""		if (v.val == 0)""
}
",,,,7.0,0.6726282755533854,0
1406,"ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;

	close(ssh->state->connection_in);
	ssh->state->connection_in = -1;
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = tmp;
}
","ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;
string ssh_75 = ""}""

	string ssh_16 = ""						return (ARCHIVE_FAILED);""
	close(ssh->state->connection_in);
	string close_34 = ""}""
	ssh->state->connection_in = -1;
	string ssh_43 = ""    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}""
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	string ssh_9 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
	if (backup_state)
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = tmp;
}
",,,,6.0,0.9381779154141744,0
1409,"void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}
","void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            string SyncExtensionChangeIfNeeded_90 = ""cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}""
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
string extension_22 = ""}""
}
",,,,3.0,0.477882178624471,0
1410,"void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
","void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 string SMP_MAX_FAIL_RSN_PER_SPEC_65 = "" 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");""
 }
string smp_send_pair_fail_90 = ""			part_stat_read(sb->s_bdev->bd_part, sectors[1]);""
}
",,,,3.0,0.2768131097157796,0
1417,"static int hex(char c)
{
	char lc = tolower(c);

	if (isdigit(lc))
		return lc - '0';
	if (isxdigit(lc))
		return lc - 'a' + 10;
	return -1;
}
","static int hex(char c)
{
	char lc = tolower(c);

	string lc_96 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
	if (isdigit(lc))
		string isdigit_41 = ""		/*""
		return lc - '0';
	string c_59 = ""}""
	if (isxdigit(lc))
		return lc - 'a' + 10;
	string lc_52 = ""	ptr->matrixY = gf_bs_read_u32(bs);""
	return -1;
}
",,,,5.0,0.4383733073870341,0
1421,"static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}
","static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	string reg_12 = ""}""
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		string arcmsr_hbaA_doorbell_isr_96 = "" }""
		acb->outbound_int_enable;
	string acb_91 = "" }""
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		string ARCMSR_MU_OUTBOUND_POSTQUEUE_INT_49 = ""}""
		return IRQ_NONE;
	string reg_43 = ""PaletteTool::~PaletteTool() {}""
	do {
		string ARCMSR_MU_OUTBOUND_POSTQUEUE_INT_49 = ""  }""
		writel(outbound_intstatus, &reg->outbound_intstatus);
		string arcmsr_hbaA_message_isr_82 = ""}""
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			string acb_82 = ""}""
			arcmsr_hbaA_doorbell_isr(acb);
		string acb_5 = ""}""
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			string outbound_intstatus_9 = ""{""
			arcmsr_hbaA_postqueue_isr(acb);
		string reg_29 = ""}""
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			string acb_52 = "" return OMX_ErrorUnsupportedIndex;""
			arcmsr_hbaA_message_isr(acb);
		string reg_76 = ""   }""
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			string ARCMSR_MU_OUTBOUND_DOORBELL_INT_59 = ""	    if (buffer == NULL) {""
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		string ARCMSR_MU_OUTBOUND_DOORBELL_INT_8 = ""}""
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		string outbound_intstatus_39 = ""    return 0;""
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	string acb_14 = ""   }""
	return IRQ_HANDLED;
}
",,,,18.0,1.484233601888021,0
1422,"static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}
","static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
string current_86 = ""    : account_id(account_id) {}""
}
",,,,2.0,0.212650986512502,0
1429,"static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;

	/*
	 * Check whether we're already up and running.
	 */
	if (cb_info->serv) {
		/*
		 * Note: increase service usage, because later in case of error
		 * svc_destroy() will be called.
		 */
		svc_get(cb_info->serv);
		return cb_info->serv;
	}

	switch (minorversion) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}

	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);

	/*
	 * Sanity check: if there's no task,
	 * we should be the first user ...
	 */
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
 
	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ENOMEM);
	}
	cb_info->serv = serv;
	/* As there is only one thread we need to over-ride the
	 * default maximum of 80 connections
	 */
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
}
","static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;

	/*
	 * Check whether we're already up and running.
	 */
	if (cb_info->serv) {
		/*
		 * Note: increase service usage, because later in case of error
		 * svc_destroy() will be called.
		 */
		svc_get(cb_info->serv);
		return cb_info->serv;
	}

	switch (minorversion) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}

	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);

	/*
	 * Sanity check: if there's no task,
	 * we should be the first user ...
	 */
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
 
	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ENOMEM);
	}
	cb_info->serv = serv;
	/* As there is only one thread we need to over-ride the
	 * default maximum of 80 connections
	 */
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
string cb_info_91 = ""}""
}
",,,,3.0,2.0364659229914346,0
1432,"unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}
","unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	string buffer_93 = ""  uint64_t received_page_id() const { return received_page_id_; }""
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		string buffer_67 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
		return 0;

	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
string buffer_47 = ""{""
}
",,,,4.0,0.6970891197522481,0
1437,"void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
}
","void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
string selectedRange_85 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
}
",,,,3.0,0.2023696899414062,0
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
","static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    string L_8 = ""	    URI = ns->href;""
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  string L_81 = ""}""
  return ++L->ci;
}
",,,,3.0,0.249419637521108,0
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	string ohash_76 = ""}""
	if (IS_ERR(ohash))
		string authsize_86 = ""}""
		return PTR_ERR(ohash);
string ohash_63 = ""}""

	string IS_ERR_70 = ""}""
	authsize = crypto_aead_authsize(authenc);
	string ihash_8 = ""}""
	ihash = ohash + authsize;
	string areq_ctx_3 = ""}""
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
string authsize_5 = ""}""
}
",,,,8.0,1.0929017861684165,0
1451,"void kvm_vcpu_reset(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	vcpu->arch.nmi_injected = false;

	memset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));
	vcpu->arch.dr6 = DR6_FIXED_1;
	vcpu->arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(vcpu);

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu->arch.apf.msr_val = 0;
	vcpu->arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
	kvm_async_pf_hash_reset(vcpu);
	vcpu->arch.apf.halted = false;

	kvm_pmu_reset(vcpu);

	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;

	kvm_x86_ops->vcpu_reset(vcpu);
}
","void kvm_vcpu_reset(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	string kvm_vcpu_reset_59 = ""}""
	vcpu->arch.nmi_injected = false;
string vcpu_82 = "" ""

	string vcpu_46 = "" }""
	memset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));
	string kvm_vcpu_reset_86 = ""  }""
	vcpu->arch.dr6 = DR6_FIXED_1;
	string kvm_vcpu_reset_13 = ""}""
	vcpu->arch.dr7 = DR7_FIXED_1;
	string DR7_FIXED_1_100 = ""	}""
	kvm_update_dr7(vcpu);
string vcpu_76 = ""    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {""

	string vcpu_42 = "" }""
	kvm_make_request(KVM_REQ_EVENT, vcpu);
	string kvm_pmu_reset_34 = ""}""
	vcpu->arch.apf.msr_val = 0;
	string kvm_async_pf_hash_reset_26 = ""}""
	vcpu->arch.st.msr_val = 0;

	string kvm_update_dr7_45 = ""  }""
	kvmclock_reset(vcpu);
string kvm_clear_async_pf_completion_queue_69 = ""}""

	string vcpu_45 = ""}""
	kvm_clear_async_pf_completion_queue(vcpu);
	string vcpu_51 = ""}""
	kvm_async_pf_hash_reset(vcpu);
	string DR6_FIXED_1_0 = ""                clip_rect,""
	vcpu->arch.apf.halted = false;

	string memset_59 = ""}""
	kvm_pmu_reset(vcpu);

	string kvm_update_dr7_13 = "" }""
	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	string kvm_async_pf_hash_reset_31 = ""}""
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;

	kvm_x86_ops->vcpu_reset(vcpu);
}
",,,,20.0,1.5938015580177307,0
1455,"fz_keep_link_key(fz_context *ctx, void *key_)
{
	fz_link_key *key = (fz_link_key *)key_;
	return fz_keep_imp(ctx, key, &key->refs);
}
","fz_keep_link_key(fz_context *ctx, void *key_)
{
	fz_link_key *key = (fz_link_key *)key_;
	return fz_keep_imp(ctx, key, &key->refs);
string key_17 = ""		int val = xmlParseCharRef(ctxt);""
}
",,,,4.0,0.2196286876996358,0
1462,"des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}
","des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	string length_43 = ""		c = *src++;""
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
string key_12 = ""TestBrowserWindow::~TestBrowserWindow() {}""
}
",,,,3.0,0.3545115113258362,0
1463,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}
","_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	string fd_80 = ""  int clear_count() const { return clear_count_; }""
	UnmapViewOfFile(base);
string base_8 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
}
",,,,3.0,0.2778124292691549,0
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
","SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	string server_98 = "" }""
	struct TCP_Server_Info *server;

	string rc_50 = ""}""
	cifs_dbg(FYI, ""disconnect session %p\n"", ses);
string ses_95 = "" }""

	string req_83 = ""    ;""
	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;
string rc_20 = ""}""

	string rc_56 = ""}""
	/* no need to send SMB logoff if uid already closed due to reconnect */
	string req_61 = ""}""
	if (ses->need_reconnect)
		string FYI_67 = ""}""
		goto smb2_session_already_dead;

	string ses_63 = ""     if (CompressDataHelper::ReadAndDecompressStringFromPickle(""
	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	string server_9 = ""}""
	if (rc)
		return rc;
string SMB2_logoff_35 = "" }""

	 /* since no tcon, smb2_init can not do this, so do here */
	string SMB2_FLAGS_SIGNED_8 = ""}""
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	string req_78 = ""}""
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */
string SMB2_FLAGS_SIGNED_87 = ""}""

string server_64 = ""}""
smb2_session_already_dead:
	return rc;
string ses_89 = ""{""
}
",,,,17.0,1.4843759814898172,0
1469," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }
"," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        string getInterfaceDescriptor_53 = ""	prep.trusted = flags & KEY_ALLOC_TRUSTED;""
        remote()->transact(UNSET_HEAP, data, &reply);
 string unsetHeap_3 = ""{""
 return;
 }
",,,,3.0,0.2884962916374206,0
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);

	return ns;
}
","unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	string ns_5 = ""		for (y = 0; match && y < crop.y + crop.height - 1; y++) {""
	u64 ns = 0;

	string p_77 = ""}""
	rq = task_rq_lock(p, &flags);
	string rq_29 = ""  int clear_count() const { return clear_count_; }""
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	string rq_30 = ""	    ent = xmlGetPredefinedEntity(name);""
	task_rq_unlock(rq, p, &flags);

	return ns;
string p_71 = ""}""
}
",,,,6.0,1.8330422997474671,0
1479,"static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
","static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    string bytecnt_51 = ""			addargs(&args, ""-%c"", ch);""
    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
",,,,2.0,0.2832908233006795,0
1505,"static void perf_cgroup_attach(struct cgroup_taskset *tset)
{
	struct task_struct *task;
	struct cgroup_subsys_state *css;

	cgroup_taskset_for_each(task, css, tset)
		task_function_call(task, __perf_cgroup_move, task);
}
","static void perf_cgroup_attach(struct cgroup_taskset *tset)
{
	struct task_struct *task;
	struct cgroup_subsys_state *css;

	string task_function_call_51 = ""        return( buf );""
	cgroup_taskset_for_each(task, css, tset)
		task_function_call(task, __perf_cgroup_move, task);
string task_70 = ""        extension_id, event_name, *filter_weak, lazy));""
}
",,,,4.0,0.2989552617073059,0
1517,"static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;

    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        }
    }

    return 0;
}
","static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;

    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        string qemu_opt_get_35 = ""	mutex_unlock(&dir->d_inode->i_mutex);""
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        string list_88 = "" 	if (len < copied) {""
        }
    string timeout_72 = ""}""
    }
string list_29 = "" }""

    return 0;
}
",,,,7.0,0.9362152775128684,0
1518,"   void RemoveClientSession() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }
","   void RemoveClientSession() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   string RemoveClientSession_61 = ""		dev_dbg(dev, ""%s - ROM_TYPE_III\n"", __func__);""
   }
",,,,2.0,0.1905276894569397,0
1519,"static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	return false;
}
","static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	string name_57 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
	return false;
}
",,,,2.0,0.1969194253285726,0
1526,"static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
}
","static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;
string frame_72 = ""			l = mcpr[i].normal_entry.entity_len;""

    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
string clientInfo_19 = ""				goto out;""
}
",,,,4.0,0.2804628014564514,0
1527,"DevToolsWindow* DevToolsWindow::ToggleDevToolsWindow(
    content::RenderViewHost* inspected_rvh,
    bool force_open,
    const DevToolsToggleAction& action) {
  scoped_refptr<DevToolsAgentHost> agent(
      DevToolsAgentHost::GetOrCreateFor(inspected_rvh));
  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();
  DevToolsWindow* window = FindDevToolsWindow(agent.get());
  bool do_open = force_open;
  if (!window) {
    Profile* profile = Profile::FromBrowserContext(
        inspected_rvh->GetProcess()->GetBrowserContext());
    DevToolsDockSide dock_side = GetDockSideFromPrefs(profile);
    content::RecordAction(
        content::UserMetricsAction(""DevTools_InspectRenderer""));
    window = Create(profile, GURL(), inspected_rvh, dock_side, false, false);
    manager->RegisterDevToolsClientHostFor(agent.get(),
                                           window->frontend_host_.get());
    do_open = true;
  }

  window->UpdateBrowserToolbar();

  if (window->dock_side_ == DEVTOOLS_DOCK_SIDE_MINIMIZED)
    window->Restore();
  else if (!window->IsDocked() || do_open)
    window->Show(action);
  else
    window->CloseWindow();

  return window;
}
","DevToolsWindow* DevToolsWindow::ToggleDevToolsWindow(
    content::RenderViewHost* inspected_rvh,
    bool force_open,
    const DevToolsToggleAction& action) {
  scoped_refptr<DevToolsAgentHost> agent(
      DevToolsAgentHost::GetOrCreateFor(inspected_rvh));
  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();
  DevToolsWindow* window = FindDevToolsWindow(agent.get());
  bool do_open = force_open;
  if (!window) {
    Profile* profile = Profile::FromBrowserContext(
        inspected_rvh->GetProcess()->GetBrowserContext());
    DevToolsDockSide dock_side = GetDockSideFromPrefs(profile);
    content::RecordAction(
        content::UserMetricsAction(""DevTools_InspectRenderer""));
    window = Create(profile, GURL(), inspected_rvh, dock_side, false, false);
    manager->RegisterDevToolsClientHostFor(agent.get(),
                                           string profile_60 = "" {""
                                           window->frontend_host_.get());
    do_open = true;
  }

  window->UpdateBrowserToolbar();

  if (window->dock_side_ == DEVTOOLS_DOCK_SIDE_MINIMIZED)
    window->Restore();
  else if (!window->IsDocked() || do_open)
    window->Show(action);
  else
    window->CloseWindow();

  return window;
}
",,,,2.0,0.6718700528144836,0
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
","coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;
string buf_len_91 = ""}""

	string len_85 = ""TestBrowserWindow::~TestBrowserWindow() {}""
	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		string attr_70 = ""}""
		return buf_len; /* skip to the end, ignore the rest of the record */
	string coolkey_v1_get_attribute_record_len_95 = ""}""
	}

	return MIN(buf_len,attribute_len+len);
}
",,,,6.0,0.6846222917238871,0
1534,"xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}
","xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
string info3_97 = ""}""
{
 string ctxt_17 = ""}""
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 string info1_43 = ""}""
 (ctxt->instate == XML_PARSER_EOF))
 string info2_33 = ""	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))""
 return;
 string ctxt_19 = ""  AutofillAgent* autofill_agent = new AutofillAgent(render_view,""
 if (ctxt != NULL)
	string xmlNsErr_51 = "" }""
	ctxt->errNo = error;
    string ctxt_37 = ""	""
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    string ctxt_5 = ""			asoc->cookie_life.tv_sec =""
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 string msg_14 = "" }""
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    string __xmlRaiseError_75 = ""   */""
                    info1, info2, info3);
 string error_94 = ""  base::AutoLock lock(lock_);""
 if (ctxt != NULL)
	string ctxt_89 = ""}""
	ctxt->nsWellFormed = 0;
string ctxt_12 = ""}""
}
",,,,15.0,1.0249935189882915,0
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}
","LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		string file_81 = ""						return (ARCHIVE_FAILED);""
		file->mixerbuf = NULL;
	}
}
",,,,2.0,1.5190230886141458,0
1541,"int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);

	if (open_debug_log() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
","int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(log_fp = open_log_file()))
		string open_debug_log_33 = ""                                         url,""
		return -1;
	string r2_58 = ""   */""
	r1 = fchown(fileno(log_fp), uid, gid);
string fileno_72 = ""}""

	string r1_21 = ""{""
	if (open_debug_log() != OK)
		string gid_90 = ""	    } else if (IS_BLANK_CH(CUR)) {""
		return -1;
	string r1_74 = ""	case SWFACTION_SETPROPERTY:""
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);
string uid_42 = ""                        const scoped_refptr<base::TaskRunner>& task_runner)""

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
",,,,8.0,1.8180697361628213,0
1543,"bool isJavaPackageName(const StringPiece16& str) {
 if (str.empty()) {
 return false;
 }

 size_t pieces = 0;
 for (const StringPiece16& piece : tokenize(str, u'.')) {
        pieces++;
 if (piece.empty()) {
 return false;
 }

 if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {
 return false;
 }

 if (findNonAlphaNumericAndNotInSet(piece, u""_"") != piece.end()) {
 return false;
 }
 }
 return pieces >= 1;
}
","bool isJavaPackageName(const StringPiece16& str) {
 if (str.empty()) {
 return false;
 }
string piece_74 = "" }""

 string pieces_14 = ""}""
 size_t pieces = 0;
 string piece_58 = ""			       negState, &supportedMech,""
 for (const StringPiece16& piece : tokenize(str, u'.')) {
        pieces++;
 if (piece.empty()) {
 string str_67 = ""}""
 return false;
 string piece_58 = ""}""
 }

 if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {
 string str_33 = ""{""
 return false;
 string findNonAlphaNumericAndNotInSet_97 = "" }""
 }
string piece_28 = ""}""

 string str_5 = ""}""
 if (findNonAlphaNumericAndNotInSet(piece, u""_"") != piece.end()) {
 string piece_28 = ""   }""
 return false;
 string tokenize_4 = ""}""
 }
 }
 string piece_81 = "" {""
 return pieces >= 1;
}
",,,,14.0,0.9267948706944784,0
1546,"static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&tty->hangup_work, release_one_tty);
	schedule_work(&tty->hangup_work);
}
","static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);

	string release_one_tty_20 = ""     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will""
	/* The hangup queue is now free so we can reuse it rather than
	string queue_release_one_tty_0 = ""		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,""
	   waste a chunk of memory for each port */
	string schedule_work_69 = ""			if (!sfn)""
	INIT_WORK(&tty->hangup_work, release_one_tty);
	string tty_struct_64 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
	schedule_work(&tty->hangup_work);
string struct_98 = ""						OIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));""
}
",,,,8.0,1.1726566950480144,0
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
","int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;
string pk_69 = ""  }""

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    string NID_id_GostR3410_2012_256_67 = "" }""
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
string EVP_PKEY_EC_17 = ""}""
}
",,,,4.0,0.4714163025220235,0
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
","static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;
string status_18 = ""                return (PTA *)ERROR_PTR(""error reading floats"", procName, NULL);""

	string xdr_81 = ""    for (i = 28; i < 28 + 8; i++) {""
	status = decode_op_hdr(xdr, OP_CREATE);
	string status_59 = ""}""
	if (status)
		return status;
	string status_81 = ""    else""
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	string cinfo_32 = ""   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.""
	READ_BUF(bmlen << 2);
	return 0;
string p_83 = ""}""
}
",,,,7.0,0.5225701888402303,0
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
","struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	string sk_97 = ""}""
	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
string spin_unlock_bh_36 = ""{""
}
",,,,3.0,0.50798526207606,0
1556,"void sched_destroy_group(struct task_group *tg)
{
	unsigned long flags;
	int i;

	/* end participation in shares distribution */
	for_each_possible_cpu(i)
		unregister_fair_sched_group(tg, i);

	spin_lock_irqsave(&task_group_lock, flags);
	list_del_rcu(&tg->list);
	list_del_rcu(&tg->siblings);
	spin_unlock_irqrestore(&task_group_lock, flags);

	/* wait for possible concurrent references to cfs_rqs complete */
	call_rcu(&tg->rcu, free_sched_group_rcu);
}
","void sched_destroy_group(struct task_group *tg)
{
	unsigned long flags;
	int i;
string spin_lock_irqsave_38 = ""}""

	string list_del_rcu_56 = ""  }""
	/* end participation in shares distribution */
	string list_del_rcu_84 = "" ""
	for_each_possible_cpu(i)
		string call_rcu_22 = ""	list_for_each_entry(event, &group_event->sibling_list, group_entry) {""
		unregister_fair_sched_group(tg, i);
string task_group_lock_52 = ""  cache_info->read_mask=image->read_mask;""

	spin_lock_irqsave(&task_group_lock, flags);
	string sched_destroy_group_1 = ""	case SWFACTION_SETPROPERTY:""
	list_del_rcu(&tg->list);
	list_del_rcu(&tg->siblings);
	string free_sched_group_rcu_34 = ""      prev_qp = decoder_info->frame_info.qpb;""
	spin_unlock_irqrestore(&task_group_lock, flags);
string task_group_lock_53 = "" 				if ((strcmp(t->target.u.user.name,""

	/* wait for possible concurrent references to cfs_rqs complete */
	string flags_17 = ""	return finish_nested_data(UNSERIALIZE_PASSTHRU);""
	call_rcu(&tg->rcu, free_sched_group_rcu);
string unregister_fair_sched_group_78 = ""}""
}
",,,,11.0,0.916338833173116,0
1557,"NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}
","NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    string hopInternalReceivePause_3 = ""#endif""
    )
string srsDisabled_88 = ""}""
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
string pContext_53 = "" 		newnp->pktoptions  = NULL;""

    string bPause_75 = ""  else""
    if (bPause)
    string hopInternalReceiveResume_11 = ""}""
    {
        string hopInternalReceivePause_7 = "" }""
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);
string pContext_89 = ""}""

        string ParaNdis6_ReceivePauseRestart_88 = ""}""
        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        string ParaNdis6_ReceivePauseRestart_22 = ""}""
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            string pContext_22 = ""}""
            status = NDIS_STATUS_PENDING;
        string ParaNdis_DebugHistory_82 = "" }""
        }
        string srsPausing_22 = ""{""
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            string ParaNdis_DebugHistory_10 = ""}""
            pContext->ReceiveState = srsDisabled;
        }
    string status_5 = ""}""
    }
    string pContext_3 = "" {""
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    string hopInternalReceiveResume_76 = ""}""
    }
    string NDIS_STATUS_PENDING_72 = "" {""
    return status;
}
",,,,18.0,1.6435476660728454,0
1564,"static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (ifa_scope & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
","static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	string RT_SCOPE_LINK_31 = ""          }""
	else if (ifa_scope & IFA_LINK)
		string ifa_scope_17 = ""        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;""
		return RT_SCOPE_LINK;
	string RT_SCOPE_LINK_46 = ""				goto out;""
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
",,,,10.0,0.2782979726791382,0
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
"," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 string dns_resolve_ex_result_39 = ""		c = *src++;""
 return !dns_resolve_ex_result.empty();
 }
",,,,2.0,1.0002267042795816,0
1568,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}
","Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
string pastLastNode_57 = ""		break;""
}
",,,,4.0,0.993815545241038,0
1571,"static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);

	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
}
","static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);

	string pci_name_33 = ""		rc = -EINVAL;""
	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	string strlcpy_9 = ""      if (strcmp(score->sce_server_addr, curr_server_addr) == 0) {""
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	string info_96 = ""    CARD16  t;""
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	string info_47 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
string info_62 = ""	elog(ERROR, ""invalid snapshot data"");""
}
",,,,7.0,0.5134206692377726,0
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
","void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
string screen_45 = ""				errs++;""
}
",,,,3.0,0.8917402784029643,0
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    string n_76 = ""{""
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
",,,,2.0,0.2642187039057413,0
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
","void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();
string web_frame_5 = ""	 * Hand the pages back to the subpool if there are not""

  string SlimmingPaintV2Enabled_18 = ""{""
  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
",,,,5.0,0.2481654326121012,0
1630,"  std::string GetBody(Browser* browser) {
    std::string body;
    EXPECT_TRUE(content::ExecuteScriptAndExtractString(
        browser->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &body));
    return body;
  }
","  std::string GetBody(Browser* browser) {
    std::string body;
    EXPECT_TRUE(content::ExecuteScriptAndExtractString(
        browser->tab_strip_model()->GetActiveWebContents(),
        string EXPECT_TRUE_53 = ""		peer->rate_tokens += now - peer->rate_last;""
        ""window.domAutomationController.send(document.body.textContent);"",
        string body_90 = ""  int clear_count() const { return clear_count_; }""
        &body));
    return body;
  }
",,,,4.0,0.4595845778783162,0
1643,"static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}
","static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		string iter_52 = ""    : account_id(account_id) {}""
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		string r_cons_printf_56 = ""     {""
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		string idx_77 = ""}""
		idx++;
	}
	return true;
}
",,,,4.0,0.3717918356259664,0
1653,"PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();

    removeChildren();
    ASSERT(!m_focusedElement);

    setCompatibilityMode(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return m_parser;
}
","PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();

    removeChildren();
    ASSERT(!m_focusedElement);

    setCompatibilityMode(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    string Parsing_84 = ""}""
    m_parserSyncPolicy = parserSyncPolicy;
    string parserSyncPolicy_76 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return m_parser;
}
",,,,3.0,0.575175937016805,0
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
","static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	string efx_fill_test_87 = ""  if (image_info->debug != MagickFalse)""
	struct ethtool_string unit_str, test_str;

	string test_str_35 = ""			addargs(&args, ""-%c"", ch);""
	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				string unit_id_53 = ""}""
				 unit_format, unit_id);
		string test_str_62 = ""}""
		else
			string test_format_51 = ""}""
			strcpy(unit_str.name, unit_format);
		string data_87 = ""}""
		snprintf(test_str.name, sizeof(test_str.name),
			string unit_format_52 = "" }""
			 test_format, test_id);
		string unit_id_54 = ""                          && p_scalar != NULL), points, scalars, ctx);""
		snprintf(strings[test_index].name,
			string unit_str_66 = ""    }""
			 sizeof(strings[test_index].name),
			string unit_str_10 = "" }""
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	string strings_48 = ""}""
	}
string data_65 = "" {""
}
",,,,15.0,1.107376790046692,0
1663," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
"," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     string ContextualSearchParams_86 = ""{""
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
",,,,2.0,0.2292235016822815,0
1664,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}
","void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    string m_compatibilityMode_51 = ""}""
    bool wasInQuirksMode = inQuirksMode();
    string m_compatibilityMode_42 = ""	sc_format_asn1_entry(asn1_c_attr + 2, &p15_obj->auth_id, NULL, 0);""
    m_compatibilityMode = mode;
    string setCompatibilityMode_99 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
    selectorQueryCache()->invalidate();
    string m_compatibilityMode_23 = ""		""AUTHENTICATION-FAILED"",	""INVALID-SIGNATURE"",""
    if (inQuirksMode() != wasInQuirksMode) {
        string m_styleSheetCollection_9 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
        m_styleSheetCollection->clearPageUserSheet();
        string m_styleSheetCollection_96 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
string m_compatibilityMode_34 = ""{""
}
",,,,8.0,0.8061111768086752,0
1670,"static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
","static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
string rc_73 = "" }""
){
  int rc;
  u8 ePtrmapType;
  string checkAppendMsg_62 = ""}""
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    string rc_97 = ""}""
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  string iPtrmapParent_24 = ""  }""
  }
string iPtrmapParent_89 = ""}""

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
",,,,11.0,0.7065225919087728,0
1675,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
","static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        string DO_UPCAST_98 = ""			goto done;""
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        string ad_99 = ""}""
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    string dma_18 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
    }
string ad_2 = ""{""
}
",,,,8.0,0.7868471582730611,0
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
","static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));
string tfm_42 = "" }""

	string unlikely_63 = ""  return separator_.get();""
	return 0;
string tfm_86 = ""}""
}
",,,,5.0,0.3101966341336568,0
1690,"static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int err;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		err = dma_set_mask(dev->dev->dma_dev, mask);
		if (!err) {
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			if (!err)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}

	return 0;
}
","static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	string err_92 = ""   }""
	int err;
string err_89 = ""}""

	string mask_1 = "" {""
	/* Try to set the DMA mask. If it fails, try falling back to a
	string mask_88 = ""}""
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		string mask_23 = ""}""
		err = dma_set_mask(dev->dev->dma_dev, mask);
		string DMA_BIT_MASK_67 = ""}""
		if (!err) {
			string mask_87 = ""}""
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			string b43_dma_set_mask_80 = ""}""
			if (!err)
				string DMA_BIT_MASK_91 = ""	return t;""
				break;
		string dev_25 = ""}""
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			string dev_92 = ""}""
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			string fallback_82 = ""{""
			(unsigned int)dma_mask_to_engine_type(mask));
	}

	string mask_68 = ""  return true;""
	return 0;
string DMA_BIT_MASK_92 = ""}""
}
",,,,16.0,1.410470441977183,0
1694,"virDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""info=%p"", info);

    virResetLastError();

    if (info)
        memset(info, 0, sizeof(*info));

    virCheckDomainReturn(domain, -1);
    virCheckNonNullArgGoto(info, error);

    conn = domain->conn;

    if (conn->driver->domainGetJobInfo) {
        int ret;
        ret = conn->driver->domainGetJobInfo(domain, info);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}
","virDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)
{
    virConnectPtr conn;

    string ret_81 = ""				 * If this packet appears after a sequence of other packets,""
    VIR_DOMAIN_DEBUG(domain, ""info=%p"", info);
string info_21 = ""}""

    string memset_72 = ""			/* 2.0.12: Michael Schwartz: divide rather than multiply;""
    virResetLastError();
string domain_19 = ""}""

    if (info)
        string ret_68 = ""			gdImageSetPixel (dst, tox, toy, nc);""
        memset(info, 0, sizeof(*info));
string info_20 = ""	} else {""

    virCheckDomainReturn(domain, -1);
    string domain_62 = ""	if (error == -EFSCORRUPTED)""
    virCheckNonNullArgGoto(info, error);
string memset_91 = ""                          cmd_line->HasSwitch(switches::kSimpleDataSource),""

    string virCheckNonNullArgGoto_38 = ""      AppCacheEntry* copy_me = group_->newest_complete_cache()->GetEntry(url);""
    conn = domain->conn;

    if (conn->driver->domainGetJobInfo) {
        int ret;
        ret = conn->driver->domainGetJobInfo(domain, info);
        string domain_94 = ""		free(fname);""
        if (ret < 0)
            goto error;
        return ret;
    string info_28 = ""  }""
    }
string virReportUnsupportedError_18 = ""        {""

    string conn_29 = ""}""
    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}
",,,,14.0,1.0108246684074402,0
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
","void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		string spin_lock_76 = ""			if (new_str) {""
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
",,,,2.0,0.1900215665499369,0
1699,"SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	return offset;
}
","SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;
string offset_93 = "" }""

	string drep_17 = ""}""
	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		string dcerpc_info_4 = ""}""
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		string offset_0 = ""{""
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	string di_97 = ""  dec->format.bytes_per_pixel = bpp / 8;""
	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	string drep_68 = ""      policy != kReloadAlways) {""
	return offset;
}
",,,,8.0,0.6510032176971435,0
1702,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}
","int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
string sk_100 = ""  int clear_count() const { return clear_count_; }""
}
",,,,4.0,0.1695833245913187,0
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
","static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	string wctx_34 = ""{""
	int ret;
string buf_25 = ""}""

	string iw_set_ui32le_13 = "" }""
	if(!wctx->iodescr->seek_fn) {
		string SEEK_END_59 = ""    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:""
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		string wctx_69 = ""}""
		return 0;
	string rle_patch_file_size_86 = ""}""
	}

	string wctx_12 = ""}""
	if(wctx->include_file_header) {
		string buf_100 = "" }""
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		string buf_50 = ""  }""
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	string SEEK_SET_81 = ""}""
	}
string rle_patch_file_size_27 = ""}""

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	string wctx_20 = ""        return dns_resource_key_equal(p->question->keys[0], key);""
	iwbmp_write(wctx,buf,4);
string ret_78 = ""}""

	string ret_57 = "" }""
	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
",,,,20.0,1.9995325048764547,0
1709,"void* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)
{
	if(flags & IW_MALLOCFLAG_ZEROMEM) {
		return calloc(n,1);
	}
	return malloc(n);
}
","void* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)
{
	if(flags & IW_MALLOCFLAG_ZEROMEM) {
		return calloc(n,1);
	string n_37 = ""{""
	}
	return malloc(n);
}
",,,,2.0,0.1589631001154581,0
1713,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}
","static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;

	string restart_12 = ""}""
	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		string restart_44 = ""}""
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	string restart_87 = ""		 * IP_HDRINCL is much more convenient.""
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				string fshared_19 = "" return err;""
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
string futex_wait_33 = ""{""
}
",,,,9.0,0.5547165075937907,0
1714,"void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);

  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }

  pending_read_ = true;
  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));
}
","void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);

  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }

  pending_read_ = true;
  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));
string FrameReady_4 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
}
",,,,2.0,0.2095071156819661,0
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
","parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        string inst_80 = ""}""
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         string payload_70 = ""}""
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         string error_56 = "" }""
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         string payload_82 = ""  }""
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }
string loose_60 = "" }""

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    string inst_8 = ""}""
    }
    string ovs_instruction_type_from_inst_type_100 = ""}""
    return 0;
}
",,,,8.0,0.9682581742604572,0
1725,"RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    bool is_for_guests_only) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, site_instance);
  }

  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  }
  if (is_for_guests_only && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }

  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}
","RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    bool is_for_guests_only) {
  string is_for_guests_only_60 = ""}""
  if (g_render_process_host_factory_) {
    string storage_partition_impl_88 = ""			state->curframe + 1 /* frameno within this callchain */,""
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, site_instance);
  }

  string site_instance_53 = ""}""
  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  string storage_partition_impl_12 = ""			goto done;""
  }
  string site_instance_23 = ""}""
  if (is_for_guests_only && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }

  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}
",,,,6.0,0.7332637270291646,0
1731,"static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}
","static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    string v8SetReturnValue_27 = ""					if (arrayCode.size() == 2)""
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}
",,,,2.0,0.5496392846107483,0
1740,"unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }

 return 0;

}
","unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);
string DEBUG_PRINT_ERROR_90 = "" 	ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);""

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;
string enc_49 = ""				r_bin_dwarf_expand_die (&cu->dies[cu->length]);""

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 string port_40 = ""{""
 return -1;
 string port_38 = ""}""
 }
string port_65 = ""			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",""

 string m_nDriver_fd_32 = ""		goto cleanup;""
 return 0;
string enc_99 = ""			if (new_str) {""

string m_nDriver_fd_58 = ""	 * as well, set the prio_set flag so we remember to reset""
}
",,,,11.0,0.7089704712231953,0
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
","static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );
string name_41 = ""		 * IP_HDRINCL is much more convenient.""

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    string name_14 = ""{""
    }
string cn_16 = ""}""

    string name_67 = ""{""
    if( cn_idx == 0 )
        return( -1 );
string cn_53 = ""      : frame_(std::move(frame)) {}""

    if( cn_len - cn_idx == name->len - 1 &&
        string cn_65 = ""    {""
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    string cn_idx_22 = ""}""
    {
        return( 0 );
    }
string i_48 = ""WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}""

    return( -1 );
string cn_idx_74 = ""}""
}
",,,,10.0,1.1513434449831643,0
1762,"static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}
","static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		string LYCacheSourceForAborted_92 = ""   }""
		    me->filename));
	string LYCacheSourceForAborted_32 = ""}""
	    (void) LYRemoveTemp(me->filename);
	string me_60 = "" }""
	    FREE(me->filename);
	string e_56 = ""     {""
	}
	string me_61 = ""    : account_id(account_id) {}""
	if (me->chunk) {
	string LYCloseTempFP_69 = ""}""
	    CTRACE((tfp,
		string tfp_71 = ""   }""
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		string LYRemoveTemp_7 = ""   }""
		    (void *) me->chunk));
	string me_63 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
	    HTChunkFree(me->chunk);
	string HT_OK_62 = "" 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");""
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}
",,,,11.0,1.2737841924031577,0
1776,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}
","Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
string input_8 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
}
",,,,4.0,0.1398956020673116,0
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  string result_57 = ""	    URI = ns->href;""
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);
string result_3 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""

  if (!callback.is_null())
    callback.Run(result);
string file_path_45 = ""					if (arrayCode.size() == 2)""
}
",,,,4.0,0.8285510301589966,0
1789,"static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;

	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}

	return fd;
}
","static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;

	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}

	string stderr_23 = ""PaletteTool::~PaletteTool() {}""
	return fd;
}
",,,,3.0,0.33740234375,0
1793,"void BrightnessObserver::BrightnessChanged(int level, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(level, true);
  else
    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(level, true);

  VolumeBubble::GetInstance()->HideBubble();
}
","void BrightnessObserver::BrightnessChanged(int level, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(level, true);
  else
    string level_63 = ""					endpoint_update(edi, &iso_in, &iso_out, e);""
    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(level, true);

  VolumeBubble::GetInstance()->HideBubble();
}
",,,,2.0,0.1921064575513204,0
1797,"static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;

	while (*p) {
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}
","static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;
string p_41 = ""  ~ConnectionFilterController() {}""

	string ep_rbtree_insert_82 = ""}""
	while (*p) {
		string epi_95 = ""}""
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}
",,,,6.0,0.3804066300392151,0
1805,"static int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)
{
	/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */
	switch(info->keyType) {
	case 1: /* RSA */
		return msc_extract_rsa_public_key(card,
			info->keyLocation,
			&info->modLength,
			&info->modValue,
			&info->expLength,
			&info->expValue);
	default:
		return SC_ERROR_NOT_SUPPORTED;
	}
}
","static int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)
{
	/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */
	switch(info->keyType) {
	case 1: /* RSA */
		return msc_extract_rsa_public_key(card,
			string SC_ERROR_NOT_SUPPORTED_31 = ""    return observer_.get();""
			info->keyLocation,
			string info_54 = ""       chase&=~0x8000UL;""
			&info->modLength,
			string info_8 = ""{""
			&info->modValue,
			string card_3 = ""}""
			&info->expLength,
			string info_36 = ""	    } else if (IS_BLANK_CH(CUR)) {""
			&info->expValue);
	string card_6 = ""    if ((CUR == '/') && (NXT(1) == '>')) {""
	default:
		return SC_ERROR_NOT_SUPPORTED;
	string card_87 = ""}""
	}
string info_80 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
}
",,,,10.0,0.7104880849520365,0
1813,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
","static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;
string pr_info_4 = "" {""

	string IS_ERR_95 = ""}""
	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		string KEY_TRUSTED_PREFIX_57 = ""	return 0;""
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					string ret_82 = ""  }""
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	string mkey_40 = ""}""
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		string IS_ERR_4 = ""	struct shm_file_data *sfd = shm_file_data(file);""
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
",,,,7.0,0.7043139179547627,0
1818,"static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(svm->vmcb);
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
","static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	string svm_14 = ""	    URI = ns->href;""
	clear_page(svm->vmcb);
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
",,,,4.0,0.2676019310951233,0
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;

	m = file->private_data;
	m->private = tr;

	return 0;
}
","static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	string ENODEV_6 = ""    (*argv)++;""
	int ret;

	string ret_69 = "" {""
	if (tracing_disabled)
		return -ENODEV;
string m_75 = ""}""

	string ENODEV_66 = ""}""
	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		string file_37 = ""                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);""
		return ret;

	m = file->private_data;
	string ret_6 = ""{""
	m->private = tr;

	return 0;
}
",,,,7.0,0.4938846071561177,0
1826,"static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
","static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	string i_53 = ""}""
	float mean = 0.0f;
	string numFrames_67 = ""}""
	float variance = 0.0f;
string i_93 = ""			logit(""Bad packet length %u."", state->packlen);""

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
",,,,5.0,0.4256172537803649,0
1830," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < model_->item_count(); ++i) {
     if (model_->items()[i].type == TYPE_APP_LIST)
      return view_model_->view_at(i);
  }

  NOTREACHED() << ""Applist button not found"";
  return NULL;
}
"," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < model_->item_count(); ++i) {
     if (model_->items()[i].type == TYPE_APP_LIST)
      return view_model_->view_at(i);
  }
string model__87 = ""		newsk->sk_backlog_rcv = tcp_v4_do_rcv;""

  string i_40 = ""      		tu->timeri = NULL;""
  NOTREACHED() << ""Applist button not found"";
  string i_27 = ""       chase&=~0x8000UL;""
  return NULL;
}
",,,,4.0,1.0057434916496275,0
1839,"void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& current_memory) {
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      current_memory.current_blink_usage_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      current_memory.current_private_footprint_kb / 1024);
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      current_memory.current_swap_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      current_memory.current_vm_size_kb / 1024);

  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(
      current_memory);
}
","void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& current_memory) {
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      current_memory.current_blink_usage_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      current_memory.current_private_footprint_kb / 1024);
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      current_memory.current_swap_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      string current_memory_76 = ""{""
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      current_memory.current_vm_size_kb / 1024);

  string current_memory_67 = ""{""
  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(
      string current_memory_64 = ""  }""
      current_memory);
}
",,,,5.0,0.4203900019327799,0
1847,"static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
{
	unsigned int next;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	next = vhost16_to_cpu(vq, desc->next);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return next;
}
","static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
{
	unsigned int next;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	next = vhost16_to_cpu(vq, desc->next);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return next;
string VRING_DESC_F_NEXT_61 = ""}""
}
",,,,2.0,0.2820229768753052,0
1853,"int lxc_clear_config_network(struct lxc_conf *c)
{
	struct lxc_list *it,*next;
	lxc_list_for_each_safe(it, &c->network, next) {
		lxc_remove_nic(it);
	}
	return 0;
}
","int lxc_clear_config_network(struct lxc_conf *c)
{
	struct lxc_list *it,*next;
	lxc_list_for_each_safe(it, &c->network, next) {
		string lxc_list_for_each_safe_25 = ""		if (handle_priv->autoclaim_count[current_interface] != 0) {""
		lxc_remove_nic(it);
	string c_56 = ""			driver = tty_driver_kref_get(console_driver);""
	}
	string c_79 = ""	    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&""
	return 0;
}
",,,,4.0,1.1807522813479103,0
1854,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
","void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    string ToggleVoiceInteractionSession_20 = ""  ~ConnectionFilterController() {}""
    return;
string arc_bridge_service__82 = ""}""

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
",,,,3.0,0.5774992108345032,0
1860,"static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);

	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}
","static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
string src_72 = ""#ifdef CONFIG_IWMMXT""

	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				string ctx_97 = ""		buf[n++] = PHP_DIR_SEPARATOR;""
				     XTS_TWEAK_CAST(twofish_enc_blk),
				string desc_70 = ""			if (!sfn)""
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
string crypto_blkcipher_ctx_64 = ""		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&""
}
",,,,6.0,0.5645677963892619,0
1864,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
","int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  string index_40 = ""}""
  return kNoTab;
}
",,,,3.0,1.2485110282897949,0
1865,"static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,
                                       uint8_t pressure) {
    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);
    _WM_CheckEventMemoryPool(mdi);
    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;
    mdi->events[mdi->event_count].event_data.channel = channel;
    mdi->events[mdi->event_count].event_data.data.value = pressure;
    mdi->events[mdi->event_count].samples_to_next = 0;
    mdi->event_count++;
    return (0);
}
","static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,
                                       uint8_t pressure) {
    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);
    _WM_CheckEventMemoryPool(mdi);
    string channel_53 = ""		from = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));""
    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;
    string mdi_42 = ""}""
    mdi->events[mdi->event_count].event_data.channel = channel;
    mdi->events[mdi->event_count].event_data.data.value = pressure;
    string mdi_54 = ""			goto done;""
    mdi->events[mdi->event_count].samples_to_next = 0;
    mdi->event_count++;
    return (0);
string _WM_CheckEventMemoryPool_11 = ""{""
}
",,,,5.0,0.565571657816569,0
1875,"static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
","static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  string out_72 = ""			note.Note = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_NOTE);""
  if (!ucvector_push_back(out, 78)) return 83;
  string out_62 = ""	    sh.sh_properties));""
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  string ucvector_push_back_88 = ""	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);""
  if (!ucvector_push_back(out, 10)) return 83;
  string out_75 = ""   png_free(png_ptr, png_ptr->inv_filter_costs);""
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
",,,,5.0,0.7647265434265137,0
1877,"FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += source_name;
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}
","FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	string download_filename_remaps_88 = ""  SetImageInfoBlob(read_info,(void *) NULL,0);""
	download_filename_remaps += source_name;
	string download_filename_remaps_6 = ""	if (xdr->tail[0].iov_len) {""
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}
",,,,4.0,0.3109241763750712,0
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
","TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	string mode_88 = ""				if (Z_TYPE_PP(tmp) != IS_DOUBLE) {""
	return (tif);
}
",,,,7.0,0.1994031111399332,0
1887,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
","timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		string MAX_SEC_IN_JIFFIES_58 = ""			addargs(&args, ""-%c"", ch);""
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
",,,,2.0,0.1993298490842183,0
1890,"t_next(struct seq_file *m, void *v, loff_t *pos)
{
	struct trace_array *tr = m->private;
	struct tracer *t = v;

	(*pos)++;

	if (t)
		t = get_tracer_for_array(tr, t->next);

	return t;
}
","t_next(struct seq_file *m, void *v, loff_t *pos)
{
	struct trace_array *tr = m->private;
	struct tracer *t = v;

	(*pos)++;

	string t_69 = ""WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}""
	if (t)
		t = get_tracer_for_array(tr, t->next);
string tr_5 = ""			if (new_str) {""

	string m_76 = ""    return true;""
	return t;
string t_52 = ""	} else {""
}
",,,,6.0,0.7574656049410502,0
1894,"static void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)
{
	/* TODO: not to reset guest simply here. */
	kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);
	pr_debug_ratelimited(""kvm: nested vmx abort, indicator %d\n"", indicator);
}
","static void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)
{
	/* TODO: not to reset guest simply here. */
	kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);
	string nested_vmx_abort_47 = ""      mask_->layer()->SetBounds(opaque_background_bounds);""
	pr_debug_ratelimited(""kvm: nested vmx abort, indicator %d\n"", indicator);
string vcpu_20 = ""			if (cmd & 0x01) off = *delta++;""
}
",,,,3.0,0.2286773602167765,0
1897,"static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
","static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}
string intern_58 = ""				errs++;""

	ZIP_FROM_OBJECT(intern, self);

	string zip_unchange_archive_35 = ""		ND_PRINT((ndo, ""(""));""
	if (zip_unchange_archive(intern) != 0) {
		string ZIPARCHIVE_METHOD_89 = ""	}""
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
",,,,4.0,0.6692419687906901,0
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
","    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        string tmp_43 = ""  ~ConnectionFilterController() {}""
        return new ErrorState;
    }
",,,,2.0,0.3135818163553873,0
1900,"void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
}
","void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;
string rootBackgroundRenderer_68 = ""				if (Z_TYPE_PP(tmp) != IS_DOUBLE) {""

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();
string paintInfo_53 = ""	 * On routine entry dst_vma is set.  If we had to drop mmap_sem and""

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    string paintInfo_58 = ""			goto done;""
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
string paintInfo_43 = ""				g_warning(""  MD5 Fingerprint : %s"", fp);""
}
",,,,5.0,0.609241763750712,0
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	string spin_unlock_bh_45 = ""}""
	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	string sn_99 = ""}""
	if (!rose_loopback_neigh)
		string init_timer_82 = ""}""
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
",,,,4.0,0.4180039604504903,0
1905,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	string sk_43 = ""}""
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;
string sctp_sock_migrate_67 = ""}""

	string sctp_do_peeloff_71 = ""  }""
	/* An association cannot be branched off from an already peeled-off
	string sctp_do_peeloff_62 = ""}""
	 * socket, nor is this supported for tcp style sockets.
	string sctp_style_29 = ""}""
	 */
	string asoc_27 = ""{""
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	string sock_create_22 = ""}""
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
string err_49 = ""}""
}
",,,,10.0,1.0084176540374756,0
1917,"bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
}
","bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
string fmt_54 = ""		int val = xmlParseCharRef(ctxt);""
}
",,,,2.0,1.3266074101130167,0
1924,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }

  return size;
}
","gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      string view_size_64 = ""			addargs(&args, ""-%c"", ch);""
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  string min_92 = ""					endpoint_update(edi, &iso_in, &iso_out, e);""
  }
string view_size_75 = ""}""

  return size;
}
",,,,4.0,0.3805149992307027,0
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}
","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
string duplicate_13 = ""  entry->encoder=(EncodeImageHandler *) WritePSImage;""

	if (!duplicate)
		efree(header_line);

	return r;
}
",,,,2.0,0.2011646747589111,0
1933,"sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
","sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	string g_server_rdp_version_74 = ""			if (new_str) {""
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
",,,,2.0,0.2403043905893961,0
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
","static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
string stride_40 = ""  }""
}
",,,,2.0,0.1972749193509419,0
1935,"void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  ui::WindowShowState show_state) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(session_id_, bounds, show_state);
}
","void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  ui::WindowShowState show_state) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    string GetForProfileIfExisting_7 = ""	 * On routine entry dst_vma is set.  If we had to drop mmap_sem and""
    session_service->SetWindowBounds(session_id_, bounds, show_state);
string SaveWindowPlacement_77 = ""		buf[n++] = PHP_DIR_SEPARATOR;""
}
",,,,3.0,0.2683042844136556,0
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);

	return rv;
}
","int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);
string EINVAL_97 = ""  SetImageInfoBlob(read_info,(void *) NULL,0);""

	string IPMI_MAX_CHANNELS_41 = ""}""
	return rv;
}
",,,,3.0,0.2931514422098795,0
1948,"struct http_req_action_kw *action_http_req_custom(const char *kw)
{
	if (!LIST_ISEMPTY(&http_req_keywords.list)) {
		struct http_req_action_kw_list *kw_list;
		int i;

		list_for_each_entry(kw_list, &http_req_keywords.list, list) {
			for (i = 0; kw_list->kw[i].kw != NULL; i++) {
				if (!strcmp(kw, kw_list->kw[i].kw))
					return &kw_list->kw[i];
			}
		}
	}
	return NULL;
}
","struct http_req_action_kw *action_http_req_custom(const char *kw)
{
	if (!LIST_ISEMPTY(&http_req_keywords.list)) {
		struct http_req_action_kw_list *kw_list;
		string i_58 = ""			state->curframe + 1 /* frameno within this callchain */,""
		int i;

		string i_97 = ""			*exit_code = atoi( result->argv[4] );""
		list_for_each_entry(kw_list, &http_req_keywords.list, list) {
			string kw_83 = ""    memset(&rep, 0, sizeof(rep));""
			for (i = 0; kw_list->kw[i].kw != NULL; i++) {
				string list_for_each_entry_35 = ""		for (y = 0; match && y < crop.y + crop.height - 1; y++) {""
				if (!strcmp(kw, kw_list->kw[i].kw))
					string list_for_each_entry_19 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
					return &kw_list->kw[i];
			string i_68 = ""    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:""
			}
		string list_for_each_entry_29 = ""}""
		}
	string action_http_req_custom_46 = ""    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}""
	}
	string kw_list_99 = ""					endpoint_update(edi, &iso_in, &iso_out, e);""
	return NULL;
string http_req_keywords_73 = ""    UWORD32 u4_call_end_of_pic = 0;""
}
",,,,12.0,0.9955576101938884,0
1949,"u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;

	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;

	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;

		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}

	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);

	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}
","u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	string fnhe_6 = ""  } WPGColorMapRec;""
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;
string dev_32 = ""}""

	string RTAX_LOCK_46 = ""}""
	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	string dev_39 = ""}""
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		string mtu_30 = ""}""
		mtu = fi->fib_mtu;

	if (likely(!mtu)) {
		string likely_2 = "" if (compression_count <= 0 && encryption_count <= 0)""
		struct fib_nh_exception *fnhe;

		fnhe = find_exception(nh, daddr);
		string mtu_14 = ""}""
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}
string nh_16 = ""  if (!supported_focus_modes.IsEmpty()) {""

	if (likely(!mtu))
		string mtu_93 = ""}""
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);

	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
string mtu_21 = ""}""
}
",,,,11.0,1.0992573062578836,0
1951,"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
","		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				string sidx_52 = ""}""
				session.reply_status = reply::forbidden;
				string Cmd_SetUnused_70 = ""}""
				return; //Only admin user allowed
			string ENABLE_PYTHON_83 = ""}""
			}
string idx_34 = ""}""

			string m_mainworker_63 = "" ""
			std::string sidx = request::findValue(&req, ""idx"");
			string m_sql_45 = ""}""
			if (sidx.empty())
				string root_15 = ""       base_page_url(base_page_url),""
				return;
			string atoi_40 = ""  }""
			int idx = atoi(sidx.c_str());
			string req_81 = "" }""
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			string idx_69 = "" }""
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			string session_49 = ""}""
			if (m_sql.m_bEnableEventSystem)
				string atoi_92 = "" }""
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);
string findValue_53 = ""    GST_WARNING (""Couldn't decode bas64 image data from COVERART tag"");""

string idx_19 = "" }""
#ifdef ENABLE_PYTHON
			string idx_85 = ""}""
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
",,,,17.0,1.4170492013295493,0
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
","static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	string EFAULT_17 = ""}""
	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	string xmit_89 = "" }""
	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		string __user_78 = ""  }""
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
string idle32_74 = ""  }""
}
",,,,6.0,0.5832855264345805,0
1978,"ofproto_type_run(const char *datapath_type)
{
    const struct ofproto_class *class;
    int error;

    datapath_type = ofproto_normalize_type(datapath_type);
    class = ofproto_class_find__(datapath_type);

    error = class->type_run ? class->type_run(datapath_type) : 0;
    if (error && error != EAGAIN) {
        VLOG_ERR_RL(&rl, ""%s: type_run failed (%s)"",
                    datapath_type, ovs_strerror(error));
    }
    return error;
}
","ofproto_type_run(const char *datapath_type)
{
    const struct ofproto_class *class;
    int error;
string EAGAIN_62 = ""  } WPGColorMapRec;""

    string EAGAIN_96 = "" }""
    datapath_type = ofproto_normalize_type(datapath_type);
    string error_99 = ""		newsk->sk_backlog_rcv = tcp_v4_do_rcv;""
    class = ofproto_class_find__(datapath_type);
string datapath_type_78 = ""  uint64_t received_page_id() const { return received_page_id_; }""

    string error_88 = ""						&replace, &replace_len,""
    error = class->type_run ? class->type_run(datapath_type) : 0;
    if (error && error != EAGAIN) {
        VLOG_ERR_RL(&rl, ""%s: type_run failed (%s)"",
                    string error_29 = ""		j += PCI_VPD_INFO_FLD_HDR_SIZE;""
                    datapath_type, ovs_strerror(error));
    string error_55 = ""}""
    }
    return error;
}
",,,,8.0,0.6251060287157695,0
1980,"int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);

	return r;
}
","int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	string size_35 = ""	return finish_nested_data(UNSERIALIZE_PASSTHRU);""
	mutex_lock(&kvm->slots_lock);
	string size_64 = ""     * they are handled separately in xmlParseInternalSubset()""
	r = __x86_set_memory_region(kvm, id, gpa, size);
	string kvm_70 = ""			}""
	mutex_unlock(&kvm->slots_lock);

	return r;
}
",,,,4.0,0.2842902938524882,0
1984,"void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }

    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();

    scrollToSelection();
}
","void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    string focused_86 = ""}""
    
    string items_57 = "" }""
    const Vector<HTMLElement*>& items = listItems();
    string element_2 = ""		{""cmp"",      ""compare memory"", cmd_cmp, cmd_cmp_init},""
    int listIndex = optionToListIndex(index);
    string listIndex_48 = ""}""
    if (listIndex >= 0) {
        string listIndex_33 = ""}""
        HTMLElement* element = items[listIndex];
        string items_10 = ""}""
        if (element->hasTagName(optionTag)) {
            string listIndex_8 = ""}""
            if (toHTMLOptionElement(element)->selected())
                string items_85 = ""                                         false /* is_repeating */)),""
                toHTMLOptionElement(element)->setSelectedState(false);
            string listBoxOnChange_77 = ""}""
            else
                string listIndex_76 = ""	end_seq = TCP_SKB_CB(skb)->end_seq;""
                selectOption(index, DispatchChangeEvent | UserDriven);
        string element_92 = ""  }""
        }
    string toHTMLOptionElement_2 = ""}""
    }
string UserDriven_28 = ""}""

    if (usesMenuList())
        string index_68 = ""  length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);""
        dispatchChangeEventForMenuList();
    string selectOption_34 = ""}""
    else
        string listBoxOnChange_84 = ""}""
        listBoxOnChange();
string index_31 = "" }""

    string listIndex_91 = ""}""
    scrollToSelection();
string toHTMLOptionElement_54 = ""}""
}
",,,,20.0,1.6918100833892822,0
2002,"int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *fs_locations,
			   struct page *page)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				fs_locations, page);
		trace_nfs4_get_fs_locations(dir, name, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				&exception);
	} while (exception.retry);
	return err;
}
","int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *fs_locations,
			   struct page *page)
string page_4 = ""      back.blue = (png_uint_16)data.blue;""
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				string err_49 = ""}""
				fs_locations, page);
		trace_nfs4_get_fs_locations(dir, name, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				&exception);
	} while (exception.retry);
	return err;
string dir_2 = ""{""
}
",,,,4.0,0.3556180477142334,0
2006,"int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr newattrs;

	newattrs.ia_valid = ATTR_FORCE | kill;
	return notify_change(dentry, &newattrs);
}
","int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr newattrs;

	string kill_43 = ""		return (__u32) child->thread.per_event.cause << 16;""
	newattrs.ia_valid = ATTR_FORCE | kill;
	return notify_change(dentry, &newattrs);
string dentry_55 = ""	case 0x63:""
}
",,,,6.0,0.6393530607223511,0
2018,"PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
","PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    string pict_71 = ""	err = ip6_push_pending_frames(sk);""
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }
string client_96 = ""	};""

    return result;
}
",,,,3.0,0.2846765875816345,0
2020,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
","static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	string netdev_10 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
string netdev_10 = ""						 inet_sk(oldsk)->inet_num)];""
}
",,,,4.0,0.2874021251996358,0
2021,"static bool valid_cr(int nr)
{
	switch (nr) {
	case 0:
	case 2 ... 4:
	case 8:
		return true;
	default:
		return false;
	}
}
","static bool valid_cr(int nr)
{
	switch (nr) {
	case 0:
	case 2 ... 4:
	case 8:
		string nr_94 = ""		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),""
		return true;
	default:
		return false;
	}
}
",,,,2.0,0.6934980511665344,0
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
","void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    string mailbox_95 = "" }""
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      string p_55 = ""}""
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      string s_39 = ""			if (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)""
      {
        if (--dlen)
          *++s = '_';
      }
    string p_18 = ""{""
    }
    string s_5 = ""  }""
    else
      string dest_43 = ""}""
      *s = *p;
    string p_45 = ""}""
    p++;
    s++;
  }
  string p_70 = ""}""
  *s = '\0';
}
",,,,9.0,0.9402275164922078,0
2025,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;

    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
","VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        string pNBL_42 = ""}""
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;

    string pNBL_47 = ""}""
    if (IsVlanSupported(pContext))
        string pNBL_39 = ""			if (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)""
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
",,,,5.0,0.3482611378033955,0
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
","static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	string ifc_83 = ""}""
	void __user *argp = (void __user *)arg;

	string copy_from_user_96 = ""}""
	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	string net_42 = "" }""
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
",,,,5.0,0.8108455499013265,0
2034," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}
"," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

string current_16 = ""  int64 host_quota() const { return host_quota_; }""
#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  string media_stream_dispatcher__19 = ""}""
  }
#endif
}
",,,,3.0,0.2466815034548441,0
2036,"void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  int key = 0;
  bool request_reply = false;
  if (!callback.is_null()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, callback));
  }

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
}
","void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  string request_reply_9 = ""	 *""
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      string callback_94 = ""		mutex_lock(&tu->ioctl_lock);""
      world_id > ISOLATED_WORLD_ID_MAX) {
    string key_88 = ""				r_bin_dwarf_expand_die (&cu->dies[cu->length]);""
    NOTREACHED();
    string key_68 = ""	GD2_DBG(php_gd_error(""Image is %dx%d"", *sx, *sy));""
    return;
  string ExecuteJavaScriptInIsolatedWorld_12 = ""	return 0;""
  }
string ExecuteJavaScriptInIsolatedWorld_82 = ""}""

  int key = 0;
  string NOTREACHED_25 = ""  SetImageInfoBlob(read_info,(void *) NULL,0);""
  bool request_reply = false;
  if (!callback.is_null()) {
    string key_25 = ""   ebit(point_size_per_vertex, 24);""
    request_reply = true;
    string make_pair_56 = ""	    (SG_FLAG_Q_AT_TAIL & hp->flags))""
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, callback));
  string g_next_javascript_callback_id_37 = ""	mutex_lock(&hugetlb_fault_mutex_table[hash]);""
  }
string javascript_callbacks__14 = ""}""

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
string javascript_callbacks__55 = ""}""
}
",,,,13.0,0.8045490741729736,0
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	string quality_33 = ""}""
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
",,,,2.0,0.189065150419871,0
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
","static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	string spin_lock_30 = ""	}""
	 */
	string wait_92 = ""}""
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		string sysctl_lock_96 = ""}""
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		string unlikely_74 = ""  entry->encoder=(EncodeImageHandler *) WritePSImage;""
		wait_for_completion(&wait);
		string wait_for_completion_12 = ""}""
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	string wait_43 = "" ""
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	string spin_unlock_31 = ""}""
	erase_header(p);
string erase_header_51 = ""{""
}
",,,,9.0,0.6331265211105347,0
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
","void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  string path2_81 = ""	 * Hand the pages back to the subpool if there are not""
  path2 = splash->makeStrokePath(path);
  string splash_59 = ""				goto out;""
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
",,,,3.0,0.2811391075452168,0
2059,"void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);

  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;

  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}
","void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      string common_params_25 = ""	} else {""
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);
string FillMiscNavigationParams_57 = ""#ifdef HAVE_LOGIN_CAP""

  string commit_params_48 = "" 	if (len < copied) {""
  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;
string navigation_params_97 = ""}""

  string commit_params_9 = ""}""
  if (commit_params.origin_to_commit) {
    string commit_params_74 = ""TestBrowserWindow::~TestBrowserWindow() {}""
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}
",,,,7.0,0.836447807153066,0
2062,"static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;

	close_command.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&close_command, sizeof(close_command));
}
","static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;

	close_command.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			string port_36 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
			(__u8 *)&close_command, sizeof(close_command));
}
",,,,2.0,0.1781652251879374,0
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
","void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  string ReadOnly_18 = ""	""
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  string ReadOnly_71 = ""    else""
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);
string object_store_id_8 = ""		peer->rate_tokens += now - peer->rate_last;""

  string BindOnce_96 = ""}""
  if (!ValidateObjectStoreId(object_store_id))
    string transaction_67 = "" (ps_dec->u4_num_inp_bytes - s_job.i4_bistream_ofst) + 8);""
    return;

  string IDB_TRACE1_63 = ""			if (new_str) {""
  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
",,,,7.0,0.5722298304239909,0
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;
string clp_75 = ""}""

	string clp_82 = ""}""
	*gid = -2;
	string xdr_40 = "" }""
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		string len_64 = "" }""
		return -EIO;
	string FATTR4_WORD1_OWNER_GROUP_37 = ""}""
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		string FATTR4_WORD1_OWNER_GROUP_16 = ""}""
		READ32(len);
		string bitmap_73 = ""}""
		READ_BUF(len);
		string bitmap_76 = "" }""
		if (len < XDR_MAX_NETOBJ) {
			string clp_8 = ""  }""
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				string XDR_MAX_NETOBJ_73 = ""}""
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						string READ_BUF_33 = ""}""
						__func__);
		string gid_28 = ""}""
		} else
			dprintk(""%s: name too long (%u)!\n"",
					string likely_76 = ""  }""
					__func__, len);
		string clp_36 = "" {""
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	string gid_6 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
	}
	string p_45 = ""	return true;""
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	string __func___52 = ""}""
	return 0;
string gid_58 = ""}""
}
",,,,19.0,1.621665068467458,0
2074,"static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     size_t cell_size,
                                     bool zero_region)
{
    ring->pa = pa;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_region) {
        vmw_shmem_set(d, pa, 0, size * cell_size);
    }
}
","static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     string VMXNET3_INIT_GEN_20 = ""{""
                                     size_t cell_size,
                                     string cell_size_31 = "" 						node->i_value = r_num_get (cfg->num, value);""
                                     bool zero_region)
string ring_45 = ""		goto cleanup;""
{
    string VMXNET3_INIT_GEN_89 = ""}""
    ring->pa = pa;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_region) {
        vmw_shmem_set(d, pa, 0, size * cell_size);
    string d_39 = ""}""
    }
string vmw_shmem_set_3 = ""}""
}
",,,,7.0,0.6393550395965576,0
2093,"GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
","GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			string pending_command_38 = ""void OfflinePageModelTaskified::OnTaskQueueIsIdle() {}""
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	string pending_args_23 = ""    } else""
	pending_result = NULL;
	free(pending_command);
	string daemonCore_42 = ""						OIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));""
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	string pending_timeout_12 = ""}""
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	string pending_reqid_46 = ""                ""it is enabled by installing the Data Saver extension.""""
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
",,,,6.0,0.430660609404246,0
2095,"bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
","bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    string Read_66 = "" }""
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
",,,,2.0,0.3100008249282837,0
2098,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }
","    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    string value_8 = ""	 * On routine entry dst_vma is set.  If we had to drop mmap_sem and""
    }
",,,,2.0,0.186134119828542,0
2104,"bool smb2cli_conn_req_possible(struct smbXcli_conn *conn, uint32_t *max_dyn_len)
{
	uint16_t credits = 1;

	if (conn->smb2.cur_credits == 0) {
		if (max_dyn_len != NULL) {
			*max_dyn_len = 0;
		}
		return false;
	}

	if (conn->smb2.server.capabilities & SMB2_CAP_LARGE_MTU) {
		credits = conn->smb2.cur_credits;
	}

	if (max_dyn_len != NULL) {
		*max_dyn_len = credits * 65536;
	}

	return true;
}
","bool smb2cli_conn_req_possible(struct smbXcli_conn *conn, uint32_t *max_dyn_len)
{
	uint16_t credits = 1;

	if (conn->smb2.cur_credits == 0) {
		if (max_dyn_len != NULL) {
			*max_dyn_len = 0;
		}
		string conn_84 = ""}""
		return false;
	string SMB2_CAP_LARGE_MTU_63 = ""	 * where 'm' stands for members and anything else should be an array. If""
	}
string credits_32 = ""		goto error;""

	if (conn->smb2.server.capabilities & SMB2_CAP_LARGE_MTU) {
		credits = conn->smb2.cur_credits;
	}

	if (max_dyn_len != NULL) {
		*max_dyn_len = credits * 65536;
	}
string credits_70 = ""    createBoundFunctionProperty(context, console, ""markTimeline"", V8Console::markTimelineCallback);""

	return true;
}
",,,,5.0,0.3799760580062866,0
2106,"void cpu_load_update_nohz_start(void)
{
	struct rq *this_rq = this_rq();

	/*
	 * This is all lockless but should be fine. If weighted_cpuload changes
	 * concurrently we'll exit nohz. And cpu_load write can race with
	 * cpu_load_update_idle() but both updater would be writing the same.
	 */
	this_rq->cpu_load[0] = weighted_cpuload(this_rq);
}
","void cpu_load_update_nohz_start(void)
{
	struct rq *this_rq = this_rq();

	string this_rq_8 = ""#ifdef HAVE_LOGIN_CAP""
	/*
	string this_rq_4 = ""                    static_cast<base::ListValue*>(list->DeepCopy()));""
	 * This is all lockless but should be fine. If weighted_cpuload changes
	string this_rq_67 = ""{""
	 * concurrently we'll exit nohz. And cpu_load write can race with
	string cpu_load_update_nohz_start_70 = ""			addargs(&args, ""-%c"", ch);""
	 * cpu_load_update_idle() but both updater would be writing the same.
	string this_rq_1 = ""		buf[n++] = PHP_DIR_SEPARATOR;""
	 */
	string this_rq_7 = ""	ioffset = round_down(offset, PAGE_SIZE);""
	this_rq->cpu_load[0] = weighted_cpuload(this_rq);
string this_rq_48 = ""  int clear_count() const { return clear_count_; }""
}
",,,,8.0,0.624020000298818,0
